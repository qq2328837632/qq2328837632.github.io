<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="线程概念线程概念：进程：有独立的 进程地址空间。有独立的 pcb。 分配资源的最小单位。线程：有独立的 pcb。没有独立的进程地址空间。 最小单位的执行。ps -Lf 进程 id —&gt; 线程号。LWP –》cpu 执行的最小单位（线程）。 ps -Lf 进程号 查看进程的线程    一个进程的线程越多，争取cpu的概率越大，但是会有峰值，然后降低 三级映射Linux内核线程实现原理类Unix">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux-线程">
<meta property="og:url" content="http://example.com/2023/06/18/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux-%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="肖汇林的博客">
<meta property="og:description" content="线程概念线程概念：进程：有独立的 进程地址空间。有独立的 pcb。 分配资源的最小单位。线程：有独立的 pcb。没有独立的进程地址空间。 最小单位的执行。ps -Lf 进程 id —&gt; 线程号。LWP –》cpu 执行的最小单位（线程）。 ps -Lf 进程号 查看进程的线程    一个进程的线程越多，争取cpu的概率越大，但是会有峰值，然后降低 三级映射Linux内核线程实现原理类Unix">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/Linux-%E7%BA%BF%E7%A8%8B/image-20230617155342436.png">
<meta property="og:image" content="http://example.com/2023/06/18/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux-%E7%BA%BF%E7%A8%8B/image-20230617155342436.png">
<meta property="og:image" content="http://example.com/Linux-%E7%BA%BF%E7%A8%8B/image-20230617160559643.png">
<meta property="og:image" content="http://example.com/2023/06/18/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux-%E7%BA%BF%E7%A8%8B/image-20230617160559643.png">
<meta property="article:published_time" content="2023-06-18T03:40:33.000Z">
<meta property="article:modified_time" content="2023-07-16T02:12:27.379Z">
<meta property="article:author" content="肖汇林">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/Linux-%E7%BA%BF%E7%A8%8B/image-20230617155342436.png">

<link rel="canonical" href="http://example.com/2023/06/18/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux-%E7%BA%BF%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Linux-线程 | 肖汇林的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖汇林的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/18/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux-%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux-线程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-18 11:40:33" itemprop="dateCreated datePublished" datetime="2023-06-18T11:40:33+08:00">2023-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-16 10:12:27" itemprop="dateModified" datetime="2023-07-16T10:12:27+08:00">2023-07-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h2><p>线程概念：<br>进程：有独立的 进程地址空间。有独立的 pcb。 分配资源的最小单位。<br>线程：有独立的 pcb。没有独立的进程地址空间。 最小单位的执行。<br>ps -Lf 进程 id —&gt; 线程号。LWP –》cpu 执行的最小单位（线程）。</p>
<p>ps -Lf 进程号 查看进程的线程</p>
<p><img src="/Linux-%E7%BA%BF%E7%A8%8B/image-20230617155342436.png" alt="image-20230617155342436"></p>
<img src="/2023/06/18/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux-%E7%BA%BF%E7%A8%8B/image-20230617155342436.png" class title="This is an test image">

<p>一个进程的线程越多，争取cpu的概率越大，但是会有峰值，然后降低</p>
<h2 id="三级映射"><a href="#三级映射" class="headerlink" title="三级映射"></a>三级映射</h2><h3 id="Linux内核线程实现原理"><a href="#Linux内核线程实现原理" class="headerlink" title="Linux内核线程实现原理"></a>Linux内核线程实现原理</h3><p>类Unix系统中，早期是没有“线程”概念的，80年代才引入，借助进程机制实现出了线程的概念。因此在这类系统中，进程和线程关系密切。</p>
<p>1.轻量级进程(light-weight process)，也有 PCB，创建线程使用的底层函数和进程一样，都是clone</p>
<p>2.从内核里看进程和线程是一样的，都有各自不同的PCB，但是PCB 中指向内存资源的三级页表是相同的</p>
<p>3.进程可以蜕变成线程。</p>
<p>4.线程可看做寄存器和栈的集合（寄存器在cpu上用来计算，栈帧开辟在栈上，目的是执行函数和存放局部变量，临时值和形参）</p>
<p>5.在 linux 下，线程是最小的执行单位;进程是最小的分配资源单位。</p>
<p>查看Lwp号:<code>ps -lf pid</code>查看指定线程的 lwp号。</p>
<h3 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB."></a>进程控制块PCB.</h3><p>我们知道,每个进程在内核中都有一个进程控制块(PCB)来维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。</p>
<p><code>/usr/src/linux-headers-3.16.0-30/include/linux/sched.h</code>.文件中可以查看struct task_struct结构体定义。其内部成员有很多，我们重点掌握以下部分即可:</p>
<ul>
<li>进程id。系统中每个进程有唯一的id，在c语言中用pid_t类型表示，其实就是一个非负整数。</li>
<li>进程的状态，有就绪、运行、挂起、停止等状态。</li>
<li>进程切换时需要保存和恢复的一些cPu寄存器。</li>
<li>描述虚拟地址空间的信息</li>
<li>描述控制终端的信息。</li>
<li>当前工作目录(Current Working Directory)。</li>
<li>umask掩码。</li>
<li>文件描述符表，包含很多指向file结构体的指针。</li>
<li>和信号相关的信息。</li>
<li>用户id和组id。</li>
<li>会话(Session）和进程组。</li>
<li>进程可以使用的资源上限（Resource Limit) 。</li>
</ul>
<p><img src="/Linux-%E7%BA%BF%E7%A8%8B/image-20230617160559643.png" alt="image-20230617160559643"></p>
<img src="/2023/06/18/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux-%E7%BA%BF%E7%A8%8B/image-20230617160559643.png" class title="This is an test image">

<p>如果是fork则另外一个进程，指向的就不一样。我们之前讲没有pcb，其实映射是需要经过pcb的。</p>
<h2 id="线程共享和非共享"><a href="#线程共享和非共享" class="headerlink" title="线程共享和非共享"></a>线程共享和非共享</h2><p>线程共享资源</p>
<ul>
<li>1.文件描述符表</li>
<li>2.每种信号的处理方式</li>
<li>3.当前工作目录</li>
<li>4.用户ID和组ID</li>
<li>5.内存地址空间(.text&#x2F;.data&#x2F;.bss&#x2F;heap&#x2F;共享库)，就是没有<strong>栈</strong>（栈执行函数和存放局部变量，临时值和形参）</li>
</ul>
<p>线程非共享资源</p>
<ul>
<li>1.线程id</li>
<li>2.处理器现场（寄存器计算的数据在处理器保存）和<strong>栈</strong>指针(内核栈)</li>
<li>3.独立的栈空间(用户空间栈)</li>
<li>4.errno变量</li>
<li>5.信号屏蔽字</li>
<li>6.调度优先级</li>
</ul>
<p>线程优、缺点：<br>优点:1.提高程序并发性	2.开销小 	3.数据通信、共享数据方便。（可以共享全局变量，不像父子进程，读时共享、写时复制）<br>缺点:1.库函数，不稳定	2.调试、编写困难、gdb不支持	3.对信号支持不好。</p>
<p>优点相对突出，缺点均不是硬伤。Linux下由于实现方法导致进程、线程差别不是很大。一般能使用线程就使用线程。</p>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pthread_t *tid是传出参数</span><br><span class="line">C++ 中的参数，既可以当做传入参数，也可以当做传出参数，具体要看参数的数据类型。</span><br><span class="line"></span><br><span class="line">非指针，非引用类型：一定是当做传入参数；</span><br><span class="line">指针，引用类型：既可以当做传入参数；也可以当做传出参数；甚至可以同时是传入参数，也是传出参数。</span><br><span class="line">其次要看对参数进行的操作：</span><br><span class="line"></span><br><span class="line">如果是只有读取，没有修改的，那就是传入参数，这时可以加上 const 限定符，以防不小心修改了参数。</span><br><span class="line">如果只有对参数进行写入，没有读取的，那就是当做传出参数的。</span><br><span class="line">如果对参数先进行了读取操作，然后又进行了写入操作，那么就是既当传入参数也当传出参数了。</span><br></pre></td></tr></table></figure>

<p><code>pthread_t pthread_self(void)</code>; 获取线程 id。 线程 id 是在进程地址空间内部，用来标识线程身份的 id 号。<br>    返回值：本线程 id<br>检查出错返回： 线程中。<br>    fprintf(stderr, “xxx error: %s\n”, strerror(ret));<br><code>int pthread_create(pthread_t *tid, const pthread_attr_t *attr, void *(*start_rountn)(void *), void *arg);</code> 创建子线程。<br>    参 1：传出参数，表新创建的子线程 id<br>    参 2：线程属性。传 NULL 表使用默认属性。<br>    参 3：子线程回调函数。创建成功，ptherad_create 函数返回时，该函数会被自动调用。<br>    参 4：参 3 的参数。没有的话，传 NULL<br>    返回值：成功：0<br>        失败：errno</p>
<p>下面这个例子，创建一个子线程去执行其他任务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;errno.h&gt;</span><br><span class="line">6. #include &lt;pthread.h&gt;</span><br><span class="line">7.</span><br><span class="line">8. void sys_err(const char *str)&#123;</span><br><span class="line">9. perror(str);</span><br><span class="line">10. exit(1);</span><br><span class="line">11. &#125;</span><br><span class="line">12.</span><br><span class="line">13. void *tfn(void *arg)&#123;</span><br><span class="line">14. printf(&quot;thread: pid = %d, tid = %lu\n&quot;, getpid(), pthread_self());</span><br><span class="line">15.</span><br><span class="line">16. return NULL;</span><br><span class="line">17. &#125;</span><br><span class="line">18.</span><br><span class="line">19. int main(int argc, char *argv[])&#123;</span><br><span class="line">20. pthread_t tid;</span><br><span class="line">21.</span><br><span class="line">22. printf(&quot;main: pid = %d, tid = %lu\n&quot;, getpid(), pthread_self());</span><br><span class="line">23.</span><br><span class="line">24. int ret = pthread_create(&amp;tid, NULL, tfn, NULL);</span><br><span class="line">25. if (ret != 0) &#123;</span><br><span class="line">26. perror(&quot;pthread_create error&quot;);</span><br><span class="line">27. &#125;</span><br><span class="line">28.</span><br><span class="line">29. return 0;</span><br><span class="line">30. &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，子线程的打印信息并未出现。原因在于，主线程执行完之后，就销毁了整个进程的地址空间，于是子线程就无法打印。简单粗暴的方法就是让主线程睡 1 秒，等子线程执行。</p>
<h2 id="循环创建多个子线程"><a href="#循环创建多个子线程" class="headerlink" title="循环创建多个子线程"></a>循环创建多个子线程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;errno.h&gt;</span><br><span class="line">6. #include &lt;pthread.h&gt;</span><br><span class="line">7.</span><br><span class="line">8. void sys_err(const char *str)&#123;</span><br><span class="line">9. perror(str);</span><br><span class="line">10. exit(1);</span><br><span class="line">11. &#125;</span><br><span class="line">12.</span><br><span class="line">13. void *tfn(void *arg)&#123;</span><br><span class="line">14. int i = (int)arg;//int i = *((int *)arg)和(void *)&amp;i，子线程如果用地址传递 i，会去读取主线程里的 i 值，而主线程里的 i 是动态变化的，不固定。所以，应该采用值传递，不用指针传递。</span><br><span class="line"></span><br><span class="line">15. sleep(i);</span><br><span class="line">16. printf(&quot;--I&#x27;m %dth thread: pid = %d, tid = %lu\n&quot;,i+1, getpid(), pthread_self());</span><br><span class="line">17.</span><br><span class="line">18. return NULL;</span><br><span class="line">19. &#125;</span><br><span class="line">20.</span><br><span class="line">21. int main(int argc, char *argv[])&#123;</span><br><span class="line">22. int i;</span><br><span class="line">23. int ret;</span><br><span class="line">24. pthread_t tid;</span><br><span class="line">25.</span><br><span class="line">26. for(i=0;i&lt;5;i++)&#123;</span><br><span class="line">27. ret = pthread_create(&amp;tid, NULL, tfn, (void *)i);//(void *)&amp;i</span><br><span class="line">28. if (ret != 0) &#123;</span><br><span class="line">29. sys_err(&quot;pthread_create error&quot;);</span><br><span class="line">30. &#125;</span><br><span class="line">31. &#125;</span><br><span class="line">32. sleep(i);</span><br><span class="line">33. printf(&quot;I&#x27;m main, pid = %d, tid = %lu\n&quot;, getpid(), pthread_self());</span><br><span class="line">34.</span><br><span class="line">35. return 0;</span><br><span class="line">36. &#125;</span><br></pre></td></tr></table></figure>

<h2 id="pthread-exit-退出"><a href="#pthread-exit-退出" class="headerlink" title="pthread_exit 退出"></a>pthread_exit 退出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">void pthread_exit(void *retval); 退出当前线程。</span><br><span class="line">    retval：退出值。 无退出值时，NULL</span><br><span class="line">    exit(); 退出当前进程。</span><br><span class="line">    return: 返回到调用者那里去。</span><br><span class="line">    pthread_exit(): 退出当前线程。</span><br><span class="line">如果在回调函数里加一段代码：</span><br><span class="line">if(i == 2)</span><br><span class="line">	exit(0);</span><br><span class="line">看起来好像是退出了第三个子线程，然而运行时，发现后续的 4,5 也没了。这是因为，exit 是退出进程。</span><br><span class="line">一、修改一下，换成：</span><br><span class="line">if(i == 2)</span><br><span class="line">	return NULL;</span><br><span class="line">这样运行一下，发现后续线程不会凉凉，说明 return 是可以达到退出线程的目的。然而真正意义上，return 是返回到函数调用者那里去，线程并没有退出。</span><br><span class="line">二、再修改一下，再定义一个函数 func，直接返回那种</span><br><span class="line">void *func(void)&#123;</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line">if(i == 2)</span><br><span class="line">	func();</span><br><span class="line">运行，发现 1,2,3,4,5 线程都还在，说明没有达到退出目的。</span><br><span class="line">三、再次修改：</span><br><span class="line">void *func(void)&#123;</span><br><span class="line">	pthread_exit(NULL);</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line">if(i == 2)</span><br><span class="line">	func();</span><br><span class="line">编译运行，发现 3 没了，看起来很科学的样子。pthread_exit 表示将当前线程退出。放在函数里，还是直接调用，都可以。</span><br><span class="line">回到之前说的一个问题，由于主线程可能先于子线程结束，所以子线程的输出可能不会打印出来，当时是用主线程 sleep 等待子线程结束来解决的。现在就可以使用 pthread_exit 来解决了。方法就是将 return 0 替换为 pthread_exit，只退出当前线程，不会对其他线程造成影响。</span><br><span class="line">void pthread_exit(void *retval); 退出当前线程。</span><br><span class="line">    retval：退出值。 无退出值时，NULL</span><br><span class="line">    exit(); 退出当前进程。</span><br><span class="line">    return: 返回到调用者那里去。</span><br><span class="line">    pthread_exit(): 退出当前线程。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join"></a>pthread_join</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int pthread_join(pthread_t thread, void **retval); 阻塞 回收线程。</span><br><span class="line">	thread: 待回收的线程 id</span><br><span class="line">	retval：传出参数。 回收的那个线程的退出值。return</span><br><span class="line">线程异常解除，值为 -1。成功被 pthread_cancel() 杀死的线程，返回 -1.使用 pthead_join 回收。</span><br><span class="line">	返回值：成功：0</span><br><span class="line">	失败：errno</span><br></pre></td></tr></table></figure>

<p>下面这个是回收线程并获取子线程返回值的小例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;errno.h&gt;</span><br><span class="line">6. #include &lt;pthread.h&gt;</span><br><span class="line">7.</span><br><span class="line">8. struct thrd &#123;</span><br><span class="line">9. int var;</span><br><span class="line">10. char str[256];</span><br><span class="line">11. &#125;;</span><br><span class="line">12.</span><br><span class="line">13. void sys_err(const char *str)</span><br><span class="line">14. &#123;</span><br><span class="line">15. perror(str);</span><br><span class="line">16. exit(1);</span><br><span class="line">17. &#125;</span><br><span class="line">18.</span><br><span class="line">19. void *tfn(void *arg)</span><br><span class="line">20. &#123;</span><br><span class="line">21. struct thrd *tval;</span><br><span class="line">22.</span><br><span class="line">23. tval = malloc(sizeof(tval));</span><br><span class="line">24. tval-&gt;var = 100;</span><br><span class="line">25. strcpy(tval-&gt;str, &quot;hello thread&quot;);</span><br><span class="line">26.</span><br><span class="line">27. return (void *)tval;</span><br><span class="line">28. &#125;</span><br><span class="line">29.</span><br><span class="line">30. int main(int argc, char *argv[])</span><br><span class="line">31. &#123;</span><br><span class="line">32. pthread_t tid;</span><br><span class="line">33.</span><br><span class="line">34. struct thrd *retval;</span><br><span class="line">35.</span><br><span class="line">36. int ret = pthread_create(&amp;tid, NULL, tfn, NULL);</span><br><span class="line">37. if (ret != 0)</span><br><span class="line">38. sys_err(&quot;pthread_create error&quot;);</span><br><span class="line">39.</span><br><span class="line">40. //int pthread_join(pthread_t thread, void **retval);//void **retval同样是传出参数</span><br><span class="line">41. ret = pthread_join(tid, (void **)&amp;retval);</span><br><span class="line">42. if (ret != 0)</span><br><span class="line">43. sys_err(&quot;pthread_join error&quot;);</span><br><span class="line">44.</span><br><span class="line">45. printf(&quot;child thread exit with var= %d, str= %s\n&quot;, retval-&gt;var, retval-&gt;str);</span><br><span class="line">46.</span><br><span class="line">47. pthread_exit(NULL);//由于主线程可能先于子线程结束，所以子线程的输出可能不会打印出来，当时是用主线程 sleep 等待子线程结束来解决的。现在就可以使用 pthread_exit 来解决了。方法就是将 return 0 替换为 pthread_exit，只退出当前线程，不会对其他线程造成影响。</span><br><span class="line">48.</span><br><span class="line">49. &#125;</span><br></pre></td></tr></table></figure>

<p>还可以改为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void *tfn(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    struct thrd *tval = (struct thrd *)arg;</span><br><span class="line">    tval-&gt;var = 100;</span><br><span class="line">    strcpy(tval-&gt;str,&quot;hello thread&quot;);</span><br><span class="line">    return (void *)tvai;//返回的是arg地址所以可以用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc,char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    pthread_t tid;</span><br><span class="line">    struct thrd arg;</span><br><span class="line">    struct thrd *retval;</span><br><span class="line">    int ret = pthread_create(&amp;tid，NULL, tfn，(void *)&amp;arg);</span><br><span class="line">    if (ret != 0)</span><br><span class="line">        sys_err( &quot;pthread_create error&quot;);</span><br><span class="line">    //int pthread_join(pthread_t thread, void **retval);</span><br><span class="line">    ret = pthread_join(tid,(void **)&amp;retval);</span><br><span class="line">    if (ret != 0)</span><br><span class="line">        sys_err( &quot;pthread_join error&quot;);</span><br><span class="line">    printf( &quot; child thread exit with var= %d，str= %s\n&quot;,retval-&gt;var,retval-&gt;str);</span><br><span class="line">    pthreadexit(NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="pthread-cancel-函数"><a href="#pthread-cancel-函数" class="headerlink" title="pthread_cancel 函数"></a>pthread_cancel 函数</h2><p><code>int pthread_cancel(pthread_t thread);</code> 杀死一个线程。 需要到达取消点（保存点），即需要调动系统内核<br>    thread: 待杀死的线程 id<br>    返回值：成功：0<br>    失败：errno<br>如果，子线程没有到达取消点， 那么 pthread_cancel 无效。<br>我们可以在程序中，手动添加一个取消点。使用 pthread_testcancel();<br>成功被 pthread_cancel() 杀死的线程，返回 -1.使用 pthead_join 回收。</p>
<p>小例子，主线程调用 pthread_cancel 杀死子线程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;errno.h&gt;</span><br><span class="line">6. #include &lt;pthread.h&gt;</span><br><span class="line">7.</span><br><span class="line">8.</span><br><span class="line">9. void *tfn(void *arg)&#123;</span><br><span class="line">10. while (1) &#123;</span><br><span class="line">11. printf(&quot;thread: pid = %d, tid = %lu\n&quot;, getpid(), pthread_self());</span><br><span class="line">12. sleep(1);</span><br><span class="line">13. &#125;</span><br><span class="line">14.</span><br><span class="line">15. return NULL;</span><br><span class="line">16. &#125;</span><br><span class="line">17.</span><br><span class="line">18. int main(int argc, char *argv[])&#123;</span><br><span class="line">19. pthread_t tid;</span><br><span class="line">20.</span><br><span class="line">21. int ret = pthread_create(&amp;tid, NULL, tfn, NULL);</span><br><span class="line">22. if (ret != 0) &#123;</span><br><span class="line">23. fprintf(stderr, &quot;pthread_create error:%s\n&quot;, strerror(ret));</span><br><span class="line">24. exit(1);</span><br><span class="line">25. &#125;</span><br><span class="line">26.</span><br><span class="line">27. printf(&quot;main: pid = %d, tid = %lu\n&quot;, getpid(), pthread_self());</span><br><span class="line">28.</span><br><span class="line">29. sleep(5);</span><br><span class="line">30.</span><br><span class="line">31. ret = pthread_cancel(tid); // 终止线程</span><br><span class="line">32. if (ret != 0) &#123;</span><br><span class="line">33. fprintf(stderr, &quot;pthread_cancel error:%s\n&quot;, strerror(ret));</span><br><span class="line">34. exit(1);</span><br><span class="line">35. &#125;</span><br><span class="line">36.</span><br><span class="line">37. while (1);</span><br><span class="line">38.</span><br><span class="line">39. pthread_exit((void *)0);//由于主线程可能先于子线程结束，所以子线程的输出可能不会打印出来，当时是用主线程 sleep 等待子线程结束来解决的。现在就可以使用 pthread_exit 来解决了。方法就是将 return 0 替换为 pthread_exit，只退出当前线程，不会对其他线程造成影响。</span><br><span class="line">40. &#125;</span><br></pre></td></tr></table></figure>

<p>这里要注意一点，pthread_cancel 工作的必要条件是进入内核，如果 tfn 真的奇葩到没有进入内核， 则 pthread_cancel 不能杀死线程，此时需要手动设置取消点，就是 pthread_testcancel()</p>
<h2 id="检查出错返回"><a href="#检查出错返回" class="headerlink" title="检查出错返回"></a>检查出错返回</h2><p>int pthread_detach(pthread_t thread); 设置线程分离<br>    thread: 待分离的线程 id<br>    返回值：成功：0<br>    失败：errno</p>
<p>下面这个例子，使用 detach 分离线程，照理来说，分离后的线程会自动回收：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;errno.h&gt;</span><br><span class="line">6. #include &lt;pthread.h&gt;</span><br><span class="line">7.</span><br><span class="line">8.</span><br><span class="line">9. void *tfn(void *arg)</span><br><span class="line">10. &#123;</span><br><span class="line">11. printf(&quot;thread: pid = %d, tid = %lu\n&quot;, getpid(), pthread_self());</span><br><span class="line">12.</span><br><span class="line">13. return NULL;</span><br><span class="line">14. &#125;</span><br><span class="line">15.</span><br><span class="line">16. int main(int argc, char *argv[])</span><br><span class="line">17. &#123;</span><br><span class="line">18. pthread_t tid;</span><br><span class="line">19.</span><br><span class="line">20. int ret = pthread_create(&amp;tid, NULL, tfn, NULL);</span><br><span class="line">21. if (ret != 0) &#123;</span><br><span class="line">22. perror(&quot;pthread_create error&quot;);</span><br><span class="line">23. &#125;</span><br><span class="line">24. ret = pthread_detach(tid); // 设置线程分离` 线程终止,会自动清理 pcb,无需回收</span><br><span class="line">25. if (ret != 0) &#123;</span><br><span class="line">26. perror(&quot;pthread_detach error&quot;);</span><br><span class="line">27. &#125;</span><br><span class="line">28.</span><br><span class="line">29. sleep(1);</span><br><span class="line">30.</span><br><span class="line">31. ret = pthread_join(tid, NULL);</span><br><span class="line">32. printf(&quot;join ret = %d\n&quot;, ret);</span><br><span class="line">33. if (ret != 0) &#123;</span><br><span class="line">34. perror(&quot;pthread_join error&quot;);</span><br><span class="line">35. &#125;</span><br><span class="line">36.</span><br><span class="line">37. printf(&quot;main: pid = %d, tid = %lu\n&quot;, getpid(), pthread_self());</span><br><span class="line">38.</span><br><span class="line">39. pthread_exit((void *)0);</span><br><span class="line">40. &#125;</span><br></pre></td></tr></table></figure>

<p>这里，问题出现了，join 出错了，但是没打印错误原因。之前的 perror 方法检查线程错误是有 问题的。应该使用 strerror，修改代码如下，因为perror方法是底层的一个全局变量，线程不能用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">20. int ret = pthread_create(&amp;tid, NULL, tfn, NULL);</span><br><span class="line">21. if (ret != 0) &#123;</span><br><span class="line">22. fprintf(stderr, &quot;pthread_create error: %s\n&quot;, strerror(ret));//stderr,直接输出到终端</span><br><span class="line">23. exit(1);</span><br><span class="line">24. &#125;</span><br></pre></td></tr></table></figure>

<p>出错，是因为线程分离后，系统会自动回收资源，用 pthread_join 去回收已经被系统 回收的线程，那个线程号就是无效参数。</p>
<p><code>pthread_join()</code>和<code>pthread_detach()</code>是用于管理线程资源的两种方式，但它们的作用是不同的。</p>
<ul>
<li><code>pthread_join(thread, status)</code>函数会将主线程阻塞，直到指定的线程 <code>thread</code> 终止。一旦目标线程终止，调用线程将从阻塞状态返回，并可以获取目标线程的退出状态信息。通过这种方式，<code>pthread_join()</code>可以实现对子线程的资源回收和同步等待操作。</li>
<li><code>pthread_detach(thread)</code>函数则是将指定的线程 <code>thread</code> 设置为分离状态，从而使得线程结束后自动释放其相关资源，包括线程栈空间和线程描述符等。相当于告诉系统不需要进行显式的资源回收操作，由系统自动回收资源。</li>
</ul>
<p>所以，虽然<code>pthread_join()</code>和<code>pthread_detach()</code>都能起到资源回收的作用，它们的使用场景和效果略有差异。<code>pthread_join()</code>适用于需要等待线程执行完毕并获取其返回状态的情况，而<code>pthread_detach()</code>适用于不关心线程返回状态，只希望在线程结束后自动回收资源的情况</p>
<h2 id="进程和线程控制原语对比"><a href="#进程和线程控制原语对比" class="headerlink" title="进程和线程控制原语对比"></a>进程和线程控制原语对比</h2><p>线程控制原语 			进程控制原语<br>pthread_create() 		fork();<br>pthread_self() 			getpid();<br>pthread_exit() 			exit(); 	&#x2F; return &#x2F;&#x2F;exit实际是退出进程，无论在哪个线程都会将整个进程都退出，return是退回到上一次调用的地方，所有只有都在主函数调用的时候效果一样。<br>pthread_join() 			wait()&#x2F;waitpid()<br>pthread_cancel() 		kill()<br>pthread_detach()</p>
<h2 id="线程属性设置分离线程"><a href="#线程属性设置分离线程" class="headerlink" title="线程属性设置分离线程"></a>线程属性设置分离线程</h2><p>线程属性：<br>设置分离属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pthread_attr_t attr 创建一个线程属性结构体变量</span><br><span class="line">pthread_attr_init(&amp;attr); 初始化线程属性</span><br><span class="line">pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED); 设置线程属性为分离态</span><br><span class="line">pthread_create(&amp;tid, &amp;attr, tfn, NULL); 借助修改后的 设置线程属性 创建为分离态的新线程</span><br><span class="line">pthread_attr_destroy(&amp;attr); 销毁线程属性</span><br></pre></td></tr></table></figure>

<p>调整线程状态，使线程创建出来就是分离态，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;errno.h&gt;</span><br><span class="line">6. #include &lt;pthread.h&gt;</span><br><span class="line">7.</span><br><span class="line">8.</span><br><span class="line">9. void *tfn(void *arg)</span><br><span class="line">10. &#123;</span><br><span class="line">11. printf(&quot;thread: pid = %d, tid = %lu\n&quot;, getpid(), pthread_self());</span><br><span class="line">12.</span><br><span class="line">13. return NULL;</span><br><span class="line">14. &#125;</span><br><span class="line">15.</span><br><span class="line">16. int main(int argc, char *argv[])</span><br><span class="line">17. &#123;</span><br><span class="line">18. pthread_t tid;</span><br><span class="line">19.</span><br><span class="line">20. pthread_attr_t attr;</span><br><span class="line">21.</span><br><span class="line">22. int ret = pthread_attr_init(&amp;attr);</span><br><span class="line">23. if (ret != 0) &#123;</span><br><span class="line">24. fprintf(stderr, &quot;attr_init error:%s\n&quot;, strerror(ret));</span><br><span class="line">25. exit(1);</span><br><span class="line">26. &#125;</span><br><span class="line">27.</span><br><span class="line">28. ret = pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED); // 设置线程属性为 分离属性</span><br><span class="line">29. if (ret != 0) &#123;</span><br><span class="line">30. fprintf(stderr, &quot;attr_setdetachstate error:%s\n&quot;, strerror(ret));</span><br><span class="line">31. exit(1);</span><br><span class="line">32. &#125;</span><br><span class="line">33.</span><br><span class="line">34. ret = pthread_create(&amp;tid, &amp;attr, tfn, NULL);</span><br><span class="line">35. if (ret != 0) &#123;</span><br><span class="line">36. perror(&quot;pthread_create error&quot;);</span><br><span class="line">37. &#125;</span><br><span class="line">38.</span><br><span class="line">39. ret = pthread_attr_destroy(&amp;attr);</span><br><span class="line">40. if (ret != 0) &#123;</span><br><span class="line">41. fprintf(stderr, &quot;attr_destroy error:%s\n&quot;, strerror(ret));</span><br><span class="line">42. exit(1);</span><br><span class="line">43. &#125;</span><br><span class="line">44.</span><br><span class="line">45. ret = pthread_join(tid, NULL);</span><br><span class="line">46. if (ret != 0) &#123;</span><br><span class="line">47. fprintf(stderr, &quot;pthread_join error:%s\n&quot;, strerror(ret));</span><br><span class="line">48. exit(1);</span><br><span class="line">49. &#125;</span><br><span class="line">50.</span><br><span class="line">51. printf(&quot;main: pid = %d, tid = %lu\n&quot;, getpid(), pthread_self());</span><br><span class="line">52.</span><br><span class="line">53. pthread_exit((void *)0);</span><br><span class="line">54. &#125;</span><br></pre></td></tr></table></figure>

<p>pthread_join 报错，说明线程已经自动回收，设置分离成功</p>
<h2 id="线程使用注意事项"><a href="#线程使用注意事项" class="headerlink" title="线程使用注意事项"></a>线程使用注意事项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.主线程退出其他线程不退出，主线程应调用`pthread_exit`</span><br><span class="line">2.避免僵尸线程。</span><br><span class="line">`pthread_joine`</span><br><span class="line">`pthread_detach`</span><br><span class="line">`pthread_create`	指定分离属性</span><br><span class="line">join线程可能在join函数返回前就释放完自己的所有内存资源，所以不应当返回被回收线程楼中的值;</span><br><span class="line">3. malloc和mmap申请的内存可以被其他线程释放</span><br><span class="line">4.应避免在多线程模型中调用fork，除非马上exec，子进程中只有调用fork 的线程存在，其他线程在子进程中均pthread_exit</span><br><span class="line">5.信号的复杂语义很难和多线程共存，应避免在多线程引入信号机制,因为信号处理是同概率的，每一个的mask是不同的，但是未决信号集是一样的，所有才能在信号来时都会主动处理。</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/06/15/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux-%E4%BF%A1%E5%8F%B7/" rel="prev" title="Linux-信号">
      <i class="fa fa-chevron-left"></i> Linux-信号
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/06/20/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux-%E9%94%81/" rel="next" title="Linux-锁">
      Linux-锁 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">线程概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E7%BA%A7%E6%98%A0%E5%B0%84"><span class="nav-number">2.</span> <span class="nav-text">三级映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">2.1.</span> <span class="nav-text">Linux内核线程实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97PCB"><span class="nav-number">2.2.</span> <span class="nav-text">进程控制块PCB.</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%92%8C%E9%9D%9E%E5%85%B1%E4%BA%AB"><span class="nav-number">3.</span> <span class="nav-text">线程共享和非共享</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">创建线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E5%88%9B%E5%BB%BA%E5%A4%9A%E4%B8%AA%E5%AD%90%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.</span> <span class="nav-text">循环创建多个子线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pthread-exit-%E9%80%80%E5%87%BA"><span class="nav-number">6.</span> <span class="nav-text">pthread_exit 退出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pthread-join"><span class="nav-number">7.</span> <span class="nav-text">pthread_join</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pthread-cancel-%E5%87%BD%E6%95%B0"><span class="nav-number">8.</span> <span class="nav-text">pthread_cancel 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E5%87%BA%E9%94%99%E8%BF%94%E5%9B%9E"><span class="nav-number">9.</span> <span class="nav-text">检查出错返回</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8E%9F%E8%AF%AD%E5%AF%B9%E6%AF%94"><span class="nav-number">10.</span> <span class="nav-text">进程和线程控制原语对比</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E5%88%86%E7%A6%BB%E7%BA%BF%E7%A8%8B"><span class="nav-number">11.</span> <span class="nav-text">线程属性设置分离线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">12.</span> <span class="nav-text">线程使用注意事项</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">肖汇林</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">76</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">肖汇林</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
