<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="进程和程序以及 CPU 相关进程：        程序：死的。只占用磁盘空间。 ——剧本。        进程；活的。运行起来的程序。占用内存、cpu 等系统资源。 ——戏。并发和并行：并行是宏观上并发，微观上串行    虚拟内存和物理内存映射关系   Linux下只有两级。从用户空间到内核空间进的时候，需要借助mmu，帮助完成全级切换。 pcb 进程控制块PCB 进程控制块：进程 id文件描述符">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux进程相关">
<meta property="og:url" content="http://example.com/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/index.html">
<meta property="og:site_name" content="肖汇林的博客">
<meta property="og:description" content="进程和程序以及 CPU 相关进程：        程序：死的。只占用磁盘空间。 ——剧本。        进程；活的。运行起来的程序。占用内存、cpu 等系统资源。 ——戏。并发和并行：并行是宏观上并发，微观上串行    虚拟内存和物理内存映射关系   Linux下只有两级。从用户空间到内核空间进的时候，需要借助mmu，帮助完成全级切换。 pcb 进程控制块PCB 进程控制块：进程 id文件描述符">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230601213825110.png">
<meta property="og:image" content="http://example.com/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230601213825110.png">
<meta property="og:image" content="http://example.com/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230601215722575.png">
<meta property="og:image" content="http://example.com/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230601215722575.png">
<meta property="og:image" content="http://example.com/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609212449400.png">
<meta property="og:image" content="http://example.com/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609212449400.png">
<meta property="og:image" content="http://example.com/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609212838706.png">
<meta property="og:image" content="http://example.com/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609212838706.png">
<meta property="og:image" content="http://example.com/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609212951089.png">
<meta property="og:image" content="http://example.com/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609212951089.png">
<meta property="og:image" content="http://example.com/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609213428815.png">
<meta property="og:image" content="http://example.com/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609213428815.png">
<meta property="og:image" content="http://example.com/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215110094.png">
<meta property="og:image" content="http://example.com/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215110094.png">
<meta property="og:image" content="http://example.com/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215242121.png">
<meta property="og:image" content="http://example.com/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215242121.png">
<meta property="og:image" content="http://example.com/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215316774.png">
<meta property="og:image" content="http://example.com/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215316774.png">
<meta property="og:image" content="http://example.com/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215813155.png">
<meta property="og:image" content="http://example.com/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215813155.png">
<meta property="og:image" content="http://example.com/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612214052445.png">
<meta property="og:image" content="http://example.com/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612214052445.png">
<meta property="og:image" content="http://example.com/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612215028041.png">
<meta property="og:image" content="http://example.com/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612215028041.png">
<meta property="og:image" content="http://example.com/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612214842946.png">
<meta property="og:image" content="http://example.com/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612214842946.png">
<meta property="og:image" content="http://example.com/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612214916095.png">
<meta property="og:image" content="http://example.com/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612214916095.png">
<meta property="og:image" content="http://example.com/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612215107477.png">
<meta property="og:image" content="http://example.com/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612215107477.png">
<meta property="og:image" content="http://example.com/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230614113240142.png">
<meta property="og:image" content="http://example.com/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230614113240142.png">
<meta property="article:published_time" content="2023-06-01T13:35:45.000Z">
<meta property="article:modified_time" content="2023-06-17T07:19:14.326Z">
<meta property="article:author" content="肖汇林">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230601213825110.png">

<link rel="canonical" href="http://example.com/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Linux进程相关 | 肖汇林的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖汇林的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux进程相关
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-01 21:35:45" itemprop="dateCreated datePublished" datetime="2023-06-01T21:35:45+08:00">2023-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-17 15:19:14" itemprop="dateModified" datetime="2023-06-17T15:19:14+08:00">2023-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="进程和程序以及-CPU-相关"><a href="#进程和程序以及-CPU-相关" class="headerlink" title="进程和程序以及 CPU 相关"></a>进程和程序以及 CPU 相关</h2><p>进程：<br>        程序：死的。只占用磁盘空间。 ——剧本。<br>        进程；活的。运行起来的程序。占用内存、cpu 等系统资源。 ——戏。<br>并发和并行：并行是宏观上并发，微观上串行</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230601213825110.png" alt="image-20230601213825110"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230601213825110.png" class title="This is an test image">

<h2 id="虚拟内存和物理内存映射关系"><a href="#虚拟内存和物理内存映射关系" class="headerlink" title="虚拟内存和物理内存映射关系"></a>虚拟内存和物理内存映射关系</h2><p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230601215722575.png" alt="image-20230601215722575"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230601215722575.png" class title="This is an test image">

<p>Linux下只有两级。从用户空间到内核空间进的时候，需要借助mmu，帮助完成全级切换。</p>
<h2 id="pcb-进程控制块"><a href="#pcb-进程控制块" class="headerlink" title="pcb 进程控制块"></a>pcb 进程控制块</h2><p>PCB 进程控制块：进程 id<br>文件描述符表<br>进程状态： 初始态、就绪态、运行态、挂起态、终止态。<br>进程工作目录位置<br>*umask 掩码 （进程的概念）<br>信号相关信息资源。<br>用户 id 和组 id<br>ps aux 返回结果里，第二列是进程 id</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609212449400.png" alt="image-20230609212449400"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609212449400.png" class title="This is an test image">

<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH 查看环境变量</span><br><span class="line">path 环境变量里记录了一系列的值，当运行一个可执行文件时，系统会去环境变量记录的位置里查</span><br><span class="line">找这个文件并执行。</span><br><span class="line">echo $TERM 查看终端</span><br><span class="line">echo $LANG 查看语言</span><br><span class="line">env 查看所有环境变量</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="fork-函数原理"><a href="#fork-函数原理" class="headerlink" title="fork 函数原理"></a>fork 函数原理</h2><p>fork 函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pid_t fork(void)</span><br><span class="line">创建子进程。父子进程各自返回。父进程返回子进程 pid。 子进程返回 0.</span><br><span class="line">getpid();getppid();</span><br><span class="line">循环创建 N 个子进程模型。 每个子进程标识自己的身份。</span><br></pre></td></tr></table></figure>

<p>父子进程相同： 刚 fork 后。 data 段、text 段、堆、栈、环境变量、全局变量、宿主目录位置、进程工作目录位 置、信号处理方式</p>
<p>父子进程不同： 进程 id、返回值、各自的父进程、进程创建时间、闹钟、未决信号集</p>
<p>父子进程共享： 读时共享、写时复制。———————— 全局变量。 1. 文件描述符 2. mmap 映射区</p>
<h2 id="fork-创建子进程"><a href="#fork-创建子进程" class="headerlink" title="fork 创建子进程"></a>fork 创建子进程</h2><p>下面是一个 fork 函数的例子，代码如下：</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609212838706.png" alt="image-20230609212838706"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609212838706.png" class title="This is an test image">

<p>fork 之前的代码，父子进程都有，但是只有父进程执行了，子进程没有执行，fork 之后的代码，父子进程都有机会执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">两个函数：</span><br><span class="line">pid_t getpid() 获取当前进程 id</span><br><span class="line">pid_t getppid() 获取当前进程的父进程 id</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609212951089.png" alt="image-20230609212951089"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609212951089.png" class title="This is an test image">

<h2 id="循环创建多个子进程"><a href="#循环创建多个子进程" class="headerlink" title="循环创建多个子进程"></a>循环创建多个子进程</h2><p>所以，直接用个 for 循环是要出事情的，因为子进程也会 fork 新的进程 这里，对调用 fork 的进程进行判定，只让父进程 fork 新的进程就行，代码如下：</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609213428815.png" alt="image-20230609213428815"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609213428815.png" class title="This is an test image">

<p>出现了问题：进程多了一个，而且不是按顺序来的。这里多出的一个，是父进程，因为父进程才有 i&#x3D;5 跳出循环这一步。所以，对父进程进行判定并处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(i=5)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;parent&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">	printf(&quot;..&quot;,i+1);</span><br></pre></td></tr></table></figure>

<p>现在还有两个问题，<br>    一个就是包括父进程在内的所有进程不是按顺序出现，多运行几次，发现是随机序列出现的。这<br>是要因为，对操作系统而言，这几个子进程几乎是同时出现的，它们和父进程一起争夺 cpu，谁抢到，<br>谁打印，所以出现顺序是随机的。<br>    第二问题就是终端提示符混在了输出里，这个是因为，loop_fork 是终端的子进程，一旦<br>loop_fork 执行完，终端就会打印提示符。就像之前没有子进程的程序，一旦执行完，就出现了终端<br>提示符。这里也就是这个道理，loop_fork 执行完了，终端提示符出现，然而 loop_fork 的子进程还<br>没执行完，所以输出就混在一起了。</p>
<p>通过 sleep 延时来解决父进程先结束这个问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(i=5)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;parent&quot;);</span><br><span class="line">	sleep(1);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">	printf(&quot;..&quot;,i+1);</span><br></pre></td></tr></table></figure>

<p>最后来解决子进程乱序输出的问题，解决方法很简单，让第 1 个子进程少等，第二个子进程多等， 后面子进程等待时间依次增加，这样就能实现有序输出。</p>
<h2 id="父子进程共享哪些内容"><a href="#父子进程共享哪些内容" class="headerlink" title="父子进程共享哪些内容"></a>父子进程共享哪些内容</h2><p>父子进程相同： 刚 fork 后。 data 段、text 段、堆、栈、环境变量、全局变量、宿主目录位置、进程工作目录位 置、信号处理方式</p>
<p>父子进程不同： 进程 id、返回值、各自的父进程、进程创建时间、闹钟、未决信号集</p>
<p>父子进程共享： 读时共享、写时复制。———————— 全局变量。如果只是读，则公用一个地址，写，则复制一份，不一起。</p>
<ol>
<li>文件描述符 2. mmap 映射区</li>
</ol>
<h2 id="父子进程-gdb-调试"><a href="#父子进程-gdb-调试" class="headerlink" title="父子进程 gdb 调试"></a>父子进程 gdb 调试</h2><p>gdb 调试：<br>设置父进程调试路径：set follow-fork-mode parent (默认)<br>设置子进程调试路径：set follow-fork-mode child<br>注意，一定要在 fork 函数调用之前设置才有效。</p>
<h2 id="exec-函数族"><a href="#exec-函数族" class="headerlink" title="exec 函数族"></a>exec 函数族</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">exec 函数族：</span><br><span class="line">使进程执行某一程序。成功无返回值，失败返回 -1</span><br><span class="line">int execlp(const char *file, const char *arg, ...); 借助 PATH 环境变量找寻待执</span><br><span class="line">行程序</span><br><span class="line">参 1： 程序名</span><br><span class="line">参 2： argv0</span><br><span class="line">参 3： argv1</span><br><span class="line">...： argvN</span><br><span class="line">哨兵：NULL</span><br><span class="line">int execl(const char *path, const char *arg, ...); 自己指定待执行程序路径。</span><br><span class="line">int execvp();</span><br><span class="line">ps ajx --&gt; pid ppid gid sid</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>fork创建子进程后执行的是和父进程相同的程序（但有可能执行不同的代码分支)，子进程往往要调用一种 exec函数以执行另一个程序。当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用exec并不创建新进程，所以调用exec前后该进程的id并未改变。<br>将当前进程的.text、.data替换为所要加载的程序的.text、.data，然后让进程从新的.text第一条指令开始执行，但进程ID不变，换核不换壳。即exec后面的子进程代码不执行了，因为进入了新的程序。</p>
<h3 id="execlp-和-ececl-函数"><a href="#execlp-和-ececl-函数" class="headerlink" title="execlp 和 ececl 函数"></a>execlp 和 ececl 函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int execlp(const char *file, const char *arg, …)</span><br><span class="line">成功，无返回，失败返回-1</span><br><span class="line">参数 1：要加载的程序名字，该函数需要配合 PATH 环境变量来使用，当 PATH 所有目录搜素后没</span><br><span class="line">有参数 1 则返回出错。</span><br><span class="line">该函数通常用来调用系统程序。如 ls、date、cp、cat 命令。</span><br><span class="line">execlp 这里面的 p，表示要借助环境变量来加载可执行文件</span><br></pre></td></tr></table></figure>

<p>示例代码，通过 execlp 让子进程去执行 ls 命令：</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215110094.png" alt="image-20230610215110094"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215110094.png" class title="This is an test image">

<p>只有父进程正确执行并输出了，子进程的 ls 输出有问题。 问题出在参数上，可变参数那里，是从 argv[0]开始计算的。 修改代码，就是将缺失的 argv[0]补上，然后让父进程延时 1 秒，保证终端提示符不和输出干扰。如 下：</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215242121.png" alt="image-20230610215242121"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215242121.png" class title="This is an test image">

<p>下面使用 execl 来让子程序调用自定义的程序。 int execl(const char *path, const char *arg, …) 这里要注意，和 execlp 不同的是，第一个参数是路径，不是文件名。 这个路径用相对路径和绝对路径都行。</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215316774.png" alt="image-20230610215316774"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215316774.png" class title="This is an test image">

<p>用 execl 也能执行 ls 这些，把路径给出来就行，但是这样麻烦，所以对于系统指令一般还是用 execlp</p>
<h2 id="exec-函数族特性"><a href="#exec-函数族特性" class="headerlink" title="exec 函数族特性"></a>exec 函数族特性</h2><p>写一个程序，使用 execlp 执行进程查看，并将结果输出到文件里。 要用到 open, execlp, dup2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">        int fd;</span><br><span class="line">        fd = open( &quot;ps.out&quot;, O_WRONLY|O_CREAT|O_TRUNC,0644);</span><br><span class="line">        if(fd &lt; 0)&#123;</span><br><span class="line">                perror(&quot;open ps.out error&quot;);</span><br><span class="line">                exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        dup2(fd,STDOUT_FILENO);</span><br><span class="line">        execlp(&quot;ps&quot;,&quot;ps&quot;,&quot;aux&quot;,NULL);</span><br><span class="line">        close(fd); //have no need to</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>exec 函数族一般规律： </p>
<p>exec 函数一旦调用成功，即执行新的程序，不返回。只有失败才返回，错误值-1，所以通常我们直接在 exec 函数调用后直接调用 perror()，和 exit()，无需 if 判断。</p>
<p>事实上，只有 execve 是真正的系统调用，其他 5 个函数最终都调用 execve，是库函数，所以 execve 在 man 手册第二节，其它函数在 man 手册第 3 节。</p>
<h2 id="孤儿进程和僵尸进程"><a href="#孤儿进程和僵尸进程" class="headerlink" title="孤儿进程和僵尸进程"></a>孤儿进程和僵尸进程</h2><p>孤儿进程：<br>父进程先于子进终止，子进程沦为“孤儿进程”，会被 init 进程领养。<br>僵尸进程：<br>子进程终止，父进程尚未对子进程进行回收，在此期间，子进程为“僵尸进程”。 kill 对其<br>无效。这里要注意，每个进程结束后都必然会经历僵尸态，时间长短的差别而已。<br>子进程终止时，子进程残留资源 PCB 存放于内核中，PCB 记录了进程结束原因，进程回收就是回<br>收 PCB。回收僵尸进程，得 kill 它的父进程，让孤儿院去回收它。</p>
<h2 id="wait-回收子进程"><a href="#wait-回收子进程" class="headerlink" title="wait 回收子进程"></a>wait 回收子进程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">wait 函数： 回收子进程退出资源， 阻塞回收任意一个。</span><br><span class="line">pid_t wait(int *status)</span><br><span class="line">参数：（传出） 回收进程的状态。</span><br><span class="line">返回值：成功： 回收进程的 pid</span><br><span class="line">失败： -1， errno</span><br><span class="line">函数作用 1： 阻塞等待子进程退出</span><br><span class="line">函数作用 2： 清理子进程残留在内核的 pcb 资源</span><br><span class="line">函数作用 3： 通过传出参数，得到子进程结束状态</span><br><span class="line">获取子进程正常终止值：</span><br><span class="line">WIFEXITED(status) --》 为真 --》调用 WEXITSTATUS(status) --》 得到 子进程 退出值。</span><br><span class="line">获取导致子进程异常终止信号：</span><br><span class="line">WIFSIGNALED(status) --》 为真 --》调用 WTERMSIG(status) --》 得到 导致子进程异常</span><br><span class="line">终止的信号编号。</span><br><span class="line">一个进程终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的 PCB 还保留着，内</span><br><span class="line">核在其中保存了一些信息：如果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程</span><br><span class="line">终止的信号是哪个。这个进程的父进程可以调用 wait 或者 waitpid 获取这些信息，然后彻底清除掉</span><br><span class="line">这个进程。我们知道一个进程的退出状态可以在 shell 中用特殊变量$？查看，因为 shell 是它的父</span><br><span class="line">进程，当它终止时，shell 调用 wait 或者 waitpid 得到它的退出状态，同时彻底清除掉这个进程。</span><br><span class="line">pid_t wait(int *status)</span><br><span class="line">其中 status 是传出参数</span><br></pre></td></tr></table></figure>

<p>下面这个例子，使用 wait 来阻塞回收子进程</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215813155.png" alt="image-20230610215813155"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215813155.png" class title="This is an test image">

<h2 id="获取子进程退出值和异常终止信号"><a href="#获取子进程退出值和异常终止信号" class="headerlink" title="获取子进程退出值和异常终止信号"></a>获取子进程退出值和异常终止信号</h2><p>获取子进程正常终止值：<br>WIFEXITED(status) –》 为真 –》调用 WEXITSTATUS(status) –》 得到 子进程 退出值。<br>获取导致子进程异常终止信号：<br>WIFSIGNALED(status) –》 为真 –》调用 WTERMSIG(status) –》 得到 导致子进程异常<br>终止的信号编号。</p>
<p>下面这个代码捕获程序异常终止的信号并打印：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;unistd.h&gt;</span><br><span class="line">4. #include &lt;sys/wait.h&gt;</span><br><span class="line">5.</span><br><span class="line">6. int main(void)</span><br><span class="line">7. &#123;</span><br><span class="line">8. pid_t pid, wpid;</span><br><span class="line">9. int status;</span><br><span class="line">10.</span><br><span class="line">11. pid = fork();</span><br><span class="line">12. if (pid == 0) &#123;</span><br><span class="line">13. printf(&quot;---child, my id= %d, going to sleep 10s\n&quot;, getpid());</span><br><span class="line">14. sleep(10);</span><br><span class="line">15. printf(&quot;-------------child die--------------\n&quot;);</span><br><span class="line">16. return 73;</span><br><span class="line">17. &#125; else if (pid &gt; 0) &#123;</span><br><span class="line">18. //wpid = wait(NULL); // 不关心子进程结束原因</span><br><span class="line">19. wpid = wait(&amp;status); // 如果子进程未终止,父进程阻塞在这个函数上</span><br><span class="line">20. if (wpid == -1) &#123;</span><br><span class="line">21. perror(&quot;wait error&quot;);</span><br><span class="line">22. exit(1);</span><br><span class="line">23. &#125;</span><br><span class="line">24. if (WIFEXITED(status)) &#123; //为真,说明子进程正常终止.</span><br><span class="line">25. printf(&quot;child exit with %d\n&quot;, WEXITSTATUS(status));</span><br><span class="line">26.</span><br><span class="line">27. &#125;</span><br><span class="line">28. if (WIFSIGNALED(status)) &#123; //为真,说明子进程是被信号终止.</span><br><span class="line">29.</span><br><span class="line">30. printf(&quot;child kill with signal %d\n&quot;, WTERMSIG(status));</span><br><span class="line">31. &#125;</span><br><span class="line">32.</span><br><span class="line">33. printf(&quot;------------parent wait finish: %d\n&quot;, wpid);</span><br><span class="line">34. &#125; else &#123;</span><br><span class="line">35. perror(&quot;fork&quot;);</span><br><span class="line">36. return 1;</span><br><span class="line">37. &#125;</span><br><span class="line">38.</span><br><span class="line">39. return 0;</span><br><span class="line">40. &#125;</span><br></pre></td></tr></table></figure>

<p>下面发送信号使得子进程异常退出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 id</span><br></pre></td></tr></table></figure>

<h2 id="waitpid-回收子进程"><a href="#waitpid-回收子进程" class="headerlink" title="waitpid 回收子进程"></a>waitpid 回收子进程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">waitpid 函数： 指定某一个进程进行回收。可以设置非阻塞。</span><br><span class="line">waitpid(-1, &amp;status, 0) == wait(&amp;status);</span><br><span class="line">	pid_t waitpid(pid_t pid, int *status, int options)</span><br><span class="line">	参数：</span><br><span class="line">		pid：指定回收某一个子进程 pid</span><br><span class="line">		&gt; 0: 待回收的子进程 pid</span><br><span class="line">		-1：任意子进程</span><br><span class="line">		0：同组的子进程。</span><br><span class="line">		status：（传出） 回收进程的状态。</span><br><span class="line">		options：WNOHANG 指定回收方式为，非阻塞。</span><br><span class="line">	返回值：</span><br><span class="line">		&gt; 0 : 表成功回收的子进程 pid</span><br><span class="line">		0 : 函数调用时， 参 3 指定了 WNOHANG， 并且，没有子进程结束。</span><br><span class="line">		-1: 失败。errno</span><br><span class="line">	一次 wait/waitpid 函数调用，只能回收一个子进程。上一个例子，父进程产生了 5 个子进程，wait 会随机回收一个，捡到哪个算哪个。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ps ajx –&gt; pid ppid gid sid</p>
<p>在演示回收指定子进程的代码时出了问题，这里问题原因在于指定子进程的 pid 传递。父进程里 的 pid 变量和子进程 pid 变量并不是同一个。子进程结束时，父进程的 pid 还是原来的 0。 </p>
<p>原来的代码没有使用 fork 的返回值，导致父进程没有得到指定回收子进程的 pid。</p>
<p>默认情况下，父进程 fork 出来的子进程都属于同一个组。</p>
<p>错误代码如下图所示，它不能回收指定的第 3 个子进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">1. //指定回收一个子进程错误示例</span><br><span class="line">2. #include &lt;stdio.h&gt;</span><br><span class="line">3. #include &lt;stdlib.h&gt;</span><br><span class="line">4. #include &lt;string.h&gt;</span><br><span class="line">5. #include &lt;unistd.h&gt;</span><br><span class="line">6. #include &lt;sys/wait.h&gt;</span><br><span class="line">7. #include &lt;pthread.h&gt;</span><br><span class="line">8.</span><br><span class="line">9. int main(int argc, char *argv[])</span><br><span class="line">10. &#123;</span><br><span class="line">11. int i;</span><br><span class="line">12. pid_t pid, wpid;</span><br><span class="line">13.</span><br><span class="line">14. for (i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">15. if (fork() == 0) &#123; // 循环期间, 子进程不 fork</span><br><span class="line">16. if (i == 2) &#123;</span><br><span class="line">17. pid = getpid();</span><br><span class="line">18. printf(&quot;------pid = %d\n&quot;, pid);</span><br><span class="line">19. &#125;</span><br><span class="line">20. break;</span><br><span class="line">21. &#125;</span><br><span class="line">22. &#125;</span><br><span class="line">23.</span><br><span class="line">24. if (5 == i) &#123; // 父进程, 从 表达式 2 跳出</span><br><span class="line">25. sleep(5);</span><br><span class="line">26.</span><br><span class="line">27. //wait(NULL); // 一次 wait/waitpid 函数调用,只能回收一个子进程.</span><br><span class="line">28. //wpid = waitpid(-1, NULL, WNOHANG); //回收任意子进程,没有结束的子进程,父进程直接返回 0</span><br><span class="line">29. //wpid = waitpid(pid, NULL, WNOHANG); //指定一个进程回收</span><br><span class="line">30.</span><br><span class="line">31. printf(&quot;------in parent , before waitpid, pid= %d\n&quot;, pid);</span><br><span class="line">32. wpid = waitpid(pid, NULL, 0); //指定一个进程回收，这里因为是进的父进程，没有pid的值</span><br><span class="line">33. if (wpid == -1) &#123;</span><br><span class="line">34. perror(&quot;waitpid error&quot;);</span><br><span class="line">35. exit(1);</span><br><span class="line">36. &#125;</span><br><span class="line">37. printf(&quot;I&#x27;m parent, wait a child finish : %d \n&quot;, wpid);</span><br><span class="line">38.</span><br><span class="line">39. &#125; else &#123; // 子进程, 从 break 跳出</span><br><span class="line">40. sleep(i);</span><br><span class="line">41. printf(&quot;I&#x27;m %dth child, pid= %d\n&quot;, i+1, getpid());</span><br><span class="line">42. &#125;</span><br><span class="line">43.</span><br><span class="line">44. return 0;</span><br><span class="line">45. &#125;</span><br></pre></td></tr></table></figure>

<p>这个代码错误如之前所述，父进程里的 pid 还是 0，因为父进程里没有获取指定子进程的 pid， 于是父进程里的 pid 还保持默认值。</p>
<p>下面是正确的示例，循环 fork 出 5 个子进程，并回收指定的子进程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;sys/wait.h&gt;</span><br><span class="line">6. #include &lt;pthread.h&gt;</span><br><span class="line">7.</span><br><span class="line">8.</span><br><span class="line">9. int main(int argc, char *argv[])</span><br><span class="line">10. &#123;</span><br><span class="line">11. int i;</span><br><span class="line">12. pid_t pid, wpid, tmpid;</span><br><span class="line">13.</span><br><span class="line">14. for (i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">15. pid = fork();</span><br><span class="line">16. if (pid == 0) &#123; // 循环期间, 子进程不 fork</span><br><span class="line">17. break;</span><br><span class="line">18. &#125;</span><br><span class="line">19. if (i == 2) &#123;//这里是父进程</span><br><span class="line">20. tmpid = pid;</span><br><span class="line">21. printf(&quot;--------pid = %d\n&quot;, tmpid);</span><br><span class="line">22. &#125;</span><br><span class="line">23. &#125;</span><br><span class="line">24.</span><br><span class="line">25. if (5 == i) &#123; // 父进程, 从 表达式 2 跳出</span><br><span class="line">26. // sleep(5);</span><br><span class="line">27.</span><br><span class="line">28. //wait(NULL); // 一次 wait/waitpid 函数调用,只能回收一个子进程.</span><br><span class="line">29. //wpid = waitpid(-1, NULL, WNOHANG); //回收任意子进程,没有结束的子进程,父进程直接返回 0</span><br><span class="line">30. //wpid = waitpid(tmpid, NULL, 0); //指定一个进程回收, 阻塞等待</span><br><span class="line">31. printf(&quot;i am parent , before waitpid, pid = %d\n&quot;, tmpid);</span><br><span class="line">32.</span><br><span class="line">33. //wpid = waitpid(tmpid, NULL, WNOHANG); //指定一个进程回收, 不阻塞</span><br><span class="line">34. wpid = waitpid(tmpid, NULL, 0); //指定一个进程回收, 阻塞回收</span><br><span class="line">35. if (wpid == -1) &#123;</span><br><span class="line">36. perror(&quot;waitpid error&quot;);</span><br><span class="line">37. exit(1);</span><br><span class="line">38. &#125;</span><br><span class="line">39. printf(&quot;I&#x27;m parent, wait a child finish : %d \n&quot;, wpid);</span><br><span class="line">40.</span><br><span class="line">41. &#125; else &#123; // 子进程, 从 break 跳出</span><br><span class="line">42. sleep(i);</span><br><span class="line">43. printf(&quot;I&#x27;m %dth child, pid= %d\n&quot;, i+1, getpid());</span><br><span class="line">44. &#125;</span><br><span class="line">45.</span><br><span class="line">46. return 0;</span><br><span class="line">47. &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>指定回收的第三个进程，就回收的第三个。这里实现由两种，一个是阻塞等待回收指定 进程，一个是非阻塞，但是用 sleep 延时父进程，以保证待回收的指定子进程已经执行结束。上面这 个代码使用的阻塞回收，这个方案的问题在于终端提示符会和输出混杂在一起。使用非阻塞回收 +延时的方法，这样终端提示符就不会混在输出里。</p>
<h2 id="waitpid-回收多个子进程"><a href="#waitpid-回收多个子进程" class="headerlink" title="waitpid 回收多个子进程"></a>waitpid 回收多个子进程</h2><p>一次 wait&#x2F;waitpid 函数调用，只能回收一个子进程。上一个例子，父进程产生了 5 个子进程， wait 会随机回收一个，捡到哪个算哪个</p>
<p>总结： wait、waitpid 一次调用，回收一个子进程。 想回收多个。while</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if (5 == i) &#123; // 父进程, 从 表达式 2 跳出</span><br><span class="line"> 	/* </span><br><span class="line"> 	while ((wpid = waitpid(-1, NULL, 0))) &#123; // 使用阻塞方式回收子进程</span><br><span class="line">		printf(&quot;wait child %d \n&quot;, wpid);</span><br><span class="line">	&#125;</span><br><span class="line">	*/</span><br><span class="line">	while ((wpid = waitpid(-1, NULL, WNOHANG)) != -1) &#123; //使用非阻塞方式,回收子进程.</span><br><span class="line">		if (wpid &gt; 0) &#123;</span><br><span class="line">			printf(&quot;wait child %d \n&quot;, wpid);</span><br><span class="line">		&#125; else if (wpid == 0) &#123;</span><br><span class="line">			sleep(1);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程间通信常见方式"><a href="#进程间通信常见方式" class="headerlink" title="进程间通信常见方式"></a>进程间通信常见方式</h2><p>IPC(InterProcess Communication)进程间通信</p>
<p>进程间通信的常用方式，特征： </p>
<p>管道：简单 </p>
<p>信号：开销小 </p>
<p>mmap 映射：非血缘关系进程间 </p>
<p>socket（本地套接字）：稳定</p>
<h2 id="管道的特质"><a href="#管道的特质" class="headerlink" title="管道的特质"></a>管道的特质</h2><p>管道：<br>实现原理： 内核借助环形队列机制，使用内核缓冲区实现。<br>特质； </p>
<p>​	1. 伪文件</p>
<ol start="2">
<li>管道中的数据只能一次读取。</li>
<li>数据在管道中，只能单向流动。</li>
</ol>
<p>局限性：</p>
<ol>
<li>自己写，不能自己读。</li>
<li>数据不可以反复读。</li>
<li>半双工通信。</li>
<li>血缘关系进程间可用。</li>
</ol>
<h2 id="管道的基本用法"><a href="#管道的基本用法" class="headerlink" title="管道的基本用法"></a>管道的基本用法</h2><p>pipe 函数： 创建，并打开管道。<br>    int pipe(int fd[2]);<br>        参数： fd[0]: 读端。<br>                    fd[1]: 写端。<br>        返回值： 成功： 0<br>                        失败： -1 errno</p>
<p>一个管道通信的示例，父进程往管道里写，子进程从管道读，然后打印读取的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;errno.h&gt;</span><br><span class="line">6. #include &lt;pthread.h&gt;</span><br><span class="line">7.</span><br><span class="line">8. void sys_err(const char *str)</span><br><span class="line">9. &#123;</span><br><span class="line">10. perror(str);</span><br><span class="line">11. exit(1);</span><br><span class="line">12. &#125;</span><br><span class="line">13.</span><br><span class="line">14. int main(int argc, char *argv[])</span><br><span class="line">15. &#123;</span><br><span class="line">16. int ret;</span><br><span class="line">17. int fd[2];</span><br><span class="line">18. pid_t pid;</span><br><span class="line">19.</span><br><span class="line">20. char *str = &quot;hello pipe\n&quot;;</span><br><span class="line">21. char buf[1024];</span><br><span class="line">22.</span><br><span class="line">23. ret = pipe(fd);</span><br><span class="line">24. if (ret == -1)</span><br><span class="line">25. sys_err(&quot;pipe error&quot;);</span><br><span class="line">26.</span><br><span class="line">27. pid = fork();</span><br><span class="line">28. if (pid &gt; 0) &#123;</span><br><span class="line">29. close(fd[0]); // 父进程关闭读段</span><br><span class="line">30. //sleep(3);</span><br><span class="line">31. write(fd[1], str, strlen(str));</span><br><span class="line">32. close(fd[1]);</span><br><span class="line">33. &#125; else if (pid == 0) &#123;</span><br><span class="line">34. close(fd[1]); // 子进程关闭写段</span><br><span class="line">35. ret = read(fd[0], buf, sizeof(buf));</span><br><span class="line">36. printf(&quot;child read ret = %d\n&quot;, ret);</span><br><span class="line">37. write(STDOUT_FILENO, buf, ret);</span><br><span class="line">38.</span><br><span class="line">39. close(fd[0]);</span><br><span class="line">40. &#125;</span><br><span class="line">41.</span><br><span class="line">42. return 0;</span><br><span class="line">43. &#125;</span><br></pre></td></tr></table></figure>

<h2 id="管道读写行为"><a href="#管道读写行为" class="headerlink" title="管道读写行为"></a>管道读写行为</h2><p>管道的读写行为：<br>读管道：</p>
<ol>
<li>管道有数据，read 返回实际读到的字节数。</li>
<li>管道无数据： 1）无写端，read 返回 0 （类似读到文件尾）<br> 2）有写端，read 阻塞等待。</li>
</ol>
<p>写管道：</p>
<ol>
<li>无读端， 异常终止。 （SIGPIPE 导致的）</li>
<li>有读端： 1） 管道已满， 阻塞等待<br> 2） 管道未满， 返回写出的字节个数。</li>
</ol>
<p>普通文件，目录，软链接，这三个要占磁盘空间 </p>
<p>管道，套接字，字符设备，块设备，不占磁盘空间，伪文件</p>
<p>磁盘访问需要open和read,内存访问用地址，即使用指针访问。</p>
<h2 id="父子进程-lswc-l"><a href="#父子进程-lswc-l" class="headerlink" title="父子进程 lswc-l"></a>父子进程 lswc-l</h2><p>练习：使用管道实现父子进程间通信，完成：ls | wc -l 假定父进程实现 ls，子进程实现 wc<br>ls 命令正常会将结果集写到 stdout，但现在会写入管道写端<br>wc -l 命令正常应该从 stdin 读取数据，但此时会从管道的读端读。<br>要用到 pipe dup2 exec<br>代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;errno.h&gt;</span><br><span class="line">6. #include &lt;pthread.h&gt;</span><br><span class="line">7.</span><br><span class="line">8. void sys_err(const char *str)</span><br><span class="line">9. &#123;</span><br><span class="line">10. perror(str);</span><br><span class="line">11. exit(1);</span><br><span class="line">12. &#125;</span><br><span class="line">13. int main(int argc, char *argv[])</span><br><span class="line">14. &#123;</span><br><span class="line">15. int fd[2];</span><br><span class="line">16. int ret;</span><br><span class="line">17. pid_t pid;</span><br><span class="line">18.</span><br><span class="line">19. ret = pipe(fd); // 父进程先创建一个管道,持有管道的读端和写端</span><br><span class="line">20. if (ret == -1) &#123;</span><br><span class="line">21. sys_err(&quot;pipe error&quot;);</span><br><span class="line">22. &#125;</span><br><span class="line">23.</span><br><span class="line">24. pid = fork(); // 子进程同样持有管道的读和写端</span><br><span class="line">25. if (pid == -1) &#123;</span><br><span class="line">26. sys_err(&quot;fork error&quot;);</span><br><span class="line">27. &#125;</span><br><span class="line">28. else if (pid &gt; 0) &#123; // 父进程 读, 关闭写端</span><br><span class="line">29. close(fd[1]);</span><br><span class="line">30. dup2(fd[0], STDIN_FILENO); // 重定向 stdin 到 管道的 读端</span><br><span class="line">31. execlp(&quot;wc&quot;, &quot;wc&quot;, &quot;-l&quot;, NULL); // 执行 wc -l 程序</span><br><span class="line">32. sys_err(&quot;exclp wc error&quot;);</span><br><span class="line">33. &#125;</span><br><span class="line">34. else if (pid == 0) &#123;</span><br><span class="line">35. close(fd[0]);</span><br><span class="line">36. dup2(fd[1], STDOUT_FILENO); // 重定向 stdout 到 管道写端</span><br><span class="line">37. execlp(&quot;ls&quot;, &quot;ls&quot;, NULL); // 子进程执行 ls 命令</span><br><span class="line">38. sys_err(&quot;exclp ls error&quot;);</span><br><span class="line">39. &#125;</span><br><span class="line">40.</span><br><span class="line">41. return 0;</span><br><span class="line">42. &#125;</span><br></pre></td></tr></table></figure>

<h2 id="兄弟进程间通信"><a href="#兄弟进程间通信" class="headerlink" title="兄弟进程间通信"></a>兄弟进程间通信</h2><p>练习题：兄弟进程间通信<br>兄：ls<br>弟：wc -l<br>父：等待回收子进程<br>要求，使用循环创建 N 个子进程模型创建兄弟进程，使用循环因子 i 标识，注意管道读写行为<br>测试：<br>是否允许，一个 pipe 有一个写端多个读端 可<br>是否允许，一个 pipe 有多个写端一个读端 可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;sys/wait.h&gt;</span><br><span class="line">5. #include &lt;unistd.h&gt;</span><br><span class="line">6. #include &lt;errno.h&gt;</span><br><span class="line">7. #include &lt;pthread.h&gt;</span><br><span class="line">8.</span><br><span class="line">9. void sys_err(const char *str)</span><br><span class="line">10. &#123;</span><br><span class="line">11. perror(str);</span><br><span class="line">12. exit(1);</span><br><span class="line">13. &#125;</span><br><span class="line">14. int main(int argc, char *argv[])</span><br><span class="line">15. &#123;</span><br><span class="line">16. int fd[2];</span><br><span class="line">17. int ret, i;</span><br><span class="line">18. pid_t pid;</span><br><span class="line">19.</span><br><span class="line">20. ret = pipe(fd);</span><br><span class="line">21. if (ret == -1) &#123;</span><br><span class="line">22. sys_err(&quot;pipe error&quot;);</span><br><span class="line">23. &#125;</span><br><span class="line">24.</span><br><span class="line">25. for(i = 0; i &lt; 2; i++) &#123; // 表达式 2 出口,仅限父进程使用</span><br><span class="line">26. pid = fork();</span><br><span class="line">27. if (pid == -1) &#123;</span><br><span class="line">28. sys_err(&quot;fork error&quot;);</span><br><span class="line">29. &#125;</span><br><span class="line">30. if (pid == 0) // 子进程,出口</span><br><span class="line">31. break;</span><br><span class="line">32. &#125;</span><br><span class="line">33.</span><br><span class="line">34. if (i == 2) &#123; // 父进程 . 不参与管道使用.</span><br><span class="line">35. close(fd[0]); // 关闭管道的 读端/写端.</span><br><span class="line">36. close(fd[1]);</span><br><span class="line">37.</span><br><span class="line">38. wait(NULL); // 回收子进程</span><br><span class="line">39. wait(NULL);</span><br><span class="line">40. &#125; else if (i == 0) &#123; // 哥哥</span><br><span class="line">41. close(fd[0]);</span><br><span class="line">42. dup2(fd[1], STDOUT_FILENO); // 重定向 stdout</span><br><span class="line">43. execlp(&quot;ls&quot;, &quot;ls&quot;, NULL);</span><br><span class="line">44. sys_err(&quot;exclp ls error&quot;);</span><br><span class="line">45. &#125; else if (i == 1) &#123; //弟弟</span><br><span class="line">46. close(fd[1]);</span><br><span class="line">47. dup2(fd[0], STDIN_FILENO); // 重定向 stdin</span><br><span class="line">48. execlp(&quot;wc&quot;, &quot;wc&quot;, &quot;-l&quot;, NULL);</span><br><span class="line">49. sys_err(&quot;exclp wc error&quot;);</span><br><span class="line">50. &#125;</span><br><span class="line">51.</span><br><span class="line">52. return 0;</span><br><span class="line">53. &#125;</span><br></pre></td></tr></table></figure>

<p>这个代码需要注意一点，父进程不使用管道，所以一定要关闭父进程的管道，保证数据单向流动。</p>
<h2 id="多个读写端操作管道和管道缓冲区大小"><a href="#多个读写端操作管道和管道缓冲区大小" class="headerlink" title="多个读写端操作管道和管道缓冲区大小"></a>多个读写端操作管道和管道缓冲区大小</h2><p>下面是一个父进程读，俩子进程写的例子，也就是一个读端多个写端。需要调控写入顺序才行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;unistd.h&gt;</span><br><span class="line">3. #include &lt;sys/wait.h&gt;</span><br><span class="line">4. #include &lt;string.h&gt;</span><br><span class="line">5. #include &lt;stdlib.h&gt;</span><br><span class="line">6.</span><br><span class="line">7. int main(void)</span><br><span class="line">8. &#123;</span><br><span class="line">9. pid_t pid;</span><br><span class="line">10. int fd[2], i, n;</span><br><span class="line">11. char buf[1024];</span><br><span class="line">12.</span><br><span class="line">13. int ret = pipe(fd);</span><br><span class="line">14. if(ret == -1)&#123;</span><br><span class="line">15. perror(&quot;pipe error&quot;);</span><br><span class="line">16. exit(1);</span><br><span class="line">17. &#125;</span><br><span class="line">18.</span><br><span class="line">19. for(i = 0; i &lt; 2; i++)&#123;</span><br><span class="line">20. if((pid = fork()) == 0)</span><br><span class="line">21. break;</span><br><span class="line">22. else if(pid == -1)&#123;</span><br><span class="line">23. perror(&quot;pipe error&quot;);</span><br><span class="line">24. exit(1);</span><br><span class="line">25. &#125;</span><br><span class="line">26. &#125;</span><br><span class="line">27.</span><br><span class="line">28. if (i == 0) &#123;</span><br><span class="line">29. close(fd[0]);</span><br><span class="line">30. write(fd[1], &quot;1.hello\n&quot;, strlen(&quot;1.hello\n&quot;));</span><br><span class="line">31. &#125; else if(i == 1) &#123;</span><br><span class="line">32. close(fd[0]);</span><br><span class="line">33. write(fd[1], &quot;2.world\n&quot;, strlen(&quot;2.world\n&quot;));</span><br><span class="line">34. &#125; else &#123;</span><br><span class="line">35. close(fd[1]); //父进程关闭写端,留读端读取数据</span><br><span class="line">36. sleep(1);</span><br><span class="line">37. n = read(fd[0], buf, 1024); //从管道中读数据</span><br><span class="line">38. write(STDOUT_FILENO, buf, n);</span><br><span class="line">39.</span><br><span class="line">40. for(i = 0; i &lt; 2; i++) //两个儿子 wait 两次</span><br><span class="line">41. wait(NULL);</span><br><span class="line">42. &#125;</span><br><span class="line">43.</span><br><span class="line">44. return 0;</span><br><span class="line">45. &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个例子需要注意，父进程必须等一下，不然可能俩子进程只写了一个，父进程就读完跑路了。 </p>
<p>管道大小，默认 4096</p>
<h2 id="命名管道-fifo-的创建和原理图"><a href="#命名管道-fifo-的创建和原理图" class="headerlink" title="命名管道 fifo 的创建和原理图"></a>命名管道 fifo 的创建和原理图</h2><p>管道的优劣：<br>优点：简单，相比信号，套接字实现进程通信，简单很多<br>缺点：1.只能单向通信，双向通信需建立两个管道<br> 2.只能用于有血缘关系的进程间通信。该问题后来使用 fifo 命名管道解决。</p>
<p>fifo 管道：可以用于无血缘关系的进程间通信。<br>命名管道： mkfifo<br>无血缘关系进程间通信：<br>读端，open fifo O_RDONLY<br>写端，open fifo O_WRONLY<br>fifo 操作起来像文件<br>下面的代码创建一个 fifo：</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612214052445.png" alt="image-20230612214052445"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612214052445.png" class title="This is an test image">

<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612215028041.png" alt="image-20230612215028041"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612215028041.png" class title="This is an test image">

<h2 id="fifo-实现非血缘关系进程间通信"><a href="#fifo-实现非血缘关系进程间通信" class="headerlink" title="fifo 实现非血缘关系进程间通信"></a>fifo 实现非血缘关系进程间通信</h2><p>下面这个例子，一个写 fifo，一个读 fifo，操作起来就像文件一样的：</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612214842946.png" alt="image-20230612214842946"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612214842946.png" class title="This is an test image">

<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612214916095.png" alt="image-20230612214916095"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612214916095.png" class title="This is an test image">

<p>编译执行，如图：<img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612215107477.png" alt="image-20230612215107477"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612215107477.png" class title="This is an test image">

<p>测试一个写端多个读端的时候，由于数据一旦被读走就没了，所以多个读端的并集才是写端的写 入数据。</p>
<h2 id="文件用于进程间通信"><a href="#文件用于进程间通信" class="headerlink" title="文件用于进程间通信"></a>文件用于进程间通信</h2><p>文件实现进程间通信： 打开的文件是内核中的一块缓冲区。多个无血缘关系的进程，可以同时访问该文件。</p>
<p><strong>socket套接字也是一种文件格式，和管道文件一样，它是一种伪文件</strong>，存在于内核的缓冲区中，大小不变，一直是0。</p>
<h2 id="mmap-函数原型"><a href="#mmap-函数原型" class="headerlink" title="mmap 函数原型"></a>mmap 函数原型</h2><p>磁盘访问需要open和read,内存访问用地址，即使用指针访问。</p>
<p>内核缓冲区是位于内核空间的一块特定内存区域，用于临时存储和处理数据。在 Linux 内核中，访问内核缓冲区通常需要使用相应的系统调用或函数。一种常见的方式是使用 I&#x2F;O 操作函数来读取或写入内核缓冲区的内容。例如，在文件 I&#x2F;O 中，我们可以使用系统调用 <code>read()</code> 和 <code>write()</code> 来分别从内核缓冲区读取数据到用户空间或将数据从用户空间写入到内核缓冲区。</p>
<p>存储映射 I&#x2F;O(Memory-mapped I&#x2F;O) 使一个磁盘文件与存储空间中的一个缓冲区相映射。于是从缓冲区中取数据，就相当于读文件中的相应字节。与此类似，将数据存入缓冲区，则相应的字节就自动写入文件。这样，就可在不使用 read 和 write 函数的情况下，使地址指针完成 I&#x2F;O 操作。<br>使用这种方法，首先应该通知内核，将一个指定文件映射到存储区域中。这个映射工作可以通过mmap 函数来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</span><br><span class="line">创建共享内存映射</span><br><span class="line">参数：</span><br><span class="line">    addr： 指定映射区的首地址。通常传 NULL，表示让系统自动分配</span><br><span class="line">    length：共享内存映射区的大小。（&lt;= 文件的实际大小）</span><br><span class="line">    prot： 共享内存映射区的读写属性。PROT_READ、PROT_WRITE、PROT_READ|PROT_WRITE</span><br><span class="line">    flags： 标注共享内存的共享属性。MAP_SHARED、MAP_PRIVATE</span><br><span class="line">    fd: 用于创建共享内存映射区的那个文件的 文件描述符。</span><br><span class="line">    offset：默认 0，表示映射文件全部。偏移位置。需是 4k 的整数倍。</span><br><span class="line">返回值：</span><br><span class="line">    成功：映射区的首地址。</span><br><span class="line">    失败：MAP_FAILED (void*(-1))， errno</span><br><span class="line">   flags 里面的 shared 意思是修改会反映到磁盘上</span><br><span class="line">     private 表示修改不反映到磁盘上</span><br><span class="line"> int munmap(void *addr, size_t length); 释放映射区。</span><br><span class="line">    addr：mmap 的返回值</span><br><span class="line">    length：大小</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>出现段错误，gdb然后run停止的地方就是段错误。</p>
<h2 id="mmap-建立映射区"><a href="#mmap-建立映射区" class="headerlink" title="mmap 建立映射区"></a>mmap 建立映射区</h2><p>下面这个示例代码，使用 mmap 创建一个映射区（共享内存），并往映射区里写入内容：</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230614113240142.png" alt="image-20230614113240142"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230614113240142.png" class title="This is an test image">

<h2 id="mmap-使用注意事项"><a href="#mmap-使用注意事项" class="headerlink" title="mmap 使用注意事项"></a>mmap 使用注意事项</h2><p>使用注意事项：</p>
<ol>
<li>用于创建映射区的文件大小为 0，实际指定非 0 大小创建映射区，出 “总线错误”。</li>
<li>用于创建映射区的文件大小为 0，实际制定 0 大小创建映射区， 出 “无效参数”。</li>
<li>用于创建映射区的文件读写属性为，只读。映射区属性为 读、写。 出 “无效参数”。</li>
<li>创建映射区，需要 read 权限。当访问权限指定为 “共享”MAP_SHARED 时， mmap 的读写权限，应该 &lt;&#x3D;文件的 open 权限。 只写不行。</li>
<li>文件描述符 fd，在 mmap 创建映射区完成即可关闭。后续访问文件，用 地址访问。</li>
<li>offset 必须是 4096 的整数倍。（MMU 映射的最小单位 4k ）</li>
<li>对申请的映射区内存，不能越界访问。</li>
<li>munmap 用于释放的 地址，必须是 mmap 申请返回的地址。</li>
<li>映射区访问权限为 “私有”MAP_PRIVATE, 对内存所做的所有修改，只在内存有效，不会反应到物理磁盘上。</li>
<li>映射区访问权限为 “私有”MAP_PRIVATE, 只需要 open 文件时，有读权限，用于创建映射区即可。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mmap 函数的保险调用方式：</span><br><span class="line">1. fd = open（&quot;文件名&quot;， O_RDWR）;</span><br><span class="line">2. mmap(NULL, 有效文件大小， PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);</span><br></pre></td></tr></table></figure>

<p>mmap 总结 </p>
<ol>
<li>创建映射区的过程中，隐含着一次对映射文件的读操作</li>
<li>当 MAP_SHARED 时，要求：映射区的权限应该&lt;&#x3D;文件打开的权限（出于对映射区的保护）。而MAP_PRIVATE 则无所谓，因为 mmap 中的权限是对内存的限制</li>
<li>映射区的释放与文件关闭无关。只要映射建立成功，文件可以立即关闭</li>
<li>特别注意，当映射文件大小为 0 时，不能创建映射区。所以：用于映射的文件必须要有实际大小！！mmap 使用时常常会出现总线错误，通常是由于共享文件存储空间大小引起的。如，400 字节大小的文件，在简历映射区时，offset4096 字节，则会报出总线错误</li>
<li>munmap 传入的地址一定是 mmap 返回的地址。坚决杜绝指针++操作,会改变地址，在指针本身上操作</li>
<li>文件偏移量必须为 4K 的整数倍</li>
<li>mmap 创建映射区出错概率非常高，一定要检查返回值，确保映射区建立成功再进行后续操作。</li>
</ol>
<h2 id="父子进程间-mmap-通信"><a href="#父子进程间-mmap-通信" class="headerlink" title="父子进程间 mmap 通信"></a>父子进程间 mmap 通信</h2><p>父子进程使用 mmap 进程间通信：<br>父进程 先 创建映射区。 <code>open（ O_RDWR） mmap( MAP_SHARED );</code><br>指定 MAP_SHARED 权限<br>fork() 创建子进程。<br>一个进程读， 另外一个进程写</p>
<p>下面这段代码，父子进程 mmap 通信，共享内存是一个 int 变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;unistd.h&gt;</span><br><span class="line">4. #include &lt;fcntl.h&gt;</span><br><span class="line">5. #include &lt;sys/mman.h&gt;</span><br><span class="line">6. #include &lt;sys/wait.h&gt;</span><br><span class="line">7.</span><br><span class="line">8. int var = 100;</span><br><span class="line">9.</span><br><span class="line">10. int main(void)</span><br><span class="line">11. &#123;</span><br><span class="line">12. int *p;</span><br><span class="line">13. pid_t pid;</span><br><span class="line">14.</span><br><span class="line">15. int fd;</span><br><span class="line">16. fd = open(&quot;temp&quot;, O_RDWR|O_CREAT|O_TRUNC, 0644);</span><br><span class="line">17. if(fd &lt; 0)&#123;</span><br><span class="line">18. perror(&quot;open error&quot;);</span><br><span class="line">19. exit(1);</span><br><span class="line">20. &#125;</span><br><span class="line">21. ftruncate(fd, 4);</span><br><span class="line">22.</span><br><span class="line">23. p = (int *)mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);</span><br><span class="line">24. //p = (int *)mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);</span><br><span class="line">25. if(p == MAP_FAILED)&#123; //注意:不是 p == NULL</span><br><span class="line">26. perror(&quot;mmap error&quot;);</span><br><span class="line">27. exit(1);</span><br><span class="line">28. &#125;</span><br><span class="line">29. close(fd); //映射区建立完毕,即可关闭文件</span><br><span class="line">30.</span><br><span class="line">31. pid = fork(); //创建子进程</span><br><span class="line">32. if(pid == 0)&#123;</span><br><span class="line">33. *p = 7000; // 写共享内存</span><br><span class="line">34. var = 1000;</span><br><span class="line">35. printf(&quot;child, *p = %d, var = %d\n&quot;, *p, var);</span><br><span class="line">36. &#125; else &#123;</span><br><span class="line">37. sleep(1);</span><br><span class="line">38. printf(&quot;parent, *p = %d, var = %d\n&quot;, *p, var); // 读共享内存</span><br><span class="line">39. wait(NULL);</span><br><span class="line">40.</span><br><span class="line">41. int ret = munmap(p, 4); //释放映射区</span><br><span class="line">42. if (ret == -1) &#123;</span><br><span class="line">43. perror(&quot;munmap error&quot;);</span><br><span class="line">44. exit(1);</span><br><span class="line">45. &#125;</span><br><span class="line">46. &#125;</span><br><span class="line">47.</span><br><span class="line">48. return 0;</span><br><span class="line">49. &#125;</span><br></pre></td></tr></table></figure>

<h2 id="无血缘关系进程间-mmap-通信"><a href="#无血缘关系进程间-mmap-通信" class="headerlink" title="无血缘关系进程间 mmap 通信"></a>无血缘关系进程间 mmap 通信</h2><p>无血缘关系进程间 mmap 通信：<br>两个进程 打开同一个文件，创建映射区。<br>指定 flags 为 MAP_SHARED。<br>一个进程写入，另外一个进程读出。<br>【注意】：无血缘关系进程间通信。mmap：数据可以重复读取。<br>fifo：数据只能一次读取。</p>
<p>下面是两个无血缘关系的通信代码，先是写进程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;sys/stat.h&gt;</span><br><span class="line">3. #include &lt;sys/types.h&gt;</span><br><span class="line">4. #include &lt;fcntl.h&gt;</span><br><span class="line">5. #include &lt;unistd.h&gt;</span><br><span class="line">6. #include &lt;stdlib.h&gt;</span><br><span class="line">7. #include &lt;sys/mman.h&gt;</span><br><span class="line">8. #include &lt;string.h&gt;</span><br><span class="line">9.</span><br><span class="line">10. struct STU &#123;</span><br><span class="line">11. int id;</span><br><span class="line">12. char name[20];</span><br><span class="line">13. char sex;</span><br><span class="line">14. &#125;;</span><br><span class="line">15.</span><br><span class="line">16. void sys_err(char *str)</span><br><span class="line">17. &#123;</span><br><span class="line">18. perror(str);</span><br><span class="line">19. exit(1);</span><br><span class="line">20. &#125;</span><br><span class="line">21.</span><br><span class="line">22. int main(int argc, char *argv[])</span><br><span class="line">23. &#123;</span><br><span class="line">24. int fd;</span><br><span class="line">25. struct STU student = &#123;10, &quot;xiaoming&quot;, &#x27;m&#x27;&#125;;</span><br><span class="line">26. char *mm;</span><br><span class="line">27.</span><br><span class="line">28. if (argc &lt; 2) &#123;</span><br><span class="line">29. printf(&quot;./a.out file_shared\n&quot;);</span><br><span class="line">30. exit(-1);</span><br><span class="line">31. &#125;</span><br><span class="line">32.</span><br><span class="line">33. fd = open(argv[1], O_RDWR | O_CREAT, 0664);</span><br><span class="line">34. ftruncate(fd, sizeof(student));</span><br><span class="line">35.</span><br><span class="line">36. mm = mmap(NULL, sizeof(student), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);</span><br><span class="line">37. if (mm == MAP_FAILED)</span><br><span class="line">38. sys_err(&quot;mmap&quot;);</span><br><span class="line">39.</span><br><span class="line">40. close(fd);</span><br><span class="line">41.</span><br><span class="line">42. while (1) &#123;</span><br><span class="line">43. memcpy(mm, &amp;student, sizeof(student));</span><br><span class="line">44. student.id++;</span><br><span class="line">45. sleep(1);</span><br><span class="line">46. &#125;</span><br><span class="line">47.</span><br><span class="line">48. munmap(mm, sizeof(student));</span><br><span class="line">49.</span><br><span class="line">50. return 0;</span><br><span class="line">51. &#125;</span><br></pre></td></tr></table></figure>

<p>然后是读进程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;sys/stat.h&gt;</span><br><span class="line">3. #include &lt;fcntl.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;stdlib.h&gt;</span><br><span class="line">6. #include &lt;sys/mman.h&gt;</span><br><span class="line">7. #include &lt;string.h&gt;</span><br><span class="line">8.</span><br><span class="line">9. struct STU &#123;</span><br><span class="line">10. int id;</span><br><span class="line">11. char name[20];</span><br><span class="line">12. char sex;</span><br><span class="line">13. &#125;;</span><br><span class="line">14.</span><br><span class="line">15. void sys_err(char *str)</span><br><span class="line">16. &#123;</span><br><span class="line">17. perror(str);</span><br><span class="line">18. exit(-1);</span><br><span class="line">19. &#125;</span><br><span class="line">20.</span><br><span class="line">21. int main(int argc, char *argv[])</span><br><span class="line">22. &#123;</span><br><span class="line">23. int fd;</span><br><span class="line">24. struct STU student;</span><br><span class="line">25. struct STU *mm;</span><br><span class="line">26.</span><br><span class="line">27. if (argc &lt; 2) &#123;</span><br><span class="line">28. printf(&quot;./a.out file_shared\n&quot;);</span><br><span class="line">29. exit(-1);</span><br><span class="line">30. &#125;</span><br><span class="line">31.</span><br><span class="line">32. fd = open(argv[1], O_RDONLY);</span><br><span class="line">33. if (fd == -1)</span><br><span class="line">34. sys_err(&quot;open error&quot;);</span><br><span class="line">35.</span><br><span class="line">36. mm = mmap(NULL, sizeof(student), PROT_READ, MAP_SHARED, fd, 0);</span><br><span class="line">37. if (mm == MAP_FAILED)</span><br><span class="line">38. sys_err(&quot;mmap error&quot;);</span><br><span class="line">39.</span><br><span class="line">40. close(fd);</span><br><span class="line">41.</span><br><span class="line">42. while (1) &#123;</span><br><span class="line">43. printf(&quot;id=%d\tname=%s\t%c\n&quot;, mm-&gt;id, mm-&gt;name, mm-&gt;sex);</span><br><span class="line">44. sleep(2);</span><br><span class="line">45. &#125;</span><br><span class="line">46. munmap(mm, sizeof(student));</span><br><span class="line">47.</span><br><span class="line">48. return 0;</span><br><span class="line">49. &#125;</span><br></pre></td></tr></table></figure>

<p>如图，一读一写，问题不大。 多个写端一个读端也没问题，打开多个写进程即可，完事儿读进程会读到所有写进程写入的内容。 这里要注意一个，内容被读走之后不会消失，所以如果读进程的读取时间间隔短，它会读到很多重复内容，就是因为写进程没来得及写入新内容。</p>
<h2 id="mmap-匿名映射区"><a href="#mmap-匿名映射区" class="headerlink" title="mmap 匿名映射区"></a>mmap 匿名映射区</h2><p>匿名映射：只能用于 血缘关系进程间通信。 </p>
<p><code>p = (int *)mmap(NULL, 40, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);</code></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/05/31/%E5%85%B3%E4%BA%8Evim%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/" rel="prev" title="关于vim的一些配置问题">
      <i class="fa fa-chevron-left"></i> 关于vim的一些配置问题
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/06/15/Linux-%E4%BF%A1%E5%8F%B7/" rel="next" title="Linux-信号">
      Linux-信号 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%A8%8B%E5%BA%8F%E4%BB%A5%E5%8F%8A-CPU-%E7%9B%B8%E5%85%B3"><span class="nav-number">1.</span> <span class="nav-text">进程和程序以及 CPU 相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%92%8C%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB"><span class="nav-number">2.</span> <span class="nav-text">虚拟内存和物理内存映射关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pcb-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="nav-number">3.</span> <span class="nav-text">pcb 进程控制块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">4.</span> <span class="nav-text">环境变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fork-%E5%87%BD%E6%95%B0%E5%8E%9F%E7%90%86"><span class="nav-number">5.</span> <span class="nav-text">fork 函数原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fork-%E5%88%9B%E5%BB%BA%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="nav-number">6.</span> <span class="nav-text">fork 创建子进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E5%88%9B%E5%BB%BA%E5%A4%9A%E4%B8%AA%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="nav-number">7.</span> <span class="nav-text">循环创建多个子进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9"><span class="nav-number">8.</span> <span class="nav-text">父子进程共享哪些内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B-gdb-%E8%B0%83%E8%AF%95"><span class="nav-number">9.</span> <span class="nav-text">父子进程 gdb 调试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exec-%E5%87%BD%E6%95%B0%E6%97%8F"><span class="nav-number">10.</span> <span class="nav-text">exec 函数族</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#execlp-%E5%92%8C-ececl-%E5%87%BD%E6%95%B0"><span class="nav-number">10.1.</span> <span class="nav-text">execlp 和 ececl 函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exec-%E5%87%BD%E6%95%B0%E6%97%8F%E7%89%B9%E6%80%A7"><span class="nav-number">11.</span> <span class="nav-text">exec 函数族特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-number">12.</span> <span class="nav-text">孤儿进程和僵尸进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wait-%E5%9B%9E%E6%94%B6%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="nav-number">13.</span> <span class="nav-text">wait 回收子进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%AD%90%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E5%80%BC%E5%92%8C%E5%BC%82%E5%B8%B8%E7%BB%88%E6%AD%A2%E4%BF%A1%E5%8F%B7"><span class="nav-number">14.</span> <span class="nav-text">获取子进程退出值和异常终止信号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#waitpid-%E5%9B%9E%E6%94%B6%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="nav-number">15.</span> <span class="nav-text">waitpid 回收子进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#waitpid-%E5%9B%9E%E6%94%B6%E5%A4%9A%E4%B8%AA%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="nav-number">16.</span> <span class="nav-text">waitpid 回收多个子进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E5%B8%B8%E8%A7%81%E6%96%B9%E5%BC%8F"><span class="nav-number">17.</span> <span class="nav-text">进程间通信常见方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%A1%E9%81%93%E7%9A%84%E7%89%B9%E8%B4%A8"><span class="nav-number">18.</span> <span class="nav-text">管道的特质</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%A1%E9%81%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">19.</span> <span class="nav-text">管道的基本用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%A1%E9%81%93%E8%AF%BB%E5%86%99%E8%A1%8C%E4%B8%BA"><span class="nav-number">20.</span> <span class="nav-text">管道读写行为</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B-lswc-l"><span class="nav-number">21.</span> <span class="nav-text">父子进程 lswc-l</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%84%E5%BC%9F%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">22.</span> <span class="nav-text">兄弟进程间通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA%E8%AF%BB%E5%86%99%E7%AB%AF%E6%93%8D%E4%BD%9C%E7%AE%A1%E9%81%93%E5%92%8C%E7%AE%A1%E9%81%93%E7%BC%93%E5%86%B2%E5%8C%BA%E5%A4%A7%E5%B0%8F"><span class="nav-number">23.</span> <span class="nav-text">多个读写端操作管道和管道缓冲区大小</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93-fifo-%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="nav-number">24.</span> <span class="nav-text">命名管道 fifo 的创建和原理图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fifo-%E5%AE%9E%E7%8E%B0%E9%9D%9E%E8%A1%80%E7%BC%98%E5%85%B3%E7%B3%BB%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">25.</span> <span class="nav-text">fifo 实现非血缘关系进程间通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%94%A8%E4%BA%8E%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">26.</span> <span class="nav-text">文件用于进程间通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mmap-%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="nav-number">27.</span> <span class="nav-text">mmap 函数原型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mmap-%E5%BB%BA%E7%AB%8B%E6%98%A0%E5%B0%84%E5%8C%BA"><span class="nav-number">28.</span> <span class="nav-text">mmap 建立映射区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mmap-%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">29.</span> <span class="nav-text">mmap 使用注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E9%97%B4-mmap-%E9%80%9A%E4%BF%A1"><span class="nav-number">30.</span> <span class="nav-text">父子进程间 mmap 通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E8%A1%80%E7%BC%98%E5%85%B3%E7%B3%BB%E8%BF%9B%E7%A8%8B%E9%97%B4-mmap-%E9%80%9A%E4%BF%A1"><span class="nav-number">31.</span> <span class="nav-text">无血缘关系进程间 mmap 通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mmap-%E5%8C%BF%E5%90%8D%E6%98%A0%E5%B0%84%E5%8C%BA"><span class="nav-number">32.</span> <span class="nav-text">mmap 匿名映射区</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">肖汇林</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">45</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">肖汇林</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
