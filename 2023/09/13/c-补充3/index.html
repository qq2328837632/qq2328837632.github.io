<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="静态类型和动态类型，静态绑定和动态绑定 静态类型：对象在声明时采用的类型，在编译期既已确定； 动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的； 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期； 动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；  非虚函数一般都是静态绑定，而虚函数都是动态绑定（如此才可实现多态">
<meta property="og:type" content="article">
<meta property="og:title" content="c++-补充3">
<meta property="og:url" content="http://example.com/2023/09/13/c-%E8%A1%A5%E5%85%853/index.html">
<meta property="og:site_name" content="肖汇林的博客">
<meta property="og:description" content="静态类型和动态类型，静态绑定和动态绑定 静态类型：对象在声明时采用的类型，在编译期既已确定； 动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的； 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期； 动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；  非虚函数一般都是静态绑定，而虚函数都是动态绑定（如此才可实现多态">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-09-13T09:01:39.000Z">
<meta property="article:modified_time" content="2023-10-25T07:48:36.005Z">
<meta property="article:author" content="肖汇林">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2023/09/13/c-%E8%A1%A5%E5%85%853/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>c++-补充3 | 肖汇林的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖汇林的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/13/c-%E8%A1%A5%E5%85%853/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          c++-补充3
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-13 17:01:39" itemprop="dateCreated datePublished" datetime="2023-09-13T17:01:39+08:00">2023-09-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-25 15:48:36" itemprop="dateModified" datetime="2023-10-25T15:48:36+08:00">2023-10-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="静态类型和动态类型，静态绑定和动态绑定"><a href="#静态类型和动态类型，静态绑定和动态绑定" class="headerlink" title="静态类型和动态类型，静态绑定和动态绑定"></a>静态类型和动态类型，静态绑定和动态绑定</h1><ul>
<li>静态类型：对象在声明时采用的类型，在编译期既已确定；</li>
<li>动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；</li>
<li>静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；</li>
<li>动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；</li>
</ul>
<p>非虚函数一般都是静态绑定，而虚函数都是动态绑定（如此才可实现多态 性）。 举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    /*virtual*/ void func() &#123; std::cout &lt;&lt; &quot;A::func()\n&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class B : public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void func() &#123; std::cout &lt;&lt; &quot;B::func()\n&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class C : public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void func() &#123; std::cout &lt;&lt; &quot;C::func()\n&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    C *pc = new C(); // pc的静态类型是它声明的类型C*，动态类型也是C*；</span><br><span class="line">    B *pb = new B(); // pb的静态类型和动态类型也都是B*；</span><br><span class="line">    A *pa = pc;      // pa的静态类型是它声明的类型A*，动态类型是pa所指向的对象pc的类型C*；</span><br><span class="line">    pa = pb;         // pa的动态类型可以更改，现在它的动态类型是B*，但其静态类型仍是声明时候的A*；</span><br><span class="line">    C *pnull = NULL; // pnull的静态类型是它声明的类型C*,没有动态类型，因为它指向了NULL；</span><br><span class="line"></span><br><span class="line">    pa-&gt;func();    // A::func() pa的静态类型永远都是A*，不管其指向的是哪个子类，都是直接调用A::func()；</span><br><span class="line">    pc-&gt;func();    // C::func() pc的动、静态类型都是C*，因此调用C::func()；</span><br><span class="line">    pnull-&gt;func(); // C::func() 不用奇怪为什么空指针也可以调用函数，因为这在编译期就确定了，和指针空不空没关系；</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果将A类中的virtual注释去掉，则运行结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pa-&gt;func(); //B::func() 因为有了virtual虚函数特性，pa的动态类型指向B*，因此先在B中查找，找到后直接调用；</span><br><span class="line">pc-&gt;func(); //C::func() pc的动、静态类型都是C*，因此也是先在C中查找；</span><br><span class="line">pnull-&gt;func(); //空指针异常，因为是func是virtual函数，因此对func的调用只能等到运行期才能确定，然后才发现pnull是空指针；</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，</p>
<ul>
<li>如果基类A中的func不是virtual函数，那么不论pa、pb、pc指向哪个子类对象，对func的调用都是在定义pa、pb、pc时的静态类型决定，早已在编译期确定了。</li>
<li>同样的空指针也能够直接调用no-virtual函数而不报错（这也说明一定要做空指针检查啊！），因此静态绑定不能实现多态；</li>
<li>如果func是虚函数，那所有的调用都要等到运行时根据其指向对象的类型才能确定，比起静态绑定自然是要有性能损失的，但是却能实现多态特性；</li>
</ul>
<p>另外，在动态绑定也即在virtual函数中，要注意默认参数的使用。当 缺省参数和virtual函数一起使用的时候一定要谨慎，不然出了问题怕是很难排查</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class E</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void func(int i = 0)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;E::func()\t&quot; &lt;&lt; i &lt;&lt; &quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class F : public E</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void func(int i = 1)override</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;F::func()\t&quot; &lt;&lt; i &lt;&lt; &quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test2()</span><br><span class="line">&#123;</span><br><span class="line">    F *pf = new F();</span><br><span class="line">    E *pe = pf;</span><br><span class="line">    pf-&gt;func(); // F::func() 1 正常，就该如此；</span><br><span class="line">    pe-&gt;func(); // F::func() 0 哇哦，这是什么情况，调用了子类的函数，却使用了基类中参数的默认值！</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    test2();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="指针加减计算"><a href="#指针加减计算" class="headerlink" title="指针加减计算"></a>指针加减计算</h1><p>指针加减本质是对其所指地址的移动，移动的步长跟指针的类型是有关系的，因此在涉及到指针加减运 算需要十分小心，加多或者减多都会导致指针指向一块未知的内存地址，如果再进行操作就会很危险。 举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> 	int *a, *b, c;</span><br><span class="line"> 	a = (int*)0x500;</span><br><span class="line"> 	b = (int*)0x520;</span><br><span class="line"> 	c = b - a;</span><br><span class="line"> 	printf(&quot;%d\n&quot;, c); // 8</span><br><span class="line"> 	a += 0x020;</span><br><span class="line"> 	c = b - a;</span><br><span class="line"> 	printf(&quot;%d\n&quot;, c); // -24</span><br><span class="line"> 	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先变量a和b都是以16进制的形式初始化，将它们转成10进制分别是1280（5<em>16^2&#x3D;1280）和 1312（5</em>16^2+2*16&#x3D;1312)， 那么它们的差值为32，也就是说a和b所指向的地址之间间隔32个位，但是 考虑到是int类型占4位，所以c的值为32&#x2F;4&#x3D;8.</p>
<p>a自增16进制0x20之后，其实际地址变为1280 + 2<em>16</em>4 &#x3D; 1408，（因为一个int占4位，所以要乘4），这 样它们的差值就变成了1312 - 1280 &#x3D; -96，所以c的值就变成了-96&#x2F;4 &#x3D; -24 遇到指针的计算，<strong>需要明确的是指针每移动一位，它实际跨越的内存间隔是指针类型的长度，建议都转 成10进制计算，计算结果除以类型长度取得结果</strong></p>
<h1 id="判断两个浮点数是否相等"><a href="#判断两个浮点数是否相等" class="headerlink" title="判断两个浮点数是否相等"></a>判断两个浮点数是否相等</h1><p>对两个浮点数判断大小和是否相等不能直接用&#x3D;&#x3D;来判断，会出错！明明相等的两个数比较反而是不相 等！对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值！浮点数与0的比较 也应该注意。与浮点数的表示方式有关。</p>
<p>在判断两个浮点数是否相等时，由于浮点数的内部表示方式以及浮点数运算的特性，直接使用相等运算符（<code>==</code>）进行比较可能会导致误差。</p>
<p>这是因为浮点数的内部二进制表示可能会存在舍入误差，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">float a = 0.1f + 0.1f + 0.1f;</span><br><span class="line">float b = 0.3f;</span><br><span class="line"></span><br><span class="line">if (a == b) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;相等&quot; &lt;&lt; endl;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    cout &lt;&lt; &quot;不相等&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，我们期望 <code>a</code> 和 <code>b</code> 的值相等，因为它们都是 0.3。然而，由于浮点数的内部二进制表示存在舍入误差，实际运行结果可能会输出 “不相等”。</p>
<p>为了解决这个问题，一种常用的方法是定义一个误差范围（epsilon），然后判断两个浮点数的绝对差是否小于该误差范围。如果绝对差小于等于 epsilon，那么认为两个浮点数是近似相等的。</p>
<p>下面是一个示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">bool areEqual(float a, float b, float epsilon = 1e-6) &#123;</span><br><span class="line">    return std::abs(a - b) &lt;= epsilon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    float a = 0.1f + 0.1f + 0.1f;</span><br><span class="line">    float b = 0.3f;</span><br><span class="line"></span><br><span class="line">    if (areEqual(a, b)) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;相等&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;不相等&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，我们定义了一个 <code>areEqual</code> 函数，用于判断两个浮点数是否近似相等。默认情况下，我们使用误差范围 <code>epsilon</code> 的值为 1e-6，你可以根据具体的需求调整这个值。</p>
<p>通过调用 <code>areEqual</code> 函数来比较 <code>a</code> 和 <code>b</code> 的值，输出结果应该是 “相等”。通过引入误差范围，可以避免由于浮点数的舍入误差而导致的比较结果错误。</p>
<h1 id="继承机制中对象之间如何转换"><a href="#继承机制中对象之间如何转换" class="headerlink" title="继承机制中对象之间如何转换"></a>继承机制中对象之间如何转换</h1><ol>
<li>向上类型转换<br>将派生类指针或引用转换为基类的指针或引用被称为向上类型转换，向上类型转换会自动进行，而且向上类型转换是安全的。</li>
<li>向下类型转换<br>将基类指针或引用转换为派生类指针或引用被称为向下类型转换，向下类型转换不会自动进行，因为一个基类对应几个派生类，所以向下类型转换时不知道对应哪个派生类，所以在向下类型转换时必须加动态类型识别技术。RTTI技术，用dynamic_cast进行向下类型转换</li>
</ol>
<h1 id="函数调用过程栈的变化"><a href="#函数调用过程栈的变化" class="headerlink" title="函数调用过程栈的变化"></a>函数调用过程栈的变化</h1><p>调用者函数把被调函数所需要的参数按照与被调函数的形参顺序相反的顺序压入栈中,即:从右向左依次把被调 函数所需要的参数压入栈;</p>
<p>调用者函数使用call指令调用被调函数,并把call指令的下一条指令的地址当成返回地址压入栈中(这个压栈操作隐含在call指令中);</p>
<h1 id="define、const、typedef、inline"><a href="#define、const、typedef、inline" class="headerlink" title="define、const、typedef、inline"></a>define、const、typedef、inline</h1><p>​		一、const与#define的区别：</p>
<ul>
<li><p>const定义的常量是变量带类型，而#define定义的只是个常数不带类型；</p>
</li>
<li><p>define只在预处理阶段起作用，简单的文本替换，而const在编译、链接过程中起作用；</p>
</li>
<li><p>define只是简单的字符串替换没有类型检查。而const是有数据类型的，是要进行判断的，可以避免一些低级错误；</p>
</li>
<li><p>define预处理后，占用代码段空间，const占用数据段空间；</p>
</li>
<li><p>const不能重定义，而define可以通过#undef取消某个符号的定义，进行重定义；</p>
</li>
<li><p>define独特功能，比如可以用来防止文件重复引用。</p>
<p>二、#define和别名typedef的区别</p>
</li>
<li><p>执行时间不同，typedef在编译阶段有效，typedef有类型检查的功能；#define是宏定义，发生在预处理阶段，不进行类型检查；</p>
</li>
<li><p>功能差异，typedef用来定义类型的别名，定义与平台无关的数据类型，与struct的结合使用等。#define不只是可以为类型取别名，还可以定义常量、变量、编译开关等。</p>
</li>
<li><p>作用域不同，#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。而typedef有自己的作用域。<br>三、 define与inline的区别</p>
</li>
<li><p>#define是关键字，inline是函数；</p>
</li>
<li><p>宏定义在预处理阶段进行文本替换，inline函数在编译阶段进行替换；</p>
</li>
<li><p>inline函数有类型检查，相比宏定义比较安全；</p>
</li>
</ul>
<h1 id="printf函数的实现原理"><a href="#printf函数的实现原理" class="headerlink" title="printf函数的实现原理"></a>printf函数的实现原理</h1><p>在C&#x2F;C++中，对函数参数的扫描是从后向前的。</p>
<p>C&#x2F;C++的函数参数是通过压入堆栈的方式来给函数传参数的（堆栈是一种先进后出的数据结构），最先压入的参数最后出来，在计算机的内存中，数据有2块，一块是堆，一块是栈（函数参数及局部变量在这里），而栈是从内存的高地址向低地址生长的，控制生长的就是堆栈指针了，最先压入的参数是在最上面，就是说在所有参数的最后面，最后压入的参数在最下面，结构上看起来是第一个，所以最后压入的参数总是能够被函数找到，因为它就在堆栈指针的上方。</p>
<p>printf的第一个被找到的参数就是那个字符指针，就是被双引号括起来的那一部分，函数通过判断字符串里控制参数的个数来判断参数个数及数据类型，通过这些就可算出数据需要的堆栈指针的偏移量了。</p>
<h1 id="strcpy和memcpy的区别"><a href="#strcpy和memcpy的区别" class="headerlink" title="strcpy和memcpy的区别"></a>strcpy和memcpy的区别</h1><ol>
<li>复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。</li>
<li>复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。</li>
<li>用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</li>
<li>① strcpy主要实现字符串变量间的拷贝<br>② sprintf主要实现其他数据类型格式到字符串的转化<br>③ memcpy主要是内存块间的拷贝。</li>
</ol>
<p><code>strcpy</code> 函数用于将一个字符串（以 null 结尾的字符数组）复制到另一个字符数组中。它的函数原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char* strcpy(char* destination, const char* source);</span><br></pre></td></tr></table></figure>

<p>其中，<code>destination</code> 是目标字符数组的指针，<code>source</code> 是要拷贝的源字符数组的指针。<code>strcpy</code> 函数会将源字符数组中的内容复制到目标字符数组中，并返回目标字符数组的指针。</p>
<p><code>memcpy</code> 函数用于将一块内存区域的内容复制到另一个内存区域。它的函数原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void* memcpy(void* destination, const void* source, size_t num);</span><br></pre></td></tr></table></figure>

<p>其中，<code>destination</code> 是目标内存区域的指针，<code>source</code> 是源内存区域的指针，<code>num</code> 是要复制的字节数。<code>memcpy</code> 函数会将源内存区域中的内容复制到目标内存区域中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memcpy(&amp;person2, &amp;person1, sizeof(Person));//prerson是类或结构体的情况</span><br></pre></td></tr></table></figure>

<h1 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1><p>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如： 操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行 优化，从而可以提供对特殊地址的稳定访问。声明时语法：int volatile vInt; 当要求使用 volatile 声明的变 量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而 且读取的数据立刻被保存。</p>
<p>volatile用在如下的几个地方：</p>
<ol>
<li>中断服务程序中修改的供其它程序检测的变量需要加volatile；</li>
<li>多任务环境下各任务间共享的标志应该加volatile；</li>
<li>存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；</li>
</ol>
<h1 id="空类默认添加函数"><a href="#空类默认添加函数" class="headerlink" title="空类默认添加函数"></a>空类默认添加函数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1) Empty(); // 缺省构造函数//</span><br><span class="line">2) Empty( const Empty&amp; ); // 拷贝构造函数//</span><br><span class="line">3) ~Empty(); // 析构函数//</span><br><span class="line">4) Empty&amp; operator=( const Empty&amp; ); // 赋值运算符//</span><br></pre></td></tr></table></figure>

<h1 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h1><ul>
<li>(1) 友元关系不能被继承。</li>
<li>(2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。</li>
<li>(3) 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明</li>
</ul>
<h1 id="成员函数中调用delete-this"><a href="#成员函数中调用delete-this" class="headerlink" title="成员函数中调用delete this"></a>成员函数中调用delete this</h1><p>在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放 在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。 当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及 到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现 不可预期的问题。</p>
<p>在成员函数中调用 <code>delete this</code> 将导致未定义行为。这是因为在调用 <code>delete this</code> 后，对象所在的内存将被释放，但对象的成员函数仍然存在。</p>
<p>由于对象所占用的内存已经被释放，再次调用该对象的成员函数将导致访问已经无效的内存，可能会导致程序崩溃或产生其他不可预测的结果。</p>
<p>所以，在调用 <code>delete this</code> 后，不应该再使用对象的成员函数，也不能对对象进行任何操作。</p>
<p>以下示例演示了在成员函数中调用 <code>delete this</code> 的问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class MyClass &#123;</span><br><span class="line">public:</span><br><span class="line">    void doSomething() &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Doing something&quot; &lt;&lt; std::endl;</span><br><span class="line">        delete this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    MyClass* obj = new MyClass();</span><br><span class="line">    obj-&gt;doSomething();  // 调用 delete this</span><br><span class="line"></span><br><span class="line">    obj-&gt;doSomething();  // 潜在的未定义行为：访问无效的内存</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>MyClass</code> 类的 <code>doSomething</code> 成员函数中调用了 <code>delete this</code>。在 <code>main</code> 函数中，我们首先创建了一个 <code>MyClass</code> 的对象 <code>obj</code>，然后调用了 <code>obj-&gt;doSomething()</code>。在该调用内部，对象被删除并且内存被释放。接着，我们又尝试调用 <code>obj-&gt;doSomething()</code> 一次，这是不安全的，因为对象已经不存在，访问无效的内存会导致未定义行为。</p>
<p>this在成员函数的开始执行前构造，在成员的执行结束后清除。这里的清除和delete有区别。</p>
<ul>
<li><p>结束对象的生命周期时，内存会被自动释放（在栈上分配的对象在作用域结束时，动态分配的对象在使用 <code>delete</code> 运算符时）。</p>
</li>
<li><p>调用 <code>delete this</code> 是显式地删除对象，包括对象本身和其成员。这是一种危险的操作，需要谨慎使用。</p>
<ul>
<li><p>栈对象：栈对象是在函数内部或代码块内部声明的对象，其存储在程序的栈上。当栈对象的作用域结束时（例如函数返回或代码块结束），编译器会自动清理栈对象，释放其所占用的内存。</p>
</li>
<li><p>堆对象：堆对象是通过 <code>new</code> 运算符在堆内存中动态分配的对象。使用 <code>new</code> 创建的对象存储在堆上，并且需要通过 <code>delete</code> 运算符显式地释放。调用 <code>delete</code> 会销毁堆对象，释放其所占用的内存。这里我理解成相当于删除副本和原件。</p>
</li>
</ul>
</li>
</ul>
<p>堆上分配的对象的生命周期不受作用域的限制。堆对象可以在任何地方创建，并且会一直存在，直到显式地通过<code>delete</code>删除或程序运行结束。</p>
<h1 id="空类"><a href="#空类" class="headerlink" title="空类"></a>空类</h1><ol>
<li>C++空类的大小不为0，不同编译器设置不一样，vs设置为1；</li>
<li>C++标准指出，不允许一个对象（当然包括类对象）的大小为0，不同的对象不能具有相同的地址；</li>
<li>带有虚函数的C++类大小不为1，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小<br>确定；</li>
<li>C++中要求对于类的每个实例都必须有独一无二的地址,那么编译器自动为空类分配一个字节大小，<br>这样便保证了每个实例均有独一无二的内存地址。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line"> 	cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 1;</span><br><span class="line"> 	A a; </span><br><span class="line"> 	cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 1;</span><br><span class="line"> 	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空类的大小是1， 在C++中空类会占一个字节，这是为了让对象的实例能够相互区别。具体来说，空类 同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个 字节，这样空类实例化之后就会拥有独一无二的内存地址。当该空白类作为基类时，该类的大小就优化 为0了，子类的大小就是子类本身的大小。这就是所谓的空白基类最优化。</p>
<p>空类的实例大小就是类的大小，所以sizeof(a)&#x3D;1字节,如果a是指针，则sizeof(a)就是指针的大小，即4字 节。因为有虚函数的类对象中都有一个虚函数表指针 __vptr，其大小是4字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A &#123; virtual Fun()&#123;&#125; &#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line"> 	cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 4(32位机器)/8(64位机器);</span><br><span class="line"> 	A a; </span><br><span class="line"> 	cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 4(32位机器)/8(64位机器);</span><br><span class="line"> 	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>静态成员存放在静态存储区，不占用类的大小, 普通函数也不占用类大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A &#123; static int a; &#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line"> 	cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 1;</span><br><span class="line"> 	A a; </span><br><span class="line"> 	cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 1;</span><br><span class="line"> 	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>静态成员a不占用类的大小，所以类的大小就是b变量的大小 即4个字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class A &#123; int a; &#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line"> 	cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 4;</span><br><span class="line"> 	A a; </span><br><span class="line"> 	cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 4;</span><br><span class="line"> 	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A &#123; static int a; int b; &#125;;;</span><br><span class="line">int main()&#123;</span><br><span class="line"> 	cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 4;</span><br><span class="line"> 	A a; </span><br><span class="line"> 	cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 4;</span><br><span class="line"> 	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="类对象的大小"><a href="#类对象的大小" class="headerlink" title="类对象的大小"></a>类对象的大小</h1><ol>
<li>类的非静态成员变量大小，静态成员不占据类的空间，成员函数也不占据类的空间大小；</li>
<li>内存对齐另外分配的空间大小，类内的数据也是需要进行内存对齐操作的；</li>
<li>虚函数的话，会在类对象插入vptr指针，加上指针大小；</li>
<li>当该类是某类的派生类，那么派生类继承的基类部分的数据成员也会存在在派生类中的空间中，也会对派生类进行扩展。</li>
</ol>
<h1 id="std-forward-list（单向链表）"><a href="#std-forward-list（单向链表）" class="headerlink" title="std::forward_list（单向链表）"></a>std::forward_list（单向链表）</h1><p><code>std::forward_list</code> 是 C++ 中的单向链表容器，它在 <code>&lt;forward_list&gt;</code> 头文件中定义。相比于其他容器，<code>std::forward_list</code> 具有内存占用低、插入删除高效等特点，适用于快速插入和删除元素的场景。</p>
<p>以下是 <code>std::forward_list</code> 的一些基本特性和用法：</p>
<ol>
<li>链表结构：<code>std::forward_list</code> 采用单向链表的数据结构，每个节点存储一个值，并通过指针连接到下一个节点。</li>
<li>基本操作：<code>std::forward_list</code> 提供了插入、删除、查找等基本操作，如 <code>push_front()</code>、<code>pop_front()</code>、<code>insert_after()</code>、<code>erase_after()</code> 等。</li>
<li>迭代器：可以使用迭代器遍历链表元素，分别为 <code>begin()</code> 和 <code>end()</code>，其中 <code>begin()</code> 返回指向第一个元素的迭代器，<code>end()</code> 返回指向最后一个元素之后的迭代器。</li>
<li>高效性能：由于链表结构的特点，<code>std::forward_list</code> 在插入和删除元素时具有高效性能，时间复杂度接近常数时间。</li>
<li>不支持随机访问：由于单向链表的特点，<code>std::forward_list</code> 不支持通过下标随机访问元素，只能通过迭代器逐个遍历查找。</li>
</ol>
<p>以下是一个使用 <code>std::forward_list</code> 的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;forward_list&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::forward_list&lt;int&gt; myList;</span><br><span class="line"></span><br><span class="line">    // 在链表头部插入元素</span><br><span class="line">    myList.push_front(2);</span><br><span class="line">    myList.push_front(1);</span><br><span class="line"></span><br><span class="line">    // 在链表头部删除元素</span><br><span class="line">    myList.pop_front();</span><br><span class="line"></span><br><span class="line">    // 遍历链表并打印元素</span><br><span class="line">    for (const auto&amp; value : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们创建了一个 <code>std::forward_list</code> 容器 <code>myList</code>，并使用 <code>push_front()</code> 在链表头部插入两个元素。然后，通过 <code>pop_front()</code> 删除链表头部的元素。最后，使用范围-based for 循环遍历链表，并打印每个元素。</p>
<ul>
<li><code>insert_after(pos, value)</code>：在迭代器 <code>pos</code> 所指节点之后插入值为 <code>value</code> 的新节点。插入的元素将成为当前节点的下一个节点。</li>
<li><code>erase_after(pos)</code>：删除迭代器 <code>pos</code> 所指节点的下一个节点。</li>
</ul>
<h1 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h1><p>C++11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些 只对应某种特定的类型说明符(例如 int)不同， auto 让编译器通过初始值来进行类型推演。从而获得定义变量的类型，所以说 auto 定义的变量必须有 初始值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//普通；类型</span><br><span class="line">int a = 1, b = 3;</span><br><span class="line">auto c = a + b;// c为int型</span><br><span class="line">//const类型</span><br><span class="line">const int i = 5;</span><br><span class="line">auto j = i; // 变量i是顶层const, 会被忽略, 所以j的类型是int</span><br><span class="line">auto k = &amp;i; // 变量i是一个常量, 对常量取地址是一种底层const, 所以b的类型是const int*</span><br><span class="line">const auto l = i; //如果希望推断出的类型是顶层const的, 那么就需要在auto前面加上cosnt</span><br><span class="line">//引用和指针类型</span><br><span class="line">int x = 2;</span><br><span class="line">int&amp; y = x;</span><br><span class="line">auto z = y; //z是int型不是int&amp; 型</span><br><span class="line">auto&amp; p1 = y; //p1是int&amp;型</span><br><span class="line">auto p2 = &amp;x; //p2是指针类型int*</span><br></pre></td></tr></table></figure>

<p>从 const 指针开始说起。<code>const int* pInt;</code> 和 <code>int *const pInt = &amp;someInt;</code>，前者是 *pInt 不能改变，而后者是 pInt 不能改变。因此指针本身是不是常量和指针所指向的对象是不是常量就是两个互相独立的问题。用<strong>顶层</strong>表示指针本身是个常量，<strong>底层</strong>表示指针所指向的对象是个常量。</p>
<p>更一般的，顶层 const 可以表示任意的对象是常量，这一点对任何数据类型都适用；<strong>底层 const 则与指针和引用等复合类型有关</strong>，比较特殊的是，指针类型<strong>既可以是顶层</strong> const <strong>也可以是底层</strong> const 或者<strong>二者兼备</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int i=0;</span><br><span class="line">int *const pl =&amp;i;//不能改变p1的值，这是一个顶层const</span><br><span class="line">const int ci =42;</span><br><span class="line">//不能改变ci的值，这是一个顶层const</span><br><span class="line">const int *p2= &amp;ci;</span><br><span class="line">//允许改变p2的值，这是一个底层const</span><br><span class="line">const int &amp;r=ci;</span><br><span class="line">//  所有的引用本身都是顶层 const，因为引用一旦初始化就不能再改为其他对象的引用，这里用于声明引用的 const 都是底层 const</span><br></pre></td></tr></table></figure>

<h1 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h1><p>有的时候我们还会遇到这种情况，我们希望从表达式中推断出要定义变量的类型，但却不想用表达式的 值去初始化变量。还有可能是函数的返回类型为某表达式的值类型。在这些时候auto显得就无力了，所 以C++11又引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数据类型。在此过程中， 编译器只是分析表达式并得到它的类型，却不进行实际的计算表达式的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int func() &#123;return 0&#125;;</span><br><span class="line">//普通类型</span><br><span class="line">decltype(func()) sum = 5; // sum的类型是函数func()的返回值的类型int, 但是这时不会实际调用函数func()</span><br><span class="line">int a = 0;</span><br><span class="line">decltype(a) b = 4; // a的类型是int, 所以b的类型也是int</span><br><span class="line"></span><br><span class="line">//不论是顶层const还是底层const, decltype都会保留 </span><br><span class="line">const int c = 3;</span><br><span class="line">decltype(c) d = c; // d的类型和c是一样的, 都是顶层const</span><br><span class="line">int e = 4;</span><br><span class="line">const int* f = &amp;e; // f是底层const</span><br><span class="line">decltype(f) g = f; // g也是底层const</span><br><span class="line"></span><br><span class="line">//引用与指针类型</span><br><span class="line">//1. 如果表达式是引用类型, 那么decltype的类型也是引用</span><br><span class="line">const int i = 3, &amp;j = i;</span><br><span class="line">decltype(j) k = 5; // k的类型是 const int&amp;</span><br><span class="line"></span><br><span class="line">//2. 如果表达式是引用类型, 但是想要得到这个引用所指向的类型, 需要修改表达式:</span><br><span class="line">int i = 3, &amp;r = i;</span><br><span class="line">decltype(r + 0) t = 5; // 此时是int类型</span><br><span class="line"></span><br><span class="line">//3. 对指针的解引用操作返回的是引用类型</span><br><span class="line">int i = 3, j = 6, *p = &amp;i;</span><br><span class="line">decltype(*p) c = j; // c是int&amp;类型, c和j绑定在一起</span><br><span class="line">//p 是一个指针，它指向变量 i。因为 *p 是解引用操作符，它返回指针 p 所指向的对象。在这种情况下，*p 返回的是 i 的引用</span><br><span class="line"></span><br><span class="line">//4. 如果一个表达式的类型不是引用, 但是我们需要推断出引用, 那么可以加上一对括号, 就变成了引用</span><br><span class="line">类型了</span><br><span class="line">int i = 3;</span><br><span class="line">decltype((i)) j = i; // 此时j的类型是int&amp;类型, j和i绑定在了一起</span><br></pre></td></tr></table></figure>

<h1 id="decltype-auto"><a href="#decltype-auto" class="headerlink" title="decltype(auto)"></a>decltype(auto)</h1><p>decltype(auto)是C++14新增的类型指示符，可以用来声明变量以及指示函数返回类型。在使用时，会将 “&#x3D;”号左边的表达式替换掉auto，再根据decltype的语法规则来确定类型。举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int e = 4;</span><br><span class="line">const int* f = &amp;e; // f是底层const</span><br><span class="line">decltype(auto) j = f;//j的类型是const int* 并且指向的是e</span><br></pre></td></tr></table></figure>

<h1 id="auto-ptr作用"><a href="#auto-ptr作用" class="headerlink" title="auto_ptr作用"></a>auto_ptr作用</h1><ol>
<li>auto_ptr的出现，主要是为了解决“有异常抛出时发生内存泄漏”的问题；抛出异常，将导致指针p所指向的空间得不到释放而导致内存泄漏；</li>
<li>auto_ptr构造时取得某个对象的控制权，在析构时释放该对象。我们实际上是创建一个auto_ptr类型的局部对象，该局部对象析构时，会将自身所拥有的指针空间释放，所以不会有内存泄漏；</li>
<li>auto_ptr的构造函数是explicit，阻止了一般指针隐式转换为 auto_ptr的构造，所以不能直接将一般类型的指针赋值给auto_ptr类型的对象，必须用auto_ptr的构造函数创建对象；</li>
<li>由于auto_ptr对象析构时会删除它所拥有的指针，所以使用时避免多个auto_ptr对象管理同一个指针；</li>
<li>Auto_ptr内部实现，析构函数中删除对象用的是delete而不是delete[]，所以auto_ptr不能管理数组；</li>
<li>auto_ptr支持所拥有的指针类型之间的隐式类型转换。</li>
<li>可以通过*和-&gt;运算符对auto_ptr所有用的指针进行提领操作；</li>
<li>T* get(),获得auto_ptr所拥有的指针；T* release()，释放auto_ptr的所有权，并将所有用的指针返回。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  // 创建一个 auto_ptr 对象并分配内存</span><br><span class="line">  std::auto_ptr&lt;int&gt; ptr(new int(42));</span><br><span class="line"></span><br><span class="line">  // 使用 get() 方法获取 auto_ptr 持有的指针</span><br><span class="line">  int* raw_ptr = ptr.get();</span><br><span class="line">  std::cout &lt;&lt; &quot;The value of the pointer is: &quot; &lt;&lt; *raw_ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  // 使用 release() 释放 auto_ptr 的所有权，并获取所拥有的指针</span><br><span class="line">  int* released_ptr = ptr.release();</span><br><span class="line">  std::cout &lt;&lt; &quot;The value of the released pointer is: &quot; &lt;&lt; *released_ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  // 此时 ptr 已没有任何所有权，不能对其进行访问或释放</span><br><span class="line">  // std::cout &lt;&lt; &quot;The value of the released auto_ptr is: &quot; &lt;&lt; *ptr &lt;&lt; std::endl; // 试图访问会导致运行时错误</span><br><span class="line">  // ptr.reset(); // 试图释放会导致运行时错误</span><br><span class="line"></span><br><span class="line">  delete released_ptr;  // 需要手动释放获取到的指针</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="智能指针的循环引用"><a href="#智能指针的循环引用" class="headerlink" title="智能指针的循环引用"></a>智能指针的循环引用</h1><p>循环引用是指使用多个智能指针share_ptr时，出现了指针之间相互指向，从而形成环的情况，有点类似 于死锁的情况，这种情况下，智能指针往往不能正常调用对象的析构函数，从而造成内存泄漏。举个例 子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class Node</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Node(const T &amp;value)</span><br><span class="line">        : _pPre(NULL), _pNext(NULL), _value(value)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Node()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Node()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;~Node()&quot; &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;this:&quot; &lt;&lt; this &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    shared_ptr&lt;Node&lt;T&gt;&gt; _pPre;</span><br><span class="line">    shared_ptr&lt;Node&lt;T&gt;&gt; _pNext;</span><br><span class="line">    T _value;</span><br><span class="line">&#125;;</span><br><span class="line">void Funtest()</span><br><span class="line">&#123;</span><br><span class="line">    shared_ptr&lt;Node&lt;int&gt;&gt; sp1(new Node&lt;int&gt;(1));</span><br><span class="line">    shared_ptr&lt;Node&lt;int&gt;&gt; sp2(new Node&lt;int&gt;(2));</span><br><span class="line">    cout &lt;&lt; &quot;sp1.use_count:&quot; &lt;&lt; sp1.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;sp2.use_count:&quot; &lt;&lt; sp2.use_count() &lt;&lt; endl;</span><br><span class="line">    sp1-&gt;_pNext = sp2; // sp1的引用+1</span><br><span class="line">    sp2-&gt;_pPre = sp1;  // sp2的引用+1</span><br><span class="line">    cout &lt;&lt; &quot;sp1.use_count:&quot; &lt;&lt; sp1.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;sp2.use_count:&quot; &lt;&lt; sp2.use_count() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Funtest();</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//输出结果</span><br><span class="line">//Node()</span><br><span class="line">//Node()</span><br><span class="line">//sp1.use_count:1</span><br><span class="line">//sp2.use_count:1</span><br><span class="line">//sp1.use_count:2</span><br><span class="line">//sp2.use_count:2</span><br></pre></td></tr></table></figure>

<p>从上面shared_ptr的实现中我们知道了只有当引用计数减减之后等于0，析构时才会释放对象，而上述情 况造成了一个僵局，那就是析构对象时先析构sp2,可是由于sp2的空间sp1还在使用中，所以sp2.use_count 减减之后为1，不释放，sp1也是相同的道理，由于sp1的空间sp2还在使用中，所以sp1.use_count减减之 后为1，也不释放。sp1等着sp2先释放，sp2等着sp1先释放,二者互不相让，导致最终都没能释放，内存泄漏。 </p>
<p>在实际编程过程中，应该尽量避免出现智能指针之前相互指向的情况，如果不可避免，可以使用使用弱 指针——weak_ptr，它不增加引用计数，只要出了作用域就会自动析构。</p>
<p>弱指针用于专门解决shared_ptr循环引用的问题，weak_ptr不会修改引用计数，即其存在与否并不影响对 象的引用计数器。循环引用就是：两个对象互相使用一个shared_ptr成员变量指向对方。弱引用并不对对 象的内存进行管理，在功能上类似于普通指针，然而一个比较大的区别是，弱引用能检测到所管理的对 象是否已经被释放，从而避免访问非法内存。</p>
<h1 id="对数组的-amp-操作"><a href="#对数组的-amp-操作" class="headerlink" title="对数组的&amp;操作"></a>对数组的&amp;操作</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[5] = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">    //&amp;a + 1 实际上就是指向数组 a 所占内存块的下一个地址，即 &amp;a[5] 的地址</span><br><span class="line">    int *p1 = (int *)(&amp;a + 1);//&amp;a 表示的是整个数组的地址。指针加 1 的操作实际上是按照指针所指向类型的大小进行偏移</span><br><span class="line">    //&amp;a 的类型是 int (*)[5]，表示指向包含 5 个 int 类型元素的数组的指针。因此，当你执行 &amp;a + 1 时，指针会增加 sizeof(int [5]) 的大小</span><br><span class="line">    int *p2 = (int *)(a + 1);</span><br><span class="line">    printf(&quot;%d, %d\n&quot;, p1[-1], p2[1]);//5, 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="子父类构造函数的调用"><a href="#子父类构造函数的调用" class="headerlink" title="子父类构造函数的调用"></a>子父类构造函数的调用</h1><p>创建子类的时候，先检查父类是否有静态的属性，如果有，则先调用静态属性的语句，然后检查子类是否也有静态类型属性，有则调用子类的静态类型，然后在调用父类普通变量，构造函数，然后才是子类的普通属性，构造函数 顺序是：<br><strong>父类静态  -&gt; 子类静态 -&gt; 父类属性  -&gt; 父类构造函数 -&gt; 子类属性 -&gt; 子类构造函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Value1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Value1()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        printf(&quot;Call Value1::Value1(int nValue1)\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    ~Value1()</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Call Value1::~Value1()\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    int m_nVal1;</span><br><span class="line">&#125;;</span><br><span class="line">class Value</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Value(int nVal)</span><br><span class="line">    &#123;</span><br><span class="line">        m_nVal = nVal;</span><br><span class="line">        printf(&quot;Call Value::Value(int nValue)\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    ~Value()</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Call Value::~Value()\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Value &amp;operator=(int nVal)</span><br><span class="line">    &#123;</span><br><span class="line">        m_nVal = nVal;</span><br><span class="line">        printf(&quot;Call Value::operator=\n&quot;);</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    void Dump()</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Value::m_nVal=%d\n&quot;, m_nVal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    int m_nVal;</span><br><span class="line">&#125;;</span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Base()</span><br><span class="line">    &#123;</span><br><span class="line">        Init();</span><br><span class="line">    &#125;</span><br><span class="line">    virtual ~Base()</span><br><span class="line">    &#123;</span><br><span class="line">        Release();</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void Init()</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Call Base::Init()\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void Release()</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Call Base::Release()\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void Dump()</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Call Base::Dump()\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    Value1 m_Val1;</span><br><span class="line">&#125;;</span><br><span class="line">class Derive : public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Derive()</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Call Derive::Derive()\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    ~Derive()</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Call Derive::~Derive()\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void Init()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        m_Val = 2;</span><br><span class="line">        printf(&quot;Call Derive::Init()\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void Release()</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Call Derive::Release()\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void Dump()</span><br><span class="line">    &#123;</span><br><span class="line">        m_Val.Dump();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static Value m_Val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Value Derive::m_Val = 0;</span><br><span class="line"></span><br><span class="line">void DestroyObj(Base *pOb)</span><br><span class="line">&#123;</span><br><span class="line">    pOb-&gt;Dump();</span><br><span class="line">    delete pOb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Derive *pOb = new Derive;</span><br><span class="line">    DestroyObj(pOb);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Call Value::Value(int nValue)</code><br><code>Call Value1::Value1(int nValue1)</code><br><code>Call Base::Init()</code><br><code>Call Derive::Derive()</code><br><code>Value::m_nVal=0</code><br><code>Call Derive::~Derive()</code><br><code>Call Base::Release()</code><br><code>Call Value1::~Value1()</code><br><code>Call Value::~Value()</code></p>
<p>父类的非静态成员变量的初始化发生在父类的构造函数之前，这是因为在构造函数执行之前，对象的内存空间已经被分配和布局好了。在对象的内存空间布局过程中，首先会为对象的成员变量分配对应的内存空间，并按照它们在类中的声明顺序进行布局。</p>
<p>由于父类的构造函数负责对父类的成员进行初始化操作，而成员变量的初始化依赖于内存空间的分配和布局，所以需要在构造函数执行之前完成。这样在父类的构造函数中，可以直接使用已经分配并初始化好的成员变量。</p>
<p>因此，在对象的构造过程中，首先进行父类的非静态成员变量的初始化，然后才会调用父类的构造函数来完成其他的初始化操作。这样确保了对象的成员变量在构造函数中是可用和正确初始化的。</p>
<h1 id="STL-中的算法来操作堆"><a href="#STL-中的算法来操作堆" class="headerlink" title="STL 中的算法来操作堆"></a>STL 中的算法来操作堆</h1><p>heap（堆）并不是STL的容器组件，是priority queue（优先队列）的底层实现机制，因为binary max  heap（大根堆）总是最大值位于堆的根部，优先级最高。 binary heap本质是一种complete binary tree（完全二叉树），整棵binary tree除了最底层的叶节点之外，都 是填满的，但是叶节点从左到右不会出现空隙</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; v = &#123;0, 1, 2, 3, 4, 5, 6&#125;;</span><br><span class="line">    make_heap(v.begin(), v.end()); // 以vector为底层容器</span><br><span class="line">    for (auto i : v)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; &quot; &quot;; // 6 4 5 3 1 0 2</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    v.push_back(7);</span><br><span class="line">    push_heap(v.begin(), v.end());</span><br><span class="line">    for (auto i : v)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; &quot; &quot;; // 7 6 5 4 1 0 2 3</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    pop_heap(v.begin(), v.end());</span><br><span class="line">    cout &lt;&lt; v.back() &lt;&lt; endl; // 7</span><br><span class="line">    v.pop_back();</span><br><span class="line">    for (auto i : v)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; &quot; &quot;; // 6 4 5 3 1 0 2</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    sort_heap(v.begin(), v.end());</span><br><span class="line">    for (auto i : v)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; &quot; &quot;; // 0 1 2 3 4 5 6</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是pop之后元素并没有被移走，如果要将其移走，可以使用 pop_back()。在heap内部执行pop_heap时，只是将其移动到vector的最后位 置，然后再为这个被挤走的元素找到一个合适的安放位置，使整颗树满足完全二叉树的条件</p>
<p>priority_queue，优先队列，是一个拥有权值观念的queue，它跟queue一样是顶部入口，底部出口，在插 入元素时，元素并非按照插入次序排列，它会自动根据权值（通常是元素的实值）排列，权值最高，排 在最前面，如下图所示。 默认情况下，priority_queue使用一个max-heap完成，底层容器使用的是一般为vector为底层容器，堆heap 为处理规则来管理底层容器实现 。priority_queue的这种实现机制导致其不被归为容器，而是一种容器配 接器。</p>
<p>priority_queue的所有元素，进出都有一定的规则，只有queue顶端的元素（权值最高者），才有机会被外 界取用，它没有遍历功能，也不提供迭代器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int ia[9] = &#123;0, 4, 1, 2, 3, 6, 5, 8, 7&#125;;</span><br><span class="line">    priority_queue&lt;int&gt; pq(ia, ia + 9);</span><br><span class="line">    cout &lt;&lt; pq.size() &lt;&lt; endl; // 9</span><br><span class="line">    for (int i = 0; i &lt; pq.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; pq.top() &lt;&lt; &quot; &quot;; // 8 8 8 8 8 8 8 8 8</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    while (!pq.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; pq.top() &lt;&lt; &#x27; &#x27;; // 8 7 6 5 4 3 2 1 0</span><br><span class="line">        pq.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="C-把引用作为返回值"><a href="#C-把引用作为返回值" class="headerlink" title="C++ 把引用作为返回值"></a>C++ 把引用作为返回值</h1><p>通过使用引用来替代指针，会使 C++ 程序更容易阅读和维护。C++ 函数可以返回一个引用，方式与返回一个指针类似。</p>
<p>当函数返回一个引用时，则返回一个指向返回值的隐式指针。这样，函数就可以放在赋值语句的左边。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">double vals[] = &#123;10.1, 12.6, 33.1, 24.1, 50.0&#125;;</span><br><span class="line"> </span><br><span class="line">double&amp; setValues(int i) &#123;  </span><br><span class="line">   double&amp; ref = vals[i];    </span><br><span class="line">   return ref;   // 返回第 i 个元素的引用，ref 是一个引用变量，ref 引用 vals[i]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 要调用上面定义函数的主函数</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;改变前的值&quot; &lt;&lt; endl;</span><br><span class="line">   for ( int i = 0; i &lt; 5; i++ )</span><br><span class="line">   &#123;</span><br><span class="line">       cout &lt;&lt; &quot;vals[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;;</span><br><span class="line">       cout &lt;&lt; vals[i] &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   setValues(1) = 20.23; // 改变第 2 个元素</span><br><span class="line">   setValues(3) = 70.8;  // 改变第 4 个元素</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;改变后的值&quot; &lt;&lt; endl;</span><br><span class="line">   for ( int i = 0; i &lt; 5; i++ )</span><br><span class="line">   &#123;</span><br><span class="line">       cout &lt;&lt; &quot;vals[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;;</span><br><span class="line">       cout &lt;&lt; vals[i] &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当返回一个引用时，要注意被引用的对象不能超出作用域。所以返回一个对局部变量的引用是不合法的，但是，可以返回一个对静态变量的引用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int&amp; func() &#123;</span><br><span class="line">   int q;</span><br><span class="line">   //! return q; // 在编译时发生错误</span><br><span class="line">   static int x;</span><br><span class="line">   return x;     // 安全，x 在函数作用域外依然是有效的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int &amp;changevalue()</span><br><span class="line">&#123;</span><br><span class="line">    static int a_return =-29;</span><br><span class="line">    return a_return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int &amp;a_return=changevalue();</span><br><span class="line">    a_return =20;</span><br><span class="line">    cout&lt;&lt;changevalue()&lt;&lt;endl;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终，屏幕上打印的结果是：20</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/09/10/c-%E8%A1%A5%E5%85%85-2/" rel="prev" title="c++补充-2">
      <i class="fa fa-chevron-left"></i> c++补充-2
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/09/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4/" rel="next" title="数据结构-4">
      数据结构-4 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%EF%BC%8C%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="nav-number">1.</span> <span class="nav-text">静态类型和动态类型，静态绑定和动态绑定</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%8A%A0%E5%87%8F%E8%AE%A1%E7%AE%97"><span class="nav-number">2.</span> <span class="nav-text">指针加减计算</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E6%B5%AE%E7%82%B9%E6%95%B0%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89"><span class="nav-number">3.</span> <span class="nav-text">判断两个浮点数是否相等</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6%E4%B8%AD%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2"><span class="nav-number">4.</span> <span class="nav-text">继承机制中对象之间如何转换</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E6%A0%88%E7%9A%84%E5%8F%98%E5%8C%96"><span class="nav-number">5.</span> <span class="nav-text">函数调用过程栈的变化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#define%E3%80%81const%E3%80%81typedef%E3%80%81inline"><span class="nav-number">6.</span> <span class="nav-text">define、const、typedef、inline</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#printf%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">7.</span> <span class="nav-text">printf函数的实现原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#strcpy%E5%92%8Cmemcpy%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">8.</span> <span class="nav-text">strcpy和memcpy的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">9.</span> <span class="nav-text">volatile关键字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A9%BA%E7%B1%BB%E9%BB%98%E8%AE%A4%E6%B7%BB%E5%8A%A0%E5%87%BD%E6%95%B0"><span class="nav-number">10.</span> <span class="nav-text">空类默认添加函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="nav-number">11.</span> <span class="nav-text">友元类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8delete-this"><span class="nav-number">12.</span> <span class="nav-text">成员函数中调用delete this</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A9%BA%E7%B1%BB"><span class="nav-number">13.</span> <span class="nav-text">空类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-number">14.</span> <span class="nav-text">类对象的大小</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#std-forward-list%EF%BC%88%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%89"><span class="nav-number">15.</span> <span class="nav-text">std::forward_list（单向链表）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#auto"><span class="nav-number">16.</span> <span class="nav-text">auto</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#decltype"><span class="nav-number">17.</span> <span class="nav-text">decltype</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#decltype-auto"><span class="nav-number">18.</span> <span class="nav-text">decltype(auto)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#auto-ptr%E4%BD%9C%E7%94%A8"><span class="nav-number">19.</span> <span class="nav-text">auto_ptr作用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="nav-number">20.</span> <span class="nav-text">智能指针的循环引用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84-amp-%E6%93%8D%E4%BD%9C"><span class="nav-number">21.</span> <span class="nav-text">对数组的&amp;操作</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%90%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8"><span class="nav-number">22.</span> <span class="nav-text">子父类构造函数的调用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#STL-%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95%E6%9D%A5%E6%93%8D%E4%BD%9C%E5%A0%86"><span class="nav-number">23.</span> <span class="nav-text">STL 中的算法来操作堆</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-%E6%8A%8A%E5%BC%95%E7%94%A8%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">24.</span> <span class="nav-text">C++ 把引用作为返回值</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">肖汇林</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">76</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">肖汇林</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
