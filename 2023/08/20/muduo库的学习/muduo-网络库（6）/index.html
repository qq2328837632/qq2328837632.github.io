<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="完善TcpConnectionWriteCompleteCallback含义对于大流量的数据不断生成数据,然后发送conn.&gt;send2.如果对等方接受不及时，受到通告窗口的控制，内核发送缓冲不足，这个时候，就会将用户数据添加到应用层发送缓冲区(output buffer);可能会撑爆output buffer.解决方法就是,调整发送频率。关注WriteCompleteCallback当所有">
<meta property="og:type" content="article">
<meta property="og:title" content="muduo-网络库（6）">
<meta property="og:url" content="http://example.com/2023/08/20/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%886%EF%BC%89/index.html">
<meta property="og:site_name" content="肖汇林的博客">
<meta property="og:description" content="完善TcpConnectionWriteCompleteCallback含义对于大流量的数据不断生成数据,然后发送conn.&gt;send2.如果对等方接受不及时，受到通告窗口的控制，内核发送缓冲不足，这个时候，就会将用户数据添加到应用层发送缓冲区(output buffer);可能会撑爆output buffer.解决方法就是,调整发送频率。关注WriteCompleteCallback当所有">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-08-20T02:44:58.000Z">
<meta property="article:modified_time" content="2023-08-24T06:43:49.689Z">
<meta property="article:author" content="肖汇林">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2023/08/20/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%886%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>muduo-网络库（6） | 肖汇林的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖汇林的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/20/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%886%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          muduo-网络库（6）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-20 10:44:58" itemprop="dateCreated datePublished" datetime="2023-08-20T10:44:58+08:00">2023-08-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-24 14:43:49" itemprop="dateModified" datetime="2023-08-24T14:43:49+08:00">2023-08-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="完善TcpConnection"><a href="#完善TcpConnection" class="headerlink" title="完善TcpConnection"></a>完善TcpConnection</h1><h2 id="WriteCompleteCallback含义"><a href="#WriteCompleteCallback含义" class="headerlink" title="WriteCompleteCallback含义"></a>WriteCompleteCallback含义</h2><p><strong>对于大流量的数据</strong><br>不断生成数据,然后发送conn.&gt;send2.<br>如果对等方接受不及时，受到通告窗口的控制，内核发送缓冲不足，这个时候，就会将用户数据添加到应用层发送缓冲区(output buffer);可能会撑爆output buffer.<br>解决方法就是,调整发送频率。<br>关注WriteCompleteCallback<br>当所有的用户数据都拷贝到内核缓冲区，WriteCompleteCallback回调，然后继续发送。output buffer被清空也会回调该函数，可以理解为低水位标回调函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WriteCompleteCallback writeCompleteCallback_;//当所有的用户数据都拷贝到内核缓冲区，WriteCompleteCallback回调，然后继续发送。</span><br><span class="line">                                              //output buffer被清空也会回调该函数（也就是所有的用户数据都拷贝到内核缓冲区），可以理解为低水位标回调函数。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">void TcpConnection::sendInLoop(const void* data, size_t len)</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  ssize_t nwrote = 0;</span><br><span class="line">  size_t remaining = len;</span><br><span class="line">  bool faultError = false;</span><br><span class="line">  if (state_ == kDisconnected)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_WARN &lt;&lt; &quot;disconnected, give up writing&quot;;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  // if no thing in output queue, try writing directly</span><br><span class="line">  //通道没有关注可写事件并且发送缓冲区没有数据，直接write</span><br><span class="line">  if (!channel_-&gt;isWriting() &amp;&amp; outputBuffer_.readableBytes() == 0)</span><br><span class="line">  &#123;</span><br><span class="line">    nwrote = sockets::write(channel_-&gt;fd(), data, len);</span><br><span class="line">    if (nwrote &gt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">      remaining = len - nwrote;</span><br><span class="line">      //写完了，回调writeCompleteCallback_</span><br><span class="line">      if (remaining == 0 &amp;&amp; writeCompleteCallback_)</span><br><span class="line">      &#123;</span><br><span class="line">        loop_-&gt;queueInLoop(std::bind(writeCompleteCallback_, shared_from_this()));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else // nwrote &lt; 0</span><br><span class="line">    &#123;</span><br><span class="line">      nwrote = 0;</span><br><span class="line">      if (errno != EWOULDBLOCK)</span><br><span class="line">      &#123;</span><br><span class="line">        LOG_SYSERR &lt;&lt; &quot;TcpConnection::sendInLoop&quot;;</span><br><span class="line">        if (errno == EPIPE || errno == ECONNRESET) // FIXME: any others?</span><br><span class="line">        &#123;</span><br><span class="line">          faultError = true;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert(remaining &lt;= len);</span><br><span class="line">  //没有错误，并且还有未写完的数据（说明内核发送缓冲区满，要将未写完的数据添加到output buffer中)</span><br><span class="line">  if (!faultError &amp;&amp; remaining &gt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    size_t oldLen = outputBuffer_.readableBytes();</span><br><span class="line">    //如果超过highwaterMark_(高水位标)，回调highwaterMarkCallback_</span><br><span class="line">    if (oldLen + remaining &gt;= highWaterMark_</span><br><span class="line">        &amp;&amp; oldLen &lt; highWaterMark_</span><br><span class="line">        &amp;&amp; highWaterMarkCallback_)</span><br><span class="line">    &#123;</span><br><span class="line">      loop_-&gt;queueInLoop(std::bind(highWaterMarkCallback_, shared_from_this(), oldLen + remaining));</span><br><span class="line">    &#125;</span><br><span class="line">    outputBuffer_.append(static_cast&lt;const char*&gt;(data)+nwrote, remaining);</span><br><span class="line">    if (!channel_-&gt;isWriting())</span><br><span class="line">    &#123;</span><br><span class="line">      channel_-&gt;enableWriting();//关注pollout事件 </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//当内核发送缓冲区有空间了，pollout事件触发就会回调该函数</span><br><span class="line">  //通道可写事件到来的时候，回调TcpConnection::handleWrite</span><br><span class="line">  channel_-&gt;setWriteCallback(</span><br><span class="line">      std::bind(&amp;TcpConnection::handleWrite, this));</span><br><span class="line"></span><br><span class="line">void TcpConnection::handleWrite()</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  if (channel_-&gt;isWriting())</span><br><span class="line">  &#123;</span><br><span class="line">    ssize_t n = sockets::write(channel_-&gt;fd(),</span><br><span class="line">                               outputBuffer_.peek(),</span><br><span class="line">                               outputBuffer_.readableBytes());</span><br><span class="line">    if (n &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      outputBuffer_.retrieve(n);</span><br><span class="line">      if (outputBuffer_.readableBytes() == 0)//发送缓冲区已清空</span><br><span class="line">      &#123;</span><br><span class="line">        channel_-&gt;disableWriting();//停止关注pollout事件，以免出现busyloop</span><br><span class="line">        if (writeCompleteCallback_)//回调writeCompleteCallback_</span><br><span class="line">        &#123;</span><br><span class="line">          //应用层发送缓冲区已被清空，就回调用writeCompleteCallback_</span><br><span class="line">          loop_-&gt;queueInLoop(std::bind(writeCompleteCallback_, shared_from_this()));</span><br><span class="line">        &#125;</span><br><span class="line">        if (state_ == kDisconnecting)//发送缓冲区已被清空并且连接状态是kDisconnecting，要关闭连接</span><br><span class="line">        &#123;</span><br><span class="line">          shutdownInLoop();//关闭连接</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      LOG_SYSERR &lt;&lt; &quot;TcpConnection::handleWrite&quot;;</span><br><span class="line">      // if (state_ == kDisconnecting)</span><br><span class="line">      // &#123;</span><br><span class="line">      //   shutdownInLoop();</span><br><span class="line">      // &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_TRACE &lt;&lt; &quot;Connection fd = &quot; &lt;&lt; channel_-&gt;fd()</span><br><span class="line">              &lt;&lt; &quot; is down, no more writing&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="HighWaterMarkCallback含义"><a href="#HighWaterMarkCallback含义" class="headerlink" title="HighWaterMarkCallback含义"></a>HighWaterMarkCallback含义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HighWaterMarkCallback highWaterMarkCallback_;//高水位标回调函数，也就是output buffer撑到一定程度回调该函数</span><br></pre></td></tr></table></figure>

<h2 id="boost-any-context"><a href="#boost-any-context" class="headerlink" title="boost::any context_"></a>boost::any context_</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void setContext(const boost::any&amp; context)</span><br><span class="line">  &#123; context_ = context; &#125;</span><br><span class="line"></span><br><span class="line">  const boost::any&amp; getContext() const//外部不可以更改</span><br><span class="line">  &#123; return context_; &#125;</span><br><span class="line"></span><br><span class="line">  boost::any* getMutableContext()//可以更改</span><br><span class="line">  &#123; return &amp;context_; &#125;</span><br><span class="line">  boost::any context_;//你可以使用C++17中引入的std::any来替代boost::any，绑定一个未知类型的上下文对象</span><br></pre></td></tr></table></figure>

<h2 id="std-any"><a href="#std-any" class="headerlink" title="std::any"></a>std::any</h2><p>可以使用C++17中引入的std::any来替代boost::any，绑定一个未知类型的上下文对象</p>
<p><code>std::any context_;</code>的目的是创建一个可以存储任意类型对象的变量。</p>
<p>使用<code>std::any</code>可以在不事先知道对象类型的情况下，将其存储在一个统一的容器中。</p>
<p><code>std::any</code>提供了以下功能：</p>
<ol>
<li>存储任意类型的对象：你可以将任何类型的对象赋值给<code>context_</code>，无论是内置类型（例如int、float）还是自定义类型。</li>
<li>类型安全的访问：你可以使用<code>std::any_cast</code>函数来安全地将对象从<code>std::any</code>中检索出来，并进行类型转换。如果尝试将<code>std::any</code>中存储的对象转换为与实际类型不匹配的类型，将会抛出<code>std::bad_any_cast</code>异常。</li>
<li>空状态检查：你可以使用<code>std::any</code>的<code>has_value</code>函数来检查它是否包含了一个有效的对象。</li>
</ol>
<p><code>std::any</code>的灵活性使得它可以用于各种情况，特别适用于需要在运行时处理不同类型对象的场景，例如实现插件系统、通用数据结构等</p>
<h2 id="signal-SIGPIPE-SIG-IGN"><a href="#signal-SIGPIPE-SIG-IGN" class="headerlink" title="signal(SIGPIPE, SIG_IGN)"></a>signal(SIGPIPE, SIG_IGN)</h2><p>EvenLoop.cc中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#pragma GCC diagnostic ignored &quot;-Wold-style-cast&quot;</span><br><span class="line">//编译器不会发出或记录与这种旧式的类型转换相关的警告信息。</span><br><span class="line">//这是因为这段代码中可能使用了旧式的C风格类型转换，而该警告可以帮助开发者避免一些潜在的问题</span><br><span class="line">//封装了系统调用</span><br><span class="line">class IgnoreSigPipe</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  IgnoreSigPipe()</span><br><span class="line">  &#123;</span><br><span class="line">    ::signal(SIGPIPE, SIG_IGN);</span><br><span class="line">    // LOG_TRACE &lt;&lt; &quot;Ignore SIGPIPE&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">#pragma GCC diagnostic error &quot;-Wold-style-cast&quot;</span><br><span class="line">//如果后面的代码中出现了旧式的类型转换，编译器将会将其作为错误处理，终止编译过程</span><br><span class="line">IgnoreSigPipe initObj;</span><br><span class="line">&#125;// namespace 代码被放置在了匿名的 namespace 中。这意味着其中的内容只对当前文件中的代码可见，不会对其他文件中的代码造成影响。这在一定程度上隐藏了实现细节，限制了作用域，并且通过将 IgnoreSigPipe 类声明为 private，限制了类在文件之外的可见性。这样可以帮助控制代码的组织和维护，并减少了潜在的命名冲突。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="可变类型解决方案"><a href="#可变类型解决方案" class="headerlink" title="可变类型解决方案"></a>可变类型解决方案</h2><ul>
<li>void*.这种方法不是类型安全的</li>
<li>boost:any<ul>
<li>任意类型的类型安全存储以及安全的取回</li>
<li>在标准库容器中存放不同类型的方法，比如说<code>vector&lt;boost::any&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">class TestServer&#123;</span><br><span class="line">public:</span><br><span class="line">TestServer(EventLoop*loop,const InetAddress&amp; listenAddr)</span><br><span class="line">			:loop_(loop),</span><br><span class="line">			server(loop,1istenAddr,&quot;TestServer&quot;)</span><br><span class="line">	&#123;</span><br><span class="line">		server_.setconnectionCa11back(</span><br><span class="line">			boost::bind(&amp;Testserver::onConnection,this，_1));</span><br><span class="line">		server_.setMessageCa11back(</span><br><span class="line">			boost::bind(&amp;TestServer::onMessage, this，_1,_2,_3));</span><br><span class="line">		server_.setWriteCompleteCallback(</span><br><span class="line">			boost::bind(&amp;TestServer::onWriteComplete, this，_1));</span><br><span class="line">		//生成数据</span><br><span class="line">		string line;</span><br><span class="line">		for (int i = 33; i &lt; 127;++i)&#123;</span><br><span class="line">			line.push_back(char(i));</span><br><span class="line">		&#125;</span><br><span class="line">		line += line;</span><br><span class="line">		for (size_t i =0 ; i &lt; 127-33; ++i)&#123;</span><br><span class="line">			message_ += line.substr(i,72)+ &#x27;\n&#x27;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	void start()&#123;</span><br><span class="line">		server_.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	void:onConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">	&#123;</span><br><span class="line">		if( conn-&gt;connected())&#123;</span><br><span class="line">			printf(&quot;onconnection(): new connettion [%s]from %s\n&quot;,</span><br><span class="line">				conn-&gt;name()-&gt;c_str(),</span><br><span class="line">				conn-&gt;peerAddress().toIpPort().c_str());</span><br><span class="line">			conn-&gt;setTcpNoDelay(true);</span><br><span class="line">			conn-&gt;send(message_);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			printf(&quot;onconnection():connettion [%s] is down\n&quot;,</span><br><span class="line">				conn-&gt;name()-&gt;c_str());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	void onMessage(const TcpConnectionPtr&amp; conn,</span><br><span class="line">					Buffer* buf,</span><br><span class="line">					Timestamp receiveTime)</span><br><span class="line">	&#123;</span><br><span class="line">		muduo::string msg(buf-&gt;retrieveAllAsString());</span><br><span class="line">		printf(&quot;onMessage(): received %zd bytes from connection [%s] at %s\n&quot;,</span><br><span class="line">				msg.size(),</span><br><span class="line">				conn-&gt;name().c_str(),</span><br><span class="line">				receiveTime.toFormattedString().c_str());</span><br><span class="line">		conn-&gt;send(msg);</span><br><span class="line">	&#125;</span><br><span class="line">	void onWriteComplete(const TcpConnectionPtr&amp; conn)</span><br><span class="line">	&#123;</span><br><span class="line">		conn-&gt;send(message_);</span><br><span class="line">	&#125;</span><br><span class="line">	EventLoop* loop_;</span><br><span class="line">	TcpServer server_;</span><br><span class="line">	muduo::string message_;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">	printf( &quot;main(): pid = %d\n&quot;,getpid());</span><br><span class="line">	InetAddress listenAddr(8888);</span><br><span class="line">	EventLoop loop;</span><br><span class="line">	TestServer server(&amp;loop,listenAddr);</span><br><span class="line">	server.start();</span><br><span class="line">	loop.loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段示例代码可以实现chargen服务程序</p>
<p>“chargen” 是指字符发生器（Character Generator）服务程序。它是一种网络服务，最初用于测试和诊断网络连接。</p>
<p>chargen 服务程序会向连接到它的客户端发送一系列 ASCII 字符。这些字符通常是可打印字符的连续序列，如字母、数字和标点符号等。服务程序以循环的方式生成字符，并不停地发送给客户端，直到连接关闭为止。</p>
<p>chargen 服务通常用于测试网络传输的稳定性和性能。通过向客户端发送大量的字符数据，可以模拟网络流量的负载情况。这对于查找网络传输问题、测量网络带宽的上限以及评估系统的抗压能力等方面非常有用。</p>
<p>然而，由于 chargen 服务产生大量的网络流量，可能会导致网络拥塞和安全问题。因此，在实际应用中，chargen 服务通常不会被广泛使用，并且在许多系统中默认关闭或禁用。可以用于进行DoS攻击。</p>
<h1 id="muduo库对编写tcp客户端程序的支持"><a href="#muduo库对编写tcp客户端程序的支持" class="headerlink" title="muduo库对编写tcp客户端程序的支持"></a>muduo库对编写tcp客户端程序的支持</h1><h2 id="Connector-h"><a href="#Connector-h" class="headerlink" title="Connector.h"></a>Connector.h</h2><p>主动发起连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_NET_CONNECTOR_H</span><br><span class="line">#define MUDUO_NET_CONNECTOR_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/noncopyable.h&quot;</span><br><span class="line">#include &quot;muduo/net/InetAddress.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">class Channel;</span><br><span class="line">class EventLoop;</span><br><span class="line"></span><br><span class="line">//主动发起连接，带有自动重连功能</span><br><span class="line">class Connector : noncopyable,</span><br><span class="line">                  public std::enable_shared_from_this&lt;Connector&gt;</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  typedef std::function&lt;void (int sockfd)&gt; NewConnectionCallback;</span><br><span class="line"></span><br><span class="line">  Connector(EventLoop* loop, const InetAddress&amp; serverAddr);</span><br><span class="line">  ~Connector();</span><br><span class="line"></span><br><span class="line">  void setNewConnectionCallback(const NewConnectionCallback&amp; cb)</span><br><span class="line">  &#123; newConnectionCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line">  void start();  // can be called in any thread</span><br><span class="line">  void restart();  // must be called in loop thread</span><br><span class="line">  void stop();  // can be called in any thread</span><br><span class="line"></span><br><span class="line">  const InetAddress&amp; serverAddress() const &#123; return serverAddr_; &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  enum States &#123; kDisconnected, kConnecting, kConnected &#125;;</span><br><span class="line">  static const int kMaxRetryDelayMs = 30*1000;//38秒，最大重连延迟时间</span><br><span class="line">  static const int kInitRetryDelayMs = 500;  //0.5秒，初始状态，连接不上，0.5秒后重连</span><br><span class="line"></span><br><span class="line">  void setState(States s) &#123; state_ = s; &#125;</span><br><span class="line">  void startInLoop();</span><br><span class="line">  void stopInLoop();</span><br><span class="line">  void connect();</span><br><span class="line">  void connecting(int sockfd);</span><br><span class="line">  void handleWrite();</span><br><span class="line">  void handleError();</span><br><span class="line">  void retry(int sockfd);</span><br><span class="line">  int removeAndResetChannel();</span><br><span class="line">  void resetChannel();</span><br><span class="line"></span><br><span class="line">  EventLoop* loop_;//所属EventLoop</span><br><span class="line">  InetAddress serverAddr_;//服务器端地址</span><br><span class="line">  bool connect_; // atomic</span><br><span class="line">  States state_;  // FIXME: use atomic variable</span><br><span class="line">  std::unique_ptr&lt;Channel&gt; channel_;//connector所对应的Channel</span><br><span class="line">  NewConnectionCallback newConnectionCallback_;//连接成功回调函数</span><br><span class="line">  int retryDelayMs_;//重连延迟时间（单位：毫秒）</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_NET_CONNECTOR_H</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Connector-cc"><a href="#Connector-cc" class="headerlink" title="Connector.cc"></a>Connector.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line">//可以跨线程调用</span><br><span class="line">void Connector::start()</span><br><span class="line">&#123;</span><br><span class="line">  connect_ = true;</span><br><span class="line">  loop_-&gt;runInLoop(std::bind(&amp;Connector::startInLoop, this)); // FIXME: unsafe</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Connector::startInLoop()</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  assert(state_ == kDisconnected);</span><br><span class="line">  if (connect_)</span><br><span class="line">  &#123;</span><br><span class="line">    connect();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_DEBUG &lt;&lt; &quot;do not connect&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Connector::stop()</span><br><span class="line">&#123;</span><br><span class="line">  connect_ = false;</span><br><span class="line">  loop_-&gt;queueInLoop(std::bind(&amp;Connector::stopInLoop, this)); // FIXME: unsafe</span><br><span class="line">  // FIXME: cancel timer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Connector::stopInLoop()</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  if (state_ == kConnecting)</span><br><span class="line">  &#123;</span><br><span class="line">    setState(kDisconnected);</span><br><span class="line">    int sockfd = removeAndResetChannel();//将通道从poller中移除关注，并将channel置空</span><br><span class="line">    retry(sockfd);//这里并非要重连，只是调用sockets::close(sockfd);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Connector::connect()</span><br><span class="line">&#123;</span><br><span class="line">  int sockfd = sockets::createNonblockingOrDie(serverAddr_.family());//创建非阻塞套接字</span><br><span class="line">  int ret = sockets::connect(sockfd, serverAddr_.getSockAddr());</span><br><span class="line">  int savedErrno = (ret == 0) ? 0 : errno;</span><br><span class="line">  switch (savedErrno)</span><br><span class="line">  &#123;</span><br><span class="line">    case 0:</span><br><span class="line">    case EINPROGRESS://非阻塞套接字，未连接成功返回码是EINPROGRESs表示正在连接</span><br><span class="line">    case EINTR:</span><br><span class="line">    case EISCONN:   //连接成功</span><br><span class="line">      connecting(sockfd);</span><br><span class="line">      break;</span><br><span class="line"></span><br><span class="line">    case EAGAIN:</span><br><span class="line">    case EADDRINUSE:</span><br><span class="line">    case EADDRNOTAVAIL:</span><br><span class="line">    case ECONNREFUSED:</span><br><span class="line">    case ENETUNREACH:</span><br><span class="line">      retry(sockfd);//重连</span><br><span class="line">      break;</span><br><span class="line"></span><br><span class="line">    case EACCES:</span><br><span class="line">    case EPERM:</span><br><span class="line">    case EAFNOSUPPORT:</span><br><span class="line">    case EALREADY:</span><br><span class="line">    case EBADF:</span><br><span class="line">    case EFAULT:</span><br><span class="line">    case ENOTSOCK:</span><br><span class="line">      LOG_SYSERR &lt;&lt; &quot;connect error in Connector::startInLoop &quot; &lt;&lt; savedErrno;</span><br><span class="line">      sockets::close(sockfd);//不能重连，关闭sockfd</span><br><span class="line">      break;</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">      LOG_SYSERR &lt;&lt; &quot;Unexpected error in Connector::startInLoop &quot; &lt;&lt; savedErrno;</span><br><span class="line">      sockets::close(sockfd);</span><br><span class="line">      // connectErrorCallback_();</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Connector::restart()</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  setState(kDisconnected);</span><br><span class="line">  retryDelayMs_ = kInitRetryDelayMs;</span><br><span class="line">  connect_ = true;</span><br><span class="line">  startInLoop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Connector::connecting(int sockfd)</span><br><span class="line">&#123;</span><br><span class="line">  setState(kConnecting);</span><br><span class="line">  assert(!channel_);</span><br><span class="line">  //channel与sockfd关联</span><br><span class="line">  channel_.reset(new Channel(loop_, sockfd));</span><br><span class="line">  //设置可写回调函数，这时候如果socket没有错误，sockfd就处于可写状态</span><br><span class="line">  channel_-&gt;setWriteCallback(</span><br><span class="line">      std::bind(&amp;Connector::handleWrite, this)); // FIXME: unsafe</span><br><span class="line">  channel_-&gt;setErrorCallback(</span><br><span class="line">      std::bind(&amp;Connector::handleError, this)); // FIXME: unsafe</span><br><span class="line"></span><br><span class="line">  // channel_-&gt;tie(shared_from_this()); is not working,</span><br><span class="line">  // as channel_ is not managed by shared_ptr</span><br><span class="line">  channel_-&gt;enableWriting();//让poller关注可写事件</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Connector::removeAndResetChannel()</span><br><span class="line">&#123;</span><br><span class="line">  channel_-&gt;disableAll();</span><br><span class="line">  channel_-&gt;remove();</span><br><span class="line">  int sockfd = channel_-&gt;fd();</span><br><span class="line">  // Can&#x27;t reset channel_ here, because we are inside Channel::handleEvent</span><br><span class="line">  //不能在这里重置channel_，因为正在调用Channel::handleEvent</span><br><span class="line">  loop_-&gt;queueInLoop(std::bind(&amp;Connector::resetChannel, this)); // FIXME: unsafe</span><br><span class="line">  return sockfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Connector::resetChannel()</span><br><span class="line">&#123;</span><br><span class="line">  channel_.reset();//channle_置空</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Connector::handleWrite()</span><br><span class="line">&#123;</span><br><span class="line">  LOG_TRACE &lt;&lt; &quot;Connector::handleWrite &quot; &lt;&lt; state_;</span><br><span class="line"></span><br><span class="line">  if (state_ == kConnecting)</span><br><span class="line">  &#123;</span><br><span class="line">    int sockfd = removeAndResetChannel();//从poller中移除关注，并将channel置空</span><br><span class="line">    //socket可写并不意味着连接一定建立成功</span><br><span class="line">    //还需要用getsockopt(sockfd, SOL_SOCKET，SO_ERROR，.….)再次确认一下.</span><br><span class="line">    int err = sockets::getSocketError(sockfd);</span><br><span class="line">    if (err)</span><br><span class="line">    &#123;</span><br><span class="line">      LOG_WARN &lt;&lt; &quot;Connector::handleWrite - SO_ERROR = &quot;</span><br><span class="line">               &lt;&lt; err &lt;&lt; &quot; &quot; &lt;&lt; strerror_tl(err);</span><br><span class="line">      retry(sockfd);//重连</span><br><span class="line">    &#125;</span><br><span class="line">    //sockets::isSelfConnect函数的作用是通过比较本地地址和对端地址的端口号和IP地址，判断一个连接是否为自连接</span><br><span class="line">    //在网络编程中，自连接指的是本地主机与自身之间建立的连接。这种情况通常发生在客户端和服务器运行在同一台主机上，且使用相同的地址和端口进行通信的情况下</span><br><span class="line">    else if (sockets::isSelfConnect(sockfd))//自连接</span><br><span class="line">    &#123;</span><br><span class="line">      LOG_WARN &lt;&lt; &quot;Connector::handleWrite - Self connect&quot;;</span><br><span class="line">      retry(sockfd);//重连</span><br><span class="line">    &#125;</span><br><span class="line">    else//连接成功</span><br><span class="line">    &#123;</span><br><span class="line">      setState(kConnected);</span><br><span class="line">      if (connect_)</span><br><span class="line">      &#123;</span><br><span class="line">        newConnectionCallback_(sockfd);//回调</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        sockets::close(sockfd);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    // what happened?</span><br><span class="line">    assert(state_ == kDisconnected);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Connector::handleError()</span><br><span class="line">&#123;</span><br><span class="line">  LOG_ERROR &lt;&lt; &quot;Connector::handleError state=&quot; &lt;&lt; state_;</span><br><span class="line">  if (state_ == kConnecting)</span><br><span class="line">  &#123;</span><br><span class="line">    int sockfd = removeAndResetChannel();//从poller中移除关注，并将channel置空</span><br><span class="line">    //需要移除对可写事件的关注的原因是已经建立了与服务器的连接。在连接成功后，我们不再需要关注套接字是否可写，因为我们已经知道它是可写的。移除对可写事件的关注可以减少不必要的事件通知和资源消耗</span><br><span class="line">    int err = sockets::getSocketError(sockfd);</span><br><span class="line">    LOG_TRACE &lt;&lt; &quot;SO_ERROR = &quot; &lt;&lt; err &lt;&lt; &quot; &quot; &lt;&lt; strerror_tl(err);</span><br><span class="line">    retry(sockfd);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//采用back-off策略重连，即重连时间逐渐延长，0.5s，1s，2s，...直至30s</span><br><span class="line">void Connector::retry(int sockfd)</span><br><span class="line">&#123;</span><br><span class="line">  sockets::close(sockfd);</span><br><span class="line">  setState(kDisconnected);</span><br><span class="line">  if (connect_)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_INFO &lt;&lt; &quot;Connector::retry - Retry connecting to &quot; &lt;&lt; serverAddr_.toIpPort()</span><br><span class="line">             &lt;&lt; &quot; in &quot; &lt;&lt; retryDelayMs_ &lt;&lt; &quot; milliseconds. &quot;;</span><br><span class="line">    //注册一个定时操作，重连</span><br><span class="line">    loop_-&gt;runAfter(retryDelayMs_/1000.0,</span><br><span class="line">                    std::bind(&amp;Connector::startInLoop, shared_from_this()));</span><br><span class="line">    retryDelayMs_ = std::min(retryDelayMs_ * 2, kMaxRetryDelayMs);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_DEBUG &lt;&lt; &quot;do not connect&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="TcpClient-h"><a href="#TcpClient-h" class="headerlink" title="TcpClient.h"></a>TcpClient.h</h2><p>包含了一个Connector对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_NET_TCPCLIENT_H</span><br><span class="line">#define MUDUO_NET_TCPCLIENT_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Mutex.h&quot;</span><br><span class="line">#include &quot;muduo/net/TcpConnection.h&quot;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">class Connector;</span><br><span class="line">typedef std::shared_ptr&lt;Connector&gt; ConnectorPtr;</span><br><span class="line"></span><br><span class="line">class TcpClient : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  // TcpClient(EventLoop* loop);</span><br><span class="line">  // TcpClient(EventLoop* loop, const string&amp; host, uint16_t port);</span><br><span class="line">  TcpClient(EventLoop* loop,</span><br><span class="line">            const InetAddress&amp; serverAddr,</span><br><span class="line">            const string&amp; nameArg);</span><br><span class="line">  ~TcpClient();  // force out-line dtor, for std::unique_ptr members.</span><br><span class="line"></span><br><span class="line">  void connect();</span><br><span class="line">  void disconnect();</span><br><span class="line">  void stop();</span><br><span class="line"></span><br><span class="line">  TcpConnectionPtr connection() const</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    return connection_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  EventLoop* getLoop() const &#123; return loop_; &#125;</span><br><span class="line">  bool retry() const &#123; return retry_; &#125;</span><br><span class="line">  void enableRetry() &#123; retry_ = true; &#125;</span><br><span class="line"></span><br><span class="line">  const string&amp; name() const</span><br><span class="line">  &#123; return name_; &#125;</span><br><span class="line"></span><br><span class="line">  /// Set connection callback.</span><br><span class="line">  /// Not thread safe.</span><br><span class="line">  void setConnectionCallback(ConnectionCallback cb)</span><br><span class="line">  &#123; connectionCallback_ = std::move(cb); &#125;</span><br><span class="line"></span><br><span class="line">  /// Set message callback.</span><br><span class="line">  /// Not thread safe.</span><br><span class="line">  void setMessageCallback(MessageCallback cb)</span><br><span class="line">  &#123; messageCallback_ = std::move(cb); &#125;</span><br><span class="line"></span><br><span class="line">  /// Set write complete callback.</span><br><span class="line">  /// Not thread safe.</span><br><span class="line">  void setWriteCompleteCallback(WriteCompleteCallback cb)</span><br><span class="line">  &#123; writeCompleteCallback_ = std::move(cb); &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  /// Not thread safe, but in loop</span><br><span class="line">  void newConnection(int sockfd);</span><br><span class="line">  /// Not thread safe, but in loop</span><br><span class="line">  void removeConnection(const TcpConnectionPtr&amp; conn);</span><br><span class="line"></span><br><span class="line">  EventLoop* loop_;</span><br><span class="line">  ConnectorPtr connector_; // avoid revealing Connector,用于主动发起连接</span><br><span class="line">  const string name_;//名称</span><br><span class="line">  ConnectionCallback connectionCallback_;//连接建立回调函数</span><br><span class="line">  MessageCallback messageCallback_;//消息到来回调函数</span><br><span class="line">  WriteCompleteCallback writeCompleteCallback_;//数据发送完毕回调函数</span><br><span class="line">  bool retry_;   // atomic，重连，是指连接建立之后又断开的时候是否重连</span><br><span class="line">  bool connect_; // atomic</span><br><span class="line">  // always in loop thread</span><br><span class="line">  int nextConnId_;//name_+nextConnId_用于标识一个连接</span><br><span class="line">  mutable MutexLock mutex_;</span><br><span class="line">  TcpConnectionPtr connection_ GUARDED_BY(mutex_);//Connector连接成功之后，得到一个TcpConnection</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_NET_TCPCLIENT_H</span><br></pre></td></tr></table></figure>

<h2 id="TcpClient-cc"><a href="#TcpClient-cc" class="headerlink" title="TcpClient.cc"></a>TcpClient.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (unique)</span><br><span class="line">&#123;</span><br><span class="line">    conn-&gt;forceClose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>connection_</code> 是唯一引用时，说明当前的 <code>TcpConnection</code> 实例没有其他智能指针指向它，也就意味着没有其他地方在使用这个连接对象。</p>
<p>在正常情况下，当需要关闭连接时，应该先发送TCP终止连接的相关消息（如FIN包），等待对方响应并进行优雅关闭的握手过程。这样可以确保数据的完整性和可靠性。</p>
<p>但是，在某些情况下，可能需要立即关闭连接，而不进行优雅关闭的握手过程。这些情况可能包括：</p>
<ol>
<li>程序逻辑需要：根据具体的业务需求，在某些特定的场景下，需要立即终止连接，而不等待握手过程完成。例如，发生了错误或异常情况，需要立即中断连接以防止进一步的数据传输。</li>
<li>资源回收：当 <code>TcpConnection</code> 对象没有其他引用时，为了及时释放与连接相关的资源，可以选择立即强制关闭连接，而不等待未来可能的操作。</li>
</ol>
<p>因此，当 <code>connection_</code> 是唯一引用时，调用 <code>forceClose()</code> 函数可以立即关闭连接，无需等待握手过程完成，以满足上述需求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line">namespace detail</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">void removeConnection(EventLoop* loop, const TcpConnectionPtr&amp; conn)</span><br><span class="line">&#123;</span><br><span class="line">  loop-&gt;queueInLoop(std::bind(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void removeConnector(const ConnectorPtr&amp; connector)</span><br><span class="line">&#123;</span><br><span class="line">  //connector-&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace detail</span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">TcpClient::TcpClient(EventLoop* loop,</span><br><span class="line">                     const InetAddress&amp; serverAddr,</span><br><span class="line">                     const string&amp; nameArg)</span><br><span class="line">  : loop_(CHECK_NOTNULL(loop)),</span><br><span class="line">    connector_(new Connector(loop, serverAddr)),</span><br><span class="line">    name_(nameArg),</span><br><span class="line">    connectionCallback_(defaultConnectionCallback),</span><br><span class="line">    messageCallback_(defaultMessageCallback),</span><br><span class="line">    retry_(false),</span><br><span class="line">    connect_(true),</span><br><span class="line">    nextConnId_(1)</span><br><span class="line">&#123;</span><br><span class="line">  connector_-&gt;setNewConnectionCallback(</span><br><span class="line">      std::bind(&amp;TcpClient::newConnection, this, _1));</span><br><span class="line">  // FIXME setConnectFailedCallback</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;TcpClient::TcpClient[&quot; &lt;&lt; name_</span><br><span class="line">           &lt;&lt; &quot;] - connector &quot; &lt;&lt; get_pointer(connector_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpClient::~TcpClient()</span><br><span class="line">&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;TcpClient::~TcpClient[&quot; &lt;&lt; name_</span><br><span class="line">           &lt;&lt; &quot;] - connector &quot; &lt;&lt; get_pointer(connector_);</span><br><span class="line">  TcpConnectionPtr conn;</span><br><span class="line">  bool unique = false;</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    unique = connection_.unique();//shared_ptr类的成员函数，用于判断该智能指针是否是唯一引用（即没有其他指针指向相同对象）</span><br><span class="line">    //如果当前智能指针是唯一引用，则返回true；否则，返回false</span><br><span class="line">    conn = connection_;</span><br><span class="line">  &#125;</span><br><span class="line">  if (conn)</span><br><span class="line">  &#123;</span><br><span class="line">    assert(loop_ == conn-&gt;getLoop());</span><br><span class="line">    // FIXME: not 100% safe, if we are in different thread</span><br><span class="line">    //重新设置TcpConnection中的closeCallback_为detail::removeConnection</span><br><span class="line">    CloseCallback cb = std::bind(&amp;detail::removeConnection, loop_, _1);</span><br><span class="line">    //不能调用TcpClient::removeConnection，因为它有重连功能</span><br><span class="line">    loop_-&gt;runInLoop(</span><br><span class="line">        std::bind(&amp;TcpConnection::setCloseCallback, conn, cb));</span><br><span class="line">    if (unique)</span><br><span class="line">    &#123;</span><br><span class="line">      conn-&gt;forceClose();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    //这种情况，说明connector处于未连接状态，将connector_停止</span><br><span class="line">    connector_-&gt;stop();</span><br><span class="line">    // FIXME: HACK</span><br><span class="line">    loop_-&gt;runAfter(1, std::bind(&amp;detail::removeConnector, connector_));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpClient::connect()</span><br><span class="line">&#123;</span><br><span class="line">  // FIXME: check state</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;TcpClient::connect[&quot; &lt;&lt; name_ &lt;&lt; &quot;] - connecting to &quot;</span><br><span class="line">           &lt;&lt; connector_-&gt;serverAddress().toIpPort();</span><br><span class="line">  connect_ = true;</span><br><span class="line">  connector_-&gt;start();</span><br><span class="line">&#125;</span><br><span class="line">//用于连接已建立的情况下，关闭连接</span><br><span class="line">void TcpClient::disconnect()</span><br><span class="line">&#123;</span><br><span class="line">  connect_ = false;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    if (connection_)</span><br><span class="line">    &#123;</span><br><span class="line">      connection_-&gt;shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//停止connector_,可能是连接尚未建立成功</span><br><span class="line">void TcpClient::stop()</span><br><span class="line">&#123;</span><br><span class="line">  connect_ = false;</span><br><span class="line">  connector_-&gt;stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpClient::newConnection(int sockfd)</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  InetAddress peerAddr(sockets::getPeerAddr(sockfd));</span><br><span class="line">  char buf[32];</span><br><span class="line">  snprintf(buf, sizeof buf, &quot;:%s#%d&quot;, peerAddr.toIpPort().c_str(), nextConnId_);</span><br><span class="line">  ++nextConnId_;</span><br><span class="line">  string connName = name_ + buf;</span><br><span class="line"></span><br><span class="line">  InetAddress localAddr(sockets::getLocalAddr(sockfd));</span><br><span class="line">  // FIXME poll with zero timeout to double confirm the new connection</span><br><span class="line">  // FIXME use make_shared if necessary</span><br><span class="line">  TcpConnectionPtr conn(new TcpConnection(loop_,</span><br><span class="line">                                          connName,</span><br><span class="line">                                          sockfd,</span><br><span class="line">                                          localAddr,</span><br><span class="line">                                          peerAddr));</span><br><span class="line"></span><br><span class="line">  conn-&gt;setConnectionCallback(connectionCallback_);</span><br><span class="line">  conn-&gt;setMessageCallback(messageCallback_);</span><br><span class="line">  conn-&gt;setWriteCompleteCallback(writeCompleteCallback_);</span><br><span class="line">  conn-&gt;setCloseCallback(</span><br><span class="line">      std::bind(&amp;TcpClient::removeConnection, this, _1)); // FIXME: unsafe</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    connection_ = conn;//保存TcpConnection</span><br><span class="line">  &#125;</span><br><span class="line">  conn-&gt;connectEstablished();//这里回调connectionCallback_</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpClient::removeConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  assert(loop_ == conn-&gt;getLoop());</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    //GUARDED_BY(mutex_)体现在每次对connection_对象使用的时候都需要保护</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    assert(connection_ == conn);</span><br><span class="line">    connection_.reset();//重置</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  loop_-&gt;queueInLoop(std::bind(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class="line">  if (retry_ &amp;&amp; connect_)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_INFO &lt;&lt; &quot;TcpClient::connect[&quot; &lt;&lt; name_ &lt;&lt; &quot;] - Reconnecting to &quot;</span><br><span class="line">             &lt;&lt; connector_-&gt;serverAddress().toIpPort();</span><br><span class="line">    connector_-&gt;restart();//这里的重连是指连接建立成功之后被断开的重连</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="测试程序-1"><a href="#测试程序-1" class="headerlink" title="测试程序"></a>测试程序</h2><h3 id="TcpClient-test-cc-x2F-x2F-echo-client"><a href="#TcpClient-test-cc-x2F-x2F-echo-client" class="headerlink" title="TcpClient_test.cc &#x2F;&#x2F; echo client"></a>TcpClient_test.cc &#x2F;&#x2F; echo client</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">class TestClient&#123;</span><br><span class="line">public:</span><br><span class="line">	TestClient(EventLoop* loop，const InetAddress&amp; listenaddr)</span><br><span class="line">		:loop_(loop),</span><br><span class="line">		client_(loop.listenAddr,&quot;Testclient&quot;),</span><br><span class="line">		stdinchanne1_(loop，0)</span><br><span class="line">	&#123;</span><br><span class="line">		client_.setConnectionCallback(</span><br><span class="line">			boost::bind(&amp;TestClient::onConnection,this,_1));</span><br><span class="line">		//有消息到来回调函数</span><br><span class="line">		client_.setMessageCa11back(</span><br><span class="line">			boost::bind(&amp;TestClient::onMessage,this,_1,_2,_3));</span><br><span class="line">		//client_.enableRetry();客户端已经建立连接成功，因为某种意外断开，是否能够重连的标志</span><br><span class="line">		//标准输入缓冲区中有数据的时候，回调Testclient::handleRead</span><br><span class="line">		stdinChannel_.setReadCallback(boost::bind(&amp;TestClient::handleRead, this));</span><br><span class="line">		stdinChanne1_.enableReading();</span><br><span class="line">	&#125;</span><br><span class="line">	void connect()&#123;</span><br><span class="line">		client_.connect();</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	void:onConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">	&#123;</span><br><span class="line">		if( conn-&gt;connected())&#123;</span><br><span class="line">			printf(&quot;onconnection(): new connettion [%s]from %s\n&quot;,</span><br><span class="line">				conn-&gt;name()-&gt;c_str(),</span><br><span class="line">				conn-&gt;peerAddress().toIpPort().c_str());</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			printf(&quot;onconnection():connettion [%s] is down\n&quot;,</span><br><span class="line">				conn-&gt;name()-&gt;c_str());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	void onMessage(const TcpConnectionPtr&amp; conn,</span><br><span class="line">					Buffer* buf,</span><br><span class="line">					Timestamp receiveTime)</span><br><span class="line">	&#123;</span><br><span class="line">		muduo::string msg(buf-&gt;retrieveAllAsString());</span><br><span class="line">		printf(&quot;onMessage(): received %zd bytes from connection [%s] at %s\n&quot;,</span><br><span class="line">				msg.size(),</span><br><span class="line">				conn-&gt;name().c_str(),</span><br><span class="line">				receiveTime.toFormattedString().c_str());</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	//标准输入缓冲区中有数据的时候,回调该函数</span><br><span class="line">	void handleRead()&#123;</span><br><span class="line">		char buf[1024]=&#123;0&#125;;</span><br><span class="line">		fgets(buf,1024,stdin);</span><br><span class="line">		buf[str1en(buf)-1]=&#x27;\0&#x27;;//去除\n</span><br><span class="line">		client_.connection()-&gt;send(buf);</span><br><span class="line">	&#125;</span><br><span class="line">	EventLoop* loop_;</span><br><span class="line">	TcpClient client_;//具有自动重连功能，是指还没建立成功的时候</span><br><span class="line">	Channel stdinChannel;//标准输入chaanel</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">	printf( &quot;main(): pid = %d\n&quot;,getpid());</span><br><span class="line">	InetAddress serverAddr(&quot;127.0.0.1&quot;,8888);</span><br><span class="line">	EventLoop loop;</span><br><span class="line">	TestClient client(&amp;loop,serverAddr);</span><br><span class="line">	client.connect();</span><br><span class="line">	loop.loop();</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/08/16/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%885%EF%BC%89/" rel="prev" title="muduo-网络库（5）">
      <i class="fa fa-chevron-left"></i> muduo-网络库（5）
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/08/21/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-http%E5%BA%93-1/" rel="next" title="muduo-http库(1)">
      muduo-http库(1) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%8C%E5%96%84TcpConnection"><span class="nav-number">1.</span> <span class="nav-text">完善TcpConnection</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#WriteCompleteCallback%E5%90%AB%E4%B9%89"><span class="nav-number">1.1.</span> <span class="nav-text">WriteCompleteCallback含义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HighWaterMarkCallback%E5%90%AB%E4%B9%89"><span class="nav-number">1.2.</span> <span class="nav-text">HighWaterMarkCallback含义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#boost-any-context"><span class="nav-number">1.3.</span> <span class="nav-text">boost::any context_</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#std-any"><span class="nav-number">1.4.</span> <span class="nav-text">std::any</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#signal-SIGPIPE-SIG-IGN"><span class="nav-number">1.5.</span> <span class="nav-text">signal(SIGPIPE, SIG_IGN)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.6.</span> <span class="nav-text">可变类型解决方案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.7.</span> <span class="nav-text">测试程序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#muduo%E5%BA%93%E5%AF%B9%E7%BC%96%E5%86%99tcp%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%94%AF%E6%8C%81"><span class="nav-number">2.</span> <span class="nav-text">muduo库对编写tcp客户端程序的支持</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Connector-h"><span class="nav-number">2.1.</span> <span class="nav-text">Connector.h</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Connector-cc"><span class="nav-number">2.2.</span> <span class="nav-text">Connector.cc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TcpClient-h"><span class="nav-number">2.3.</span> <span class="nav-text">TcpClient.h</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TcpClient-cc"><span class="nav-number">2.4.</span> <span class="nav-text">TcpClient.cc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F-1"><span class="nav-number">2.5.</span> <span class="nav-text">测试程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TcpClient-test-cc-x2F-x2F-echo-client"><span class="nav-number">2.5.1.</span> <span class="nav-text">TcpClient_test.cc &#x2F;&#x2F; echo client</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">肖汇林</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">76</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">肖汇林</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
