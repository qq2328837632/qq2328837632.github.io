<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="目录结构   基础库      时间戳Timestamp类封装1&lt;base&#x2F;types.h&gt;  less_than_comparable    要求实现&lt;，可自动实现&gt;,&lt;&#x3D;,&gt;&#x3D; BOOST_STATIC_ASSERT 使用PRId64 Timestamp实现及测试 BOOST_STATIC_ASSERT编译时断言，现在是STATIC_AS">
<meta property="og:type" content="article">
<meta property="og:title" content="muduo-基础库（1）">
<meta property="og:url" content="http://example.com/2023/08/01/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/index.html">
<meta property="og:site_name" content="肖汇林的博客">
<meta property="og:description" content="目录结构   基础库      时间戳Timestamp类封装1&lt;base&#x2F;types.h&gt;  less_than_comparable    要求实现&lt;，可自动实现&gt;,&lt;&#x3D;,&gt;&#x3D; BOOST_STATIC_ASSERT 使用PRId64 Timestamp实现及测试 BOOST_STATIC_ASSERT编译时断言，现在是STATIC_AS">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230730155255822.png">
<meta property="og:image" content="http://example.com/2023/08/01/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230730155255822.png">
<meta property="og:image" content="http://example.com/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230730155339712.png">
<meta property="og:image" content="http://example.com/2023/08/01/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230730155339712.png">
<meta property="og:image" content="http://example.com/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230730155404611.png">
<meta property="og:image" content="http://example.com/2023/08/01/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230730155404611.png">
<meta property="og:image" content="http://example.com/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230730165438382.png">
<meta property="og:image" content="http://example.com/2023/08/01/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230730165438382.png">
<meta property="og:image" content="http://example.com/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230731161906596.png">
<meta property="og:image" content="http://example.com/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230801150628949.png">
<meta property="og:image" content="http://example.com/2023/08/01/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230801150628949.png">
<meta property="article:published_time" content="2023-08-01T04:04:15.000Z">
<meta property="article:modified_time" content="2023-08-19T08:40:28.071Z">
<meta property="article:author" content="肖汇林">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230730155255822.png">

<link rel="canonical" href="http://example.com/2023/08/01/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>muduo-基础库（1） | 肖汇林的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖汇林的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/01/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          muduo-基础库（1）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-01 12:04:15" itemprop="dateCreated datePublished" datetime="2023-08-01T12:04:15+08:00">2023-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-19 16:40:28" itemprop="dateModified" datetime="2023-08-19T16:40:28+08:00">2023-08-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p><img src="/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230730155255822.png" alt="image-20230730155255822"></p>
<img src="/2023/08/01/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230730155255822.png" class title="This is an test image">

<h2 id="基础库"><a href="#基础库" class="headerlink" title="基础库"></a>基础库</h2><p><img src="/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230730155339712.png" alt="image-20230730155339712"></p>
<img src="/2023/08/01/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230730155339712.png" class title="This is an test image">

<p><img src="/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230730155404611.png" alt="image-20230730155404611"></p>
<img src="/2023/08/01/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230730155404611.png" class title="This is an test image">

<h2 id="时间戳Timestamp类封装"><a href="#时间戳Timestamp类封装" class="headerlink" title="时间戳Timestamp类封装"></a>时间戳Timestamp类封装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;base/types.h&gt;</span><br></pre></td></tr></table></figure>

<p>less_than_comparable<br>    要求实现&lt;，可自动实现&gt;,&lt;&#x3D;,&gt;&#x3D;</p>
<p>BOOST_STATIC_ASSERT</p>
<p>使用PRId64</p>
<p>Timestamp实现及测试</p>
<p><strong>BOOST_STATIC_ASSERT</strong>编译时断言，现在是STATIC_ASSERT<br><strong>assert</strong>是运行时断言</p>
<p><code>static_assert</code> 是标准 C++ 的一部分，更为现代和推荐的用法，特别是在使用 C++11 及以上标准的项目中。而 <code>BOOST_STATIC_ASSERT</code> 则是为了兼容 C++03 标准而提供的 Boost 库中的宏，在旧的编译环境中可能会使用到。在使用时，根据项目的需求和所支持的 C++ 标准版本来选择使用哪种静态断言宏。</p>
<h3 id="使用PRld64"><a href="#使用PRld64" class="headerlink" title="使用PRld64"></a>使用PRld64</h3><p>int64_t用来表示64位整数，在32位系统中是long long int，在64位系统中是long int,所以打印int64_t的格式化方法是:<br><code>printf(&quot;%ld&quot;, value);// 64bit os</code></p>
<p><code>printf(&quot;%lld&quot;, value); // 32bit Os</code></p>
<p>跨平台的做法:<br><code>#define_STDC_FORMAT_MACROS</code>这是一个预处理指令，用于定义一个宏 <code>_STDC_FORMAT_MACROS</code>。在 <code>inttypes.h</code> 头文件中，如果检测到定义了这个宏，它将启用一系列与格式化整数类型相关的宏定义，包括 <code>PRId64</code>、<code>PRIu64</code> 等</p>
<p><code>#include &lt;inttypes.h&gt;</code>这是包含 C&#x2F;C++ 标准库中 <code>inttypes.h</code> 头文件的指令。<code>inttypes.h</code> 头文件提供了一系列用于处理整数类型的宏和格式说明符</p>
<p><code>#undef_STDC_FORMAT_MACROS</code>这是另一个预处理指令，用于取消之前定义的 <code>_STDC_FORMAT_MACROS</code> 宏。在包含完 <code>inttypes.h</code> 头文件之后，我们取消这个宏的定义，以防止它在后续代码中产生影响。</p>
<p><code>printf(&quot;%&quot;PRId64 &quot;\n&quot;, value);</code></p>
<p><img src="/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230730165438382.png" alt="image-20230730165438382"></p>
<img src="/2023/08/01/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230730165438382.png" class title="This is an test image">

<h3 id="Timestamp-h"><a href="#Timestamp-h" class="headerlink" title="Timestamp.h"></a>Timestamp.h</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#ifndef MUDUO_BASE_TIMESTAMP_H</span><br><span class="line">#define MUDUO_BASE_TIMESTAMP_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/copyable.h&quot;</span><br><span class="line">#include &quot;muduo/base/Types.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;boost/operators.hpp&gt;</span><br><span class="line"></span><br><span class="line">namespace muduo//namespace muduo 是一个命名空间（namespace），用于将一组相关的类、函数、变量等实体封装在一个逻辑上相互隔离的作用域中。这个命名空间在上述代码中包含了一个名为 Timestamp 的类以及与该类相关的一些函数和常量。</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">///</span><br><span class="line">/// Time stamp in UTC, in microseconds resolution.</span><br><span class="line">///</span><br><span class="line">/// This class is immutable.</span><br><span class="line">/// It&#x27;s recommended to pass it by value, since it&#x27;s passed in register on x64.</span><br><span class="line">///</span><br><span class="line">class Timestamp : public muduo::copyable,//是值语义，值语义是指对象的复制行为是复制其值而非引用。在 C++ 中，默认情况下，类的对象的复制行为是浅拷贝，即复制对象的成员变量的值，而不复制指向的资源</span><br><span class="line">                  public boost::equality_comparable&lt;Timestamp&gt;,</span><br><span class="line">                  public boost::less_than_comparable&lt;Timestamp&gt;</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  ///</span><br><span class="line">  /// Constucts an invalid Timestamp.</span><br><span class="line">  ///</span><br><span class="line">  Timestamp()</span><br><span class="line">    : microSecondsSinceEpoch_(0)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ///</span><br><span class="line">  /// Constucts a Timestamp at specific time</span><br><span class="line">  ///</span><br><span class="line">  /// @param microSecondsSinceEpoch</span><br><span class="line">  explicit Timestamp(int64_t microSecondsSinceEpochArg)</span><br><span class="line">    : microSecondsSinceEpoch_(microSecondsSinceEpochArg)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void swap(Timestamp&amp; that)</span><br><span class="line">  &#123;</span><br><span class="line">    std::swap(microSecondsSinceEpoch_, that.microSecondsSinceEpoch_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // default copy/assignment/dtor are Okay</span><br><span class="line"></span><br><span class="line">  string toString() const;</span><br><span class="line">  string toFormattedString(bool showMicroseconds = true) const;</span><br><span class="line"></span><br><span class="line">  bool valid() const &#123; return microSecondsSinceEpoch_ &gt; 0; &#125;</span><br><span class="line"></span><br><span class="line">  // for internal usage.</span><br><span class="line">  int64_t microSecondsSinceEpoch() const &#123; return microSecondsSinceEpoch_; &#125;</span><br><span class="line">  time_t secondsSinceEpoch() const</span><br><span class="line">  &#123; return static_cast&lt;time_t&gt;(microSecondsSinceEpoch_ / kMicroSecondsPerSecond); &#125;</span><br><span class="line"></span><br><span class="line">  ///</span><br><span class="line">  /// Get time of now.</span><br><span class="line">  ///</span><br><span class="line">  static Timestamp now();</span><br><span class="line">  static Timestamp invalid()</span><br><span class="line">  &#123;</span><br><span class="line">    return Timestamp();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static Timestamp fromUnixTime(time_t t)</span><br><span class="line">  &#123;</span><br><span class="line">    return fromUnixTime(t, 0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static Timestamp fromUnixTime(time_t t, int microseconds)</span><br><span class="line">  &#123;</span><br><span class="line">    return Timestamp(static_cast&lt;int64_t&gt;(t) * kMicroSecondsPerSecond + microseconds);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static const int kMicroSecondsPerSecond = 1000 * 1000;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  int64_t microSecondsSinceEpoch_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inline bool operator&lt;(Timestamp lhs, Timestamp rhs)//声明和定义都在.h文件</span><br><span class="line">&#123;</span><br><span class="line">  return lhs.microSecondsSinceEpoch() &lt; rhs.microSecondsSinceEpoch();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline bool operator==(Timestamp lhs, Timestamp rhs)//实现&lt;，可自动实现&gt;,&lt;=,&gt;=</span><br><span class="line">&#123;</span><br><span class="line">  return lhs.microSecondsSinceEpoch() == rhs.microSecondsSinceEpoch();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///</span><br><span class="line">/// Gets time difference of two timestamps, result in seconds.</span><br><span class="line">///</span><br><span class="line">/// @param high, low</span><br><span class="line">/// @return (high-low) in seconds</span><br><span class="line">/// @c double has 52-bit precision, enough for one-microsecond</span><br><span class="line">/// resolution for next 100 years.</span><br><span class="line">inline double timeDifference(Timestamp high, Timestamp low)</span><br><span class="line">&#123;</span><br><span class="line">  int64_t diff = high.microSecondsSinceEpoch() - low.microSecondsSinceEpoch();</span><br><span class="line">  return static_cast&lt;double&gt;(diff) / Timestamp::kMicroSecondsPerSecond;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///</span><br><span class="line">/// Add @c seconds to given timestamp.</span><br><span class="line">///</span><br><span class="line">/// @return timestamp+seconds as Timestamp</span><br><span class="line">///</span><br><span class="line">inline Timestamp addTime(Timestamp timestamp, double seconds)</span><br><span class="line">&#123;</span><br><span class="line">  int64_t delta = static_cast&lt;int64_t&gt;(seconds * Timestamp::kMicroSecondsPerSecond);</span><br><span class="line">  return Timestamp(timestamp.microSecondsSinceEpoch() + delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_BASE_TIMESTAMP_H</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Timestamp-cc"><a href="#Timestamp-cc" class="headerlink" title="Timestamp.cc"></a>Timestamp.cc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Timestamp.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#ifndef __STDC_FORMAT_MACROS</span><br><span class="line">#define __STDC_FORMAT_MACROS</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#include &lt;inttypes.h&gt;//如果 __STDC_FORMAT_MACROS 宏未定义，就会将其定义为非零值，然后再包含 &lt;inttypes.h&gt; 头文件，从而确保特殊的格式化宏在代码中可用</span><br><span class="line"></span><br><span class="line">using namespace muduo;//是一个命名空间的使用声明语句。它的作用是将命名空间 muduo 中的所有符号（变量、函数、类等）引入到当前的代码作用域中，使得在代码中可以直接使用这些符号而无需显式指定命名空间前缀。</span><br><span class="line"></span><br><span class="line">static_assert(sizeof(Timestamp) == sizeof(int64_t),</span><br><span class="line">              &quot;Timestamp should be same size as int64_t&quot;);</span><br><span class="line">string Timestamp::toString() const</span><br><span class="line">&#123;</span><br><span class="line">  char buf[32] = &#123;0&#125;;</span><br><span class="line">  int64_t seconds = microSecondsSinceEpoch_ / kMicroSecondsPerSecond;</span><br><span class="line">  int64_t microseconds = microSecondsSinceEpoch_ % kMicroSecondsPerSecond;</span><br><span class="line">  snprintf(buf, sizeof(buf), &quot;%&quot; PRId64 &quot;.%06&quot; PRId64 &quot;&quot;, seconds, microseconds);</span><br><span class="line">  return buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string Timestamp::toFormattedString(bool showMicroseconds) const</span><br><span class="line">&#123;</span><br><span class="line">  char buf[64] = &#123;0&#125;;</span><br><span class="line">  time_t seconds = static_cast&lt;time_t&gt;(microSecondsSinceEpoch_ / kMicroSecondsPerSecond);</span><br><span class="line">  struct tm tm_time;</span><br><span class="line">  gmtime_r(&amp;seconds, &amp;tm_time);//gmtime_r 是 C 语言和 C++ 中的一个函数，用于将 Unix 时间戳（自 1970 年 1 月 1 日以来的秒数）转换为 UTC（协调世界时）时间的结构体表示。该函数的功能与 gmtime 类似，但具有线程安全的特性。</span><br><span class="line"></span><br><span class="line">  if (showMicroseconds)</span><br><span class="line">  &#123;</span><br><span class="line">    int microseconds = static_cast&lt;int&gt;(microSecondsSinceEpoch_ % kMicroSecondsPerSecond);</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%4d%02d%02d %02d:%02d:%02d.%06d&quot;,</span><br><span class="line">             tm_time.tm_year + 1900, tm_time.tm_mon + 1, tm_time.tm_mday,</span><br><span class="line">             tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec,</span><br><span class="line">             microseconds);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%4d%02d%02d %02d:%02d:%02d&quot;,</span><br><span class="line">             tm_time.tm_year + 1900, tm_time.tm_mon + 1, tm_time.tm_mday,</span><br><span class="line">             tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec);</span><br><span class="line">  &#125;</span><br><span class="line">  return buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Timestamp Timestamp::now()</span><br><span class="line">&#123;</span><br><span class="line">  struct timeval tv;</span><br><span class="line">  gettimeofday(&amp;tv, NULL);</span><br><span class="line">  int64_t seconds = tv.tv_sec;</span><br><span class="line">  return Timestamp(seconds * kMicroSecondsPerSecond + tv.tv_usec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">seconds * kMicroSecondsPerSecond + tv.tv_usec</span><br><span class="line">这是计算时间戳的微秒数部分。首先，将 seconds 中的秒数部分转换成微秒，即乘以 kMicroSecondsPerSecond，这个值等于 1,000,000，表示一秒有多少微秒。然后，将这个值与 tv.tv_usec 的微秒数部分相加，得到完整的时间戳的微秒数。</span><br><span class="line">return Timestamp(seconds * kMicroSecondsPerSecond + tv.tv_usec);</span><br><span class="line">最后，通过上述计算得到的完整时间戳的微秒数，创建一个 Timestamp 类的对象，并将其作为函数的返回值。</span><br><span class="line">这行代码的作用是获取当前时间，计算得到完整的时间戳（以微秒为单位），然后返回这个时间戳作为 Timestamp 类的对象。</span><br><span class="line">这个时间戳将用于创建一个 Timestamp 类的对象，并作为函数 Timestamp::now() 的返回值。所以该表达式实际上是用于计算返回值</span><br></pre></td></tr></table></figure>

<h3 id="Timestamp-unittest-cc"><a href="#Timestamp-unittest-cc" class="headerlink" title="Timestamp_unittest.cc"></a>Timestamp_unittest.cc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/Timestamp.h&quot;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using muduo::Timestamp;//它的作用是将命名空间 muduo 中的 Timestamp 类引入到当前的代码作用域中，使得在代码中可以直接使用 Timestamp 类而无需显式指定命名空间前缀</span><br><span class="line"></span><br><span class="line">void passByConstReference(const Timestamp&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;%s\n&quot;, x.toString().c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void passByValue(Timestamp x)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;%s\n&quot;, x.toString().c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void benchmark()</span><br><span class="line">&#123;</span><br><span class="line">  const int kNumber = 1000*1000;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;Timestamp&gt; stamps;</span><br><span class="line">  stamps.reserve(kNumber);</span><br><span class="line">  for (int i = 0; i &lt; kNumber; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    stamps.push_back(Timestamp::now());</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;%s\n&quot;, stamps.front().toString().c_str());</span><br><span class="line">  printf(&quot;%s\n&quot;, stamps.back().toString().c_str());</span><br><span class="line">  printf(&quot;%f\n&quot;, timeDifference(stamps.back(), stamps.front()));</span><br><span class="line"></span><br><span class="line">  int increments[100] = &#123; 0 &#125;;</span><br><span class="line">  int64_t start = stamps.front().microSecondsSinceEpoch();</span><br><span class="line">  for (int i = 1; i &lt; kNumber; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    int64_t next = stamps[i].microSecondsSinceEpoch();</span><br><span class="line">    int64_t inc = next - start;</span><br><span class="line">    start = next;</span><br><span class="line">    if (inc &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;reverse!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (inc &lt; 100)</span><br><span class="line">    &#123;</span><br><span class="line">      ++increments[inc];</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;big gap %d\n&quot;, static_cast&lt;int&gt;(inc));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for (int i = 0; i &lt; 100; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;%2d: %d\n&quot;, i, increments[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  Timestamp now(Timestamp::now());//这是一个对象的定义和初始化语句，它使用上述调用 now() 的结果来初始化一个名为 now 的 Timestamp 类对象。这里使用的是直接初始化的方式，通过调用 now() 函数得到的时间戳对象来初始化 now 对象</span><br><span class="line">  //相当于Timestamp now=Timestamp::now();调用拷贝构造函数初始化对象</span><br><span class="line">  printf(&quot;%s\n&quot;, now.toString().c_str());</span><br><span class="line">  passByValue(now);</span><br><span class="line">  passByConstReference(now);</span><br><span class="line">  benchmark();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tests下的CMake"><a href="#tests下的CMake" class="headerlink" title="tests下的CMake"></a>tests下的CMake</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_executable(timestamp_unittest Timestamp_unittest.cc)</span><br><span class="line">target_link_libraries(timestamp_unittest muduo_base)//target_link_libraries 命令用于将库（静态库或动态库）链接到目标（可执行文件或其他库）</span><br><span class="line">add_test(NAME timestamp_unittest COMMAND timestamp_unittest)</span><br></pre></td></tr></table></figure>

<h2 id="Atomic-h-执行原子性操作"><a href="#Atomic-h-执行原子性操作" class="headerlink" title="Atomic.h 执行原子性操作"></a>Atomic.h 执行原子性操作</h2><p>因为多线程用锁的话，是性能杀手，而原子性操作可以有同样效果，但是没有性能问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#ifndef MUDUO_BASE_ATOMIC_H</span><br><span class="line">#define MUDUO_BASE_ATOMIC_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/noncopyable.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">namespace detail</span><br><span class="line">&#123;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class AtomicIntegerT : noncopyable// noncopyable表示这个类不可拷贝的</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  AtomicIntegerT()</span><br><span class="line">    : value_(0)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // uncomment if you need copying and assignment</span><br><span class="line">  //复制构造函数用于创建一个新对象并将其初始化为传入对象的值</span><br><span class="line">  // AtomicIntegerT(const AtomicIntegerT&amp; that)</span><br><span class="line">  //   : value_(that.get())</span><br><span class="line">  // &#123;&#125;</span><br><span class="line">  //</span><br><span class="line">  // AtomicIntegerT&amp; operator=(const AtomicIntegerT&amp; that)//把等号运算符做成私有的</span><br><span class="line">  // &#123;</span><br><span class="line">  //   getAndSet(that.get());</span><br><span class="line">  //   return *this;</span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line">  T get()//原子地比较指定变量的值和期望值，如果相等则将该变量的值设置为新的值，并返回操作之前的值</span><br><span class="line">  &#123;</span><br><span class="line">    // in gcc &gt;= 4.7: __atomic_load_n(&amp;value_, __ATOMIC_SEQ_CST)</span><br><span class="line">    return __sync_val_compare_and_swap(&amp;value_, 0, 0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T getAndAdd(T x)//原子地将指定变量的值加上一个增量，并返回变量加增量后的结果</span><br><span class="line">  &#123;</span><br><span class="line">    // in gcc &gt;= 4.7: __atomic_fetch_add(&amp;value_, x, __ATOMIC_SEQ_CST)</span><br><span class="line">    return __sync_fetch_and_add(&amp;value_, x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T addAndGet(T x)</span><br><span class="line">  &#123;</span><br><span class="line">    return getAndAdd(x) + x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T incrementAndGet()</span><br><span class="line">  &#123;</span><br><span class="line">    return addAndGet(1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T decrementAndGet()</span><br><span class="line">  &#123;</span><br><span class="line">    return addAndGet(-1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void add(T x)</span><br><span class="line">  &#123;</span><br><span class="line">    getAndAdd(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void increment()</span><br><span class="line">  &#123;</span><br><span class="line">    incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void decrement()</span><br><span class="line">  &#123;</span><br><span class="line">    decrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T getAndSet(T newValue)</span><br><span class="line">  &#123;</span><br><span class="line">    // in gcc &gt;= 4.7: __atomic_exchange_n(&amp;value_, newValue, __ATOMIC_SEQ_CST)</span><br><span class="line">    return __sync_lock_test_and_set(&amp;value_, newValue);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  volatile T value_;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  // namespace detail</span><br><span class="line"></span><br><span class="line">typedef detail::AtomicIntegerT&lt;int32_t&gt; AtomicInt32;</span><br><span class="line">typedef detail::AtomicIntegerT&lt;int64_t&gt; AtomicInt64;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_BASE_ATOMIC_H</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在c++11下有更新</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;atomic&gt;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class AtomicIntegerT : noncopyable</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    AtomicIntegerT()</span><br><span class="line">        : value_(0)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T get()</span><br><span class="line">    &#123;</span><br><span class="line">        return value_.load(std::memory_order_seq_cst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T getAndAdd(T x)</span><br><span class="line">    &#123;</span><br><span class="line">        return value_.fetch_add(x, std::memory_order_seq_cst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T addAndGet(T x)</span><br><span class="line">    &#123;</span><br><span class="line">        return getAndAdd(x) + x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T incrementAndGet()</span><br><span class="line">    &#123;</span><br><span class="line">        return addAndGet(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T decrementAndGet()</span><br><span class="line">    &#123;</span><br><span class="line">        return addAndGet(-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void add(T x)</span><br><span class="line">    &#123;</span><br><span class="line">        getAndAdd(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void increment()</span><br><span class="line">    &#123;</span><br><span class="line">        incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void decrement()</span><br><span class="line">    &#123;</span><br><span class="line">        decrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T getAndSet(T newValue)</span><br><span class="line">    &#123;</span><br><span class="line">        return value_.exchange(newValue, std::memory_order_seq_cst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::atomic&lt;T&gt; value_;//具有volatile特性</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="测试文件Atomic-test-cc"><a href="#测试文件Atomic-test-cc" class="headerlink" title="测试文件Atomic_test.cc"></a>测试文件Atomic_test.cc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/Atomic.h&quot;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  &#123;</span><br><span class="line">  muduo::AtomicInt64 a0;</span><br><span class="line">  assert(a0.get() == 0);</span><br><span class="line">  assert(a0.getAndAdd(1) == 0);</span><br><span class="line">  assert(a0.get() == 1);</span><br><span class="line">  assert(a0.addAndGet(2) == 3);</span><br><span class="line">  assert(a0.get() == 3);</span><br><span class="line">  assert(a0.incrementAndGet() == 4);</span><br><span class="line">  assert(a0.get() == 4);</span><br><span class="line">  a0.increment();</span><br><span class="line">  assert(a0.get() == 5);</span><br><span class="line">  assert(a0.addAndGet(-3) == 2);</span><br><span class="line">  assert(a0.getAndSet(100) == 2);</span><br><span class="line">  assert(a0.get() == 100);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">  muduo::AtomicInt32 a1;</span><br><span class="line">  assert(a1.get() == 0);</span><br><span class="line">  assert(a1.getAndAdd(1) == 0);</span><br><span class="line">  assert(a1.get() == 1);</span><br><span class="line">  assert(a1.addAndGet(2) == 3);</span><br><span class="line">  assert(a1.get() == 3);</span><br><span class="line">  assert(a1.incrementAndGet() == 4);</span><br><span class="line">  assert(a1.get() == 4);</span><br><span class="line">  a1.increment();</span><br><span class="line">  assert(a1.get() == 5);</span><br><span class="line">  assert(a1.addAndGet(-3) == 2);</span><br><span class="line">  assert(a1.getAndSet(100) == 2);</span><br><span class="line">  assert(a1.get() == 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在tests下的CMake里不需要target_link_libraries，因为它没有编译静态库</span><br></pre></td></tr></table></figure>

<h3 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h3><p><img src="/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230731161906596.png" alt="image-20230731161906596"></p>
<h3 id="Types-h"><a href="#Types-h" class="headerlink" title="Types.h"></a>Types.h</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename To, typename From&gt;</span><br><span class="line">inline To implicit_cast(From const &amp;f)//隐式转换</span><br><span class="line">&#123;</span><br><span class="line">  return f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>好处是可以在没有前面代码的基础下能看懂是隐式转换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename To, typename From&gt;     // use like this: down_cast&lt;T*&gt;(foo);</span><br><span class="line">inline To down_cast(From* f)                     // so we only accept pointers</span><br><span class="line">&#123;//向下转型的函数</span><br><span class="line">  // Ensures that To is a sub-type of From *.  This test is here only</span><br><span class="line">  // for compile-time type checking, and has no overhead in an</span><br><span class="line">  // optimized build at run-time, as it will be optimized away</span><br><span class="line">  // completely.</span><br><span class="line">  if (false)</span><br><span class="line">  &#123;</span><br><span class="line">    implicit_cast&lt;From*, To&gt;(0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">#if !defined(NDEBUG) &amp;&amp; !defined(GOOGLE_PROTOBUF_NO_RTTI)</span><br><span class="line">  assert(f == NULL || dynamic_cast&lt;To&gt;(f) != NULL);  // RTTI: debug mode only!</span><br><span class="line">#endif</span><br><span class="line">  return static_cast&lt;To&gt;(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异常Exception封装"><a href="#异常Exception封装" class="headerlink" title="异常Exception封装"></a>异常Exception封装</h2><p>Exception类实现</p>
<ul>
<li><p>backtrace，栈回溯，保存各个栈帧的地址</p>
</li>
<li><p>backtrace_symbols，根据地址，转成相应的函数符号</p>
</li>
<li><p>abi: :__cxa_demangle,我这里使用了将<code>demangle</code>参数设置为ture可以进行符号解析以得到更具可读性的堆栈信息</p>
</li>
</ul>
<h3 id="Exception-h"><a href="#Exception-h" class="headerlink" title="Exception.h"></a>Exception.h</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#ifndef MUDUO_BASE_EXCEPTION_H</span><br><span class="line">#define MUDUO_BASE_EXCEPTION_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Types.h&quot;</span><br><span class="line">#include &lt;exception&gt;  </span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">class Exception : public std::exception</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  Exception(string what);</span><br><span class="line">  ~Exception() noexcept override = default;</span><br><span class="line"></span><br><span class="line">  // default copy-ctor and operator= are okay.</span><br><span class="line"></span><br><span class="line">  const char* what() const noexcept override</span><br><span class="line">  &#123;</span><br><span class="line">    return message_.c_str();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const char* stackTrace() const noexcept</span><br><span class="line">  //const 关键字在函数名后面表示该函数是一个常量成员函数。而 noexcept 关键字则表示该函数不会抛出异常</span><br><span class="line">  &#123;</span><br><span class="line">    return stack_.c_str();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  string message_;</span><br><span class="line">  string stack_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_BASE_EXCEPTION_H</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Exception-cc"><a href="#Exception-cc" class="headerlink" title="Exception.cc"></a>Exception.cc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Exception.h&quot;</span><br><span class="line">#include &quot;muduo/base/CurrentThread.h&quot;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Exception::Exception(string msg)</span><br><span class="line">  : message_(std::move(msg)),//std::move用于实现右值引用（rvalue reference）。它将一个左值（lvalue）强制转换为右值引用，从而可以实现移动语义，减少不必要的拷贝，提高代码的性能</span><br><span class="line">    stack_(CurrentThread::stackTrace(/*demangle=*/false))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>stack_(CurrentThread::stackTrace(/*demangle=*/false))</code>这行代码是在构造<code>Exception</code>对象时调用<code>stackTrace</code>函数，并将返回的字符串作为参数传递给<code>stack_</code>成员变量。</p>
<p>具体调用过程如下：</p>
<ol>
<li>在<code>Exception</code>类的构造函数中，使用<code>std::move(msg)</code>将传入的<code>msg</code>字符串初始化<code>message_</code>成员变量。</li>
<li>接着，调用<code>CurrentThread::stackTrace(/*demangle=*/false)</code>函数，获取当前线程的堆栈信息，<code>demangle</code>参数设置为<code>false</code>表示不需要进行符号解析（mangling）。</li>
<li><code>stackTrace</code>函数首先声明了一个字符串<code>stack</code>，用于存储堆栈信息。</li>
<li>接下来，通过<code>::backtrace()</code>函数获取当前线程的调用堆栈帧，并将返回的帧指针数组存储在<code>frame</code>中。</li>
<li>使用<code>::backtrace_symbols()</code>函数将帧指针数组转换为可读的字符串数组<code>strings</code>，每个字符串表示一个堆栈帧的信息。</li>
<li>然后，函数进入一个循环，遍历堆栈帧，处理每个帧的信息。</li>
<li>如果<code>demangle</code>为<code>true</code>，则尝试对符号进行解析，以得到可读的函数名和地址信息。这里使用<code>abi::__cxa_demangle()</code>进行符号解析。</li>
<li>解析得到的字符串会与原始的堆栈帧信息拼接，然后添加到<code>stack</code>字符串中，并添加一个换行符。</li>
<li>如果<code>demangle</code>为<code>false</code>或解析失败，将使用原始的堆栈帧信息添加到<code>stack</code>字符串中，并添加一个换行符。</li>
<li>最后，返回拼接好的<code>stack</code>字符串作为函数的返回值。</li>
<li>这个返回的字符串将被用来初始化<code>Exception</code>对象的<code>stack_</code>成员变量。</li>
</ol>
<p>总结：<code>stack_(CurrentThread::stackTrace(/*demangle=*/false))</code>调用了<code>stackTrace</code>函数并将返回的字符串作为堆栈信息赋值给<code>stack_</code>成员变量。</p>
<h3 id="CurrentThread-cc"><a href="#CurrentThread-cc" class="headerlink" title="CurrentThread.cc"></a>CurrentThread.cc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">string stackTrace(bool demangle)</span><br><span class="line">&#123;</span><br><span class="line">  string stack;</span><br><span class="line">  const int max_frames = 200;</span><br><span class="line">  void* frame[max_frames];</span><br><span class="line">  int nptrs = ::backtrace(frame, max_frames);</span><br><span class="line">  char** strings = ::backtrace_symbols(frame, nptrs);</span><br><span class="line">  if (strings)</span><br><span class="line">  &#123;</span><br><span class="line">    size_t len = 256;</span><br><span class="line">    char* demangled = demangle ? static_cast&lt;char*&gt;(::malloc(len)) : nullptr;</span><br><span class="line">    for (int i = 1; i &lt; nptrs; ++i)  // skipping the 0-th, which is this function</span><br><span class="line">    &#123;</span><br><span class="line">      if (demangle)</span><br><span class="line">      &#123;</span><br><span class="line">        // https://panthema.net/2008/0901-stacktrace-demangled/</span><br><span class="line">        // bin/exception_test(_ZN3Bar4testEv+0x79) [0x401909]</span><br><span class="line">        char* left_par = nullptr;</span><br><span class="line">        char* plus = nullptr;</span><br><span class="line">        for (char* p = strings[i]; *p; ++p)</span><br><span class="line">        &#123;</span><br><span class="line">          if (*p == &#x27;(&#x27;)</span><br><span class="line">            left_par = p;</span><br><span class="line">          else if (*p == &#x27;+&#x27;)</span><br><span class="line">            plus = p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (left_par &amp;&amp; plus)</span><br><span class="line">        &#123;</span><br><span class="line">          *plus = &#x27;\0&#x27;;</span><br><span class="line">          int status = 0;</span><br><span class="line">          char* ret = abi::__cxa_demangle(left_par+1, demangled, &amp;len, &amp;status);</span><br><span class="line">          *plus = &#x27;+&#x27;;</span><br><span class="line">          if (status == 0)</span><br><span class="line">          &#123;</span><br><span class="line">            demangled = ret;  // ret could be realloc()</span><br><span class="line">            stack.append(strings[i], left_par+1);</span><br><span class="line">            stack.append(demangled);</span><br><span class="line">            stack.append(plus);</span><br><span class="line">            stack.push_back(&#x27;\n&#x27;);</span><br><span class="line">            continue;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // Fallback to mangled names</span><br><span class="line">      stack.append(strings[i]);</span><br><span class="line">      stack.push_back(&#x27;\n&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    free(demangled);</span><br><span class="line">    free(strings);</span><br><span class="line">  &#125;</span><br><span class="line">  return stack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在C++中，双冒号<code>::</code>被用于两个主要目的：</p>
<ol>
<li>表示全局命名空间：在全局作用域中，<code>::</code>表示全局命名空间，例如<code>::function_name()</code>表示调用全局命名空间中的函数<code>function_name</code>。</li>
<li>限定类的作用域：在类的作用域中，<code>::</code>可以用于限定类的作用域，例如<code>Class::member_function()</code>表示调用类<code>Class</code>的成员函数<code>member_function</code>。</li>
</ol>
<p>对于<code>::backtrace()</code>这个函数，它不属于任何特定的类，所以双冒号<code>::</code>表示全局命名空间，这样可以在全局范围内调用<code>backtrace</code>函数。</p>
<h3 id="Exception-test-cc"><a href="#Exception-test-cc" class="headerlink" title="Exception_test.cc"></a>Exception_test.cc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/CurrentThread.h&quot;</span><br><span class="line">#include &quot;muduo/base/Exception.h&quot;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">class Bar</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  void test(std::vector&lt;std::string&gt; names = &#123;&#125;)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Stack:\n%s\n&quot;, muduo::CurrentThread::stackTrace(true).c_str());</span><br><span class="line">    [] &#123;</span><br><span class="line">      printf(&quot;Stack inside lambda:\n%s\n&quot;, muduo::CurrentThread::stackTrace(true).c_str());</span><br><span class="line">    &#125;();</span><br><span class="line">    std::function&lt;void()&gt; func([] &#123;</span><br><span class="line">      printf(&quot;Stack inside std::function:\n%s\n&quot;, muduo::CurrentThread::stackTrace(true).c_str());</span><br><span class="line">    &#125;);</span><br><span class="line">    func();</span><br><span class="line"></span><br><span class="line">    func = std::bind(&amp;Bar::callback, this);</span><br><span class="line">    func();</span><br><span class="line"></span><br><span class="line">    throw muduo::Exception(&quot;oops&quot;);</span><br><span class="line">    //会创建一个 muduo::Exception 类型的异常对象，并将其抛出。然后程序会搜索调用栈，查找适合处理该异常的异常处理代码。如果找不到合适的处理代码，程序将终止并显示异常信息，跳转到下面catch</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">   void callback()</span><br><span class="line">   &#123;</span><br><span class="line">     printf(&quot;Stack inside std::bind:\n%s\n&quot;, muduo::CurrentThread::stackTrace(true).c_str());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void foo()</span><br><span class="line">&#123;</span><br><span class="line">  Bar b;</span><br><span class="line">  b.test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  try</span><br><span class="line">  &#123;</span><br><span class="line">    foo();</span><br><span class="line">  &#125;</span><br><span class="line">  catch (const muduo::Exception&amp; ex)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;reason: %s\n&quot;, ex.what());</span><br><span class="line">    printf(&quot;stack trace:\n%s\n&quot;, ex.stackTrace());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230801150628949.png" alt="image-20230801150628949"></p>
<img src="/2023/08/01/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230801150628949.png" class title="This is an test image">

<p>对throw muduo::Exception(“oops”);的理解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // 可能抛出异常的代码块</span><br><span class="line">    // ...</span><br><span class="line">    throw SomeException(&quot;Error message&quot;); // 抛出异常</span><br><span class="line">    // ...</span><br><span class="line">&#125; catch (const SomeException&amp; ex) &#123;</span><br><span class="line">    // 处理异常的代码块</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/07/27/muduo-1/" rel="prev" title="muduo-1">
      <i class="fa fa-chevron-left"></i> muduo-1
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/08/01/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%882%EF%BC%89/" rel="next" title="muduo-基础库（2）">
      muduo-基础库（2） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">目录结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E5%BA%93"><span class="nav-number">1.1.</span> <span class="nav-text">基础库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E6%88%B3Timestamp%E7%B1%BB%E5%B0%81%E8%A3%85"><span class="nav-number">1.2.</span> <span class="nav-text">时间戳Timestamp类封装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8PRld64"><span class="nav-number">1.2.1.</span> <span class="nav-text">使用PRld64</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Timestamp-h"><span class="nav-number">1.2.2.</span> <span class="nav-text">Timestamp.h</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Timestamp-cc"><span class="nav-number">1.2.3.</span> <span class="nav-text">Timestamp.cc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Timestamp-unittest-cc"><span class="nav-number">1.2.4.</span> <span class="nav-text">Timestamp_unittest.cc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tests%E4%B8%8B%E7%9A%84CMake"><span class="nav-number">1.2.5.</span> <span class="nav-text">tests下的CMake</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Atomic-h-%E6%89%A7%E8%A1%8C%E5%8E%9F%E5%AD%90%E6%80%A7%E6%93%8D%E4%BD%9C"><span class="nav-number">1.3.</span> <span class="nav-text">Atomic.h 执行原子性操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6Atomic-test-cc"><span class="nav-number">1.3.1.</span> <span class="nav-text">测试文件Atomic_test.cc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9"><span class="nav-number">1.3.2.</span> <span class="nav-text">编译选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Types-h"><span class="nav-number">1.3.3.</span> <span class="nav-text">Types.h</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8Exception%E5%B0%81%E8%A3%85"><span class="nav-number">1.4.</span> <span class="nav-text">异常Exception封装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Exception-h"><span class="nav-number">1.4.1.</span> <span class="nav-text">Exception.h</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exception-cc"><span class="nav-number">1.4.2.</span> <span class="nav-text">Exception.cc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CurrentThread-cc"><span class="nav-number">1.4.3.</span> <span class="nav-text">CurrentThread.cc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exception-test-cc"><span class="nav-number">1.4.4.</span> <span class="nav-text">Exception_test.cc</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">肖汇林</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">76</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">肖汇林</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
