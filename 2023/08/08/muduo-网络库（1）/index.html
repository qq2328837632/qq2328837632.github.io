<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="TCP网络编程本质TCP网络编程最本质是处理三个半事件  连接建立:服务器accept（被动）接受连接，客户端connect（主动）发起连接 连接断开:主动断开（close、shutdown），被动断开(read返回0) 消息到达:文件描述符可读 消息发送完毕:这算半个。对于低流量的服务，可不必关心这个事件;这里的发送完毕是指数据写入操作系统缓冲区，将由TCP协议栈负责数据的发送与重传不代表对方已">
<meta property="og:type" content="article">
<meta property="og:title" content="muduo-网络库（1）">
<meta property="og:url" content="http://example.com/2023/08/08/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/index.html">
<meta property="og:site_name" content="肖汇林的博客">
<meta property="og:description" content="TCP网络编程本质TCP网络编程最本质是处理三个半事件  连接建立:服务器accept（被动）接受连接，客户端connect（主动）发起连接 连接断开:主动断开（close、shutdown），被动断开(read返回0) 消息到达:文件描述符可读 消息发送完毕:这算半个。对于低流量的服务，可不必关心这个事件;这里的发送完毕是指数据写入操作系统缓冲区，将由TCP协议栈负责数据的发送与重传不代表对方已">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230808151011083.png">
<meta property="og:image" content="http://example.com/2023/08/08/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230808151011083.png">
<meta property="og:image" content="http://example.com/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230808152449591.png">
<meta property="og:image" content="http://example.com/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230809104948379.png">
<meta property="og:image" content="http://example.com/2023/08/08/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230809104948379.png">
<meta property="og:image" content="http://example.com/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230809113131684.png">
<meta property="og:image" content="http://example.com/2023/08/08/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230809113131684.png">
<meta property="og:image" content="http://example.com/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230809163337743.png">
<meta property="og:image" content="http://example.com/2023/08/08/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230809163337743.png">
<meta property="article:published_time" content="2023-08-08T03:10:38.000Z">
<meta property="article:modified_time" content="2023-08-13T07:57:20.458Z">
<meta property="article:author" content="肖汇林">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230808151011083.png">

<link rel="canonical" href="http://example.com/2023/08/08/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>muduo-网络库（1） | 肖汇林的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖汇林的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/08/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          muduo-网络库（1）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-08 11:10:38" itemprop="dateCreated datePublished" datetime="2023-08-08T11:10:38+08:00">2023-08-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-13 15:57:20" itemprop="dateModified" datetime="2023-08-13T15:57:20+08:00">2023-08-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="TCP网络编程本质"><a href="#TCP网络编程本质" class="headerlink" title="TCP网络编程本质"></a>TCP网络编程本质</h1><p>TCP网络编程最本质是处理三个半事件</p>
<ul>
<li>连接建立:服务器accept（被动）接受连接，客户端connect（主动）发起连接</li>
<li>连接断开:主动断开（close、shutdown），被动断开(read返回0)</li>
<li>消息到达:文件描述符可读</li>
<li>消息发送完毕:这算半个。对于低流量的服务，可不必关心这个事件;这里的发送完毕是指数据写入操作系统缓冲区，将由TCP协议栈负责数据的发送与重传不代表对方已经接收到数据。</li>
</ul>
<p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230808151011083.png" alt="image-20230808151011083"></p>
<img src="/2023/08/08/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230808151011083.png" class title="This is an test image">

<p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230808152449591.png" alt="image-20230808152449591"></p>
<p>也是基于对象编程思想</p>
<h1 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h1><ul>
<li>one loop per thread意思是说每个线程最多只能有一个EventLoop对象。</li>
<li>EventLoop对象构造的时候，会检查当前线程是否己经创建了具他EventLoop,如果已创建，终止程序（LOG FATAL)</li>
<li>EventLoop构造函数会记住本对象所属线程（threadld_)</li>
<li>创建了EventLoop对象的线程称为lO线程，其功能是运行事件循环（EventLoop::loop)</li>
</ul>
<h2 id="EventLoop-h部分"><a href="#EventLoop-h部分" class="headerlink" title="EventLoop.h部分"></a>EventLoop.h部分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">class Channel;</span><br><span class="line">class Poller;</span><br><span class="line">class TimerQueue;</span><br><span class="line"></span><br><span class="line">///</span><br><span class="line">/// Reactor, at most one per thread.</span><br><span class="line">///</span><br><span class="line">/// This is an interface class, so don&#x27;t expose too much details.</span><br><span class="line">class EventLoop : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  typedef std::function&lt;void()&gt; Functor;</span><br><span class="line"></span><br><span class="line">  EventLoop();</span><br><span class="line">  ~EventLoop();  // force out-line dtor, for std::unique_ptr members.</span><br><span class="line">  void updateChannel(Channel* channel);//在Poller中添加或更新通道</span><br><span class="line">  void removeChannel(Channel* channel);//从Poller中移除通道</span><br><span class="line">  // pid_t threadId() const &#123; return threadId_; &#125;</span><br><span class="line">  void assertInLoopThread()</span><br><span class="line">  &#123;</span><br><span class="line">    if (!isInLoopThread())</span><br><span class="line">    &#123;</span><br><span class="line">      abortNotInLoopThread();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  bool isInLoopThread() const &#123; return threadId_ == CurrentThread::tid(); &#125;</span><br><span class="line">  // bool callingPendingFunctors() const &#123; return callingPendingFunctors_; &#125;</span><br><span class="line">  bool eventHandling() const &#123; return eventHandling_; &#125;</span><br><span class="line"> private:</span><br><span class="line">  void abortNotInLoopThread();</span><br><span class="line">  void handleRead();  // waked up</span><br><span class="line">  void doPendingFunctors();</span><br><span class="line"></span><br><span class="line">  void printActiveChannels() const; // DEBUG</span><br><span class="line">  typedef std::vector&lt;Channel*&gt; ChannelList;</span><br><span class="line"></span><br><span class="line">  bool looping_; /* atomic */</span><br><span class="line">  std::atomic&lt;bool&gt; quit_;</span><br><span class="line">  bool eventHandling_; /* atomic */</span><br><span class="line">  bool callingPendingFunctors_; /* atomic */</span><br><span class="line">  int64_t iteration_;</span><br><span class="line">  const pid_t threadId_;//当前对象所属线程id</span><br><span class="line">  Timestamp pollReturnTime_;//调用poll返回的时间戳</span><br><span class="line">  std::unique_ptr&lt;Poller&gt; poller_;</span><br><span class="line">  std::unique_ptr&lt;TimerQueue&gt; timerQueue_;</span><br><span class="line">  ChannelList activeChannels_;//Poller返回的活动通道</span><br><span class="line">  Channel* currentActiveChannel_;//当前正在处理的活动通道</span><br><span class="line"></span><br><span class="line">  mutable MutexLock mutex_;</span><br><span class="line">  std::vector&lt;Functor&gt; pendingFunctors_ GUARDED_BY(mutex_);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h2 id="EventLoop-cc部分"><a href="#EventLoop-cc部分" class="headerlink" title="EventLoop.cc部分"></a>EventLoop.cc部分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">namespace</span><br><span class="line">&#123;</span><br><span class="line">//当前线程EventLoop对象指针</span><br><span class="line">//线程局部存储</span><br><span class="line">__thread EventLoop* t_loopInThisThread = 0;//__thread表示每个线程都有这样一个对象</span><br><span class="line"></span><br><span class="line">const int kPollTimeMs = 10000;</span><br><span class="line"></span><br><span class="line">int createEventfd()</span><br><span class="line">&#123;</span><br><span class="line">  int evtfd = ::eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC);</span><br><span class="line">  if (evtfd &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSERR &lt;&lt; &quot;Failed in eventfd&quot;;</span><br><span class="line">    abort();</span><br><span class="line">  &#125;</span><br><span class="line">  return evtfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma GCC diagnostic ignored &quot;-Wold-style-cast&quot;</span><br><span class="line">class IgnoreSigPipe</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  IgnoreSigPipe()</span><br><span class="line">  &#123;</span><br><span class="line">    ::signal(SIGPIPE, SIG_IGN);</span><br><span class="line">    // LOG_TRACE &lt;&lt; &quot;Ignore SIGPIPE&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">#pragma GCC diagnostic error &quot;-Wold-style-cast&quot;</span><br><span class="line"></span><br><span class="line">IgnoreSigPipe initObj;</span><br><span class="line">&#125;  // namespace 代码被放置在了匿名的 namespace 中。这意味着其中的内容只对当前文件中的代码可见，不会对其他文件中的代码造成影响。这在一定程度上隐藏了实现细节，限制了作用域，并且通过将 IgnoreSigPipe 类声明为 private，限制了类在文件之外的可见性。这样可以帮助控制代码的组织和维护，并减少了潜在的命名冲突。</span><br><span class="line">EventLoop* EventLoop::getEventLoopOfCurrentThread()</span><br><span class="line">&#123;</span><br><span class="line">  return t_loopInThisThread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventLoop::EventLoop()</span><br><span class="line">  : looping_(false),</span><br><span class="line">    quit_(false),</span><br><span class="line">    eventHandling_(false),</span><br><span class="line">    callingPendingFunctors_(false),</span><br><span class="line">    iteration_(0),</span><br><span class="line">    threadId_(CurrentThread::tid()),</span><br><span class="line">    poller_(Poller::newDefaultPoller(this)),</span><br><span class="line">    timerQueue_(new TimerQueue(this)),</span><br><span class="line">    wakeupFd_(createEventfd()),</span><br><span class="line">    wakeupChannel_(new Channel(this, wakeupFd_)),</span><br><span class="line">    currentActiveChannel_(NULL)</span><br><span class="line">&#123;</span><br><span class="line">  LOG_DEBUG &lt;&lt; &quot;EventLoop created &quot; &lt;&lt; this &lt;&lt; &quot; in thread &quot; &lt;&lt; threadId_;</span><br><span class="line">  //如果当前线程已经创建了EventLoop对象，终止（LOG_FATAL）</span><br><span class="line">  if (t_loopInThisThread)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_FATAL &lt;&lt; &quot;Another EventLoop &quot; &lt;&lt; t_loopInThisThread</span><br><span class="line">              &lt;&lt; &quot; exists in this thread &quot; &lt;&lt; threadId_;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    t_loopInThisThread = this;</span><br><span class="line">  &#125;</span><br><span class="line">  wakeupChannel_-&gt;setReadCallback(</span><br><span class="line">      std::bind(&amp;EventLoop::handleRead, this));</span><br><span class="line">  // we are always reading the wakeupfd</span><br><span class="line">  wakeupChannel_-&gt;enableReading();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventLoop::~EventLoop()</span><br><span class="line">&#123;</span><br><span class="line">  LOG_DEBUG &lt;&lt; &quot;EventLoop &quot; &lt;&lt; this &lt;&lt; &quot; of thread &quot; &lt;&lt; threadId_</span><br><span class="line">            &lt;&lt; &quot; destructs in thread &quot; &lt;&lt; CurrentThread::tid();</span><br><span class="line">  wakeupChannel_-&gt;disableAll();</span><br><span class="line">  wakeupChannel_-&gt;remove();</span><br><span class="line">  ::close(wakeupFd_);</span><br><span class="line">  t_loopInThisThread = NULL;</span><br><span class="line">&#125;</span><br><span class="line">//事件循环，该函数不能跨线程调用</span><br><span class="line">//只能在创建该对象的线程中调用</span><br><span class="line">void EventLoop::loop()</span><br><span class="line">&#123;</span><br><span class="line">  assert(!looping_);</span><br><span class="line">  assertInLoopThread();//断言当前处于创建该对象的线程中</span><br><span class="line">  looping_ = true;</span><br><span class="line">  quit_ = false;  // FIXME: what if someone calls quit() before loop() ?</span><br><span class="line">  LOG_TRACE &lt;&lt; &quot;EventLoop &quot; &lt;&lt; this &lt;&lt; &quot; start looping&quot;;</span><br><span class="line"></span><br><span class="line">  while (!quit_)</span><br><span class="line">  &#123;</span><br><span class="line">    activeChannels_.clear();</span><br><span class="line">    pollReturnTime_ = poller_-&gt;poll(kPollTimeMs, &amp;activeChannels_);</span><br><span class="line">    ++iteration_;</span><br><span class="line">    if (Logger::logLevel() &lt;= Logger::TRACE)</span><br><span class="line">    &#123;</span><br><span class="line">      printActiveChannels();</span><br><span class="line">    &#125;</span><br><span class="line">    // TODO sort channel by priority</span><br><span class="line">    eventHandling_ = true;</span><br><span class="line">    for (Channel* channel : activeChannels_)</span><br><span class="line">    &#123;</span><br><span class="line">      currentActiveChannel_ = channel;</span><br><span class="line">      currentActiveChannel_-&gt;handleEvent(pollReturnTime_);</span><br><span class="line">    &#125;</span><br><span class="line">    currentActiveChannel_ = NULL;</span><br><span class="line">    eventHandling_ = false;</span><br><span class="line">    doPendingFunctors();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LOG_TRACE &lt;&lt; &quot;EventLoop &quot; &lt;&lt; this &lt;&lt; &quot; stop looping&quot;;</span><br><span class="line">  looping_ = false;</span><br><span class="line">&#125;</span><br><span class="line">void EventLoop::updateChannel(Channel* channel)</span><br><span class="line">&#123;</span><br><span class="line">  assert(channel-&gt;ownerLoop() == this);</span><br><span class="line">  assertInLoopThread();</span><br><span class="line">  poller_-&gt;updateChannel(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void EventLoop::removeChannel(Channel* channel)</span><br><span class="line">&#123;</span><br><span class="line">  assert(channel-&gt;ownerLoop() == this);</span><br><span class="line">  assertInLoopThread();</span><br><span class="line">  if (eventHandling_)</span><br><span class="line">  &#123;</span><br><span class="line">    assert(currentActiveChannel_ == channel ||</span><br><span class="line">        std::find(activeChannels_.begin(), activeChannels_.end(), channel) == activeChannels_.end());</span><br><span class="line">  &#125;</span><br><span class="line">  poller_-&gt;removeChannel(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool EventLoop::hasChannel(Channel* channel)</span><br><span class="line">&#123;</span><br><span class="line">  assert(channel-&gt;ownerLoop() == this);</span><br><span class="line">  assertInLoopThread();</span><br><span class="line">  return poller_-&gt;hasChannel(channel);</span><br><span class="line">&#125;</span><br><span class="line">//终止程序</span><br><span class="line">void EventLoop::abortNotInLoopThread()</span><br><span class="line">&#123;</span><br><span class="line">  LOG_FATAL &lt;&lt; &quot;EventLoop::abortNotInLoopThread - EventLoop &quot; &lt;&lt; this</span><br><span class="line">            &lt;&lt; &quot; was created in threadId_ = &quot; &lt;&lt; threadId_</span><br><span class="line">            &lt;&lt; &quot;, current thread id = &quot; &lt;&lt;  CurrentThread::tid();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="muduo网络库相关类图的关系"><a href="#muduo网络库相关类图的关系" class="headerlink" title="muduo网络库相关类图的关系"></a>muduo网络库相关类图的关系</h1><p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230809104948379.png" alt="image-20230809104948379"></p>
<img src="/2023/08/08/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230809104948379.png" class title="This is an test image">

<p>白色的是外部类，对外是可见的，黑色的是内部类，对外是不可见的</p>
<p>Poller是muduo库唯一一个用面向对象封装的，3个都是纯虚函数。</p>
<p>EventLoop和Poller是组合关系，<strong>一个EventLoop包含一个Poller</strong>，并且Poller生存周期由EventLoop控制，EventLoop的loop函数是调用Poller的poll函数实现的。</p>
<p>Channel是对IO事件的注册与响应的封装，handleEvent对所发生的IO事件进行处理，当调用Channel的update来注册和更新IO的可读可写事件时候，又会调用到EventLoop的updateChannel函数，从而又调用了Poller的updateChannel，相当于把Channel注册到Poller当中，或者说将文件描述符的可读可写事件注册到Poller，<strong>一个EventLoop包含多个Channel</strong>，也就是说可以用来捕捉多个通道的可读可写事件，一对多，<strong>聚合关系</strong>，也就是说不负责Channel生存期控制，并且Channel不拥有文件描述符，也就是说当它销毁的时候不close关闭文件描述符。Channel跟TcpConnection，Acceptor，Connector是组合关系，并且Channel生存周期由他们控制。</p>
<p>FileDescriptor不是一个类，跟Channel是关联关系，<strong>一对一</strong>，<strong>一个EventLoop有多个fd</strong>,FileDescriptor是由Socket拥有的，生存周期由套接字控制。</p>
<p>Acceptor是对被动连接的抽象，关注的是监听套接字的可读事件，这个事件由Channel的handleEvent注册，从而调用了handleRead，是基于对象的编程思想，回调了handleRead。</p>
<p>Connector是对主动连接的抽象，与Acceptor差不多。不管是被动连接还是主动成功后，都会得到一个已连接套接字，对已连接套接字的抽象就是TcpConnection，TcpServer和Acceptor是组合关系，Acceptor生存期由TcpServer控制，但是一个TcpServer有多个TcpConnection，是聚合关系，但是不控制生存期。</p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><ul>
<li>Channel是selectable lO channel，负责注册与响应IO事件，它不拥有file descriptor。</li>
<li>Channel是Acceptor、Connector、EventLoopTimerQueue、TcpConnection的成员，生命期由后者控制。</li>
</ul>
<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230809113131684.png" alt="image-20230809113131684"></p>
<img src="/2023/08/08/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230809113131684.png" class title="This is an test image">

<p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230809163337743.png" alt="image-20230809163337743"></p>
<img src="/2023/08/08/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230809163337743.png" class title="This is an test image">

<h2 id="Channel-h"><a href="#Channel-h" class="headerlink" title="Channel.h"></a>Channel.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">class EventLoop;</span><br><span class="line"></span><br><span class="line">///</span><br><span class="line">/// A selectable I/O channel.</span><br><span class="line">///</span><br><span class="line">/// This class doesn&#x27;t own the file descriptor.</span><br><span class="line">/// The file descriptor could be a socket,</span><br><span class="line">/// an eventfd, a timerfd, or a signalfd</span><br><span class="line">class Channel : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  typedef std::function&lt;void()&gt; EventCallback;</span><br><span class="line">  typedef std::function&lt;void(Timestamp)&gt; ReadEventCallback;</span><br><span class="line"></span><br><span class="line">  Channel(EventLoop* loop, int fd);</span><br><span class="line">  ~Channel();</span><br><span class="line"></span><br><span class="line">  void handleEvent(Timestamp receiveTime);</span><br><span class="line">  void setReadCallback(ReadEventCallback cb)</span><br><span class="line">  &#123; readCallback_ = std::move(cb); &#125;</span><br><span class="line">  void setWriteCallback(EventCallback cb)</span><br><span class="line">  &#123; writeCallback_ = std::move(cb); &#125;</span><br><span class="line">  void setCloseCallback(EventCallback cb)</span><br><span class="line">  &#123; closeCallback_ = std::move(cb); &#125;</span><br><span class="line">  void setErrorCallback(EventCallback cb)</span><br><span class="line">  &#123; errorCallback_ = std::move(cb); &#125;</span><br><span class="line"></span><br><span class="line">  /// Tie this channel to the owner object managed by shared_ptr,</span><br><span class="line">  /// prevent the owner object being destroyed in handleEvent.</span><br><span class="line">  void tie(const std::shared_ptr&lt;void&gt;&amp;);</span><br><span class="line"></span><br><span class="line">  int fd() const &#123; return fd_; &#125;</span><br><span class="line">  int events() const &#123; return events_; &#125;</span><br><span class="line">  void set_revents(int revt) &#123; revents_ = revt; &#125; // used by pollers</span><br><span class="line">  // int revents() const &#123; return revents_; &#125;</span><br><span class="line">  bool isNoneEvent() const &#123; return events_ == kNoneEvent; &#125;</span><br><span class="line"></span><br><span class="line">  void enableReading() &#123; events_ |= kReadEvent; update(); &#125;</span><br><span class="line">  void disableReading() &#123; events_ &amp;= ~kReadEvent; update(); &#125;</span><br><span class="line">  void enableWriting() &#123; events_ |= kWriteEvent; update(); &#125;</span><br><span class="line">  void disableWriting() &#123; events_ &amp;= ~kWriteEvent; update(); &#125;</span><br><span class="line">  void disableAll() &#123; events_ = kNoneEvent; update(); &#125;</span><br><span class="line">  bool isWriting() const &#123; return events_ &amp; kWriteEvent; &#125;</span><br><span class="line">  bool isReading() const &#123; return events_ &amp; kReadEvent; &#125;</span><br><span class="line"></span><br><span class="line">  // for Poller</span><br><span class="line">  int index() &#123; return index_; &#125;</span><br><span class="line">  void set_index(int idx) &#123; index_ = idx; &#125;</span><br><span class="line"></span><br><span class="line">  // for debug</span><br><span class="line">  string reventsToString() const;</span><br><span class="line">  string eventsToString() const;</span><br><span class="line"></span><br><span class="line">  void doNotLogHup() &#123; logHup_ = false; &#125;</span><br><span class="line"></span><br><span class="line">  EventLoop* ownerLoop() &#123; return loop_; &#125;</span><br><span class="line">  void remove();</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  static string eventsToString(int fd, int ev);</span><br><span class="line"></span><br><span class="line">  void update();</span><br><span class="line">  void handleEventWithGuard(Timestamp receiveTime);</span><br><span class="line"></span><br><span class="line">  static const int kNoneEvent;</span><br><span class="line">  static const int kReadEvent;</span><br><span class="line">  static const int kWriteEvent;</span><br><span class="line"></span><br><span class="line">  EventLoop* loop_;//所属EventLoop</span><br><span class="line">  const int  fd_;//文件描述符，但不负责关闭</span><br><span class="line">  int        events_;//关注的事件</span><br><span class="line">  int        revents_; // it&#x27;s the received event types of epoll or poll，poll/epoll返回的事件</span><br><span class="line">  int        index_; // used by Poller.表示在poll的事件数组中的序号</span><br><span class="line">  bool       logHup_;</span><br><span class="line"></span><br><span class="line">  std::weak_ptr&lt;void&gt; tie_;</span><br><span class="line">  bool tied_;</span><br><span class="line">  bool eventHandling_;//是否处于处理事件中</span><br><span class="line">  bool addedToLoop_;</span><br><span class="line">  ReadEventCallback readCallback_;</span><br><span class="line">  EventCallback writeCallback_;</span><br><span class="line">  EventCallback closeCallback_;</span><br><span class="line">  EventCallback errorCallback_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br></pre></td></tr></table></figure>

<h2 id="Channel-cc"><a href="#Channel-cc" class="headerlink" title="Channel.cc"></a>Channel.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">const int Channel::kNoneEvent = 0;</span><br><span class="line">const int Channel::kReadEvent = POLLIN | POLLPRI;</span><br><span class="line">const int Channel::kWriteEvent = POLLOUT;</span><br><span class="line"></span><br><span class="line">Channel::Channel(EventLoop* loop, int fd__)</span><br><span class="line">  : loop_(loop),</span><br><span class="line">    fd_(fd__),</span><br><span class="line">    events_(0),</span><br><span class="line">    revents_(0),</span><br><span class="line">    index_(-1),</span><br><span class="line">    logHup_(true),</span><br><span class="line">    tied_(false),</span><br><span class="line">    eventHandling_(false),</span><br><span class="line">    addedToLoop_(false)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Channel::~Channel()</span><br><span class="line">&#123;</span><br><span class="line">  assert(!eventHandling_);</span><br><span class="line">  assert(!addedToLoop_);</span><br><span class="line">  if (loop_-&gt;isInLoopThread())</span><br><span class="line">  &#123;</span><br><span class="line">    assert(!loop_-&gt;hasChannel(this));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Channel::tie(const std::shared_ptr&lt;void&gt;&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">  tie_ = obj;</span><br><span class="line">  tied_ = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Channel::update()</span><br><span class="line">&#123;</span><br><span class="line">  addedToLoop_ = true;</span><br><span class="line">  loop_-&gt;updateChannel(this);</span><br><span class="line">&#125;</span><br><span class="line">//调用这个函数之前确保调用disableAll</span><br><span class="line">void Channel::remove()</span><br><span class="line">&#123;</span><br><span class="line">  assert(isNoneEvent());</span><br><span class="line">  addedToLoop_ = false;</span><br><span class="line">  loop_-&gt;removeChannel(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Channel::handleEvent(Timestamp receiveTime)</span><br><span class="line">&#123;</span><br><span class="line">  std::shared_ptr&lt;void&gt; guard;</span><br><span class="line">  if (tied_)</span><br><span class="line">  &#123;</span><br><span class="line">    guard = tie_.lock();//tie_.lock() 是用于从 std::weak_ptr 类型对象获取其关联的 std::shared_ptr 对象的方法</span><br><span class="line">    //在 Channel::handleEvent() 函数中，tie_.lock() 被用来获取与 tie_ 关联的 std::shared_ptr&lt;void&gt;，如果该 std::shared_ptr 有效，则执行相关的事件处理。这种方式可以确保在事件处理期间，与 Channel 关联的对象仍然有效，避免了因为对象被释放而导致的问题。</span><br><span class="line">    if (guard)</span><br><span class="line">    &#123;</span><br><span class="line">      handleEventWithGuard(receiveTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    handleEventWithGuard(receiveTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">void Channel::handleEventWithGuard(Timestamp receiveTime)</span><br><span class="line">&#123;</span><br><span class="line">  eventHandling_ = true;</span><br><span class="line">  LOG_TRACE &lt;&lt; reventsToString();</span><br><span class="line">  if ((revents_ &amp; POLLHUP) &amp;&amp; !(revents_ &amp; POLLIN))//如果发生了挂起事件，并且没有发生可读事件</span><br><span class="line">  &#123;</span><br><span class="line">    if (logHup_)</span><br><span class="line">    &#123;</span><br><span class="line">      LOG_WARN &lt;&lt; &quot;fd = &quot; &lt;&lt; fd_ &lt;&lt; &quot; Channel::handle_event() POLLHUP&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    if (closeCallback_) closeCallback_();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (revents_ &amp; POLLNVAL)//fd not open</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_WARN &lt;&lt; &quot;fd = &quot; &lt;&lt; fd_ &lt;&lt; &quot; Channel::handle_event() POLLNVAL&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (revents_ &amp; (POLLERR | POLLNVAL))</span><br><span class="line">  &#123;</span><br><span class="line">    if (errorCallback_) errorCallback_();</span><br><span class="line">  &#125;</span><br><span class="line">  if (revents_ &amp; (POLLIN | POLLPRI | POLLRDHUP))</span><br><span class="line">  &#123;</span><br><span class="line">    if (readCallback_) readCallback_(receiveTime);</span><br><span class="line">  &#125;</span><br><span class="line">  if (revents_ &amp; POLLOUT)</span><br><span class="line">  &#123;</span><br><span class="line">    if (writeCallback_) writeCallback_();</span><br><span class="line">  &#125;</span><br><span class="line">  eventHandling_ = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string Channel::reventsToString() const</span><br><span class="line">&#123;</span><br><span class="line">  return eventsToString(fd_, revents_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string Channel::eventsToString() const</span><br><span class="line">&#123;</span><br><span class="line">  return eventsToString(fd_, events_);</span><br><span class="line">&#125;</span><br><span class="line">//用来调试的，发生了什么事件</span><br><span class="line">string Channel::eventsToString(int fd, int ev)</span><br><span class="line">&#123;</span><br><span class="line">  std::ostringstream oss;</span><br><span class="line">  oss &lt;&lt; fd &lt;&lt; &quot;: &quot;;</span><br><span class="line">  if (ev &amp; POLLIN)</span><br><span class="line">    oss &lt;&lt; &quot;IN &quot;;</span><br><span class="line">  if (ev &amp; POLLPRI)</span><br><span class="line">    oss &lt;&lt; &quot;PRI &quot;;</span><br><span class="line">  if (ev &amp; POLLOUT)</span><br><span class="line">    oss &lt;&lt; &quot;OUT &quot;;</span><br><span class="line">  if (ev &amp; POLLHUP)</span><br><span class="line">    oss &lt;&lt; &quot;HUP &quot;;</span><br><span class="line">  if (ev &amp; POLLRDHUP)</span><br><span class="line">    oss &lt;&lt; &quot;RDHUP &quot;;</span><br><span class="line">  if (ev &amp; POLLERR)</span><br><span class="line">    oss &lt;&lt; &quot;ERR &quot;;</span><br><span class="line">  if (ev &amp; POLLNVAL)</span><br><span class="line">    oss &lt;&lt; &quot;NVAL &quot;;</span><br><span class="line"></span><br><span class="line">  return oss.str();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Channel::tie(const std::shared_ptr&lt;void&gt;&amp; obj)</code> 函数的功能是在 <code>Channel</code> 类中设置一个关联对象，以便在事件处理期间使用。这个函数在事件循环中处理事件时很有用，可以保证关联的对象在事件处理期间有效，避免在处理过程中被释放导致的错误。</p>
<p>在具体代码中，函数的作用如下：</p>
<ol>
<li>接受一个 <code>std::shared_ptr&lt;void&gt;</code> 类型的参数 <code>obj</code>，这是一个指向任意类型的 <code>std::shared_ptr</code> 智能指针。<code>std::shared_ptr</code> 是一个可以共享拥有资源所有权的智能指针，它可以确保资源在不再需要时自动释放。</li>
<li>将传入的 <code>obj</code> 赋值给成员变量 <code>tie_</code>，这是一个 <code>std::weak_ptr&lt;void&gt;</code> 类型的成员变量。<code>std::weak_ptr</code> 是一种弱引用指针，它不会增加资源的引用计数，也不会阻止资源的释放。</li>
<li>将成员变量 <code>tied_</code> 设置为 <code>true</code>，表示已经关联了一个对象。</li>
</ol>
<p>函数的目的是在事件处理期间保证相关联的对象不会被提前释放。在事件处理函数 <code>Channel::handleEvent()</code> 中，首先会检查 <code>tied_</code> 是否为 <code>true</code>，如果是，就会尝试使用 <code>std::shared_ptr&lt;void&gt;</code> 类型的 <code>guard</code> 对象来保持关联对象的有效性。这样可以防止在处理事件时，关联对象已经被释放导致的问题。</p>
<p>总之，<code>Channel::tie()</code> 函数允许用户将一个智能指针与 <code>Channel</code> 对象关联起来，以确保在事件处理期间关联对象不会被过早地释放，从而增强了代码的健壮性。这在多线程环境中尤其有用，可以避免悬空指针和资源竞争等问题。</p>
<h2 id="Poller-h"><a href="#Poller-h" class="headerlink" title="Poller.h"></a>Poller.h</h2><p>是面向对象实现的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">class Channel;</span><br><span class="line"></span><br><span class="line">///</span><br><span class="line">/// Base class for IO Multiplexing</span><br><span class="line">///</span><br><span class="line">/// This class doesn&#x27;t own the Channel objects.</span><br><span class="line">class Poller : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  typedef std::vector&lt;Channel*&gt; ChannelList;</span><br><span class="line"></span><br><span class="line">  Poller(EventLoop* loop);</span><br><span class="line">  virtual ~Poller();</span><br><span class="line"></span><br><span class="line">  /// Polls the I/O events.</span><br><span class="line">  /// Must be called in the loop thread.</span><br><span class="line">  virtual Timestamp poll(int timeoutMs, ChannelList* activeChannels) = 0;</span><br><span class="line"></span><br><span class="line">  /// Changes the interested I/O events.</span><br><span class="line">  /// Must be called in the loop thread.</span><br><span class="line">  virtual void updateChannel(Channel* channel) = 0;</span><br><span class="line"></span><br><span class="line">  /// Remove the channel, when it destructs.</span><br><span class="line">  /// Must be called in the loop thread.</span><br><span class="line">  virtual void removeChannel(Channel* channel) = 0;</span><br><span class="line"></span><br><span class="line">  virtual bool hasChannel(Channel* channel) const;</span><br><span class="line"></span><br><span class="line">  static Poller* newDefaultPoller(EventLoop* loop);</span><br><span class="line"></span><br><span class="line">  void assertInLoopThread() const</span><br><span class="line">  &#123;</span><br><span class="line">    ownerLoop_-&gt;assertInLoopThread();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> protected:</span><br><span class="line">  typedef std::map&lt;int, Channel*&gt; ChannelMap;</span><br><span class="line">  ChannelMap channels_;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  EventLoop* ownerLoop_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br></pre></td></tr></table></figure>

<p>在代码片段中，<code>class Channel;</code> 的写法在 <code>namespace muduo::net</code> 命名空间中的作用是进行前向声明（forward declaration）。</p>
<p>前向声明是一种在编译器还未看到实际类定义的情况下，告诉编译器某个类的存在的方式。这在处理循环引用（circular dependencies）或减少编译依赖性时非常有用。在这个特定的情况下，前向声明的目的是在 <code>Poller</code> 类中声明一个指向 <code>Channel</code> 类的指针或引用，而不需要知道 <code>Channel</code> 类的完整定义。</p>
<p>具体来说，<code>class Channel;</code> 的作用是：</p>
<ol>
<li><strong>解决编译依赖性问题：</strong> 如果在 <code>Poller</code> 类中包含了 <code>Channel</code> 类的完整定义，那么在编译 <code>Poller</code> 类时，编译器会需要知道 <code>Channel</code> 类的所有细节。而如果 <code>Channel</code> 类也依赖于 <code>Poller</code> 类，就会导致循环依赖，从而编译错误。通过使用前向声明，<code>Poller</code> 类可以在不知道 <code>Channel</code> 类的完整定义的情况下编译，从而解决了这种依赖性问题。</li>
<li><strong>降低编译时间：</strong> 前向声明可以减少编译时间，因为编译器不需要读取和处理完整的 <code>Channel</code> 类定义，而只需要知道有一个名为 <code>Channel</code> 的类存在即可。</li>
<li><strong>避免不必要的头文件包含：</strong> 如果不需要在 <code>Poller</code> 类中使用 <code>Channel</code> 类的成员变量或方法，而只需要一个指针或引用，那么可以通过前向声明避免包含 <code>Channel</code> 类的完整头文件，从而减少编译依赖和编译时间。</li>
</ol>
<p>综上所述，<code>class Channel;</code> 的写法在这个上下文中用于进行前向声明，以解决编译依赖性问题和提高编译效率。这是 C++ 中常见的用法，可以帮助代码模块化和降低耦合度。</p>
<h2 id="Poller-cc"><a href="#Poller-cc" class="headerlink" title="Poller.cc"></a>Poller.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">Poller::Poller(EventLoop* loop)</span><br><span class="line">  : ownerLoop_(loop)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Poller::~Poller() = default;</span><br><span class="line"></span><br><span class="line">bool Poller::hasChannel(Channel* channel) const</span><br><span class="line">&#123;</span><br><span class="line">  assertInLoopThread();</span><br><span class="line">  ChannelMap::const_iterator it = channels_.find(channel-&gt;fd());</span><br><span class="line">  return it != channels_.end() &amp;&amp; it-&gt;second == channel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="PollPoller-h"><a href="#PollPoller-h" class="headerlink" title="PollPoller.h"></a>PollPoller.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">struct pollfd;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">///</span><br><span class="line">/// IO Multiplexing with poll(2).</span><br><span class="line">///</span><br><span class="line">class PollPoller : public Poller</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line"></span><br><span class="line">  PollPoller(EventLoop* loop);</span><br><span class="line">  ~PollPoller() override;</span><br><span class="line"></span><br><span class="line">  Timestamp poll(int timeoutMs, ChannelList* activeChannels) override;</span><br><span class="line">  void updateChannel(Channel* channel) override;</span><br><span class="line">  void removeChannel(Channel* channel) override;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  void fillActiveChannels(int numEvents,</span><br><span class="line">                          ChannelList* activeChannels) const;</span><br><span class="line"></span><br><span class="line">  typedef std::vector&lt;struct pollfd&gt; PollFdList;</span><br><span class="line">  PollFdList pollfds_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br></pre></td></tr></table></figure>

<h2 id="PollPoller-cc"><a href="#PollPoller-cc" class="headerlink" title="PollPoller.cc"></a>PollPoller.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">PollPoller::PollPoller(EventLoop* loop)</span><br><span class="line">  : Poller(loop)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PollPoller::~PollPoller() = default;</span><br><span class="line"></span><br><span class="line">Timestamp PollPoller::poll(int timeoutMs, ChannelList* activeChannels)</span><br><span class="line">&#123;</span><br><span class="line">  // XXX pollfds_ shouldn&#x27;t change</span><br><span class="line">  int numEvents = ::poll(&amp;*pollfds_.begin(), pollfds_.size(), timeoutMs);</span><br><span class="line">  int savedErrno = errno;</span><br><span class="line">  Timestamp now(Timestamp::now());</span><br><span class="line">  if (numEvents &gt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_TRACE &lt;&lt; numEvents &lt;&lt; &quot; events happened&quot;;</span><br><span class="line">    fillActiveChannels(numEvents, activeChannels);//loop调用，pollReturnTime_ = poller_-&gt;poll(kPollTimeMs, &amp;activeChannels_);是一个地址传递</span><br><span class="line">  &#125;</span><br><span class="line">  else if (numEvents == 0)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_TRACE &lt;&lt; &quot; nothing happened&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    if (savedErrno != EINTR)</span><br><span class="line">    &#123;</span><br><span class="line">      errno = savedErrno;</span><br><span class="line">      LOG_SYSERR &lt;&lt; &quot;PollPoller::poll()&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PollPoller::fillActiveChannels(int numEvents,</span><br><span class="line">                                    ChannelList* activeChannels) const</span><br><span class="line">&#123;</span><br><span class="line">  for (PollFdList::const_iterator pfd = pollfds_.begin();</span><br><span class="line">      pfd != pollfds_.end() &amp;&amp; numEvents &gt; 0; ++pfd)</span><br><span class="line">  &#123;</span><br><span class="line">    if (pfd-&gt;revents &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      --numEvents;</span><br><span class="line">      //声明了一个常量迭代器ch</span><br><span class="line">      ChannelMap::const_iterator ch = channels_.find(pfd-&gt;fd);</span><br><span class="line">      assert(ch != channels_.end());</span><br><span class="line">      Channel* channel = ch-&gt;second;//second成员是std::map中键值对的值部分</span><br><span class="line">      assert(channel-&gt;fd() == pfd-&gt;fd);</span><br><span class="line">      channel-&gt;set_revents(pfd-&gt;revents);</span><br><span class="line">      // pfd-&gt;revents = 0;</span><br><span class="line">      activeChannels-&gt;push_back(channel);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//注册和更新事件</span><br><span class="line">void PollPoller::updateChannel(Channel* channel)</span><br><span class="line">&#123;</span><br><span class="line">  Poller::assertInLoopThread();</span><br><span class="line">  LOG_TRACE &lt;&lt; &quot;fd = &quot; &lt;&lt; channel-&gt;fd() &lt;&lt; &quot; events = &quot; &lt;&lt; channel-&gt;events();</span><br><span class="line">  if (channel-&gt;index() &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    //index小于0说明是一个新通道</span><br><span class="line">    // a new one, add to pollfds_</span><br><span class="line">    //断言在 channels_ 容器中不能找到具有与 channel 对象相同文件描述符的 Channel 对象</span><br><span class="line">    assert(channels_.find(channel-&gt;fd()) == channels_.end());</span><br><span class="line">    struct pollfd pfd;</span><br><span class="line">    pfd.fd = channel-&gt;fd();</span><br><span class="line">    pfd.events = static_cast&lt;short&gt;(channel-&gt;events());</span><br><span class="line">    pfd.revents = 0;</span><br><span class="line">    pollfds_.push_back(pfd);</span><br><span class="line">    int idx = static_cast&lt;int&gt;(pollfds_.size())-1;</span><br><span class="line">    channel-&gt;set_index(idx);</span><br><span class="line">    channels_[pfd.fd] = channel;//key是文件描述符，值是channel</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    // update existing one</span><br><span class="line">    assert(channels_.find(channel-&gt;fd()) != channels_.end());</span><br><span class="line">    assert(channels_[channel-&gt;fd()] == channel);</span><br><span class="line">    int idx = channel-&gt;index();</span><br><span class="line">    assert(0 &lt;= idx &amp;&amp; idx &lt; static_cast&lt;int&gt;(pollfds_.size()));</span><br><span class="line">    struct pollfd&amp; pfd = pollfds_[idx];//引用，不需要拷贝</span><br><span class="line">    assert(pfd.fd == channel-&gt;fd() || pfd.fd == -channel-&gt;fd()-1);</span><br><span class="line">    pfd.fd = channel-&gt;fd();</span><br><span class="line">    pfd.events = static_cast&lt;short&gt;(channel-&gt;events());</span><br><span class="line">    pfd.revents = 0;</span><br><span class="line">    //将一个通道暂时更改为不关注事件，但不从Poller中移除该通道</span><br><span class="line">    if (channel-&gt;isNoneEvent())</span><br><span class="line">    &#123;</span><br><span class="line">      // ignore this pollfd</span><br><span class="line">      //暂时忽略该文件描述符的事件</span><br><span class="line">      //这里pfd.fd可以直接设置为-1</span><br><span class="line">      pfd.fd = -channel-&gt;fd()-1;//这样子设置是为了removeChannel优化</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//移除调用removeChannel之前一定要设置成不关注事件，即要先调用isNoneEvent()</span><br><span class="line">void PollPoller::removeChannel(Channel* channel)</span><br><span class="line">&#123;</span><br><span class="line">  Poller::assertInLoopThread();</span><br><span class="line">  LOG_TRACE &lt;&lt; &quot;fd = &quot; &lt;&lt; channel-&gt;fd();</span><br><span class="line">  assert(channels_.find(channel-&gt;fd()) != channels_.end());</span><br><span class="line">  assert(channels_[channel-&gt;fd()] == channel);</span><br><span class="line">  assert(channel-&gt;isNoneEvent());</span><br><span class="line">  int idx = channel-&gt;index();</span><br><span class="line">  assert(0 &lt;= idx &amp;&amp; idx &lt; static_cast&lt;int&gt;(pollfds_.size()));</span><br><span class="line">  const struct pollfd&amp; pfd = pollfds_[idx]; (void)pfd;</span><br><span class="line">  assert(pfd.fd == -channel-&gt;fd()-1 &amp;&amp; pfd.events == channel-&gt;events());</span><br><span class="line">  size_t n = channels_.erase(channel-&gt;fd());</span><br><span class="line">  assert(n == 1); (void)n;</span><br><span class="line">  if (implicit_cast&lt;size_t&gt;(idx) == pollfds_.size()-1)</span><br><span class="line">  &#123;</span><br><span class="line">    //如果是最后一个</span><br><span class="line">    pollfds_.pop_back();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    //这里移除的算法复杂度是O(1)，将待删除元素与最后一个元素交换再pop_back</span><br><span class="line">    int channelAtEnd = pollfds_.back().fd;</span><br><span class="line">    iter_swap(pollfds_.begin()+idx, pollfds_.end()-1);</span><br><span class="line">    if (channelAtEnd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      channelAtEnd = -channelAtEnd-1;</span><br><span class="line">    &#125;</span><br><span class="line">    channels_[channelAtEnd]-&gt;set_index(idx);</span><br><span class="line">    pollfds_.pop_back();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/08/04/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%884%EF%BC%89/" rel="prev" title="muduo-基础库（4）">
      <i class="fa fa-chevron-left"></i> muduo-基础库（4）
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1/" rel="next" title="数据结构-1">
      数据结构-1 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#TCP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%9C%AC%E8%B4%A8"><span class="nav-number">1.</span> <span class="nav-text">TCP网络编程本质</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#EventLoop"><span class="nav-number">2.</span> <span class="nav-text">EventLoop</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#EventLoop-h%E9%83%A8%E5%88%86"><span class="nav-number">2.1.</span> <span class="nav-text">EventLoop.h部分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EventLoop-cc%E9%83%A8%E5%88%86"><span class="nav-number">2.2.</span> <span class="nav-text">EventLoop.cc部分</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E7%9B%B8%E5%85%B3%E7%B1%BB%E5%9B%BE%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">3.</span> <span class="nav-text">muduo网络库相关类图的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Channel"><span class="nav-number">3.1.</span> <span class="nav-text">Channel</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E5%BA%8F%E5%9B%BE"><span class="nav-number">3.2.</span> <span class="nav-text">时序图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Channel-h"><span class="nav-number">3.3.</span> <span class="nav-text">Channel.h</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Channel-cc"><span class="nav-number">3.4.</span> <span class="nav-text">Channel.cc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Poller-h"><span class="nav-number">3.5.</span> <span class="nav-text">Poller.h</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Poller-cc"><span class="nav-number">3.6.</span> <span class="nav-text">Poller.cc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PollPoller-h"><span class="nav-number">3.7.</span> <span class="nav-text">PollPoller.h</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PollPoller-cc"><span class="nav-number">3.8.</span> <span class="nav-text">PollPoller.cc</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">肖汇林</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">76</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">肖汇林</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
