<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="回调函数函数指针作为某个函数的参数函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。 简单讲：回调函数是由别人的函数执行时调用你实现的函数。  以下是来自知乎作者常溪玲的解说： 你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，">
<meta property="og:type" content="article">
<meta property="og:title" content="第四天 c语言">
<meta property="og:url" content="http://example.com/2023/03/18/c%E5%92%8Cc++/%E7%AC%AC%E5%9B%9B%E5%A4%A9-c%E8%AF%AD%E8%A8%80/index.html">
<meta property="og:site_name" content="肖汇林的博客">
<meta property="og:description" content="回调函数函数指针作为某个函数的参数函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。 简单讲：回调函数是由别人的函数执行时调用你实现的函数。  以下是来自知乎作者常溪玲的解说： 你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-03-18T06:53:58.000Z">
<meta property="article:modified_time" content="2023-03-18T12:44:28.611Z">
<meta property="article:author" content="肖汇林">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2023/03/18/c%E5%92%8Cc++/%E7%AC%AC%E5%9B%9B%E5%A4%A9-c%E8%AF%AD%E8%A8%80/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>第四天 c语言 | 肖汇林的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖汇林的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/18/c%E5%92%8Cc++/%E7%AC%AC%E5%9B%9B%E5%A4%A9-c%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          第四天 c语言
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-18 14:53:58 / 修改时间：20:44:28" itemprop="dateCreated datePublished" datetime="2023-03-18T14:53:58+08:00">2023-03-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><h2 id="函数指针作为某个函数的参数"><a href="#函数指针作为某个函数的参数" class="headerlink" title="函数指针作为某个函数的参数"></a>函数指针作为某个函数的参数</h2><p>函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。</p>
<p>简单讲：回调函数是由别人的函数执行时调用你实现的函数。</p>
<blockquote>
<p>以下是来自知乎作者常溪玲的解说：</p>
<p>你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。</p>
</blockquote>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>实例中 <strong>populate_array()</strong> 函数定义了三个参数，其中第三个参数是函数的指针，通过该函数来设置数组的值。</p>
<p>实例中我们定义了回调函数 **getNextRandomValue()**，它返回一个随机值，它作为一个函数指针传递给 <strong>populate_array()</strong> 函数。</p>
<p><strong>populate_array()</strong> 将调用 <strong>10</strong> 次回调函数，并将回调函数的返回值赋值给数组。</p>
<p><strong>回调函数最大的意义在于解耦，降低了代码之间的耦合度。</strong></p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">void populate_array(int *array, size_t arraySize, int (*getNextValue)(void))</span><br><span class="line">&#123;  /*有关于 size_t:size_t 是一种数据类型，近似于无符号整型，但容量范围一般大于 int 和 unsigned。这里使用 size_t 是为了保证 arraysize 变量能够有足够大的容量来储存可能大的数组。*/</span><br><span class="line">    for (size_t i=0; i&lt;arraySize; i++)</span><br><span class="line">        array[i] = getNextValue();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 获取随机值</span><br><span class="line">int getNextRandomValue(void)</span><br><span class="line">&#123;</span><br><span class="line">    return rand();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int myarray[10];</span><br><span class="line">    /* getNextRandomValue 不能加括号，否则无法编译，因为加上括号之后相当于传入此参数时传入了 int , 而不是函数指针*/</span><br><span class="line">    populate_array(myarray, 10, getNextRandomValue);</span><br><span class="line">    for(int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        printf(&quot;%d &quot;, myarray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>size_t 类型在C语言标准库函数原型使用的很多，数值范围一般是要大于int和unsigned.</p>
<p>但凡不涉及负值范围的表示size取值的，都可以用size_t；比如array[size_t]。</p>
<p>size_t 在stddef.h头文件中定义。</p>
<p>在其他常见的宏定义以及函数中常用到有：</p>
<p>1，sizeof运算符返回的结果是size_t类型；</p>
<p>2，void *malloc(size_t size)…</p>
<hr>
<h1 id="C字符串"><a href="#C字符串" class="headerlink" title="C字符串"></a>C字符串</h1><p>字符串在以如下输入进行初始化的时候需要对 <strong>\0</strong> 特别注意：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char greeting[6] = &#123;&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;\0&#x27;&#125;;</span><br></pre></td></tr></table></figure>

<p>如果没有在字符数组最后增加 <strong>\0</strong> 的话输出结果有误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 初始化字符串</span><br><span class="line">char greeting[5] = &#123; &#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27; &#125;;</span><br><span class="line">printf(&quot;Greeting message: %s\n&quot;, greeting);</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Greeting message: Hello烫烫烫?侵7(?╔?╚╔╔</span><br></pre></td></tr></table></figure>

<p>在使用不定长数组初始化字符串时默认结尾为 <strong>\0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char greeting[] = &quot;Hello&quot;;</span><br><span class="line">printf(&quot;Greeting message: %s, greeting[] Length: %d\n&quot;, greeting, sizeof(greeting));</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Greeting message: Hello, greeting[] Length: 6</span><br></pre></td></tr></table></figure>

<p><strong>结论：</strong>需在给定字符数组的大小时在原有的字符串的字符数上加 1。</p>
<hr>
<p><strong>strlen 与 sizeof的区别：</strong></p>
<p>strlen 是函数，sizeof 是运算操作符，二者得到的结果类型为 size_t，即 unsigned int 类型。</p>
<p>sizeof 计算的是变量的大小，不受字符 <strong>\0</strong> 影响；</p>
<p>sizeof() 计算字符串的长度，包含末尾的 ‘\0’;</p>
<h5 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char s[] = &quot;Hello, world!&quot;;</span><br><span class="line">sizeof(s) ;// 输出 14，即字符串 s 中有 14 个字符（包括结尾的空字符 &#x27;\0&#x27;）</span><br></pre></td></tr></table></figure>

<p>而 strlen 计算的是字符串的长度，以 <strong>\0</strong> 作为长度判定依据。strlen() 函数只能用于计算以空字符 ‘\0’ 结尾的字符串的长度，如果字符串中没有空字符，则 strlen() 函数的行为是未定义的.</p>
<p>其中 string 是一个以空字符 ‘\0’ 结尾的字符串，但是计算字符串的长度，不包含末尾的 ‘\0’。例如：</p>
<h5 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char s[] = &quot;Hello, world!&quot;;</span><br><span class="line">strlen(s) ;// 输出 13，即字符串 s 中有 13 个字符（不包括结尾的空字符 &#x27;\0&#x27;）</span><br></pre></td></tr></table></figure>

<p>sizeof 可以用类型做参数，<strong>strlen</strong> 只能用 <strong>char*</strong> 做参数，且必须是以 <strong>\0</strong> 结尾的。</p>
<p>sizeof 还可以用函数做参数，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">short f();</span><br><span class="line">printf(&quot;%d\n&quot;, sizeof(f()));</span><br></pre></td></tr></table></figure>

<p>输出的结果是 sizeof(short)，即 2。</p>
<p>数组做 <strong>sizeof</strong> 的参数不退化，传递给 <strong>strlen</strong> 就退化为指针了。</p>
<p>大部分编译程序在编译的时候就把 <strong>sizeof</strong> 计算过了，是类型或是变量的长度，这就是 <strong>sizeof(x)</strong> 可以用来定义数组维数的原因。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char str[20]=&quot;0123456789&quot;;</span><br><span class="line">int a=strlen(str); // a=10;</span><br><span class="line">int b=sizeof(str); // 而 b=20;</span><br></pre></td></tr></table></figure>

<p>strlen 的结果要在运行的时候才能计算出来，是用来计算字符串的长度，不是类型占内存的大小。</p>
<p>数组作为参数传给函数时传的是指针而不是数组，传递的是数组的首地址， 如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun(char [8])</span><br><span class="line">fun(char [])</span><br></pre></td></tr></table></figure>

<p>都等价于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun(char *) </span><br></pre></td></tr></table></figure>

<p>在 C++ 里参数传递数组永远都是传递指向数组首元素的指针，编译器不知道数组的大小。</p>
<hr>
<p><strong>‘a’</strong> 表示是一个字符，**”a”** 表示一个字符串相当于 <strong>‘a’+’\0’</strong>;</p>
<p><strong>‘’</strong> 里面只能放一个字符;</p>
<p><strong>“”</strong> 里面表示是字符串系统自动会在串末尾补一个 0。</p>
<hr>
<h1 id="C结构体"><a href="#C结构体" class="headerlink" title="C结构体"></a>C结构体</h1><p>结构体定义由关键字 <strong>struct</strong> 和结构体名组成，结构体名可以根据需要自行定义。</p>
<p>struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct tag &#123; </span><br><span class="line">    member-list</span><br><span class="line">    member-list </span><br><span class="line">    member-list  </span><br><span class="line">    ...</span><br><span class="line">&#125; variable-list ;</span><br></pre></td></tr></table></figure>

<p>在一般情况下，<strong>tag、member-list、variable-list</strong> 这 3 部分至少要出现 2 个。以下为实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">在一般情况下，tag、member-list、variable-list 这 3 部分至少要出现 2 个。以下为实例：</span><br><span class="line"></span><br><span class="line">//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c</span><br><span class="line">//同时又声明了结构体变量s1</span><br><span class="line">//这个结构体并没有标明其标签</span><br><span class="line">struct </span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    char b;</span><br><span class="line">    double c;</span><br><span class="line">&#125; s1;</span><br><span class="line"> </span><br><span class="line">//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c</span><br><span class="line">//结构体的标签被命名为SIMPLE,没有声明变量</span><br><span class="line">struct SIMPLE</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    char b;</span><br><span class="line">    double c;</span><br><span class="line">&#125;;</span><br><span class="line">//用SIMPLE标签的结构体，另外声明了变量t1、t2、t3</span><br><span class="line">struct SIMPLE t1, t2[20], *t3;</span><br><span class="line"> </span><br><span class="line">//也可以用typedef创建新类型</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    char b;</span><br><span class="line">    double c; </span><br><span class="line">&#125; Simple2;</span><br><span class="line">//现在可以用Simple2作为类型声明新的结构体变量</span><br><span class="line">Simple2 u1, u2[20], *u3;</span><br><span class="line">在上面的声明中，第一个和第二声明被编译器当作两个完全不同的类型，即使他们的成员列表是一样的，如果令 t3=&amp;s1，则是非法的。</span><br><span class="line"></span><br><span class="line">结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针，而通常这种指针的应用是为了实现一些更高级的数据结构如链表和树等。</span><br><span class="line"></span><br><span class="line">//此结构体的声明包含了其他的结构体</span><br><span class="line">struct COMPLEX</span><br><span class="line">&#123;</span><br><span class="line">    char string[100];</span><br><span class="line">    struct SIMPLE a;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">//此结构体的声明包含了指向自己类型的指针</span><br><span class="line">struct NODE</span><br><span class="line">&#123;</span><br><span class="line">    char string[100];</span><br><span class="line">    struct NODE *next_node;</span><br><span class="line">&#125;;</span><br><span class="line">如果两个结构体互相包含，则需要对其中一个结构体进行不完整声明，如下所示：</span><br><span class="line"></span><br><span class="line">struct B;    //对结构体B进行不完整声明</span><br><span class="line"> </span><br><span class="line">//结构体A中包含指向结构体B的指针</span><br><span class="line">struct A</span><br><span class="line">&#123;</span><br><span class="line">    struct B *partner;</span><br><span class="line">    //other members;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">//结构体B中包含指向结构体A的指针，在A声明完后，B也随之进行声明</span><br><span class="line">struct B</span><br><span class="line">&#123;</span><br><span class="line">    struct A *partner;</span><br><span class="line">    //other members;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的声明中，第一个和第二声明被编译器当作两个完全不同的类型，即使他们的成员列表是一样的，如果令 t3&#x3D;&amp;s1，则是非法的。</p>
<p>结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针，而通常这种指针的应用是为了实现一些更高级的数据结构如链表和树等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//此结构体的声明包含了其他的结构体</span><br><span class="line">struct COMPLEX</span><br><span class="line">&#123;</span><br><span class="line">    char string[100];</span><br><span class="line">    struct SIMPLE a;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">//此结构体的声明包含了指向自己类型的指针</span><br><span class="line">struct NODE</span><br><span class="line">&#123;</span><br><span class="line">    char string[100];</span><br><span class="line">    struct NODE *next_node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果两个结构体互相包含，则需要对其中一个结构体进行不完整声明，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct B;    //对结构体B进行不完整声明</span><br><span class="line"> </span><br><span class="line">//结构体A中包含指向结构体B的指针</span><br><span class="line">struct A</span><br><span class="line">&#123;</span><br><span class="line">    struct B *partner;</span><br><span class="line">    //other members;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">//结构体B中包含指向结构体A的指针，在A声明完后，B也随之进行声明</span><br><span class="line">struct B</span><br><span class="line">&#123;</span><br><span class="line">    struct A *partner;</span><br><span class="line">    //other members;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="指向结构的指针"><a href="#指向结构的指针" class="headerlink" title="指向结构的指针"></a>指向结构的指针</h2><p>您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct Books *struct_pointer;</span><br></pre></td></tr></table></figure>

<p>现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 &amp; 运算符放在结构名称的前面，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct_pointer = &amp;Book1;</span><br></pre></td></tr></table></figure>

<p>为了使用指向该结构的指针访问结构的成员，您必须使用 -&gt; 运算符，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct_pointer-&gt;title;</span><br></pre></td></tr></table></figure>

<p>让我们使用结构指针来重写上面的实例，这将有助于您理解结构指针的概念：</p>
<h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">struct Books</span><br><span class="line">&#123;</span><br><span class="line">   char  title[50];</span><br><span class="line">   char  author[50];</span><br><span class="line">   char  subject[100];</span><br><span class="line">   int   book_id;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">/* 函数声明 */</span><br><span class="line">void printBook( struct Books *book );</span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   struct Books Book1;        /* 声明 Book1，类型为 Books */</span><br><span class="line">   struct Books Book2;        /* 声明 Book2，类型为 Books */</span><br><span class="line"> </span><br><span class="line">   /* Book1 详述 */</span><br><span class="line">   strcpy( Book1.title, &quot;C Programming&quot;);</span><br><span class="line">   strcpy( Book1.author, &quot;Nuha Ali&quot;); </span><br><span class="line">   strcpy( Book1.subject, &quot;C Programming Tutorial&quot;);</span><br><span class="line">   Book1.book_id = 6495407;</span><br><span class="line"> </span><br><span class="line">   /* Book2 详述 */</span><br><span class="line">   strcpy( Book2.title, &quot;Telecom Billing&quot;);</span><br><span class="line">   strcpy( Book2.author, &quot;Zara Ali&quot;);</span><br><span class="line">   strcpy( Book2.subject, &quot;Telecom Billing Tutorial&quot;);</span><br><span class="line">   Book2.book_id = 6495700;</span><br><span class="line"> </span><br><span class="line">   /* 通过传 Book1 的地址来输出 Book1 信息 */</span><br><span class="line">   printBook( &amp;Book1 );</span><br><span class="line"> </span><br><span class="line">   /* 通过传 Book2 的地址来输出 Book2 信息 */</span><br><span class="line">   printBook( &amp;Book2 );</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line">void printBook( struct Books *book )</span><br><span class="line">&#123;</span><br><span class="line">   printf( &quot;Book title : %s\n&quot;, book-&gt;title);</span><br><span class="line">   printf( &quot;Book author : %s\n&quot;, book-&gt;author);</span><br><span class="line">   printf( &quot;Book subject : %s\n&quot;, book-&gt;subject);</span><br><span class="line">   printf( &quot;Book book_id : %d\n&quot;, book-&gt;book_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>struct内存原则：</strong> 从上至下进行内存分配，对齐方式以<strong>当前分配到的</strong>内部成员类型<strong>最宽字节数</strong>为基准；整体以结构体成员最宽类型字节为基准，且整个结构体的总大小为最宽基本类型成员大小的整数倍。</p>
<ol>
<li>struct A 内存分配</li>
</ol>
<p>来看一下结构体AA的内存分配：编译器首先将变量 char a 分配一个字节，并以1个字节为对齐基准；<br>接着对 short b 进行内存分配，此时发现b为两个字节，则以b为基准对齐，此时 a 需要补充一个字节内存，a、b 总分配内存为4个字节；<br>接着对 int c 进行内存分配，发现c占4个字节，则以4个字节为基准对齐，因为之前 a、b 内存共计为4个字节刚好与“4个字节的基准”一致，则此时 struct A 共计8个字节内存。<br>struct A { char a; short b; int c; };</p>
<p>结构体中成员变量分配的空间是按照成员变量中占用空间最大的来作为分配单位,同样成员变量的存储空间也是不能跨分配单位的,如果当前的空间不足,则会存储到下一个分配单位中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char a;</span><br><span class="line">    unsigned int  b;</span><br><span class="line">    unsigned char c;</span><br><span class="line">&#125; debug_size1_t;</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char a;</span><br><span class="line">    unsigned char b;</span><br><span class="line">    unsigned int  c;</span><br><span class="line">&#125; debug_size2_t;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;debug_size1_t size=%lu,debug_size2_t size=%lu\r\n&quot;, sizeof(debug_size1_t), sizeof(debug_size2_t));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译执行输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debug_size1_t size=12,debug_size2_t size=8</span><br></pre></td></tr></table></figure>

<p>结构体占用存储空间,以32位机为例</p>
<ul>
<li><p>1.debug_size1_t 存储空间分布为a(1byte)+空闲(3byte)+b(4byte)+c(1byte)+空闲(3byte)&#x3D;12(byte)。</p>
</li>
<li><p>1.debug_size2_t 存储空间分布为a(1byte)+b(1byte)+空闲(2byte)+c(4byte)&#x3D;8(byte)。</p>
</li>
</ul>
<hr>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    struct Student &#123;</span><br><span class="line">        char name[50];</span><br><span class="line">        int gender;</span><br><span class="line">        int age;</span><br><span class="line">    &#125; student2 = &#123;&quot;张三&quot;,0,30&#125;;</span><br><span class="line">    struct Student student1;</span><br><span class="line">    printf(&quot;name:\n&quot;);</span><br><span class="line">    scanf(&quot;%s&quot;,student1.name);</span><br><span class="line">    printf(&quot;gender:\n&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;student1.gender);</span><br><span class="line">    printf(&quot;age:\n&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;student1.age);</span><br><span class="line">    printf(&quot;student1 &gt;&gt;name = %s, gender = %d, age = %d\n&quot;, student1.name, student1.gender, student1.age);</span><br><span class="line">    printf(&quot;student2 &gt;&gt;name = %s, gender = %d, age = %d\n&quot;, student2.name, student2.gender, student2.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    struct Student &#123;</span><br><span class="line">        char name[100];</span><br><span class="line">        int gender;</span><br><span class="line">        int age;</span><br><span class="line">    &#125; student2 = &#123;&quot;0&quot;,0,1&#125;;//char数组初始化如果是&#x27;0&#x27;，age会无法初始化。中文占两个字节，而char类型是一个字节长度的；因此，它的长度与char类型数据并不符合。这也就意味着我们不能像char类型一样简单操作中文字符</span><br><span class="line">   </span><br><span class="line">    struct Student student1;</span><br><span class="line">    printf(&quot;name:\n&quot;);</span><br><span class="line">    scanf(&quot;%s&quot;,&amp;student1.name);</span><br><span class="line">    printf(&quot;gender:\n&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;student1.gender);</span><br><span class="line">    printf(&quot;age:\n&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;student1.age);</span><br><span class="line">    printf(&quot;student2 &gt;&gt;name:\n&quot;);</span><br><span class="line">    scanf(&quot;%s&quot;,&amp;student2.name);//阻止了汉字乱码</span><br><span class="line">    printf(&quot;student1 &gt;&gt;name = %s, gender = %d, age = %d\n&quot;, student1.name, student1.gender, student1.age);</span><br><span class="line">    printf(&quot;student2 &gt;&gt;name = %s, gender = %d, age = %d\n&quot;, student2.name, student2.gender, student2.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h2><p>一个结构体变量中可以存放一组数据（如一个学生的学号，姓名，成绩等数据）。如果有10个学生的数据需要参加运算，显然应该用数组，这就是结构体数组。结构体数组与以前介绍过的数据值型数组不同之处在于每个数组元素都一个结构体类型的数据，它们分别包括各个成员（分量）项。</p>
<h3 id="定义结构体数组"><a href="#定义结构体数组" class="headerlink" title="定义结构体数组"></a>定义结构体数组</h3><p>和定义结构体变量的方法相仿，只需说明其为数组即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct student</span><br><span class="line">&#123;</span><br><span class="line">    int num;</span><br><span class="line">    char name[20];</span><br><span class="line">    char sex;</span><br><span class="line">    int age;</span><br><span class="line">    float score;</span><br><span class="line">    char addr[30];</span><br><span class="line">&#125;;</span><br><span class="line">struct student stu[3];</span><br></pre></td></tr></table></figure>

<hr>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/03/16/c%E5%92%8Cc++/%E7%AC%AC%E4%B8%89%E5%A4%A9-c%E8%AF%AD%E8%A8%80/" rel="prev" title="第三天 c语言">
      <i class="fa fa-chevron-left"></i> 第三天 c语言
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/03/19/c%E5%92%8Cc++/%E7%AC%AC%E4%BA%94%E5%A4%A9-c%E8%AF%AD%E8%A8%80/" rel="next" title="第五天 c语言">
      第五天 c语言 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="nav-number">1.</span> <span class="nav-text">回调函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E6%9F%90%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">1.1.</span> <span class="nav-text">函数指针作为某个函数的参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.1.1.</span> <span class="nav-text">实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B-1"><span class="nav-number">1.2.</span> <span class="nav-text">实例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.</span> <span class="nav-text">C字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B-2"><span class="nav-number">2.0.0.0.1.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B-3"><span class="nav-number">2.0.0.0.2.</span> <span class="nav-text">实例</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">3.</span> <span class="nav-text">C结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E5%90%91%E7%BB%93%E6%9E%84%E7%9A%84%E6%8C%87%E9%92%88"><span class="nav-number">3.1.</span> <span class="nav-text">指向结构的指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B-4"><span class="nav-number">3.1.1.</span> <span class="nav-text">实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84"><span class="nav-number">3.2.</span> <span class="nav-text">结构体数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84"><span class="nav-number">3.2.1.</span> <span class="nav-text">定义结构体数组</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">肖汇林</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">肖汇林</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
