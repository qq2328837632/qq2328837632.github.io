<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="static修饰的函数作用与意义static修饰的函数叫做静态函数，静态函数有两种，根据其出现的地方来分类： 如果这个静态函数出现在类里，那么它是一个静态成员函数；        静态成员函数的作用在于：调用这个函数不会访问或者修改任何对象（非static）数据成员。 ​    其实很好理解，类的静态成员(变量和方法)属于类本身，在类加载的时候就会分配内存，可以通过类名直接去访问；非静态成员（变量">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux网络编程-libevent">
<meta property="og:url" content="http://example.com/2023/07/15/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent/index.html">
<meta property="og:site_name" content="肖汇林的博客">
<meta property="og:description" content="static修饰的函数作用与意义static修饰的函数叫做静态函数，静态函数有两种，根据其出现的地方来分类： 如果这个静态函数出现在类里，那么它是一个静态成员函数；        静态成员函数的作用在于：调用这个函数不会访问或者修改任何对象（非static）数据成员。 ​    其实很好理解，类的静态成员(变量和方法)属于类本身，在类加载的时候就会分配内存，可以通过类名直接去访问；非静态成员（变量">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent/image-20230716114206318.png">
<meta property="og:image" content="http://example.com/2023/07/15/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent/image-20230716114206318.png">
<meta property="og:image" content="http://example.com/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent/image-20230717161012885.png">
<meta property="og:image" content="http://example.com/2023/07/15/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent/image-20230717161012885.png">
<meta property="og:image" content="http://example.com/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent/image-20230717162404576.png">
<meta property="og:image" content="http://example.com/2023/07/15/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent/image-20230717162404576.png">
<meta property="article:published_time" content="2023-07-15T08:35:58.000Z">
<meta property="article:modified_time" content="2023-07-26T08:08:35.691Z">
<meta property="article:author" content="肖汇林">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent/image-20230716114206318.png">

<link rel="canonical" href="http://example.com/2023/07/15/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Linux网络编程-libevent | 肖汇林的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖汇林的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/15/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux网络编程-libevent
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-15 16:35:58" itemprop="dateCreated datePublished" datetime="2023-07-15T16:35:58+08:00">2023-07-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-26 16:08:35" itemprop="dateModified" datetime="2023-07-26T16:08:35+08:00">2023-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="static修饰的函数作用与意义"><a href="#static修饰的函数作用与意义" class="headerlink" title="static修饰的函数作用与意义"></a>static修饰的函数作用与意义</h2><p>static修饰的函数叫做静态函数，静态函数有两种，根据其出现的地方来分类：</p>
<p>如果这个静态函数出现在类里，那么它是一个静态成员函数；<br>        静态成员函数的作用在于：<strong>调用这个函数不会访问或者修改任何对象（非static）数据成员。</strong></p>
<p>​    其实很好理解，类的静态成员(变量和方法)属于类本身，在类加载的时候就会分配内存，可以通过类名直接去访问；非静态成员（变量和方法）属于类的对象，所以只有在类的对象产生（创建类的实例）时才会分配内存，然后通过类的对象（实例）去访问。</p>
<p>如果它不是出现在类中，那么它是一个普通的全局的静态函数。<br>        这样的static函数与普通函数的区别是：用static修饰的函数，限定在本源码文件中，不能被本源码文件以外的代码文件调用。而普通的函数，默认是extern的，也就是说它可以被其它代码文件调用。<br>　　在函数的返回类型前加上关键字static，函数就被定义成为静态函数。普通 函数的定义和声明默认情况下是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。因此定义静态函数有以下好处：<br>　　&lt;1&gt; 其他文件中可以定义相同名字的函数，不会发生冲突。<br>　　&lt;2&gt; 静态函数不能被其他文件所用。</p>
<p>在C++中，静态成员函数（static function）是与类关联的函数，而不是与类的实例对象关联的。它们可以直接通过类名调用，无需创建类的实例。</p>
<p>静态成员函数在以下几种情况下被调用：</p>
<ol>
<li>通过类名调用：静态成员函数可以通过类名直接调用，而不需要通过类的实例对象。这样调用时，它们与普通的全局函数类似，没有隐含的 this 指针。例如：<code>ClassName::staticFunction()</code>。</li>
<li>在类内部调用：静态成员函数可以在类的其他成员函数中被调用，包括其他静态成员函数和非静态成员函数。</li>
<li>在类的派生类中调用：派生类可以通过类名或派生类名直接调用继承的静态成员函数。</li>
</ol>
<p>需要注意的是，静态成员函数只能访问类的静态成员变量和其他静态成员函数，不能直接访问类的非静态成员变量和非静态成员函数。静态成员函数也没有访问权限限定符（public、private、protected）的限制。</p>
<p>静态成员函数的主要作用是为了某些与类相关的功能提供一个公共的接口，不依赖于类的实例化。常见的用途包括实现工具函数、访问类的静态成员变量等</p>
<h2 id="libevent简介"><a href="#libevent简介" class="headerlink" title="libevent简介"></a>libevent简介</h2><p>libevent库</p>
<p>  开源。精简。跨平台（Windows、Linux、maxos、unix）。专注于网络通信。</p>
<p>源码包安装： 参考 README、readme</p>
<p>  .&#x2F;configure    检查安装环境 生成 makefile</p>
<p>  make     生成 .o 和 可执行文件 </p>
<p>  sudo make install 将必要的资源cp置系统指定目录。</p>
<p>  进入 sample 目录，运行demo验证库安装使用情况。 </p>
<p>  编译使用库的 .c 时，需要加 -levent 选项。 </p>
<p>  库名 libevent.so –&gt; &#x2F;usr&#x2F;local&#x2F;lib  查看的到。</p>
<p>特性：</p>
<p>  基于“事件”异步通信模型。— 回调。</p>
<h2 id="libevent封装的框架思想"><a href="#libevent封装的框架思想" class="headerlink" title="libevent封装的框架思想"></a>libevent封装的框架思想</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">libevent框架：</span><br><span class="line"></span><br><span class="line">	1. 创建 event_base		(乐高底座)</span><br><span class="line">	2. 创建 事件evnet	</span><br><span class="line">	3. 将事件 添加到 base上	</span><br><span class="line">	4. 循环监听事件满足</span><br><span class="line">	5. 释放 event_base</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 创建 event_base		(乐高底座)</span><br><span class="line"></span><br><span class="line">		struct event_base *event_base_new(void);</span><br><span class="line"></span><br><span class="line">		struct event_base *base = event_base_new();</span><br><span class="line"></span><br><span class="line">2. 创建 事件evnet	</span><br><span class="line"></span><br><span class="line">		常规事件 event	--&gt; event_new(); </span><br><span class="line"></span><br><span class="line">		bufferevent --&gt; bufferevent_socket_new();</span><br><span class="line"></span><br><span class="line">3. 将事件 添加到 base上	</span><br><span class="line"></span><br><span class="line">		int event_add(struct event *ev, const struct timeval *tv)</span><br><span class="line"></span><br><span class="line">4. 循环监听事件满足</span><br><span class="line"></span><br><span class="line">		int event_base_dispatch(struct event_base *base);</span><br><span class="line"></span><br><span class="line">			event_base_dispatch(base);</span><br><span class="line"></span><br><span class="line">5. 释放 event_base</span><br><span class="line"></span><br><span class="line">		event_base_free(base);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="一些不常用相关函数了解"><a href="#一些不常用相关函数了解" class="headerlink" title="一些不常用相关函数了解"></a>一些不常用相关函数了解</h2><p>查看支持哪些多路IO<br><code>const char **event_get_supported_methods(void);</code></p>
<p>查看当前用的多路lO<br><code>const char * event_base_get_method(const struct event_base *base);</code></p>
<p>查看fork 后子进程使用的event_base<br><code>int event_reinit(struct event_base *base);</code><br>成功︰0，失败︰ -1<br>使用该函数后，父创建的base才能在子进程中生效。”</p>
<p><code>int event_base_loopexit(struct event_base *base, const struct timeval *tv);</code><br>在指定时间后停止循环。</p>
<p><code>int event_base_loopbreak(struct event_base *base);</code><br>立即停止循环。</p>
<h2 id="创建事件对象"><a href="#创建事件对象" class="headerlink" title="创建事件对象"></a>创建事件对象</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">创建事件event：</span><br><span class="line"></span><br><span class="line">	struct event *ev；</span><br><span class="line"></span><br><span class="line">	struct event *event_new(struct event_base *base，evutil_socket_t fd，short what，event_callback_fn cb;  void *arg);</span><br><span class="line"></span><br><span class="line">		base： event_base_new()返回值。</span><br><span class="line"></span><br><span class="line">		 fd： 绑定到 event 上的 文件描述符</span><br><span class="line"></span><br><span class="line">		what：对应的事件（r、w、e）</span><br><span class="line"></span><br><span class="line">			EV_READ		一次 读事件</span><br><span class="line"></span><br><span class="line">			EV_WRTIE	一次 写事件</span><br><span class="line"></span><br><span class="line">			EV_PERSIST	持续触发。 结合 event_base_dispatch 函数使用，生效。</span><br><span class="line"></span><br><span class="line">		cb：一旦事件满足监听条件，回调的函数。</span><br><span class="line"></span><br><span class="line">		typedef void (*event_callback_fn)(evutil_socket_t fd,  short,  void *)	</span><br><span class="line"></span><br><span class="line">		arg： 回调的函数的参数。</span><br><span class="line"></span><br><span class="line">		返回值：成功创建的 event</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="事件event操作"><a href="#事件event操作" class="headerlink" title="事件event操作"></a>事件event操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">添加事件到 event_base</span><br><span class="line"></span><br><span class="line">	int event_add(struct event *ev, const struct timeval *tv);</span><br><span class="line"></span><br><span class="line">		ev: event_new() 的返回值。</span><br><span class="line"></span><br><span class="line">		tv：NULL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">销毁事件</span><br><span class="line"></span><br><span class="line">	int event_free(struct event *ev);</span><br><span class="line"></span><br><span class="line">		ev: event_new() 的返回值。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用fifo的读写"><a href="#使用fifo的读写" class="headerlink" title="使用fifo的读写"></a>使用fifo的读写</h2><p>读端的代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;sys/types.h&gt;  </span><br><span class="line">#include &lt;sys/stat.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;fcntl.h&gt;  </span><br><span class="line">#include &lt;event2/event.h&gt;  </span><br><span class="line">  </span><br><span class="line">// 对操作处理函数  </span><br><span class="line">void read_cb(evutil_socket_t fd, short what, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    // 读管道  </span><br><span class="line">    char buf[1024] = &#123;0&#125;;  </span><br><span class="line">      </span><br><span class="line">    int len = read(fd, buf, sizeof(buf));  </span><br><span class="line">      </span><br><span class="line">    printf(&quot;read event: %s \n&quot;, what &amp; EV_READ ? &quot;Yes&quot; : &quot;No&quot;);  </span><br><span class="line">    printf(&quot;data len = %d, buf = %s\n&quot;, len, buf);  </span><br><span class="line">      </span><br><span class="line">    sleep(1);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">// 读管道  </span><br><span class="line">int main(int argc, const char* argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">    unlink(&quot;myfifo&quot;);  </span><br><span class="line">  </span><br><span class="line">    //创建有名管道  </span><br><span class="line">    mkfifo(&quot;myfifo&quot;, 0664);  </span><br><span class="line">  </span><br><span class="line">    // open file  </span><br><span class="line">    int fd = open(&quot;myfifo&quot;, O_RDONLY | O_NONBLOCK);//因为libevent是基于epoll反应堆实现的，所以是非阻塞的 </span><br><span class="line">    //int fd = open(&quot;myfifo&quot;, O_RDONLY);  </span><br><span class="line">    if(fd == -1)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(&quot;open error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // 创建个event_base  </span><br><span class="line">    struct event_base* base = NULL;  </span><br><span class="line">    base = event_base_new();  </span><br><span class="line">  </span><br><span class="line">    // 创建事件  </span><br><span class="line">    struct event* ev = NULL;  </span><br><span class="line">    ev = event_new(base, fd, EV_READ | EV_PERSIST, read_cb, NULL);  </span><br><span class="line">  </span><br><span class="line">    // 添加事件  </span><br><span class="line">    event_add(ev, NULL);  </span><br><span class="line">  </span><br><span class="line">    // 事件循环  </span><br><span class="line">    event_base_dispatch(base);  // while（1） &#123; epoll();&#125;  </span><br><span class="line">  </span><br><span class="line">    // 释放资源  </span><br><span class="line">    event_free(ev);  </span><br><span class="line">    event_base_free(base);  </span><br><span class="line">    close(fd);  </span><br><span class="line">      </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>写管道代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;sys/types.h&gt;  </span><br><span class="line">#include &lt;sys/stat.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;fcntl.h&gt;  </span><br><span class="line">#include &lt;event2/event.h&gt;  </span><br><span class="line">  </span><br><span class="line">// 对操作处理函数  </span><br><span class="line">void write_cb(evutil_socket_t fd, short what, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    // write管道  </span><br><span class="line">    char buf[1024] = &#123;0&#125;;  </span><br><span class="line">      </span><br><span class="line">    static int num = 0;  </span><br><span class="line">    sprintf(buf, &quot;hello,world-%d\n&quot;, num++);  </span><br><span class="line">    write(fd, buf, strlen(buf)+1);  </span><br><span class="line">      </span><br><span class="line">    sleep(1);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">// 写管道  </span><br><span class="line">int main(int argc, const char* argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">    // open file  </span><br><span class="line">    //int fd = open(&quot;myfifo&quot;, O_WRONLY | O_NONBLOCK);  </span><br><span class="line">    int fd = open(&quot;myfifo&quot;, O_WRONLY);  </span><br><span class="line">    if(fd == -1)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(&quot;open error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // 写管道  </span><br><span class="line">    struct event_base* base = NULL;  </span><br><span class="line">    base = event_base_new();  </span><br><span class="line">  </span><br><span class="line">    // 创建事件  </span><br><span class="line">    struct event* ev = NULL;  </span><br><span class="line">    // 检测的写缓冲区是否有空间写  </span><br><span class="line">    //ev = event_new(base, fd, EV_WRITE , write_cb, NULL);  </span><br><span class="line">    ev = event_new(base, fd, EV_WRITE | EV_PERSIST, write_cb, NULL);  </span><br><span class="line">  </span><br><span class="line">    // 添加事件  </span><br><span class="line">    event_add(ev, NULL);  </span><br><span class="line">  </span><br><span class="line">    // 事件循环  </span><br><span class="line">    event_base_dispatch(base);  </span><br><span class="line">  </span><br><span class="line">    // 释放资源  </span><br><span class="line">    event_free(ev);  </span><br><span class="line">    event_base_free(base);  </span><br><span class="line">    close(fd);  </span><br><span class="line">      </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个也说明不一定只能在网络上才能用libevent库</p>
<h2 id="未决和非未决"><a href="#未决和非未决" class="headerlink" title="未决和非未决"></a>未决和非未决</h2><p>未决和非未决： </p>
<p>  非未决: 没有资格被处理</p>
<p>  未决： 有资格被处理，但尚未被处理</p>
<p>  event_new –&gt; event —&gt; 非未决 –&gt; event_add –&gt; 未决 –&gt; dispatch() &amp;&amp; 监听事件被触发 –&gt; 激活态 </p>
<p>  –&gt; 执行回调函数 –&gt; 处理态 –&gt; 非未决 event_add &amp;&amp; EV_PERSIST –&gt; 未决 –&gt; event_del –&gt; 非未决</p>
<p><img src="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent/image-20230716114206318.png" alt="image-20230716114206318"></p>
<img src="/2023/07/15/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent/image-20230716114206318.png" class title="This is an test image">

<h2 id="bufferevent特性"><a href="#bufferevent特性" class="headerlink" title="bufferevent特性"></a>bufferevent特性</h2><p><img src="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent/image-20230717161012885.png" alt="image-20230717161012885"></p>
<img src="/2023/07/15/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent/image-20230717161012885.png" class title="This is an test image">

<p>带缓冲区的事件 bufferevent</p>
<p>  <code>#include &lt;event2/bufferevent.h&gt;</code>  </p>
<p>  <code>read/write 两个缓冲. 借助 队列.</code></p>
<h3 id="bufferevent事件对象创建、销毁"><a href="#bufferevent事件对象创建、销毁" class="headerlink" title="bufferevent事件对象创建、销毁"></a>bufferevent事件对象创建、销毁</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">创建、销毁bufferevent：</span><br><span class="line"></span><br><span class="line">	struct bufferevent *ev；</span><br><span class="line"></span><br><span class="line">	struct bufferevent *bufferevent_socket_new(struct event_base *base, evutil_socket_t fd, enum bufferevent_options options);</span><br><span class="line"></span><br><span class="line">		base： event_base</span><br><span class="line"></span><br><span class="line">		fd:	封装到bufferevent内的 fd</span><br><span class="line"></span><br><span class="line">		options：BEV_OPT_CLOSE_ON_FREE（设置它在关闭的时候释放相应的这个套件对象）</span><br><span class="line"></span><br><span class="line">	返回： 成功创建的 bufferevent事件对象。</span><br><span class="line">void  bufferevent_socket_free(struct bufferevent *ev);</span><br></pre></td></tr></table></figure>

<h3 id="给bufferevent事件对象设置回调"><a href="#给bufferevent事件对象设置回调" class="headerlink" title="给bufferevent事件对象设置回调"></a>给bufferevent事件对象设置回调</h3><p><code>bufferevent_flush()</code> 函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cCopy Codeint bufferevent_flush(struct bufferevent *bufev, short iotype, enum bufferevent_flush_mode mode);</span><br></pre></td></tr></table></figure>

<p>该函数用于将缓冲区中的数据写入底层传输机制，以确保数据尽快发送出去。</p>
<p>参数说明：</p>
<ul>
<li><code>bufev</code>：指向 <code>struct bufferevent</code> 结构体的指针，表示要刷新的缓冲事件。</li>
<li><code>iotype</code>：表示刷新操作的类型，可以是 <code>EV_READ</code>、<code>EV_WRITE</code> 或它们的按位或运算结果。如果指定了 <code>EV_READ</code>，则刷新读缓冲区；如果指定了 <code>EV_WRITE</code>，则刷新写缓冲区。</li>
<li><code>mode</code>：表示刷新模式，可以是 <code>BEV_NORMAL</code>、<code>BEV_FLUSH</code> 或 <code>BEV_FINISHED</code>。<code>BEV_NORMAL</code> 表示正常模式，<code>BEV_FLUSH</code> 表示强制刷新缓冲区，<code>BEV_FINISHED</code> 表示刷新完毕。</li>
</ul>
<p>函数返回值为 0 表示成功，-1 表示失败。</p>
<p>通过调用 <code>bufferevent_flush()</code> 函数，可以显式地触发将缓冲区中的数据发送到底层传输机制。需要注意的是，该函数只是将数据写入底层传输机制，并不保证立即发送到对端，实际的发送可能受到底层传输机制和网络状况的影响。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">给bufferevent设置回调：</span><br><span class="line">	</span><br><span class="line">	对比event：	event_new( fd, callback );  					event_add() -- 挂到 event_base 上。</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">			bufferevent_socket_new（fd）  bufferevent_setcb（ callback ）</span><br><span class="line"></span><br><span class="line">	void bufferevent_setcb(struct bufferevent * bufev,</span><br><span class="line">				bufferevent_data_cb readcb,</span><br><span class="line">				bufferevent_data_cb writecb,</span><br><span class="line">				bufferevent_event_cb eventcb,</span><br><span class="line">				void *cbarg );</span><br><span class="line"></span><br><span class="line">	bufev： bufferevent_socket_new() 返回值</span><br><span class="line"></span><br><span class="line">	readcb： 设置 bufferevent 读缓冲，对应回调  read_cb&#123;  bufferevent_read() 读数据  &#125;</span><br><span class="line"></span><br><span class="line">	writecb： 设置 bufferevent 写缓冲，对应回调 write_cb &#123;  &#125; -- 给调用者，发送写成功通知。  可以 NULL,因为它是写成功才调用，很鸡肋</span><br><span class="line"></span><br><span class="line">	eventcb： 设置 事件回调。   也可传NULL</span><br><span class="line"></span><br><span class="line">		typedef void (*bufferevent_event_cb)(struct bufferevent *bev,  short events, void *ctx);</span><br><span class="line"></span><br><span class="line">		void event_cb(struct bufferevent *bev,  short events, void *ctx)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			。。。。。</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		events： BEV_EVENT_CONNECTED</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cbarg：	上述回调函数使用的 参数。</span><br><span class="line"></span><br><span class="line">	read 回调函数类型：</span><br><span class="line"></span><br><span class="line">		typedef void (*bufferevent_data_cb)(struct bufferevent *bev, void*ctx);</span><br><span class="line"></span><br><span class="line">		void read_cb(struct bufferevent *bev, void *cbarg )</span><br><span class="line">		&#123;</span><br><span class="line">			.....</span><br><span class="line">			bufferevent_read();   --- read();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	bufferevent_read()函数的原型：</span><br><span class="line"></span><br><span class="line">		size_t bufferevent_read(struct bufferevent *bev, void *buf, size_t bufsize);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	write 回调函数类型：</span><br><span class="line"></span><br><span class="line">		int bufferevent_write(struct bufferevent *bufev, const void *data,  size_t size);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="缓冲区开启和关闭"><a href="#缓冲区开启和关闭" class="headerlink" title="缓冲区开启和关闭"></a>缓冲区开启和关闭</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">启动、关闭 bufferevent的 缓冲区：</span><br><span class="line"></span><br><span class="line">	void bufferevent_enable(struct bufferevent *bufev, short events);   启动	</span><br><span class="line"></span><br><span class="line">		events： EV_READ、EV_WRITE、EV_READ|EV_WRITE</span><br><span class="line"></span><br><span class="line">		默认write 缓冲是 enable、read 缓冲是 disable</span><br><span class="line"></span><br><span class="line">			bufferevent_enable(evev, EV_READ);		-- 开启读缓冲。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="客户端和服务器连接和监听"><a href="#客户端和服务器连接和监听" class="headerlink" title="客户端和服务器连接和监听"></a>客户端和服务器连接和监听</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">连接客户端：</span><br><span class="line"></span><br><span class="line">	socket();connect();</span><br><span class="line"></span><br><span class="line">	int bufferevent_socket_connect(struct bufferevent *bev, struct sockaddr *address, int addrlen);</span><br><span class="line"></span><br><span class="line">		bev: bufferevent 事件对象（封装了fd）</span><br><span class="line"></span><br><span class="line">		address、len：等同于 connect() 参2/3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">创建监听服务器：</span><br><span class="line"></span><br><span class="line">	------ socket();bind();listen();accept();</span><br><span class="line"></span><br><span class="line">	struct evconnlistener * listner</span><br><span class="line"></span><br><span class="line">	struct evconnlistener *evconnlistener_new_bind (	</span><br><span class="line">		struct event_base *base,</span><br><span class="line">		evconnlistener_cb cb, </span><br><span class="line">		void *ptr, </span><br><span class="line">		unsigned flags,</span><br><span class="line">		int backlog,</span><br><span class="line">		const struct sockaddr *sa,</span><br><span class="line">		int socklen);</span><br><span class="line"></span><br><span class="line">	base： event_base</span><br><span class="line"></span><br><span class="line">	cb: 回调函数。 一旦被回调，说明在其内部应该与客户端完成， 数据读写操作，进行通信。</span><br><span class="line"></span><br><span class="line">	ptr： 回调函数的参数</span><br><span class="line"></span><br><span class="line">	flags： LEV_OPT_CLOSE_ON_FREE | LEV_OPT_REUSEABLE</span><br><span class="line"></span><br><span class="line">	backlog： listen() 2参。 -1 表最大值</span><br><span class="line"></span><br><span class="line">	sa：服务器自己的地址结构体</span><br><span class="line"></span><br><span class="line">	socklen：服务器自己的地址结构体大小。</span><br><span class="line"></span><br><span class="line">	返回值：成功创建的监听器。</span><br><span class="line">释放监听服务器:</span><br><span class="line"></span><br><span class="line">	void evconnlistener_free(struct evconnlistener *lev);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="libevent实现TCP服务器流程"><a href="#libevent实现TCP服务器流程" class="headerlink" title="libevent实现TCP服务器流程"></a>libevent实现TCP服务器流程</h2><p>服务器端 libevent 创建TCP连接：</p>
<ol>
<li>创建event_base</li>
<li>创建bufferevent事件对象。bufferevent_socket_new();</li>
<li>使用bufferevent_setcb() 函数给 bufferevent的 read、write、event 设置回调函数。</li>
<li>当监听的 事件满足时，read_cb会被调用， 在其内部 bufferevent_read();读</li>
<li>使用 evconnlistener_new_bind 创建监听服务器， 设置其回调函数，当有客户端成功连接时，这个回调函数会被调用。</li>
<li>封装 listner_cb() 在函数内部。完成与客户端通信。 </li>
<li>设置读缓冲、写缓冲的 使能状态 enable、disable</li>
<li>启动循环 event_base_dispath();</li>
<li>释放连接。</li>
</ol>
<p>服务器源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;sys/types.h&gt;  </span><br><span class="line">#include &lt;sys/stat.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;event2/event.h&gt;  </span><br><span class="line">#include &lt;event2/listener.h&gt;  </span><br><span class="line">#include &lt;event2/bufferevent.h&gt;  </span><br><span class="line">  </span><br><span class="line">// 读缓冲区回调  </span><br><span class="line">void read_cb(struct bufferevent *bev, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    char buf[1024] = &#123;0&#125;;     </span><br><span class="line">    bufferevent_read(bev, buf, sizeof(buf));  </span><br><span class="line">    printf(&quot;client say: %s\n&quot;, buf);  </span><br><span class="line">  </span><br><span class="line">    char *p = &quot;我是服务器, 已经成功收到你发送的数据!&quot;;  </span><br><span class="line">    // 发数据给客户端  </span><br><span class="line">    bufferevent_write(bev, p, strlen(p)+1);  </span><br><span class="line">    sleep(1);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// 写缓冲区回调  </span><br><span class="line">void write_cb(struct bufferevent *bev, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    printf(&quot;I&#x27;m服务器, 成功写数据给客户端,写缓冲区回调函数被回调...\n&quot;);   </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// 事件  </span><br><span class="line">void event_cb(struct bufferevent *bev, short events, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    if (events &amp; BEV_EVENT_EOF)  </span><br><span class="line">    &#123;  </span><br><span class="line">        printf(&quot;connection closed\n&quot;);    </span><br><span class="line">    &#125;  </span><br><span class="line">    else if(events &amp; BEV_EVENT_ERROR)     </span><br><span class="line">    &#123;  </span><br><span class="line">        printf(&quot;some other error\n&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    bufferevent_free(bev);      </span><br><span class="line">    printf(&quot;buffevent 资源已经被释放...\n&quot;);   </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"> // 被回调，说明有客户端成功连接， cfd已经传入该参数内部。 创建bufferevent事件对象 </span><br><span class="line"> // 与客户端完成读写操作。  </span><br><span class="line">void cb_listener(  </span><br><span class="line">        struct evconnlistener *listener,   </span><br><span class="line">        evutil_socket_t fd,   </span><br><span class="line">        struct sockaddr *addr,   </span><br><span class="line">        int len, void *ptr)  </span><br><span class="line">&#123;  </span><br><span class="line">   printf(&quot;connect new client\n&quot;);  </span><br><span class="line">  </span><br><span class="line">   struct event_base* base = (struct event_base*)ptr;  </span><br><span class="line">   // 通信操作  </span><br><span class="line">   // 添加新事件  </span><br><span class="line">   struct bufferevent *bev;  </span><br><span class="line">   bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);  //将fd封装进去bev</span><br><span class="line">  </span><br><span class="line">   // 给bufferevent缓冲区设置回调  </span><br><span class="line">   bufferevent_setcb(bev, read_cb, write_cb, event_cb, NULL);  //write_cb和event_cb甚至可以传NULL</span><br><span class="line">   // 启动 read 缓冲区的 使能状态</span><br><span class="line">   bufferevent_enable(bev, EV_READ);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">int main(int argc, const char* argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">  </span><br><span class="line">    // init server   </span><br><span class="line">    struct sockaddr_in serv;  </span><br><span class="line">  </span><br><span class="line">    memset(&amp;serv, 0, sizeof(serv));  </span><br><span class="line">    serv.sin_family = AF_INET;  </span><br><span class="line">    serv.sin_port = htons(9876);  </span><br><span class="line">    serv.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">  </span><br><span class="line">    struct event_base* base;  </span><br><span class="line">    base = event_base_new();  </span><br><span class="line">    // 创建套接字  </span><br><span class="line">    // 绑定  </span><br><span class="line">    // 接收连接请求  </span><br><span class="line">    struct evconnlistener* listener;  </span><br><span class="line">    listener = evconnlistener_new_bind(base, cb_listener, base,   </span><br><span class="line">                                  LEV_OPT_CLOSE_ON_FREE | LEV_OPT_REUSEABLE,   </span><br><span class="line">                                  36, (struct sockaddr*)&amp;serv, sizeof(serv));  </span><br><span class="line">  </span><br><span class="line">    event_base_dispatch(base);  </span><br><span class="line">  </span><br><span class="line">    evconnlistener_free(listener);  </span><br><span class="line">    event_base_free(base);  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="客户端流程简析和回顾"><a href="#客户端流程简析和回顾" class="headerlink" title="客户端流程简析和回顾"></a>客户端流程简析和回顾</h3><p><img src="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent/image-20230717162404576.png" alt="image-20230717162404576"></p>
<img src="/2023/07/15/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent/image-20230717162404576.png" class title="This is an test image">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;sys/types.h&gt;  </span><br><span class="line">#include &lt;sys/stat.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;event2/bufferevent.h&gt;  </span><br><span class="line">#include &lt;event2/event.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">  </span><br><span class="line">void read_cb(struct bufferevent *bev, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    char buf[1024] = &#123;0&#125;;   </span><br><span class="line">    bufferevent_read(bev, buf, sizeof(buf));  </span><br><span class="line">  </span><br><span class="line">    printf(&quot;fwq say:%s\n&quot;, buf);  </span><br><span class="line">  </span><br><span class="line">    bufferevent_write(bev, buf, strlen(buf)+1);  </span><br><span class="line">    sleep(1);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void write_cb(struct bufferevent *bev, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    printf(&quot;----------我是客户端的写回调函数,没卵用\n&quot;);   </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void event_cb(struct bufferevent *bev, short events, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    if (events &amp; BEV_EVENT_EOF)  </span><br><span class="line">    &#123;  </span><br><span class="line">        printf(&quot;connection closed\n&quot;);    </span><br><span class="line">    &#125;  </span><br><span class="line">    else if(events &amp; BEV_EVENT_ERROR)     </span><br><span class="line">    &#123;  </span><br><span class="line">        printf(&quot;some other error\n&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">    else if(events &amp; BEV_EVENT_CONNECTED)  </span><br><span class="line">    &#123;  </span><br><span class="line">        printf(&quot;已经连接服务器...\\(^o^)/...\n&quot;);  </span><br><span class="line">        return;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    // 释放资源  </span><br><span class="line">    bufferevent_free(bev);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// 客户端与用户交互，从终端读取数据写给服务器  </span><br><span class="line">void read_terminal(evutil_socket_t fd, short what, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    // 读数据  </span><br><span class="line">    char buf[1024] = &#123;0&#125;;  </span><br><span class="line">    int len = read(fd, buf, sizeof(buf));  </span><br><span class="line">  </span><br><span class="line">    struct bufferevent* bev = (struct bufferevent*)arg;  </span><br><span class="line">    // 发送数据  </span><br><span class="line">    bufferevent_write(bev, buf, len+1);  //将len增加1，确保缓冲区中包含字符串的终止符，这在处理字符串时非常重要。</span><br><span class="line"></span><br><span class="line">//如果不包括终止符，接收方可能会在读取数据时出现问题，因为它们可能没有办法确定何时停止读取字符串。因此，确保缓冲区的末尾有一个终止符可以提供字符串的正确性和完整性。</span><br><span class="line"></span><br><span class="line">//总之，使用len+1而不是简单的len确保了传输的字符串在缓冲区中正确终止，避免了潜在的错误和问题。</span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int main(int argc, const char* argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">    struct event_base* base = NULL;  </span><br><span class="line">    base = event_base_new();  </span><br><span class="line">  </span><br><span class="line">    int fd = socket(AF_INET, SOCK_STREAM, 0);  //没有服务器那边监听器，所以需要创建fd</span><br><span class="line">  </span><br><span class="line">    // 通信的fd放到bufferevent中  </span><br><span class="line">    struct bufferevent* bev = NULL;  </span><br><span class="line">    bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);  //将fd封装进bev</span><br><span class="line">  </span><br><span class="line">    // init server info  </span><br><span class="line">    struct sockaddr_in serv;  </span><br><span class="line">    memset(&amp;serv, 0, sizeof(serv));  </span><br><span class="line">    serv.sin_family = AF_INET;  </span><br><span class="line">    serv.sin_port = htons(9876);  </span><br><span class="line">    inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;serv.sin_addr.s_addr);  </span><br><span class="line">  </span><br><span class="line">    // 连接服务器  </span><br><span class="line">    bufferevent_socket_connect(bev, (struct sockaddr*)&amp;serv, sizeof(serv));  </span><br><span class="line">  </span><br><span class="line">    // 设置回调  </span><br><span class="line">    bufferevent_setcb(bev, read_cb, write_cb, event_cb, NULL);  </span><br><span class="line">  </span><br><span class="line">    // 设置读回调生效  </span><br><span class="line">    // bufferevent_enable(bev, EV_READ);  </span><br><span class="line">  </span><br><span class="line">    // 创建事件  </span><br><span class="line">    struct event* ev = event_new(base, STDIN_FILENO, EV_READ | EV_PERSIST,  </span><br><span class="line">                                 read_terminal, bev);  </span><br><span class="line">    // 添加事件                       </span><br><span class="line">    event_add(ev, NULL);  </span><br><span class="line">  </span><br><span class="line">    event_base_dispatch(base);  </span><br><span class="line">  </span><br><span class="line">    event_free(ev);  </span><br><span class="line">      </span><br><span class="line">    event_base_free(base);  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="还有一些函数"><a href="#还有一些函数" class="headerlink" title="还有一些函数"></a>还有一些函数</h2><h3 id="evsignal-new"><a href="#evsignal-new" class="headerlink" title="evsignal_new"></a>evsignal_new</h3><p><code>evsignal_new</code> 是一个函数，用于创建一个新的 libevent 信号事件对象。 libevent 是一个开源的高性能网络库，用于事件驱动的编程。</p>
<p><code>evsignal_new</code> 的声明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct event *evsignal_new(struct event_base *base, int signo,</span><br><span class="line">                           void (*cb)(evutil_socket_t, short, void *), void *arg);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>base</code>：指向事件基础结构体（<code>event_base</code>）的指针。</li>
<li><code>signo</code>：要监听的信号编号。</li>
<li><code>cb</code>：当信号触发时调用的回调函数。</li>
<li><code>arg</code>：传递给回调函数的参数。</li>
</ul>
<p>该函数成功创建并返回一个新的 <code>event</code> 结构体指针，或者返回 <code>NULL</code> 表示创建失败。</p>
<p>一般情况下，使用 <code>evsignal_new</code> 函数后，还需要调用 <code>event_add</code> 将事件添加到事件循环中，并调用 <code>event_base_dispatch</code> 开始事件循环。</p>
<h3 id="strcasecmp"><a href="#strcasecmp" class="headerlink" title="strcasecmp"></a>strcasecmp</h3><p><code>strcasecmp()</code> 是一个字符串比较函数，它忽略字符串的大小写差异进行比较。</p>
<p>语法形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cCopy Codeint strcasecmp(const char *str1, const char *str2);</span><br></pre></td></tr></table></figure>

<p>参数 <code>str1</code> 和 <code>str2</code> 分别是要比较的两个字符串。函数会将这两个字符串进行比较，并返回一个整数值，用于表示比较结果。</p>
<p>返回值的含义如下：</p>
<ul>
<li>如果 <code>str1</code> 等于 <code>str2</code>（不区分大小写），则返回值为 0。</li>
<li>如果 <code>str1</code> 大于 <code>str2</code>（忽略大小写），则返回值大于 0。</li>
<li>如果 <code>str1</code> 小于 <code>str2</code>（忽略大小写），则返回值小于 0。</li>
</ul>
<p>在给定的代码中，<code>strcasecmp(method, &quot;GET&quot;) == 0</code> 表达式用于判断字符串 <code>method</code> 是否等于 <code>&quot;GET&quot;</code>（不区分大小写）。如果相等，条件表达式的结果为真（非零），执行相应的代码块。否则，条件表达式的结果为假（零），代码块将被跳过。</p>
<p>因此，所给代码段用于检查 <code>method</code> 是否为 <code>&quot;GET&quot;</code>，并执行与之相关的处理逻辑。</p>
<h3 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h3><p><code>stat()</code> 函数被调用来获取指定文件的状态信息并存储在 <code>sb</code> 结构体中。<code>stat()</code> 函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cCopy Codeint stat(const char *path, struct stat *buf);</span><br></pre></td></tr></table></figure>

<p>参数 <code>path</code> 是要获取状态信息的文件路径，<code>buf</code> 是一个指向 <code>struct stat</code> 结构体的指针，用于存储获取到的状态信息。</p>
<p>函数返回值为 0 表示成功，-1 表示失败。</p>
<p>接下来，通过判断 <code>stat(pf, &amp;sb) &lt; 0</code> 来检查 <code>stat()</code> 函数是否执行失败。如果执行失败，说明无法获取文件的状态信息，这时会输出错误信息到标准错误流（使用 <code>perror()</code> 函数），发送错误响应（使用 <code>send_error()</code> 函数），并返回 -1，表示函数执行出错。</p>
<p>“状态”在这里指的是文件的状态信息，而不是文件的结尾。</p>
<p><code>stat()</code> 函数用于获取文件的状态信息，包括文件的权限、大小、修改时间等。通过 <code>struct stat</code> 结构体来存储这些信息。在给定的代码中，<code>stat()</code> 函数将获取到的文件状态信息存储在 <code>sb</code> 结构体中。</p>
<p>这些状态信息可以用于判断文件的类型（如普通文件、目录、符号链接等）、访问权限以及其他属性。通过检查这些状态信息，可以在程序中进行相应的逻辑处理，例如根据文件类型进行不同的操作或者判断文件是否存在等。</p>
<p>文件的结尾字符实际上是文件内容的一部分，而不是文件的状态信息。要读取文件的内容，可以使用文件操作函数如 <code>fread()</code> 或者相关的系统调用如 <code>read()</code> 来读取文件的字节流数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct stat sb;</span><br><span class="line">        if(stat(pf,&amp;sb) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;open file err:&quot;);</span><br><span class="line">            send_error(bev);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(S_ISDIR(sb.st_mode))//处理目录</span><br><span class="line">        &#123;</span><br><span class="line">            //应该显示目录列表</span><br><span class="line">            send_header(bev, 200, &quot;OK&quot;, get_file_type(&quot;.html&quot;), -1);</span><br><span class="line">            send_dir(bev, pf);</span><br><span class="line">        &#125;</span><br><span class="line">        else //处理文件</span><br><span class="line">        &#123;</span><br><span class="line">            send_header(bev, 200, &quot;OK&quot;, get_file_type(pf), sb.st_size);</span><br><span class="line">            send_file_to_http(pf, bev);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<h3 id="scandir"><a href="#scandir" class="headerlink" title="scandir"></a>scandir</h3><p><code>scandir()</code> 函数用于扫描指定目录中的文件，并将文件列表存储在一个目录项数组中。</p>
<p>具体解释如下：</p>
<ol>
<li><p><code>scandir()</code> 函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cCopy Codeint scandir(const char *dir, struct dirent ***namelist,</span><br><span class="line">            int (*filter)(const struct dirent *),</span><br><span class="line">            int (*compar)(const struct dirent **, const struct dirent **));</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数解析：</p>
<ul>
<li><code>dir</code>：要扫描的目录路径。</li>
<li><code>namelist</code>：指向一个结构体指针的指针，用于存储扫描结果的目录项数组。每个目录项都包含文件名等信息。</li>
<li><code>filter</code>：可选的过滤函数，用于过滤不满足特定条件的目录项。在给定的代码中，设置为 <code>NULL</code>，表示不进行过滤。</li>
<li><code>compar</code>：可选的比较函数，用于排序目录项数组。在给定的代码中，设置为 <code>alphasort</code>，表示按字母顺序排序。</li>
</ul>
</li>
<li><p>函数返回值：</p>
<ul>
<li>如果成功调用 <code>scandir()</code> 函数，则返回扫描到的目录项数量（包括隐藏文件和特殊文件）。</li>
<li>如果调用失败，则返回 -1，并设置相应的错误码。</li>
</ul>
</li>
</ol>
<p>在给定的代码中，通过 <code>int num = scandir(dirname, &amp;dirinfo, NULL, alphasort);</code>，将 <code>dirname</code> 目录中的文件列表扫描到 <code>dirinfo</code> 目录项数组中，并将扫描到的目录项数量存储在整型变量 <code>num</code> 中。这些目录项可以通过 <code>dirinfo</code> 数组进行访问和处理。</p>
<h3 id="strftime"><a href="#strftime" class="headerlink" title="strftime"></a>strftime</h3><p><code>strftime()</code> 函数用于将时间信息格式化为指定的字符串形式。</p>
<p>具体解释如下：</p>
<ol>
<li><p><code>strftime()</code> 函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cCopy Codesize_t strftime(char *s, size_t maxsize, const char *format, const struct tm *timeptr);</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数解析：</p>
<ul>
<li><code>s</code>：指向一个字符数组的指针，用于存储格式化后的时间字符串。</li>
<li><code>maxsize</code>：指定 <code>s</code> 数组的大小，用于避免溢出。</li>
<li><code>format</code>：指定输出时间字符串的格式。例如，在给定的代码中，格式化字符串为 <code>&quot;  %d  %b   %Y  %H:%M&quot;</code>，表示以两个空格开头，然后依次为日期（日），月份（缩写），年份，小时和分钟，之间用空格分隔。</li>
<li><code>timeptr</code>：指向一个 <code>struct tm</code> 结构体的指针，包含了要格式化的时间信息。在给定的代码中，使用 <code>localtime(&amp;sb.st_mtime)</code> 获取文件的最后修改时间，并将其转换为本地时间的 <code>struct tm</code> 结构体。</li>
</ul>
</li>
<li><p>函数返回值：</p>
<ul>
<li>返回生成的时间字符串的长度，不包括 null 终止符。</li>
<li>如果格式化失败或输出字符串超过了 <code>maxsize</code> 的限制，则返回 0。</li>
</ul>
</li>
</ol>
<p>在给定的代码中，通过 <code>strftime(timestr, sizeof(timestr), &quot;  %d  %b   %Y  %H:%M&quot;, localtime(&amp;sb.st_mtime));</code> 将 <code>sb.st_mtime</code> 所表示的最后修改时间格式化为 <code>&quot;  %d  %b   %Y  %H:%M&quot;</code> 的字符串形式，并将结果存储在 <code>timestr</code> 字符数组中。这样，<code>timestr</code> 就保存了文件的最后修改时间的格式化字符串。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/07/14/Linux-%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="prev" title="Linux-线程池">
      <i class="fa fa-chevron-left"></i> Linux-线程池
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/07/18/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/" rel="next" title="Linux网络编程-web大练习-B/S">
      Linux网络编程-web大练习-B/S <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#static%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E4%B8%8E%E6%84%8F%E4%B9%89"><span class="nav-number">1.</span> <span class="nav-text">static修饰的函数作用与意义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#libevent%E7%AE%80%E4%BB%8B"><span class="nav-number">2.</span> <span class="nav-text">libevent简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#libevent%E5%B0%81%E8%A3%85%E7%9A%84%E6%A1%86%E6%9E%B6%E6%80%9D%E6%83%B3"><span class="nav-number">3.</span> <span class="nav-text">libevent封装的框架思想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%B8%B8%E7%94%A8%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E4%BA%86%E8%A7%A3"><span class="nav-number">4.</span> <span class="nav-text">一些不常用相关函数了解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.</span> <span class="nav-text">创建事件对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6event%E6%93%8D%E4%BD%9C"><span class="nav-number">5.1.</span> <span class="nav-text">事件event操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8fifo%E7%9A%84%E8%AF%BB%E5%86%99"><span class="nav-number">6.</span> <span class="nav-text">使用fifo的读写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AA%E5%86%B3%E5%92%8C%E9%9D%9E%E6%9C%AA%E5%86%B3"><span class="nav-number">7.</span> <span class="nav-text">未决和非未决</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bufferevent%E7%89%B9%E6%80%A7"><span class="nav-number">8.</span> <span class="nav-text">bufferevent特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bufferevent%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E3%80%81%E9%94%80%E6%AF%81"><span class="nav-number">8.1.</span> <span class="nav-text">bufferevent事件对象创建、销毁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%99bufferevent%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E8%AE%BE%E7%BD%AE%E5%9B%9E%E8%B0%83"><span class="nav-number">8.2.</span> <span class="nav-text">给bufferevent事件对象设置回调</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E5%BC%80%E5%90%AF%E5%92%8C%E5%85%B3%E9%97%AD"><span class="nav-number">8.3.</span> <span class="nav-text">缓冲区开启和关闭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9B%91%E5%90%AC"><span class="nav-number">8.4.</span> <span class="nav-text">客户端和服务器连接和监听</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#libevent%E5%AE%9E%E7%8E%B0TCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B5%81%E7%A8%8B"><span class="nav-number">9.</span> <span class="nav-text">libevent实现TCP服务器流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B5%81%E7%A8%8B%E7%AE%80%E6%9E%90%E5%92%8C%E5%9B%9E%E9%A1%BE"><span class="nav-number">9.1.</span> <span class="nav-text">客户端流程简析和回顾</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%98%E6%9C%89%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0"><span class="nav-number">10.</span> <span class="nav-text">还有一些函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#evsignal-new"><span class="nav-number">10.1.</span> <span class="nav-text">evsignal_new</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#strcasecmp"><span class="nav-number">10.2.</span> <span class="nav-text">strcasecmp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stat"><span class="nav-number">10.3.</span> <span class="nav-text">stat</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#scandir"><span class="nav-number">10.4.</span> <span class="nav-text">scandir</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#strftime"><span class="nav-number">10.5.</span> <span class="nav-text">strftime</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">肖汇林</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">肖汇林</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
