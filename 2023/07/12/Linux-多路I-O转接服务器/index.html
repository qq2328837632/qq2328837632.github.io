<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="多路IO转接服务器设计思路   select函数参数简介1234567891011121314151617181920212223int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout);		nfds：监听的所有文件描述符中，最大文件描述符+1		readfd">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux-多路I&#x2F;O转接服务器">
<meta property="og:url" content="http://example.com/2023/07/12/Linux-%E5%A4%9A%E8%B7%AFI-O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/index.html">
<meta property="og:site_name" content="肖汇林的博客">
<meta property="og:description" content="多路IO转接服务器设计思路   select函数参数简介1234567891011121314151617181920212223int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout);		nfds：监听的所有文件描述符中，最大文件描述符+1		readfd">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/Linux-%E5%A4%9A%E8%B7%AFI-O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230711110952097.png">
<meta property="og:image" content="http://example.com/2023/07/12/Linux-%E5%A4%9A%E8%B7%AFI-O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230711110952097.png">
<meta property="og:image" content="http://example.com/Linux-%E5%A4%9A%E8%B7%AFI-O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230713145435478.png">
<meta property="og:image" content="http://example.com/2023/07/12/Linux-%E5%A4%9A%E8%B7%AFI-O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230713145435478.png">
<meta property="og:image" content="http://example.com/Linux-%E5%A4%9A%E8%B7%AFI-O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230727221452876.png">
<meta property="og:image" content="http://example.com/2023/07/12/Linux-%E5%A4%9A%E8%B7%AFI-O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230727221452876.png">
<meta property="article:published_time" content="2023-07-12T06:56:57.000Z">
<meta property="article:modified_time" content="2023-07-28T04:09:04.109Z">
<meta property="article:author" content="肖汇林">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/Linux-%E5%A4%9A%E8%B7%AFI-O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230711110952097.png">

<link rel="canonical" href="http://example.com/2023/07/12/Linux-%E5%A4%9A%E8%B7%AFI-O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Linux-多路I/O转接服务器 | 肖汇林的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖汇林的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/12/Linux-%E5%A4%9A%E8%B7%AFI-O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux-多路I/O转接服务器
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-12 14:56:57" itemprop="dateCreated datePublished" datetime="2023-07-12T14:56:57+08:00">2023-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-28 12:09:04" itemprop="dateModified" datetime="2023-07-28T12:09:04+08:00">2023-07-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="多路IO转接服务器设计思路"><a href="#多路IO转接服务器设计思路" class="headerlink" title="多路IO转接服务器设计思路"></a>多路IO转接服务器设计思路</h2><p><img src="/Linux-%E5%A4%9A%E8%B7%AFI-O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230711110952097.png" alt="image-20230711110952097"></p>
<img src="/2023/07/12/Linux-%E5%A4%9A%E8%B7%AFI-O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230711110952097.png" class title="This is an test image">

<h2 id="select函数参数简介"><a href="#select函数参数简介" class="headerlink" title="select函数参数简介"></a>select函数参数简介</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout);</span><br><span class="line"></span><br><span class="line">		nfds：监听的所有文件描述符中，最大文件描述符+1</span><br><span class="line"></span><br><span class="line">		readfds： 读 文件描述符监听集合。	传入、传出参数</span><br><span class="line"></span><br><span class="line">		writefds：写 文件描述符监听集合。	传入、传出参数		NULL</span><br><span class="line"></span><br><span class="line">		exceptfds：异常 文件描述符监听集合	传入、传出参数		NULL</span><br><span class="line"></span><br><span class="line">		timeout： 	&gt; 0: 	设置监听超时时长。</span><br><span class="line"></span><br><span class="line">				NULL:	阻塞监听</span><br><span class="line"></span><br><span class="line">				0：	非阻塞监听，轮询</span><br><span class="line">		返回值：</span><br><span class="line"></span><br><span class="line">			&gt; 0:	所有监听集合（3个）中， 满足对应事件的总数。</span><br><span class="line"></span><br><span class="line">			0：	没有满足监听条件的文件描述符</span><br><span class="line"></span><br><span class="line">			-1： 	errno</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="select相关函数参数分析"><a href="#select相关函数参数分析" class="headerlink" title="select相关函数参数分析"></a>select相关函数参数分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void FD_CLR(int fd, fd_set *set)		把某一个fd清除出去</span><br><span class="line">int FD_ISSET(int fd, fd_set *set)		判定某个fd是否在位图中</span><br><span class="line">void FD_SET(int fd, fd_set *set)		把某一个fd添加到位图</span><br><span class="line">void FD_ZERO(fd_set *set)				位图所有二进制位置零</span><br><span class="line"></span><br><span class="line">select多路IO转接：</span><br><span class="line"></span><br><span class="line">	原理：  借助内核， select 来监听， 客户端连接、数据通信事件。</span><br><span class="line"></span><br><span class="line">	void FD_ZERO(fd_set *set);	--- 清空一个文件描述符集合。</span><br><span class="line"></span><br><span class="line">		fd_set rset;</span><br><span class="line"></span><br><span class="line">		FD_ZERO(&amp;rset);</span><br><span class="line"></span><br><span class="line">	void FD_SET(int fd, fd_set *set);	--- 将待监听的文件描述符，添加到监听集合中</span><br><span class="line"></span><br><span class="line">		FD_SET(3, &amp;rset);	FD_SET(5, &amp;rset);	FD_SET(6, &amp;rset);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	void FD_CLR(int fd, fd_set *set);	--- 将一个文件描述符从监听集合中 移除。</span><br><span class="line"></span><br><span class="line">		FD_CLR（4， &amp;rset）;</span><br><span class="line"></span><br><span class="line">	int  FD_ISSET(int fd, fd_set *set);	--- 判断一个文件描述符是否在监听集合中。</span><br><span class="line"></span><br><span class="line">		返回值： 在：1；不在：0；</span><br><span class="line"></span><br><span class="line">		FD_ISSET（4， &amp;rset）;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="select实现多路IO转接设计思路"><a href="#select实现多路IO转接设计思路" class="headerlink" title="select实现多路IO转接设计思路"></a>select实现多路IO转接设计思路</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">思路分析：</span><br><span class="line"></span><br><span class="line">	int maxfd = 0；</span><br><span class="line"></span><br><span class="line">	lfd = socket() ;			创建套接字</span><br><span class="line"></span><br><span class="line">	maxfd = lfd；</span><br><span class="line"></span><br><span class="line">	bind();					绑定地址结构</span><br><span class="line"></span><br><span class="line">	listen();				设置监听上限</span><br><span class="line"></span><br><span class="line">	fd_set rset， allset;			创建r监听集合</span><br><span class="line"></span><br><span class="line">	FD_ZERO(&amp;allset);				将r监听集合清空</span><br><span class="line"></span><br><span class="line">	FD_SET(lfd, &amp;allset);			将 lfd 添加至读集合中。</span><br><span class="line"></span><br><span class="line">	while（1） &#123;</span><br><span class="line"></span><br><span class="line">		rset = allset；			保存监听集合</span><br><span class="line">	</span><br><span class="line">		ret  = select(lfd+1， &amp;rset， NULL， NULL， NULL);		监听文件描述符集合对应事件。</span><br><span class="line"></span><br><span class="line">		if（ret &gt; 0） &#123;							有监听的描述符满足对应事件</span><br><span class="line">		</span><br><span class="line">			if (FD_ISSET(lfd, &amp;rset)) &#123;				// 1 在。 0不在。</span><br><span class="line"></span><br><span class="line">				cfd = accept（）；				建立连接，返回用于通信的文件描述符</span><br><span class="line"></span><br><span class="line">				maxfd = cfd；</span><br><span class="line"></span><br><span class="line">				FD_SET(cfd, &amp;allset);				添加到监听通信描述符集合中。</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			for （i = lfd+1； i &lt;= 最大文件描述符; i++）&#123;</span><br><span class="line"></span><br><span class="line">				FD_ISSET(i, &amp;rset)				有read、write事件</span><br><span class="line"></span><br><span class="line">				read（）</span><br><span class="line"></span><br><span class="line">				小 -- 大</span><br><span class="line"></span><br><span class="line">				write();</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="select实现多路IO转接-代码review"><a href="#select实现多路IO转接-代码review" class="headerlink" title="select实现多路IO转接-代码review"></a>select实现多路IO转接-代码review</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">#include &lt;ctype.h&gt;  </span><br><span class="line"></span><br><span class="line">#include &quot;wrap.h&quot;  </span><br><span class="line"></span><br><span class="line">#define SERV_PORT 6666  </span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">    int i, j, n, nready;  </span><br><span class="line"></span><br><span class="line">    int maxfd = 0;  </span><br><span class="line"></span><br><span class="line">    int listenfd, connfd;  </span><br><span class="line"></span><br><span class="line">    char buf[BUFSIZ];         /* #define INET_ADDRSTRLEN 16 */  </span><br><span class="line"></span><br><span class="line">    struct sockaddr_in clie_addr, serv_addr;  </span><br><span class="line">    socklen_t clie_addr_len;  </span><br><span class="line"></span><br><span class="line">    listenfd = Socket(AF_INET, SOCK_STREAM, 0);    </span><br><span class="line">    int opt = 1;  </span><br><span class="line">    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, (void *)&amp;opt, sizeof(opt));  </span><br><span class="line">    </span><br><span class="line">    bzero(&amp;serv_addr, sizeof(serv_addr));  </span><br><span class="line">    serv_addr.sin_family= AF_INET;  </span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">    serv_addr.sin_port= htons(SERV_PORT);  </span><br><span class="line">    Bind(listenfd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr));  </span><br><span class="line">    Listen(listenfd, 128);  </span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">    fd_set rset, allset;                            /* rset 读事件文件描述符集合 allset用来暂存 */  </span><br><span class="line">  </span><br><span class="line">    maxfd = listenfd;  </span><br><span class="line">  </span><br><span class="line">    FD_ZERO(&amp;allset);  </span><br><span class="line">    FD_SET(listenfd, &amp;allset);                                  /* 构造select监控文件描述符集 */  </span><br><span class="line">  </span><br><span class="line">    while (1) &#123;     </span><br><span class="line">        rset = allset;                                          /* 每次循环时都从新设置select监控信号集 */  </span><br><span class="line">        nready = select(maxfd+1, &amp;rset, NULL, NULL, NULL);  </span><br><span class="line">        if (nready &lt; 0)  </span><br><span class="line">            perr_exit(&quot;select error&quot;);  </span><br><span class="line">  </span><br><span class="line">        if (FD_ISSET(listenfd, &amp;rset)) &#123;                        /* 说明有新的客户端链接请求 */  </span><br><span class="line">  </span><br><span class="line">            clie_addr_len = sizeof(clie_addr);  </span><br><span class="line">            connfd = Accept(listenfd, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);       /* Accept 不会阻塞 */  </span><br><span class="line">  </span><br><span class="line">            FD_SET(connfd, &amp;allset);                            /* 向监控文件描述符集合allset添加新的文件描述符connfd */  </span><br><span class="line">  </span><br><span class="line">            if (maxfd &lt; connfd)  </span><br><span class="line">                maxfd = connfd;  </span><br><span class="line">  </span><br><span class="line">            if (0 == --nready)                                  /* 只有listenfd有事件, 后续的 for 不需执行 */  </span><br><span class="line">                continue;  </span><br><span class="line">        &#125;   </span><br><span class="line">  </span><br><span class="line">        for (i = listenfd+1; i &lt;= maxfd; i++) &#123;                 /* 检测哪个clients 有数据就绪 */  </span><br><span class="line">  </span><br><span class="line">            if (FD_ISSET(i, &amp;rset)) &#123;  </span><br><span class="line">  </span><br><span class="line">                if ((n = Read(i, buf, sizeof(buf))) == 0) &#123;    /* 当client关闭链接时,服务器端也关闭对应链接 */  </span><br><span class="line">                    Close(i);  </span><br><span class="line">                    FD_CLR(i, &amp;allset);                        /* 解除select对此文件描述符的监控 */  </span><br><span class="line">                    &#125; else if (n &gt; 0) &#123;  </span><br><span class="line">	  </span><br><span class="line">	                    for (j = 0; j &lt; n; j++)  </span><br><span class="line">	                        buf[j] = toupper(buf[j]);  </span><br><span class="line">	                    Write(i, buf, n);  </span><br><span class="line">	                &#125;  </span><br><span class="line">	            &#125;  </span><br><span class="line">	        &#125;  </span><br><span class="line">	    &#125;  </span><br><span class="line">	  </span><br><span class="line">	    Close(listenfd);  </span><br><span class="line">	  </span><br><span class="line">	    return 0;  </span><br><span class="line">	&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用 Ctrl+Z 组合键是一种在命令行界面下停止（暂停）进程的方法，而不是正确关闭连接或套接字。</p>
<p>在大多数操作系统中，Ctrl+Z 组合键用于发送一个 SIGTSTP 信号给当前运行的进程，以暂停其执行。这通常是在后台运行的进程或任务中使用的，如在 Linux 或 UNIX 系统中运行的程序。通过按下 Ctrl+Z，您可以使进程进入后台挂起状态，并返回到命令行提示符，从而可以执行其他操作。</p>
<p>然而，Ctrl+Z 并不会主动关闭连接或套接字，它只是将进程暂停，但连接可能仍然处于活动状态。如果您希望正确关闭连接或套接字，应该在适当的时间调用相应的方法或函数来明确地关闭它们。具体取决于所使用的编程语言和网络库。</p>
<p>对于大多数命令行界面，使用 <strong>Ctrl+C</strong> 组合键是一种常用的方法来停止正在运行的进程或程序，包括网络连接和套接字。</p>
<p>按下 Ctrl+C 组合键会发送一个 SIGINT 信号给当前运行的进程，这通常会中断进程的执行并终止它。在网络编程中，当您想要停止正在进行的连接时，可以按下 Ctrl+C 组合键来关闭连接并终止与该连接相关的进程。</p>
<p>需要注意的是，按下 Ctrl+C 组合键将会立即终止进程，可能导致一些未完成的操作无法正确处理。因此，在关闭连接或套接字之前，建议在适当的时机进行必要的清理和处理操作，以确保数据的完整性和资源的正确释放。</p>
<p>总而言之，Ctrl+C 是一种常见且有效的方式来停止正在运行的进程，包括关闭网络连接和套接字。但请谨慎使用，确保在终止进程之前进行必要的清理和处理操作，以避免可能的问题。</p>
<h3 id="select优缺点"><a href="#select优缺点" class="headerlink" title="select优缺点"></a>select优缺点</h3><p>select优缺点：</p>
<p>  缺点： 监听上限受文件描述符限制。 最大 1024.</p>
<p>​    检测满足条件的fd， 自己添加业务逻辑提高小。 提高了编码难度。</p>
<p>  优点： 跨平台。win、linux、macOS、Unix、类Unix、mips</p>
<ol>
<li><p>select能监听的文件描述符个数受限于FD_SETSIZE,一般为1024，单纯改变进程打开的文件描述符个数并不能改变select监听文件个数</p>
</li>
<li><p>解决1024以下客户端时使用select是很合适的，但如果链接客户端过多，select采用的是轮询模型，会大大降低服务器响应效率，不应在select上投入更多精力</p>
</li>
</ol>
<p>select代码里有个可以优化的地方，用数组存下文件描述符，这样就不需要每次扫描一大堆无关文件描述符了</p>
<h2 id="添加一个自定义数组提高效率"><a href="#添加一个自定义数组提高效率" class="headerlink" title="添加一个自定义数组提高效率"></a>添加一个自定义数组提高效率</h2><p>这里就是改进之前代码的问题，之前的代码，如果最大fd是1023，每次确定有事件发生的fd时，就要扫描3-1023的所有文件描述符，这看起来很蠢。于是定义一个数组，把要监听的文件描述符存下来，每次扫描这个数组就行了。看起来科学得多。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">1.	#include &lt;stdio.h&gt;  </span><br><span class="line">2.	#include &lt;stdlib.h&gt;  </span><br><span class="line">3.	#include &lt;unistd.h&gt;  </span><br><span class="line">4.	#include &lt;string.h&gt;  </span><br><span class="line">5.	#include &lt;arpa/inet.h&gt;  </span><br><span class="line">6.	#include &lt;ctype.h&gt;  </span><br><span class="line">7.	  </span><br><span class="line">8.	#include &quot;wrap.h&quot;  </span><br><span class="line">9.	  </span><br><span class="line">10.	#define SERV_PORT 6666  </span><br><span class="line">11.	  </span><br><span class="line">12.	int main(int argc, char *argv[])  </span><br><span class="line">13.	&#123;  </span><br><span class="line">14.	    int i, j, n, maxi;  </span><br><span class="line">15.	  </span><br><span class="line">16.	    int nready, client[FD_SETSIZE];                 /* 自定义数组client, 防止遍历1024个文件描述符  FD_SETSIZE默认为1024 */  </span><br><span class="line">17.	    int maxfd, listenfd, connfd, sockfd;  </span><br><span class="line">18.	    char buf[BUFSIZ], str[INET_ADDRSTRLEN];         /* #define INET_ADDRSTRLEN 16 */  </span><br><span class="line">19.	  </span><br><span class="line">20.	    struct sockaddr_in clie_addr, serv_addr;  </span><br><span class="line">21.	    socklen_t clie_addr_len;  </span><br><span class="line">22.	    fd_set rset, allset;                            /* rset 读事件文件描述符集合 allset用来暂存 */  </span><br><span class="line">23.	  </span><br><span class="line">24.	    listenfd = Socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">25.	  </span><br><span class="line">26.	    int opt = 1;  </span><br><span class="line">27.	    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt));  </span><br><span class="line">28.	  </span><br><span class="line">29.	    bzero(&amp;serv_addr, sizeof(serv_addr));  </span><br><span class="line">30.	    serv_addr.sin_family= AF_INET;  </span><br><span class="line">31.	    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">32.	    serv_addr.sin_port= htons(SERV_PORT);  </span><br><span class="line">33.	  </span><br><span class="line">34.	    Bind(listenfd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr));  </span><br><span class="line">35.	    Listen(listenfd, 128);  </span><br><span class="line">36.	  </span><br><span class="line">37.	    maxfd = listenfd;                                           /* 起初 listenfd 即为最大文件描述符 */  </span><br><span class="line">38.	  </span><br><span class="line">39.	    maxi = -1;                                                  /* 将来用作client[]的下标, 初始值指向0个元素之前下标位置 */  </span><br><span class="line">40.	    for (i = 0; i &lt; FD_SETSIZE; i++)  </span><br><span class="line">41.	        client[i] = -1;                                         /* 用-1初始化client[] */  </span><br><span class="line">42.	  </span><br><span class="line">43.	    FD_ZERO(&amp;allset);  </span><br><span class="line">44.	    FD_SET(listenfd, &amp;allset);                                  /* 构造select监控文件描述符集 */  </span><br><span class="line">45.	  </span><br><span class="line">46.	    while (1) &#123;     </span><br><span class="line">47.	        rset = allset;                                          /* 每次循环时都重新设置select监控信号集 */  </span><br><span class="line">48.	  </span><br><span class="line">49.	        nready = select(maxfd+1, &amp;rset, NULL, NULL, NULL);  //2  1--lfd  1--connfd  </span><br><span class="line">50.	        if (nready &lt; 0)  </span><br><span class="line">51.	            perr_exit(&quot;select error&quot;);  </span><br><span class="line">52.	  </span><br><span class="line">53.	        if (FD_ISSET(listenfd, &amp;rset)) &#123;                        /* 说明有新的客户端链接请求 */  </span><br><span class="line">54.	  </span><br><span class="line">55.	            clie_addr_len = sizeof(clie_addr);  </span><br><span class="line">56.	            connfd = Accept(listenfd, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);       /* Accept 不会阻塞 */  </span><br><span class="line">57.	            printf(&quot;received from %s at PORT %d\n&quot;,  </span><br><span class="line">58.	                    inet_ntop(AF_INET, &amp;clie_addr.sin_addr, str, sizeof(str)),  </span><br><span class="line">59.	                    ntohs(clie_addr.sin_port));  </span><br><span class="line">60.	  </span><br><span class="line">61.	            for (i = 0; i &lt; FD_SETSIZE; i++)  </span><br><span class="line">62.	                if (client[i] &lt; 0) &#123;                            /* 找client[]中没有使用的位置 */  </span><br><span class="line">63.	                    client[i] = connfd;                         /* 保存accept返回的文件描述符到client[]里 */  </span><br><span class="line">64.	                    break;  </span><br><span class="line">65.	                &#125;  </span><br><span class="line">66.	  </span><br><span class="line">67.	            if (i == FD_SETSIZE) &#123;                              /* 达到select能监控的文件个数上限 1024 */  </span><br><span class="line">68.	                fputs(&quot;too many clients\n&quot;, stderr);  </span><br><span class="line">69.	                exit(1);  </span><br><span class="line">70.	            &#125;  </span><br><span class="line">71.	  </span><br><span class="line">72.	            FD_SET(connfd, &amp;allset);                            /* 向监控文件描述符集合allset添加新的文件描述符connfd */  </span><br><span class="line">73.	  </span><br><span class="line">74.	            if (connfd &gt; maxfd)  </span><br><span class="line">75.	                maxfd = connfd;                                 /* select第一个参数需要 */  </span><br><span class="line">76.	  </span><br><span class="line">77.	            if (i &gt; maxi)  </span><br><span class="line">78.	                maxi = i;                                       /* 保证maxi存的总是client[]最后一个元素下标 */  </span><br><span class="line">79.	  </span><br><span class="line">80.	            if (--nready == 0)  //在后面的原因，如果有请求，lfd有FD_ISSET(listenfd, &amp;rset)，再进行accept，无阻塞</span><br><span class="line">81.	                continue;  </span><br><span class="line">82.	        &#125;   </span><br><span class="line">83.	  </span><br><span class="line">84.	        for (i = 0; i &lt;= maxi; i++) &#123;                               /* 检测哪个clients 有数据就绪 */  </span><br><span class="line">85.	  </span><br><span class="line">86.	            if ((sockfd = client[i]) &lt; 0)  </span><br><span class="line">87.	                continue;  </span><br><span class="line">88.	            if (FD_ISSET(sockfd, &amp;rset)) &#123;  </span><br><span class="line">89.	  </span><br><span class="line">90.	                if ((n = Read(sockfd, buf, sizeof(buf))) == 0) &#123;    /* 当client关闭链接时,服务器端也关闭对应链接 */  </span><br><span class="line">91.	                    Close(sockfd);  </span><br><span class="line">92.	                    FD_CLR(sockfd, &amp;allset);                        /* 解除select对此文件描述符的监控 */  </span><br><span class="line">93.	                    client[i] = -1;  </span><br><span class="line">94.	                &#125; else if (n &gt; 0) &#123;  </span><br><span class="line">95.	                    for (j = 0; j &lt; n; j++)  </span><br><span class="line">96.	                        buf[j] = toupper(buf[j]);  </span><br><span class="line">97.	                    Write(sockfd, buf, n);  </span><br><span class="line">98.	                    Write(STDOUT_FILENO, buf, n);  </span><br><span class="line">99.	                &#125;  </span><br><span class="line">100.	                if (--nready == 0)  </span><br><span class="line">101.	                    break;                                          /* 跳出for, 但还在while中 */  </span><br><span class="line">102.	            &#125;  </span><br><span class="line">103.	        &#125;  </span><br><span class="line">104.	    &#125;  </span><br><span class="line">105.	    Close(listenfd);  </span><br><span class="line">106.	    return 0;  </span><br><span class="line">107.	&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="poll函数原型分析"><a href="#poll函数原型分析" class="headerlink" title="poll函数原型分析"></a>poll函数原型分析</h2><p>poll是对select的改进，但是它是个半成品，相对select提升不大。最终版本是epoll，所以poll了解一下就完事儿，重点掌握epoll。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">poll：</span><br><span class="line">	int poll(struct pollfd *fds, nfds_t nfds, int timeout);</span><br><span class="line"></span><br><span class="line">		fds：监听的文件描述符【数组】</span><br><span class="line"></span><br><span class="line">			struct pollfd &#123;</span><br><span class="line">				</span><br><span class="line">				int fd：	待监听的文件描述符</span><br><span class="line">				</span><br><span class="line">				short events：	待监听的文件描述符对应的监听事件</span><br><span class="line"></span><br><span class="line">						取值：POLLIN、POLLOUT、POLLERR</span><br><span class="line"></span><br><span class="line">				short revnets：	传入时， 给0。如果满足对应事件的话， 返回 非0 --&gt; POLLIN、POLLOUT、POLLERR</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		nfds: 监听数组的，实际有效监听个数。</span><br><span class="line"></span><br><span class="line">		timeout:  &gt; 0:  超时时长。单位：毫秒。</span><br><span class="line"></span><br><span class="line">			  -1:	阻塞等待</span><br><span class="line"></span><br><span class="line">			  0：  不阻塞</span><br><span class="line"></span><br><span class="line">		返回值：返回满足对应监听事件的文件描述符 总个数。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  优点：</p>
<p>​    自带数组结构。 可以将 监听事件集合 和 返回事件集合 分离。</p>
<p>​    拓展 监听上限。 超出 1024限制。</p>
<p>  缺点：</p>
<p>​    不能跨平台。 Linux</p>
<p>​    无法直接定位满足监听事件的文件描述符， 编码难度较大。</p>
<h3 id="poll函数实现服务器"><a href="#poll函数实现服务器" class="headerlink" title="poll函数实现服务器"></a>poll函数实现服务器</h3><p>这个东西用得少，基本都用epoll</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">1.	/* server.c */  </span><br><span class="line">2.	#include &lt;stdio.h&gt;  </span><br><span class="line">3.	#include &lt;stdlib.h&gt;  </span><br><span class="line">4.	#include &lt;string.h&gt;  </span><br><span class="line">5.	#include &lt;netinet/in.h&gt;  </span><br><span class="line">6.	#include &lt;arpa/inet.h&gt;  </span><br><span class="line">7.	#include &lt;poll.h&gt;  </span><br><span class="line">8.	#include &lt;errno.h&gt;  </span><br><span class="line">9.	#include &quot;wrap.h&quot;  </span><br><span class="line">10.	  </span><br><span class="line">11.	#define MAXLINE 80  </span><br><span class="line">12.	#define SERV_PORT 6666  </span><br><span class="line">13.	#define OPEN_MAX 1024  </span><br><span class="line">14.	  </span><br><span class="line">15.	int main(int argc, char *argv[])  </span><br><span class="line">16.	&#123;  </span><br><span class="line">17.	    int i, j, maxi, listenfd, connfd, sockfd;  </span><br><span class="line">18.	    int nready;  </span><br><span class="line">19.	    ssize_t n;  </span><br><span class="line">20.	    char buf[MAXLINE], str[INET_ADDRSTRLEN];  </span><br><span class="line">21.	    socklen_t clilen;  </span><br><span class="line">22.	    struct pollfd client[OPEN_MAX];  </span><br><span class="line">23.	    struct sockaddr_in cliaddr, servaddr;  </span><br><span class="line">24.	  </span><br><span class="line">25.	    listenfd = Socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">26.	  </span><br><span class="line">27.	    bzero(&amp;servaddr, sizeof(servaddr));  </span><br><span class="line">28.	    servaddr.sin_family = AF_INET;  </span><br><span class="line">29.	    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">30.	    servaddr.sin_port = htons(SERV_PORT);  </span><br><span class="line">31.	  </span><br><span class="line">32.	    Bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));  </span><br><span class="line">33.	  </span><br><span class="line">34.	    Listen(listenfd, 20);  </span><br><span class="line">35.	  </span><br><span class="line">36.	    client[0].fd = listenfd;  </span><br><span class="line">37.	    client[0].events = POLLRDNORM;                  /* listenfd监听普通读事件 */  </span><br><span class="line">38.	  </span><br><span class="line">39.	    for (i = 1; i &lt; OPEN_MAX; i++)  </span><br><span class="line">40.	        client[i].fd = -1;                          /* 用-1初始化client[]里剩下元素 */  </span><br><span class="line">41.	    maxi = 0;                                       /* client[]数组有效元素中最大元素下标 */  </span><br><span class="line">42.	  </span><br><span class="line">43.	    for ( ; ; ) &#123;  </span><br><span class="line">44.	        nready = poll(client, maxi+1, -1);          /* 阻塞 */  </span><br><span class="line">45.	        if (client[0].revents &amp; POLLRDNORM) &#123;       /* 有客户端链接请求 */  </span><br><span class="line">46.	            clilen = sizeof(cliaddr);  </span><br><span class="line">47.	            connfd = Accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;clilen);  </span><br><span class="line">48.	            printf(&quot;received from %s at PORT %d\n&quot;,  </span><br><span class="line">49.	                    inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, sizeof(str)),  </span><br><span class="line">50.	                    ntohs(cliaddr.sin_port));  </span><br><span class="line">51.	            for (i = 1; i &lt; OPEN_MAX; i++) &#123;  </span><br><span class="line">52.	                if (client[i].fd &lt; 0) &#123;  </span><br><span class="line">53.	                    client[i].fd = connfd;  /* 找到client[]中空闲的位置，存放accept返回的connfd */  </span><br><span class="line">54.	                    break;  </span><br><span class="line">55.	                &#125;  </span><br><span class="line">56.	            &#125;  </span><br><span class="line">57.	  </span><br><span class="line">58.	            if (i == OPEN_MAX)  </span><br><span class="line">59.	                perr_exit(&quot;too many clients&quot;);  </span><br><span class="line">60.	  </span><br><span class="line">61.	            client[i].events = POLLRDNORM;      /* 设置刚刚返回的connfd，监控读事件 */  </span><br><span class="line">62.	            if (i &gt; maxi)  </span><br><span class="line">63.	                maxi = i;                       /* 更新client[]中最大元素下标 */  </span><br><span class="line">64.	            if (--nready &lt;= 0)  </span><br><span class="line">65.	                continue;                       /* 没有更多就绪事件时,继续回到poll阻塞 */  </span><br><span class="line">66.	        &#125;  </span><br><span class="line">67.	        for (i = 1; i &lt;= maxi; i++) &#123;            /* 检测client[] */  </span><br><span class="line">68.	            if ((sockfd = client[i].fd) &lt; 0)  </span><br><span class="line">69.	                continue;  </span><br><span class="line">70.	            if (client[i].revents &amp; (POLLRDNORM | POLLERR)) &#123;  </span><br><span class="line">71.	                if ((n = Read(sockfd, buf, MAXLINE)) &lt; 0) &#123;  </span><br><span class="line">72.	                    if (errno == ECONNRESET) &#123; /* 当收到 RST标志时 */  </span><br><span class="line">73.	                        /* connection reset by client */  </span><br><span class="line">74.	                        printf(&quot;client[%d] aborted connection\n&quot;, i);  </span><br><span class="line">75.	                        Close(sockfd);  </span><br><span class="line">76.	                        client[i].fd = -1;  </span><br><span class="line">77.	                    &#125; else &#123;  </span><br><span class="line">78.	                        perr_exit(&quot;read error&quot;);  </span><br><span class="line">79.	                    &#125;  </span><br><span class="line">80.	                &#125; else if (n == 0) &#123;  </span><br><span class="line">81.	                    /* connection closed by client */  </span><br><span class="line">82.	                    printf(&quot;client[%d] closed connection\n&quot;, i);  </span><br><span class="line">83.	                    Close(sockfd);  </span><br><span class="line">84.	                    client[i].fd = -1;  </span><br><span class="line">85.	                &#125; else &#123;  </span><br><span class="line">86.	                    for (j = 0; j &lt; n; j++)  </span><br><span class="line">87.	                        buf[j] = toupper(buf[j]);  </span><br><span class="line">88.	                        Writen(sockfd, buf, n);  </span><br><span class="line">89.	                &#125;  </span><br><span class="line">90.	                if (--nready &lt;= 0)  </span><br><span class="line">91.	                    break;              /* no more readable descriptors */  </span><br><span class="line">92.	            &#125;  </span><br><span class="line">93.	        &#125;  </span><br><span class="line">94.	    &#125;  </span><br><span class="line">95.	    return 0;  </span><br><span class="line">96.	&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="epoll函数实现的多路IO转接"><a href="#epoll函数实现的多路IO转接" class="headerlink" title="epoll函数实现的多路IO转接"></a>epoll函数实现的多路IO转接</h2><h3 id="突破1024文件描述符设置"><a href="#突破1024文件描述符设置" class="headerlink" title="突破1024文件描述符设置"></a>突破1024文件描述符设置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">突破 1024 文件描述符限制：</span><br><span class="line"></span><br><span class="line">	cat /proc/sys/fs/file-max  --&gt; 当前计算机所能打开的最大文件个数。 受硬件影响。</span><br><span class="line"></span><br><span class="line">	ulimit -a 	——&gt; 当前用户下的进程，默认打开文件描述符个数。  缺省为 1024</span><br><span class="line"></span><br><span class="line">	修改：</span><br><span class="line">		打开 sudo vi /etc/security/limits.conf， 写入：</span><br><span class="line"></span><br><span class="line">		* soft nofile 65536			--&gt; 设置默认值， 可以直接借助命令修改。 【注销用户，使其生效】</span><br><span class="line"></span><br><span class="line">		* hard nofile 100000			--&gt; 命令修改上限。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cat /proc/sys/fs/file-max		查看最大文件描述符上限</span><br><span class="line">ulimit -a 	来查看open files</span><br><span class="line">sudo vi /etc/security/limits.conf  修改上限，修改之后，注销用户重新登录，查看文件描述符上限</span><br><span class="line">如果使用ulimit -n  来修改，会受到之前设置的hard的限制</span><br><span class="line">用ulimit -n设置之后，往下调可以，往上调需要注销用户再登录。</span><br></pre></td></tr></table></figure>

<h3 id="epoll-create和epoll-ctl"><a href="#epoll-create和epoll-ctl" class="headerlink" title="epoll_create和epoll_ctl"></a>epoll_create和epoll_ctl</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">epoll：</span><br><span class="line">	int epoll_create(int size);						创建一棵监听红黑树</span><br><span class="line"></span><br><span class="line">		size：创建的红黑树的监听节点数量。（仅供内核参考。）</span><br><span class="line"></span><br><span class="line">		返回值：指向新创建的红黑树的根节点的 fd。 </span><br><span class="line"></span><br><span class="line">			失败： -1 errno</span><br><span class="line"></span><br><span class="line">	int epoll_create1(int flags);</span><br><span class="line">		If  flags  is 0, then, other than the fact that the obsolete size argument is dropped, epoll_create1() is the same</span><br><span class="line">       as epoll_create().  The following value can be included in flags to obtain different behavior:</span><br><span class="line"></span><br><span class="line">       EPOLL_CLOEXEC</span><br><span class="line">              Set the close-on-exec (FD_CLOEXEC) flag on the new file descriptor.  See the description of  the  O_CLOEXEC</span><br><span class="line">              flag in open(2) for reasons why this may be useful.</span><br><span class="line">              相当于上面的多调用了一次f_cntl函数指定为O_CLOEXEC，节点数量依赖于系统的资源</span><br><span class="line">              </span><br><span class="line">	int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);	操作监听红黑树</span><br><span class="line"></span><br><span class="line">		epfd：epoll_create 函数的返回值。 epfd</span><br><span class="line"></span><br><span class="line">		op：对该监听红黑数所做的操作。</span><br><span class="line"></span><br><span class="line">			EPOLL_CTL_ADD 添加fd到 监听红黑树</span><br><span class="line"></span><br><span class="line">			EPOLL_CTL_MOD 修改fd在 监听红黑树上的监听事件。</span><br><span class="line"></span><br><span class="line">			EPOLL_CTL_DEL 将一个fd 从监听红黑树上摘下（取消监听）</span><br><span class="line"></span><br><span class="line">		fd：</span><br><span class="line">			待监听的fd</span><br><span class="line"></span><br><span class="line">		event：	本质 struct epoll_event 结构体 地址</span><br><span class="line"></span><br><span class="line">			成员 events：</span><br><span class="line">	</span><br><span class="line">				EPOLLIN / EPOLLOUT / EPOLLERR</span><br><span class="line"></span><br><span class="line">			成员 data： 联合体（共用体）：</span><br><span class="line"></span><br><span class="line">				int fd;	  对应监听事件的 fd</span><br><span class="line"></span><br><span class="line">				void *ptr； </span><br><span class="line"></span><br><span class="line">				uint32_t u32;</span><br><span class="line"></span><br><span class="line">				uint64_t u64;		</span><br><span class="line"></span><br><span class="line">		返回值：成功 0； 失败： -1 errno</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="epoll-wait函数"><a href="#epoll-wait函数" class="headerlink" title="epoll_wait函数"></a>epoll_wait函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); 	 阻塞监听。</span><br><span class="line"></span><br><span class="line">		epfd：epoll_create 函数的返回值。 epfd</span><br><span class="line"></span><br><span class="line">		events：传出参数，【数组】， 满足监听条件的 那些 fd 结构体。</span><br><span class="line"></span><br><span class="line">		maxevents：数组 元素的总个数。 1024</span><br><span class="line">				</span><br><span class="line">			struct epoll_event events[1024]</span><br><span class="line">		timeout：</span><br><span class="line"></span><br><span class="line">			-1: 阻塞</span><br><span class="line"></span><br><span class="line">			0： 不阻塞</span><br><span class="line"></span><br><span class="line">			&gt;0: 超时时间 （毫秒）</span><br><span class="line"></span><br><span class="line">		返回值：</span><br><span class="line"></span><br><span class="line">			&gt; 0: 满足监听的 总个数。 可以用作循环上限。</span><br><span class="line"></span><br><span class="line">			0： 没有fd满足监听事件</span><br><span class="line"></span><br><span class="line">			-1：失败。 errno</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &quot;wrap.h&quot;</span><br><span class="line"></span><br><span class="line">#define MAXLINE 80</span><br><span class="line">#define SERV_PORT 6666</span><br><span class="line">#define OPEN_MAX 1024</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int i, j, listenfd, connfd, sockfd;</span><br><span class="line">	int nready, efd, res;</span><br><span class="line">	ssize_t n;</span><br><span class="line">	char buf[MAXLINE], str[INET_ADDRSTRLEN];</span><br><span class="line">	socklen_t clilen;</span><br><span class="line">	</span><br><span class="line">	struct sockaddr_in cliaddr, servaddr;</span><br><span class="line">	struct epoll_event tep, ep[OPEN_MAX];//tep: epoll_ctl参数  ep[] : epoll_wait参数</span><br><span class="line"></span><br><span class="line">	listenfd = Socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">	int opt = 1;  </span><br><span class="line">	setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt));      //端口复用</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, sizeof(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">	Bind(listenfd, (struct sockaddr *) &amp;servaddr, sizeof(servaddr));</span><br><span class="line"></span><br><span class="line">	Listen(listenfd, 20);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	efd = epoll_create(OPEN_MAX);//创建epoll模型, efd指向红黑树根节点 </span><br><span class="line">	if (efd == -1)</span><br><span class="line">		perr_exit(&quot;epoll_create&quot;);</span><br><span class="line"></span><br><span class="line">	tep.events = EPOLLIN; </span><br><span class="line">	tep.data.fd = listenfd; //指定lfd的监听时间为&quot;读&quot;</span><br><span class="line"></span><br><span class="line">	res = epoll_ctl(efd, EPOLL_CTL_ADD, listenfd, &amp;tep);//将lfd及对应的结构体设置到树上,efd可找到该树  </span><br><span class="line">	if (res == -1)</span><br><span class="line">		perr_exit(&quot;epoll_ctl&quot;);</span><br><span class="line"></span><br><span class="line">	while (1) &#123;/*epoll为server阻塞监听事件, ep为struct epoll_event类型数组, OPEN_MAX为数组容量, -1表永久阻塞*/  </span><br><span class="line">		nready = epoll_wait(efd, ep, OPEN_MAX, -1);			 /* 阻塞监听 */</span><br><span class="line">		if (nready == -1)</span><br><span class="line">			perr_exit(&quot;epoll_wait&quot;);</span><br><span class="line"></span><br><span class="line">		for (i = 0; i &lt; nready; i++) &#123;</span><br><span class="line">			if (!(ep[i].events &amp; EPOLLIN))//如果不是&quot;读&quot;事件, 继续循环 </span><br><span class="line">				continue;</span><br><span class="line">			if (ep[i].data.fd == listenfd) &#123;//判断满足事件的fd是不是lfd    </span><br><span class="line">				clilen = sizeof(cliaddr);</span><br><span class="line">				connfd = Accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;clilen);//接受链接 </span><br><span class="line">				printf(&quot;received from %s at PORT %d\n&quot;, </span><br><span class="line">						inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, sizeof(str)), </span><br><span class="line">						ntohs(cliaddr.sin_port));</span><br><span class="line">				</span><br><span class="line">				</span><br><span class="line"></span><br><span class="line">				tep.events = EPOLLIN; </span><br><span class="line">				tep.data.fd = connfd;</span><br><span class="line">				res = epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &amp;tep);//加入红黑树</span><br><span class="line">				if (res == -1)</span><br><span class="line">					perr_exit(&quot;epoll_ctl&quot;);</span><br><span class="line">			&#125; else &#123;  															//不是lfd</span><br><span class="line">				sockfd = ep[i].data.fd;</span><br><span class="line">				n = Read(sockfd, buf, MAXLINE);</span><br><span class="line">				if (n == 0) &#123;										//读到0,说明客户端关闭链接</span><br><span class="line">					</span><br><span class="line">					res = epoll_ctl(efd, EPOLL_CTL_DEL, sockfd, NULL);  //将该文件描述符从红黑树摘</span><br><span class="line">					if (res == -1)</span><br><span class="line">						perr_exit(&quot;epoll_ctl&quot;);</span><br><span class="line"></span><br><span class="line">					Close(sockfd);									 //关闭与该客户端的链接 </span><br><span class="line">					printf(&quot;client[%d] closed connection\n&quot;, j);</span><br><span class="line">				&#125; else &#123;	//实际读到了字节数</span><br><span class="line">					for (j = 0; j &lt; n; j++)	</span><br><span class="line">						buf[j] = toupper(buf[j]);</span><br><span class="line">					Writen(sockfd, buf, n);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	close(listenfd);</span><br><span class="line">	close(efd);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="read函数返回值"><a href="#read函数返回值" class="headerlink" title="read函数返回值:"></a>read函数返回值:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; 0:实际读到的字节数</span><br><span class="line">=0:</span><br><span class="line">	socket中，表示对端关闭。close ()</span><br><span class="line">-1:</span><br><span class="line">    如果errno == EINTR被异常终端。 需要重启。</span><br><span class="line">    如果errno = EAGIN或EYOULDBLOCK以非阻塞方式读数据，但是没有数据。需要， 再次读。</span><br><span class="line">    如果errno == ECONNRESET说明连接被 重置。需要close ()，移除监听队列。</span><br><span class="line">    错误。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">while( (len = read(fd, buf, sizeof(buf))) &gt; 0 ) &#123;   </span><br><span class="line">        // 发送读出的数据</span><br><span class="line">        ret = send(cfd, buf, len, 0);</span><br><span class="line">        if (ret == -1) &#123;</span><br><span class="line">            if (errno == EAGAIN) &#123;</span><br><span class="line">                perror(&quot;send error:&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125; else if (errno == EINTR) &#123;</span><br><span class="line">                perror(&quot;send error:&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                perror(&quot;send error:&quot;);</span><br><span class="line">                exit(1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="ET和LT模式"><a href="#ET和LT模式" class="headerlink" title="ET和LT模式"></a>ET和LT模式</h2><p>epoll是Linux下多路复用IO接口select&#x2F;poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率，因为它会复用文件描述符集合来传递结果而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合，另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。</p>
<p><img src="/Linux-%E5%A4%9A%E8%B7%AFI-O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230713145435478.png" alt="image-20230713145435478"></p>
<img src="/2023/07/12/Linux-%E5%A4%9A%E8%B7%AFI-O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230713145435478.png" class title="This is an test image">

<p>EPOLL事件有两种模型：</p>
<p>​	Edge Triggered (ET) 边缘触发只有数据到来才触发，不管缓存区中是否还有数据。</p>
<p>​	Level Triggered (LT) 水平触发只要有数据都会触发。</p>
<p>用一个子进程来写内容，用ET和LT模式来读取，结果很能说明问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;sys/epoll.h&gt;  </span><br><span class="line">#include &lt;errno.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">  </span><br><span class="line">#define MAXLINE 10  </span><br><span class="line">  </span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">    int efd, i;  </span><br><span class="line">    int pfd[2];  </span><br><span class="line">    pid_t pid;  </span><br><span class="line">    char buf[MAXLINE], ch = &#x27;a&#x27;;  </span><br><span class="line">  </span><br><span class="line">    pipe(pfd);  //管道</span><br><span class="line">    pid = fork();  </span><br><span class="line">  </span><br><span class="line">    if (pid == 0) &#123;             //子 写  </span><br><span class="line">        close(pfd[0]);  </span><br><span class="line">        while (1) &#123;  </span><br><span class="line">            //aaaa\n  </span><br><span class="line">            for (i = 0; i &lt; MAXLINE/2; i++)  </span><br><span class="line">                buf[i] = ch;  </span><br><span class="line">            buf[i-1] = &#x27;\n&#x27;;  </span><br><span class="line">            ch++;  </span><br><span class="line">            //bbbb\n  </span><br><span class="line">            for (; i &lt; MAXLINE; i++)  </span><br><span class="line">                buf[i] = ch;  </span><br><span class="line">            buf[i-1] = &#x27;\n&#x27;;  </span><br><span class="line">            ch++;  </span><br><span class="line">            //aaaa\nbbbb\n  </span><br><span class="line">            write(pfd[1], buf, sizeof(buf));  </span><br><span class="line">            sleep(5);  </span><br><span class="line">        &#125;  </span><br><span class="line">        close(pfd[1]);  </span><br><span class="line">  </span><br><span class="line">    &#125; else if (pid &gt; 0) &#123;       //父 读  </span><br><span class="line">        struct epoll_event event;  </span><br><span class="line">        struct epoll_event resevent[10];        //epoll_wait就绪返回event  </span><br><span class="line">        int res, len;  </span><br><span class="line">  </span><br><span class="line">        close(pfd[1]);  </span><br><span class="line">        efd = epoll_create(10);  </span><br><span class="line">  </span><br><span class="line">        event.events = EPOLLIN | EPOLLET;     // ET 边沿触发  </span><br><span class="line">       // event.events = EPOLLIN;                 // LT 水平触发 (默认)  </span><br><span class="line">        event.data.fd = pfd[0];  </span><br><span class="line">        epoll_ctl(efd, EPOLL_CTL_ADD, pfd[0], &amp;event);  </span><br><span class="line">  </span><br><span class="line">        while (1) &#123;  </span><br><span class="line">            res = epoll_wait(efd, resevent, 10, -1);  </span><br><span class="line">            printf(&quot;res %d\n&quot;, res);  </span><br><span class="line">            if (resevent[0].data.fd == pfd[0]) &#123;  </span><br><span class="line">                len = read(pfd[0], buf, MAXLINE/2);  </span><br><span class="line">                write(STDOUT_FILENO, buf, len);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        close(pfd[0]);  </span><br><span class="line">        close(efd);  </span><br><span class="line">  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        perror(&quot;fork&quot;);  </span><br><span class="line">        exit(-1);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>简单理解就是，水平触发就是有数据就触发，边沿触发是有新数据进来才触发。</p>
<h2 id="网络中ET和LT模式"><a href="#网络中ET和LT模式" class="headerlink" title="网络中ET和LT模式"></a>网络中ET和LT模式</h2><p>server代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;netinet/in.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">#include &lt;signal.h&gt;  </span><br><span class="line">#include &lt;sys/wait.h&gt;  </span><br><span class="line">#include &lt;sys/types.h&gt;  </span><br><span class="line">#include &lt;sys/epoll.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">  </span><br><span class="line">#define MAXLINE 10  </span><br><span class="line">#define SERV_PORT 9000  </span><br><span class="line">  </span><br><span class="line">int main(void)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct sockaddr_in servaddr, cliaddr;  </span><br><span class="line">    socklen_t cliaddr_len;  </span><br><span class="line">    int listenfd, connfd;  </span><br><span class="line">    char buf[MAXLINE];  </span><br><span class="line">    char str[INET_ADDRSTRLEN];  </span><br><span class="line">    int efd;  </span><br><span class="line">  </span><br><span class="line">    listenfd = socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">  </span><br><span class="line">    bzero(&amp;servaddr, sizeof(servaddr));  </span><br><span class="line">    servaddr.sin_family = AF_INET;  </span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);  </span><br><span class="line">  </span><br><span class="line">    bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));  </span><br><span class="line">  </span><br><span class="line">    listen(listenfd, 20);  </span><br><span class="line">  </span><br><span class="line">    struct epoll_event event;  </span><br><span class="line">    struct epoll_event resevent[10];  </span><br><span class="line">    int res, len;  </span><br><span class="line">  </span><br><span class="line">    efd = epoll_create(10);  </span><br><span class="line">    event.events = EPOLLIN | EPOLLET;     /* ET 边沿触发 */  </span><br><span class="line">    //event.events = EPOLLIN;                 /* 默认 LT 水平触发 */  </span><br><span class="line">  </span><br><span class="line">    printf(&quot;Accepting connections ...\n&quot;);  </span><br><span class="line">  </span><br><span class="line">    cliaddr_len = sizeof(cliaddr);  </span><br><span class="line">    connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);  </span><br><span class="line">    printf(&quot;received from %s at PORT %d\n&quot;,  </span><br><span class="line">            inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, sizeof(str)),  </span><br><span class="line">            ntohs(cliaddr.sin_port));  </span><br><span class="line">  </span><br><span class="line">    event.data.fd = connfd;  </span><br><span class="line">    epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &amp;event);  </span><br><span class="line">  </span><br><span class="line">    while (1) &#123;  </span><br><span class="line">        res = epoll_wait(efd, resevent, 10, -1);  </span><br><span class="line">  </span><br><span class="line">        printf(&quot;res %d\n&quot;, res);  </span><br><span class="line">        if (resevent[0].data.fd == connfd) &#123;  </span><br><span class="line">            len = read(connfd, buf, MAXLINE/2);         //readn(500)     </span><br><span class="line">            write(STDOUT_FILENO, buf, len);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>client代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">#include &lt;netinet/in.h&gt;  </span><br><span class="line">  </span><br><span class="line">#define MAXLINE 10  </span><br><span class="line">#define SERV_PORT 9000  </span><br><span class="line">  </span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">    struct sockaddr_in servaddr;  </span><br><span class="line">    char buf[MAXLINE];  </span><br><span class="line">    int sockfd, i;  </span><br><span class="line">    char ch = &#x27;a&#x27;;  </span><br><span class="line">  </span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">  </span><br><span class="line">    bzero(&amp;servaddr, sizeof(servaddr));  </span><br><span class="line">    servaddr.sin_family = AF_INET;  </span><br><span class="line">    inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;servaddr.sin_addr);  </span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);  </span><br><span class="line">  </span><br><span class="line">    connect(sockfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));  </span><br><span class="line">  </span><br><span class="line">    while (1) &#123;  </span><br><span class="line">        //aaaa\n  </span><br><span class="line">        for (i = 0; i &lt; MAXLINE/2; i++)  </span><br><span class="line">            buf[i] = ch;  </span><br><span class="line">        buf[i-1] = &#x27;\n&#x27;;  </span><br><span class="line">        ch++;  </span><br><span class="line">        //bbbb\n  </span><br><span class="line">        for (; i &lt; MAXLINE; i++)  </span><br><span class="line">            buf[i] = ch;  </span><br><span class="line">        buf[i-1] = &#x27;\n&#x27;;  </span><br><span class="line">        ch++;  </span><br><span class="line">        //aaaa\nbbbb\n  </span><br><span class="line">        write(sockfd, buf, sizeof(buf));  </span><br><span class="line">        sleep(5);  </span><br><span class="line">    &#125;  </span><br><span class="line">    close(sockfd);  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行后，每过5秒钟服务器才输出一组字符，这是就是边沿触发的效果</p>
<p>更改服务器为水平触发模式，运行程序，运行后，每5秒输出两组字符串，这是因为只写入了两组，这个模式的服务器，缓冲区有多少读多少。</p>
<h3 id="epoll的ET非阻塞模式"><a href="#epoll的ET非阻塞模式" class="headerlink" title="epoll的ET非阻塞模式"></a>epoll的ET非阻塞模式</h3><p>readn调用的阻塞，比如设定读500个字符，但是只读到498，完事儿阻塞了，等另剩下的2个字符，然而在server代码里，一旦read变为readn阻塞了，它就不会被唤醒了，因为epoll_wait因为readn的阻塞不会循环执行，读不到新数据。有点死锁的意思，差俩字符所以阻塞，因为阻塞，读不到新字符。</p>
<p>LT(level triggered)：LT是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的select&#x2F;poll都是这种模型的代表。</p>
<p>ET(edge-triggered)：ET是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知。请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once).</p>
<p>用fcntl设置阻塞</p>
<p>非阻塞epoll的服务器代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;netinet/in.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">#include &lt;sys/wait.h&gt;  </span><br><span class="line">#include &lt;sys/types.h&gt;  </span><br><span class="line">#include &lt;sys/epoll.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;fcntl.h&gt;  </span><br><span class="line">  </span><br><span class="line">#define MAXLINE 10  </span><br><span class="line">#define SERV_PORT 8000  </span><br><span class="line">  </span><br><span class="line">int main(void)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct sockaddr_in servaddr, cliaddr;  </span><br><span class="line">    socklen_t cliaddr_len;  </span><br><span class="line">    int listenfd, connfd;  </span><br><span class="line">    char buf[MAXLINE];  </span><br><span class="line">    char str[INET_ADDRSTRLEN];  </span><br><span class="line">    int efd, flag;  </span><br><span class="line">  </span><br><span class="line">    listenfd = socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">  </span><br><span class="line">    bzero(&amp;servaddr, sizeof(servaddr));  </span><br><span class="line">    servaddr.sin_family = AF_INET;  </span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);  </span><br><span class="line">  </span><br><span class="line">    bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));  </span><br><span class="line">  </span><br><span class="line">    listen(listenfd, 20);  </span><br><span class="line">  </span><br><span class="line">    ///////////////////////////////////////////////////////////////////////  </span><br><span class="line">    struct epoll_event event;  </span><br><span class="line">    struct epoll_event res_event[10];  </span><br><span class="line">    int res, len;  </span><br><span class="line">  </span><br><span class="line">    efd = epoll_create(10);  </span><br><span class="line">  </span><br><span class="line">    event.events = EPOLLIN | EPOLLET;     /* ET 边沿触发，默认是水平触发 */  </span><br><span class="line">  </span><br><span class="line">    //event.events = EPOLLIN;  </span><br><span class="line">    printf(&quot;Accepting connections ...\n&quot;);  </span><br><span class="line">    cliaddr_len = sizeof(cliaddr);  </span><br><span class="line">    connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);  </span><br><span class="line">    printf(&quot;received from %s at PORT %d\n&quot;,  </span><br><span class="line">            inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, sizeof(str)),  </span><br><span class="line">            ntohs(cliaddr.sin_port));  </span><br><span class="line">  </span><br><span class="line">    flag = fcntl(connfd, F_GETFL);          /* 修改connfd为非阻塞读 */  </span><br><span class="line">    flag |= O_NONBLOCK;  </span><br><span class="line">    fcntl(connfd, F_SETFL, flag);  </span><br><span class="line">  </span><br><span class="line">    event.data.fd = connfd;  </span><br><span class="line">    epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &amp;event);      //将connfd加入监听红黑树  </span><br><span class="line">    while (1) &#123;  </span><br><span class="line">        printf(&quot;epoll_wait begin\n&quot;);  </span><br><span class="line">        res = epoll_wait(efd, res_event, 10, -1);        //最多10个, 阻塞监听  </span><br><span class="line">        printf(&quot;epoll_wait end res %d\n&quot;, res);  </span><br><span class="line">  </span><br><span class="line">        if (res_event[0].data.fd == connfd) &#123;  </span><br><span class="line">            while ((len = read(connfd, buf, MAXLINE/2)) &gt;0 )    //非阻塞读, 轮询  </span><br><span class="line">                write(STDOUT_FILENO, buf, len);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其实就是多了这几行：</p>
<pre><code>flag = fcntl(connfd, F_GETFL);          /* 修改connfd为非阻塞读 */  
flag |= O_NONBLOCK;  
fcntl(connfd, F_SETFL, flag);  
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">结论：</span><br><span class="line">		epoll 的 ET模式， 高效模式，但是只支持 非阻塞模式。 --- 忙轮询。</span><br><span class="line"></span><br><span class="line">		struct epoll_event event;</span><br><span class="line"></span><br><span class="line">		event.events = EPOLLIN | EPOLLET;</span><br><span class="line">		event.data.fd = connfd;</span><br><span class="line"></span><br><span class="line">		epoll_ctl(epfd, EPOLL_CTL_ADD, connfd， &amp;event);	</span><br><span class="line"></span><br><span class="line">		int flg = fcntl(cfd, F_GETFL);	</span><br><span class="line"></span><br><span class="line">		flg |= O_NONBLOCK;</span><br><span class="line"></span><br><span class="line">		fcntl(cfd, F_SETFL, flg);</span><br><span class="line"></span><br><span class="line">	优点：</span><br><span class="line"></span><br><span class="line">		高效。突破1024文件描述符。</span><br><span class="line"></span><br><span class="line">	缺点：</span><br><span class="line">		不能跨平台。 Linux。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">后面使用epoll就用这种非阻塞的</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="epoll反应堆模型总述"><a href="#epoll反应堆模型总述" class="headerlink" title="epoll反应堆模型总述"></a>epoll反应堆模型总述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">epoll 反应堆模型：</span><br><span class="line"></span><br><span class="line">	epoll ET模式 + 非阻塞、轮询 + void *ptr。</span><br><span class="line"></span><br><span class="line">	原来：	socket、bind、listen -- epoll_create 创建监听 红黑树 --  返回 epfd -- epoll_ctl() 向树上添加一个监听fd -- while（1）--</span><br><span class="line"></span><br><span class="line">		-- epoll_wait 监听 -- 对应监听fd有事件产生 -- 返回 监听满足数组。 -- 判断返回数组元素 -- lfd满足 -- Accept -- cfd 满足 </span><br><span class="line"></span><br><span class="line">		-- read() --- 小-&gt;大 -- write回去。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">反应堆：不但要监听 cfd 的读事件、还要监听cfd的写事件。</span><br><span class="line"></span><br><span class="line">		socket、bind、listen -- epoll_create 创建监听 红黑树 --  返回 epfd -- epoll_ctl() 向树上添加一个监听fd -- while（1）--</span><br><span class="line"></span><br><span class="line">		-- epoll_wait 监听 -- 对应监听fd有事件产生 -- 返回 监听满足数组。 -- 判断返回数组元素 -- lfd满足 -- Accept -- cfd 满足 </span><br><span class="line"></span><br><span class="line">		-- read() --- 小-&gt;大 -- cfd从监听红黑树上摘下 -- EPOLLOUT -- 回调函数 -- epoll_ctl() -- EPOLL_CTL_ADD 重新放到红黑上监听写事件</span><br><span class="line"></span><br><span class="line">		-- 等待 epoll_wait 返回 -- 说明 cfd 可写 -- write回去 -- cfd从监听红黑树上摘下 -- EPOLLIN </span><br><span class="line"></span><br><span class="line">		-- epoll_ctl() -- EPOLL_CTL_ADD 重新放到红黑上监听读事件 -- epoll_wait 监听</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">反应堆的理解：加入IO转接之后，有了事件，server才去处理，这里反应堆也是这样，由于网络环境复杂，服务器处理数据之后，可能并不能直接写回去，比如遇到网络繁忙或者对方缓冲区已经满了这种情况，就不能直接写回给客户端。反应堆就是在处理数据之后，监听写事件，能写会客户端了，才去做写回操作。写回之后，再改为监听读事件。如此循环。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="epoll反应堆main逻辑"><a href="#epoll反应堆main逻辑" class="headerlink" title="epoll反应堆main逻辑"></a>epoll反应堆main逻辑</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> *epoll基于非阻塞I/O事件驱动 </span><br><span class="line"> */  </span><br><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;sys/socket.h&gt;  </span><br><span class="line">#include &lt;sys/epoll.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">#include &lt;fcntl.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;errno.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;time.h&gt;  </span><br><span class="line">  </span><br><span class="line">#define MAX_EVENTS  1024                                    //监听上限数  </span><br><span class="line">#define BUFLEN 4096  </span><br><span class="line">#define SERV_PORT   8080  </span><br><span class="line">  </span><br><span class="line">void recvdata(int fd, int events, void *arg);  </span><br><span class="line">void senddata(int fd, int events, void *arg);  </span><br><span class="line">  </span><br><span class="line">/* 描述就绪文件描述符相关信息 */  </span><br><span class="line">  </span><br><span class="line">struct myevent_s &#123;  </span><br><span class="line">    int fd;                                                 //要监听的文件描述符  </span><br><span class="line">    int events;                                             //对应的监听事件  </span><br><span class="line">    void *arg;                                              //泛型参数  </span><br><span class="line">    void (*call_back)(int fd, int events, void *arg);       //回调函数  </span><br><span class="line">    int status;                                             //是否在监听:1-&gt;在红黑树上(监听), 0-&gt;不在(不监听)  </span><br><span class="line">    char buf[BUFLEN];  </span><br><span class="line">    int len;  </span><br><span class="line">    long last_active;                                       //记录每次加入红黑树 g_efd 的时间值  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">int g_efd;                                                  //全局变量, 保存epoll_create返回的文件描述符  </span><br><span class="line">struct myevent_s g_events[MAX_EVENTS+1];                    //自定义结构体类型数组. +1--&gt;listen fd  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">/*将结构体 myevent_s 成员变量 初始化*/  </span><br><span class="line">  </span><br><span class="line">void eventset(struct myevent_s *ev, int fd, void (*call_back)(int, int, void *), void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    ev-&gt;fd = fd;  </span><br><span class="line">    ev-&gt;call_back = call_back;  </span><br><span class="line">    ev-&gt;events = 0;  </span><br><span class="line">    ev-&gt;arg = arg;  </span><br><span class="line">    ev-&gt;status = 0;  </span><br><span class="line">    memset(ev-&gt;buf, 0, sizeof(ev-&gt;buf));  </span><br><span class="line">    ev-&gt;len = 0;  </span><br><span class="line">    ev-&gt;last_active = time(NULL);                       //调用eventset函数的时间  </span><br><span class="line">  </span><br><span class="line">    return;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">/* 向 epoll监听的红黑树 添加一个 文件描述符 */  </span><br><span class="line">  </span><br><span class="line">//eventadd(efd, EPOLLIN, &amp;g_events[MAX_EVENTS]);  </span><br><span class="line">void eventadd(int efd, int events, struct myevent_s *ev)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct epoll_event epv = &#123;0, &#123;0&#125;&#125;;  </span><br><span class="line">    int op;  </span><br><span class="line">    epv.data.ptr = ev;  </span><br><span class="line">    epv.events = ev-&gt;events = events;       //EPOLLIN 或 EPOLLOUT  </span><br><span class="line">  </span><br><span class="line">    if (ev-&gt;status == 0) &#123;                                          //已经在红黑树 g_efd 里  </span><br><span class="line">        op = EPOLL_CTL_ADD;                 //将其加入红黑树 g_efd, 并将status置1  </span><br><span class="line">        ev-&gt;status = 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    if (epoll_ctl(efd, op, ev-&gt;fd, &amp;epv) &lt; 0)                       //实际添加/修改  </span><br><span class="line">        printf(&quot;event add failed [fd=%d], events[%d]\n&quot;, ev-&gt;fd, events);  </span><br><span class="line">    else  </span><br><span class="line">        printf(&quot;event add OK [fd=%d], op=%d, events[%0X]\n&quot;, ev-&gt;fd, op, events);  </span><br><span class="line">  </span><br><span class="line">    return ;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">/* 从epoll 监听的 红黑树中删除一个 文件描述符*/  </span><br><span class="line">  </span><br><span class="line">void eventdel(int efd, struct myevent_s *ev)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct epoll_event epv = &#123;0, &#123;0&#125;&#125;;  </span><br><span class="line">  </span><br><span class="line">    if (ev-&gt;status != 1)                                        //不在红黑树上  </span><br><span class="line">        return ;  </span><br><span class="line">  </span><br><span class="line">    //epv.data.ptr = ev;  </span><br><span class="line">    epv.data.ptr = NULL;  </span><br><span class="line">    ev-&gt;status = 0;                                             //修改状态  </span><br><span class="line">    epoll_ctl(efd, EPOLL_CTL_DEL, ev-&gt;fd, &amp;epv);                //从红黑树 efd 上将 ev-&gt;fd 摘除  </span><br><span class="line">  </span><br><span class="line">    return ;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">/*  当有文件描述符就绪, epoll返回, 调用该函数 与客户端建立链接 */  </span><br><span class="line">  </span><br><span class="line">void acceptconn(int lfd, int events, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct sockaddr_in cin;  </span><br><span class="line">    socklen_t len = sizeof(cin);  </span><br><span class="line">    int cfd, i;  </span><br><span class="line">  </span><br><span class="line">    if ((cfd = accept(lfd, (struct sockaddr *)&amp;cin, &amp;len)) == -1) &#123;  </span><br><span class="line">        if (errno != EAGAIN &amp;&amp; errno != EINTR) &#123;  </span><br><span class="line">            /* 暂时不做出错处理 */  </span><br><span class="line">        &#125;  </span><br><span class="line">        printf(&quot;%s: accept, %s\n&quot;, __func__, strerror(errno));  </span><br><span class="line">        return ;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    do &#123;  </span><br><span class="line">        for (i = 0; i &lt; MAX_EVENTS; i++)                                //从全局数组g_events中找一个空闲元素  </span><br><span class="line">            if (g_events[i].status == 0)                                //类似于select中找值为-1的元素  </span><br><span class="line">                break;                                                  //跳出 for  </span><br><span class="line">  </span><br><span class="line">        if (i == MAX_EVENTS) &#123;  </span><br><span class="line">            printf(&quot;%s: max connect limit[%d]\n&quot;, __func__, MAX_EVENTS);  </span><br><span class="line">            break;                                                      //跳出do while(0) 不执行后续代码  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        int flag = 0;  </span><br><span class="line">        if ((flag = fcntl(cfd, F_SETFL, O_NONBLOCK)) &lt; 0) &#123;             //将cfd也设置为非阻塞  </span><br><span class="line">            printf(&quot;%s: fcntl nonblocking failed, %s\n&quot;, __func__, strerror(errno));  </span><br><span class="line">            break;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        /* 给cfd设置一个 myevent_s 结构体, 回调函数 设置为 recvdata */  </span><br><span class="line">        eventset(&amp;g_events[i], cfd, recvdata, &amp;g_events[i]);     </span><br><span class="line">        eventadd(g_efd, EPOLLIN, &amp;g_events[i]);                         //将cfd添加到红黑树g_efd中,监听读事件  </span><br><span class="line">  </span><br><span class="line">    &#125; while(0);  </span><br><span class="line">  </span><br><span class="line">    printf(&quot;new connect [%s:%d][time:%ld], pos[%d]\n&quot;,   </span><br><span class="line">            inet_ntoa(cin.sin_addr), ntohs(cin.sin_port), g_events[i].last_active, i);  </span><br><span class="line">    return ;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void recvdata(int fd, int events, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct myevent_s *ev = (struct myevent_s *)arg;  </span><br><span class="line">    int len;  </span><br><span class="line">  </span><br><span class="line">    len = recv(fd, ev-&gt;buf, sizeof(ev-&gt;buf), 0);            //读文件描述符, 数据存入myevent_s成员buf中  </span><br><span class="line">  </span><br><span class="line">    eventdel(g_efd, ev);        //将该节点从红黑树上摘除  </span><br><span class="line">  </span><br><span class="line">    if (len &gt; 0) &#123;  </span><br><span class="line">  </span><br><span class="line">        ev-&gt;len = len;  </span><br><span class="line">        ev-&gt;buf[len] = &#x27;\0&#x27;;                                //手动添加字符串结束标记  </span><br><span class="line">        printf(&quot;C[%d]:%s\n&quot;, fd, ev-&gt;buf);  </span><br><span class="line">  </span><br><span class="line">        eventset(ev, fd, senddata, ev);                     //设置该 fd 对应的回调函数为 senddata  </span><br><span class="line">        eventadd(g_efd, EPOLLOUT, ev);                      //将fd加入红黑树g_efd中,监听其写事件  </span><br><span class="line">  </span><br><span class="line">    &#125; else if (len == 0) &#123;  </span><br><span class="line">        close(ev-&gt;fd);  </span><br><span class="line">        /* ev-g_events 地址相减得到偏移元素位置 */  </span><br><span class="line">        printf(&quot;[fd=%d] pos[%ld], closed\n&quot;, fd, ev-g_events);  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        close(ev-&gt;fd);  </span><br><span class="line">        printf(&quot;recv[fd=%d] error[%d]:%s\n&quot;, fd, errno, strerror(errno));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void senddata(int fd, int events, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct myevent_s *ev = (struct myevent_s *)arg;  </span><br><span class="line">    int len;  </span><br><span class="line">  </span><br><span class="line">    len = send(fd, ev-&gt;buf, ev-&gt;len, 0);                    //直接将数据 回写给客户端。未作处理  </span><br><span class="line">  </span><br><span class="line">    eventdel(g_efd, ev);                                //从红黑树g_efd中移除  </span><br><span class="line">  </span><br><span class="line">    if (len &gt; 0) &#123;  </span><br><span class="line">  </span><br><span class="line">        printf(&quot;send[fd=%d], [%d]%s\n&quot;, fd, len, ev-&gt;buf);  </span><br><span class="line">        eventset(ev, fd, recvdata, ev);                     //将该fd的 回调函数改为 recvdata  </span><br><span class="line">        eventadd(g_efd, EPOLLIN, ev);                       //从新添加到红黑树上， 设为监听读事件  </span><br><span class="line">  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        close(ev-&gt;fd);                                      //关闭链接  </span><br><span class="line">        printf(&quot;send[fd=%d] error %s\n&quot;, fd, strerror(errno));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return ;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">/*创建 socket, 初始化lfd */  </span><br><span class="line">  </span><br><span class="line">void initlistensocket(int efd, short port)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct sockaddr_in sin;  </span><br><span class="line">  </span><br><span class="line">    int lfd = socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">    fcntl(lfd, F_SETFL, O_NONBLOCK);                                            //将socket设为非阻塞  </span><br><span class="line">  </span><br><span class="line">    memset(&amp;sin, 0, sizeof(sin));                                               //bzero(&amp;sin, sizeof(sin))  </span><br><span class="line">    sin.sin_family = AF_INET;  </span><br><span class="line">    sin.sin_addr.s_addr = INADDR_ANY;  </span><br><span class="line">    sin.sin_port = htons(port);  </span><br><span class="line">  </span><br><span class="line">    bind(lfd, (struct sockaddr *)&amp;sin, sizeof(sin));  </span><br><span class="line">  </span><br><span class="line">    listen(lfd, 20);  </span><br><span class="line">  </span><br><span class="line">    /* void eventset(struct myevent_s *ev, int fd, void (*call_back)(int, int, void *), void *arg);  */  </span><br><span class="line">    eventset(&amp;g_events[MAX_EVENTS], lfd, acceptconn, &amp;g_events[MAX_EVENTS]);  </span><br><span class="line">  </span><br><span class="line">    /* void eventadd(int efd, int events, struct myevent_s *ev) */  </span><br><span class="line">    eventadd(efd, EPOLLIN, &amp;g_events[MAX_EVENTS]);  </span><br><span class="line">  </span><br><span class="line">    return ;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned short port = SERV_PORT;  </span><br><span class="line">  </span><br><span class="line">    if (argc == 2)  </span><br><span class="line">        port = atoi(argv[1]);                           //使用用户指定端口.如未指定,用默认端口,把参数 str 所指向的字符串转换为一个整数（类型为 int 型）  </span><br><span class="line">  </span><br><span class="line">    g_efd = epoll_create(MAX_EVENTS+1);                 //创建红黑树,返回给全局 g_efd   </span><br><span class="line">    if (g_efd &lt;= 0)  </span><br><span class="line">        printf(&quot;create efd in %s err %s\n&quot;, __func__, strerror(errno));  </span><br><span class="line">  </span><br><span class="line">    initlistensocket(g_efd, port);                      //初始化监听socket  </span><br><span class="line">  </span><br><span class="line">    struct epoll_event events[MAX_EVENTS+1];            //保存已经满足就绪事件的文件描述符数组   </span><br><span class="line">    printf(&quot;server running:port[%d]\n&quot;, port);  </span><br><span class="line">  </span><br><span class="line">    int checkpos = 0, i;  </span><br><span class="line">    while (1) &#123;  </span><br><span class="line">        /* 超时验证，每次测试100个链接，不测试listenfd 当客户端60秒内没有和服务器通信，则关闭此客户端链接 */  </span><br><span class="line">  </span><br><span class="line">        long now = time(NULL);                          //当前时间  </span><br><span class="line">        for (i = 0; i &lt; 100; i++, checkpos++) &#123;         //一次循环检测100个。 使用checkpos控制检测对象  </span><br><span class="line">            if (checkpos == MAX_EVENTS)  </span><br><span class="line">                checkpos = 0;  </span><br><span class="line">            if (g_events[checkpos].status != 1)         //不在红黑树 g_efd 上  </span><br><span class="line">                continue;  </span><br><span class="line">  </span><br><span class="line">            long duration = now - g_events[checkpos].last_active;       //客户端不活跃的世间  </span><br><span class="line">  //用一个last_active存储上次活跃时间，完事儿用当前时间和上次活跃时间来计算不活跃时间长度，不活跃时间超过一定阈值，就踢掉这个客户端。</span><br><span class="line">            if (duration &gt;= 60) &#123;  </span><br><span class="line">                close(g_events[checkpos].fd);                           //关闭与该客户端链接  </span><br><span class="line">                printf(&quot;[fd=%d] timeout\n&quot;, g_events[checkpos].fd);  </span><br><span class="line">                eventdel(g_efd, &amp;g_events[checkpos]);                   //将该客户端 从红黑树 g_efd移除  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        /*监听红黑树g_efd, 将满足的事件的文件描述符加至events数组中, 1秒没有事件满足, 返回 0*/  </span><br><span class="line">        int nfd = epoll_wait(g_efd, events, MAX_EVENTS+1, 1000);  </span><br><span class="line">        if (nfd &lt; 0) &#123;  </span><br><span class="line">            printf(&quot;epoll_wait error, exit\n&quot;);  </span><br><span class="line">            break;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        for (i = 0; i &lt; nfd; i++) &#123;  </span><br><span class="line">            /*使用自定义结构体myevent_s类型指针, 接收 联合体data的void *ptr成员*/  </span><br><span class="line">            struct myevent_s *ev = (struct myevent_s *)events[i].data.ptr;    </span><br><span class="line">  </span><br><span class="line">            if ((events[i].events &amp; EPOLLIN) &amp;&amp; (ev-&gt;events &amp; EPOLLIN)) &#123;           //读就绪事件  </span><br><span class="line">                ev-&gt;call_back(ev-&gt;fd, events[i].events, ev-&gt;arg);  </span><br><span class="line">                //lfd  EPOLLIN    </span><br><span class="line">            &#125;  </span><br><span class="line">            if ((events[i].events &amp; EPOLLOUT) &amp;&amp; (ev-&gt;events &amp; EPOLLOUT)) &#123;         //写就绪事件  </span><br><span class="line">                ev-&gt;call_back(ev-&gt;fd, events[i].events, ev-&gt;arg);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /* 退出前释放所有资源 */  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>main逻辑：创建套接字—》初始化连接—》超时验证—》监听—》处理读事件和写事件</p>
<p>eventset函数指定了不同事件对应的回调函数，所以虽然读写事件都用的call_back来回调，但实际上调用的是不同的函数。</p>
<p>eventset函数：</p>
<p>​    设置回调函数。  lfd –》 acceptconn()</p>
<p>​       cfd –&gt; recvdata();</p>
<p>​      cfd –&gt; senddata();</p>
<p>eventadd函数： </p>
<p>​    将一个fd， 添加到 监听红黑树。 设置监听 read事件，还是监听写事件。</p>
<p>网络编程中：   read — recv()</p>
<p>​      write — send();</p>
<hr>
<h2 id="accept返回EMFILE的处理"><a href="#accept返回EMFILE的处理" class="headerlink" title="accept返回EMFILE的处理"></a>accept返回EMFILE的处理</h2><p><img src="/Linux-%E5%A4%9A%E8%B7%AFI-O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230727221452876.png" alt="image-20230727221452876"></p>
<img src="/2023/07/12/Linux-%E5%A4%9A%E8%B7%AFI-O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230727221452876.png" class title="This is an test image">

<p>如果文件描述符不够用了</p>
<p>准备一个空闲的文件描述符。遇到这种情况，先关闭这个空闲文件，获得一个文件描述符名额;再accept (2)拿到socket连接的文件描述符;随后立刻close(2)，这样就优雅地断开了与客户端的连接;最后重新打开空闲文件，把“坑”填上，以备再次出现这种情况时使用。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/07/09/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/" rel="prev" title="Linux高性能服务器编程">
      <i class="fa fa-chevron-left"></i> Linux高性能服务器编程
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/07/14/Linux-%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="next" title="Linux-线程池">
      Linux-线程池 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E8%B7%AFIO%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="nav-number">1.</span> <span class="nav-text">多路IO转接服务器设计思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#select%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%AE%80%E4%BB%8B"><span class="nav-number">2.</span> <span class="nav-text">select函数参数简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#select%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90"><span class="nav-number">2.1.</span> <span class="nav-text">select相关函数参数分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#select%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%B7%AFIO%E8%BD%AC%E6%8E%A5%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="nav-number">2.2.</span> <span class="nav-text">select实现多路IO转接设计思路</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#select%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%B7%AFIO%E8%BD%AC%E6%8E%A5-%E4%BB%A3%E7%A0%81review"><span class="nav-number">3.</span> <span class="nav-text">select实现多路IO转接-代码review</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#select%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">3.1.</span> <span class="nav-text">select优缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E7%BB%84%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87"><span class="nav-number">4.</span> <span class="nav-text">添加一个自定义数组提高效率</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#poll%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E5%88%86%E6%9E%90"><span class="nav-number">5.</span> <span class="nav-text">poll函数原型分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#poll%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">5.1.</span> <span class="nav-text">poll函数实现服务器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%A4%9A%E8%B7%AFIO%E8%BD%AC%E6%8E%A5"><span class="nav-number">6.</span> <span class="nav-text">epoll函数实现的多路IO转接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%81%E7%A0%B41024%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%AE%BE%E7%BD%AE"><span class="nav-number">6.1.</span> <span class="nav-text">突破1024文件描述符设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll-create%E5%92%8Cepoll-ctl"><span class="nav-number">6.2.</span> <span class="nav-text">epoll_create和epoll_ctl</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll-wait%E5%87%BD%E6%95%B0"><span class="nav-number">6.3.</span> <span class="nav-text">epoll_wait函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#read%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">6.4.</span> <span class="nav-text">read函数返回值:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ET%E5%92%8CLT%E6%A8%A1%E5%BC%8F"><span class="nav-number">7.</span> <span class="nav-text">ET和LT模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E4%B8%ADET%E5%92%8CLT%E6%A8%A1%E5%BC%8F"><span class="nav-number">8.</span> <span class="nav-text">网络中ET和LT模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll%E7%9A%84ET%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F"><span class="nav-number">8.1.</span> <span class="nav-text">epoll的ET非阻塞模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll%E5%8F%8D%E5%BA%94%E5%A0%86%E6%A8%A1%E5%9E%8B%E6%80%BB%E8%BF%B0"><span class="nav-number">9.</span> <span class="nav-text">epoll反应堆模型总述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll%E5%8F%8D%E5%BA%94%E5%A0%86main%E9%80%BB%E8%BE%91"><span class="nav-number">9.1.</span> <span class="nav-text">epoll反应堆main逻辑</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#accept%E8%BF%94%E5%9B%9EEMFILE%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">10.</span> <span class="nav-text">accept返回EMFILE的处理</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">肖汇林</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">50</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">肖汇林</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
