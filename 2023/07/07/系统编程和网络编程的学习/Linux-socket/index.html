<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="网络字节序网络字节序：   小端法：（pc本地存储）  高位存高地址。低位存低地址。  int a &#x3D; 0x12345678   大端法：（网络存储） 高位存低地址。低位存高地址    htonl –&gt; 本地–》网络 （IP）     192.168.1.11 –&gt; string –&gt; atoi –&gt; int –&gt; htonl –&gt; 网络字节序   将">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux-socket">
<meta property="og:url" content="http://example.com/2023/07/07/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux-socket/index.html">
<meta property="og:site_name" content="肖汇林的博客">
<meta property="og:description" content="网络字节序网络字节序：   小端法：（pc本地存储）  高位存高地址。低位存低地址。  int a &#x3D; 0x12345678   大端法：（网络存储） 高位存低地址。低位存高地址    htonl –&gt; 本地–》网络 （IP）     192.168.1.11 –&gt; string –&gt; atoi –&gt; int –&gt; htonl –&gt; 网络字节序   将">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/Linux-socket/image-20230707141717803.png">
<meta property="og:image" content="http://example.com/2023/07/07/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux-socket/image-20230707141717803.png">
<meta property="og:image" content="http://example.com/Linux-socket/image-20230713205816024.png">
<meta property="og:image" content="http://example.com/2023/07/07/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux-socket/image-20230713205816024.png">
<meta property="og:image" content="http://example.com/Linux-socket/image-20230709110056462.png">
<meta property="og:image" content="http://example.com/2023/07/07/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux-socket/image-20230709110056462.png">
<meta property="og:image" content="http://example.com/Linux-socket/image-20230709110238005.png">
<meta property="og:image" content="http://example.com/2023/07/07/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux-socket/image-20230709110238005.png">
<meta property="og:image" content="http://example.com/Linux-socket/image-20230715144754541.png">
<meta property="og:image" content="http://example.com/2023/07/07/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux-socket/image-20230715144754541.png">
<meta property="article:published_time" content="2023-07-07T06:12:22.000Z">
<meta property="article:modified_time" content="2023-10-05T09:24:27.309Z">
<meta property="article:author" content="肖汇林">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/Linux-socket/image-20230707141717803.png">

<link rel="canonical" href="http://example.com/2023/07/07/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux-socket/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Linux-socket | 肖汇林的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖汇林的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/07/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux-socket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux-socket
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-07 14:12:22" itemprop="dateCreated datePublished" datetime="2023-07-07T14:12:22+08:00">2023-07-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-05 17:24:27" itemprop="dateModified" datetime="2023-10-05T17:24:27+08:00">2023-10-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h2><p>网络字节序：</p>
<p>  小端法：（pc本地存储）  高位存高地址。低位存低地址。  int a &#x3D; 0x12345678</p>
<p>  大端法：（网络存储） 高位存低地址。低位存高地址 </p>
<p>  htonl –&gt; 本地–》网络 （IP）     192.168.1.11 –&gt; string –&gt; atoi –&gt; int –&gt; htonl –&gt; 网络字节序   将32位主机字节序的整数转换为网络字节序（big-endian）</p>
<p>  htons –&gt; 本地–》网络 (port)        将16位主机字节序的短整数（通常是端口号）转换为网络字节序（big-endian）</p>
<p>  ntohl –&gt; 网络–》 本地（IP）</p>
<p>  ntohs –&gt; 网络–》 本地（Port）</p>
<p>ntohl函数用于字节顺序转换，将32位整数从网络字节顺序转换为主机字节顺序，对应于网络编程中的网络字节顺序的转换。它接收一个32位整数（网络字节顺序是大端法因为是tcp，早期大型机采用的是大端字节序，而大部分网络协议设计也遵循了这个约定）并返回主机字节顺序(一般是小端法)的整数。上面是POSIX标准的函数，可以在windows下使用，有移植效果。</p>
<hr>
<p>只能在Linux使用<code>htobe64</code>、<code>htobe32</code>、<code>htobe16</code>、<code>be64toh</code>、<code>be32toh</code>、<code>be16toh</code> 来完成实际的字节序转换操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">inline uint64_t hostToNetwork64(uint64_t host64)</span><br><span class="line">&#123;</span><br><span class="line">  return htobe64(host64);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline uint32_t hostToNetwork32(uint32_t host32)</span><br><span class="line">&#123;</span><br><span class="line">  return htobe32(host32);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline uint16_t hostToNetwork16(uint16_t host16)</span><br><span class="line">&#123;</span><br><span class="line">  return htobe16(host16);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline uint64_t networkToHost64(uint64_t net64)</span><br><span class="line">&#123;</span><br><span class="line">  return be64toh(net64);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline uint32_t networkToHost32(uint32_t net32)</span><br><span class="line">&#123;</span><br><span class="line">  return be32toh(net32);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline uint16_t networkToHost16(uint16_t net16)</span><br><span class="line">&#123;</span><br><span class="line">  return be16toh(net16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不可移植的</p>
<h2 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h2><p>IP地址转换函数：</p>
<p>  <code>int inet_pton(int af, const char *src, void *dst);</code>   本地字节序（string IP） —&gt; 网络字节序</p>
<p>​    af：AF_INET、AF_INET6</p>
<p>​    src：传入，IP地址（点分十进制）</p>
<p>​    dst：传出，转换后的 网络字节序的 IP地址。 </p>
<p>​    返回值：</p>
<p>​      成功： 1</p>
<p>​      异常： 0， 说明src指向的不是一个有效的ip地址。</p>
<p>​      失败：-1</p>
<p>​    <code>const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);</code> 网络字节序 —&gt; 本地字节序（string IP）</p>
<p>   参数说明：</p>
<ul>
<li><code>af</code>：地址族，即地址的类型，可以是 <code>AF_INET</code>（IPv4）或 <code>AF_INET6</code>（IPv6）。</li>
<li><code>src</code>：指向存储 IP 地址的字节序列的指针。</li>
<li><code>dst</code>：用于存储转换后的 IP 地址字符串的缓冲区。</li>
<li><code>size</code>：缓冲区 <code>dst</code> 的大小。</li>
</ul>
<p><code>inet_ntop</code> 函数会根据地址族和提供的字节序列，将 IP 地址转换成字符串，并存储在 <code>dst</code> 缓冲区中。它返回一个指向 <code>dst</code> 的指针，指向转换后的 IP 地址字符串。</p>
<h2 id="sockaddr地址结构"><a href="#sockaddr地址结构" class="headerlink" title="sockaddr地址结构"></a>sockaddr地址结构</h2><p><img src="/Linux-socket/image-20230707141717803.png" alt="image-20230707141717803"></p>
<img src="/2023/07/07/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux-socket/image-20230707141717803.png" class title="This is an test image">

<p>sockaddr地址结构：  IP + port –&gt; 在网络环境中唯一标识一个进程。</p>
<p>  struct sockaddr_in addr;</p>
<p>  addr.sin_family &#x3D; AF_INET&#x2F;AF_INET6      man 7 ip</p>
<p>  addr.sin_port &#x3D; htons(9527);</p>
<p>​    <code>int dst;</code></p>
<p>​    <code>inet_pton(AF_INET, &quot;192.157.22.45&quot;, (void *)&amp;dst);</code></p>
<p>  <code>addr.sin_addr.s_addr = dst;</code>相当于addr.sin_addr.s_addr &#x3D; htonl(INADDR_ANY);一般用后者简单</p>
<p>  <code>【*】addr.sin_addr.s_addr = htonl(INADDR_ANY);</code>    取出系统中有效的任意IP地址。二进制类型。</p>
<p>  <code>bind(fd, (struct sockaddr *)&amp;addr, size);</code></p>
<p><img src="/Linux-socket/image-20230713205816024.png" alt="image-20230713205816024"></p>
<img src="/2023/07/07/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux-socket/image-20230713205816024.png" class title="This is an test image">

<h3 id="socket和bind"><a href="#socket和bind" class="headerlink" title="socket和bind"></a>socket和bind</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">socket函数：</span><br><span class="line"></span><br><span class="line">	#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">	int socket(int domain, int type, int protocol);		创建一个 套接字</span><br><span class="line"></span><br><span class="line">		domain：AF_INET、AF_INET6、AF_UNIX</span><br><span class="line"></span><br><span class="line">		type：SOCK_STREAM（传输层使用tcp协议）、SOCK_DGRAM（传输层使用udp协议）</span><br><span class="line"></span><br><span class="line">		protocol: 0 </span><br><span class="line">		protocol参数是在前两个参数构成的协议集合下，再选择一个具体的协议。不过这个值通常都是唯一的（前两个参数已经完全决定了它的值)。几乎在所有情况下，我们都应该把它设置为0，表示使用默认协议。</span><br><span class="line"></span><br><span class="line">		返回值：</span><br><span class="line">	</span><br><span class="line">			成功： 新套接字所对应文件描述符</span><br><span class="line"></span><br><span class="line">			失败: -1 errno</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">值得指出的是，自Linux内核版本2.6.17起，type参数可以接受上述服务类型与下面两个重要的标志相与的值:SOCK_NONBLOCK和SOCK_CLOEXEC。它们分别表示将新创建的socket 设为非阻塞的，以及用fork调用创建子进程时在子进程中关闭该socket。在内核版本2.6.17之前的Linux中，文件描述符的这两个属性都需要使用额外的系统调用（比如fcntl）来设置。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">	 int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);		给socket绑定一个 地址结构 (IP+port)</span><br><span class="line"></span><br><span class="line">		sockfd: socket 函数返回值</span><br><span class="line"></span><br><span class="line">			struct sockaddr_in addr;</span><br><span class="line"></span><br><span class="line">			addr.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line">			addr.sin_port = htons(8888);</span><br><span class="line"></span><br><span class="line">			addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">		addr: 传入参数(struct sockaddr *)&amp;addr</span><br><span class="line"></span><br><span class="line">		addrlen: sizeof(addr) 地址结构的大小。</span><br><span class="line"></span><br><span class="line">		返回值：</span><br><span class="line"></span><br><span class="line">			成功：0</span><br><span class="line"></span><br><span class="line">			失败：-1 errno</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="listen和accept"><a href="#listen和accept" class="headerlink" title="listen和accept"></a>listen和accept</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">int listen(int sockfd, int backlog);		设置同时与服务器建立连接的上限数。（同时进行3次握手的客户端数量）</span><br><span class="line"></span><br><span class="line">		sockfd: socket 函数返回值</span><br><span class="line"></span><br><span class="line">		backlog：上限数值。最大值 128.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		返回值：</span><br><span class="line"></span><br><span class="line">			成功：0</span><br><span class="line"></span><br><span class="line">			失败：-1 errno	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);	阻塞等待客户端建立连接，成功的话，返回一个与客户端成功连接的socket文件描述符。</span><br><span class="line"></span><br><span class="line">		sockfd: socket 函数返回值</span><br><span class="line"></span><br><span class="line">		addr：传出参数。成功与服务器建立连接的那个客户端的地址结构（IP+port）</span><br><span class="line"></span><br><span class="line">			socklen_t clit_addr_len = sizeof(addr);</span><br><span class="line"></span><br><span class="line">		addrlen：传入传出。 &amp;clit_addr_len</span><br><span class="line"></span><br><span class="line">			 入：addr的大小。 出：客户端addr实际大小。</span><br><span class="line"></span><br><span class="line">		返回值：</span><br><span class="line"></span><br><span class="line">			成功：能与客户端进行数据通信的 socket 对应的文件描述。</span><br><span class="line"></span><br><span class="line">			失败： -1 ， errno</span><br><span class="line">		</span><br></pre></td></tr></table></figure>

<h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);	  使用现有的 socket 与服务器建立连接</span><br><span class="line"></span><br><span class="line">		sockfd： socket 函数返回值</span><br><span class="line"></span><br><span class="line">			struct sockaddr_in srv_addr;		// 服务器地址结构</span><br><span class="line"></span><br><span class="line">			srv_addr.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line">			srv_addr.sin_port = 9527 	跟服务器bind时设定的 port 完全一致。</span><br><span class="line"></span><br><span class="line">			inet_pton(AF_INET, &quot;服务器的IP地址&quot;，&amp;srv_adrr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">		addr：传入参数。服务器的地址结构</span><br><span class="line"></span><br><span class="line">			</span><br><span class="line">		addrlen：服务器的地址结构的大小</span><br><span class="line"></span><br><span class="line">		返回值：</span><br><span class="line"></span><br><span class="line">			成功：0</span><br><span class="line"></span><br><span class="line">			失败：-1 errno</span><br><span class="line"></span><br><span class="line">		如果不使用bind绑定客户端地址结构, 采用&quot;隐式绑定&quot;.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="CS模型的TCP通信分析"><a href="#CS模型的TCP通信分析" class="headerlink" title="CS模型的TCP通信分析"></a>CS模型的TCP通信分析</h2><p>TCP通信流程分析:</p>
<p>server:<br>    1. socket()	创建socket</p>
<ol start="2">
<li><p>bind()	绑定服务器地址结构</p>
</li>
<li><p>listen()	设置监听上限</p>
</li>
<li><p>accept()	阻塞监听客户端连接</p>
</li>
<li><p>read(fd)	读socket获取客户端数据</p>
</li>
<li><p>小–大写	toupper()</p>
</li>
<li><p>write(fd)</p>
</li>
<li><p>close();</p>
</li>
</ol>
<p>client:</p>
<ol>
<li><p>socket()	创建socket</p>
</li>
<li><p>connect();	与服务器建立连接</p>
</li>
<li><p>write()	写数据到 socket</p>
</li>
<li><p>read()	读转换后的数据。</p>
</li>
<li><p>显示读取结果</p>
</li>
<li><p>close()</p>
</li>
</ol>
<h2 id="server的实现"><a href="#server的实现" class="headerlink" title="server的实现"></a>server的实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include &lt;ctype.h&gt;  </span><br><span class="line">#include &lt;sys/socket.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;errno.h&gt;  </span><br><span class="line">#include &lt;pthread.h&gt;  </span><br><span class="line">#define SERV_PORT 9527  </span><br><span class="line"></span><br><span class="line">void sys_err(const char *str)  </span><br><span class="line">&#123;  </span><br><span class="line">        perror(str);  </span><br><span class="line">        exit(1);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">        int lfd = 0, cfd = 0;  </span><br><span class="line">        int ret, i;  </span><br><span class="line">        char buf[BUFSIZ], client_IP[1024]; //[+d查看系统定义的BUFSIZ的大小 </span><br><span class="line"></span><br><span class="line">        struct sockaddr_in serv_addr, clit_addr;  // 定义服务器地址结构 和 客户端地址结构  </span><br><span class="line">        socklen_t clit_addr_len;                  // 客户端地址结构大小  </span><br><span class="line"></span><br><span class="line">        serv_addr.sin_family = AF_INET;             // IPv4  </span><br><span class="line">        serv_addr.sin_port = htons(SERV_PORT);      // 转为网络字节序的 端口号  </span><br><span class="line">        serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  // 获取本机任意有效IP  </span><br><span class="line"></span><br><span class="line">        lfd = socket(AF_INET, SOCK_STREAM, 0);      //创建一个 socket  </span><br><span class="line">        if (lfd == -1) &#123;  </span><br><span class="line">                sys_err(&quot;socket error&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        bind(lfd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr));//给服务器socket绑定地址结构（IP+port)  </span><br><span class="line"></span><br><span class="line">        listen(lfd, 128);                   //  设置监听上限  </span><br><span class="line"></span><br><span class="line">        clit_addr_len = sizeof(clit_addr);  //  获取客户端地址结构大小  </span><br><span class="line"></span><br><span class="line">        cfd = accept(lfd, (struct sockaddr *)&amp;clit_addr, &amp;clit_addr_len);   // 阻塞等待客户端连接请求  </span><br><span class="line">        if (cfd == -1)  </span><br><span class="line">                sys_err(&quot;accept error&quot;);  </span><br><span class="line"></span><br><span class="line">        printf(&quot;client ip:%s port:%d\n&quot;,   </span><br><span class="line">                        inet_ntop(AF_INET, &amp;clit_addr.sin_addr.s_addr, client_IP, sizeof(client_IP)),                        ntohs(clit_addr.sin_port));         // 根据accept传出参数，获取客户端 ip 和 port  </span><br><span class="line"></span><br><span class="line">        while (1) &#123;  </span><br><span class="line">                ret = read(cfd, buf, sizeof(buf));      // 读客户端数据 ssize_t read(int fd, void *buf, size_t count); </span><br><span class="line">                //read函数的返回值是读取到的字节数，将其赋给ret变量。</span><br><span class="line">                write(STDOUT_FILENO, buf, ret);         // 写到屏幕查看  ssize_t write(int fd, const void *buf, size_t count);</span><br><span class="line"></span><br><span class="line">                for (i = 0; i &lt; ret; i++)                // 小写 -- 大写  </span><br><span class="line">                        buf[i] = toupper(buf[i]);  </span><br><span class="line"></span><br><span class="line">                write(cfd, buf, ret);                   // 将大写，写回给客户端。  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        close(lfd);  </span><br><span class="line">        close(cfd);  </span><br><span class="line"></span><br><span class="line">        return 0;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="获取客户端地址结构"><a href="#获取客户端地址结构" class="headerlink" title="获取客户端地址结构"></a>获取客户端地址结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cfd = accept(lfd, (struct sockaddr *)&amp;clit_addr, &amp;clit_addr_len);</span><br><span class="line">accept函数中的clit_addr传出的就是客户端地址结构，IP+port</span><br><span class="line"></span><br><span class="line">于是，在代码中增加此段代码，可获取客户端信息：</span><br><span class="line">printf(&quot;client ip:%s port:%d\n&quot;, </span><br><span class="line">            inet_ntop(AF_INET,&amp;clit_addr.sin_addr.s_addr, client_IP, sizeof(client_IP)), </span><br><span class="line">            ntohs(clit_addr.sin_port));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="client的实现"><a href="#client的实现" class="headerlink" title="client的实现"></a>client的实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;sys/socket.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;errno.h&gt;  </span><br><span class="line">#include &lt;pthread.h&gt;  </span><br><span class="line"></span><br><span class="line">#define SERV_PORT 9527  </span><br><span class="line"></span><br><span class="line">void sys_err(const char* str)  </span><br><span class="line">&#123;  </span><br><span class="line">    perror(str);  </span><br><span class="line">    exit(1);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">    int cfd;  </span><br><span class="line">    int conter = 10;  </span><br><span class="line">    char buf[BUFSIZ];  </span><br><span class="line">    </span><br><span class="line">    struct sockaddr_in serv_addr;          //服务器地址结构  </span><br><span class="line"></span><br><span class="line">    serv_addr.sin_family = AF_INET;  </span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);  </span><br><span class="line">    //inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;serv_addr.sin_addr.s_addr);  </span><br><span class="line">    inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;serv_addr.sin_addr);  </span><br><span class="line"></span><br><span class="line">    cfd = socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">    if (cfd == -1)  </span><br><span class="line">        sys_err(&quot;socket error&quot;);  </span><br><span class="line"></span><br><span class="line">    int ret = connect(cfd, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr));  </span><br><span class="line">    if (ret != 0)  </span><br><span class="line">        sys_err(&quot;connect err&quot;);  </span><br><span class="line"></span><br><span class="line">    while (--conter) &#123;  </span><br><span class="line">        write(cfd, &quot;hello\n&quot;, 6);  </span><br><span class="line">        ret = read(cfd, buf, sizeof(buf));  </span><br><span class="line">        write(STDOUT_FILENO, buf, ret);  </span><br><span class="line">        sleep(1);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    close(cfd);  </span><br><span class="line"></span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里遇到过一个问题，如果之前运行server，用Ctrl+z终止进程，ps aux列表里会有服务器进程残留，这个会影响当前服务器。解决方法是kill掉这些服务器进程。不然端口被占用，当前运行的服务器进程接收不到东西，没有回显。</p>
<h2 id="错误处理函数的封装思路"><a href="#错误处理函数的封装思路" class="headerlink" title="错误处理函数的封装思路"></a>错误处理函数的封装思路</h2><p>wrap.h文件如下，就是包裹函数的声明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __WRAP_H_  </span><br><span class="line">#define __WRAP_H_  </span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">void perr_exit(const char* s);</span><br><span class="line">int Accept(int fd, struct sockaddr* sa, socklen_t* salenptr);</span><br><span class="line">int Bind(int fd, const struct sockaddr* sa, socklen_t salen);</span><br><span class="line">int Connect(int fd, const struct sockaddr* sa, socklen_t salen);</span><br><span class="line">int Listen(int fd, int backlog);</span><br><span class="line">int Socket(int family, int type, int protocol);</span><br><span class="line">ssize_t Read(int fd, void* ptr, size_t nbytes);</span><br><span class="line">ssize_t Write(int fd, const void* ptr, size_t nbytes);</span><br><span class="line">int Close(int fd);</span><br><span class="line">ssize_t Readn(int fd, void* vptr, size_t n);</span><br><span class="line">ssize_t Writen(int fd, const void* vptr, size_t n);</span><br><span class="line">ssize_t my_read(int fd, char* ptr);</span><br><span class="line">ssize_t Readline(int fd, void* vptr, size_t maxlen);</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>wrap.c随便取一部分，如下，就是包裹函数的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;wrap.h&quot;</span><br><span class="line"></span><br><span class="line">void perr_exit(const char *s)</span><br><span class="line">&#123;</span><br><span class="line">	perror(s);</span><br><span class="line">	exit(1);</span><br><span class="line">&#125;</span><br><span class="line">int Accept(int fd, struct sockaddr *sa, socklen_t *salenptr)</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	again:</span><br><span class="line">	if ( (n = accept(fd, sa, salenptr)) &lt; 0) &#123;</span><br><span class="line">		if ((errno == ECONNABORTED) || (errno == EINTR))</span><br><span class="line">			goto again;</span><br><span class="line">		else</span><br><span class="line">			perr_exit(&quot;accept error&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br><span class="line">int Bind(int fd, const struct sockaddr *sa, socklen_t salen)</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	if ((n = bind(fd, sa, salen)) &lt; 0)</span><br><span class="line">		perr_exit(&quot;bind error&quot;);</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br><span class="line">int Connect(int fd, const struct sockaddr *sa, socklen_t salen)</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	if ((n = connect(fd, sa, salen)) &lt; 0)</span><br><span class="line">		perr_exit(&quot;connect error&quot;);</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br><span class="line">int Listen(int fd, int backlog)</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	if ((n = listen(fd, backlog)) &lt; 0)</span><br><span class="line">		perr_exit(&quot;listen error&quot;);</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br><span class="line">int Socket(int family, int type, int protocol)</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	if ( (n = socket(family, type, protocol)) &lt; 0)</span><br><span class="line">		perr_exit(&quot;socket error&quot;);</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br><span class="line">ssize_t Read(int fd, void *ptr, size_t nbytes)</span><br><span class="line">&#123;</span><br><span class="line">	ssize_t n;</span><br><span class="line">again:</span><br><span class="line">	if ( (n = read(fd, ptr, nbytes)) == -1) &#123;</span><br><span class="line">		if (errno == EINTR)</span><br><span class="line">			goto again;</span><br><span class="line">		else</span><br><span class="line">			return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br><span class="line">ssize_t Write(int fd, const void *ptr, size_t nbytes)</span><br><span class="line">&#123;</span><br><span class="line">	ssize_t n;</span><br><span class="line">again:</span><br><span class="line">	if ( (n = write(fd, ptr, nbytes)) == -1) &#123;</span><br><span class="line">		if (errno == EINTR)</span><br><span class="line">			goto again;</span><br><span class="line">		else</span><br><span class="line">			return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br><span class="line">int Close(int fd)</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	if ((n = close(fd)) == -1)</span><br><span class="line">		perr_exit(&quot;close error&quot;);</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br><span class="line">ssize_t Readn(int fd, void *vptr, size_t n)</span><br><span class="line">&#123;</span><br><span class="line">	size_t nleft;</span><br><span class="line">	ssize_t nread;</span><br><span class="line">	char *ptr;</span><br><span class="line"></span><br><span class="line">	ptr = vptr;</span><br><span class="line">	nleft = n;</span><br><span class="line"></span><br><span class="line">	while (nleft &gt; 0) &#123;</span><br><span class="line">		if ( (nread = read(fd, ptr, nleft)) &lt; 0) &#123;</span><br><span class="line">			if (errno == EINTR)</span><br><span class="line">				nread = 0;</span><br><span class="line">			else</span><br><span class="line">				return -1;</span><br><span class="line">		&#125; else if (nread == 0)</span><br><span class="line">			break;</span><br><span class="line">		nleft -= nread;</span><br><span class="line">		ptr += nread;</span><br><span class="line">	&#125;</span><br><span class="line">	return n - nleft;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ssize_t Writen(int fd, const void *vptr, size_t n)</span><br><span class="line">&#123;</span><br><span class="line">	size_t nleft;</span><br><span class="line">	ssize_t nwritten;</span><br><span class="line">	const char *ptr;</span><br><span class="line"></span><br><span class="line">	ptr = vptr;</span><br><span class="line">	nleft = n;</span><br><span class="line"></span><br><span class="line">	while (nleft &gt; 0) &#123;</span><br><span class="line">		if ( (nwritten = write(fd, ptr, nleft)) &lt;= 0) &#123;</span><br><span class="line">			if (nwritten &lt; 0 &amp;&amp; errno == EINTR)</span><br><span class="line">				nwritten = 0;</span><br><span class="line">			else</span><br><span class="line">				return -1;</span><br><span class="line">		&#125;</span><br><span class="line">		nleft -= nwritten;</span><br><span class="line">		ptr += nwritten;</span><br><span class="line">	&#125;</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ssize_t my_read(int fd, char *ptr)</span><br><span class="line">&#123;</span><br><span class="line">	static int read_cnt;</span><br><span class="line">	static char *read_ptr;</span><br><span class="line">	static char read_buf[100];</span><br><span class="line"></span><br><span class="line">	if (read_cnt &lt;= 0) &#123;</span><br><span class="line">again:</span><br><span class="line">		if ((read_cnt = read(fd, read_buf, sizeof(read_buf))) &lt; 0) &#123;</span><br><span class="line">			if (errno == EINTR)</span><br><span class="line">				goto again;</span><br><span class="line">			return -1;	</span><br><span class="line">		&#125; else if (read_cnt == 0)</span><br><span class="line">			return 0;</span><br><span class="line">		read_ptr = read_buf;</span><br><span class="line">	&#125;</span><br><span class="line">	read_cnt--;</span><br><span class="line">	*ptr = *read_ptr++;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ssize_t Readline(int fd, void *vptr, size_t maxlen)</span><br><span class="line">&#123;</span><br><span class="line">	ssize_t n, rc;</span><br><span class="line">	char c, *ptr;</span><br><span class="line">	ptr = vptr;</span><br><span class="line"></span><br><span class="line">	for (n = 1; n &lt; maxlen; n++) &#123;</span><br><span class="line">		if ( (rc = my_read(fd, &amp;c)) == 1) &#123;</span><br><span class="line">			*ptr++ = c;</span><br><span class="line">			if (c == &#x27;\n&#x27;)</span><br><span class="line">				break;</span><br><span class="line">		&#125; else if (rc == 0) &#123;</span><br><span class="line">			*ptr = 0;</span><br><span class="line">			return n - 1;</span><br><span class="line">		&#125; else</span><br><span class="line">			return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	*ptr = 0;</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里原函数和包裹函数的函数名差异只有首字母大写，这是因为man page对字母大小写不敏感，同名的包裹函数一样可以跳转至man page</p>
<hr>
<p>错误处理函数： </p>
<p>  封装目的：</p>
<p>​    在 server.c 编程过程中突出逻辑，将出错处理与逻辑分开，可以直接跳转man手册。</p>
<p>  【wrap.c】             【wrap.h】</p>
<p>  存放网络通信相关常用 自定义函数         存放 网络通信相关常用 自定义函数原型(声明)。</p>
<p>  命名方式：系统调用函数首字符大写, 方便查看man手册</p>
<p>​     如：Listen()、Accept();</p>
<p>  函数功能：调用系统调用函数，处理出错场景。</p>
<p>  在 server.c 和 client.c 中调用 自定义函数 </p>
<p>  联合编译 server.c 和 wrap.c 生成 server</p>
<p>​     			client.c 和 wrap.c 生成 client </p>
<p>readn：</p>
<p>  读 N 个字节 </p>
<p>readline：</p>
<p>  读一行</p>
<h2 id="TCP和UDP通信优缺点"><a href="#TCP和UDP通信优缺点" class="headerlink" title="TCP和UDP通信优缺点"></a>TCP和UDP通信优缺点</h2><p>TCP通信和UDP通信各自的优缺点：</p>
<p>  TCP： 面向连接的，可靠数据包传输。对于不稳定的网络层，采取完全弥补的通信方式。 丢包重传。</p>
<p>​    优点：</p>
<p>​      稳定。   </p>
<p>​       数据流量稳定、速度稳定、顺序</p>
<p>​    缺点：</p>
<p>​      传输速度慢。相率低。开销大。</p>
<p>​    使用场景：数据的完整型要求较高，不追求效率。</p>
<p>​       大数据传输、文件传输。</p>
<p>  UDP： 无连接的，不可靠的数据报传递。对于不稳定的网络层，采取完全不弥补的通信方式。 默认还原网络状况</p>
<p>​    优点：</p>
<p>​      传输速度块。相率高。开销小。</p>
<p>​    缺点：</p>
<p>​      不稳定。</p>
<p>​       数据流量。速度。顺序。</p>
<p>​    使用场景：对时效性要求较高场合。稳定性其次。</p>
<p>​       游戏、视频会议、视频电话。    腾讯、华为、阿里 — 应用层数据校验协议，弥补udp的不足。</p>
<h2 id="UDP通信server和client流程"><a href="#UDP通信server和client流程" class="headerlink" title="UDP通信server和client流程"></a>UDP通信server和client流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">UDP实现的 C/S 模型：直接就支持多路IO</span><br><span class="line"></span><br><span class="line">	recv()/send() 只能用于 TCP 通信。 替代 read、write</span><br><span class="line"></span><br><span class="line">	accpet(); ---- Connect(); ---被舍弃</span><br><span class="line"></span><br><span class="line">	server：</span><br><span class="line"></span><br><span class="line">		lfd = socket(AF_INET, STREAM, 0);	SOCK_DGRAM --- 报式协议。</span><br><span class="line"></span><br><span class="line">		bind();</span><br><span class="line"></span><br><span class="line">		listen();  --- 可有可无</span><br><span class="line"></span><br><span class="line">		while（1）&#123;</span><br><span class="line"></span><br><span class="line">			read(cfd, buf, sizeof) --- 被替换 --- recvfrom（） --- 涵盖accept传出地址结构。</span><br><span class="line">小-- 大</span><br><span class="line">				</span><br><span class="line">			write();--- 被替换 --- sendto（）---- connect</span><br><span class="line">		&#125;</span><br><span class="line">		close();</span><br><span class="line"></span><br><span class="line">client：</span><br><span class="line"></span><br><span class="line">		connfd = socket(AF_INET, SOCK_DGRAM, 0);</span><br><span class="line"></span><br><span class="line">		sendto（‘服务器的地址结构’， 地址结构大小）</span><br><span class="line"></span><br><span class="line">		recvfrom（）</span><br><span class="line"></span><br><span class="line">		写到屏幕</span><br><span class="line"></span><br><span class="line">		close();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="recvfrom和sendto函数"><a href="#recvfrom和sendto函数" class="headerlink" title="recvfrom和sendto函数"></a>recvfrom和sendto函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,struct sockaddr *src_addr, socklen_t *addrlen);</span><br><span class="line"></span><br><span class="line">					sockfd： 套接字</span><br><span class="line"></span><br><span class="line">					buf：缓冲区地址</span><br><span class="line"></span><br><span class="line">					len：缓冲区大小</span><br><span class="line"></span><br><span class="line">					flags： 0</span><br><span class="line"></span><br><span class="line">					src_addr：（struct sockaddr *）&amp;addr 传出。 对端地址结构</span><br><span class="line"></span><br><span class="line">					addrlen：传入传出。</span><br><span class="line"></span><br><span class="line">				返回值： 成功接收数据字节数。 失败：-1 errn。 0： 对端关闭。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,const struct sockaddr *dest_addr, socklen_t addrlen);</span><br><span class="line"></span><br><span class="line">					sockfd： 套接字</span><br><span class="line"></span><br><span class="line">					buf：存储数据的缓冲区</span><br><span class="line"></span><br><span class="line">					len：数据长度</span><br><span class="line"></span><br><span class="line">					flags： 0</span><br><span class="line"></span><br><span class="line">					src_addr：（struct sockaddr *）&amp;addr 传入。 目标地址结构</span><br><span class="line"></span><br><span class="line">					addrlen：地址结构长度。</span><br><span class="line"></span><br><span class="line">				返回值：成功写出数据字节数。 失败 -1， errno		</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="UDP实现的并发服务器和客户端"><a href="#UDP实现的并发服务器和客户端" class="headerlink" title="UDP实现的并发服务器和客户端"></a>UDP实现的并发服务器和客户端</h3><p>服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">#include &lt;ctype.h&gt;  </span><br><span class="line">  </span><br><span class="line">#define SERV_PORT 8000  </span><br><span class="line">  </span><br><span class="line">int main(void)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct sockaddr_in serv_addr, clie_addr;  </span><br><span class="line">    socklen_t clie_addr_len;  </span><br><span class="line">    int sockfd;  </span><br><span class="line">    char buf[BUFSIZ];  </span><br><span class="line">    char str[INET_ADDRSTRLEN];  </span><br><span class="line">    int i, n;  </span><br><span class="line">  </span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, 0);  </span><br><span class="line">  </span><br><span class="line">    bzero(&amp;serv_addr, sizeof(serv_addr));  </span><br><span class="line">    serv_addr.sin_family = AF_INET;  </span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);  </span><br><span class="line">  </span><br><span class="line">    bind(sockfd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr));  </span><br><span class="line">  </span><br><span class="line">    printf(&quot;Accepting connections ...\n&quot;);  </span><br><span class="line">    while (1) &#123;  </span><br><span class="line">        clie_addr_len = sizeof(clie_addr);  </span><br><span class="line">        n = recvfrom(sockfd, buf, BUFSIZ,0, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);  </span><br><span class="line">        if (n == -1)  </span><br><span class="line">            perror(&quot;recvfrom error&quot;);  </span><br><span class="line">  </span><br><span class="line">        printf(&quot;received from %s at PORT %d\n&quot;,  </span><br><span class="line">                inet_ntop(AF_INET, &amp;clie_addr.sin_addr, str, sizeof(str)),  </span><br><span class="line">                ntohs(clie_addr.sin_port));  </span><br><span class="line">  </span><br><span class="line">        for (i = 0; i &lt; n; i++)  </span><br><span class="line">            buf[i] = toupper(buf[i]);  </span><br><span class="line">  </span><br><span class="line">        n = sendto(sockfd, buf, n, 0, (struct sockaddr *)&amp;clie_addr, sizeof(clie_addr));  </span><br><span class="line">        if (n == -1)  </span><br><span class="line">            perror(&quot;sendto error&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    close(sockfd);  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">#include &lt;ctype.h&gt;  </span><br><span class="line">  </span><br><span class="line">#define SERV_PORT 8000  </span><br><span class="line">  </span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">    struct sockaddr_in servaddr;  </span><br><span class="line">    int sockfd, n;  </span><br><span class="line">    char buf[BUFSIZ];  </span><br><span class="line">  </span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, 0);  </span><br><span class="line">  </span><br><span class="line">    bzero(&amp;servaddr, sizeof(servaddr));  </span><br><span class="line">    servaddr.sin_family = AF_INET;  </span><br><span class="line">    inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;servaddr.sin_addr);  </span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);  </span><br><span class="line">  </span><br><span class="line">    bind(sockfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));  </span><br><span class="line">  </span><br><span class="line">    while (fgets(buf, BUFSIZ, stdin) != NULL) &#123;  </span><br><span class="line">        n = sendto(sockfd, buf, strlen(buf), 0, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));  </span><br><span class="line">        if (n == -1)  </span><br><span class="line">            perror(&quot;sendto error&quot;);  </span><br><span class="line">  </span><br><span class="line">        n = recvfrom(sockfd, buf, BUFSIZ, 0, NULL, 0);         //NULL:不关心对端信息  </span><br><span class="line">        if (n == -1)  </span><br><span class="line">            perror(&quot;recvfrom error&quot;);  </span><br><span class="line">  </span><br><span class="line">        write(STDOUT_FILENO, buf, n);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    close(sockfd);  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="多进程并发服务器思路分析"><a href="#多进程并发服务器思路分析" class="headerlink" title="多进程并发服务器思路分析"></a>多进程并发服务器思路分析</h2><p>在一个多进程并发服务器中，通常会有一个父进程负责监听新的连接请求，而子进程负责处理具体的连接。这种架构被称为”预派生”或”预分叉”模型。当子进程已经派生并开始处理连接时，父进程的监听套接字（用于接受新的连接）以及子进程不再需要的其他资源都应该被关闭，以避免资源泄漏和冲突。</p>
<ol>
<li><strong>子进程关闭监听套接字：</strong> 子进程派生后，<strong>会继承父进程的文件描述符</strong>，包括监听套接字。由于每个套接字需要一个独立的进程去处理连接，因此子进程需要关闭不再使用的监听套接字。这样可以确保每个子进程只处理属于它的连接，并防止不必要的资源占用。</li>
<li><strong>父进程关闭已连接的套接字：</strong> 在并发服务器中，父进程在派生子进程后，不再处理具体的连接，而是将连接交给子进程处理。因此，父进程应该关闭已连接的套接字，即已经建立连接并交给子进程处理的套接字。这样可以避免不同进程之间对同一套接字资源的冲突。</li>
</ol>
<p>总之，关闭不再使用的套接字可以避免资源泄漏和进程间的竞争问题，确保并发服务器的稳定运行。</p>
<h3 id="多进程并发服务器实现"><a href="#多进程并发服务器实现" class="headerlink" title="多进程并发服务器实现"></a>多进程并发服务器实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;ctype.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;sys/wait.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;strings.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;errno.h&gt;  </span><br><span class="line">#include &lt;signal.h&gt;  </span><br><span class="line">#include &lt;sys/socket.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">#include &lt;pthread.h&gt;  </span><br><span class="line"></span><br><span class="line">#include &quot;wrap.h&quot;  </span><br><span class="line"></span><br><span class="line">#define SRV_PORT 9999  </span><br><span class="line">//在每个子进程退出时，内核会发送 SIGCHLD 信号，然后调用 catch_child 函数进行处理。在 catch_child 函数内部，使用 waitpid 函数来回收已经退出的子进程，防止其成为僵尸进程。循环调用 waitpid 是为了确保一次性处理所有已退出的子进程</span><br><span class="line">void catch_child(int signum)  //当子进程退出时，父进程收到信号，就会去回收子进程了，不会出现僵尸进程</span><br><span class="line">&#123;  </span><br><span class="line">    while ((waitpid(0, NULL, WNOHANG)) &gt; 0);  //waitpid可以通过传递WNOHANG使父进程不阻塞立即返回</span><br><span class="line">    return;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;</span><br><span class="line">    int lfd, cfd;  </span><br><span class="line">    pid_t pid;  </span><br><span class="line">    struct sockaddr_in srv_addr, clt_addr;  </span><br><span class="line">    socklen_t clt_addr_len;   </span><br><span class="line">    char buf[BUFSIZ];  </span><br><span class="line">    int ret, i;  </span><br><span class="line">    </span><br><span class="line">    //memset(&amp;srv_addr, 0, sizeof(srv_addr));                 // 将地址结构清零  </span><br><span class="line">    bzero(&amp;srv_addr, sizeof(srv_addr));  </span><br><span class="line">    </span><br><span class="line">    srv_addr.sin_family = AF_INET;  </span><br><span class="line">    srv_addr.sin_port = htons(SRV_PORT);  </span><br><span class="line">    srv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">    </span><br><span class="line">    lfd = Socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">    </span><br><span class="line">    Bind(lfd, (struct sockaddr *)&amp;srv_addr, sizeof(srv_addr));  </span><br><span class="line">    </span><br><span class="line">    Listen(lfd, 128);  </span><br><span class="line">    </span><br><span class="line">    clt_addr_len = sizeof(clt_addr);  </span><br><span class="line">    </span><br><span class="line">    while (1) &#123;  </span><br><span class="line">    </span><br><span class="line">        cfd = Accept(lfd, (struct sockaddr *)&amp;clt_addr, &amp;clt_addr_len);  </span><br><span class="line">    </span><br><span class="line">        pid = fork();  </span><br><span class="line">        if (pid &lt; 0) &#123;  </span><br><span class="line">            perr_exit(&quot;fork error&quot;);  </span><br><span class="line">        &#125; else if (pid == 0) &#123;  //子进程</span><br><span class="line">            close(lfd);  </span><br><span class="line">            break;          </span><br><span class="line">        &#125; else &#123;  //父进程</span><br><span class="line">            struct sigaction act;  </span><br><span class="line">    </span><br><span class="line">            act.sa_handler = catch_child;  </span><br><span class="line">            sigemptyset(&amp;act.sa_mask);  </span><br><span class="line">            act.sa_flags = 0;  </span><br><span class="line">    </span><br><span class="line">            ret = sigaction(SIGCHLD, &amp;act, NULL);  </span><br><span class="line">            if (ret != 0) &#123;  </span><br><span class="line">               perr_exit(&quot;sigaction error&quot;);  </span><br><span class="line">            &#125;  </span><br><span class="line">            close(cfd);   </span><br><span class="line">            continue;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    if (pid == 0) &#123;  </span><br><span class="line">        for (;;) &#123;  </span><br><span class="line">            ret = Read(cfd, buf, sizeof(buf));  </span><br><span class="line">            if (ret == 0) &#123;  </span><br><span class="line">                close(cfd);  </span><br><span class="line">                exit(1);  </span><br><span class="line">            &#125;   </span><br><span class="line">    </span><br><span class="line">            for (i = 0; i &lt; ret; i++)  </span><br><span class="line">                buf[i] = toupper(buf[i]);  </span><br><span class="line">    </span><br><span class="line">            write(cfd, buf, ret);  </span><br><span class="line">            write(STDOUT_FILENO, buf, ret);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    return 0；</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>使用桥接模式，让自己主机和其他人主机处于同一个网段</p>
<p><img src="/Linux-socket/image-20230709110056462.png" alt="image-20230709110056462"></p>
<img src="/2023/07/07/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux-socket/image-20230709110056462.png" class title="This is an test image">

<p><img src="/Linux-socket/image-20230709110238005.png" alt="image-20230709110238005"></p>
<img src="/2023/07/07/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux-socket/image-20230709110238005.png" class title="This is an test image">

<p>然后再断开再桥接连一下，这个是你自己取的名字。</p>
<h3 id="服务器程序上传外网服务器并访问"><a href="#服务器程序上传外网服务器并访问" class="headerlink" title="服务器程序上传外网服务器并访问"></a>服务器程序上传外网服务器并访问</h3><p>scp -r 命令，将本地文件拷贝至远程服务器上目标位置</p>
<p>scp -r 源地址 目标地址</p>
<h2 id="多线程服务器代码review"><a href="#多线程服务器代码review" class="headerlink" title="多线程服务器代码review"></a>多线程服务器代码review</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">多线程并发服务器： server.c </span><br><span class="line"></span><br><span class="line">	1. Socket();		创建 监听套接字 lfd</span><br><span class="line"></span><br><span class="line">	2. Bind()		绑定地址结构 Strcut scokaddr_in addr;</span><br><span class="line"></span><br><span class="line">	3. Listen();		</span><br><span class="line"></span><br><span class="line">	4. while (1) &#123;		</span><br><span class="line"></span><br><span class="line">		cfd = Accept(lfd, );</span><br><span class="line"></span><br><span class="line">		pthread_create(&amp;tid, NULL, tfn, (void *)cfd);</span><br><span class="line"></span><br><span class="line">		pthread_detach(tid);  				// pthead_join(tid, void **);  新线程---专用于回收子线程。</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	5. 子线程：</span><br><span class="line"></span><br><span class="line">		void *tfn(void *arg) </span><br><span class="line">		&#123;</span><br><span class="line">			// close(lfd)			不能关闭。 主线程要使用lfd</span><br><span class="line"></span><br><span class="line">			read(cfd)</span><br><span class="line"></span><br><span class="line">			小--大</span><br><span class="line"></span><br><span class="line">			write(cfd)</span><br><span class="line"></span><br><span class="line">			pthread_exit（(void *)10）;	</span><br><span class="line">		&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;ctype.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;wrap.h&quot;</span><br><span class="line"></span><br><span class="line">#define MAXLINE 8192</span><br><span class="line">#define SERV_PORT 8000</span><br><span class="line"></span><br><span class="line">struct s_info &#123;											//定义一个结构体, 将地址结构跟cfd捆绑</span><br><span class="line">    struct sockaddr_in cliaddr;</span><br><span class="line">    int connfd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void *do_work(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    int n, i;</span><br><span class="line">    struct s_info *ts = (struct s_info *) arg;</span><br><span class="line">    char buf[MAXLINE];</span><br><span class="line">    char str[INET_ADDRSTRLEN];				//#define INET_ADDRSTRLEN 16  可用&quot;[+d&quot;查看</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        n = Read(ts-&gt;connfd, buf, MAXLINE);	//读客户端</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            printf(&quot;the client %d closed...\n&quot;, ts-&gt;connfd);</span><br><span class="line">            break;							//跳出循环,关闭cfd </span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;received from %s at PORT %d\n&quot;,</span><br><span class="line">               inet_ntop(AF_INET, &amp;(*ts).cliaddr.sin_addr, str, sizeof(str)),</span><br><span class="line">               ntohs((*ts).cliaddr.sin_port));			//打印客户端信息(IP/PORT)</span><br><span class="line"></span><br><span class="line">        for (i = 0; i &lt; n; i++)</span><br><span class="line">            buf[i] = toupper(buf[i]);					  //小写--&gt;大写  </span><br><span class="line"></span><br><span class="line">        Write(STDOUT_FILENO, buf, n);					//写出至屏幕  </span><br><span class="line">        Write(ts-&gt;connfd, buf, n);						  //回写给客户端 </span><br><span class="line">    &#125;</span><br><span class="line">    Close(ts-&gt;connfd);</span><br><span class="line"></span><br><span class="line">    return (void *) 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    struct sockaddr_in servaddr, cliaddr;</span><br><span class="line">    socklen_t cliaddr_len;</span><br><span class="line">    int listenfd, connfd;</span><br><span class="line">    pthread_t tid;</span><br><span class="line"></span><br><span class="line">    struct s_info ts[256];								 //创建结构体数组</span><br><span class="line">    int i = 0;</span><br><span class="line">	</span><br><span class="line">    listenfd = Socket(AF_INET, SOCK_STREAM, 0);			//创建一个socket, 得到lfd  </span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, sizeof(servaddr));					//地址结构清零	</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);					//指定本地任意IP  </span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);				    //指定端口号   </span><br><span class="line"></span><br><span class="line">    Bind(listenfd, (struct sockaddr *) &amp;servaddr, sizeof(servaddr)); //绑定  	</span><br><span class="line"></span><br><span class="line">    Listen(listenfd, 128);		     //设置同一时刻链接服务器上限数  </span><br><span class="line"></span><br><span class="line">    printf(&quot;Accepting client connect ...\n&quot;);</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        cliaddr_len = sizeof(cliaddr);</span><br><span class="line">        connfd = Accept(listenfd, (struct sockaddr *) &amp;cliaddr, &amp;cliaddr_len); //阻塞监听客户端链接请求  </span><br><span class="line">        ts[i].cliaddr = cliaddr;</span><br><span class="line">        ts[i].connfd = connfd;</span><br><span class="line"></span><br><span class="line">        pthread_create(&amp;tid, NULL, do_work, (void *) &amp;ts[i]);//这里可以传地址是因为不会改变</span><br><span class="line">        pthread_detach(tid);			  //子线程分离,防止僵线程产生.  </span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	</p>
<h2 id="C语言C-中assert的用法"><a href="#C语言C-中assert的用法" class="headerlink" title="C语言C++中assert的用法"></a>C语言C++中assert的用法</h2><p><code>void assert(int expression);</code></p>
<p>assert宏的原型定义在&lt;assert.h&gt;中，其作用是先计算表达式expression的值为假(即为0),那么它就先向stderr打印一条出错信息，然后通过条用abort来终止程序；</p>
<p>使用assert的缺点是，频繁的调用会极大的影响程序的性能，增加额外的开销。</p>
<p>在调试结束后，可以通过在包含#include 的语句之前插入 #define NDEBUG 来禁用assert调用，示例代码如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 #include </span><br><span class="line">2 #define NDEBUG </span><br><span class="line">3 #include</span><br></pre></td></tr></table></figure>

<p>根据提示我们很快就能定位到错误点，就在assert(i++)处；既然assert这么便于定位出错点，在工程中使用它就显得很有必要；但其也有一定的使用规则；</p>
<p>断言语句不会永远被执行，可以屏蔽也可以启用，这就要求assert不管是在屏蔽还是启用状态下都不能对我们本身代码有所影响，这样刚才我们在代码中使用的<code>assert(i++)</code>就不行，因为如果禁用了<code>assert</code>,那i++就不能执行；正确的做法应该是：<code>assert(i);i++;</code></p>
<h2 id="本地套接字和网络套接字比较"><a href="#本地套接字和网络套接字比较" class="headerlink" title="本地套接字和网络套接字比较"></a>本地套接字和网络套接字比较</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">本地套接字：</span><br><span class="line"></span><br><span class="line">	IPC： pipe、fifo、mmap、信号、本地套（domain）--- CS模型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	对比网络编程 TCP C/S模型， 注意以下几点：</span><br><span class="line"></span><br><span class="line">	1. int socket(int domain, int type, int protocol); 参数 domain：AF_INET --&gt; AF_UNIX/AF_LOCAL </span><br><span class="line">	</span><br><span class="line">							     type: SOCK_STREAM/SOCK_DGRAM  都可以。	</span><br><span class="line">	2. 地址结构：  sockaddr_in --&gt; sockaddr_un</span><br><span class="line"></span><br><span class="line">		struct sockaddr_in srv_addr; --&gt; struct sockaddr_un srv_adrr;</span><br><span class="line"></span><br><span class="line">		srv_addr.sin_family = AF_INET;  --&gt; srv_addr.sun_family = AF_UNIX;</span><br><span class="line">·</span><br><span class="line">		srv_addr.sin_port = htons(8888);    strcpy(srv_addr.sun_path, &quot;srv.socket&quot;)</span><br><span class="line"></span><br><span class="line">		srv_addr.sin_addr.s_addr = htonl(INADDR_ANY);			len = offsetof(struct sockaddr_un, sun_path) + strlen(&quot;srv.socket&quot;);//offsetof用于求结构体成员较首地址偏移，第一个是AF_UNIX，第二个是sun_path</span><br><span class="line">	</span><br><span class="line">		bind(fd, (struct sockaddr *)&amp;srv_addr, sizeof(srv_addr));  --&gt; 	bind(fd, (struct sockaddr *)&amp;srv_addr, len); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	3. bind()函数调用成功，会创建一个 socket。因此为保证bind成功，通常我们在 bind之前， 可以使用 unlink(&quot;srv.socket&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	4. 客户端不能依赖 “隐式绑定”。并且应该在通信建立过程中，创建且初始化2个地址结构：</span><br><span class="line"></span><br><span class="line">		1） client_addr --&gt; bind()</span><br><span class="line"></span><br><span class="line">		2)  server_addr --&gt; connect();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="本地套接字通信"><a href="#本地套接字通信" class="headerlink" title="本地套接字通信"></a>本地套接字通信</h3><p>服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;sys/socket.h&gt;  </span><br><span class="line">#include &lt;strings.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;ctype.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">#include &lt;sys/un.h&gt;  </span><br><span class="line">#include &lt;stddef.h&gt;  </span><br><span class="line">  </span><br><span class="line">#include &quot;wrap.h&quot;  </span><br><span class="line">  </span><br><span class="line">#define SERV_ADDR  &quot;serv.socket&quot;  //没有了IP和port，改成伪文件，实际是没有大小的</span><br><span class="line">  </span><br><span class="line">int main(void)  </span><br><span class="line">&#123;  </span><br><span class="line">    int lfd, cfd, len, size, i;  </span><br><span class="line">    struct sockaddr_un servaddr, cliaddr;  </span><br><span class="line">    char buf[4096];  </span><br><span class="line">  </span><br><span class="line">    lfd = Socket(AF_UNIX, SOCK_STREAM, 0);  </span><br><span class="line">  </span><br><span class="line">    bzero(&amp;servaddr, sizeof(servaddr));  </span><br><span class="line">    servaddr.sun_family = AF_UNIX;  </span><br><span class="line">    strcpy(servaddr.sun_path, SERV_ADDR);  </span><br><span class="line">  </span><br><span class="line">    len = offsetof(struct sockaddr_un, sun_path) + strlen(servaddr.sun_path);     /* servaddr total len */  </span><br><span class="line">  </span><br><span class="line">    unlink(SERV_ADDR);                              /* 确保bind之前serv.sock文件不存在,bind会创建该文件 */  </span><br><span class="line">    Bind(lfd, (struct sockaddr *)&amp;servaddr, len);           /* 参3不能是sizeof(servaddr) */  </span><br><span class="line">  </span><br><span class="line">    Listen(lfd, 20);  </span><br><span class="line">  </span><br><span class="line">    printf(&quot;Accept ...\n&quot;);  </span><br><span class="line">    while (1) &#123;  </span><br><span class="line">        len = sizeof(cliaddr);  //AF_UNIX大小+108B  </span><br><span class="line">  </span><br><span class="line">        cfd = Accept(lfd, (struct sockaddr *)&amp;cliaddr, (socklen_t *)&amp;len);  </span><br><span class="line">  </span><br><span class="line">        len -= offsetof(struct sockaddr_un, sun_path);      /* 得到文件名的长度 */  </span><br><span class="line">        cliaddr.sun_path[len] = &#x27;\0&#x27;;                       /* 确保打印时,没有乱码出现 */  </span><br><span class="line">  </span><br><span class="line">        printf(&quot;client bind filename %s\n&quot;, cliaddr.sun_path);  </span><br><span class="line">  </span><br><span class="line">        while ((size = read(cfd, buf, sizeof(buf))) &gt; 0) &#123;  </span><br><span class="line">            for (i = 0; i &lt; size; i++)  </span><br><span class="line">                buf[i] = toupper(buf[i]);  </span><br><span class="line">            write(cfd, buf, size);  </span><br><span class="line">        &#125;  </span><br><span class="line">        close(cfd);  </span><br><span class="line">    &#125;  </span><br><span class="line">    close(lfd);  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;sys/types.h&gt;           </span><br><span class="line">#include &lt;sys/socket.h&gt;  </span><br><span class="line">#include &lt;strings.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;ctype.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">#include &lt;sys/un.h&gt;  </span><br><span class="line">#include &lt;stddef.h&gt;  </span><br><span class="line">  </span><br><span class="line">#include &quot;wrap.h&quot;  </span><br><span class="line">  </span><br><span class="line">#define SERV_ADDR &quot;serv.socket&quot;  </span><br><span class="line">#define CLIE_ADDR &quot;clie.socket&quot;  </span><br><span class="line">  </span><br><span class="line">int main(void)  </span><br><span class="line">&#123;  </span><br><span class="line">    int  cfd, len;  </span><br><span class="line">    struct sockaddr_un servaddr, cliaddr;  </span><br><span class="line">    char buf[4096];  </span><br><span class="line">  </span><br><span class="line">    cfd = Socket(AF_UNIX, SOCK_STREAM, 0);  </span><br><span class="line">  </span><br><span class="line">    bzero(&amp;cliaddr, sizeof(cliaddr));  </span><br><span class="line">    cliaddr.sun_family = AF_UNIX;  </span><br><span class="line">    strcpy(cliaddr.sun_path,CLIE_ADDR);  </span><br><span class="line">  </span><br><span class="line">    len = offsetof(struct sockaddr_un, sun_path) + strlen(cliaddr.sun_path);     /* 计算客户端地址结构有效长度 */  </span><br><span class="line">  </span><br><span class="line">    unlink(CLIE_ADDR);  </span><br><span class="line">    Bind(cfd, (struct sockaddr *)&amp;cliaddr, len);                                 /* 客户端也需要bind, 不能依赖自动绑定*/  </span><br><span class="line">  </span><br><span class="line">      </span><br><span class="line">    bzero(&amp;servaddr, sizeof(servaddr));                                          /* 构造server 地址 */  </span><br><span class="line">    servaddr.sun_family = AF_UNIX;  </span><br><span class="line">    strcpy(servaddr.sun_path, SERV_ADDR);  </span><br><span class="line">  </span><br><span class="line">    len = offsetof(struct sockaddr_un, sun_path) + strlen(servaddr.sun_path);   /* 计算服务器端地址结构有效长度 */  </span><br><span class="line">  </span><br><span class="line">    Connect(cfd, (struct sockaddr *)&amp;servaddr, len);  </span><br><span class="line">  </span><br><span class="line">    while (fgets(buf, sizeof(buf), stdin) != NULL) &#123;  </span><br><span class="line">        write(cfd, buf, strlen(buf));  </span><br><span class="line">        len = read(cfd, buf, sizeof(buf));  </span><br><span class="line">        write(STDOUT_FILENO, buf, len);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    close(cfd);  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="对比本地套接字和网络套接字"><a href="#对比本地套接字和网络套接字" class="headerlink" title="对比本地套接字和网络套接字"></a>对比本地套接字和网络套接字</h3><p><img src="/Linux-socket/image-20230715144754541.png" alt="image-20230715144754541"></p>
<img src="/2023/07/07/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux-socket/image-20230715144754541.png" class title="This is an test image">

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/07/06/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" rel="prev" title="Linux-网络基础">
      <i class="fa fa-chevron-left"></i> Linux-网络基础
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/07/07/%E4%B9%A6%E7%B1%8D%E7%9A%84%E9%98%85%E8%AF%BB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/" rel="next" title="深入理解计算机系统-第七章-链接">
      深入理解计算机系统-第七章-链接 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="nav-number">1.</span> <span class="nav-text">网络字节序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IP%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="nav-number">2.</span> <span class="nav-text">IP地址转换函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sockaddr%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="nav-number">3.</span> <span class="nav-text">sockaddr地址结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#socket%E5%92%8Cbind"><span class="nav-number">3.1.</span> <span class="nav-text">socket和bind</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#listen%E5%92%8Caccept"><span class="nav-number">3.2.</span> <span class="nav-text">listen和accept</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#connect"><span class="nav-number">3.3.</span> <span class="nav-text">connect</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CS%E6%A8%A1%E5%9E%8B%E7%9A%84TCP%E9%80%9A%E4%BF%A1%E5%88%86%E6%9E%90"><span class="nav-number">4.</span> <span class="nav-text">CS模型的TCP通信分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#server%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.</span> <span class="nav-text">server的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="nav-number">5.1.</span> <span class="nav-text">获取客户端地址结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#client%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.</span> <span class="nav-text">client的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E7%9A%84%E5%B0%81%E8%A3%85%E6%80%9D%E8%B7%AF"><span class="nav-number">7.</span> <span class="nav-text">错误处理函数的封装思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E5%92%8CUDP%E9%80%9A%E4%BF%A1%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">8.</span> <span class="nav-text">TCP和UDP通信优缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP%E9%80%9A%E4%BF%A1server%E5%92%8Cclient%E6%B5%81%E7%A8%8B"><span class="nav-number">9.</span> <span class="nav-text">UDP通信server和client流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#recvfrom%E5%92%8Csendto%E5%87%BD%E6%95%B0"><span class="nav-number">9.1.</span> <span class="nav-text">recvfrom和sendto函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UDP%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">9.2.</span> <span class="nav-text">UDP实现的并发服务器和客户端</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90"><span class="nav-number">10.</span> <span class="nav-text">多进程并发服务器思路分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="nav-number">10.1.</span> <span class="nav-text">多进程并发服务器实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E4%B8%8A%E4%BC%A0%E5%A4%96%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B9%B6%E8%AE%BF%E9%97%AE"><span class="nav-number">10.2.</span> <span class="nav-text">服务器程序上传外网服务器并访问</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%A0%81review"><span class="nav-number">11.</span> <span class="nav-text">多线程服务器代码review</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C%E8%AF%AD%E8%A8%80C-%E4%B8%ADassert%E7%9A%84%E7%94%A8%E6%B3%95"><span class="nav-number">12.</span> <span class="nav-text">C语言C++中assert的用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E5%A5%97%E6%8E%A5%E5%AD%97%E5%92%8C%E7%BD%91%E7%BB%9C%E5%A5%97%E6%8E%A5%E5%AD%97%E6%AF%94%E8%BE%83"><span class="nav-number">13.</span> <span class="nav-text">本地套接字和网络套接字比较</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%9A%E4%BF%A1"><span class="nav-number">13.1.</span> <span class="nav-text">本地套接字通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94%E6%9C%AC%E5%9C%B0%E5%A5%97%E6%8E%A5%E5%AD%97%E5%92%8C%E7%BD%91%E7%BB%9C%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="nav-number">13.2.</span> <span class="nav-text">对比本地套接字和网络套接字</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">肖汇林</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">76</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">肖汇林</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
