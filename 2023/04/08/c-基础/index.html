<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="处理类型类型别名有两种方法可用于定义类型别名。传统的方法是使用关键字typedef: 123typedef double wages;&#x2F;&#x2F;wages是 double的同义词typedef wages base,*p;&#x2F;&#x2F;base是double的同义词,p是double*的同义词  新标准规定了一种新的方法，使用别名声明(alias declaration)来定义类型的别名: 1using SI &#x3D;">
<meta property="og:type" content="article">
<meta property="og:title" content="c++ 基础">
<meta property="og:url" content="http://example.com/2023/04/08/c-%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="肖汇林的博客">
<meta property="og:description" content="处理类型类型别名有两种方法可用于定义类型别名。传统的方法是使用关键字typedef: 123typedef double wages;&#x2F;&#x2F;wages是 double的同义词typedef wages base,*p;&#x2F;&#x2F;base是double的同义词,p是double*的同义词  新标准规定了一种新的方法，使用别名声明(alias declaration)来定义类型的别名: 1using SI &#x3D;">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-04-08T05:49:29.000Z">
<meta property="article:modified_time" content="2023-04-09T08:19:51.685Z">
<meta property="article:author" content="肖汇林">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2023/04/08/c-%E5%9F%BA%E7%A1%80/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>c++ 基础 | 肖汇林的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖汇林的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/08/c-%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          c++ 基础
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-08 13:49:29" itemprop="dateCreated datePublished" datetime="2023-04-08T13:49:29+08:00">2023-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-09 16:19:51" itemprop="dateModified" datetime="2023-04-09T16:19:51+08:00">2023-04-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h1><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>有两种方法可用于定义类型别名。传统的方法是使用关键字typedef:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef double wages;//wages是 double的同义词</span><br><span class="line"></span><br><span class="line">typedef wages base,*p;//base是double的同义词,p是double*的同义词</span><br></pre></td></tr></table></figure>

<p>新标准规定了一种新的方法，使用别名声明(alias declaration)来定义类型的别名:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using SI = Sales_item;/ /SI是sales_item的同义词</span><br></pre></td></tr></table></figure>

<p>这种方法用关键字using 作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。</p>
<p>例如以下声明中的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef long double DBL;</span><br><span class="line"></span><br><span class="line">我们引入了一个新的类型名称DBL，它是long double的别名，并且具有：</span><br><span class="line"></span><br><span class="line">typedef：存储类说明符</span><br><span class="line"></span><br><span class="line">long double：类型说明符</span><br><span class="line"></span><br><span class="line">DBL：声明符</span><br></pre></td></tr></table></figure>



<h3 id="指针、常量和类型别名"><a href="#指针、常量和类型别名" class="headerlink" title="指针、常量和类型别名"></a>指针、常量和类型别名</h3><p>如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。</p>
<p>例如下面的声明语句用到了类型pstring,它实际上是类型char*的别名:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef char *pstring;</span><br><span class="line">const pstring cstr = 0;// cstr是指向char的常量指针</span><br><span class="line">const pstring *ps;// ps是一个指针，它的对象是指向char的常量指针</span><br></pre></td></tr></table></figure>

<p>上述两条声明语句的基本数据类型都是const pstring，和过去一样，const是对给定类型的修饰。pstring 实际上是指向char的指针，因此，const pstring 就是指向char的常量指针，而非指向常量字符的指针。</p>
<p>遇到一条使用了类型别名的声明语句时，人们往往会错误地尝试把类型别名替换成它本来的样子，以理解该语句的含义:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const char *cstr =0;</span><br><span class="line">//是对const pstring cstr的错误理解</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再强调一遍:这种理解是错误的。声明语句中用到pstring时，其基本数据类型是指针。可是用 char重写了声明语句后，数据类型就变成了char，* 成为了声明符的一部分。这样改写的结果是，const char成了基本数据类型。前后两种声明含义截然不同，前者声明了一个指向char的常量指针,改写后的形式则声明了一个指向const char的指针。主要是看  * 具体跟谁。这里的区别在于，typedef出来的类型是看做一个单独的类型，而char <em>这种直接的写法中，char才是单独的类型，</em>需要看做是和p结合在一起，含义不同。</p>
<h2 id="类型说明符"><a href="#类型说明符" class="headerlink" title="类型说明符"></a>类型说明符</h2><p>编程时常常需要把表达式的值赋给变量，这就要求在声明变量的时候清楚地知道表达式的类型。然而要做到这一点并非那么容易，有时甚至根本做不到。为了解决这个问题，C++11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符（比如double）不同，auto让编译器通过初始值来推算变量的类型。显然，auto定义的变量必须有初始值:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//由val1和val2相加的结果可以推断出item的类型</span><br><span class="line">auto item = val1 + val2;// item初始化为vall和val2相加的结果</span><br></pre></td></tr></table></figure>

<p>此处编译器将根据vall和val2相加的结果来推断item的类型。如果val1和val2是类sales item的对象，则item的类型就是Sales_item;如果这两个变量的类型是double，则item的类型就是double，以此类推。</p>
<p>使用auto也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto i = 0, *p=&amp;i;//正确:i是整数、p是整型指针,auto代表int型</span><br><span class="line">auto sz = 0,pi = 3.14;//错误:sz和pi的类型不一致</span><br></pre></td></tr></table></figure>

<p>还可以将引用的类型设为auto，此时原来的初始化规则仍然适用:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto  &amp;g=ci;//g是一个整型常量引用，绑定到ci</span><br><span class="line">auto &amp;h=42;//错误:不能为非常量引用绑定字面值</span><br><span class="line">const auto &amp;j=42; //正确:可以为常量引用绑定字面值</span><br></pre></td></tr></table></figure>

<p>要在一条语句中定义多个变量，切记，符号&amp;和*只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto k=ci, &amp;l= i;//k是整数，1是整型引用</span><br><span class="line">auto &amp;m= ci, *p= &amp;ci;// m是对整型常量(const int)的引用，p是指向整型常量(const int)的指针</span><br><span class="line">//错误:i的类型是int而&amp;ci的类型是const int</span><br><span class="line">auto &amp;n= i, *p2= &amp;ci;//使用引用作为初始类型，初始值中的顶层const属性仍然保存,底层 const 的限制却不能被忽视。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层 const 资格，或者两个对象的数据类型必须能够转换，一般来说，非常量可以转化为常量，反之不行。</span><br></pre></td></tr></table></figure>



<h2 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h2><p>有时会遇到这种情况:希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。为了满足这一要求，C++11新标准引入了第二种类型说明符dec1type，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decltype(f()) sum = x; // sum的类型就是函数f的返回类型</span><br></pre></td></tr></table></figure>

<p>编译器并不实际调用函数f，而是使用当调用发生时f的返回值类型作为sum 的类型。换句话说，编译器为sum 指定的类型是什么呢?就是假如f被调用的话将会返回的那个类型。<br>decltype处理顶层const和引用的方式与auto有些许不同。如果 decltype使用的表达式是一个变量,则decltype返回该变量的类型(包括顶层const和引用在内):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const int ci= 0,&amp;cj=ci;</span><br><span class="line">decltype(ci) x= 0;//x的类型是const int</span><br><span class="line">decltype(cj) y= x;//y的类型是const int&amp;， y绑定到变量x</span><br><span class="line">decltype(cj） z;//错误:z是一个引用，必须初始化</span><br></pre></td></tr></table></figure>

<p>因为cj是一个引用，decltype(cj)的结果就是引用类型，因此作为引用的z必须被初始化。</p>
<p>需要指出的是，引用从来都作为其所指对象的同义词出现，只有用在decltype处是一个例外,作为返回值类型。</p>
<h3 id="decltype-和引用"><a href="#decltype-和引用" class="headerlink" title="decltype 和引用"></a>decltype 和引用</h3><p>如果 decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。如4.1.1节（第120页）将要介绍的，有些表达式将向decltype返回一个引用类型。一般来说当这种情况发生时,意味着该表达式的结果对象能作为一条赋值语句的左值:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// decltype的结果可以是引用类型</span><br><span class="line">int i = 42,*p= &amp;i, &amp;r=i;</span><br><span class="line">decltype(r + 0) b;//正确:加法的结果是int，因此b是一个(未初始化的)int</span><br><span class="line">decltype(*p) c;//错误:c是int&amp;，必须初始化</span><br></pre></td></tr></table></figure>

<p>因为r是一个引用，因此 decltype (r)的结果是引用类型。如果想让结果类型是r所指的类型，可以把r作为表达式的一部分，如r+0，显然这个表达式的结果将是一个具体值而非一个引用。</p>
<p>另一方面，如果表达式的内容是解引用操作，则 decltype 将得到引用类型。正如我们所熟悉的那样，解引用指针可以得到指针所指的对象，而且还能给这个对象赋值。因此，decltype(*p)的结果类型就是int&amp;，而非int。</p>
<p>如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型，切记:decltype ((variable))（注意是双层括号)的结果永远是引用，而decltype(variable)结果只有当variable本身就是一个引用时才是引用。</p>
<blockquote>
<p>赋值是会产生引用的一类典型表达式，<strong>引用的类型就是左值的类型</strong>。也就是说，如果 i 是 int，则表达式 i&#x3D;x 的类型是 int&amp;。根据这一特点，请指出下面的代码中每一个变量的类型和值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) c = a;</span><br><span class="line"><span class="keyword">decltype</span>(a = b) d = a;</span><br><span class="line">a <span class="type">int</span> <span class="number">3</span>；</span><br><span class="line">b <span class="type">int</span> <span class="number">4</span>；</span><br><span class="line">c <span class="type">int</span> <span class="number">3</span>；</span><br><span class="line">d <span class="type">int</span> &amp; <span class="number">3</span>。</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="自定义数据结构"><a href="#自定义数据结构" class="headerlink" title="自定义数据结构"></a>自定义数据结构</h1><h2 id="编写自己的头文件"><a href="#编写自己的头文件" class="headerlink" title="编写自己的头文件"></a>编写自己的头文件</h2><p>为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在头文件的名字应与类的名字一样。例如，库类型string在名为string的头文件中定义。又如,我们应该把Sales_data类定义在名为Sales_data.h的头文件中。</p>
<p>注意：头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明。</p>
<h3 id="预处理器概述"><a href="#预处理器概述" class="headerlink" title="预处理器概述"></a>预处理器概述</h3><p>C++程序还会用到的一项预处理功能是头文件保护符（header guard)，头文件保护符依赖于预处理变量(参见2.3.2节，第48页)。预处理变量有两种状态:已定义和未定义。#define指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义:#ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到#endif指令为止。<br>使用这些功能就能有效地防止重复包含的发生:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#ifndef SALES_DATA_H</span><br><span class="line">#define SALES_DATA_H</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">struct Sales_data &#123;</span><br><span class="line">	std::string bookNo;</span><br><span class="line">	unsigned units_sold = 0;</span><br><span class="line">	double revenue = 0.0;</span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h1 id="字符串、向量和数组"><a href="#字符串、向量和数组" class="headerlink" title="字符串、向量和数组"></a>字符串、向量和数组</h1><h2 id="命名空间的using声明"><a href="#命名空间的using声明" class="headerlink" title="命名空间的using声明"></a>命名空间的using声明</h2><p>头文件不应包含using声明</p>
<p>位于头文件的代码一般来说不应该使用using声明。这是因为头文件的内容会铂贝到所有引用它的文件中去，如果头文件里有某个using 声明,那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字,反而可能产生始料未及的名字冲突。</p>
<h3 id="使用getline读取一整行"><a href="#使用getline读取一整行" class="headerlink" title="使用getline读取一整行"></a>使用getline读取一整行</h3><p>有时我们希望能在最终得到的字符串中保留输入时的空白符，这时应该用getline函数代替原来的&gt;&gt;运算符。getline函数的参数是一个输入流和一个string对象，函数从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了)，然后把所读的内容存入到那个string对象中去(注意不存换行符)。getline只要一遇到换行符就结束读取操作并返回结果，哪怕输入的一开始就是换行符也是如此。如果输入真的一开始就是换行符，那么所得的结果是个空string。</p>
<p>和输入运算符一样，getline也会返回它的流参数。因此既然输入运算符能作为判断的条件，我们也能用getline的结果作为条件。例如，可以通过改写之前的程序让它一次输出一整行，而不再是每行输出一个词了:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while (getline(cin,line))</span><br><span class="line">	cout&lt;&lt; line &lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>注意：触发getline函数返回的那个换行符实际上被丢弃掉了,得到的string对象中并不包含该换行符。</p>
<h3 id="string-size-type类型"><a href="#string-size-type类型" class="headerlink" title="string:size_type类型"></a>string:size_type类型</h3><p>对于size函数来说，返回一个int或者返回一个 unsigned 似乎都是合情合理的。但其实size函数返回的是一个string: :size type类型的值，下面就对这种新的类型稍作解释。</p>
<p>尽管我们不太清楚string::size_type类型的细节，但有一点是肯定的:它是个<strong>无符号类型</strong>的值,而且能足够存放下任何string对象的大小所有用于存放string类的size函数返回值的变量，都应该是 string::size_type类型的。</p>
<p>在c++11标准中，允许编译器通过auto或者decltype来推断变量的类型:<br>auto len &#x3D; line.size();&#x2F;&#x2F; len的类型是string: :size_type</p>
<p>由于size函数返回的是一个无符号整型数，因此切记，如果在表达式中混用了带符号数和无符号数将可能产生意想不到的结果。例如，假设n是一个具有负值的int,则表达式s.size ()&lt;n的判断结果几乎肯定是true。这是因为负值n会自动地转换成一个比较大的无符号值。</p>
<p>注意：如果一条表达式中已经有了size()函数就不要再使用int了,这样可以避免混用int和unsigned可能带来的问题。</p>
<p>因为某些历史原因，也为了与C兼容,所以C++语言中的字符串字面值（如“hello”）并不是标准库类型string 的对象。切记，字符串字面值与string是不同的类型。</p>
<h4 id="建议-使用C-版本的C标准库头文件"><a href="#建议-使用C-版本的C标准库头文件" class="headerlink" title="建议:使用C++版本的C标准库头文件"></a>建议:使用C++版本的C标准库头文件</h4><p>C++标准库中除了定义C++语言特有的功能外，也兼容了C语言的标准库。C语言的头文件形如name.h,C+则将这些文件命名为cname。也就是去掉了.h后缀，而在文件名 name之前添加了字母c，这里的c表示这是一个属于C语言标准库的头文件。</p>
<p>因此，cctype头文件和ctype.h头文件的内容是一样的，只不过从命名规范上来讲更符合C++语言的要求。特别的,在名为cname的头文件中定义的名字从属于命名空间std，而定义在名为.h的头文件中的则不然。</p>
<p>一般来说，C++程序应该使用名为cname的头文件而不使用name.h的形式，标准库中的名字总能在命名空间std中找到。如果使用.h形式的头文件，程序员就不得不时刻牢记哪些是从C语言那儿继承过来的，哪些又是C++语言所独有的。</p>
<hr>
<p>新的例子不再是统计标点符号的个数了，假设我们想要把字符串改写为大写字母的形式。为了做到这一点可以使用标准库函数 toupper，该函数接收一个字符，然后输出其对应的大写形式。这样，为了把整个string对象转换成大写，只要对其中的每个字符调用toupper函数并将结果再赋给原字符就可以了:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s(&quot;Hello World!!!&quot;);</span><br><span class="line">//转换成大写形式。</span><br><span class="line">for (auto &amp;c :s)//对于s中的每个字符（注意:c是引用)</span><br><span class="line">	c= toupper(c);//c是一个引用，因此赋值语句将改变s中字符的值</span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>每次迭代时，变量c引用string对象s的下一个字符，赋值给c也就是在改变s中对应字符的值。因此当执行下面的语句时，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c= toupper(c);//c是一个引用，因此赋值语句将改变s中字符的值</span><br></pre></td></tr></table></figure>

<p>实际上改变了c绑定的字符的值。整个循环结束后, str 中的所有字符都变成了大写形式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">另一个例子是把s的第一个词改成大写形式:</span><br><span class="line">//依次处理s中的字符直至我们处理完全部字符或者遇到一个空白</span><br><span class="line">for (decltype(s.size()） index = 0;</span><br><span class="line">index != s.size () &amp;&amp; !isspace(s[index]); ++index)</span><br><span class="line">	s [index] = toupper (s[index]);//将当前字符改成大写形式</span><br></pre></td></tr></table></figure>

<p>使用下标时必须确保其在合理范围之内，也就是说，下标必须大于等于0而小于字符串的 size()的值。一种简便易行的方法是，总是设下标的类型为string::size_type，因为此类型是<strong>无符号数，可以确保下标不会小于0</strong>。此时，代码只需保证下标小于size()的值就可以了。</p>
<h2 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h2><p>vector能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，所以不存在包含引用的vector。除此之外，其他大多数（非引用）内置类型和类类型都可以构成vector对象，甚至组成vector的元素也可以是vector.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; V1 (10);//v1有10个元素，每个的值都是0</span><br><span class="line">vector&lt;int&gt; V2&#123;10&#125;;//v2有1个元素，该元素的值是10</span><br><span class="line">vector&lt;int&gt; V3(10,1); // v3有10个元素，每个的值都是1</span><br><span class="line">vector&lt;int&gt; v4&#123;10，1&#125;; // v4有2个元素，值分别是10和1</span><br></pre></td></tr></table></figure>

<p>另一方面，如果初始化时使用了花括号的形式但是提供的值又不能用来列表初始化，就要考虑用这样的值来构造vector对象了。例如，要想列表初始化一个含有string对象的vector对象，应该提供能赋给string对象的初值。此时不难区分到底是要列表初始化 vector对象的元素还是用给定的容量值来构造vector对象:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; v5&#123; &quot;hi&quot;&#125;;//列表初始化:v5有一个元素</span><br><span class="line">vector&lt;string&gt; v6(&quot;hi&quot;);//错误:不能使用字符串字面值构建vector对象</span><br><span class="line">vector&lt;string&gt; v7 &#123;10&#125;;//v7有10个默认初始化的元素</span><br><span class="line">vector&lt;string&gt; v8&#123;10,&quot;hi&quot;&#125;;// v8有10个值为&quot;hi&quot;的元素</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/04/07/%E7%AC%AC%E5%85%AD%E5%A4%A9-c/" rel="prev" title="第六天 c++">
      <i class="fa fa-chevron-left"></i> 第六天 c++
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/04/08/%E7%AC%AC%E4%B8%83%E5%A4%A9-c/" rel="next" title="第七天 c++">
      第七天 c++ <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">处理类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="nav-number">1.1.</span> <span class="nav-text">类型别名</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E3%80%81%E5%B8%B8%E9%87%8F%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="nav-number">1.1.1.</span> <span class="nav-text">指针、常量和类型别名</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="nav-number">1.2.</span> <span class="nav-text">类型说明符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#decltype%E7%B1%BB%E5%9E%8B%E6%8C%87%E7%A4%BA%E7%AC%A6"><span class="nav-number">1.3.</span> <span class="nav-text">decltype类型指示符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#decltype-%E5%92%8C%E5%BC%95%E7%94%A8"><span class="nav-number">1.3.1.</span> <span class="nav-text">decltype 和引用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">自定义数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-number">2.1.</span> <span class="nav-text">编写自己的头文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="nav-number">2.1.1.</span> <span class="nav-text">预处理器概述</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84"><span class="nav-number">3.</span> <span class="nav-text">字符串、向量和数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84using%E5%A3%B0%E6%98%8E"><span class="nav-number">3.1.</span> <span class="nav-text">命名空间的using声明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8getline%E8%AF%BB%E5%8F%96%E4%B8%80%E6%95%B4%E8%A1%8C"><span class="nav-number">3.1.1.</span> <span class="nav-text">使用getline读取一整行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#string-size-type%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.1.2.</span> <span class="nav-text">string:size_type类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%BA%E8%AE%AE-%E4%BD%BF%E7%94%A8C-%E7%89%88%E6%9C%AC%E7%9A%84C%E6%A0%87%E5%87%86%E5%BA%93%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">建议:使用C++版本的C标准库头文件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bvector"><span class="nav-number">3.2.</span> <span class="nav-text">标准库类型vector</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">肖汇林</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">肖汇林</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
