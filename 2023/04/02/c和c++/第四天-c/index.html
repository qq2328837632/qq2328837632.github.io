<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="C++对象模型和this指针成员变量和成员函数分开存储1234567891011121314151617181920Class Person&amp;#123;	int m_A; &#x2F;&#x2F;非静态成员变量 属于类的对象上	static int m_B;&#x2F;&#x2F;静态成员变量 不属于类对象上	void func()&amp;#123;&amp;#125;&#x2F;&#x2F;非静态成员函数 不属于类对象上,即test02测试空间没有包含  不属于类对象">
<meta property="og:type" content="article">
<meta property="og:title" content="第四天 c++">
<meta property="og:url" content="http://example.com/2023/04/02/c%E5%92%8Cc++/%E7%AC%AC%E5%9B%9B%E5%A4%A9-c/index.html">
<meta property="og:site_name" content="肖汇林的博客">
<meta property="og:description" content="C++对象模型和this指针成员变量和成员函数分开存储1234567891011121314151617181920Class Person&amp;#123;	int m_A; &#x2F;&#x2F;非静态成员变量 属于类的对象上	static int m_B;&#x2F;&#x2F;静态成员变量 不属于类对象上	void func()&amp;#123;&amp;#125;&#x2F;&#x2F;非静态成员函数 不属于类对象上,即test02测试空间没有包含  不属于类对象">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/04/02/c%E5%92%8Cc++/%E7%AC%AC%E5%9B%9B%E5%A4%A9-c/Users/86191/AppData/Roaming/Typora/typora-user-images/image-20230402164555514.png">
<meta property="og:image" content="http://example.com/2023/04/02/c%E5%92%8Cc++/%E7%AC%AC%E5%9B%9B%E5%A4%A9-c/Users/86191/AppData/Roaming/Typora/typora-user-images/image-20230402175305513.png">
<meta property="article:published_time" content="2023-04-02T02:18:27.000Z">
<meta property="article:modified_time" content="2023-07-25T14:36:57.599Z">
<meta property="article:author" content="肖汇林">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/04/02/c%E5%92%8Cc++/%E7%AC%AC%E5%9B%9B%E5%A4%A9-c/Users/86191/AppData/Roaming/Typora/typora-user-images/image-20230402164555514.png">

<link rel="canonical" href="http://example.com/2023/04/02/c%E5%92%8Cc++/%E7%AC%AC%E5%9B%9B%E5%A4%A9-c/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>第四天 c++ | 肖汇林的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖汇林的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/02/c%E5%92%8Cc++/%E7%AC%AC%E5%9B%9B%E5%A4%A9-c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          第四天 c++
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-02 10:18:27" itemprop="dateCreated datePublished" datetime="2023-04-02T10:18:27+08:00">2023-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-25 22:36:57" itemprop="dateModified" datetime="2023-07-25T22:36:57+08:00">2023-07-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="C-对象模型和this指针"><a href="#C-对象模型和this指针" class="headerlink" title="C++对象模型和this指针"></a>C++对象模型和this指针</h2><h3 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a>成员变量和成员函数分开存储</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Class Person&#123;</span><br><span class="line">	int m_A; //非静态成员变量 属于类的对象上</span><br><span class="line">	static int m_B;//静态成员变量 不属于类对象上</span><br><span class="line">	void func()&#123;&#125;//非静态成员函数 不属于类对象上,即test02测试空间没有包含  不属于类对象上</span><br><span class="line">	static void func2()&#123;&#125;//静态成员函数 不属于类对象上</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">int Person: :m_B = 0;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">Person p ;</span><br><span class="line">//空对象占用内存空间为:1</span><br><span class="line">//C++编译器会给每个空对象也分配一个字节空间，是为了区分空对象占内存的位置</span><br><span class="line">//每个空对象也应该有一个独一无二的内存地址</span><br><span class="line">cout &lt;&lt; &quot;size of p = &quot; &lt;&lt; sizeof(p) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test02()&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	cout &lt;&lt; &quot;size of p = &quot; &lt;&lt; sizeof(p) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码，如果有p1,p2,p3…</p>
<p>每一个调用都是调用同一块内存空间</p>
<h3 id="this指针概念"><a href="#this指针概念" class="headerlink" title="this指针概念"></a>this指针概念</h3><p>接上那么问题是:这—块代码是如何区分那个对象调用自己的呢?</p>
<p>C++通i过提供特殊的对象指针， this指针，解决上述问题。</p>
<p>this指针指向被调用的成员函数所属的对象。</p>
<p>this指针是隐含每一个非静态成员函数内的一种指针。</p>
<p>this指针不需要定义，直接使用即可。</p>
<p>静态函数没有this指针。因为静态函数不属于某个对象。</p>
<p>this指针指向的就是对象,通过*this解引用可以访问该对象本身</p>
<p><strong>this指针的用途</strong>:</p>
<p>当形参和成员变量同名时，可用this指针来区分。</p>
<p>在类的非静态成员函数中返回对象本身，可使用return *this。</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">	Person (int age)&#123;</span><br><span class="line">	this-&gt;age = age;//谁调用Person，this就指向谁，比如Person p1;则this指向p1</span><br><span class="line">	&#125;</span><br><span class="line">	Person&amp; PersonAddAge (Person &amp;p)&#123;//引用指向本身内存。不用引用就是拷贝了,而拷贝指向另一个内存</span><br><span class="line">	//不引用就会直接使用复制构造函数。因为*this这个对象会在函数结束后销毁</span><br><span class="line">	//引用可以让p2使用同一个内存，而*this指向的就是内存地址，所以不加&amp;后面的</span><br><span class="line">	//p2.PersonAddAge(p1).PersonAddAge(p1).PersonAddAge(pl);就和第一个调用的p2无关了</span><br><span class="line">	this-&gt;age += p.age;</span><br><span class="line">	//this指向p2的指针，而*this指向的就是p2这个对象本体</span><br><span class="line">	return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	int age;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">void test02 ()&#123;</span><br><span class="line">	Person p1(10) ;</span><br><span class="line">	Person p2(10);</span><br><span class="line">	//链式编程思想</span><br><span class="line">	p2.PersonAddAge(p1).PersonAddAge(p1). PersonAddAge(pl);//上面如果不加引用，则后面每次创建都是一个新的对象，则输出总是20</span><br><span class="line">	cout &lt;&lt; &quot;p2的年龄为:&quot;&lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h3><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p>
<p>如果用到this指针，需要加以判断保证代码的健壮性</p>
<p>this指针的本质是指针常量,指针的指向是不可以修改的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">	void showPersonAge()&#123;</span><br><span class="line">	//报错原因是因为传入的指针是为NULL</span><br><span class="line">		if (this == NULL)//保证代码健壮性</span><br><span class="line">		&#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; &quot;age = &quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;//当为null时，this空对象，报错</span><br><span class="line">		&#125;</span><br><span class="line">int age;</span><br><span class="line">&#125; ;</span><br><span class="line">void test()&#123;</span><br><span class="line">	Person *p=NULL;</span><br><span class="line">	p-&gt;showPersonAge();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h3><p>常函数:</p>
<p>成员函数后加const后我们称为这个函数为常函数</p>
<p>常函数内不可以修改成员属性</p>
<p>成员属性声明时加关键字mutable后，在常函数中依然可以修改</p>
<p>常对象:</p>
<p>声明对象前加const称该对象为常对象</p>
<p>常对象只能调用常函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Class Person&#123;</span><br><span class="line">public:</span><br><span class="line">	//this指针的本质是指针常量指针的指向是不可以修改的</span><br><span class="line">	// const Person * const this;</span><br><span class="line">	//在成员函数后面加const，修饰的是this指向，让指针指向的值也不可以修改</span><br><span class="line">	void showPerson() const</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;m_B=100; </span><br><span class="line">		//this-&gt;m_A = 100;</span><br><span class="line">		//this = NULL; //this指针不可以修改指针的指向的</span><br><span class="line">	&#125;</span><br><span class="line">	int m_A;</span><br><span class="line">	mutable int m_B;//特殊变量，即使在常函数中，也可以修改这个值</span><br><span class="line">&#125;;</span><br><span class="line">//常对象</span><br><span class="line">void test02 ()</span><br><span class="line">&#123;</span><br><span class="line">	const Person p;//在对象前加const，变为常对象</span><br><span class="line">	//p.m_A = 100;</span><br><span class="line">	p.m_B = 100; //m_B是特殊值，在常对象下也可以修改</span><br><span class="line">	//常对象只能调用常函数</span><br><span class="line">	p.showPerson () ;</span><br><span class="line">	//P.func ();//如果能调用，则可能会出现m_A被修改，其实是不能修改的。常对象不可以调用普通成员函数，因为普通成员函数可以修改属性,常对象可以修改静态变量的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><h3 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h3><p>在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>
<p>友元的目的就是让—个函数或者类访问另一个类中私有成员</p>
<p>友元的关键字为friend </p>
<p>友元的三种实现</p>
<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Building&#123;</span><br><span class="line">	//goodGay全局函数是 Building好朋友，可以访问Building中私有成员</span><br><span class="line">	//告诉编译器goodGay全局函数是Building类的好朋友，可以访问类中的私有内容</span><br><span class="line">	friend void goodGay(Building *building);</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">//全局函数</span><br><span class="line">void goodGay(Building *building)</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;&quot;好基友全局函数正在访问:&quot;&lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout&lt;&lt;&quot;好基友全局函数正在访问: &quot;&lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	Building building;</span><br><span class="line">	goodGay(&amp;building);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Building;</span><br><span class="line">class goodGay&#123;</span><br><span class="line">public:</span><br><span class="line">	goodGay();</span><br><span class="line">	void visit();</span><br><span class="line">private:</span><br><span class="line">	Building *building;</span><br><span class="line">&#125;;</span><br><span class="line">class Building&#123;</span><br><span class="line">	//告诉编译器goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span><br><span class="line">	friend class goodGay;</span><br><span class="line">public :</span><br><span class="line">	Building();</span><br><span class="line">public:</span><br><span class="line">	string m_sittingRoom;//客厅</span><br><span class="line">private:</span><br><span class="line">	string m_BedRoom; //卧室</span><br><span class="line">&#125;;</span><br><span class="line">Building : : Building()&#123;//类的定义可以在类外进行，所以以后文件太大时，声明在头文件中，定义在源文件中</span><br><span class="line">	this-&gt;m_sittingRoom =&quot;客厅&quot;;</span><br><span class="line">	this-&gt;m_BedRoom =&quot;卧室&quot;;</span><br><span class="line">&#125;</span><br><span class="line">goodGay : : goodGay ()&#123;</span><br><span class="line">	building = new Buildng;//创建一个堆区 </span><br><span class="line">&#125;</span><br><span class="line">void goodGay : : visit()&#123;</span><br><span class="line">	cout &lt;&lt;“好基友正在访问”&lt;&lt; building-&gt;m_sittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt;“好基友正在访问”&lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void teste1()&#123;</span><br><span class="line">	goodGay gg;</span><br><span class="line">	gg.visit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Building;</span><br><span class="line">class goodGay&#123;</span><br><span class="line">public:</span><br><span class="line">	goodGay();</span><br><span class="line">	void visit();//只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span><br><span class="line">	void visit2();</span><br><span class="line">private:</span><br><span class="line">	Building *building;</span><br><span class="line">&#125;;</span><br><span class="line">class Building&#123;</span><br><span class="line">	//告诉编译器goodGay类中的visit成员函数是Building类的好朋友，可以访问到Building类中私有内容</span><br><span class="line">	friend void goodGay::visit();</span><br><span class="line">public :</span><br><span class="line">	Building();</span><br><span class="line">public:</span><br><span class="line">	string m_sittingRoom;//客厅</span><br><span class="line">private:</span><br><span class="line">	string m_BedRoom; //卧室</span><br><span class="line">&#125;;</span><br><span class="line">Building : : Building()&#123;//类的定义可以在类外进行，所以以后文件太大时，声明在头文件中，定义在源文件中</span><br><span class="line">	this-&gt;m_sittingRoom =&quot;客厅&quot;;</span><br><span class="line">	this-&gt;m_BedRoom =&quot;卧室&quot;;</span><br><span class="line">&#125;</span><br><span class="line">goodGay : : goodGay ()&#123;</span><br><span class="line">	building = new Buildng;//创建一个堆区 </span><br><span class="line">&#125;</span><br><span class="line">void goodGay : : visit()&#123;</span><br><span class="line">	cout &lt;&lt;“好基友正在访问”&lt;&lt; building-&gt;m_sittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt;“好基友正在访问”&lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void goodGay : : visit2()&#123;</span><br><span class="line">	cout &lt;&lt;“好基友正在访问”&lt;&lt; building-&gt;m_sittingRoom &lt;&lt; endl;</span><br><span class="line">	//cout &lt;&lt;“好基友正在访问”&lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void teste1()&#123;</span><br><span class="line">	goodGay gg;</span><br><span class="line">	gg.visit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>运算符重载概念:对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>
<h3 id="加号运算符重载"><a href="#加号运算符重载" class="headerlink" title="加号运算符重载"></a>加号运算符重载</h3><p>作用:实现两个自定义数据类型相加的运算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">	person()&#123;&#125;;</span><br><span class="line">	person(int a, int b)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;m_A = a;</span><br><span class="line">		this-&gt;m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line">	//成员函数实现＋号运算符重载</span><br><span class="line">	Person operator+( const Person&amp; p)&#123;</span><br><span class="line">		Person temp;</span><br><span class="line">		temp.m_A = this-&gt;m_A + p.m_A;</span><br><span class="line">		temp.m_B = this-&gt;m_B + p.m_B;</span><br><span class="line">		return temp;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	int m_A;</span><br><span class="line">	int m_B;</span><br><span class="line">&#125;</span><br><span class="line">//全局函数实现+号运算符重载 </span><br><span class="line">//Person operator+( const Person &amp;p1, const Person &amp;p2)&#123;</span><br><span class="line">//	Person temp(0，0);</span><br><span class="line">//	temp.m_A = p1.m_A + p2.m_A;</span><br><span class="line">//	temp.m_B = p1.m_B +p2.m_B;</span><br><span class="line">//&#125;</span><br><span class="line">//运算符重载可以发生函数重载</span><br><span class="line">Person operator+(const Person&amp; p2， int val)</span><br><span class="line">&#123;</span><br><span class="line">	Person temp;</span><br><span class="line">	temp.m_A = p2.m_A + val;</span><br><span class="line">	temp.m_B = p2.m_B + val;</span><br><span class="line">	return temp;</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">	Person p1(10，10);</span><br><span class="line">	Person p2(20，20);</span><br><span class="line">	//成员函数方式</span><br><span class="line">	Person p3 = p2 +p1;//相当于p2.operaor+(p1)</span><br><span class="line">	cout &lt;&lt; &quot;mA: &quot; &lt;&lt;p3.m_A &lt;&lt; &quot; mB: &quot; &lt;&lt; p3.m_B &lt;&lt; endl;</span><br><span class="line">	Person p4 = p3 +10;//相当于operator+(p3,10)</span><br><span class="line">	cout &lt;&lt;“mA: &quot; &lt;&lt;p4.m_A &lt;&lt; &quot; mB : &quot;&lt;&lt; p4.m_B &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建了两个 <code>Person</code> 对象 <code>p1</code> 和 <code>p2</code>，分别初始化 <code>m_A</code> 和 <code>m_B</code> 的值。</li>
<li>使用成员函数方式重载的 <code>+</code> 运算符，将 <code>p1</code> 加到 <code>p2</code> 上，得到结果 <code>p3</code>，其中 <code>p3.m_A = p2.m_A + p1.m_A = 20 + 10 = 30</code>，<code>p3.m_B = p2.m_B + p1.m_B = 20 + 10 = 30</code>。</li>
<li>输出 <code>p3</code> 的结果，即 <code>mA: 30 mB: 30</code>。</li>
<li>使用全局函数方式重载的 <code>+</code> 运算符，将 <code>p3</code> 加上整数 <code>10</code>，得到结果 <code>p4</code>，其中 <code>p4.m_A = p3.m_A + 10 = 30 + 10 = 40</code>，<code>p4.m_B = p3.m_B + 10 = 30 + 10 = 40</code>。</li>
<li>输出 <code>p4</code> 的结果，即 <code>mA: 40 mB : 40</code>。</li>
</ul>
<p>总结1:对于内置的数据类型的表达式的的运算符是不可能改变的</p>
<p>总结2:不要滥用运算符重载</p>
<h3 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h3><p>作用:可以输出自定义数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">	friend ostream&amp; operator&lt;&lt;(ostream&amp; out，Person&amp; p);</span><br><span class="line">public:</span><br><span class="line">	Person(int a, int b)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;m_A = a;this-&gt;m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line">	//成员函数实现不了p &lt;&lt;cout不是我们想要的效果 </span><br><span class="line">	//void operator&lt;&lt;(Person&amp; p)&#123;</span><br><span class="line">	//&#125;</span><br><span class="line">private :</span><br><span class="line">	int m_A;</span><br><span class="line">	int m_B;</span><br><span class="line">&#125;;</span><br><span class="line">//全局函数实现左移重载</span><br><span class="line">//ostream对象只能有一个</span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; cout，Person&amp; p)&#123;</span><br><span class="line">	out &lt;&lt; &quot;a: &quot; &lt;&lt; p.m_A &lt;&lt; &quot; b:&quot; &lt;&lt; p.m_B;</span><br><span class="line">	return cout;</span><br><span class="line">&#125;</span><br><span class="line">void test() &#123;</span><br><span class="line">	Person p1(10，20);</span><br><span class="line">	cout &lt;&lt;p1 &lt;&lt; &quot;hello world&quot; &lt;&lt;endl;//链式编程,需要返回ostream&amp;,才可以接着后面运算</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:重载左移运算符配合友元可以实现输出自定义数据类型</p>
<h3 id="递增运算符重载"><a href="#递增运算符重载" class="headerlink" title="递增运算符重载"></a>递增运算符重载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class MyInteger &#123;</span><br><span class="line">	friend ostream&amp; operator&lt;&lt;(ostream&amp; out,MyInteger myint);</span><br><span class="line">public:</span><br><span class="line">	MyInteger() &#123;</span><br><span class="line">		m_Num = 0;</span><br><span class="line">	&#125;</span><br><span class="line">	//前置++</span><br><span class="line">	MyInteger&amp; operator++()</span><br><span class="line">	&#123;</span><br><span class="line">		//先++</span><br><span class="line">		m_Num++;</span><br><span class="line">		//再返回自身</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	//后置++</span><br><span class="line">	MyInteger operator++(int) &#123;</span><br><span class="line">		//先返回</span><br><span class="line">		MyInteger temp = *this;//记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++;</span><br><span class="line">		m_Num++;</span><br><span class="line">		return temp;//temp是临时变量，完了会释放，所以不会返回引用</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	int m_Num;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; out,MyInteger myint) &#123;</span><br><span class="line">	out &lt;&lt; myint.m_Num;</span><br><span class="line">	return out;</span><br><span class="line">&#125;</span><br><span class="line">//前置++ 先++ 再返回</span><br><span class="line">void test01() &#123;</span><br><span class="line">	MyInteger myInt;</span><br><span class="line">	cout&lt;&lt;(++myInt)++ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt;myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//后置++ 先返回 再++</span><br><span class="line">void test02() &#123;</span><br><span class="line">	MyInteger myInt;</span><br><span class="line">	cout &lt;&lt; myInt++ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	test01();</span><br><span class="line">	//test02();</span><br><span class="line">	system( &quot;pause&quot; );</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:前置递增返回引用，后置递增返回值</p>
<h3 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h3><p>C++编译器至少给一个类添加4个函数</p>
<ul>
<li>1.默认构造函数(无参，函数体为空)</li>
<li>⒉.默认析构函数(无参，函数体为空)</li>
<li>3.默认拷贝构造函数，对属性进行值拷贝</li>
<li>4.赋值运算符operator&#x3D;,对属性进行值拷贝</li>
</ul>
<p><strong>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">	Person( int age)&#123;</span><br><span class="line">	//将年龄数据开辟到堆区</span><br><span class="line">	m_Age = new int(age);</span><br><span class="line">	&#125;</span><br><span class="line">	//重载赋值运算符</span><br><span class="line">	person&amp; operator=(Person &amp;p)&#123;</span><br><span class="line">		if (m_Age != NULL)&#123;</span><br><span class="line">			delete m_Age;</span><br><span class="line">			m_Age = NULL;</span><br><span class="line">		&#125;</span><br><span class="line">		//编译器提供的代码是浅拷贝</span><br><span class="line">		// m_Age = p.m_Age;</span><br><span class="line">		//提供深拷贝解决浅拷贝的问题</span><br><span class="line">		m_Age = new int(*p.m_Age);</span><br><span class="line">		//返回自身,保证了下面能连等</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	~Person()&#123;</span><br><span class="line">		if (m_Age != NULL)&#123;</span><br><span class="line">			delete m_Age;</span><br><span class="line">			m_Age = NULL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//年龄的指针</span><br><span class="line">	int *m_Age;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()&#123;</span><br><span class="line">	Person p1 (18);</span><br><span class="line">	Person p2(20);</span><br><span class="line">	Person p3( 30);</span><br><span class="line"> 	p3=p2= p1;//赋值操作</span><br><span class="line">	cout &lt;&lt;&quot;p1的年龄为:&quot;&lt;&lt;*p1.m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;p2的年龄为:&quot; &lt;&lt;*p2.m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;p3的年龄为:&quot; &lt;&lt;*p3.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h3><p>作用:重载关系运算符，可以让两个<strong>自定义类型对象</strong>进行对比操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">	Person( string name，int age)&#123;</span><br><span class="line">		this-&gt;m_Name = name;</span><br><span class="line">		this-&gt;m_Age = age;</span><br><span class="line">	&#125;;</span><br><span class="line">	bool operator==(Person &amp; p)&#123;</span><br><span class="line">		if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)&#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	bool operator ! =( Person &amp; p)&#123;</span><br><span class="line">		if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)&#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	string m_Name;</span><br><span class="line">	int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	Person a(&quot;孙悟空&quot;，18);</span><br><span class="line">	Person b(&quot;孙悟空&quot;，18);</span><br><span class="line">	if ( a == b)</span><br><span class="line">	&#123;</span><br><span class="line">    	cout &lt;&lt; &quot;a和b相等”&quot;&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">    cout &lt;&lt; &quot;a和b不等”&quot;&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    if (a !=b)&#123;</span><br><span class="line">		cout &lt;&lt;&quot;a和b不相等&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		cout &lt;&lt; &quot;a和b相等”&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a>函数调用运算符重载</h3><p>函数调用运算符()也可以重载</p>
<p>由于重载后使用的方式非常像函数的调用，因此称为仿函数</p>
<p>仿函数没有固定写法，非常灵活</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class MyPrint&#123;</span><br><span class="line">public:</span><br><span class="line">	void operator()(string text)&#123;</span><br><span class="line">		cout &lt;&lt; text &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()&#123;</span><br><span class="line">	//重载的()操作符也称为仿函数</span><br><span class="line">	MyPrint myFunc;</span><br><span class="line">	myFunc( &quot;hello world&quot; ) ;</span><br><span class="line">&#125;</span><br><span class="line">class MyAdd&#123;</span><br><span class="line">public:</span><br><span class="line">	int operator()(int v1,int v2)&#123;</span><br><span class="line">		return v1 +v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test02()&#123;</span><br><span class="line">	MyAdd add;</span><br><span class="line">	int ret = add(10，10);</span><br><span class="line">	cout &lt;&lt; &quot;ret - &quot; &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">	//匿名对象调用</span><br><span class="line">	cout &lt;&lt;&quot;MyAdd()(100,100) = &quot; &lt;&lt; MyAdd() (100，100) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="继承的基本语法"><a href="#继承的基本语法" class="headerlink" title="继承的基本语法"></a>继承的基本语法</h3><p>继承的好处:减少重复代码</p>
<p>语法:class 	子类:	继承方式	父类</p>
<p>子类也称为派生类</p>
<p>父类也称为基类</p>
<h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p>继承的语法:class子类∶继承方式父类</p>
<p>继承方式一共有三种:</p>
<ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承</li>
</ul>
<p><img src="/2023/04/02/c%E5%92%8Cc++/%E7%AC%AC%E5%9B%9B%E5%A4%A9-c/Users\86191\AppData\Roaming\Typora\typora-user-images\image-20230402164555514.png" alt="image-20230402164555514"></p>
<p>保护权限和私有权限类外都访问不到。</p>
<h3 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Base&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_A;</span><br><span class="line">protected:</span><br><span class="line">	int m_B;</span><br><span class="line">private:</span><br><span class="line">	int m_c; //私有成员只是被隐藏了，但是还是会继承下去</span><br><span class="line">&#125;;</span><br><span class="line">//公共继承</span><br><span class="line">class Son :public Base&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_D;</span><br><span class="line">&#125;;</span><br><span class="line">void teste1()&#123;</span><br><span class="line">	cout &lt;&lt; &quot;sizeof Son = &quot; &lt;&lt; sizeof(Son)&lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论:父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p>
<h3 id="继承中构造和析构顺序"><a href="#继承中构造和析构顺序" class="headerlink" title="继承中构造和析构顺序"></a>继承中构造和析构顺序</h3><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p>
<p>问题:父类和子类的构造和析构顺序是谁先谁后?</p>
<p>总结:继承中先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p>
<h3 id="继承同名成员处理方式"><a href="#继承同名成员处理方式" class="headerlink" title="继承同名成员处理方式"></a>继承同名成员处理方式</h3><p>问题:当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢?</p>
<p>访问子类同名成员直接访问即可</p>
<p>访问父类同名成员需要加作用域</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">	Base()&#123;</span><br><span class="line">		m_A = 100;</span><br><span class="line">	&#125;</span><br><span class="line">	void func()&#123;</span><br><span class="line">		cout &lt;&lt;&quot;Base - func()调用”&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	void func(int a)&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Base - func ( int a)调用&quot;&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	int m_A;</span><br><span class="line">&#125;;</span><br><span class="line">class son : public Base &#123;</span><br><span class="line">public:</span><br><span class="line">	son()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A= 200;</span><br><span class="line">	&#125;</span><br><span class="line">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span><br><span class="line">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span><br><span class="line">	void func()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Son - func()调用&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	int m_A;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()&#123;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; &quot;Son下的m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;Base下的m_A = &quot; &lt;&lt; s.Base::m_A&lt;&lt; endl;</span><br><span class="line">	s.func();</span><br><span class="line">	s.Base::func();</span><br><span class="line">	s.Base::func(10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:<br>1.子类对象可以直接访问到子类中同名成员</p>
<p>2.子类对象加作用域可以访问到父类同名成员</p>
<p>3.当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</p>
<h3 id="继承同名静态成员处理方式"><a href="#继承同名静态成员处理方式" class="headerlink" title="继承同名静态成员处理方式"></a>继承同名静态成员处理方式</h3><p>问题:继承中同名的静态成员在子类对象上如何进行访问?</p>
<p>静态成员和非静态成员出现同名，处理方式—致</p>
<p>·访问子类同名成员直接访问即可</p>
<p>·访问父类同名成员需要加作用域</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">	static void func()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Base - static void func()&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static void func(int a)&#123;</span><br><span class="line">		cout &lt;&lt;&quot;Base - static void func( int a)&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	static int m_A;</span><br><span class="line">&#125;;</span><br><span class="line">int Base::m_A = 100;</span><br><span class="line">class Son : public Base&#123;</span><br><span class="line">public:</span><br><span class="line">	static void func()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Son - static void func()&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	static int m_A;</span><br><span class="line">&#125;;</span><br><span class="line">int Son::m_A = 200;</span><br><span class="line">//同名成员属性</span><br><span class="line">void test01()&#123;</span><br><span class="line">	//通过对象访问</span><br><span class="line">	cout &lt;&lt;“通过对象访问:&quot;&lt;&lt;endl;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; &quot;Son 下m_A =&quot; &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;Base 下m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line">	//通过类名访问</span><br><span class="line">	cout &lt;&lt;“通过类名访问:“ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;Son下m_A = &quot; &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">	cout&lt;&lt; &quot;Base 下m_A = &quot; &lt;&lt;Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//同名成员函数</span><br><span class="line">void test02()&#123;&#125;</span><br><span class="line">	//通过对象访问</span><br><span class="line">	cout &lt;&lt;“通过对象访问:“ &lt;&lt;endl;</span><br><span class="line">	Son s;</span><br><span class="line">	s.func();</span><br><span class="line">	s.Base::func( );</span><br><span class="line">	cout &lt;&lt;“通过类名访问:&quot; &lt;&lt; endl ;</span><br><span class="line">	Son::func();</span><br><span class="line">	son::Base::func();</span><br><span class="line">	//出现同名。子类会隐藏掉父类中所有同名成员函数，需要加作用域访问</span><br><span class="line">	Son::Base::func(100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式(通过对象和通过类名）</p>
<h3 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h3><p>C++允许一个类继承多个类</p>
<p>语法:	class	子类	∶	继承方式	父类1 ，继承方式	父类2…{};</p>
<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>
<p>C++实际开发中不建议用多继承</p>
<p>总结:多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p>
<p>在多继承中，派生类对于每个基类的访问级别（即继承方式）会影响成员的可访问性。C++ 中有三种基本的继承方式：<code>public</code>、<code>protected</code> 和 <code>private</code>。</p>
<ol>
<li><p><code>public</code> 继承：当派生类以 <code>public</code> 方式继承基类时，基类的公有成员仍然保持公有性，基类的保护成员仍然保持保护性，但对于外部代码来说，它们都通过派生类对象可直接访问。继承方式对于派生类内部和派生类外部的代码是一样的。基类的私有成员无法访问</p>
</li>
<li><p><code>protected</code> 继承：当派生类以 <code>protected</code> 方式继承基类时，基类的公有成员将变为派生类的受保护成员，无法通过派生类对象直接访问。而基类的保护成员仍然保持保护性，只能在派生类内部访问。这意味着，派生类的成员函数可以访问基类的保护成员，但派生类对象不能。基类的私有成员无法访问</p>
</li>
<li><p><code>private</code> 继承：当派生类以 <code>private</code> 方式继承基类时，基类的公有和保护成员都将变为派生类的私有成员，基类的私有成员无法访问，无法通过派生类对象直接访问。这意味着，派生类的成员函数可以访问基类的成员，但派生类对象不能。</p>
</li>
</ol>
<h3 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line">//继承前加virtual关键字后，变为虚继承//此时公共的父类Animal称为虚基类</span><br><span class="line">class sheep : virtual public Animal&#123;&#125;;</span><br><span class="line">class Tuo: virtual public Animal &#123;&#125;;</span><br><span class="line">class SheepTuo : public Sheep，public Tuo &#123;&#125;;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	sheepTuo st;</span><br><span class="line">	st.Sheep::m_Age = 100;</span><br><span class="line">	st.Tuo::m_Age = 200;//指向的是一样的地址，第二个是后改变的，用后面的数据</span><br><span class="line">	cout &lt;&lt; &quot;st.Sheep::m_Age = &quot;&lt;&lt; st.sheep:: m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;st.Tuo : :m_Age = &quot;&lt;&lt;st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;st.m_Age =&quot; &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:<br>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</p>
<p>利用虚继承可以解决菱形继承问题</p>
<p>虚继承底层原理：</p>
<p><img src="/2023/04/02/c%E5%92%8Cc++/%E7%AC%AC%E5%9B%9B%E5%A4%A9-c/Users\86191\AppData\Roaming\Typora\typora-user-images\image-20230402175305513.png" alt="image-20230402175305513"></p>
<p>vbptr相当于指针，指向一个虚基类表，表中记录了偏移量，指针加上偏移量，指向了唯一的数据。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/03/31/c%E5%92%8Cc++/%E7%AC%AC%E4%B8%89%E5%A4%A9-c/" rel="prev" title="第三天 c++">
      <i class="fa fa-chevron-left"></i> 第三天 c++
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/04/03/c%E5%92%8Cc++/%E7%AC%AC%E4%BA%94%E5%A4%A9-c/" rel="next" title="第五天 c++">
      第五天 c++ <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%92%8Cthis%E6%8C%87%E9%92%88"><span class="nav-number">1.</span> <span class="nav-text">C++对象模型和this指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%88%86%E5%BC%80%E5%AD%98%E5%82%A8"><span class="nav-number">1.1.</span> <span class="nav-text">成员变量和成员函数分开存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this%E6%8C%87%E9%92%88%E6%A6%82%E5%BF%B5"><span class="nav-number">1.2.</span> <span class="nav-text">this指针概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.</span> <span class="nav-text">空指针访问成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.</span> <span class="nav-text">const修饰成员函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8B%E5%85%83"><span class="nav-number">2.</span> <span class="nav-text">友元</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E5%81%9A%E5%8F%8B%E5%85%83"><span class="nav-number">2.1.</span> <span class="nav-text">全局函数做友元</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%81%9A%E5%8F%8B%E5%85%83"><span class="nav-number">2.2.</span> <span class="nav-text">类做友元</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%81%9A%E5%8F%8B%E5%85%83"><span class="nav-number">2.3.</span> <span class="nav-text">成员函数做友元</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">3.</span> <span class="nav-text">运算符重载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">3.1.</span> <span class="nav-text">加号运算符重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A6%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">3.2.</span> <span class="nav-text">左移运算符重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">3.3.</span> <span class="nav-text">递增运算符重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">3.4.</span> <span class="nav-text">赋值运算符重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">3.5.</span> <span class="nav-text">关系运算符重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">3.6.</span> <span class="nav-text">函数调用运算符重载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">4.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">4.1.</span> <span class="nav-text">继承的基本语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F"><span class="nav-number">4.2.</span> <span class="nav-text">继承方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.3.</span> <span class="nav-text">继承中的对象模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F"><span class="nav-number">4.4.</span> <span class="nav-text">继承中构造和析构顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">4.5.</span> <span class="nav-text">继承同名成员处理方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E5%90%8C%E5%90%8D%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">4.6.</span> <span class="nav-text">继承同名静态成员处理方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF%E8%AF%AD%E6%B3%95"><span class="nav-number">4.7.</span> <span class="nav-text">多继承语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF"><span class="nav-number">4.8.</span> <span class="nav-text">菱形继承</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">肖汇林</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">肖汇林</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
