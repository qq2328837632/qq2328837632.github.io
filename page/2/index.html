<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="选择有时候比努力更重要">
<meta property="og:type" content="website">
<meta property="og:title" content="肖汇林的博客">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="肖汇林的博客">
<meta property="og:description" content="选择有时候比努力更重要">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="肖汇林">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>肖汇林的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖汇林的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/07/c%E5%92%8Cc++/%E7%AC%AC%E5%85%AD%E5%A4%A9-c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/07/c%E5%92%8Cc++/%E7%AC%AC%E5%85%AD%E5%A4%A9-c/" class="post-title-link" itemprop="url">第六天 c++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-07 16:10:16" itemprop="dateCreated datePublished" datetime="2023-04-07T16:10:16+08:00">2023-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-08 20:01:43" itemprop="dateModified" datetime="2023-04-08T20:01:43+08:00">2023-04-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="函数模板语法"><a href="#函数模板语法" class="headerlink" title="函数模板语法"></a>函数模板语法</h2><p>函数模板作用:<br>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表。<br>语法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line"></span><br><span class="line">函数声明或定义</span><br></pre></td></tr></table></figure>

<p>解释:</p>
<p>template —声明创建模板Ⅰ</p>
<p>typename —表面其后面的符号是—种数据类型，可以用class代替T—通用的数据类型，名称可以替换，通常为大写字母</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//利用模板提供通用的交换函数</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void mySwap(T&amp; a，T&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	int a = 10;</span><br><span class="line">	int b = 20;</span><br><span class="line">	// swapInt(a，b);</span><br><span class="line">	//利用模板实现交换</span><br><span class="line">	//1、自动类型推导</span><br><span class="line">	mySwap(a，b);</span><br><span class="line">	//2、显示指定类型</span><br><span class="line">	mySwap&lt;int&gt;(a，b);</span><br><span class="line">	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout&lt;&lt; &quot; b = &quot;&lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:</p>
<ul>
<li>函数模板利用关键字template</li>
<li>使用函数模板有两种方式:自动类型推导、显示指定类型</li>
<li>模板的目的是为了提高复用性，将类型参数化</li>
<li>使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型</li>
</ul>
<p>普通函数与函数模板区别:</p>
<ul>
<li>普通函数调用时可以发生自动类型转换(隐式类型转换)</li>
<li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li>
<li>如果利用显示指定类型的方式，可以发生隐式类型转换</li>
</ul>
<p>总结:建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T。</p>
<h2 id="普通函数与函数模板的调用规则"><a href="#普通函数与函数模板的调用规则" class="headerlink" title="普通函数与函数模板的调用规则"></a>普通函数与函数模板的调用规则</h2><p>调用规则如下:</p>
<p>1.如果函数模板和普通函数都可以实现，优先调用普通函数</p>
<p>2.可以通过空模板参数列表来强制调用函数模板</p>
<p>3.函数模板也可以发生重载</p>
<p>4.如果函数模板可以产生更好的匹配,优先调用函数模板</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//普通函数与函数模板调用规则</span><br><span class="line">void myPrint(int a, int b)&#123;</span><br><span class="line">	cout &lt;&lt;&quot;调用的普通函数”&quot;&lt;&lt;endl;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void myPrint(T a， T b)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt;“调用的模板&quot;&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void myPrint(T a， T b， T c)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt;&quot;调用重载的模板&quot;&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">    //1、如果函数模板和普通函数都可以实现，优先调用普通函数</span><br><span class="line">    //注意如果告诉编译器普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到</span><br><span class="line">    int a = 10;</span><br><span class="line">    int b = 20;</span><br><span class="line">    myPrint(a，b);//调用普通函数</span><br><span class="line">    //2、可以通过空模板参数列表&lt;&gt;来强制调用函数模板</span><br><span class="line">    myPrint&lt;&gt;(a, b);//调用函数模板</span><br><span class="line">    //3、函数模板也可以发生重载</span><br><span class="line">    int c = 30;</span><br><span class="line">    myprint(a,b, c);//调用重载的函数模板</span><br><span class="line">    //4、如果函数模板可以产生更好的匹配,优先调用函数模板</span><br><span class="line">    char c1 = &#x27;a&#x27;;</span><br><span class="line">    char c2 = &#x27;b&#x27;;</span><br><span class="line">    myPrint(c1，c2);//调用函数模板</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:</p>
<p>既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性。</p>
<h2 id="模板的局限性"><a href="#模板的局限性" class="headerlink" title="模板的局限性"></a>模板的局限性</h2><p>局限性:</p>
<p>模板的通用性并不是万能的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">void f(T a，T b)</span><br><span class="line">&#123;</span><br><span class="line">    if(a &gt; b) </span><br><span class="line">    &#123; .. &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行</p>
<p>因此C++为了解决这种问题，提供模板的重载，可以为这些特定的类型提供具体化的模板</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">	Person( string name，int age)&#123;</span><br><span class="line">	this- &gt;m_Name I name;</span><br><span class="line">	this-&gt;m_Age - age;</span><br><span class="line">	&#125;</span><br><span class="line">string m_Name;</span><br><span class="line">int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line">//普通函数模板</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">bool myCompare(T&amp; a，T&amp; b)&#123;</span><br><span class="line">	if (a == b)&#123;</span><br><span class="line">	return true;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">	return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型</span><br><span class="line">//具体化优先于常规模板</span><br><span class="line">template&lt;&gt; bool myCompare(Person &amp;p1，Person &amp;p2)</span><br><span class="line">&#123;</span><br><span class="line">	if ( p1.m_Name == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age)&#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">	return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; 	</span><br><span class="line">void test01()&#123;</span><br><span class="line">	int a - 10;</span><br><span class="line">	int b = 20;</span><br><span class="line">	//内置数据类型可以直接使用通用的函数模板</span><br><span class="line">	bool ret = myCompare(a， b);</span><br><span class="line">	if (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;a == b &quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;a != b &quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:</p>
<ul>
<li>利用具体化的模板，可以解决由定义类型的通用化</li>
<li>学习模板并不是为了写模板，而是在STL能够运用系统提供的模板</li>
</ul>
<h2 id="类模板语法"><a href="#类模板语法" class="headerlink" title="类模板语法"></a>类模板语法</h2><p>类模板作用:<br>    建立一个通用类，类中的成员数据类型可以不具体制定，用一个虚拟的类型来代表。<br>语法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">类</span><br></pre></td></tr></table></figure>

<p>解释:</p>
<p>template —声明创建模板</p>
<p>typename —表面其后面的符号是一种数据类型，可以用class代替</p>
<p>T —通用的数据类型，名称可以替换，通常为大写字母</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class NameType,class AgeType&gt;</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Person(NameType name，AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">	this- &gt;mName = name;</span><br><span class="line">	this-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	void showPerson()&#123;</span><br><span class="line">	cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	//指定NameType 为string类型，AgeType 为int类型</span><br><span class="line">	Person&lt;string, int&gt;P1(&quot;孙悟空&quot;,999);</span><br><span class="line">	p1.showPerson( );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类模板与函数模板区别"><a href="#类模板与函数模板区别" class="headerlink" title="类模板与函数模板区别"></a>类模板与函数模板区别</h2><p>类模板与函数模板区别主要有两点:</p>
<p>1.类模板没有自动类型推导的使用方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//1、类模板没有自动类型推导的使用方式</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	// Person p(&quot;孙悟空&quot;,1000); //错误类模板使用时候，不可以用自动类型推导</span><br><span class="line">	Person &lt;string ,int&gt;p(&quot;孙悟空&quot;，1000);//必须使用显示指定类型的方式，使用类模板</span><br><span class="line">	p.showPerson();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⒉类模板在模板参数列表中可以有默认参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//2、类模板在模板参数列表中可以有默认参数</span><br><span class="line">void test02()&#123;</span><br><span class="line">    Person &lt;string&gt; p(&quot;猪八戒&quot;, 999);//类模板中的模板参数列表可以指定默认参数template&lt;class //NameType,class AgeType=int&gt;</span><br><span class="line">    p.showPerson( ) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:</p>
<ul>
<li>类模板使用只能用显示指定类型方式</li>
<li>类模板中的模板参数列表可以有默认参数</li>
</ul>
<h2 id="类模板对象做函数参数"><a href="#类模板对象做函数参数" class="headerlink" title="类模板对象做函数参数"></a>类模板对象做函数参数</h2><p>学习目标:</p>
<p>类模板实例化出的对象，向函数传参的方式</p>
<p>—共有三种传入方式:</p>
<p>​	1.指定传入的类型	—直接显示对象的数据类型</p>
<p>​	2.参数模板化	—将对象中的参数变为模板进行传递</p>
<p>​	3.整个类模板化	—将这个对象类型模板化进行传递</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class NameType,class AgeType=int&gt;</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Person(NameType name，AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">	this- &gt;mName = name;</span><br><span class="line">	this-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	void showPerson()&#123;</span><br><span class="line">	cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line">//1、指定传入的类型</span><br><span class="line">void PrintPerson1( Person&lt;string， int&gt; &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">	p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	person &lt;string， int &gt;p(&quot;孙悟空&quot;，100);</span><br><span class="line">	printPerson1(p);</span><br><span class="line">&#125;</span><br><span class="line">//2、参数模板化</span><br><span class="line">template &lt;class T1，class T2&gt;</span><br><span class="line">void printPerson2(Person&lt;T1，T2&gt;&amp;p)</span><br><span class="line">&#123;</span><br><span class="line">	p.showPerson();</span><br><span class="line">	cout &lt;&lt;&quot;T1的类型为:“ &lt;&lt; typeid(T1).name() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt;&quot;T2的类型为:“ &lt;&lt; typeid(T2).name() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">	Person &lt;string, int &gt;p(&quot;猪八戒&quot;，90);</span><br><span class="line">	printPerson2(p);</span><br><span class="line">&#125;</span><br><span class="line">//3、整个类模板化</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void printPerson3(T &amp; p)(</span><br><span class="line">	cout &lt;&lt;&quot;T的类型为:“ &lt;&lt; typeid(T).name() &lt;&lt; endl;</span><br><span class="line">	p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line">void test03()&#123;</span><br><span class="line">	Person &lt;string, int &gt;p(“唐借&quot;，30);</span><br><span class="line">	printPerson3(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:</p>
<ul>
<li>通过类模板创建的对象，可以有三种方式向函数中进行传参</li>
<li>使用比较广泛是第一种:指定传入的类型</li>
</ul>
<h2 id="类模板与继承"><a href="#类模板与继承" class="headerlink" title="类模板与继承"></a>类模板与继承</h2><p>当类模板碰到继承时，需要注意一下几点:</p>
<ul>
<li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</li>
<li>如果不指定，编译器无法给子类分配内存</li>
<li>如果想灵活指定出父类中T的类型，子类也需变为类模板</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">	T m;</span><br><span class="line">&#125;;</span><br><span class="line">//class Son: public Base//错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承</span><br><span class="line">class Son :public Base&lt;int&gt;//必须指定一个类型</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()&#123;</span><br><span class="line">	son c;</span><br><span class="line">&#125;</span><br><span class="line">//类模板继承类模板,可以用T2指定父类中的T类型</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class Son2 :public Base&lt;T2&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Son2()&#123;</span><br><span class="line">	cout &lt;&lt; typeid(T1).name() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; typeid(T2).name() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test02()&#123;</span><br><span class="line">	Son2&lt;int, char&gt; child1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:如果父类是类模板，子类需要指定出父类中T的数据类型</p>
<h2 id="类模板成员函数类外实现"><a href="#类模板成员函数类外实现" class="headerlink" title="类模板成员函数类外实现"></a>类模板成员函数类外实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//类模板中成员函数类外实现</span><br><span class="line">template&lt;class T1，class T2&gt;</span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">	//成员函数类内声明</span><br><span class="line">	Person(T1 name，T2 age);</span><br><span class="line">	void showPerson();</span><br><span class="line">public:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line">//构造函数类外实现</span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">Person&lt;T1，T2&gt; : : Person(T1 name，T2 age) &#123;</span><br><span class="line">	this-&gt;m_Name = name;</span><br><span class="line">	this-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line">//成员函数类外实现</span><br><span class="line">template&lt;class T1，class T2&gt;</span><br><span class="line">void Person&lt;T1，T2&gt; : : showPerson( ) &#123;</span><br><span class="line">	cout &lt;&lt;“姓名:&quot;&lt;&lt; this-&gt;m_Name &lt;&lt;”年龄:&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test01()&#123;</span><br><span class="line">	Person&lt;string, int&gt; p(&quot;Tom&quot;,20);</span><br><span class="line">	p.showPerson();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类模板分文件编写"><a href="#类模板分文件编写" class="headerlink" title="类模板分文件编写"></a>类模板分文件编写</h2><p>问题:</p>
<ul>
<li>类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</li>
</ul>
<p>解决:</p>
<ul>
<li>解决方式1:直接包含.cpp源文件</li>
<li>解决方式2∶将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制</li>
</ul>
<p>person.hpp中代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">	Person(T1 name，T2 age);</span><br><span class="line">	void showPerson();</span><br><span class="line">public:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line">//构造函数类外实现</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">Person&lt;T1，T2&gt; : :Person(T1 name，T2 age) &#123;</span><br><span class="line">	this-&gt;m_Name = name;</span><br><span class="line">	this-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line">//成员函数类外实现</span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">void Person&lt;T1，T2&gt; : : showPerson() &#123;</span><br><span class="line">	cout &lt;&lt;“姓名;&quot;&lt;&lt; this-&gt;m_Name &lt;&lt;”年龄:&quot;&lt;&lt; this-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类模板分文件编写.cpp中代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iosiream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//#include &quot;person.h&quot;</span><br><span class="line">#include &quot;person.cpp”//解决方式1，包含cpp源文件</span><br><span class="line">//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp</span><br><span class="line">#include &quot;person.hpp&quot;</span><br><span class="line">void teste1()</span><br><span class="line">&#123;</span><br><span class="line">	Person&lt;string, int&gt; p( Tom&quot;，10);</span><br><span class="line">	p.showPerson( );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp</p>
<h2 id="类模板与友元"><a href="#类模板与友元" class="headerlink" title="类模板与友元"></a>类模板与友元</h2><p>学习目标:</p>
<ul>
<li>掌握类模板配合友元函数的类内和类外实现</li>
<li>全局函数类内实现-直接在类内声明友元即可</li>
<li>全局函数类外实现–需要提前让编译器知道全局函数的存在</li>
</ul>
<p>成员函数加friend变为全局函数,可在全局作用于该类对象.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//2、全局函数配合友元类外实现–先做函数模板声明，下方在做函数模板定义，在做友元</span><br><span class="line">template&lt;class T1,class T2&gt; </span><br><span class="line">class Person;</span><br><span class="line">//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到</span><br><span class="line">//template&lt;class T1，class T2&gt; void printPerson2(Person&lt;T1，T2&gt;&amp; p);</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">void printPerson2( Person&lt;T1，T2&gt;&amp; p)&#123;</span><br><span class="line">	cout &lt;&lt;&quot;类外实现----姓名: &quot; &lt;&lt; p.m_Name &lt;&lt;”年龄:&quot;&lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">	//1、全局函数配合友元类内实现</span><br><span class="line">	friend void printPerson(Person&lt;T1，T2&gt; &amp;p)</span><br><span class="line">		cout &lt;&lt;&quot;姓名:&quot;&lt;&lt; p.m_Name &lt;&lt;”年龄:”&lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">	//全局函数配合友元类外实现</span><br><span class="line">	friend void printPerson2&lt;&gt;(Person&lt;T1，T2&gt; &amp; p);</span><br><span class="line">public:</span><br><span class="line">	Person( T1 name，T2 age)&#123;</span><br><span class="line">		this-&gt;m_Name = name;</span><br><span class="line">		this-&gt;m_Age -l age;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line">//1、全局函数在类内实现</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	Person &lt;string， int &gt;p( &quot;Tom&quot;，20);</span><br><span class="line">	printPerson(p);</span><br><span class="line">&#125;</span><br><span class="line">//2、全局函数在类外实现</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">	Person &lt;string, int &gt;p(&quot;Jerry&quot; , 30);</span><br><span class="line">	printPerson2(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:建议全局函数做类内实现，用法简单，而且编译器可以直接识别</p>
<h2 id="类模板案例"><a href="#类模板案例" class="headerlink" title="类模板案例"></a>类模板案例</h2><p>案例描述:实现一个通用的数组类，要求如下:</p>
<ul>
<li>可以对内置数据类型以及自定义数据类型的数据进行存储</li>
<li>将数组中的数据存储到堆区</li>
<li>构造函数中可以传入数组的容量</li>
<li>提供对应的拷贝构造函数以及operator&#x3D;防止浅拷贝问题</li>
<li>提供尾插法和尾删法对数组中的数据进行增加和删除</li>
<li>可以通过下标的方式访问数组中的元素</li>
<li>可以获取数组中当前元素个数和数组的容量</li>
</ul>
<p>myArray.hpp中代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class MyArray&#123;</span><br><span class="line">public:</span><br><span class="line">	//构造函数</span><br><span class="line">	MyArray(int capacity)&#123;</span><br><span class="line">		this-&gt;m_Capacity = capacity;</span><br><span class="line">		this-&gt;m_size = 0;</span><br><span class="line">		pAddress = new T[this-&gt;m_Capacity];</span><br><span class="line">	&#125;</span><br><span class="line">	//拷贝构造</span><br><span class="line">	MyArray(const MyArray &amp; arr)&#123;</span><br><span class="line">		this-&gt;m_Capacity = arr.m_capacity;</span><br><span class="line">		this-&gt;m_Size = arr.m_Size;</span><br><span class="line">		this-&gt;pAddress = new T[this-&gt;m_capacity];</span><br><span class="line">		for (int i =0; i &lt; this-&gt;m_size; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			//如果T为对象，而且还包含指针，必须需要重载=操作符，因为这个等号不是构造而是赋值</span><br><span class="line">			//普通类型可以直接=但是指针类型需要深拷贝</span><br><span class="line">			this-&gt;pAddress[i] = arr. pAddress[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//重载=操作符  防止浅拷贝问题</span><br><span class="line">	MyArray&amp; operator=( const MyArray&amp; myarray) &#123;</span><br><span class="line">		if(this-&gt;pAddress != NULL) &#123;</span><br><span class="line">			delete[] this-&gt;pAddress;</span><br><span class="line">			this-&gt;m_Capacity = 0;</span><br><span class="line">			this-&gt;m_size = 0;</span><br><span class="line">		&#125;</span><br><span class="line">		this-&gt;m_Capacity = myarray.m_capacity;</span><br><span class="line">		this-&gt;m_Size = myarray.m_size;</span><br><span class="line">		this-&gt;pAddress = new T[this-&gt;m_capacity];</span><br><span class="line">		for (int i = 0; i &lt; this-&gt;m_size; i++) &#123;</span><br><span class="line">				this-&gt;pAddress[i] = myarray[i];</span><br><span class="line">		&#125;</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	//重载[]操作符 arr[0]</span><br><span class="line">	T&amp; operator [](int index)</span><br><span class="line">	&#123;</span><br><span class="line">		return this-&gt;pAddress[index]; //不考虑越界，用户自己去处理</span><br><span class="line">	&#125;</span><br><span class="line">	//尾插法</span><br><span class="line">	void Push_back( const T &amp; val)</span><br><span class="line">	&#123;</span><br><span class="line">		if (this-&gt;m_Capacity == this-&gt;m_size)&#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		this-&gt;pAddress[this-&gt;m_size] = val;</span><br><span class="line">		this-&gt;m_size++;</span><br><span class="line">	&#125;</span><br><span class="line">	//尾删法</span><br><span class="line">	void Pop_back()&#123;</span><br><span class="line">		if (this-&gt;m_size == e)&#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		this-&gt;m_size--;</span><br><span class="line">	&#125;</span><br><span class="line">	//获取数组容量</span><br><span class="line">	int getCapacity()&#123;</span><br><span class="line">		return this-&gt;m_capacity;</span><br><span class="line">	&#125;</span><br><span class="line">	//获取数组大小</span><br><span class="line">	int getsize()</span><br><span class="line">	&#123;</span><br><span class="line">		return this-&gt;m_size;</span><br><span class="line">	&#125;</span><br><span class="line">	//析构</span><br><span class="line">	~MyArray()&#123;</span><br><span class="line">		if (this-&gt;pAddress != NULL)&#123;</span><br><span class="line">			delete[] this-&gt;pAddress;</span><br><span class="line">			this-&gt;pAddress = NULL;</span><br><span class="line">			this-&gt;m_Capacity = 0;</span><br><span class="line">			this-&gt;m_Size = 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	T *pAddress;//指向一个堆空间，这个空间存储真正的数据</span><br><span class="line">	int m_Capacity;//容量</span><br><span class="line">	int m_Size;//大小</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类模板案例―数组类封装.cpp中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;myArray.hpp&quot;</span><br><span class="line">include &lt;string&gt;</span><br><span class="line">void printIntArray(MyArray&lt;int&gt;&amp; arr) &#123;</span><br><span class="line">	for (int i =0; i &lt; arr.getsize(); i++) &#123;</span><br><span class="line">	cout &lt;&lt; arr[i] &lt;&lt;&quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">//测试内置数据类型</span><br><span class="line">void test01()&#123;</span><br><span class="line">	MyArray&lt;int&gt; artay1(10);</span><br><span class="line">	for (int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">		array1.Push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; &quot;array1打印输出:” &lt;&lt; endl;</span><br><span class="line">	printIntArray( array1);</span><br><span class="line">	cout &lt;&lt; &quot;array1的大小:&quot; &lt;&lt;array1.getsize() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;array1的容量:&quot;&lt;&lt; array1.getCapacity() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;-------------------&quot;&lt;&lt;endl;</span><br><span class="line">	MyArray&lt;int&gt; array2( array1);//拷贝</span><br><span class="line">	array2.pop_back( );</span><br><span class="line">	cout &lt;&lt; &quot;array2打印输出:” &lt;&lt; endl;printIntArray( array2) ;</span><br><span class="line">	cout &lt;&lt; &quot;array2的大小:&quot; &lt;&lt;array2.getsize() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;array2的容量:&quot;&lt;&lt; array2.getCapacity() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//测试自定义数据类型</span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">	Person()&#123;&#125;</span><br><span class="line">	Person(string name,int age) </span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;m_Name = name;</span><br><span class="line">		this-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	string m_Name;</span><br><span class="line">	int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line">void printPersonArray(MyArray&lt;Person&gt;&amp; personArr)</span><br><span class="line">&#123;</span><br><span class="line">	for (int i = 0; i &lt; personArr.getsize(); i++) &#123;</span><br><span class="line">		cout &lt;&lt;&quot;姓名:&quot; &lt;&lt;personArr[i].m_Name &lt;&lt;”年龄: &quot;&lt;&lt; personArr[i].m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void test02()</span><br><span class="line">	&#123;</span><br><span class="line">	//创建数组</span><br><span class="line">		MyArray&lt;Person&gt; pArray (10);</span><br><span class="line">		Person p1(”孙悟空&quot;，30);</span><br><span class="line">		person p2(“韩信&quot;，20);</span><br><span class="line">		Person p3(&quot;妲己&quot;，18) ;</span><br><span class="line">		Person p4(“王昭君&quot;，15);</span><br><span class="line">		person p5(&quot;赵云&quot;，24);</span><br><span class="line">		//插入数据</span><br><span class="line">		pArray. push_back(p1);</span><br><span class="line">		pArray. Push_back(p2);</span><br><span class="line">		printPersonArray(pArray);</span><br><span class="line">		cout &lt;&lt; &quot;pArray的大小:&quot; &lt;&lt;pArray.getsize() &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; &quot;pArray的容量:&quot;&lt;&lt;pArray.getcapacity() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/03/c%E5%92%8Cc++/c-%E8%A1%A5%E5%85%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/03/c%E5%92%8Cc++/c-%E8%A1%A5%E5%85%85/" class="post-title-link" itemprop="url">c++补充</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-03 16:59:54" itemprop="dateCreated datePublished" datetime="2023-04-03T16:59:54+08:00">2023-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-26 12:37:35" itemprop="dateModified" datetime="2023-04-26T12:37:35+08:00">2023-04-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>如果以前使用过C语言，您可能觉得前面讨论的#define语句已经足够完成这样的工作了。但const比#defien好。首先，它能够明确指定类型。其次，可以使用C++的作用域规则将定义限制在特定的函数或文件中（作用域规则描述了名称在各种模块中的可知程度，将在第9章讨论)。第三，可以将const用于更复杂的类型，如第4章将介绍的数组和结构。</p>
<p>提示:如果读者在学习C++之前学习过C语言，并打算使用#define来定义符号常量，请不要这样做，而应使用const。</p>
<h3 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h3><p>如果定义变量时没有指定初值，则变量被默认初始化（default initialized)，此时变量被赋予了“默认值”。默认值到底是什么由变量类型决定，同时定义变量的位置也会对此有影响。</p>
<p>如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0。一种例外情况是，定义在函数体内部的内置类型变量将不被初始化（uninitialized)。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。</p>
<p>绝大多数类都支持无须显式初始化而定义对象，这样的类提供了一个合适的默认值。例如，以刚刚所见为例，string类规定如果没有指定初值则生成一个空串。</p>
<p>一些类要求每个对象都显式初始化，此时如果创建了一个该类的对象而未对其做明确的初始化操作，将引发错误。</p>
<p>建议初始化每一个内置类型的变量。虽然并非必须这么做，但如果我们不能硝保初始化后程序安全,那么这么做不失为一种简单可靠的方法。</p>
<hr>
<p>变量能且只能被定义一次,但是可以被多次声明。<br>声明和定义的区别看起来也许微不足道，但实际上却非常重要。如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。</p>
<h3 id="关键概念-静态类型"><a href="#关键概念-静态类型" class="headerlink" title="关键概念:静态类型"></a>关键概念:静态类型</h3><p>C++是一种静态类型(statically typed)语言,其含义是在编译阶段检查类型。其中,检查类型的过程称为类型检查（type checking ).</p>
<p>我们已经知道，对象的类型决定了对象所能参与的运算。在C++语言中，编译器负责检查数据类型是否支持要执行的运算，如果试图执行类型不支持的运算，编译器将报错并且不会生成可执行文件。<br>程序越复杂，静态类型检查越有助于发现问题。然而，前提是编译器必须知道每一个实体对象的类型，这就要求我们在使用某个变量之前必须声明其类型。</p>
<h3 id="变量命名规范"><a href="#变量命名规范" class="headerlink" title="变量命名规范"></a>变量命名规范</h3><p>变量命名有许多约定俗成的规范，下面的这些规范能有效提高程序的可读性:标识符要能体现实际含义。<br>变量名一般用小写字母，如 index，不要使用Index或INDEX。用户自定义的类名一般以大写字母开头，如 Sales item。<br>如果标识符由多个单词组成，则单词间应有明显区分，如 student loan或<br>studentLoan，不要使用 studentloan。</p>
<h3 id="指针值"><a href="#指针值" class="headerlink" title="指针值"></a>指针值</h3><p>指针的值（即地址）应属下列4种状态之一:</p>
<p>1．指向一个对象。</p>
<p>2．指向紧邻对象所占空间的下一个位置。</p>
<p>3.空指针，意味着指针没有指向任何对象。</p>
<p>4．无效指针，也就是上述情况之外的其他值。</p>
<p>试图拷贝或以其他方式访问无效指针的值都将引发错误。编译器并不负责检查此类错误,这一点和试图使用未经初始化的变量是一样的。访问无效指针的后果无法预计，因此程序员必须清楚任意给定的指针是否有效。<br>尽管第2种和第3种形式的指针是有效的，但其使用同样受到限制。显然这些指针没有指向任何具体对象，所以试图访问此类指针（假定的）对象的行为不被允许。如果这样做了，后果也无法预计。</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">int **main**() &#123;</span><br><span class="line"></span><br><span class="line">  **SetConsoleOutputCP**(65001);</span><br><span class="line"></span><br><span class="line">  int i=42;</span><br><span class="line"></span><br><span class="line">  int &amp;r=i;</span><br><span class="line"></span><br><span class="line">  int *p ;</span><br><span class="line"></span><br><span class="line">  p=&amp;i;</span><br><span class="line"></span><br><span class="line">  *p=i;</span><br><span class="line"></span><br><span class="line">  int &amp;r2=*p;</span><br><span class="line"></span><br><span class="line">  // test01();</span><br><span class="line"></span><br><span class="line">  //test02();</span><br><span class="line"></span><br><span class="line">  cout&lt;&lt;r&lt;&lt;endl&lt;&lt;&amp;r&lt;&lt;endl&lt;&lt;*p&lt;&lt; endl&lt;&lt;p &lt;&lt; endl&lt;&lt;&amp;r2 &lt;&lt;endl&lt;&lt;r2&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">  system( &quot;pause&quot; );</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">输出</span><br><span class="line">42</span><br><span class="line">0x61fe04</span><br><span class="line">42</span><br><span class="line">0x61fe04</span><br><span class="line">0x61fe04</span><br><span class="line">42//与上面引用类似</span><br></pre></td></tr></table></figure>

<h3 id="建议-初始化所有指针"><a href="#建议-初始化所有指针" class="headerlink" title="建议:初始化所有指针"></a>建议:初始化所有指针</h3><p>使用未经初始化的指针是引发运行时错误的一大原因，和其他变量一样，访问未经初始化的指针所引发的后果也是无法预计的。通常这一行为将造成程序崩溃,而且一旦崩溃，要想定位到出错位置将是特别棘手的问题。</p>
<p>在大多数编译器环境下，如果使用了未经初始化的指针，则该指针所占内存空间的当前内容将被看作一个地址值。访问该指针,相当于去访问一个本不存在的位置上的本不存在的对象。糟糕的是，如果指针所占内存空间中恰好有内容，而这些内容又被当作了某个地址，我们就很难分清它到底是合法的还是非法的了。</p>
<p>因此建议初始化所有的指针,并且在可能的情况下，尽量等定义了对象之后再定义指向它的指针。如果实在不清楚指针应该指向何处,就把它初始化为nullptr或者0.这样程序就能检测并知道它没有指向任何具体的对象了。</p>
<h3 id="赋值和指针"><a href="#赋值和指针" class="headerlink" title="赋值和指针"></a>赋值和指针</h3><p>指针和引用都能提供对其他对象的间接访问，然而在具体实现细节上二者有很大不同，其中最重要的一点就是引用本身并非一个对象。一旦定义了引用，就无法令其再绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象。</p>
<p>指针和它存放的地址之间就没有这种限制了。和其他任何变量(只要不是引用)一样，给指针赋值就是令它存放一个新的地址，从而指向一个新的对象</p>
<p>有时候要想搞清楚一条赋值语句到底是改变了指针的值还是改变了指针所指对象的值不太容易,最好的办法就是记住赋值永远改变的是等号左侧的对象。当写出如下语句时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int *p=0;</span><br><span class="line">int ival=1;</span><br><span class="line">p=&amp;ival;</span><br><span class="line"></span><br><span class="line">//意思是为pi赋一个新的值，也就是改变了那个存放在pi内的地址值。相反的，如果写出如下语句，</span><br><span class="line">*p=0;//ival的值被改变,指针pi并没有改变,即*(&amp;ival)=0;</span><br><span class="line">//则*pi（也就是指针pi指向的那个对象）发生改变。</span><br></pre></td></tr></table></figure>

<hr>
<p>利用void指针能做的事儿比较有限:拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个 void指针。不能直接操作 void指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。<br>概括说来，以void的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间中所存的对象.</p>
<h3 id="指向指针的引用"><a href="#指向指针的引用" class="headerlink" title="指向指针的引用"></a>指向指针的引用</h3><p>引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i =42;</span><br><span class="line">int *p;//p是一个 int型指针</span><br><span class="line">int *&amp;r =p;// r是一个对指针p的引用</span><br><span class="line">r= &amp;i;//r引用了一个指针，因此给r赋值&amp;i就是令p指向i</span><br><span class="line">*r= 0;//解引用r得到i，也就是p指向的对象，将i的值改为0</span><br></pre></td></tr></table></figure>

<p>要理解r的类型到底是什么，最简单的办法是从右向左阅读r的定义。离变量名最近的符号（此例中是&amp;r的符号&amp;）对变量的类型有最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，此例中的符号*说明r引用的是一个指针。最后，声明的基本数据类型部分指出r引用的是一个int指针。</p>
<p>面对一条比较复杂的指针或引用的声明语句时,从右向左阅读有助于弄清楚它的真实含义。</p>
<p>解引用——解释引用，说的通俗一点就是，直接去寻找指针所指的地址里面的内容，此内容可以是任何数据类型，当然也可以是指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int *p ,a=6;</span><br><span class="line">p=&amp;a;</span><br><span class="line">cout&lt;&lt;p&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;*p&lt;&lt;endl;//解引用,具体解释指针p所指向的内存地址里存放的内容。</span><br></pre></td></tr></table></figure>

<p>&amp;表示的是引用，就表示函数内的变量和主函数的变量是同一个，函数内改变它的值，主函数相应的变量也就跟着改变了；没有&amp;符号，就表示函数内的变量是主函数的变量的一个副本，在函数内改变其值，是不会改变主函数中变量的值的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int *p ,a=6;</span><br><span class="line">p=&amp;a;</span><br><span class="line">int &amp;c=a;</span><br><span class="line">cout&lt;&lt;c&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>脱解引用——就是用&amp;抵消掉*对a的引用效果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p=&amp;a;</span><br><span class="line">cout&lt;&lt;&amp;*p&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;*(&amp;*p)&lt;&lt;endl;</span><br><span class="line">因此代码的行输出的是a的内存地址，而代码下一行输出的是a的值。</span><br></pre></td></tr></table></figure>



<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>某些时候有这样一种const变量，它的初始值不是一个常量表达式，但又确实有必要在文件间共享。这种情况下，我们不希望编译器为每个文件分别生成独立的变量。相反，我们想让这类const对象像其他（非常量）对象一样工作，也就是说，只在一个文件中定义const，而在其他多个文件中声明并使用它。</p>
<p>解决的办法是，对于 const变量不管是声明还是定义都添加extern关键字，这样只需定义一次就可以了:<br>&#x2F;&#x2F; file_l.cc定义并初始化了一个常量，该常量能被其他文件访问</p>
<p>extern const int bufSize &#x3D; fcn();</p>
<p>&#x2F;&#x2F;file l.h头文件</p>
<p>extern const int bufSize;&#x2F;&#x2F;与file_1.cc中定义的bufSize是同一个</p>
<p>如上述程序所示，file_1.cc定义并初始化了bufsize。因为这条语句包含了初始值，所以它(显然）是一次定义。然而，因为bufsize是一个常量，必须用extern加以限定使其被其他文件使用。<br>file_1.h头文件中的声明也由extern做了限定，其作用是指明bufSize并非本文件所独有，它的定义将在别处出现。</p>
<p>如果想在多个文件之间共享 const对象,必须在变量的定义之前添加extern关键字。</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i=42;</span><br><span class="line">const int &amp;r1 = i;//允许将const int&amp;绑定到一个普通int对象上</span><br><span class="line">const int &amp;r2=42; //正确:r1是一个常量引用</span><br><span class="line">const int &amp;r3 = r1* 2; //正确:r3是一个常量引用</span><br><span class="line">int &amp;r4 = r1 * 2;//错误:r4是一个普通的非常量引用</span><br></pre></td></tr></table></figure>

<p>要想理解这种例外情况的原因，最简单的办法是弄清楚当一个常量引用被绑定到另外一种类型上时到底发生了什么:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double dval = 3.14;</span><br><span class="line">const int &amp;ri = dval;</span><br></pre></td></tr></table></figure>

<p>此处ri引用了一个int型的数。对ri的操作应该是整数运算，但dval却是一个双精度浮点数而非整数。因此为了确保让ri绑定一个整数，编译器把上述代码变成了如下形式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int temp = dval;//由双精度浮点数生成一个临时的整型常量</span><br><span class="line">const int &amp;ri = temp;//让ri绑定这个临时量</span><br></pre></td></tr></table></figure>

<p>在这种情况下，ri 绑定了一个<strong>临时量</strong> (temporary）对象。所谓临时量对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。C++程序员们常常把临时量对象简称为临时量。</p>
<p>接下来探讨当ri不是常量时，如果执行了类似于上面的初始化过程将带来什么样的后果。如果ri不是常量，就允许对ri赋值，这样就会改变ri所引用对象的值。注意，此时绑定的对象是一个临时量而非dval。程序员既然让ri引用dval，就肯定想通过ri改变dval的值，否则干什么要给ri赋值呢?如此看来，既然大家基本上不会想着把引用绑定到临时量上，C++语言也就把这种行为归为非法。</p>
<h3 id="指针和-const"><a href="#指针和-const" class="headerlink" title="指针和 const"></a>指针和 const</h3><p>与引用一样，也可以令指针指向常量或非常量。类似于常量引用，指向常量的指针（pointer to const)不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const double pi =3.14;//pi是个常量,它的值不能改变</span><br><span class="line">double *ptr = &amp;pi;//错误:ptr是一个普通指针</span><br><span class="line">const double *cptr = &amp;pi;//正确:cptr可以指向一个双精度常量</span><br><span class="line">*cptr =42;//错误:不能给*cptr赋值</span><br></pre></td></tr></table></figure>

<p>指针的类型必须与其所指对象的类型一致，但是有两个例外。第一种例外情况是允许令一个指向常量的指针指向一个非常量对象:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double dval = 3.14;//dval是一个双精度浮点数，它的值可以改变</span><br><span class="line">cptr=&amp;dval;//正确:但是不能通过cptr改变 dval的值</span><br></pre></td></tr></table></figure>

<p>和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。</p>
<h3 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a>const指针</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int errNumb=0;</span><br><span class="line">int *const curErr=&amp;errNumb;// curErr将一直指向errNumb</span><br><span class="line">const double pi=3.14159;</span><br><span class="line">const double *const pip = &amp;pi;// pip是一个指向常量对象的常量指针</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。常量指针(const pointer)必须初始化，而且一旦初始化完成，则它的值(也就是存放在指针中的那个地址）就不能再改变了。把放在const关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味，即<strong>不变的是指针本身的值</strong>(地址)而非指向的那个值（*curErr &#x3D;0;&#x2F;&#x2F;正确:把curErr所指的对象的值重置）:所以curErr指向的是一个一般的非常量整数，那么就完全可以用curErr去修改errNumb的值（当errNumb不为0时，）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//如果curErr所指的对象（也就是errNumb)的值不为0</span><br><span class="line">if(*curErr) &#123;</span><br><span class="line">	errorHandler ();</span><br><span class="line">	*curErr =0;//正确:把curErr所指的对象的值重置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>要想弄清楚这些声明的含义最行之有效的办法是从右向左阅读。此例中，离curErr最近的符号是const，意味着curErr本身是一个常量对象，对象的类型由声明符的其余部分确定。声明符中的下一个符号是*，意思是curErr是一个常量指针。最后，该声明语句的基本数据类型部分确定了常量指针指向的是一个int对象。与之相似，我们也能推断出，pip是一个常量指针，它指向的对象是一个双精度浮点型常量。</p>
<h3 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层const</h3><p>如前所述，指针本身是一个对象，它又可以指向另外一个对象。因此，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。用名词顶层const( top-level const）表示指针本身是个常量，而用名词底层const(low-level const）表示指针所指的对象是一个常量。<br>更一般的，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用,如算术类型、类、指针等。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const，这一点和其他类型相比区别明显:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int i=0;</span><br><span class="line">int *const pl =&amp;i;//不能改变p1的值，这是一个顶层const</span><br><span class="line">const int ci =42;</span><br><span class="line">//不能改变ci的值，这是一个顶层const</span><br><span class="line">const int *p2= &amp;ci;</span><br><span class="line">//允许改变p2的值，这是一个底层const</span><br><span class="line">const int &amp;r=ci;</span><br><span class="line">//  所有的引用本身都是顶层 const，因为引用一旦初始化就不能再改为其他对象的引用，这里用于声明引用的 const 都是底层 const</span><br></pre></td></tr></table></figure>

<p>当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显。其中，顶层const不受什么影响:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i= ci;//正确:铂贝ci的值，ci是一个顶层const，对此操作无影响</span><br><span class="line">p2 = p3;//正确:p2和p3指向的对象类型相同,p3顶层const的部分不影响</span><br></pre></td></tr></table></figure>

<p>执行拷贝操作并不会改变被拷贝对象的值，因此，拷入和拷出的对象是否是常量都没什么影响。</p>
<p>另一方面，底层 const 的限制却不能忽视。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*int p= p3;</span><br><span class="line">//错误:p3包含底层const的定义，而p没有</span><br><span class="line">p2= p3;</span><br><span class="line">//正确:p2和p3都是底层const</span><br><span class="line">p2 = &amp;i;</span><br><span class="line">//正确:int*能转换成const int*</span><br><span class="line">int &amp;r =ci;</span><br><span class="line">//错误:普通的int&amp;不能绑定到int常量上</span><br><span class="line">const int &amp;r2 =i;</span><br><span class="line">//正确:const int&amp;可以绑定到一个普通int上</span><br></pre></td></tr></table></figure>

<p>p3既是顶层const也是底层const，拷贝p3时可以不在乎它是一个顶层const，但是必须清楚它指向的对象得是一个常量。因此，不能用p3去初始化p，因为p指向的是一个普通的（非常量)整数。另一方面，p3的值可以赋给p2，是因为这两个指针都是底层const，尽管p3同时也是一个常量指针（顶层 const)，仅就这次赋值而言不会有什么影响。</p>
<h3 id="constexpr变量"><a href="#constexpr变量" class="headerlink" title="constexpr变量"></a>constexpr变量</h3><p>在一个复杂系统中，很难（几乎肯定不能）分辨一个初始值到底是不是常量表达式。当然可以定义一个 const变量并把它的初始值设为我们认为的某个常量表达式，但在实际使用时，尽管要求如此却常常发现初始值并非常量表达式的情况。可以这么说，在此种情况下，对象的定义和使用根本就是两回事儿。<br>C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">constexpr int mf = 20;// 20是常量表达式</span><br><span class="line">constexpr int limit = mf +1;// mf +1是常量表达式</span><br><span class="line">constexpr int sz=size();//只有当size是一个constexpr函数时,才是一条正确的声明语句</span><br></pre></td></tr></table></figure>

<p>尽管不能使用普通函数作为constexpr变量的初始值，新标准允许定义一种特殊的constexpr函数。这种函数应该足够简单以使得编译时就可以计算其结果,这样就能用constexpr函数去初始化constexpr变量了。</p>
<p>一般来说，如果你认定变量是一个常量表达式，那就把它声明成constexpr类型。</p>
<h3 id="字面值类型"><a href="#字面值类型" class="headerlink" title="字面值类型"></a>字面值类型</h3><p>常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为“字面值类型”(literal type）。</p>
<p>到目前为止接触过的数据类型中，<strong>算术类型、引用和指针</strong>都属于字面值类型。自定义类sales item、IO库、string 类型则不属于字面值类型，也就不能被定义成constexpr。</p>
<p>尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0,或者是存储于某个固定地址中的对象。</p>
<p>函数体内定义的变量一般来说并非存放在固定地址中，因此constexpr指针不能指向这样的变量。相反的，定义于所有函数体之外的对象其地址固定不变，能用来初始化constexpr 指针。允许函数定义一类有效范围超出函数本身的变量，这类变量和定义在函数体之外的变量一样也有固定地址。因此，constexpr 引用能绑定到这样的变量上，constexpr指针也能指向这样的变量。定义constexpr常量都要在函数体外。</p>
<p>必须明确一点，在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int *p = nullptr;// p是一个指向整型常量的指针</span><br><span class="line">constexpr int *q= nullptr; //q是一个指向整数的常量指针</span><br></pre></td></tr></table></figure>

<p>p和q的类型相差甚远，p是一个指向常量的指针，而q是一个常量指针，其中的关键在于constexpr把它所定义的对象置为了顶层const。</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>一.sync_with_stdio</strong><br>这个函数是一个“是否兼容stdio”的开关，C++为了兼容C，保证程序在使用了<code>std::printf</code>和<code>std::cout</code>的时候不发生混乱，将输出流绑到了一起。<br><code>cin</code>，<code>cout</code>之所以效率低，是因为先把要输出的东西存入缓冲区，再输出，导致效率降低，而这段语句可以来打消iostream的输入输出缓存，可以节省许多时间，使效率与scanf与printf相差无几.</p>
<p><strong>应用</strong><br>在ACM里，经常出现数据集超大造成 cin <strong>运行超时</strong> &#x2F;<code>Time Limit Exceeded</code>【TLE】的情况。这时候大部分人（包括原来我也是）认为这是cin的效率不及scanf的错，甚至还上升到C语言和C++语言的执行效率层面的无聊争论。其实像上文所说，这<strong>只是C++为了兼容而采取的保守措施</strong>。我们可以<strong>在IO之前将stdio解除绑定</strong>，这样做了之后要注意不要同时混用cout&#x2F;cin和printf&#x2F;scanf之类。</p>
<p><strong>二.tie</strong><br><code>tie</code>是将两个<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=stream&spm=1001.2101.3001.7020">stream</a>绑定的函数，空参数的话返回当前的输出流指针。<br>在默认的情况下<code>cin</code>绑定的是<code>cout</code>，每次执行 &lt;&lt; 操作符的时候都要调用flush，这样会增加IO负担。可以通过<code>tie(0)</code>（0表示NULL）来解除<code>cin</code>与<code>cout</code>的绑定，进一步加快执行效率。</p>
<hr>
<h3 id="c-11"><a href="#c-11" class="headerlink" title="c++11"></a>c++11</h3><p>在 C++11新标准中，如果我们需要默认的行为，那么可以通过在参数列表后面写上&#x3D; default来要求编译器生成构造函数。其中，&#x3D; default 既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部。和其他函数一样，如果&#x3D; default在类的内部，则默认构造函数是内联的;如果它在类的外部，则该成员默认情况下不是内联的。</p>
<h3 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h3><p>接下来我们介绍类中定义的另外两个构造函数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sales_data(const std: :string &amp;s): bookNo(s) &#123;&#125;</span><br><span class="line">Sales_data (const std: :string &amp;s,unsigned n, double p):</span><br><span class="line">bookNo(s), units_sold(n),revenue(p*n)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这两个定义中出现了新的部分，即冒号以及冒号和花括号之间的代码，其中花括号定义了(空的）函数体。我们把新出现的部分称为构造函数初始值列表(constructor initialize list)，它负责为新创建的对象的一个或几个数据成员赋初值。构造函数初始值是成员名字的一个列表，每个名字后面紧跟括号括起来的(或者在花括号内的）成员初始值。不同成员的初始化通过逗号分隔开来。</p>
<p>含有三个参数的构造函数分别使用它的前两个参数初始化成员 bookNo和units_sold,revenue的初始值则通过将售出图书总数和每本书单价相乘计算得到。<br>只有一个string类型参数的构造函数使用这个string对象初始化bookNo，对于units sold和revenue则没有显式地初始化。当某个数据成员被构造函数初始值列表忽略时，它将以与合成默认构造函数相同的方式<strong>隐式初始化</strong>。在此例中，这样的成员使用类内初始值初始化，因此只接受一个string参数的构造函数等价于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//与上面定义的那个构造函数效果相同</span><br><span class="line">Sales_ data(const std: :string &amp;s):</span><br><span class="line">bookNo (s) , units_sold(0), revenue(0)&#123;&#125;</span><br><span class="line">std::string bookNo;</span><br><span class="line">unsigned units_sold = 0;</span><br><span class="line">double revenue = 0.0;</span><br></pre></td></tr></table></figure>

<p>通常情况下，构造函数使用类内初始值不失为一种好的选择，因为只要这样的初始值存在我们就能确保为成员赋予了一个正确的值。不过，如果你的编译器不支持类内初始值，则所有构造函数都应该显式地初始化每个内置类型的成员。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/03/c%E5%92%8Cc++/%E7%AC%AC%E4%BA%94%E5%A4%A9-c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/03/c%E5%92%8Cc++/%E7%AC%AC%E4%BA%94%E5%A4%A9-c/" class="post-title-link" itemprop="url">第五天 c++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-03 09:24:35" itemprop="dateCreated datePublished" datetime="2023-04-03T09:24:35+08:00">2023-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-22 11:32:50" itemprop="dateModified" datetime="2023-04-22T11:32:50+08:00">2023-04-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="多态的基本概念"><a href="#多态的基本概念" class="headerlink" title="多态的基本概念"></a>多态的基本概念</h3><p>多态是C++面向对象三大特性之一</p>
<p>多态分为两类:</p>
<ul>
<li>静态多态:函数重载和运算符重载属于静态多态，复用函数名</li>
<li>动态多态:派生类和虚函数实现运行时多态</li>
</ul>
<p>静态多态和动态多态区别:</p>
<ul>
<li>静态多态的函数地址早绑定–编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定–运行阶段确定函数地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	// Speak函数就是虚函数</span><br><span class="line">	//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span><br><span class="line">	//vfptr-虚函教（表）指针</span><br><span class="line">	//v- virtual</span><br><span class="line">	//f - function</span><br><span class="line">	//ptr - pointer</span><br><span class="line">	virtual void speak()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;动物在说话&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Cat :public Animal&#123;</span><br><span class="line">public:</span><br><span class="line">	void speak()&#123;</span><br><span class="line">		cout &lt;&lt;&quot;小猫在说话&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">class Dog :public Animal&#123;</span><br><span class="line">public:</span><br><span class="line">	void speak( )&#123;</span><br><span class="line">		cout &lt;&lt;&quot;小狗在说话&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//我们希望传入什么对象，那么就调用什么对象的函数</span><br><span class="line">//如果函数地址在编译阶段就能确定，那么静态联编</span><br><span class="line">//如果函数地址在运行阶段才能确定，就是动态联编</span><br><span class="line"></span><br><span class="line">void DoSpeak( Animal &amp; animal)&#123;//Animal &amp; animal=cat;引用指向子类对象,如果没有virtual，则编译阶段就确定函数调用Animal了，则不能实现动态调用了</span><br><span class="line">	animal.speak( );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//多态满足条件:</span><br><span class="line">//1、有继承关系</span><br><span class="line">//2、子类重写父类中的虚函数，这里就是speak函数</span><br><span class="line">//多态使用:</span><br><span class="line">//父类指针或引用指向子类对象</span><br><span class="line">void test01()&#123;</span><br><span class="line">	Cat cat;</span><br><span class="line">	DoSpeak(cat);//用引用也可以。引用不用手动释放内存。指针不用实例化对象。各有优劣,即引用时不能写成	//DoSpeak(new Cat);</span><br><span class="line">	Dog dog;</span><br><span class="line">	DoSpeak( dog);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    SetConsoleOutputCP(65001);</span><br><span class="line">	test01();</span><br><span class="line">	//test02();</span><br><span class="line">	system( &quot;pause&quot; );</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:</p>
<p>多态满足条件</p>
<ul>
<li>有继承关系</li>
<li>子类<strong>重写</strong>父类中的虚函数</li>
</ul>
<p>多态信用条件</p>
<ul>
<li>父类指针或引用指向子类对象</li>
</ul>
<p>重写:函数返回值类型	函数名	参数列表	完全—致称为重写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//重写	函数返回值类型	函数名参	数列表完全相同</span><br><span class="line">virtual void speak ()</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;”小猫在说话”&lt;&lt; endl:</span><br><span class="line">&#125;</span><br><span class="line">当子类重写父类的虚函数</span><br><span class="line">这里不是子类中的虚函数表内部会替换成子类的虚函数地址，而是添加，因为替换的话，子类的虚函数就会丢失父类的虚函数地址，但实际上子类的虚函数表中同时有父类的虚函数地址和它自己的虚函数地址，通过使用方式不同，如利用父类指针或引用指向子类这种方式，来区分到底是使用子类虚数表里两个虚数表中的哪一个</span><br></pre></td></tr></table></figure>

<h3 id="多态案例一-计算器类"><a href="#多态案例一-计算器类" class="headerlink" title="多态案例一-计算器类"></a>多态案例一-计算器类</h3><p>案例描述:</p>
<p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p>
<p>多态的优点:</p>
<ul>
<li>代码组织结构清晰。可读性强</li>
<li>利于前期和后期的扩展以及维护</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">//普通实现</span><br><span class="line">class calculator &#123;</span><br><span class="line">public:</span><br><span class="line">	int getResult( string oper)&#123;</span><br><span class="line">		if (oper == &quot;+&quot;) &#123;</span><br><span class="line">			return m_Num1 + m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (oper == &quot;-&quot;) &#123;</span><br><span class="line">			return m_Num1 - m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (oper ==“*&quot;)&#123;</span><br><span class="line">			return m_Num1 *m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">	//如果要提供新的运算，需要修改源码</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	int m_Num1;</span><br><span class="line">	int m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line">void teste1()&#123;</span><br><span class="line">	//普通实现测试</span><br><span class="line">	Calculator c;</span><br><span class="line">	c.m_Num1 = 10;</span><br><span class="line">	c.m_Num2 = 10;</span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; c.m_Num2&lt;&lt; &quot; - &quot; &lt;&lt; c.getResult(&quot;+&quot;) &lt;&lt; endl;</span><br><span class="line">	cout &lt; c.m_Num1 &lt;&lt; &quot; . &quot; &lt;&lt; c.m_Num2&lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;-&quot;) &lt;&lt; endl;</span><br><span class="line">	cout &lt; c.m_Num1 &lt;&lt;”*&quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;*&quot;) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//多态实现</span><br><span class="line">//抽象计算器类</span><br><span class="line">//多态优点:代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护</span><br><span class="line">class Abstractcalculator</span><br><span class="line">&#123;</span><br><span class="line">public :</span><br><span class="line">	virtual int getResult()&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">		int m_Num1;</span><br><span class="line">		int m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//加法计算器</span><br><span class="line">class Addcalculator :public Abstractcalculator&#123;</span><br><span class="line">public:</span><br><span class="line">	int getResult()&#123;</span><br><span class="line">		return m_Num1 + m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//减法计算器</span><br><span class="line">class Subcalculator :public Abstractcalculator&#123;</span><br><span class="line">public:</span><br><span class="line">	int getResult()&#123;</span><br><span class="line">		return m_Num1 - m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//乘法计算器</span><br><span class="line">class Mulcalculator :public Abstractcalculator&#123;</span><br><span class="line">public:</span><br><span class="line">	int getResult()&#123;</span><br><span class="line">		return m_Num1 * m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void teste2()&#123;</span><br><span class="line">	//创建加法计算器</span><br><span class="line">	Abstractcalculator *abc = new Addcalculator;//多态使用:</span><br><span class="line">	//父类指针或引用指向子类对象,这里是父类指针指向子类对象</span><br><span class="line">	abc-&gt;m_Num1 = 10;</span><br><span class="line">	abc-&gt;m_Num2 = 10;</span><br><span class="line">	cout &lt; abc-&gt;m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;</span><br><span class="line">	delete abc;//用完了记得销毁</span><br><span class="line">	//创建减法计算器</span><br><span class="line">	abc = new Subcalculator;</span><br><span class="line">	abc-&gt;m_Num1 = 10;</span><br><span class="line">	abc-&gt;m_Num2 = 10;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; -&quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;</span><br><span class="line">	delete abc;</span><br><span class="line">	//创建乘法计算器</span><br><span class="line">	abc = new MulCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = 10;</span><br><span class="line">	abc-&gt;m_Num2 = 10;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt;&quot; * &quot; &lt;&lt; abc-&gt;m_Num2 〈&lt; &quot; - &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;</span><br><span class="line">	delete abc;</span><br><span class="line">	&#125; </span><br></pre></td></tr></table></figure>

<p>总结:C++开发提倡利用多森设计程序架构，因为多态优点很多</p>
<h3 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h3><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p>
<p>因此可以将虚函数改为纯虚函数</p>
<p>纯虚函数语法:virtual 	返回值类型	函数名	(参数列表)&#x3D; 0;</p>
<p>当类中有了纯虚函数，这个类也称为<strong>抽象类</strong></p>
<p>抽象类特点:</p>
<ul>
<li>无法实例化对象</li>
<li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Base&#123;</span><br><span class="line">public:</span><br><span class="line">	//纯虚函数</span><br><span class="line">	//类中只要有一个纯虚函数就称为抽象类</span><br><span class="line">	//抽象类无法实例化对象,但是能定义一个指向该类的指针</span><br><span class="line">	//子类必须重写父类中的纯虚函数，否则也属于抽象类</span><br><span class="line">	virtual void func() = 0;</span><br><span class="line">&#125;;</span><br><span class="line">class Son :public Base&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void func()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;func调用&quot;&lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">void teste1()&#123;</span><br><span class="line">	Base * base = NULL;</span><br><span class="line">	// base = new Base; </span><br><span class="line">	//错误，抽象类无法实例化对象</span><br><span class="line">	base = new Son;</span><br><span class="line">	base-&gt;func( );</span><br><span class="line">	delete base; //记得销毁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h3><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>
<p>解决方式:将父类中的析构函数改为<strong>虚析构</strong>或者纯虚析构</p>
<p>虚析构和纯虚析构共性:</p>
<ul>
<li>可以解决父类指针释放子类对象</li>
<li>都需要有具体的函数实现</li>
</ul>
<p>虚析构和纯虚析构区别:</p>
<ul>
<li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li>
</ul>
<p>在基类析构函数声明为virtual的时候，delete基类指针，会先调用派生类的析构函数，再调用基类的析构函数。在基类析构函数没有声明为virtual的时候，delete基类指针，只会调用基类的析构函数，而不会调用派生类的析构函数，这样会造成销毁对象的不完全。</p>
<p>虚析构语法:</p>
<p><code>virtual ~类名( )&#123;&#125;</code></p>
<p>纯虚析构语法:</p>
<p><code>virtual	~类名()= 0;</code></p>
<p><code>类名::~类名()&#123;&#125;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">public:</span><br><span class="line">	Animal()&#123;</span><br><span class="line">	cout &lt;&lt; &quot;Animal构造函数调用!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void Speak() = 0;</span><br><span class="line">	//析构函数加上virtual关键字，变成虚析构函数</span><br><span class="line">	//virtual ~Animal()</span><br><span class="line">	//&#123;</span><br><span class="line">	//cout &lt;&lt; &quot;Animal虚析构函数调用! &quot;&lt;&lt;endl;</span><br><span class="line">    //&#125;</span><br><span class="line">	virtual ~Animal() = 0;</span><br><span class="line">&#125;;</span><br><span class="line">Animal : :~Animal()&#123;</span><br><span class="line">	cout &lt;&lt;&quot;Animal纯虚析构函数调用!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span><br><span class="line">class Cat : public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">	Cat(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;cat构造函数调用!&quot; &lt;&lt;endl;</span><br><span class="line">		m_Name = new string( name);</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void Speak()&#123;</span><br><span class="line">		cout &lt;&lt; *m_Name &lt;&lt;&quot;小猫在说话!&quot;&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~Cat()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;cat析构函数调用!&quot;&lt;&lt; endl;</span><br><span class="line">		if (this-&gt;m_Name != NULL)&#123;</span><br><span class="line">		delete m_Name;</span><br><span class="line">		m_Name = NULL;//置空是为了防止出现野指针</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	string *m_Name;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	Animal *animal = new Cat( &quot;Tom&quot; ) ;</span><br><span class="line">	animal-&gt;Speak();</span><br><span class="line">	//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏</span><br><span class="line">	//怎么解决?给基类增加一个虚析构函数</span><br><span class="line">	//虚析构函数就是用来解决通过父类指针释放子类对象</span><br><span class="line">	delete animal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>1.虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p>
<p>2.如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p>
<p>3.拥有纯虚析构函数的类也属于抽象类</p>
<p>抽象类不能实例化,但是能定义一个指向该类的指针</p>
<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>程序运行时产生的数据都属于临时数据，程序—旦运行结束都会被释放通过文件可以将数据持久化</p>
<p>C++中对文件操作需要包含头文件&lt; fstream &gt;</p>
<p>文件类型分为两种:</p>
<p>1.文本文件-文件以文本的ASCII码形式存储在计算机中</p>
<p>2.二进制文件-文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们</p>
<p>操作文件的三大类:</p>
<ul>
<li>ofstream:写操作</li>
<li>ifstream:读操作</li>
<li>fstream :读写操作</li>
</ul>
<h3 id="写文件步骤如下"><a href="#写文件步骤如下" class="headerlink" title="写文件步骤如下:"></a>写文件步骤如下:</h3><p>1.包含头文件</p>
<p>#include <fstream></p>
<p>2.创建流对象<br>ofstream ofs;&#x2F;&#x2F;读文件则为ifstream ofs</p>
<p>3.打开文件<br>ofs.open(“文件路径”,打开方式);&#x2F;&#x2F;读文件则为ifs.open(“文件路径”,打开方式)</p>
<p>4.写数据</p>
<p>ofs &lt;&lt;”写入的数据”;</p>
<p>5.关闭文件</p>
<p>ofs.close();&#x2F;&#x2F;读文件则为ifs.close()</p>
<p>文件打开方式:</p>
<table>
<thead>
<tr>
<th>打开方式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>ios:in</td>
<td>为读文件而打开文件</td>
</tr>
<tr>
<td>ios::out</td>
<td>为写文件而打开文件</td>
</tr>
<tr>
<td>ios:.ate</td>
<td>初始位置:文件尾</td>
</tr>
<tr>
<td>ios:.app</td>
<td>追加方式写文件</td>
</tr>
<tr>
<td>ios:trunc</td>
<td>如果文件存在先删除，再创建</td>
</tr>
<tr>
<td>ios:binary</td>
<td>二进制方式</td>
</tr>
</tbody></table>
<p>注意:文件打开方式可以配合使用，利用|操作符</p>
<p>例如:用二进制方式写文件<code>ios ::binary | ios:: out</code></p>
<h3 id="读文件步骤如下"><a href="#读文件步骤如下" class="headerlink" title="读文件步骤如下:"></a>读文件步骤如下:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ifstream ifs;</span><br><span class="line">ifs.open(&quot;test.txt&quot;, ios ::in);</span><br><span class="line">if ( !ifs.is_open())</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt;&quot;文件打开失败”&lt;&lt; endl;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">//第—种方式</span><br><span class="line">//char buf[1024] =&#123; 0 &#125;;</span><br><span class="line">// while (ifs &gt;&gt; buf)</span><br><span class="line">//&#123;</span><br><span class="line">	//cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">	//&#125;</span><br><span class="line">//第二种</span><br><span class="line">//char buf[ 1024] - &#123; 0 &#125;;</span><br><span class="line">// while (ifs.getline(buf,sizeof( buf) )); </span><br><span class="line">//&#123;</span><br><span class="line">	//cout &lt;&lt; buf &lt;&lt; endl;	</span><br><span class="line">//&#125;</span><br><span class="line">//第三种</span><br><span class="line">//string buf;</span><br><span class="line">// while (getline(ifs, buf )) </span><br><span class="line">//&#123;</span><br><span class="line">	//cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">// &#125;</span><br><span class="line">char c;</span><br><span class="line">while ((c = ifs.get()) !=EOF)&#123;//EOF end of file</span><br><span class="line">	cout &lt;&lt; c;</span><br><span class="line">&#125;</span><br><span class="line">ifs.close();</span><br></pre></td></tr></table></figure>

<p>在 C++ 中，ifstream 是用于从文件中读取数据的输入流对象。它通过空格字符（空格符、制表符、换行符等）来分隔输入数据。在默认情况下，每次读取一定数量的字符（通常是一个单词或一行），直到遇到空格字符或换行为止。如果需要，可以使用 getline 函数来读取整行数据，而不是只读取到第一个空格字符。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/02/c%E5%92%8Cc++/%E7%AC%AC%E5%9B%9B%E5%A4%A9-c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/02/c%E5%92%8Cc++/%E7%AC%AC%E5%9B%9B%E5%A4%A9-c/" class="post-title-link" itemprop="url">第四天 c++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-02 10:18:27 / 修改时间：17:55:52" itemprop="dateCreated datePublished" datetime="2023-04-02T10:18:27+08:00">2023-04-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="C-对象模型和this指针"><a href="#C-对象模型和this指针" class="headerlink" title="C++对象模型和this指针"></a>C++对象模型和this指针</h2><h3 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a>成员变量和成员函数分开存储</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Class Person&#123;</span><br><span class="line">	int m_A; //非静态成员变量 属于类的对象上</span><br><span class="line">	static int m_B;//静态成员变量 不属于类对象上</span><br><span class="line">	void func()&#123;&#125;//非静态成员函数 不属于类对象上,即test02测试空间没有包含  不属于类对象上</span><br><span class="line">	static void func2()&#123;&#125;//静态成员函数 不属于类对象上</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">int Person: :m_B = o;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">Person p ;</span><br><span class="line">//空对象占用内存空间为:1</span><br><span class="line">//C++编译器会给每个空对象也分配一个字节空间，是为了区分空对象占内存的位置</span><br><span class="line">//每个空对象也应该有一个独一无二的内存地址</span><br><span class="line">cout &lt;&lt; &quot;size of p = &quot; &lt;&lt; sizeof(p) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test02()&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	cout &lt;&lt; &quot;size of p = &quot; &lt;&lt; sizeof(p) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码，如果有p1,p2,p3…</p>
<p>每一个调用都是调用同一块内存空间</p>
<h3 id="this指针概念"><a href="#this指针概念" class="headerlink" title="this指针概念"></a>this指针概念</h3><p>接上那么问题是:这—块代码是如何区分那个对象调用自己的呢?</p>
<p>C++通i过提供特殊的对象指针， this指针，解决上述问题。</p>
<p>this指针指向被调用的成员函数所属的对象。</p>
<p>this指针是隐含每一个非静态成员函数内的一种指针。</p>
<p>this指针不需要定义，直接使用即可。</p>
<p>静态函数没有this指针。因为静态函数不属于某个对象。</p>
<p>this指针指向的就是对象,通过*this解引用可以访问该对象本身</p>
<p><strong>this指针的用途</strong>:</p>
<p>当形参和成员变量同名时，可用this指针来区分。</p>
<p>在类的非静态成员函数中返回对象本身，可使用return *this。</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">	Person (int age)&#123;</span><br><span class="line">	this-&gt;age = age;//谁调用Person，this就指向谁，比如Person p1;则this指向p1</span><br><span class="line">	&#125;</span><br><span class="line">	Person&amp; PersonAddAge (Person &amp;p)&#123;//引用指向本身内存。不用引用就是拷贝了,而拷贝指向另一个内存</span><br><span class="line">	//不引用就会直接使用复制构造丽数。因为*this这个对象会在函数结束后销毁</span><br><span class="line">	//引用可以让p2使用同一个内存，而*this指向的就是内存地址，所以不加&amp;后面的</span><br><span class="line">	//p2.PersonAddAge(p1).PersonAddAge(p1).PersonAddAge(pl);就和第一个调用的p2无关了</span><br><span class="line">	this-&gt;age += p.age;</span><br><span class="line">	//this指向p2的指针，而*this指向的就是p2这个对象本体</span><br><span class="line">	return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	int age;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">void test02 ()&#123;</span><br><span class="line">	Person p1(10) ;</span><br><span class="line">	Person p2(10);</span><br><span class="line">	//链式编程思想</span><br><span class="line">	p2.PersonAddAge(p1).PersonAddAge(p1). PersonAddAge(pl);//上面如果不加引用，则后面每次创建都是一个新的对象，则输出总是20</span><br><span class="line">	cout &lt;&lt; &quot;p2的年龄为:&quot;&lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h3><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p>
<p>如果用到this指针，需要加以判断保证代码的健壮性</p>
<p>this指针的本质是指针常量,指针的指向是不可以修改的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">	void showPersonAge()&#123;</span><br><span class="line">	//报错原因是因为传入的指针是为NULL</span><br><span class="line">		if (this == NULL)//保证代码健壮性</span><br><span class="line">		&#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; &quot;age = &quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;//当为null时，this空对象，报错</span><br><span class="line">		&#125;</span><br><span class="line">int age;</span><br><span class="line">&#125; ;</span><br><span class="line">void test()&#123;</span><br><span class="line">	Person *p=NULL;</span><br><span class="line">	p-&gt;showPersonAge();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h3><p>常函数:</p>
<p>成员函数后加const后我们称为这个函数为常函数</p>
<p>常函数内不可以修改成员属性</p>
<p>成员属性声明时加关键字mutable后，在常函数中依然可以修改</p>
<p>常对象:</p>
<p>声明对象前加const称该对象为常对象</p>
<p>常对象只能调用常函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Class Person&#123;</span><br><span class="line">public:</span><br><span class="line">	//this指针的本质是指针常量指针的指向是不可以修改的</span><br><span class="line">	// const Person * const this;</span><br><span class="line">	//在成员函数后面加const，修饰的是this指向，让指针指向的值也不可以修改</span><br><span class="line">	void showPerson() const</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;m_B=100; </span><br><span class="line">		//this-&gt;m_A = 100;</span><br><span class="line">		//this = NULL; //this指针不可以修改指针的指向的</span><br><span class="line">	&#125;</span><br><span class="line">	int m_A;</span><br><span class="line">	mutable int m_B;//特殊变量，即使在常函数中，也可以修改这个值</span><br><span class="line">&#125;;</span><br><span class="line">//常对象</span><br><span class="line">void test02 ()</span><br><span class="line">&#123;</span><br><span class="line">	const Person p;//在对象前加const，变为常对象</span><br><span class="line">	//p.m_A = 100;</span><br><span class="line">	p.m_B = 100; //m_B是特殊值，在常对象下也可以修改</span><br><span class="line">	//常对象只能调用常函数</span><br><span class="line">	p.showPerson () ;</span><br><span class="line">	//P.func ();//如果能调用，则可能会出现m_A被修改，其实是不能修改的。常对象不可以调用普通成员函数，因为普通成员函数可以修改属性,常对象可以修改静态变量的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><h3 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h3><p>在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>
<p>友元的目的就是让—个函数或者类访问另一个类中私有成员</p>
<p>友元的关键字为friend </p>
<p>友元的三种实现</p>
<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Building&#123;</span><br><span class="line">	//goodGay全局函数是 Building好朋友，可以访问Building中私有成员</span><br><span class="line">	//告诉编译器goodGay全局函数是Building类的好朋友，可以访问类中的私有内容</span><br><span class="line">	friend void goodGay(Building *building);</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">//全局函数</span><br><span class="line">void goodGay(Building *building)</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;&quot;好基友全局函数正在访问:&quot;&lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout&lt;&lt;&quot;好基友全局函数正在访问: &quot;&lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	Building building;</span><br><span class="line">	goodGay(&amp;building);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Building;</span><br><span class="line">class goodGay&#123;</span><br><span class="line">public:</span><br><span class="line">	goodGay();</span><br><span class="line">	void visit();</span><br><span class="line">private:</span><br><span class="line">	Building *building;</span><br><span class="line">&#125;;</span><br><span class="line">class Building&#123;</span><br><span class="line">	//告诉编译器goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span><br><span class="line">	friend class goodGay;</span><br><span class="line">public :</span><br><span class="line">	Building();</span><br><span class="line">public:</span><br><span class="line">	string m_sittingRoom;//客厅</span><br><span class="line">private:</span><br><span class="line">	string m_BedRoom; //卧室</span><br><span class="line">&#125;;</span><br><span class="line">Building : : Building()&#123;//类的定义可以在类外进行，所以以后文件太大时，声明在头文件中，定义在源文件中</span><br><span class="line">	this-&gt;m_sittingRoom =&quot;客厅&quot;;</span><br><span class="line">	this-&gt;m_BedRoom =&quot;卧室&quot;;</span><br><span class="line">&#125;</span><br><span class="line">goodGay : : goodGay ()&#123;</span><br><span class="line">	building = new Buildng;//创建一个堆区 </span><br><span class="line">&#125;</span><br><span class="line">void goodGay : : visit()&#123;</span><br><span class="line">	cout &lt;&lt;“好基友正在访问”&lt;&lt; building-&gt;m_sittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt;“好基友正在访问”&lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void teste1()&#123;</span><br><span class="line">	goodGay gg;</span><br><span class="line">	gg.visit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Building;</span><br><span class="line">class goodGay&#123;</span><br><span class="line">public:</span><br><span class="line">	goodGay();</span><br><span class="line">	void visit();//只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span><br><span class="line">	void visit2();</span><br><span class="line">private:</span><br><span class="line">	Building *building;</span><br><span class="line">&#125;;</span><br><span class="line">class Building&#123;</span><br><span class="line">	//告诉编译器goodGay类中的visit成员函数是Building类的好朋友，可以访问到Building类中私有内容</span><br><span class="line">	friend void goodGay::visit();</span><br><span class="line">public :</span><br><span class="line">	Building();</span><br><span class="line">public:</span><br><span class="line">	string m_sittingRoom;//客厅</span><br><span class="line">private:</span><br><span class="line">	string m_BedRoom; //卧室</span><br><span class="line">&#125;;</span><br><span class="line">Building : : Building()&#123;//类的定义可以在类外进行，所以以后文件太大时，声明在头文件中，定义在源文件中</span><br><span class="line">	this-&gt;m_sittingRoom =&quot;客厅&quot;;</span><br><span class="line">	this-&gt;m_BedRoom =&quot;卧室&quot;;</span><br><span class="line">&#125;</span><br><span class="line">goodGay : : goodGay ()&#123;</span><br><span class="line">	building = new Buildng;//创建一个堆区 </span><br><span class="line">&#125;</span><br><span class="line">void goodGay : : visit()&#123;</span><br><span class="line">	cout &lt;&lt;“好基友正在访问”&lt;&lt; building-&gt;m_sittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt;“好基友正在访问”&lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void goodGay : : visit2()&#123;</span><br><span class="line">	cout &lt;&lt;“好基友正在访问”&lt;&lt; building-&gt;m_sittingRoom &lt;&lt; endl;</span><br><span class="line">	//cout &lt;&lt;“好基友正在访问”&lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void teste1()&#123;</span><br><span class="line">	goodGay gg;</span><br><span class="line">	gg.visit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>运算符重载概念:对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>
<h3 id="加号运算符重载"><a href="#加号运算符重载" class="headerlink" title="加号运算符重载"></a>加号运算符重载</h3><p>作用:实现两个自定义数据类型相加的运算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">	person()&#123;&#125;;</span><br><span class="line">	person(int a, int b)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;m_A = a;</span><br><span class="line">		this-&gt;m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line">	//成员函数实现＋号运算符重载</span><br><span class="line">	Person operator+( const Person&amp; p)&#123;</span><br><span class="line">		Person temp;</span><br><span class="line">		temp.m_A = this-&gt;m_A + p.m_A;</span><br><span class="line">		temp.m_B = this-&gt;m_B + p.m_B;</span><br><span class="line">		return temp;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	int m_A;</span><br><span class="line">	int m_B;</span><br><span class="line">&#125;</span><br><span class="line">//全局函数实现+号运算符重载 </span><br><span class="line">//Person operator+( const Person &amp;p1, const Person &amp;p2)&#123;</span><br><span class="line">//	Person temp(0，0);</span><br><span class="line">//	temp.m_A = p1.m_A + p2.m_A;</span><br><span class="line">//	temp.m_B = p1.m_B +p2.m_B;</span><br><span class="line">//&#125;</span><br><span class="line">//运算符重载可以发生函数重载</span><br><span class="line">Person operator+(const Person&amp; p2， int val)</span><br><span class="line">&#123;</span><br><span class="line">	Person temp;</span><br><span class="line">	temp.m_A = p2.m_A + val;</span><br><span class="line">	temp.m_B = p2.m_B + val;</span><br><span class="line">	return temp;</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">	Person p1(10，10);</span><br><span class="line">	Person p2(20，20);</span><br><span class="line">	//成员函数方式</span><br><span class="line">	Person p3 = p2 +p1;//相当于p2.operaor+(p1)</span><br><span class="line">	cout &lt;&lt; &quot;mA: &quot; &lt;&lt;p3.m_A &lt;&lt; &quot; mB: &quot; &lt;&lt; p3.m_B &lt;&lt; endl;</span><br><span class="line">	Person p4 = p3 +10;//相当于operator+(p3,10)</span><br><span class="line">	cout &lt;&lt;“mA: &quot; &lt;&lt;p4.m_A &lt;&lt; &quot; mB : &quot;&lt;&lt; p4.m_B &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结1:对于内置的数据类型的表达式的的运算符是不可能改变的</p>
<p>总结2:不要滥用运算符重载</p>
<h3 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h3><p>作用:可以输出自定义数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">	friend ostream&amp; operator&lt;&lt;(ostream&amp; out，Person&amp; p);</span><br><span class="line">public:</span><br><span class="line">	Person(int a, int b)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;m_A = a;this-&gt;m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line">	//成员函数实现不了p &lt;&lt;cout不是我们想要的效果 </span><br><span class="line">	//void operator&lt;&lt;(Person&amp; p)&#123;</span><br><span class="line">	//&#125;</span><br><span class="line">private :</span><br><span class="line">	int m_A;</span><br><span class="line">	int m_B;</span><br><span class="line">&#125;;</span><br><span class="line">//全局函数实现左移重载</span><br><span class="line">//ostream对象只能有一个</span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; cout，Person&amp; p)&#123;</span><br><span class="line">	out &lt;&lt; &quot;a: &quot; &lt;&lt; p.m_A &lt;&lt; &quot; b:&quot; &lt;&lt; p.m_B;</span><br><span class="line">	return cout;</span><br><span class="line">&#125;</span><br><span class="line">void test() &#123;</span><br><span class="line">	Person p1(10，20);</span><br><span class="line">	cout &lt;&lt;p1 &lt;&lt; &quot;hello world&quot; &lt;&lt;endl;//链式编程,需要返回ostream&amp;,才可以接着后面运算</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:重载左移运算符配合友元可以实现输出自定义数据类型</p>
<h3 id="递增运算符重载"><a href="#递增运算符重载" class="headerlink" title="递增运算符重载"></a>递增运算符重载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class MyInteger &#123;</span><br><span class="line">	friend ostream&amp; operator&lt;&lt;(ostream&amp; out,MyInteger myint);</span><br><span class="line">public:</span><br><span class="line">	MyInteger() &#123;</span><br><span class="line">		m_Num = 0;</span><br><span class="line">	&#125;</span><br><span class="line">	//前置++</span><br><span class="line">	MyInteger&amp; operator++()</span><br><span class="line">	&#123;</span><br><span class="line">		//先++</span><br><span class="line">		m_Num++;</span><br><span class="line">		//再返回自身</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	//后置++</span><br><span class="line">	MyInteger operator++(int) &#123;</span><br><span class="line">		//先返回</span><br><span class="line">		MyInteger temp = *this;//记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++;</span><br><span class="line">		m_Num++;</span><br><span class="line">		return temp;//temp是临时变量，完了会释放，所以不会返回引用</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	int m_Num;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; out,MyInteger myint) &#123;</span><br><span class="line">	out &lt;&lt; myint.m_Num;</span><br><span class="line">	return out;</span><br><span class="line">&#125;</span><br><span class="line">//前置++ 先++ 再返回</span><br><span class="line">void test01() &#123;</span><br><span class="line">	MyInteger myInt;</span><br><span class="line">	cout&lt;&lt;(++myInt)++ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt;myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//后置++ 先返回 再++</span><br><span class="line">void test02() &#123;</span><br><span class="line">	MyInteger myInt;</span><br><span class="line">	cout &lt;&lt; myInt++ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	test01();</span><br><span class="line">	//test02();</span><br><span class="line">	system( &quot;pause&quot; );</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:前置递增返回引用，后置递增返回值</p>
<h3 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h3><p>C++编译器至少给一个类添加4个函数</p>
<ul>
<li>1.默认构造函数(无参，函数体为空)</li>
<li>⒉.默认析构函数(无参，函数体为空)</li>
<li>3.默认拷贝构造函数，对属性进行值拷贝</li>
<li>4.赋值运算符operator&#x3D;,对属性进行值拷贝</li>
</ul>
<p><strong>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">	Person( int age)&#123;</span><br><span class="line">	//将年龄数据开辟到堆区</span><br><span class="line">	m_Age = new int(age);</span><br><span class="line">	&#125;</span><br><span class="line">	//重载赋值运算符</span><br><span class="line">	person&amp; operator=(Person &amp;p)&#123;</span><br><span class="line">		if (m_Age != NULL)&#123;</span><br><span class="line">			delete m_Age;</span><br><span class="line">			m_Age = NULL;</span><br><span class="line">		&#125;</span><br><span class="line">		//编译器提供的代码是浅拷贝</span><br><span class="line">		// m_Age = p.m_Age;</span><br><span class="line">		//提供深拷贝解决浅拷贝的问题</span><br><span class="line">		m_Age = new int(*p.m_Age);</span><br><span class="line">		//返回自身,保证了下面能连等</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	~Person()&#123;</span><br><span class="line">		if (m_Age != NULL)&#123;</span><br><span class="line">			delete m_Age;</span><br><span class="line">			m_Age = NULL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//年龄的指针</span><br><span class="line">	int *m_Age;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()&#123;</span><br><span class="line">	Person p1 (18);</span><br><span class="line">	Person p2(20);</span><br><span class="line">	Person p3( 30);</span><br><span class="line"> 	p3=p2= p1;//赋值操作</span><br><span class="line">	cout &lt;&lt;&quot;p1的年龄为:&quot;&lt;&lt;*p1.m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;p2的年龄为:&quot; &lt;&lt;*p2.m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;p3的年龄为:&quot; &lt;&lt;*p3.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h3><p>作用:重载关系运算符，可以让两个<strong>自定义类型对象</strong>进行对比操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">	Person( string name，int age)&#123;</span><br><span class="line">		this-&gt;m_Name = name;</span><br><span class="line">		this-&gt;m_Age = age;</span><br><span class="line">	&#125;;</span><br><span class="line">	bool operator==(Person &amp; p)&#123;</span><br><span class="line">		if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)&#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	bool operator ! =( Person &amp; p)&#123;</span><br><span class="line">		if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)&#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	string m_Name;</span><br><span class="line">	int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	Person a(&quot;孙悟空&quot;，18);</span><br><span class="line">	Person b(&quot;孙悟空&quot;，18);</span><br><span class="line">	if ( a == b)</span><br><span class="line">	&#123;</span><br><span class="line">    	cout &lt;&lt; &quot;a和b相等”&quot;&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">    cout &lt;&lt; &quot;a和b不等”&quot;&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    if (a !=b)&#123;</span><br><span class="line">		cout &lt;&lt;&quot;a和b不相等&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		cout &lt;&lt; &quot;a和b相等”&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a>函数调用运算符重载</h3><p>函数调用运算符()也可以重载</p>
<p>由于重载后使用的方式非常像函数的调用，因此称为仿函数</p>
<p>仿函数没有固定写法，非常灵活</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class MyPrint&#123;</span><br><span class="line">public:</span><br><span class="line">	void operator()(string text)&#123;</span><br><span class="line">		cout &lt;&lt; text &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()&#123;</span><br><span class="line">	//重载的()操作符也称为仿函数</span><br><span class="line">	MyPrint myFunc;</span><br><span class="line">	myFunc( &quot;hello world&quot; ) ;</span><br><span class="line">&#125;</span><br><span class="line">class MyAdd&#123;</span><br><span class="line">public:</span><br><span class="line">	int operator()(int v1,int v2)&#123;</span><br><span class="line">		return v1 +v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test02()&#123;</span><br><span class="line">	MyAdd add;</span><br><span class="line">	int ret = add(10，10);</span><br><span class="line">	cout &lt;&lt; &quot;ret - &quot; &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">	//匿名对象调用</span><br><span class="line">	cout &lt;&lt;&quot;MyAdd()(100,100) = &quot; &lt;&lt; MyAdd() (100，100) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="继承的基本语法"><a href="#继承的基本语法" class="headerlink" title="继承的基本语法"></a>继承的基本语法</h3><p>继承的好处:减少重复代码</p>
<p>语法:class 	子类:	继承方式	父类</p>
<p>子类也称为派生类</p>
<p>父类也称为基类</p>
<h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p>继承的语法:class子类∶继承方式父类</p>
<p>继承方式一共有三种:</p>
<ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承</li>
</ul>
<p><img src="C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20230402164555514.png" alt="image-20230402164555514"></p>
<p>保护权限和私有权限类外都访问不到。</p>
<h3 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Base&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_A;</span><br><span class="line">protected:</span><br><span class="line">	int m_B;</span><br><span class="line">private:</span><br><span class="line">	int m_c; //私有成员只是被隐藏了，但是还是会继承下去</span><br><span class="line">&#125;;</span><br><span class="line">//公共继承</span><br><span class="line">class Son :public Base&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_D;</span><br><span class="line">&#125;;</span><br><span class="line">void teste1()&#123;</span><br><span class="line">	cout &lt;&lt; &quot;sizeof Son = &quot; &lt;&lt; sizeof(Son)&lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论:父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p>
<h3 id="继承中构造和析构顺序"><a href="#继承中构造和析构顺序" class="headerlink" title="继承中构造和析构顺序"></a>继承中构造和析构顺序</h3><p>子拳继承父类后，当创建子类对象，也会调用父类的构造函数</p>
<p>问题:父类和子类的构造和析构顺序是谁先谁后?</p>
<p>总结:继承中先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p>
<h3 id="4-6-5继承同名成员处理方式"><a href="#4-6-5继承同名成员处理方式" class="headerlink" title="4.6.5继承同名成员处理方式"></a>4.6.5继承同名成员处理方式</h3><p>问题:当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢?</p>
<p>访问子类同名成员直接访问即可</p>
<p>访问父类同名成员需要加作用域</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">	Base()&#123;</span><br><span class="line">		m_A = 100;</span><br><span class="line">	&#125;</span><br><span class="line">	void func()&#123;</span><br><span class="line">		cout &lt;&lt;&quot;Base - func()调用”&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	void func(int a)&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Base - func ( int a)调用&quot;&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	int m_A;</span><br><span class="line">&#125;;</span><br><span class="line">class son : public Base &#123;</span><br><span class="line">public:</span><br><span class="line">	son()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A= 200;</span><br><span class="line">	&#125;</span><br><span class="line">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span><br><span class="line">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span><br><span class="line">	void func()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Son - func()调用&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	int m_A;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()&#123;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; &quot;Son下的m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;Base下的m_A = &quot; &lt;&lt; s.Base::m_A&lt;&lt; endl;</span><br><span class="line">	s.func();</span><br><span class="line">	s.Base::func();</span><br><span class="line">	s.Base::func(10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:<br>1.子类对象可以直接访问到子类中同名成员</p>
<p>2.子类对象加作用域可以访问到父类同名成员</p>
<p>3.当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</p>
<h3 id="继承同名静态成员处理方式"><a href="#继承同名静态成员处理方式" class="headerlink" title="继承同名静态成员处理方式"></a>继承同名静态成员处理方式</h3><p>问题:继承中同名的静态成员在子类对象上如何进行访问?</p>
<p>静态成员和非静态成员出现同名，处理方式—致</p>
<p>·访问子类同名成员直接访问即可</p>
<p>·访问父类同名成员需要加作用域</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">	static void func()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Base - static void func()&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static void func(int a)&#123;</span><br><span class="line">		cout &lt;&lt;&quot;Base - static void func( int a)&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	static int m_A;</span><br><span class="line">&#125;;</span><br><span class="line">int Base::m_A = 100;</span><br><span class="line">class Son : public Base&#123;</span><br><span class="line">public:</span><br><span class="line">	static void func()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Son - static void func()&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	static int m_A;</span><br><span class="line">&#125;;</span><br><span class="line">int Son::m_A = 200;</span><br><span class="line">//同名成员属性</span><br><span class="line">void test01()&#123;</span><br><span class="line">	//通过对象访问</span><br><span class="line">	cout &lt;&lt;“通过对象访问:&quot;&lt;&lt;endl;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; &quot;Son 下m_A =&quot; &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;Base 下m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line">	//通过类名访问</span><br><span class="line">	cout &lt;&lt;“通过类名访问:“ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;Son下m_A = &quot; &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">	cout&lt;&lt; &quot;Base 下m_A = &quot; &lt;&lt;Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//同名成员函数</span><br><span class="line">void test02()&#123;&#125;</span><br><span class="line">	//通过对象访问</span><br><span class="line">	cout &lt;&lt;“通过对象访问:“ &lt;&lt;endl;</span><br><span class="line">	Son s;</span><br><span class="line">	s.func();</span><br><span class="line">	s.Base::func( );</span><br><span class="line">	cout &lt;&lt;“通过类名访问:&quot; &lt;&lt; endl ;</span><br><span class="line">	Son::func();</span><br><span class="line">	son::Base::func();</span><br><span class="line">	//出现同名。子类会隐藏掉父类中所有同名成员函数，需要加作用域访问</span><br><span class="line">	Son::Base::func(100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式(通过对象和通过类名）</p>
<h3 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h3><p>C++允许一个类继承多个类</p>
<p>语法:	class	子类	∶	继承方式	父类1 ，继承方式	父类2…{};</p>
<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>
<p>C++实际开发中不建议用多继承</p>
<p>总结:多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p>
<h3 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line">//继承前加virtual关键字后，变为虚继承//此时公共的父类Animal称为虚基类</span><br><span class="line">class sheep : virtual public Animal&#123;&#125;;</span><br><span class="line">class Tuo: virtual public Animal &#123;&#125;;</span><br><span class="line">class SheepTuo : public Sheep，public Tuo &#123;&#125;;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	sheepTuo st;</span><br><span class="line">	st.Sheep::m_Age = 100;</span><br><span class="line">	st.Tuo::m_Age = 200;//指向的是一样的地址，第二个是后改变的，用后面的数据</span><br><span class="line">	cout &lt;&lt; &quot;st.Sheep::m_Age = &quot;&lt;&lt; st.sheep:: m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;st.Tuo : :m_Age = &quot;&lt;&lt;st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;st.m_Age =&quot; &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:<br>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</p>
<p>利用虚继承可以解决菱形继承问题</p>
<p>虚继承底层原理：</p>
<p><img src="C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20230402175305513.png" alt="image-20230402175305513"></p>
<p>vbptr相当于指针，指向一个虚基类表，表中记录了偏移量，指针加上偏移量，指向了唯一的数据。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/31/c%E5%92%8Cc++/%E7%AC%AC%E4%B8%89%E5%A4%A9-c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/31/c%E5%92%8Cc++/%E7%AC%AC%E4%B8%89%E5%A4%A9-c/" class="post-title-link" itemprop="url">第三天 c++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-31 09:53:22" itemprop="dateCreated datePublished" datetime="2023-03-31T09:53:22+08:00">2023-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-01 21:04:23" itemprop="dateModified" datetime="2023-04-01T21:04:23+08:00">2023-04-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="函数提高"><a href="#函数提高" class="headerlink" title="函数提高"></a>函数提高</h1><h2 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h2><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p>
<p>语法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">返回值类型	函数名	(参数=默认值)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//参数值传递会覆盖默认参数</span><br><span class="line">int func(int a,int b=20,int c=30)&#123;</span><br><span class="line">return a+b+c;</span><br><span class="line">&#125;</span><br><span class="line">//注意事项</span><br><span class="line">//1.错误，默认参数在前面则后面也必须默认值</span><br><span class="line">//int func2(int a=10,int b,int c)&#123;</span><br><span class="line">//return a+b+c;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//2.如果函数声明有默认值，函数实现的时候不能有默认参数，相反依此</span><br><span class="line">int func2(int a,intb);</span><br><span class="line">int func2(int a=10,int b=10)&#123;</span><br><span class="line">	return a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">func(10,30,30);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//函数重载的注意事项</span><br><span class="line">//1、引用作为重载的条件</span><br><span class="line">void func (int &amp;a)//int &amp;a = 10;不合法</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;func(int &amp;a)调用&quot;&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void func (const int &amp;a) // const int &amp;a = 10;合法代码</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt; &quot;func (const int &amp;a)调用&quot;&lt;&lt; end1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int a=10;</span><br><span class="line">	func(a);//输出第一个</span><br><span class="line">	func(10);//输出第二个</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类中的属性和行为我们统一称为成员</p>
<p>属性称为	成员属性	成员变量</p>
<p>行为称为	成员函数	成员方法</p>
<h2 id="封装意义"><a href="#封装意义" class="headerlink" title="封装意义:"></a>封装意义:</h2><p>类在设计时，可以把属性和行为放在不同的权限下，加以控制访问权限有三种:</p>
<p>1.public	公共权限</p>
<p>2.protected	保护权限</p>
<p>3.private	私有权限<br>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//三种权限</span><br><span class="line">//公共权限public	类内可以访问类外可以访问</span><br><span class="line">//保护权限protected	类内可以访问类外不可以访问</span><br><span class="line">//私有权限private	类内可以访问类外不可以访问</span><br></pre></td></tr></table></figure>

<h2 id="struct和class区别"><a href="#struct和class区别" class="headerlink" title="struct和class区别"></a>struct和class区别</h2><p>在C++中struct和class唯—的区别就在于默认的访问权限不同</p>
<p>区别:<br>struct默认权限为公共</p>
<p>class 默认权限为私有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class C1&#123;</span><br><span class="line">	int m_A;//默认是私有权限</span><br><span class="line">&#125;;</span><br><span class="line">struct C2&#123;</span><br><span class="line">	int m_A;//默认是公共权限</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结构体声明通常不包括public或private的访问修饰符。</p>
<p>struct是为了兼容c而存在的,在以后尽量使用class.</p>
<h2 id="成员属性设置为私有"><a href="#成员属性设置为私有" class="headerlink" title="成员属性设置为私有"></a>成员属性设置为私有</h2><p>优点1:将所有成员属性设置为私有，可以自己控制读写权限。</p>
<p>优点2:对于写权限，我们可以检测数据的有效性。</p>
<h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">	//1.构造函数</span><br><span class="line">	//没有返回值不用写void//函数名与类名相同</span><br><span class="line">	//构造函数可以有参数，可以发生重载</span><br><span class="line">	//创建对象的时候，构造函数会自动调用，而且只调用一次</span><br><span class="line">	Person()</span><br><span class="line">	&#123;</span><br><span class="line">	cout &lt;&lt;&quot;Person构造函数的调用&quot;&lt;&lt; end1;</span><br><span class="line">	&#125;</span><br><span class="line">	Person(int age)</span><br><span class="line">	&#123;</span><br><span class="line">	cout &lt;&lt;&quot;Person有参构造函数的调用&quot;&lt;&lt; end1;</span><br><span class="line">	&#125;</span><br><span class="line">	//1.2拷贝构造函数</span><br><span class="line">	Person( const Person &amp;p )&#123;</span><br><span class="line">	//将传入的人身上的所有属性，拷贝到我身上</span><br><span class="line">	age = p.age;</span><br><span class="line">	&#125;</span><br><span class="line">	//2.析构函数进行清理的操作</span><br><span class="line">	//没有返回值不写void</span><br><span class="line">	//函数名和类名相同在名称前加~</span><br><span class="line">	//析构函数不可以有参数的，不可以发生重载</span><br><span class="line">	//对象在销毁前会自动调用析构函数，而且只会调用一次</span><br><span class="line">	~Person()</span><br><span class="line">	&#123;</span><br><span class="line">	cout &lt;&lt;&quot;Person析构函数的调用&quot;&lt;&lt; end1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">	Person p2=Person(10);//有参构造，也可写成Person p2(10);</span><br><span class="line">	Person p3=Person(p2);//拷贝构造,也可写成Person p3(p2);</span><br><span class="line">	//注意:调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明(void fuc();)</span><br><span class="line">	Person p2();</span><br><span class="line">	Person(10);//匿名对象﹑特点:当前行执行结束后，系统会立即回收掉匿名对象</span><br><span class="line">	//不要利用拷贝构造函数初始化匿名对象瞭编译器会认为Person (p3) === Person p3;</span><br><span class="line">	//Person(p3);//错误的</span><br><span class="line">	//3、隐式转换法</span><br><span class="line">	Person p4 = 10; //相当于写了Person p4 = Person(10) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造和析构都是必须有的实现，如果我们自己不提供，编译器会提供一个空实现的构造和析构</p>
<h2 id="拷贝构造函数调用时机"><a href="#拷贝构造函数调用时机" class="headerlink" title="拷贝构造函数调用时机"></a>拷贝构造函数调用时机</h2><p>C++中拷贝构造函数调用时机通常有三种情况：</p>
<p>使用一个已经创建完毕的对象来初始化一个新对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p2=Person(10);//有参构造，也可写成Person p2(10);</span><br><span class="line">Person p3=Person(p2);//拷贝构造,也可写成Person p3(p2);</span><br></pre></td></tr></table></figure>



<p>值传递的方式给函数参数传值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void doWork ( Person p)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void test02()&#123;</span><br><span class="line">	Person p;//相当于值传递，调用了拷贝函数</span><br><span class="line">	doWork(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以值方式返回局部对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person doWork2()&#123;</span><br><span class="line">	Person pl;</span><br><span class="line">	return p1;//p1是局部对象，会拷贝一个新的person类型返回</span><br><span class="line">&#125;</span><br><span class="line">void test03 ()&#123;</span><br><span class="line">	Person p = doWork2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造函数调用规则"><a href="#构造函数调用规则" class="headerlink" title="构造函数调用规则"></a>构造函数调用规则</h2><p>默认情况下，c++编译器至少给一个类添加3个函数</p>
<p>1．默认构造函数(无参，函数体为空)</p>
<p>2．默认析构函数(无参，函数体为空)</p>
<p>3．默认拷贝构造函数，对属性进行值拷贝</p>
<p>构造函数调用规则如下:</p>
<ul>
<li>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造。</li>
<li>如果用户定义拷贝构造函数，C++不会再提供其他构造函数。（拷贝构造函数也是有参数的，所以编译器不会提供无参构造函数了）</li>
</ul>
<h2 id="4-2-5深拷贝与浅拷贝"><a href="#4-2-5深拷贝与浅拷贝" class="headerlink" title="4.2.5深拷贝与浅拷贝"></a>4.2.5深拷贝与浅拷贝</h2><p>深浅拷贝是面试经典问题，也是常见的一个坑</p>
<p>浅拷贝:简单的赋值拷贝操作</p>
<p>深拷贝:在堆区重新申请空间，进行拷贝操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Person (int age , int height)</span><br><span class="line">&#123;</span><br><span class="line">	m_Age = age;</span><br><span class="line">	m_Height =new int(height) ;//创建堆区</span><br><span class="line">	cout &lt;&lt; &quot;Person的有参构造函数调用&quot;&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">/*自己实现拷贝构造函数解决浅拷贝带来的问题</span><br><span class="line">若不自己实现，则有问题，浅拷贝是对成员变量的简单赋值,拷贝时会直接拷贝堆的地址,所以p2的height指针=p1的height指针,即两个height指针指向堆区的同一个地址</span><br><span class="line">p2在进行拷贝初婚化时使用的是编译器提供的浅拷贝</span><br><span class="line">函数test01结束后，p1和p2把同一个空间释放了两次。所以程序崩了</span><br><span class="line">*/</span><br><span class="line">Person(const Person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;Person拷贝构造函数调用&quot;&lt;&lt; endl;</span><br><span class="line">	m_Age = p.m_Age;</span><br><span class="line">	//m_Height = p.m_Height;编译器默认实现就是这行代码</span><br><span class="line">	//深拷贝操作</span><br><span class="line">	m_Height = new int(*p.m_Height) ;</span><br><span class="line">&#125;</span><br><span class="line">~Person()</span><br><span class="line">&#123;</span><br><span class="line">//析构代码，将堆区开辟数据做释放操作</span><br><span class="line">	if (m_Height != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		delete m_Height;</span><br><span class="line">		m_Height = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt;&quot;Person的析构函数调用&quot;&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">	int m_Age;</span><br><span class="line">	int *m_Height;</span><br></pre></td></tr></table></figure>

<p>总结:如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p>
<h2 id="4-2-6初始化列表"><a href="#4-2-6初始化列表" class="headerlink" title="4.2.6初始化列表"></a>4.2.6初始化列表</h2><p>作用:</p>
<p>C++提供了初始化列表语法，用来初始化属性</p>
<p>语法:构造函数()∶属性1(值1) ,属性2(值2) … {}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">	//初始化列表初始化属性</span><br><span class="line">    Person(int a, int , int c) :m_A(a), m_B(b), m_c(c)</span><br><span class="line">    &#123;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &#125;</span><br><span class="line">    int m_A;</span><br><span class="line">    int m_B;</span><br><span class="line">    int m_C;</span><br></pre></td></tr></table></figure>

<h2 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h2><p>C++类中的成员可以是另一个类的对象，我们称该成员为对象成员<br>例如∶</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;&#125;</span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">	A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>B类中有对象A作为成员，A为对象成员</p>
<p>当其他类对象作为本类成员，构造时候先构造类对象(A)，再构造自身(B ),析构的顺序与构造相反，取木块同理。不可能直接取前面的那个，只有将后面的先取出来才能取到前面的那个。<br>而创建对象也是。我需要用phone对象补全person就需要先创建phone而person因为在后面，所以取的时候先取它。</p>
<h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p>
<p>静态成员分为:</p>
<ul>
<li>静态成员变量</li>
</ul>
<p>所有对象共享同一份数据。</p>
<p>在编译阶段分配内存。编译阶段就分配内存─代码还未开始前(即程序还未运行前),在全局区优先分配好内存</p>
<p>类内声明，类外初始化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	//1所有对象都共享同一份数据</span><br><span class="line">	//2编译阶段就分配内存</span><br><span class="line">	//3类内声明，类外初始化操作</span><br><span class="line">	static int m_A;</span><br><span class="line">private:</span><br><span class="line">	static int m_B;//静态成员变量也是有访问权限的，私有的类外访问不到</span><br><span class="line">&#125;;</span><br><span class="line">int Person::m_A = 100;//这里强调一下，是必须在类外写一下，否则报错，可以不付初值，默认初值是0,加Person是为了说明他是Person类的static </span><br><span class="line">int Person::m_B = 100;</span><br><span class="line">void test()&#123;</span><br><span class="line">	//静态成员变量不属于某个对象上，所有对象都共享同一份数据</span><br><span class="line">	//因此静态成员变量有两种访问方式</span><br><span class="line">	//1、通过对象进行访问</span><br><span class="line">	Person p;</span><br><span class="line">	cout &lt;&lt; p.m_A &lt;&lt; endl;</span><br><span class="line">	//2、通过类名进行访问</span><br><span class="line">	cout &lt;&lt;Person::m_A &lt;&lt; end1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>静态成员函数</li>
</ul>
<p>所有对象共享同一个函数</p>
<p>静态成员函数只能访问静态成员变量，因为如果静态成员函数里有非静态成员变量，class会判断不出非静态成员变量是在什么地方定义的,所以无法确定是否是类成员</p>
<p>静态成员函数也是有访问权限的，私有的类外访问不到静态成员函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//因此静态函数有两种访问方式</span><br><span class="line">	//1、通过对象进行访问</span><br><span class="line">	Person p;</span><br><span class="line">	p.func();</span><br><span class="line">	//2、通过类名进行访问</span><br><span class="line">	Person::func();</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/30/c%E5%92%8Cc++/%E7%AC%AC%E4%BA%8C%E5%A4%A9-c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/30/c%E5%92%8Cc++/%E7%AC%AC%E4%BA%8C%E5%A4%A9-c/" class="post-title-link" itemprop="url">第二天 c++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-30 16:01:35 / 修改时间：22:02:12" itemprop="dateCreated datePublished" datetime="2023-03-30T16:01:35+08:00">2023-03-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h1><p>指针变量指向内存中编号为0的空间</p>
<p>用途:初始化指针变量</p>
<p>注意:空指针指向的内存（0-255）是不可以访问的，因为这些初始化的内存往往是系统的一些中断，若想赋值，只能定义其它数值，再把地址赋予指针变量，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">int b = 20;</span><br><span class="line">int *p=nullptr;</span><br><span class="line">p=&amp;a;</span><br><span class="line">cout &lt;&lt;*p &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h1 id="const修饰指针"><a href="#const修饰指针" class="headerlink" title="const修饰指针"></a>const修饰指针</h1><p>理解一个<strong>指针常量</strong>的地址是固定的不能更改（int * const p;），但是该地址里面的值是可以更改的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int * const p=&amp;a;</span><br><span class="line">*p=100;//正确的</span><br><span class="line">p=&amp;b;//错误的</span><br></pre></td></tr></table></figure>

<p><strong>常量指针</strong>的地址可变（const int *p;），但是值不能变。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const int *p=&amp;a;</span><br><span class="line">*p=100;//错误的</span><br><span class="line">p=&amp;b;//正确的，可以改变指向来改变值</span><br></pre></td></tr></table></figure>

<p>const即修饰指针,又修饰常量，指针指向和指向的值都不能变(const int * const p;)。</p>
<p>connst是一个c语言的关键字，具有着举足轻重的地位。它限定一个变量不允许被改变，产生静态作用。使用const在一定程度上可以提高程序的安全性和可靠性。</p>
<p>const修饰规律:修饰的是什么，什么不能（通过此变量)改变。</p>
<p>const修饰结构体（如const student *stu）,可以防止误操作修改stu的值。</p>
<p>其实本质上const关键字只是告诉编译器该修饰的变量不可以被修改，并不能改变它修饰的变量在内存中所存放的区域。即const修饰的全局变量还是在全局区，但是修饰局部变量则在局部区。</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">system(&quot;pause&quot;);//按任意键继续</span><br><span class="line">system(&quot;cls&quot;);//清屏</span><br></pre></td></tr></table></figure>

<h1 id="内存分区模型"><a href="#内存分区模型" class="headerlink" title="内存分区模型"></a>内存分区模型</h1><p>代码区:存放函数体的二进制代码，由操作系统进行管理的·全局区:存放全局变量和静态变量以及常量。</p>
<p>栈区:由编译器自动分配释放,存放函数的参数值,局部变量等。</p>
<p>堆区:由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收。</p>
<p>内存四区意义:</p>
<p>不同区域存放的数据，赋予不同的生命周期,给我们更大的灵活编程。</p>
<h2 id="程序运行前"><a href="#程序运行前" class="headerlink" title="程序运行前"></a>程序运行前</h2><p>在程序<strong>编译</strong>后，生成了exe可执行程序，<strong>未执行</strong>该程序前分为两个区域</p>
<p><strong>代码区</strong>:</p>
<p>存放CPU执行的机器指令</p>
<p>代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可代码区是只读的，使其</p>
<p>只读的原因是防止程序意外地修改了它的指令</p>
<p><strong>全局区</strong>:</p>
<p>全局变量和静态变量存放在此.全局区还包含了常量区,字符串常量和其他常量也存放在此.该区域的数据在程序结</p>
<p>后由操作系统释放.</p>
<h2 id="程序运行后"><a href="#程序运行后" class="headerlink" title="程序运行后"></a>程序运行后</h2><p><strong>栈区</strong>：</p>
<p>由编译器自动分配释放,存放函数的参数值,局部变量等。</p>
<p>注意事项:不要返回局部变量的地址，栈区开辟的数据由编译器自动释放。</p>
<p><strong>堆区：</strong></p>
<p>由程序员分配释放,若程序员不释放,程序结束时由操作系统回收。在C++中主要利用new在堆区开辟内存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//利用new关键字，可以将数据开辟到堆区,new返回的该数据类型的指针。</span><br><span class="line">//指针本质也是局部变量，放在栈上，指针保存的数据是放在堆区。</span><br><span class="line">int *p=new int(10);//堆区存放10，p是地址</span><br><span class="line">int *arr=new int[10];//创建数组，10个连续的地址</span><br><span class="line">delete[] arr;//释放数组要加[]</span><br><span class="line">delete p;//释放内存</span><br></pre></td></tr></table></figure>

<p>不释放动态内存有个专有名词，叫内存泄漏，内存泄漏就是这块数据已经不需要了，但是没有将这块数据清除，</p>
<p>会一直占用内存，这就是内存泄漏。内存数据放硬盘上的操作叫进程的挂起。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//引用基本语法</span><br><span class="line">//数据类型 &amp;别名=原名</span><br><span class="line">int a = 10;</span><br><span class="line">//创建引用</span><br><span class="line">int &amp;b = a;</span><br><span class="line">cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; end1;</span><br><span class="line">cout &lt;&lt; &quot;b = &quot; &lt;&lt; b&lt;&lt; endl;//两个输出一样,即两个指向同一个地址</span><br></pre></td></tr></table></figure>

<h2 id="引用注意事项"><a href="#引用注意事项" class="headerlink" title="引用注意事项"></a>引用注意事项</h2><p>引用必须初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int &amp;b;//错误的</span><br></pre></td></tr></table></figure>

<p>引用在初始化后，不可以改变。即b已经是a的别名，则不能是c的别名。</p>
<h2 id="引用做函数参数"><a href="#引用做函数参数" class="headerlink" title="引用做函数参数"></a>引用做函数参数</h2><p><strong>作用</strong>:函数传参时，可以利用引用的技术让形参修饰实参。</p>
<p><strong>优点</strong>:可以简化指针修改实参</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void swap(&amp;a,&amp;b)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">swap(a,b);//引用传递，形参会修饰实参的,在传递时就已经初始化了，即&amp;a=a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单。</p>
<h2 id="引用做函数的返回值"><a href="#引用做函数的返回值" class="headerlink" title="引用做函数的返回值"></a>引用做函数的返回值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//1、不要返回局部变量的引用</span><br><span class="line">int&amp; test01()</span><br><span class="line">&#123;</span><br><span class="line">int a = 10;//局部变量存放在四区中的栈区</span><br><span class="line">return a;//返回的是int&amp;类型</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//2、函数的调用可以作为左值,即在main函数可以这样写test02()=1000；则ref输出也会变1000</span><br><span class="line">//返回静态变量引用</span><br><span class="line">int&amp; test02()</span><br><span class="line">&#123;</span><br><span class="line">static int a = 20;//此时可以输出正确，因为static</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int &amp;ref = test01();//接受的也需要int&amp;类型,&amp;ref是a的别名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;&quot;ref=&quot;&lt;&lt;ref&lt;&lt;endl;//第一次结果正确，是因为编译器做了保留，局部变量的返回也是如此</span><br><span class="line">Cout&lt;&lt;“ref=“&lt;&lt;ref&lt;&lt;endl;//第二次结果错误，因为a的内存已经释放</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h2><p>引用相当于指针常量，指向的值能改但指向不能改（即指向地址不变）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int&amp; ref=a;//自动转换为int * const ref=&amp;a;</span><br><span class="line">ref=20;//内部发现ref是引用，自动转换为：*ref =20;</span><br></pre></td></tr></table></figure>

<p>指针常量是不能拿函数当左值的,所以引用不仅仅是懒人版指针。</p>
<p>引用的地址和原变量是一样的，指针和原变量的地址不一样。所以引用更省空间。</p>
<p>结论:C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了。 </p>
<h2 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//引用通常修饰形参（val）</span><br><span class="line">void showValue(const int &amp;val)&#123;</span><br><span class="line">	//val=1000;//const防止误操作，相当于这个函教是传入了一个常量指针常量。既不能修改值，又不能修改指向，如果没有const，val修改则main函数的a值也会改变,相当于前面地址传递。</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	//int&amp; ref = 10;引用本身需要一个合法的内存空间，因此这行错误</span><br><span class="line">	const int&amp; ref - 10;//加入const就可以了，编译器会优化这行代码为int temp = 10; const int&amp; ref = temp;temp是临时变量</span><br><span class="line">	int a=100;</span><br><span class="line">	showValue(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/29/c%E5%92%8Cc++/%E7%AC%AC%E4%B8%80%E5%A4%A9-c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/29/c%E5%92%8Cc++/%E7%AC%AC%E4%B8%80%E5%A4%A9-c/" class="post-title-link" itemprop="url">第一天 c++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-29 11:21:09" itemprop="dateCreated datePublished" datetime="2023-03-29T11:21:09+08:00">2023-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-30 16:14:57" itemprop="dateModified" datetime="2023-03-30T16:14:57+08:00">2023-03-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="函数的分文件编写"><a href="#函数的分文件编写" class="headerlink" title="函数的分文件编写"></a>函数的分文件编写</h1><p>1、创建后缀名为.h的头文件<br>2、创建后缀名为.cpp的源文件<br>3、在头文件中写函数声明<br>4、在源文件中写函数的定义</p>
<p>示例：（求最大值）<br>1、创建后缀名为.h的头文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//max.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//3、函数声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br></pre></td></tr></table></figure>

<p>2、创建后缀名为.cpp的源文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//max.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;max.h&quot;</span><span class="comment">//&quot; &quot;表示是我们自己定义的头文件</span></span></span><br><span class="line"><span class="comment">//4、函数的定义</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;<span class="comment">//三目运算符，返回最大值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>max.cpp</code>中包含我们自己定义的头文件<code>&quot;max.h&quot;</code>说明其与<code>&quot;max.h&quot;</code>是配套的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;max.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	max(a, b);</span><br><span class="line"> 	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>main函数中也只需要引用我们自己定义的<code>&quot;max.h&quot;</code>即可<br>就不用再写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>

<p>因为其已在<code>&quot;max.h&quot;</code>头文件中包含了</p>
<p>最后在注意一点，一个项目中只能有一个main函数！！！</p>
<hr>
<p>总结：</p>
<ol>
<li>创建后缀名为.h的头文件，在头文件中写函数的声明，也就是我们自己封装好的函数的各个函数名。</li>
<li>创建后缀名为.cpp的源文件，在源文件中写函数的定义，也就是在源文件中封装代表各个功能的函数，方便调用。</li>
<li>创建主函数（main)文件，调用我们想用的各个封装函数，实现功能。</li>
</ol>
<p>在终端运行mingw(按tab补全)，得到结果，注意，千万不要用右上角的run code执行！</p>
<p>再用<img src="C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20230329213057548.png" alt="image-20230329213057548"></p>
<p>如果运行后显示中文乱码可以试试下面的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span><span class="comment">//用于函数SetConsoleOutputCP(65001);更改cmd编码为utf8</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">SetConsoleOutputCP</span>(<span class="number">65001</span>);</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;中文正常显示&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次如此运行后需要更改代码需要重新此步骤</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/25/c%E5%92%8Cc++/%E7%AC%AC%E5%8D%81%E5%A4%A9-c%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/25/c%E5%92%8Cc++/%E7%AC%AC%E5%8D%81%E5%A4%A9-c%E8%AF%AD%E8%A8%80/" class="post-title-link" itemprop="url">第十天 c语言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-25 14:53:39" itemprop="dateCreated datePublished" datetime="2023-03-25T14:53:39+08:00">2023-03-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-27 20:30:19" itemprop="dateModified" datetime="2023-03-27T20:30:19+08:00">2023-03-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C-命令行参数"><a href="#C-命令行参数" class="headerlink" title="C 命令行参数"></a>C 命令行参数</h1><p>执行程序时，可以从命令行传值给 C 程序。这些值被称为<strong>命令行参数</strong>，它们对程序很重要，特别是当您想从外部控制程序，而不是在代码内对这些值进行硬编码时，就显得尤为重要了。</p>
<p>命令行参数是使用 main() 函数参数来处理的，其中，<strong>argc</strong> 是指传入参数的个数，<strong>argv[]</strong> 是一个指针数组，指向传递给程序的每个参数。下面是一个简单的实例，检查命令行是否有提供参数，并根据参数执行相应的动作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main( int argc, char *argv[] )  </span><br><span class="line">&#123;</span><br><span class="line">//应当指出的是，argv[0] 存储程序的名称(编译文件的名称)，argv[1] 是一个指向第一个命令行参数的指针，*argv[n] 是最后一个参数。如果没有提供任何参数，argc 将为 1，否则，如果传递了一个参数，argc 将被设置为 2。</span><br><span class="line"></span><br><span class="line">//多个命令行参数之间用空格分隔，但是如果参数本身带有空格，那么传递参数的时候应把参数放置在双引号 &quot;&quot; 或单引号 &#x27;&#x27; 内部(&quot;&quot;里面表示一个参数)。让我们重新编写上面的实例，有一个空间，那么你可以通过这样的观点，把它们放在双引号或单引号&quot;&quot;&quot;&quot;。让我们重新编写上面的实例，向程序传递一个放置在双引号内部的命令行参数：</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main 的两个参数的参数名如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int main( int argc, char *argv[] )</span><br></pre></td></tr></table></figure>

<p>并不一定这样写，只是约定俗成罢了。但是亦可以写成下面这样:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int main( int test_argc, char *test_argv[] )  </span><br></pre></td></tr></table></figure>

<hr>
<p><strong>冒泡排序</strong>是一种<strong>稳定</strong>的排序方式！</p>
<p><strong>选择排序</strong>是一种<strong>不稳定</strong>的排序方式！</p>
<p>所谓<strong>稳定</strong>，就是指排完序后序列的各个元素的下标不会改变，如：冒泡排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1;i &lt;= n - 1;i ++)</span><br><span class="line"> for (int j = 1;j &lt;= n - i;j ++)</span><br><span class="line">  if (a[j] &gt; a[j + 1]) swap(a[j],a[j + 1]);</span><br></pre></td></tr></table></figure>

<p>第零趟：<strong>2</strong>,3,2,1</p>
<p>第一趟：<strong>2</strong> 2 1 3 </p>
<p>2： <strong>2</strong> 1 2 3</p>
<p>3:    1 <strong>2</strong> 2 3</p>
<p>排完之后，加粗的2还在前面。</p>
<p>所谓<strong>不稳定</strong>，恰恰相反，如：选择排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1;i &lt;= n - 1;i ++)</span><br><span class="line"> for (int j = i + 1;j &lt;= n;j ++)</span><br><span class="line">  if (a[i] &gt; a[j]) swap(a[i],a[j]);</span><br></pre></td></tr></table></figure>

<p>第零趟：<strong>2</strong> 3 2 1</p>
<p>第一趟：1 3 2 <strong>2</strong></p>
<p>第二趟：1 2 3 <strong>2</strong></p>
<p>3:1 2 <strong>2</strong> 3</p>
<p>排完之后，加粗的2到后面去了。</p>
<p><strong>稳定性</strong>非常重要！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/23/c%E5%92%8Cc++/%E7%AC%AC%E4%B9%9D%E5%A4%A9-c%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/23/c%E5%92%8Cc++/%E7%AC%AC%E4%B9%9D%E5%A4%A9-c%E8%AF%AD%E8%A8%80/" class="post-title-link" itemprop="url">第九天 c语言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-23 14:43:06 / 修改时间：21:07:01" itemprop="dateCreated datePublished" datetime="2023-03-23T14:43:06+08:00">2023-03-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C 内存管理"></a>C 内存管理</h1><p>C 语言为内存的分配和管理提供了几个函数。这些函数可以在 <strong>&lt;stdlib.h&gt;</strong> 头文件中找到。</p>
<p>1.stdlib.h中的几个函数操作内存；calloc(）分配指定个数指定大小的连续内存块，返回值是这些连续内存块组成的大内存块地址；malloc()分配指定大小的一块内存，返回值是内存的地址；realloc()通过已分配的内存块的地址扩展或者减小内存的大小；free()释放指定地址对应的内存块，无返回值；alloc是allocate 分配的缩写；malloc mess+allocate 整块的分配</p>
<p>2.stdlib中几个内存管理的函数返回值是 void *,表示任意类型的指针，或者说它可以转化成任意类型；</p>
<p>3.内存管理的意义：数组、基本数据类型、结构体、共用体都是固定的为数据分配内存空间，而内存管理却可以直接申请一块内存，然后给其指定存储的数据类型，之后就可以存储数据了，且还可以根据数据的大小来扩展内存空间；</p>
<hr>
<p>malloc与calloc没有本质区别，malloc之后的未初始化内存可以使用memset进行初始化。</p>
<p>主要的不同是malloc不初始化分配的内存，calloc初始化已分配的内存为0。</p>
<p>次要的不同是calloc返回的是一个数组，而malloc返回的是一个对象。</p>
<p>calloc等于malloc后再memset，所以malloc比calloc更高效。</p>
<p>分配内存空间函数malloc 调用形式: (类型说明符*) malloc (size) 。</p>
<p>分配内存空间函数 calloc calloc 也用于分配内存空间。</p>
<p>为什么多用malloc而很少用calloc？</p>
<p>因为calloc虽然对内存进行了初始化（全部初始化为0），</p>
<p>calloc相当于</p>
<p>p &#x3D; malloc();</p>
<p>memset(p, 0,size);(C 库函数 <strong>void *memset(void *str, int c, size_t n)</strong> 复制字符 <strong>c</strong>（一个无符号字符）到参数 <strong>str</strong> 所指向的字符串的前 <strong>n</strong> 个字符。)</p>
<p>相对于malloc多了对内存的写零操作，而写零这个操作我们有时候需要，而大部分时间不需要。</p>
<hr>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数和描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>void *calloc(int num, int size);</strong> 在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是 0。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>void free(void *address);</strong> 该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>void *malloc(int num);</strong> 在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>void *realloc(void *address, int newsize);</strong> 该函数重新分配内存，把内存扩展到 <strong>newsize</strong>。</td>
</tr>
</tbody></table>
<p>直接使用原来的指针变量接收 <strong>realloc</strong> 的返回值是可能存在内存泄漏的。例如以下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">description = (char *) realloc( description, 100 * sizeof(char) );</span><br></pre></td></tr></table></figure>

<p>若 realloc 函数执行失败，description 原先所指向的空间不变，realloc 函数返回 NULL。</p>
<p>此时 description 的值被赋为 NULL, 但原先指向的空间未被释放，造成了内存泄漏。（内存泄漏 （Memory leak）是在计算机科学中，由于疏忽或错误造成程序未能释放已经不再使用的内存 。 内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。 内存泄漏通常情况下只能由获得程序源代码的程序员才能分析出来。）</p>
<hr>
<p><strong>注意：</strong>void * 类型表示未确定类型的指针。C、C++ 规定 void * 类型可以通过类型转换强制转换为任何其它类型的指针。</p>
<p><strong>注：</strong>void 指针可以任意类型的数据，可以在程序中给我们带来一些好处，函数中形为指针类型时，我们可以将其定义为 void 指针，这样函数就可以接受任意类型的指针。</p>
<p>void 指针可以指向任意类型的数据，就是说可以用任意类型的指针对 void 指针对 void 指针赋值。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int *a；</span><br><span class="line">void *p；</span><br><span class="line">p=a；</span><br></pre></td></tr></table></figure>

<p>如果要将 void 指针 p 赋给其他类型的指针，则需要强制类型转换，就本例而言：<strong>a&#x3D;（int *）p</strong>。</p>
<p>对于 void 指针，GNU 认为 <strong>void *</strong> 和 <strong>char *</strong> 一样，所以以下写法是正确的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">description = malloc( 200 * sizeof(char) );</span><br></pre></td></tr></table></figure>

<p>但按照 ANSI(American National Standards Institute) 标准，需要对 void 指针进行强制转换，如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">description = (char *)malloc( 200 * sizeof(char) );</span><br></pre></td></tr></table></figure>

<p>同时，按照 ANSI(American National Standards Institute) 标准，不能对 void 指针进行算法操作:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void * pvoid;</span><br><span class="line">pvoid++; //ANSI：错误</span><br><span class="line">pvoid += 1; //ANSI：错误</span><br><span class="line">// ANSI标准之所以这样认定，是因为它坚持：进行算法操作的指针必须是确定知道其指向数据类型大小的。</span><br><span class="line"></span><br><span class="line">int *pint;</span><br><span class="line">pint++; //ANSI：正确</span><br></pre></td></tr></table></figure>

<p>在实际的程序设计中，为迎合 ANSI 标准，并提高程序的可移植性，我们可以这样编写实现同样功能的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void * pvoid;</span><br><span class="line">((char *)pvoid)++; //ANSI：错误；GNU：正确</span><br><span class="line">(char *)pvoid += 1; //ANSI：错误；GNU：正确</span><br></pre></td></tr></table></figure>

<h2 id="动态分配内存"><a href="#动态分配内存" class="headerlink" title="动态分配内存"></a>动态分配内存</h2><p>预先不知道需要存储的文本长度，例如您想存储有关一个主题的详细描述。在这里，我们需要定义一个指针，该指针指向未定义所需内存大小的字符，后续再根据需求来分配内存，如下所示：</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   char name[100];</span><br><span class="line">   char *description;</span><br><span class="line"> </span><br><span class="line">   strcpy(name, &quot;Zara Ali&quot;);</span><br><span class="line"> </span><br><span class="line">   /* 动态分配内存 */</span><br><span class="line">   description = (char *)malloc( 200 * sizeof(char) );</span><br><span class="line">   if( description == NULL )</span><br><span class="line">   &#123;</span><br><span class="line">      fprintf(stderr, &quot;Error - unable to allocate required memory\n&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">      strcpy( description, &quot;Zara ali a DPS student in class 10th&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   printf(&quot;Name = %s\n&quot;, name );</span><br><span class="line">   printf(&quot;Description: %s\n&quot;, description );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序也可以使用 <strong>calloc()</strong> 来编写，只需要把 malloc 替换为 calloc 即可，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">calloc(200, sizeof(char));</span><br></pre></td></tr></table></figure>

<p>当动态分配内存时，您有完全控制权，可以传递任何大小的值。而那些预先定义了大小的数组，一旦定义则无法改变大小。</p>
<h2 id="重新调整内存的大小和释放内存"><a href="#重新调整内存的大小和释放内存" class="headerlink" title="重新调整内存的大小和释放内存"></a>重新调整内存的大小和释放内存</h2><p>当程序退出时，操作系统会自动释放所有分配给程序的内存，但是，建议您在不需要内存时，都应该调用函数 <strong>free()</strong> 来释放内存。</p>
<p>或者，您可以通过调用函数 <strong>realloc()</strong> 来增加或减少已分配的内存块的大小。让我们使用 realloc() 和 free() 函数，再次查看上面的实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   char name[100];</span><br><span class="line">   char *description;</span><br><span class="line"> </span><br><span class="line">   strcpy(name, &quot;Zara Ali&quot;);</span><br><span class="line"> </span><br><span class="line">   /* 动态分配内存 */</span><br><span class="line">   description = (char *)malloc( 30 * sizeof(char) );</span><br><span class="line">   if( description == NULL )</span><br><span class="line">   &#123;</span><br><span class="line">      fprintf(stderr, &quot;Error - unable to allocate required memory\n&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">      strcpy( description, &quot;Zara ali a DPS student.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   /* 假设您想要存储更大的描述信息 */</span><br><span class="line">   description = (char *) realloc( description, 100 * sizeof(char) );</span><br><span class="line">   if( description == NULL )</span><br><span class="line">   &#123;</span><br><span class="line">      fprintf(stderr, &quot;Error - unable to allocate required memory\n&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">      strcat( description, &quot;She is in class 10th&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   printf(&quot;Name = %s\n&quot;, name );</span><br><span class="line">   printf(&quot;Description: %s\n&quot;, description );</span><br><span class="line"> </span><br><span class="line">   /* 使用 free() 函数释放内存 */</span><br><span class="line">   free(description);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尝试一下不重新分配额外的内存，strcat() 函数会生成一个错误，因为存储 description 时可用的内存不足。</p>
<hr>
<p>动态可变长的结构体：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  int id;</span><br><span class="line">  char name[0];</span><br><span class="line">&#125;stu_t;</span><br></pre></td></tr></table></figure>

<p>定义该结构体，只占用4字节的内存，name不占用内存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stu_t *s = NULL;    //定义一个结构体指针</span><br><span class="line">s = malloc(sizeof(*s) + 100);//sizeof(*s)获取的是4，但加上了100，4字节给id成员使用，100字节是属于name成员的</span><br><span class="line">s-&gt;id = 1010;</span><br><span class="line">strcpy(s-&gt;name,&quot;hello&quot;);</span><br></pre></td></tr></table></figure>

<p>注意：一个结构体中只能有一个可变长的成员，并且该成员必须是最后一个成员。</p>
<h3 id="C-语言中常用的内存管理函数和运算符"><a href="#C-语言中常用的内存管理函数和运算符" class="headerlink" title="C 语言中常用的内存管理函数和运算符"></a>C 语言中常用的内存管理函数和运算符</h3><ul>
<li>malloc() 函数：用于动态分配内存。它接受一个参数，即需要分配的内存大小（以字节为单位），并返回一个指向分配内存的指针。</li>
<li>free() 函数：用于释放先前分配的内存。它接受一个指向要释放内存的指针作为参数，并将该内存标记为未使用状态。</li>
<li>calloc() 函数：用于动态分配内存，并将其初始化为零。它接受两个参数，即需要分配的内存块数和每个内存块的大小（以字节为单位），并返回一个指向分配内存的指针。</li>
<li>realloc() 函数：用于重新分配内存。它接受两个参数，即一个先前分配的指针和一个新的内存大小，然后尝试重新调整先前分配的内存块的大小。如果调整成功，它将返回一个指向重新分配内存的指针，否则返回一个空指针。</li>
<li>sizeof 运算符：用于获取数据类型或变量的大小（以字节为单位）。</li>
<li>指针运算符：用于获取指针所指向的内存地址或变量的值。</li>
<li>&amp; 运算符：用于获取变量的内存地址。</li>
<li>***** 运算符：用于获取指针所指向的变量的值。</li>
<li><strong>-&gt;</strong> 运算符：用于指针访问结构体成员，语法为 <strong>pointer-&gt;member</strong>，等价于 <strong>(*pointer).member</strong>。</li>
<li>memcpy() 函数：用于从源内存区域复制数据到目标内存区域。它接受三个参数，即目标内存区域的指针、源内存区域的指针和要复制的数据大小（以字节为单位）。<strong>void *memcpy(void *str1, const void *str2, size_t n)</strong> 从存储区 <strong>str2</strong> 复制 <strong>n</strong> 个字节到存储区 <strong>str1</strong>。该函数返回一个指向目标存储区 str1 的指针。</li>
<li>memmove() 函数：类似于 memcpy() 函数，但它可以处理重叠的内存区域。它接受三个参数，即目标内存区域的指针、源内存区域的指针和要复制的数据大小（以字节为单位）。<strong>void *memmove(void *str1, const void *str2, size_t n)</strong> 从 <strong>str2</strong> 复制 <strong>n</strong> 个字符到 <strong>str1</strong>，但是在重叠内存块这方面，memmove() 是比 memcpy() 更安全的方法。如果目标区域和源区域有重叠的话，memmove() 能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中，复制后源区域的内容会被更改。如果目标区域与源区域没有重叠，则和 memcpy() 函数功能相同。</li>
</ul>
<p>任何类型的指针都可以传入 memcpy 和 memset 中</p>
<hr>
<p>对于我们手动分配的内存，在 C 语言中是不用强制转换类型的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">description = malloc( 200 * sizeof(char) ); // C 语言正确。</span><br><span class="line">description = malloc( 200 * sizeof(char) ); // C++ 错误</span><br></pre></td></tr></table></figure>

<p>但是 C++ 是强制要求的，不然会报错。</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/22/c%E5%92%8Cc++/%E7%AC%AC%E5%85%AB%E5%A4%A9-c%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/22/c%E5%92%8Cc++/%E7%AC%AC%E5%85%AB%E5%A4%A9-c%E8%AF%AD%E8%A8%80/" class="post-title-link" itemprop="url">第八天 c语言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-22 16:14:02" itemprop="dateCreated datePublished" datetime="2023-03-22T16:14:02+08:00">2023-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-23 14:43:19" itemprop="dateModified" datetime="2023-03-23T14:43:19+08:00">2023-03-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C递归"><a href="#C递归" class="headerlink" title="C递归"></a>C递归</h1><p>递归是一个简洁的概念，同时也是一种很有用的手段。但是，使用递归是要付出代价的。与直接的语句(如while循环)相比，递归函数会<strong>耗费更多的运行时间，并且要占用大量的栈空间</strong>。递归函数每次调用自身时，都需要把它的状态存到栈中，以便在它调用完自身后，程序可以返回到它原来的状态。未经精心设计的递归函数总是会带来麻烦。</p>
<p>电脑空间大致分<strong>Heap（堆）</strong>和<strong>Stack（栈）</strong>两种。</p>
<p><strong>栈</strong>是用于<strong>函数</strong>的空间。</p>
<p>电脑调用一个函数，就会使用一层栈；</p>
<p>相反，电脑中一个函数结束（return），就会释放这一层栈，<strong>连同在这层栈（这个函数）中定义的所有东西</strong>。</p>
<p>不在栈中的，应该就在堆中。<strong>（这就是定义全区变量与局部变量的用处）</strong></p>
<p>如果调用太多层栈（太多个函数），电脑就会暴空间！</p>
<p>所以说，调用递归函数，就会<strong>一层一层地压栈</strong>，<strong>电脑就会暴空间！</strong>（<strong>并不代表不建议用递归，只是作提示而已</strong>）</p>
<p><strong>栈：</strong></p>
<p>在函数中定义的变量存放的内存区域。常见的int、float、char等变量均存放于栈区中，它的特点是由系统自动分配与释放，不需要程序员考虑资源回收的问题，方便简洁。ps：栈区的地址分配是从内存的高地址开始向地地址分配；</p>
<p><strong>堆：</strong></p>
<p>通过指令自主向系统申请的内存区域，大小由自己决定，它在使用完后同样需要自己通过指令去释放该区域内存，否则将有可能出现内存的浪费与溢出。</p>
<p>C语言中申请堆区指令为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = (<span class="type">int</span> *) <span class="built_in">malloc</span>( N * <span class="keyword">sizeof</span>(<span class="type">int</span>) );  <span class="comment">//分配N个int型(4字节)的内存，即 4 * N 个字节</span></span><br></pre></td></tr></table></figure>

<p>ps：<strong>但指针p存放于栈区，指向堆</strong>。</p>
<p>C语言中释放堆区指令为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>( p ); <span class="comment">//注意此处参数为指针</span></span><br></pre></td></tr></table></figure>

<p>使用中应该注意，尽量不要去修改p指针对应的地址值，否则在内存释放时将出现错误。(编译可通过，运行出现问题)</p>
<p><strong>bss区：</strong></p>
<p>通常是指用来存放程序中未初始化的全局变量的一块内存区域，由static修饰，BSS是英文Block Started by Symbol的简称，BSS段属于静态内存分配。ps：静态变量仅在第一次创建时初始化一次，之后自动跳过初始化语句。全局变量与静态变量均由系统分配和释放内存，若未对它们进行初始化操作，系统将自动将其值设置为0。(堆区与栈区则不会)</p>
<p><strong>代码段：</strong></p>
<p>代码段(code segment&#x2F;text segment)通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。常见的使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *s = <span class="string">&quot;HelloWorld&quot;</span>;<span class="comment">//该字符串 HelloWorld 即存放于文字常量区，不可修改。</span></span><br></pre></td></tr></table></figure>

<p>ps：但指针s存放于栈区。</p>
<p>pps：若在程序中尝试对其修改（例如尝试修改第一个字符 *s &#x3D; ‘h’;），将出现编译可通过，运行报错的情况。</p>
<p>同时因注意它与const修饰的变量之间的区别：char aa &#x3D; ‘A’;&#x2F;&#x2F;aa存放于栈区；const char bb &#x3D; ‘B’; &#x2F;&#x2F;bb同样存放于栈区，const修饰的变量仅仅用于告诉编译器bb是一个常量，如果后续的程序中有出现尝试修改bb的操作时，编译将报错。这种写法主要是为了防止程序员在后续的代码中误操作bb变量而添加的一个约束条件，并不会影响它存放的位置。</p>
<h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> val1 = <span class="number">1</span>;        <span class="comment">//val1存放在.data段</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> val2 = <span class="number">1</span>;               <span class="comment">//初始化的全局变量存放在.data段</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> val3 ;                  <span class="comment">//未初始化的全局变量存放在.bss段</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> val4 = <span class="number">1</span>;         <span class="comment">//val4存放在.rodata（只读数据段）</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Demo</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num)</span> <span class="comment">//num 存放在栈区</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> var = <span class="string">&quot;123456&quot;</span>;               <span class="comment">//var存放在栈区，&quot;123456&quot;存放在常量区</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> num1 = <span class="number">1</span> ;            <span class="comment">//num1存放在栈区</span></span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> num2 = <span class="number">0</span>;      <span class="comment">//num2存放在.data段</span></span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> num3 = <span class="number">7</span>;       <span class="comment">//num3存放在栈区</span></span><br><span class="line">  <span class="type">void</span> *p;</span><br><span class="line">  p = <span class="built_in">malloc</span>(<span class="number">8</span>);                     <span class="comment">//p存放在堆区，但指针p存放于栈区，指向堆</span></span><br><span class="line">  <span class="built_in">free</span>(p);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> num = <span class="number">0</span> ;</span><br><span class="line">  num = Demo(num);                   <span class="comment">//Demo()函数的返回值存放在栈区。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DATA 段（全局初始化区）存放初始化的全局变量和静态变量；BSS 段（全局未初始化区）存放未初始化的全局变量和静态变量。</p>
<p>静态局部变量时在编译时被赋值的，即自始至终<strong>只赋值一次</strong>，在程序运行时它已经有初值。以后每次调用函数时不再重新赋初值而只是保留上次函数调用结束时的值。而自动变量赋初值，不是在编译时进行的，而是在<strong>运行时进行</strong>，所以<strong>每调用一次函数就赋一次初值</strong>。</p>
<h1 id="C-可变参数"><a href="#C-可变参数" class="headerlink" title="C 可变参数"></a>C 可变参数</h1><p>有时，您可能会碰到这样的情况，您希望函数带有可变数量的参数，而不是预定义数量的参数。</p>
<p>C 语言为这种情况提供了一个解决方案，它允许您定义一个函数，能根据具体的需求接受可变数量的参数。</p>
<p>声明方式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int func_name(int arg1, ...);</span><br></pre></td></tr></table></figure>

<p>其中，省略号 <strong>…</strong> 表示可变参数列表。</p>
<p>下面的实例演示了这种函数的使用：</p>
<p>int func(int, … )  {   .   .   . }  int main() {   func(2, 2, 3);   func(3, 2, 3, 4); }</p>
<p>请注意，函数 <strong>func()</strong> 最后一个参数写成省略号，即三个点号（**…**），省略号之前的那个参数是 <strong>int</strong>，代表了要传递的可变参数的总数。为了使用这个功能，您需要使用 <strong>stdarg.h</strong> 头文件，该文件提供了实现可变参数功能的函数和宏。具体步骤如下：</p>
<ul>
<li>定义一个函数，最后一个参数为省略号，省略号前面可以设置自定义参数。</li>
<li>在函数定义中创建一个 <strong>va_list</strong> 类型变量，该类型是在 stdarg.h 头文件中定义的。</li>
<li>使用 <strong>int</strong> 参数和 <strong>va_start()</strong> 宏来初始化 <strong>va_list</strong> 变量为一个参数列表。宏 <strong>va_start()</strong> 是在 stdarg.h 头文件中定义的。</li>
<li>使用 <strong>va_arg()</strong> 宏和 <strong>va_list</strong> 变量来访问参数列表中的每个项。</li>
<li>使用宏 <strong>va_end()</strong> 来清理赋予 <strong>va_list</strong> 变量的内存。</li>
</ul>
<p>常用的宏有：</p>
<ul>
<li><code>**va_start(ap, last_arg)**</code>：初始化可变参数列表。<code>ap</code> 是一个 <code>va_list</code> 类型的变量，<code>last_arg</code> 是最后一个固定参数的名称（也就是可变参数列表之前的参数）。该宏将 <code>ap</code> 指向可变参数列表中的第一个参数。</li>
<li><code>**va_arg(ap, type)**</code>：获取可变参数列表中的下一个参数。<code>ap</code> 是一个 <code>va_list</code> 类型的变量，<code>type</code> 是下一个参数的类型。该宏返回类型为 <code>type</code> 的值，并将 <code>ap</code> 指向下一个参数。</li>
<li>va_copy(va_list dest, va_list src) 宏：用于将src指向的参数复制到dest中。</li>
<li><code>**va_end(ap)**</code>：结束可变参数列表的访问。<code>ap</code> 是一个 <code>va_list</code> 类型的变量。该宏将 <code>ap</code> 置为 <code>NULL</code>。</li>
</ul>
<p>现在让我们按照上面的步骤，来编写一个带有可变数量参数的函数，并返回它们的平均值：</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdarg.h&gt;</span><br><span class="line"> </span><br><span class="line">double average(int num,...)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    va_list valist;</span><br><span class="line">    double sum = 0.0;</span><br><span class="line">    int i;</span><br><span class="line"> </span><br><span class="line">    /* 为 num 个参数初始化 valist */</span><br><span class="line">    va_start(valist, num);</span><br><span class="line"> </span><br><span class="line">    /* 访问所有赋给 valist 的参数 */</span><br><span class="line">    for (i = 0; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       sum += va_arg(valist, int); // 获取当前参数，并将指针移动到下一个参数</span><br><span class="line">    &#125;</span><br><span class="line">    /* 清理为 valist 保留的内存 */</span><br><span class="line">    va_end(valist);</span><br><span class="line"> </span><br><span class="line">    return sum/num;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;Average of 2, 3, 4, 5 = %f\n&quot;, average(4,2,3,4,5));</span><br><span class="line">   printf(&quot;Average of 5, 10, 15 = %f\n&quot;, average(3,5,10,15));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，average() 函数接受一个整数 num 和任意数量的整数参数。函数内部使用 va_list 类型的变量 va_list 来访问可变参数列表。在循环中，每次使用 va_arg() 宏获取下一个整数参数，并输出。最后，在函数结束时使用 va_end() 宏结束可变参数列表的访问。</p>
<p>当上面的代码被编译和执行时，它会产生下列结果。应该指出的是，函数 <strong>average()</strong> 被调用两次，每次第一个参数都是表示被传的可变参数的总数。省略号被用来传递可变数量的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Average of 2, 3, 4, 5 = 3.500000</span><br><span class="line">Average of 5, 10, 15 = 10.000000</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 本质上，va_list 类型，就是「char指针」类型，指向 1B 大小的内存地址</span><br><span class="line">typedef char* va_list;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">肖汇林</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">肖汇林</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
