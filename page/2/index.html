<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="选择有时候比努力更重要">
<meta property="og:type" content="website">
<meta property="og:title" content="肖汇林的博客">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="肖汇林的博客">
<meta property="og:description" content="选择有时候比努力更重要">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="肖汇林">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>肖汇林的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖汇林的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/18/%E7%AC%AC%E5%9B%9B%E5%A4%A9-c%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/18/%E7%AC%AC%E5%9B%9B%E5%A4%A9-c%E8%AF%AD%E8%A8%80/" class="post-title-link" itemprop="url">第四天 c语言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-18 14:53:58 / 修改时间：20:44:28" itemprop="dateCreated datePublished" datetime="2023-03-18T14:53:58+08:00">2023-03-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><h2 id="函数指针作为某个函数的参数"><a href="#函数指针作为某个函数的参数" class="headerlink" title="函数指针作为某个函数的参数"></a>函数指针作为某个函数的参数</h2><p>函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。</p>
<p>简单讲：回调函数是由别人的函数执行时调用你实现的函数。</p>
<blockquote>
<p>以下是来自知乎作者常溪玲的解说：</p>
<p>你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。</p>
</blockquote>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>实例中 <strong>populate_array()</strong> 函数定义了三个参数，其中第三个参数是函数的指针，通过该函数来设置数组的值。</p>
<p>实例中我们定义了回调函数 **getNextRandomValue()**，它返回一个随机值，它作为一个函数指针传递给 <strong>populate_array()</strong> 函数。</p>
<p><strong>populate_array()</strong> 将调用 <strong>10</strong> 次回调函数，并将回调函数的返回值赋值给数组。</p>
<p><strong>回调函数最大的意义在于解耦，降低了代码之间的耦合度。</strong></p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">void populate_array(int *array, size_t arraySize, int (*getNextValue)(void))</span><br><span class="line">&#123;  /*有关于 size_t:size_t 是一种数据类型，近似于无符号整型，但容量范围一般大于 int 和 unsigned。这里使用 size_t 是为了保证 arraysize 变量能够有足够大的容量来储存可能大的数组。*/</span><br><span class="line">    for (size_t i=0; i&lt;arraySize; i++)</span><br><span class="line">        array[i] = getNextValue();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 获取随机值</span><br><span class="line">int getNextRandomValue(void)</span><br><span class="line">&#123;</span><br><span class="line">    return rand();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int myarray[10];</span><br><span class="line">    /* getNextRandomValue 不能加括号，否则无法编译，因为加上括号之后相当于传入此参数时传入了 int , 而不是函数指针*/</span><br><span class="line">    populate_array(myarray, 10, getNextRandomValue);</span><br><span class="line">    for(int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        printf(&quot;%d &quot;, myarray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>size_t 类型在C语言标准库函数原型使用的很多，数值范围一般是要大于int和unsigned.</p>
<p>但凡不涉及负值范围的表示size取值的，都可以用size_t；比如array[size_t]。</p>
<p>size_t 在stddef.h头文件中定义。</p>
<p>在其他常见的宏定义以及函数中常用到有：</p>
<p>1，sizeof运算符返回的结果是size_t类型；</p>
<p>2，void *malloc(size_t size)…</p>
<hr>
<h1 id="C字符串"><a href="#C字符串" class="headerlink" title="C字符串"></a>C字符串</h1><p>字符串在以如下输入进行初始化的时候需要对 <strong>\0</strong> 特别注意：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char greeting[6] = &#123;&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;\0&#x27;&#125;;</span><br></pre></td></tr></table></figure>

<p>如果没有在字符数组最后增加 <strong>\0</strong> 的话输出结果有误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 初始化字符串</span><br><span class="line">char greeting[5] = &#123; &#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27; &#125;;</span><br><span class="line">printf(&quot;Greeting message: %s\n&quot;, greeting);</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Greeting message: Hello烫烫烫?侵7(?╔?╚╔╔</span><br></pre></td></tr></table></figure>

<p>在使用不定长数组初始化字符串时默认结尾为 <strong>\0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char greeting[] = &quot;Hello&quot;;</span><br><span class="line">printf(&quot;Greeting message: %s, greeting[] Length: %d\n&quot;, greeting, sizeof(greeting));</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Greeting message: Hello, greeting[] Length: 6</span><br></pre></td></tr></table></figure>

<p><strong>结论：</strong>需在给定字符数组的大小时在原有的字符串的字符数上加 1。</p>
<hr>
<p><strong>strlen 与 sizeof的区别：</strong></p>
<p>strlen 是函数，sizeof 是运算操作符，二者得到的结果类型为 size_t，即 unsigned int 类型。</p>
<p>sizeof 计算的是变量的大小，不受字符 <strong>\0</strong> 影响；</p>
<p>sizeof() 计算字符串的长度，包含末尾的 ‘\0’;</p>
<h5 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char s[] = &quot;Hello, world!&quot;;</span><br><span class="line">sizeof(s) ;// 输出 14，即字符串 s 中有 14 个字符（包括结尾的空字符 &#x27;\0&#x27;）</span><br></pre></td></tr></table></figure>

<p>而 strlen 计算的是字符串的长度，以 <strong>\0</strong> 作为长度判定依据。strlen() 函数只能用于计算以空字符 ‘\0’ 结尾的字符串的长度，如果字符串中没有空字符，则 strlen() 函数的行为是未定义的.</p>
<p>其中 string 是一个以空字符 ‘\0’ 结尾的字符串，但是计算字符串的长度，不包含末尾的 ‘\0’。例如：</p>
<h5 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char s[] = &quot;Hello, world!&quot;;</span><br><span class="line">strlen(s) ;// 输出 13，即字符串 s 中有 13 个字符（不包括结尾的空字符 &#x27;\0&#x27;）</span><br></pre></td></tr></table></figure>

<p>sizeof 可以用类型做参数，<strong>strlen</strong> 只能用 <strong>char*</strong> 做参数，且必须是以 <strong>\0</strong> 结尾的。</p>
<p>sizeof 还可以用函数做参数，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">short f();</span><br><span class="line">printf(&quot;%d\n&quot;, sizeof(f()));</span><br></pre></td></tr></table></figure>

<p>输出的结果是 sizeof(short)，即 2。</p>
<p>数组做 <strong>sizeof</strong> 的参数不退化，传递给 <strong>strlen</strong> 就退化为指针了。</p>
<p>大部分编译程序在编译的时候就把 <strong>sizeof</strong> 计算过了，是类型或是变量的长度，这就是 <strong>sizeof(x)</strong> 可以用来定义数组维数的原因。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char str[20]=&quot;0123456789&quot;;</span><br><span class="line">int a=strlen(str); // a=10;</span><br><span class="line">int b=sizeof(str); // 而 b=20;</span><br></pre></td></tr></table></figure>

<p>strlen 的结果要在运行的时候才能计算出来，是用来计算字符串的长度，不是类型占内存的大小。</p>
<p>数组作为参数传给函数时传的是指针而不是数组，传递的是数组的首地址， 如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun(char [8])</span><br><span class="line">fun(char [])</span><br></pre></td></tr></table></figure>

<p>都等价于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun(char *) </span><br></pre></td></tr></table></figure>

<p>在 C++ 里参数传递数组永远都是传递指向数组首元素的指针，编译器不知道数组的大小。</p>
<hr>
<p><strong>‘a’</strong> 表示是一个字符，**”a”** 表示一个字符串相当于 <strong>‘a’+’\0’</strong>;</p>
<p><strong>‘’</strong> 里面只能放一个字符;</p>
<p><strong>“”</strong> 里面表示是字符串系统自动会在串末尾补一个 0。</p>
<hr>
<h1 id="C结构体"><a href="#C结构体" class="headerlink" title="C结构体"></a>C结构体</h1><p>结构体定义由关键字 <strong>struct</strong> 和结构体名组成，结构体名可以根据需要自行定义。</p>
<p>struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct tag &#123; </span><br><span class="line">    member-list</span><br><span class="line">    member-list </span><br><span class="line">    member-list  </span><br><span class="line">    ...</span><br><span class="line">&#125; variable-list ;</span><br></pre></td></tr></table></figure>

<p>在一般情况下，<strong>tag、member-list、variable-list</strong> 这 3 部分至少要出现 2 个。以下为实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">在一般情况下，tag、member-list、variable-list 这 3 部分至少要出现 2 个。以下为实例：</span><br><span class="line"></span><br><span class="line">//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c</span><br><span class="line">//同时又声明了结构体变量s1</span><br><span class="line">//这个结构体并没有标明其标签</span><br><span class="line">struct </span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    char b;</span><br><span class="line">    double c;</span><br><span class="line">&#125; s1;</span><br><span class="line"> </span><br><span class="line">//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c</span><br><span class="line">//结构体的标签被命名为SIMPLE,没有声明变量</span><br><span class="line">struct SIMPLE</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    char b;</span><br><span class="line">    double c;</span><br><span class="line">&#125;;</span><br><span class="line">//用SIMPLE标签的结构体，另外声明了变量t1、t2、t3</span><br><span class="line">struct SIMPLE t1, t2[20], *t3;</span><br><span class="line"> </span><br><span class="line">//也可以用typedef创建新类型</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    char b;</span><br><span class="line">    double c; </span><br><span class="line">&#125; Simple2;</span><br><span class="line">//现在可以用Simple2作为类型声明新的结构体变量</span><br><span class="line">Simple2 u1, u2[20], *u3;</span><br><span class="line">在上面的声明中，第一个和第二声明被编译器当作两个完全不同的类型，即使他们的成员列表是一样的，如果令 t3=&amp;s1，则是非法的。</span><br><span class="line"></span><br><span class="line">结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针，而通常这种指针的应用是为了实现一些更高级的数据结构如链表和树等。</span><br><span class="line"></span><br><span class="line">//此结构体的声明包含了其他的结构体</span><br><span class="line">struct COMPLEX</span><br><span class="line">&#123;</span><br><span class="line">    char string[100];</span><br><span class="line">    struct SIMPLE a;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">//此结构体的声明包含了指向自己类型的指针</span><br><span class="line">struct NODE</span><br><span class="line">&#123;</span><br><span class="line">    char string[100];</span><br><span class="line">    struct NODE *next_node;</span><br><span class="line">&#125;;</span><br><span class="line">如果两个结构体互相包含，则需要对其中一个结构体进行不完整声明，如下所示：</span><br><span class="line"></span><br><span class="line">struct B;    //对结构体B进行不完整声明</span><br><span class="line"> </span><br><span class="line">//结构体A中包含指向结构体B的指针</span><br><span class="line">struct A</span><br><span class="line">&#123;</span><br><span class="line">    struct B *partner;</span><br><span class="line">    //other members;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">//结构体B中包含指向结构体A的指针，在A声明完后，B也随之进行声明</span><br><span class="line">struct B</span><br><span class="line">&#123;</span><br><span class="line">    struct A *partner;</span><br><span class="line">    //other members;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的声明中，第一个和第二声明被编译器当作两个完全不同的类型，即使他们的成员列表是一样的，如果令 t3&#x3D;&amp;s1，则是非法的。</p>
<p>结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针，而通常这种指针的应用是为了实现一些更高级的数据结构如链表和树等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//此结构体的声明包含了其他的结构体</span><br><span class="line">struct COMPLEX</span><br><span class="line">&#123;</span><br><span class="line">    char string[100];</span><br><span class="line">    struct SIMPLE a;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">//此结构体的声明包含了指向自己类型的指针</span><br><span class="line">struct NODE</span><br><span class="line">&#123;</span><br><span class="line">    char string[100];</span><br><span class="line">    struct NODE *next_node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果两个结构体互相包含，则需要对其中一个结构体进行不完整声明，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct B;    //对结构体B进行不完整声明</span><br><span class="line"> </span><br><span class="line">//结构体A中包含指向结构体B的指针</span><br><span class="line">struct A</span><br><span class="line">&#123;</span><br><span class="line">    struct B *partner;</span><br><span class="line">    //other members;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">//结构体B中包含指向结构体A的指针，在A声明完后，B也随之进行声明</span><br><span class="line">struct B</span><br><span class="line">&#123;</span><br><span class="line">    struct A *partner;</span><br><span class="line">    //other members;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="指向结构的指针"><a href="#指向结构的指针" class="headerlink" title="指向结构的指针"></a>指向结构的指针</h2><p>您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct Books *struct_pointer;</span><br></pre></td></tr></table></figure>

<p>现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 &amp; 运算符放在结构名称的前面，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct_pointer = &amp;Book1;</span><br></pre></td></tr></table></figure>

<p>为了使用指向该结构的指针访问结构的成员，您必须使用 -&gt; 运算符，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct_pointer-&gt;title;</span><br></pre></td></tr></table></figure>

<p>让我们使用结构指针来重写上面的实例，这将有助于您理解结构指针的概念：</p>
<h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">struct Books</span><br><span class="line">&#123;</span><br><span class="line">   char  title[50];</span><br><span class="line">   char  author[50];</span><br><span class="line">   char  subject[100];</span><br><span class="line">   int   book_id;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">/* 函数声明 */</span><br><span class="line">void printBook( struct Books *book );</span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   struct Books Book1;        /* 声明 Book1，类型为 Books */</span><br><span class="line">   struct Books Book2;        /* 声明 Book2，类型为 Books */</span><br><span class="line"> </span><br><span class="line">   /* Book1 详述 */</span><br><span class="line">   strcpy( Book1.title, &quot;C Programming&quot;);</span><br><span class="line">   strcpy( Book1.author, &quot;Nuha Ali&quot;); </span><br><span class="line">   strcpy( Book1.subject, &quot;C Programming Tutorial&quot;);</span><br><span class="line">   Book1.book_id = 6495407;</span><br><span class="line"> </span><br><span class="line">   /* Book2 详述 */</span><br><span class="line">   strcpy( Book2.title, &quot;Telecom Billing&quot;);</span><br><span class="line">   strcpy( Book2.author, &quot;Zara Ali&quot;);</span><br><span class="line">   strcpy( Book2.subject, &quot;Telecom Billing Tutorial&quot;);</span><br><span class="line">   Book2.book_id = 6495700;</span><br><span class="line"> </span><br><span class="line">   /* 通过传 Book1 的地址来输出 Book1 信息 */</span><br><span class="line">   printBook( &amp;Book1 );</span><br><span class="line"> </span><br><span class="line">   /* 通过传 Book2 的地址来输出 Book2 信息 */</span><br><span class="line">   printBook( &amp;Book2 );</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line">void printBook( struct Books *book )</span><br><span class="line">&#123;</span><br><span class="line">   printf( &quot;Book title : %s\n&quot;, book-&gt;title);</span><br><span class="line">   printf( &quot;Book author : %s\n&quot;, book-&gt;author);</span><br><span class="line">   printf( &quot;Book subject : %s\n&quot;, book-&gt;subject);</span><br><span class="line">   printf( &quot;Book book_id : %d\n&quot;, book-&gt;book_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>struct内存原则：</strong> 从上至下进行内存分配，对齐方式以<strong>当前分配到的</strong>内部成员类型<strong>最宽字节数</strong>为基准；整体以结构体成员最宽类型字节为基准，且整个结构体的总大小为最宽基本类型成员大小的整数倍。</p>
<ol>
<li>struct A 内存分配</li>
</ol>
<p>来看一下结构体AA的内存分配：编译器首先将变量 char a 分配一个字节，并以1个字节为对齐基准；<br>接着对 short b 进行内存分配，此时发现b为两个字节，则以b为基准对齐，此时 a 需要补充一个字节内存，a、b 总分配内存为4个字节；<br>接着对 int c 进行内存分配，发现c占4个字节，则以4个字节为基准对齐，因为之前 a、b 内存共计为4个字节刚好与“4个字节的基准”一致，则此时 struct A 共计8个字节内存。<br>struct A { char a; short b; int c; };</p>
<p>结构体中成员变量分配的空间是按照成员变量中占用空间最大的来作为分配单位,同样成员变量的存储空间也是不能跨分配单位的,如果当前的空间不足,则会存储到下一个分配单位中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char a;</span><br><span class="line">    unsigned int  b;</span><br><span class="line">    unsigned char c;</span><br><span class="line">&#125; debug_size1_t;</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char a;</span><br><span class="line">    unsigned char b;</span><br><span class="line">    unsigned int  c;</span><br><span class="line">&#125; debug_size2_t;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;debug_size1_t size=%lu,debug_size2_t size=%lu\r\n&quot;, sizeof(debug_size1_t), sizeof(debug_size2_t));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译执行输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debug_size1_t size=12,debug_size2_t size=8</span><br></pre></td></tr></table></figure>

<p>结构体占用存储空间,以32位机为例</p>
<ul>
<li><p>1.debug_size1_t 存储空间分布为a(1byte)+空闲(3byte)+b(4byte)+c(1byte)+空闲(3byte)&#x3D;12(byte)。</p>
</li>
<li><p>1.debug_size2_t 存储空间分布为a(1byte)+b(1byte)+空闲(2byte)+c(4byte)&#x3D;8(byte)。</p>
</li>
</ul>
<hr>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    struct Student &#123;</span><br><span class="line">        char name[50];</span><br><span class="line">        int gender;</span><br><span class="line">        int age;</span><br><span class="line">    &#125; student2 = &#123;&quot;张三&quot;,0,30&#125;;</span><br><span class="line">    struct Student student1;</span><br><span class="line">    printf(&quot;name:\n&quot;);</span><br><span class="line">    scanf(&quot;%s&quot;,student1.name);</span><br><span class="line">    printf(&quot;gender:\n&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;student1.gender);</span><br><span class="line">    printf(&quot;age:\n&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;student1.age);</span><br><span class="line">    printf(&quot;student1 &gt;&gt;name = %s, gender = %d, age = %d\n&quot;, student1.name, student1.gender, student1.age);</span><br><span class="line">    printf(&quot;student2 &gt;&gt;name = %s, gender = %d, age = %d\n&quot;, student2.name, student2.gender, student2.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    struct Student &#123;</span><br><span class="line">        char name[100];</span><br><span class="line">        int gender;</span><br><span class="line">        int age;</span><br><span class="line">    &#125; student2 = &#123;&quot;0&quot;,0,1&#125;;//char数组初始化如果是&#x27;0&#x27;，age会无法初始化。中文占两个字节，而char类型是一个字节长度的；因此，它的长度与char类型数据并不符合。这也就意味着我们不能像char类型一样简单操作中文字符</span><br><span class="line">   </span><br><span class="line">    struct Student student1;</span><br><span class="line">    printf(&quot;name:\n&quot;);</span><br><span class="line">    scanf(&quot;%s&quot;,&amp;student1.name);</span><br><span class="line">    printf(&quot;gender:\n&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;student1.gender);</span><br><span class="line">    printf(&quot;age:\n&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;student1.age);</span><br><span class="line">    printf(&quot;student2 &gt;&gt;name:\n&quot;);</span><br><span class="line">    scanf(&quot;%s&quot;,&amp;student2.name);//阻止了汉字乱码</span><br><span class="line">    printf(&quot;student1 &gt;&gt;name = %s, gender = %d, age = %d\n&quot;, student1.name, student1.gender, student1.age);</span><br><span class="line">    printf(&quot;student2 &gt;&gt;name = %s, gender = %d, age = %d\n&quot;, student2.name, student2.gender, student2.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h2><p>一个结构体变量中可以存放一组数据（如一个学生的学号，姓名，成绩等数据）。如果有10个学生的数据需要参加运算，显然应该用数组，这就是结构体数组。结构体数组与以前介绍过的数据值型数组不同之处在于每个数组元素都一个结构体类型的数据，它们分别包括各个成员（分量）项。</p>
<h3 id="定义结构体数组"><a href="#定义结构体数组" class="headerlink" title="定义结构体数组"></a>定义结构体数组</h3><p>和定义结构体变量的方法相仿，只需说明其为数组即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct student</span><br><span class="line">&#123;</span><br><span class="line">    int num;</span><br><span class="line">    char name[20];</span><br><span class="line">    char sex;</span><br><span class="line">    int age;</span><br><span class="line">    float score;</span><br><span class="line">    char addr[30];</span><br><span class="line">&#125;;</span><br><span class="line">struct student stu[3];</span><br></pre></td></tr></table></figure>

<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/16/%E7%AC%AC%E4%B8%89%E5%A4%A9-c%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/16/%E7%AC%AC%E4%B8%89%E5%A4%A9-c%E8%AF%AD%E8%A8%80/" class="post-title-link" itemprop="url">第三天 c语言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-16 10:14:44" itemprop="dateCreated datePublished" datetime="2023-03-16T10:14:44+08:00">2023-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-22 16:59:16" itemprop="dateModified" datetime="2023-03-22T16:59:16+08:00">2023-03-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    int var_runoob = 10;</span><br><span class="line">    int *p;              // 定义指针变量</span><br><span class="line">    p = &amp;var_runoob;</span><br><span class="line"> </span><br><span class="line">   printf(&quot;var_runoob 变量的地址： %p\n&quot;, p);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1）p是一个指针，存储var的地址</p>
<p>2）p的类型必须与var类型一致，因为整形指针只能存储整形变量的指针</p>
<p><strong>指针的一些复杂说明：</strong></p>
<ul>
<li><strong>int p;</strong> – 这是一个普通的整型变量</li>
<li><strong>int *p;</strong> – 首先从 p 处开始,先与*结合,所以说明 p 是一个指针, 然后再与 int 结合, 说明指针所指向的内容的类型为 int 型。所以 p 是一个返回整型数据的指针。</li>
<li><strong>int p[3]</strong> – 首先从 p 处开始,先与[] 结合,说明 p 是一个数组, 然后与 int 结合, 说明数组里的元素是整型的, 所以 p 是一个由整型数据组成的数组。</li>
<li><strong>int *p[3];</strong> – 首先从 p 处开始, 先与 [] 结合, 因为其优先级比 * 高,所以 p 是一个数组, 然后再与 * 结合, 说明数组里的元素是指针类型, 然后再与 int 结合, 说明指针所指向的内容的类型是整型的, 所以 p 是一个由返回整型数据的指针所组成的数组。</li>
<li><strong>int (*p)[3];</strong> – 首先从 p 处开始, 先与 * 结合,说明 p 是一个指针然后再与 [] 结合(与”()”这步可以忽略,只是为了改变优先级), 说明指针所指向的内容是一个数组, 然后再与int 结合, 说明数组里的元素是整型的。所以 p 是一个指向由整型数据组成的数组的指针。</li>
<li>*<em>int *<em>p;</em></em> – 首先从 p 开始, 先与 * 结合, 说是 p 是一个指针, 然后再与 * 结合, 说明指针所指向的元素是指针, 然后再与 int 结合, 说明该指针所指向的元素是整型数据。由于二级指针以及更高级的指针极少用在复杂的类型中, 所以后面更复杂的类型我们就不考虑多级指针了, 最多只考虑一级指针。</li>
<li><strong>int p(int);</strong> – 从 p 处起,先与 () 结合, 说明 p 是一个函数, 然后进入 () 里分析, 说明该函数有一个整型变量的参数, 然后再与外面的 int 结合, 说明函数的返回值是一个整型数据。</li>
<li><strong>int (*p)(int);</strong> – 从 p 处开始, 先与指针结合, 说明 p 是一个指针, 然后与()结合, 说明指针指向的是一个函数, 然后再与()里的 int 结合, 说明函数有一个int 型的参数, 再与最外层的 int 结合, 说明函数的返回类型是整型, 所以 p 是一个指向有一个整型参数且返回类型为整型的函数的指针。</li>
<li><strong>int *(*p(int))[3];</strong> – 可以先跳过, 不看这个类型, 过于复杂从 p 开始,先与 () 结合, 说明 p 是一个函数, 然后进入 () 里面, 与 int 结合, 说明函数有一个整型变量参数, 然后再与外面的 * 结合, 说明函数返回的是一个指针, 然后到最外面一层, 先与[]结合, 说明返回的指针指向的是一个数组, 然后再与 * 结合, 说明数组里的元素是指针, 然后再与 int 结合, 说明指针指向的内容是整型数据。所以 p 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数。</li>
</ul>
<h2 id="C-指针的算术运算"><a href="#C-指针的算术运算" class="headerlink" title="C 指针的算术运算"></a>C 指针的算术运算</h2><p>假设 <strong>ptr</strong> 是一个指向地址 1000 的整型指针，是一个 32 位的整数，让我们对该指针执行下列的算术运算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr++</span><br></pre></td></tr></table></figure>

<p>在执行完上述的运算之后，<strong>ptr</strong> 将指向位置 1004，因为 ptr 每增加一次，它都将指向下一个整数位置，即当前位置往后移 4 字节。这个运算会在不影响内存位置中实际值的情况下，移动指针到下一个内存位置。如果 <strong>ptr</strong> 指向一个地址为 1000 的字符，上面的运算会导致指针指向位置 1001，因为下一个字符位置是在 1001。</p>
<p>我们概括一下：</p>
<ul>
<li>指针的每一次递增，它其实会指向下一个元素的存储单元。</li>
<li>指针的每一次递减，它都会指向前一个元素的存储单元。</li>
<li>指针在递增和递减时跳跃的字节数取决于指针所指向变量数据类型长度，比如 int 就是 4 个字节。</li>
</ul>
<h2 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *ptr[MAX];</span><br></pre></td></tr></table></figure>

<p>在这里，把 <strong>ptr</strong> 声明为一个数组，由 MAX 个整数指针组成。因此，ptr 中的每个元素，都是一个指向 int 值的指针。</p>
<p><strong>add:</strong></p>
<p>const的好处，是引入了常量的概念，让我们不要去修改某一块不该修改的内存，使某一值被保护起来避免出现错误，在编码过程中考虑const是良好的习惯，无论是常量的定义还是类中的const函数。<br>static我认为最大的用处在于共享。static设置了函数或变量的存储方式：存储在静态存储区域。它使得局部变量和类成员变量的生命周期变长了（因为其存储方式的特殊性）。它使类成员函数更像是一份各个对象共享的代码，使类成员变量也能在各个对象之间共享，它虽然不属于类中的成员，却能被同一类的各个对象为之所用。</p>
<p>在函数前加static，则此函数成为<strong>静态函数（内部函数）</strong>，我们用static修饰函数的主要目的是：<strong>用来表示不能被其它文件访问的一个函数（和用static修饰全局变量的目的一样，都是不允许其它文件访问）。</strong>这样一来便有一个好处：<strong>程序员不用担心自己编写的函数与其他文件的函数同名</strong>。</p>
<p>具有全局作用域，只初始化一次，它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即<strong>被 static 关键字修饰过的变量具有文件作用域。</strong>（使得作用域仅限于被定义的文件中 即，从变量定义到本文件结尾处，其他文件不论通过什么方式都不能访问）。</p>
<p>const和static（<strong>怀疑</strong>）修饰的全局变量如果要在多个文件之间共享，则可以在其他文件需要时使用extern关键字,声明外部变量，使用时一定包含所定义变量所在的文件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//file.h</span><br><span class="line">const int a = 10;</span><br><span class="line">static int b = 100;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//file2</span><br><span class="line">#include “file.h”</span><br><span class="line"></span><br><span class="line">extern const int a;</span><br><span class="line">extern int b;//不需加static关键字</span><br></pre></td></tr></table></figure>

<p>无论对于const修饰的变量a还是static变量b，这样做的结果是，整个工程的程序链接完成后，所有需要使用该变量的程序共享同一个这个变量的存储区域。</p>
<p><strong>指针数组</strong>：指针的数组，实际是一个数组，长度由数组本身决定，这个数组的所有元素都是指针类型，存放的都是地址。<strong>int *a[3]<strong>：为什么这里是指针数组，</strong>[]</strong> 的优先级高于 ***** ，所以这是一个数组，而 ***** 修饰数组，所以是指针数组，数组的元素是整型的指针。</p>
<p><strong>int *prt[ 10 ] ; *prt[ 1 ],*prt[ 2 ],*prt[ 3 ]……</strong> 数组中每个元素都指向一个地址。</p>
<p><strong>数组指针</strong>：数组的指针，实际是一个指针，长度固定(32 位系统下占 4 个字节)，这个指针指向数组，但指向的数组占多少个字节不确定。**int (*a)[3]**：同样的方式，首先括号的优先级最高，所以 *<strong>a</strong> 是指针，而 <strong>[]</strong> 修饰 *<strong>a</strong> ，所以是数组指针，一个指向 3 个元素的一维数组指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int  a[5]=&#123; 1,2,3,4,5 &#125;;    //定义一个一维数组 a</span><br><span class="line">int  (*prt)[5];      // 步长为 5 的数组指针，即 prt 指向的数组里有 5 个元素  </span><br><span class="line">prt=&amp;a;    // 把数组 a 的地址付给 prt，则 prt 为数组 a 的地址，*prt 表示数组 a 本身</span><br><span class="line">prt[ 0 ];    //表示数组首元素的地址</span><br><span class="line">*prt[ 0 ]；  //表示数组的首元素的值，即为数组 a 的 1</span><br><span class="line">**prt;         //表示数组的首元素的值，即为数组 a 的 1</span><br><span class="line">*prt[ 1 ] ;   //表示指向数组的下一行元素的首元素的值，但是a是一维数组，只有一行，所以指向的地址中的值不确定</span><br></pre></td></tr></table></figure>

<p>数组指针加 1，步长为所指向数组的列数，即为下一行的首地址，只在二维及以上维度的数组中有意义，一维数组只有一行，无意义。</p>
<h2 id="C-指向指针的指针"><a href="#C-指向指针的指针" class="headerlink" title="C 指向指针的指针"></a>C 指向指针的指针</h2><p>指针更像是一个找地址开门取物品的操作。其中 ***** 就是这个动作重复的次数，<strong>ptr</strong> 是取东西的门牌号也就是地址值：</p>
<ul>
<li>*<strong>ptr</strong> 是完成一次开门取东西操作最终取出来的东西。</li>
<li>*<strong>*ptr</strong> 是完成两次开门取物.需要注意的是第一次取得的是第二次要开的门的门牌号或者说地址，然后根据门牌号继续开门取物。 所以 *<strong>ptr</strong> 或者 *<strong>*ptr</strong> 一定是取出来的东西，即为数值。而 <strong>ptr</strong> 一定是门牌号，即为地址值。</li>
</ul>
<h2 id="C-传递指针给函数"><a href="#C-传递指针给函数" class="headerlink" title="C 传递指针给函数"></a>C 传递指针给函数</h2><h3 id="指针和函数的关系"><a href="#指针和函数的关系" class="headerlink" title="指针和函数的关系"></a>指针和函数的关系</h3><p><strong>1、函数指针（指向函数的指针）</strong></p>
<p>一个函数在编译之后，会占据一部分内存，而它的函数名，就是这段函数的首地址。</p>
<p>可以把一个指针声明成为一个指向函数的指针。</p>
<p>C 语言规定函数名会被转换为指向这个函数的指针，除非这个函数名作为 &amp; 操作符或 sizeof 操作符的操作数(注意：函数名用于 sizeof 的操作数是非法的)。也就是说 f &#x3D; test; 中 test 被自动转换为 &amp;test，而 f &#x3D; &amp;test; 中已经显示使用了 &amp;test，所以 test 就不会再发生转换了。因此直接引用函数名等效于在函数名上应用 &amp; 运算符，两种方法都会得到指向该函数的指针。</p>
<p>指向函数的指针必须初始化，或者具有 0 值，才能在函数调用中使用。</p>
<p>与数组一样：</p>
<ul>
<li>（1）禁止对指向函数的指针进行自增运算++</li>
<li>（2）禁止对函数名赋值，函数名也不能用于进行算术运算。</li>
</ul>
<p>示例1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int fun1(int,int);</span><br><span class="line">int fun1(int a, int b)&#123; </span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int (*pfun1)(int,int); </span><br><span class="line">    pfun1=fun1;//这里&amp;fun1和fun1的值和类型都一样，用哪个无所谓 </span><br><span class="line">    int a=(*pfun1)(5,7); //通过函数指针调用函数。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int Max(int x, int y)  //定义Max函数</span><br><span class="line">&#123;</span><br><span class="line">    int z;</span><br><span class="line">    if (x &gt; y) &#123;</span><br><span class="line">        z = x;</span><br><span class="line">    &#125;else &#123; </span><br><span class="line">        z = y;</span><br><span class="line">    &#125;</span><br><span class="line">    return z;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;//定义一个函数指针</span><br><span class="line">    int(*p)(int, int);</span><br><span class="line">    int a, b, c;//把函数Max赋给指针变量p, 使p指向Max函数</span><br><span class="line">    p = Max;</span><br><span class="line">    printf(&quot;please enter a and b:&quot;);</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);//通过函数指针调用Max函数</span><br><span class="line">    c = (*p)(a, b);</span><br><span class="line">    printf(&quot;a = %d\nb = %d\nmax = %d\n&quot;, a, b, c);</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例3:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line">void test( )&#123;</span><br><span class="line">    printf(&quot;test called!/n&quot;);</span><br><span class="line">&#125; </span><br><span class="line">int main( )&#123;   </span><br><span class="line">    void (*f) ( );   </span><br><span class="line">    f = test;     </span><br><span class="line">    f ( ); </span><br><span class="line">    (*f)( );    </span><br><span class="line">    //test++;             // error，标准禁止对指向函数的指针进行自增运算          </span><br><span class="line">    //test = test + 2;    // error，不能对函数名赋值，函数名也不能用于进行算术运算          </span><br><span class="line">    printf(&quot;%p/n&quot;, test);          </span><br><span class="line">    printf(&quot;%p/n&quot;, &amp;test);          </span><br><span class="line">    printf(&quot;%p/n&quot;, *test);  </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test called!</span><br><span class="line">test called!</span><br><span class="line">004013EE004013EE004013EE</span><br></pre></td></tr></table></figure>

<p>这里的玄学就是 *test 为什么能和上面两个之前介绍过的输出一样的值。</p>
<p>首先来看函数名 test，是一个符号用来标识一个函数的入口地址，在使用中函数名会被转换为指向这个函数的指针，指针的值就是函数的入口地址，&amp;test 在前面已经说了：显示获取函数的地址。*test 可以认为由于 test 已经被转换成了函数指针, 指向这个函数，所以 *test 就是取这个指针所指向的函数名，而又根据函数名会被转换指向该函数的指针的规则，这个函数也转变成了一个指针，所以 <em>test 最终也是一个指向函数 test 的指针。也就是说:</em>(*<em>test –&gt; *(&amp;test) –&gt; test –&gt; &amp;test</em>)。</p>
<h2 id="C-从函数返回指针"><a href="#C-从函数返回指针" class="headerlink" title="C 从函数返回指针"></a>C 从函数返回指针</h2><p>C 不支持在调用函数时返回局部变量的地址，除非定义局部变量为 static 变量。</p>
<p>因为局部变量是存储在内存的栈区内，当函数调用结束后，局部变量所占的内存地址便被释放了，因此当其函数执行完毕后，函数内的变量便不再拥有那个内存地址，所以不能返回其指针。</p>
<p>除非将其变量定义为 static 变量，static 变量的值存放在内存中的静态数据区，不会随着函数执行的结束而被清除，故能返回其地址。</p>
<h2 id="一些其他的："><a href="#一些其他的：" class="headerlink" title="一些其他的："></a>一些其他的：</h2><p>sizeof(数组名)返回的是数组的大小</p>
<p>sizeof(ca)&#x3D;7，注意此处包含一个结束符<br>sizeof(cb)&#x3D;18，</p>
<p>sizeof(一维数组指针)返回的是数组单个元素指针的大小，即系统指针的长度，32位系统为4，64位系统位8</p>
<p>64位：sizeof(pca)&#x3D;8，32位：sizeof(pca)&#x3D;4</p>
<p>sizeof(*一维数组指针)返回的是数组单个元素对应类型的大小</p>
<p>sizeof(*pca)&#x3D;1，char的大小</p>
<p>sizeof(二维数组指针)返回的是二维数组行指针的大小，32位系统为行数×4，64位系统位行数×8</p>
<p>sizeof(pcb)等同于sizeof(pcb[0])、sizeof(pcb[1])、sizeof(pcb[2])</p>
<p>64位：sizeof(pcb)&#x3D;24，3行×8，注意二维数组每一行的结尾没有结束符’\0’，所以是行长度为8</p>
<p>32位：sizeof(pcb)&#x3D;12，3行×4，</p>
<p>sizeof(*二维数组指针)返回的是系统指针的长度，32位系统为4，64位系统位8</p>
<p>64位：sizeof(pcb)&#x3D;8，32位：sizeof(pcb)&#x3D;4</p>
<p>sizeof(**二维数组指针)返回的是数组单个元素指针的大小，即char的大小</p>
<p>sizeof(**pcb)&#x3D;1</p>
<hr>
<p><strong>下面总结一下数组的数组名(数组中储存的也是数组)的问题:</strong></p>
<p>声明了一个数组 **TYPE array[n]**，则数组名称 array 就有了两重含义：</p>
<ul>
<li>第一，它代表整个数组，它的类型是 **TYPE[n]**；</li>
<li>第二，它是一个常量指针，该指针的类型是 **TYPE***，该指针指向的类型是 <strong>TYPE</strong>，也就是数组单元的类型，该指针指向的内存区就是数组第 0 号单元，该指针自己占有单独的内存区，注意它和数组第 0 号单元占据的内存区是不同的。该指针的值是不能修改的，即类似 array++ 的表达式是错误的。在不同的表达式中数组名 array 可以扮演不同的角色。在表达式 sizeof(array) 中，数组名 array 代表数组本身，故这时 sizeof 函数测出的是整个数组的大小。</li>
</ul>
<p>在表达式 <em>array 中，array 扮演的是指针，因此这个表达式的结果就是数组第 0 号单元的值。*<em>sizeof(*array)</em></em> 测出的是数组单元的大小。</p>
<p>表达式 array+n（其中n&#x3D;0，1，2，…..）中，array 扮演的是指针，故array+n 的结果是一个指针，它的类型是 <strong>TYPE *<strong>，它指向的类型是 TYPE，它指向数组第 n 号单元。</strong>故sizeof(array+n)测出的是指针类型的大小。在 32 位程序中结果是 4。</strong></p>
<hr>
<p>这里 <strong>&amp;</strong> 是取地址运算符，***** 是间接运算符。</p>
<p><strong>&amp;a</strong> 的运算结果是一个指针，指针的类型是 a 的类型加个 *，指针所指向的类型是 a 的类型，指针所指向的地址嘛，那就是 a 的地址。</p>
<p>*<strong>p</strong> 的运算结果就五花八门了。总之 *p 的结果是p 所指向的东西，这个东西有这些特点：它的类型是 p 指向的类型，它所占用的地址是 p 所指向的地址。</p>
<p>实例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int a=12; int b; int *p; int **ptr;</span><br><span class="line">p=&amp;a; //&amp;a 的结果是一个指针，类型是int*，指向的类型是</span><br><span class="line">//int，指向的地址是a 的地址。</span><br><span class="line">*p=24; //*p 的结果，在这里它的类型是int，它所占用的地址是</span><br><span class="line">//p 所指向的地址，显然，*p 就是变量a。</span><br><span class="line">ptr=&amp;p; //&amp;p 的结果是个指针，该指针的类型是p 的类型加个*，</span><br><span class="line">//在这里是int **。该指针所指向的类型是p 的类型，这</span><br><span class="line">//里是int*。该指针所指向的地址就是指针p 自己的地址。</span><br><span class="line">*ptr=&amp;b; //*ptr 是个指针，&amp;b 的结果也是个指针，且这两个指针</span><br><span class="line">//的类型和所指向的类型是一样的，所以用&amp;b 来给*ptr 赋</span><br><span class="line">//值就是毫无问题的了。</span><br><span class="line">**ptr=34; //*ptr 的结果是ptr 所指向的东西，在这里是一个指针，</span><br><span class="line">//对这个指针再做一次*运算，结果是一个int 类型的变量。</span><br></pre></td></tr></table></figure>

<hr>
<p>实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">char *str[3]=&#123;</span><br><span class="line">    &quot;Hello,thisisasample!&quot;,</span><br><span class="line">    &quot;Hi,goodmorning.&quot;,</span><br><span class="line">    &quot;Helloworld&quot;</span><br><span class="line">&#125;;</span><br><span class="line">char s[80]；</span><br><span class="line">strcpy(s,str[0]); //也可写成strcpy(s,*str);</span><br><span class="line">strcpy(s,str[1]); //也可写成strcpy(s,*(str+1));</span><br><span class="line">strcpy(s,str[2]); //也可写成strcpy(s,*(str+2));</span><br></pre></td></tr></table></figure>

<p>上例中，str 是一个三单元的数组，该数组的每个单元都是一个指针，这些指针各指向一个字符串。把指针数组名 str 当作一个指针的话，它指向数组的第 0 号单元，它的类型是 char **，它指向的类型是 char *。</p>
<p><em>str 也是一个指针，它的类型是 char <em>，它所指向的类型是 char，它指向的地址是字符串 “Hello,thisisasample!” 的第一个字符的地址，即 ‘H’ 的地址。**注意:字符串相当于是一个数组, 在内存中以数组的形式储存, 只不过字符串是一个数组常量, 内容不可改变,且只能是右值.如果看成指针的话, 他即是常量指针, 也是指针常量。</em></em></p>
<p>str+1 也是一个指针，它指向数组的第 1 号单元，它的类型是 char*<em>，它指向的类型是 char</em>。</p>
<p><em>(str+1) 也是一个指针，它的类型是 char</em>，它所指向的类型是 char，它指向 “Hi,goodmorning.” 的第一个字符 ‘H’。</p>
<hr>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int(*ptr)[10];</span><br></pre></td></tr></table></figure>

<p>则在 32 位程序中，有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sizeof(int(*)[10])==4</span><br><span class="line">sizeof(int[10])==40</span><br><span class="line">sizeof(ptr)==4</span><br></pre></td></tr></table></figure>

<p>实际上，sizeof(对象)测出的都是对象自身的类型的大小，而不是别的什么类型的大小。</p>
<hr>
<p>在指针的强制类型转换：<strong>ptr1&#x3D;(TYPE *)ptr2</strong> 中，如果 sizeof(ptr2的类型)大于 sizeof(ptr1 的类型)，那么在使用指针 ptr1 来访问 ptr2 所指向的存储区时是安全的。如果 sizeof(ptr2 的类型) 小于sizeof(ptr1 的类型)，那么在使用指针ptr1 来访问ptr2 所指向的存储区时是不安全的。</p>
<p>如果ptr2不是指针类型则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char s=&#x27;a&#x27;;</span><br><span class="line">int *ptr;</span><br><span class="line">ptr=(int *)&amp;s;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/16/%E7%AC%AC%E4%BA%8C%E5%A4%A9-c%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/16/%E7%AC%AC%E4%BA%8C%E5%A4%A9-c%E8%AF%AD%E8%A8%80/" class="post-title-link" itemprop="url">第二天 c语言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-16 10:02:10 / 修改时间：10:03:19" itemprop="dateCreated datePublished" datetime="2023-03-16T10:02:10+08:00">2023-03-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C-存储类"><a href="#C-存储类" class="headerlink" title="C 存储类"></a>C 存储类</h1><p>存储类定义 C 程序中变量&#x2F;函数的的存储位置、生命周期和作用域。</p>
<p>这些说明符放置在它们所修饰的类型之前。</p>
<p>下面列出 C 程序中可用的存储类：</p>
<p>auto</p>
<p>register</p>
<p>static</p>
<p>extern</p>
<h2 id="auto-存储类"><a href="#auto-存储类" class="headerlink" title="auto 存储类"></a>auto 存储类</h2><p><strong>auto</strong> 存储类是所有局部变量默认的存储类。</p>
<p><strong>auto</strong>  普通局部栈变量，是自动存储，这种对象会自动创建和销毁 ，建议这个变量要放在堆栈上面，调用函数时分配内存，函数结束时释放内存。一般隐藏auto默认为自动存储类别。我们程序变量大多是自动变量。</p>
<h2 id="register-存储类"><a href="#register-存储类" class="headerlink" title="register 存储类"></a>register 存储类</h2><p><strong>register</strong> 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个字），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。</p>
<p>register 存储类定义存储在寄存器，所以变量的访问速度更快，但是它不能直接取地址，因为它不是存储在 RAM 中的。在需要频繁访问的变量上使用 register 存储类可以提高程序的运行速度。</p>
<h2 id="static-存储类"><a href="#static-存储类" class="headerlink" title="static 存储类"></a>static 存储类</h2><p><strong>static</strong> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</p>
<p>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。</p>
<p>全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。</p>
<p>静态变量在程序中只被初始化一次，即使函数被调用多次，该变量的值也不会重置。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">/* 函数声明 */</span><br><span class="line">void func1(void);</span><br><span class="line"> </span><br><span class="line">static int count=10;        /* 全局变量 - static 是默认的 */</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  while (count--) &#123;</span><br><span class="line">      func1();</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void func1(void)</span><br><span class="line">&#123;</span><br><span class="line">/* &#x27;thingy&#x27; 是 &#x27;func1&#x27; 的局部变量 - 只初始化一次</span><br><span class="line"> * 每次调用函数 &#x27;func1&#x27; &#x27;thingy&#x27; 值不会被重置。</span><br><span class="line"> */                </span><br><span class="line">  static int thingy=5;</span><br><span class="line">  thingy++;</span><br><span class="line">  printf(&quot; thingy 为 %d ， count 为 %d\n&quot;, thingy, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例中 count 作为全局变量可以在函数内使用，thingy 使用 static 修饰后，不会在每次调用时重置。</p>
<h2 id="extern-存储类"><a href="#extern-存储类" class="headerlink" title="extern 存储类"></a>extern 存储类</h2><p><strong>extern</strong> 存储类用于定义在其他文件中声明的全局变量或函数。当使用 extern 关键字时，不会为变量分配任何存储空间，而只是指示编译器该变量在其他文件中定义。</p>
<p><strong>extern</strong> 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 <strong>extern</strong> 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p>
<p>当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 <em>extern</em> 来得到已定义的变量或函数的引用。可以这么理解，<em>extern</em> 是用来在另一个文件中声明一个全局变量或函数。</p>
<p>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：</p>
<p><strong>第一个文件：main.c</strong></p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int count ;</span><br><span class="line">extern void write_extern();</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   count = 5;</span><br><span class="line">   write_extern();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二个文件：support.c</strong></p>
<h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">extern int count;</span><br><span class="line"> </span><br><span class="line">void write_extern(void)</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;count is %d\n&quot;, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>1、auto存储类型的变量只能在某个程序范围内使用,他采用堆栈的方式分配空间。</p>
<p>  在定义变量时,auto是可以省略的,如:auto  int  i;等效于int  i.</p>
<p>2、全局变量不允许声明为auto变量，register不适用于全局变量。</p>
<p>3、register是不能取址的。比如 int i；(自动为auto)int *p&#x3D;&amp;i;是对的，但register int j; int *p &#x3D; &amp;j;是错的，因为无法对寄存器的定址。</p>
<p>4、声明变量为register,编译器并不一定会将它处理为寄存器变量，毕竟，资源是有限的。</p>
<p>5、实际上现在一般的编译器都忽略auto和register申明，现在的编译器自己能够区分最好将那些变量放置在寄存器中，那些放置在堆栈中；甚至于将一些变量有时存放在堆栈，有时存放在寄存器中。</p>
<p>6、auto register 是用来修饰变量的,static extern 变量函数都可以。</p>
<p>7、Extern外部变量：如果我们希望该外部变量只能在本文件内使用，而不能被其他文件引用可以在外部变量定义时加static声明。防止别人写的模块误用。</p>
<p>8、全局变量会被初始化为空, 而局部变量在没有赋值前是一个垃圾值。</p>
<p>9、static 关键字: 修饰的局部变量是静态局部变量; 静态局部变量存值如同全局变量, 区别在于它只属于拥有它的函数; 它也会被初始化为空。</p>
<p>10、静态全局变量也具有全局作用域，它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。因此static 这个说明符在不同的地方所起的作用是不同的。应予以注意。</p>
<p><strong>Tips:</strong></p>
<p> A.若全局变量仅在单个C文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度；</p>
<p> B.若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度；</p>
<p> C.设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑重入问题，因为他们都放在静态数据存储区，全局可见；</p>
<p> D.如果我们需要一个可重入的函数，那么，我们一定要避免函数中使用static变量(这样的函数被称为：带”内部存储器”功能的的函数)</p>
<p> E.函数中必须要使用static变量情况:比如当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类型，则返回为错指针。</p>
<h4 id="利用异或-来交换两个数的值，而且不引入其他变量。"><a href="#利用异或-来交换两个数的值，而且不引入其他变量。" class="headerlink" title="利用异或 ^ 来交换两个数的值，而且不引入其他变量。"></a>利用异或 <strong>^</strong> 来交换两个数的值，而且不引入其他变量。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unsigned int a=60;  //0011 1100</span><br><span class="line">unsigned int b=13;  //0000 1101</span><br><span class="line">a=a^b;              //a=a^b=0011 0001</span><br><span class="line">b=a^b;              //b=a^b=0011 1100  相当于b1=(a^b)^b</span><br><span class="line">a=a^b;              //a=a^b=0000 1101  相当于a1=(a^b)^((a^b)^b)</span><br></pre></td></tr></table></figure>

<p>当然，这种利用位运算的交换方法只适用于整型变量，不能用于浮点型变量!</p>
<p>利用位与 <strong>&amp;</strong> 运算，判断一个整数是否是2的整数次幂。利用这一特点，即可判断一个整数是否是2的整数次幂。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int func(int num)</span><br><span class="line">&#123;</span><br><span class="line">    return ((num &gt; 0) &amp;&amp; ((num &amp; (num - 1)) == 0));//2的n次幂大于0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回值为 1，则输入的正整数为 2 的整数次幂，返回值为 0 则不是。</p>
<p>我们将 <strong>||</strong> 和 <strong>&amp;&amp;</strong> 定义为逻辑运算符，而 <strong>|</strong> 和 <strong>&amp;</strong> 定义为位运算符。</p>
<p><strong>&amp;&amp;</strong> 如果两个操作数都非零，则条件为真；</p>
<p><strong>||</strong> 如果两个操作数中有任意一个非零，则条件为真。可以看出 &amp; 和 &amp;&amp; 在判断语句中都可以实现“和”这个功能，不过区别在于 &amp; 两边都运算，而 &amp;&amp; 先算 &amp;&amp; 左侧，若左侧为 false 那么右侧就不运算了。因此从效率上来说，判断语句中推荐使用 &amp;&amp;（换句话就是逻辑运算就老老实实用逻辑运算符，不然它为啥叫逻辑运算符呢？）</p>
<table>
<thead>
<tr>
<th><strong>&amp;</strong></th>
<th><strong>返回变量的地址。</strong></th>
<th><strong>&amp;a; 将给出变量的实际地址。</strong></th>
</tr>
</thead>
<tbody><tr>
<td>*****</td>
<td><strong>指向一个变量。</strong></td>
<td>*<strong>a; 将指向一个变量。</strong></td>
</tr>
</tbody></table>
<p>根据函数能否被其他源文件调用，将函数区分为内部函数和外部函数。</p>
<p>tips:</p>
<ul>
<li><p>对数组元素 a[i]的引用也可以写成*(a+i)这种形式。</p>
</li>
<li><p>赋值语句 p&#x3D;&amp;a[0] 也可以写成下列形式: p&#x3D;a。</p>
</li>
<li><p>p 是个指针，p[i]与*(p+i)是等价的。</p>
</li>
<li><p>&#96;&#96;&#96;<br>int a[10];</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">数组名是指向数组首个元素的指针常量，*a==a[0]，*(a+1)==a[1]，其类型应该为指向 **int** 类型的指针：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>int *;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  对数组名取地址：&amp;a，得到的应该是整个数组的地址。这时可以认为 **a** 是整个数组的变量名，对变量名进行取地址操作：&amp;，会得到该变量的地址；</span><br><span class="line"></span><br><span class="line">  操作：(&amp;a+1) 得到的是增大整个数组内存大小的地址：增大 **4\*10**。</span><br><span class="line"></span><br><span class="line">## 内部函数</span><br><span class="line"></span><br><span class="line">如果一个函数只能被本文件中其他函数所调用，它称为内部函数。在定义内部函数时，在函数名和函数类型的前面加 static，即</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>static 类型名 函数名 （形参表）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例如，函数的首行：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>static int max(int a,int b)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">内部函数又称静态函数。使用内部函数，可以使函数的作用域只局限于所在文件。即使在不同的文件中有同名的内部函数，也互不干扰。提高了程序的可靠性。</span><br><span class="line"></span><br><span class="line">## 外部函数</span><br><span class="line"></span><br><span class="line">如果在定义函数时，在函数的首部的最左端加关键字 extern，则此函数是外部函数，可供其它文件调用。</span><br><span class="line"></span><br><span class="line">如函数首部可以为</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>extern int max (int a,int b)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">C 语言规定，如果在定义函数时省略 extern，则默认为外部函数。</span><br><span class="line"></span><br><span class="line">在需要调用此函数的其他文件中，需要对此函数作声明（不要忘记，即使在本文件中调用一个函数，也要用函数原型来声明）。在对此函数作声明时，要加关键字 extern，表示该函数是在其他文件中定义的外部函数。</span><br><span class="line"></span><br><span class="line">## 实例</span><br><span class="line"></span><br><span class="line">以下实例通过多个文件的函数实现输入一串字符串，然后删除指定的字符：</span><br><span class="line"></span><br><span class="line">file1.c(文件1)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>#include &lt;stdio.h&gt;</p>
<p>static void delete_string(char str[],char ch);<br>int main()<br>{<br>    extern void enter(char str[]); &#x2F;&#x2F; 对函数的声明<br>    extern void print(char str[]); &#x2F;&#x2F; 对函数的声明<br>    char c,str[100];<br>    enter(str);<br>    scanf(“%c”,&amp;c);<br>    delete_string(str,c);<br>    print(str);<br>    return 0;<br>}</p>
<p>static void delete_string(char str[],char ch)&#x2F;&#x2F;内部函数<br>{<br>    int i,j;<br>    for(i&#x3D;j&#x3D;0;str[i]!&#x3D;’\0’;i++)<br>    if(str[i]!&#x3D;ch)<br>    str[j++]&#x3D;str[i];<br>    str[j]&#x3D;’\0’;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">file2.c(文件2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#include &lt;stdio.h&gt;</p>
<p>void enter(char str[100]) &#x2F;&#x2F; 定义外部函数 enter<br>{<br>    fgets(str, 100, stdin); &#x2F;&#x2F; 向字符数组输入字符串<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">file3.c(文件3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#include &lt;stdio.h&gt;</p>
<p>void print(char str[]) &#x2F;&#x2F; 定义外部函数 print<br>{<br>    printf(“%s\n”,str);<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输入字符串&quot;abcdef&quot;，给字符数组 str，在输入要删去的字符&#x27;d&#x27;。 运行结果:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$ gcc file1.c file2.c file3.c<br>$ .&#x2F;a.out<br>abcdef                   # 输入的字符串<br>d                        # 要删除的字符<br>abcef                    # 删除后的字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## **关于 main 函数的参数**</span><br><span class="line"></span><br><span class="line">在有些很专业的书会看到如下代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>int main( int argc, char *argv[] )</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上面的代码中 main 函数带了参数。</span><br><span class="line"></span><br><span class="line">但是有时又会看见main函数没有参数，如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>int main()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**那么 main 函数到底有没有参数，有没有参数会不会有什么影响？**</span><br><span class="line"></span><br><span class="line">main 函数其实与我们写的函数没有什么区别，它也会有自己的参数。</span><br><span class="line"></span><br><span class="line">argc 和 argv 是 main 函数的形式参数。</span><br><span class="line"></span><br><span class="line">这两个形式参数的类型是系统规定的。如果 main 函数要带参数，就是这两个类型的参数；否则main函数就没有参数。</span><br><span class="line"></span><br><span class="line">变量名称argc和argv是常规的名称，当然也可以换成其他名称。在传入参数后main函数收到参数后就会做自己的事。那么，实际参数是如何传递给main函数的argc和argv的呢？我们知道，C程序在编译和链接后，都生成一个exe文件，执行该exe文件时，可以直接执行；也可以在命令行下带参数执行，命令行执行的形式为：可执行文件名称 参数1 参数2 ... ... 参数n。可执行文件名称和参数、参数之间均使用空格隔开。</span><br><span class="line"></span><br><span class="line">如果按照这种方法执行，命令行字符串将作为实际参数传递给main函数。具体为：</span><br><span class="line"></span><br><span class="line">-  (1) 可执行文件名称和所有参数的个数之和传递给 argc；</span><br><span class="line">-  (2) 可执行文件名称（包括路径名称）作为一个字符串，首地址被赋给 argv[0]，参数1也作为一个字符串，首地址被赋给 argv[1]，... ...依次类推。</span><br><span class="line"></span><br><span class="line">## 占位符</span><br><span class="line"></span><br><span class="line">就是先占住一个固定的位置，等着你再往里面添加内容的符号，广泛用于计算机中各类文档的编辑。</span><br><span class="line"></span><br><span class="line">格式占位符(%)是在C/C++语言中格式输入函数，如 scanf、printf 等函数中使用。其意义就是起到格式占位的意思，表示在该位置有输入或者输出。</span><br><span class="line"></span><br><span class="line">-  **%d, %i** 代表整数</span><br><span class="line">-  **%f** 浮点</span><br><span class="line">-  **%s** 字符串</span><br><span class="line">-  **%c** char</span><br><span class="line">-  **%p** 指针</span><br><span class="line">-  **%fL** 长log</span><br><span class="line">-  **%e** 科学计数</span><br><span class="line">-  **%g** 小数或科学计数。</span><br><span class="line">-  **%a,%A** 读入一个浮点值(仅C99有效)。</span><br><span class="line">-  **%c** 读入一个字符。</span><br><span class="line">-  **%d** 读入十进制整数。</span><br><span class="line">-  **%i** 读入十进制，八进制，十六进制整数。</span><br><span class="line">-  **%o** 读入八进制整数。</span><br><span class="line">-  **%x,%X** 读入十六进制整数。</span><br><span class="line">-  **%s** 读入一个字符串，遇空格、制表符或换行符结束。</span><br><span class="line">-  **%f,%F,%e,%E,%g,%G** 用来输入实数，可以用小数形式或指数形式输入。</span><br><span class="line">-  **%p** 读入一个指针。</span><br><span class="line">-  **%u** 读入一个无符号十进制整数。</span><br><span class="line">-  **%n** 至此已读入值的等价字符数。</span><br><span class="line">-  **%[]** 扫描字符集合。</span><br><span class="line">-  **%%** 读 % 符号</span><br><span class="line"></span><br><span class="line">## **全局变量与局部变量在内存中的区别**：</span><br><span class="line"></span><br><span class="line">全局变量保存在内存的全局存储区中，占用静态的存储单元；</span><br><span class="line"></span><br><span class="line">局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。</span><br><span class="line"></span><br><span class="line">## 初始化局部变量和全局变量</span><br><span class="line"></span><br><span class="line">当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动对其初始化，如下所示：</span><br><span class="line"></span><br><span class="line">| 数据类型 | 初始化默认值 |</span><br><span class="line">| :------- | :----------- |</span><br><span class="line">| int      | 0            |</span><br><span class="line">| char     | &#x27;\0&#x27;         |</span><br><span class="line">| float    | 0            |</span><br><span class="line">| double   | 0            |</span><br><span class="line">| pointer  | NULL         |</span><br><span class="line"></span><br><span class="line">正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果，因为未初始化的变量会导致一些在内存位置中已经可用的垃圾值。</span><br><span class="line"></span><br><span class="line">除了函数是有作用域外，其实在 **if、for、do-while** 中也是有作用域的，若在这些语句块中初始化的话，到了其外部就无法访问。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#include &lt;stdio.h&gt;</p>
<p>int main()<br>{<br>    for (int i &#x3D; 0; i &lt; 1; i++) {<br>        int a &#x3D; 1;<br>    }<br>    if (1) {<br>        int a &#x3D; 1;<br>    }<br>    int b &#x3D; 1;<br>    while (b) {<br>        b–;<br>        int a;<br>    }<br>    switch (b) {<br>        case 0:<br>            int a &#x3D; 0;<br>            break;<br>    }<br>    do {<br>        b–;<br>        int a &#x3D; 0;<br>    } while (b &#x3D;&#x3D; 0);<br>    int c &#x3D; 0;<br>    if (1) {<br>        int c &#x3D; 10;<br>    }<br>    printf(“%d”,a);&#x2F;&#x2F;错误，提示未定义标识符a<br>    printf(“%d”, c);&#x2F;&#x2F;输出“0”<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## C 指向数组的指针</span><br><span class="line"></span><br><span class="line">数组名是一个指向数组中第一个元素的常量指针。因此，在下面的声明中：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>double balance[50];</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**balance** 是一个指向 &amp;balance[0] 的指针，即数组 balance 的第一个元素的地址。因此，下面的程序片段把 **p** 赋值为 **balance** 的第一个元素的地址：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>double *p;<br>double balance[10];</p>
<p>p &#x3D; balance;</p>
<pre><code>
使用数组名作为常量指针是合法的，反之亦然。因此，*(balance + 4) 是一种访问 balance[4] 数据的合法方式。

一旦您把第一个元素的地址存储在 p 中，您就可以使用 *p、*(p+1)、*(p+2) 等来访问数组元素。
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/13/%E7%AC%AC%E4%B8%80%E5%A4%A9-c%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/13/%E7%AC%AC%E4%B8%80%E5%A4%A9-c%E8%AF%AD%E8%A8%80/" class="post-title-link" itemprop="url">第一天 c语言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-13 14:53:57 / 修改时间：16:30:54" itemprop="dateCreated datePublished" datetime="2023-03-13T14:53:57+08:00">2023-03-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="C-中的变量声明"><a href="#C-中的变量声明" class="headerlink" title="C 中的变量声明"></a>C 中的变量声明</h2><p>变量声明向编译器保证变量以指定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。</p>
<p>变量的声明有两种情况：</p>
<ul>
<li>1、一种是需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。</li>
<li>2、另一种是不需要建立存储空间的，通过使用extern关键字声明变量名而不定义它。 例如：extern int a 其中变量 a 可以在别的文件中定义的。</li>
<li>除非有extern关键字，否则都是变量的定义。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i; <span class="comment">//声明，不是定义</span></span><br><span class="line"><span class="type">int</span> i; <span class="comment">//声明，也是定义</span></span><br></pre></td></tr></table></figure>

<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>尝试下面的实例，其中，变量在头部就已经被声明，但是定义与初始化在主函数内：</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">// 函数外定义变量 x 和 y</span><br><span class="line">int x;</span><br><span class="line">int y;</span><br><span class="line">int addtwonum()</span><br><span class="line">&#123;</span><br><span class="line">    // 函数内声明变量 x 和 y 为外部变量</span><br><span class="line">    extern int x;</span><br><span class="line">    extern int y;</span><br><span class="line">    // 给外部变量（全局变量）x 和 y 赋值</span><br><span class="line">    x = 1;</span><br><span class="line">    y = 2;</span><br><span class="line">    return x+y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int result;</span><br><span class="line">    // 调用函数 addtwonum</span><br><span class="line">    result = addtwonum();</span><br><span class="line">    </span><br><span class="line">    printf(&quot;result 为: %d&quot;,result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result 为: 3</span><br></pre></td></tr></table></figure>

<p>如果需要在一个源文件中引用另外一个源文件中定义的变量，我们只需在引用的文件中将变量加上 extern 关键字的声明即可。</p>
<h2 id="addtwonum-c-文件代码："><a href="#addtwonum-c-文件代码：" class="headerlink" title="addtwonum.c 文件代码："></a>addtwonum.c 文件代码：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">/*外部变量声明*/</span><br><span class="line">extern int x ;</span><br><span class="line">extern int y ;</span><br><span class="line">int addtwonum()</span><br><span class="line">&#123;</span><br><span class="line">    return x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="test-c-文件代码："><a href="#test-c-文件代码：" class="headerlink" title="test.c 文件代码："></a>test.c 文件代码：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">  </span><br><span class="line">/*定义两个全局变量*/</span><br><span class="line">int x=1;</span><br><span class="line">int y=2;</span><br><span class="line">int addtwonum();</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int result;</span><br><span class="line">    result = addtwonum();</span><br><span class="line">    printf(&quot;result 为: %d\n&quot;,result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc addtwonum.c test.c -o main</span><br><span class="line">$ ./main</span><br><span class="line">result 为: 3</span><br></pre></td></tr></table></figure>

<h3 id="c-x2F-c-中的lvaues-左值-和rvalues-右值"><a href="#c-x2F-c-中的lvaues-左值-和rvalues-右值" class="headerlink" title="c&#x2F;c++中的lvaues(左值)和rvalues(右值)"></a>c&#x2F;c++中的lvaues(左值)和rvalues(右值)</h3><p>lvaues本质“就是指一些对象、或者是表达式。这些对象、表达式必须代表一块内存区域”。换句话说，lvaues就是代表一块内存区域的对象(object)或者是表达式(expression)。</p>
<p> rvalues 被定义为“除了lvaues以外的所有对象、或者表达式”。其实，本质是“不能表示一块内存区域”。</p>
<p>总结：</p>
<p>1、 当需要保存数据的时候，需要lvalues。</p>
<p>2、 当需要读取数据的时候，需要rvalues。</p>
<h4 id="lvalues和rvalues角色的相互转换"><a href="#lvalues和rvalues角色的相互转换" class="headerlink" title="lvalues和rvalues角色的相互转换"></a>lvalues和rvalues角色的相互转换</h4><p>1、 根据表达式的上下文情况，lvalues在需要rvalues的地方会自动转换为rvalues。例如，</p>
<p>int n;</p>
<p>int m;</p>
<p>m &#x3D; n+2;&#x2F;&#x2F;这个表达式里n是rvalues</p>
<p>2、 rvalues永远不能转换为lvalues</p>
<p><strong>变量的内存寻址(与系统有关)</strong></p>
<p>(1)内存寻址由大到小，优先分配内存地址比较大的字节给变量，所以说变量越先定义，内存地址就越大。 如下面代码，先定义变量 a,再定义变量 b,打印出 a 的地址是 0x7fff5fbff828,b 的值是 0x7fff5fbff824。a 的地址比 b 的地址大 4 字节。栈的内存地址生长方向与堆相反，由高到底，所以后定义的变量地址低于先定义的变量，比如代码中变量 b的地址小于变量 a 的地址.</p>
<p>栈（stack）：由编译器进行管理，自动分配和释放，存放函数调用过程中的各种参数、局部变量、返回值以及函数返回地址。操作方式类似数据结构中的栈。</p>
<p>(2)变量地址的获取方式：&amp; 变量名。</p>
<p>(3)输出地址的方式：%p。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">  </span><br><span class="line">int main()   </span><br><span class="line">&#123;  </span><br><span class="line">      </span><br><span class="line">    int a;  </span><br><span class="line">    int b;  </span><br><span class="line">  </span><br><span class="line">    printf(&quot;a的地址是%p\nb的地址是%p\n&quot;,&amp;a,&amp;b);  </span><br><span class="line">    return 0;  </span><br><span class="line">     </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>(4)一个变量一定要先初始化才可以使用，因为 c 语言中默认一个没有初始化的变量值是一个不可知的很大值。如下面所示，a 没有初始化，打印出 a 的值是 -858993460。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">  </span><br><span class="line">int main()   </span><br><span class="line">&#123;  </span><br><span class="line">      </span><br><span class="line">    int a;  </span><br><span class="line">  </span><br><span class="line">    printf(&quot;a的值是%d\n&quot;,a);  </span><br><span class="line">    return 0;  </span><br><span class="line">     </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>全局变量和局部变量在内存中的区别</strong></p>
<p>全局变量保存在内存的全局存储区中，占用静态的存储单元；局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。</p>
<p>C语言经过编译之后将内存分为以下几个区域：</p>
<ul>
<li>（1）栈（stack）：由编译器进行管理，自动分配和释放，存放函数调用过程中的各种参数、局部变量、返回值以及函数返回地址。操作方式类似数据结构中的栈。</li>
<li>（2）堆（heap）：用于程序动态申请分配和释放空间。C语言中的malloc和free，C++中的new和delete均是在堆中进行的。正常情况下，程序员申请的空间在使用结束后应该释放，若程序员没有释放空间，则程序结束时系统自动回收。注意：这里的“堆”并不是数据结构中的“堆”。</li>
<li>（3）全局（静态）存储区：分为DATA段和BSS段。DATA段（全局初始化区）存放初始化的全局变量和静态变量；BSS段（全局未初始化区）存放未初始化的全局变量和静态变量。程序运行结束时自动释放。其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。</li>
<li>（4）文字常量区：存放常量字符串。程序结束后由系统释放。</li>
<li>（5）程序代码区：存放程序的二进制代码。</li>
</ul>
<p>显然，C语言中的全局变量和局部变量在内存中是有区别的。C语言中的全局变量包括外部变量和静态变量，均是保存在全局存储区中，占用永久性的存储单元；局部变量，即自动变量，保存在栈中，只有在所在函数被调用时才由系统动态在栈中分配临时性的存储单元。</p>
<p>栈的内存地址生长方向与堆相反，由高到底，所以后定义的变量地址低于先定义的变量.</p>
<p>堆的内存地址生长方向与栈相反，由低到高，但需要注意的是，后申请的内存空间并不一定在先申请的内存空间的后面，即 p2 指向的地址并不一定大于 p1 所指向的内存地址，原因是先申请的内存空间一旦被释放，后申请的内存空间则会利用先前被释放的内存，从而导致先后分配的内存空间在地址上不存在先后关系。堆中存储的数据若未释放，则其生命周期等同于程序的生命周期。</p>
<p>关于堆上内存空间的分配过程，首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序。另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确地释放本内存空间。由于找到的堆节点的大小不一定正好等于申请的大小，系统会自动地将多余的那部分重新放入空闲链表。</p>
<p><strong>变量定义：</strong>用于为变量分配存储空间，还可为变量指定初始值。程序中，变量有且仅有一个定义。</p>
<p><strong>变量声明</strong>：用于向程序表明变量的类型和名字。</p>
<p><strong>定义也是声明：</strong>当定义变量时我们声明了它的类型和名字。</p>
<p><strong>extern 声明不是定义：</strong>通过使用 extern 关键字声明变量名而不定义它。</p>
<p><strong>[注意]</strong></p>
<p>变量在使用前就要被定义或者声明。</p>
<p>在一个程序中，变量只能定义一次，却可以声明多次。</p>
<p>定义分配存储空间，而声明不会。</p>
<h2 id="堆与栈区别"><a href="#堆与栈区别" class="headerlink" title="堆与栈区别"></a>堆与栈区别</h2><p>堆与栈实际上是操作系统对进程占用的内存空间的两种管理方式，主要有如下几种区别：<br>（1）管理方式不同。栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏；</p>
<p>（2）空间大小不同。每个进程拥有的栈大小要远远小于堆大小。理论上，进程可申请的堆大小为虚拟内存大小，进程栈的大小 64bits 的 Windows 默认 1MB，64bits 的 Linux 默认 10MB；</p>
<p>（3）生长方向不同。堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低。</p>
<p>（4）分配方式不同。堆都是动态分配的，没有静态分配的堆。栈有 2 种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。动态分配由<code>alloca()</code>函数分配，但是栈的动态分配和堆是不同的，它的动态分配是由操作系统进行释放，无需我们手工实现。</p>
<p>（5）分配效率不同。栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是由C&#x2F;C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。</p>
<p>（6）存放内容不同。栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等。当主函数调用另外一个函数的时候，要对当前函数执行断点进行保存，需要使用栈来实现，首先入栈的是主函数下一条语句的地址，即扩展指针寄存器的内容（EIP），然后是当前栈帧的底部地址，即扩展基址指针寄存器内容（EBP），再然后是被调函数的实参等，一般情况下是按照从右向左的顺序入栈，之后是被调函数的局部变量，注意静态变量是存放在数据段或者BSS段，是不入栈的。出栈的顺序正好相反，最终栈顶指向主函数下一条语句的地址，主程序又从该地址开始执行。堆，一般情况堆顶使用一个字节的空间来存放堆的大小，而堆中具体存放内容是由程序员来填充的。</p>
<p>从以上可以看到，堆和栈相比，由于大量malloc()&#x2F;free()或new&#x2F;delete的使用，容易造成大量的内存碎片，并且可能引发用户态和核心态的切换，效率较低。栈相比于堆，在程序中应用较为广泛，最常见的是函数的调用过程由栈来实现，函数返回地址、EBP、实参和局部变量都采用栈的方式存放。虽然栈有众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，主要还是用堆。</p>
<p>无论是堆还是栈，在内存使用时都要防止非法越界，越界导致的非法内存访问可能会摧毁程序的堆、栈数据，轻则导致程序运行处于不确定状态，获取不到预期结果，重则导致程序异常崩溃，这些都是我们编程时与内存打交道时应该注意的问题。</p>
<p><strong>关于无符号的理解</strong></p>
<p>C语言中无符号字符型其实就是是长度为1个字节的整数，从本质上说也是整数类型，通常用来存放ASCII码。</p>
<p>整型分为无符号（unsigned）和有符号（signed）两种类型，默认整型变量是有符号的类型，char有点特别。需声明无符号类型就要在类型前加上unsigned。</p>
<p>无符号整型和有符号整型的区别在于无符号类型可以存放的正数范围比有符号整型中的范围大一倍，因为有符号类型将最高位储存符号，而无符号类型全都储存数字。</p>
<h3 id="const-关键字"><a href="#const-关键字" class="headerlink" title="const 关键字"></a>const 关键字</h3><p>您可以使用 <strong>const</strong> 前缀声明指定类型的常量，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const type variable = value;</span><br></pre></td></tr></table></figure>

<p>请注意，把常量定义为大写字母形式，是一个很好的编程习惯。</p>
<p><strong>#define</strong> 是宏定义，它不能定义常量，但宏定义可以实现在字面意义上和其它定义常量相同的功能，本质的区别就在于 <strong>#define</strong> 不为宏名分配内存，而 <strong>const</strong> 也不为常量分配内存，怎么回事呢，其实 <strong>const</strong> 并不是去定义一个常量，而是去改变一个变量的存储类，把该变量所占的内存变为只读！</p>
<p><strong>const</strong> 定义的是变量不是常量，只是这个变量的值不允许改变是常变量！带有类型。编译运行的时候起作用存在类型检查。</p>
<p><strong>define</strong> 定义的是不带类型的常数，只进行简单的字符替换。在预编译的时候起作用，不存在类型检查。</p>
<h2 id="1、两者的区别"><a href="#1、两者的区别" class="headerlink" title="1、两者的区别"></a>1、两者的区别</h2><p><strong>(1) 编译器处理方式不同</strong></p>
<ul>
<li>#define 宏是在预处理阶段展开。</li>
<li>const 常量是编译运行阶段使用。</li>
</ul>
<p><strong>(2) 类型和安全检查不同</strong></p>
<ul>
<li>#define 宏没有类型，不做任何类型检查，仅仅是展开。</li>
<li>const 常量有具体的类型，在编译阶段会执行类型检查。</li>
</ul>
<p><strong>(3) 存储方式不同</strong></p>
<ul>
<li>#define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。（宏定义不分配内存，变量定义分配内存。）</li>
<li>const常量会在内存中分配(可以是堆中也可以是栈中)。</li>
</ul>
<p><strong>(4) const 可以节省空间，避免不必要的内存分配。 例如：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define NUM 3.14159 //常量宏</span><br><span class="line">const doulbe Num = 3.14159; //此时并未将Pi放入ROM中 ......</span><br><span class="line">double i = Num; //此时为Pi分配内存，以后不再分配！</span><br><span class="line">double I= NUM; //编译期间进行宏替换，分配内存</span><br><span class="line">double j = Num; //没有内存分配</span><br><span class="line">double J = NUM; //再进行宏替换，又一次分配内存！</span><br></pre></td></tr></table></figure>

<p>const 定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象 #define 一样给出的是立即数，所以，const 定义的常量在程序运行过程中只有一份拷贝（因为是全局的只读变量，存在静态区），而 #define 定义的常量在内存中有若干个拷贝。</p>
<p><strong>(5) 提高了效率。 编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。</strong></p>
<p><strong>(6) 宏替换只作替换，不做计算，不做表达式求解;</strong></p>
<p>宏预编译时就替换了，程序运行时，并不分配内存。</p>
<p><strong>注：</strong></p>
<p>define 注意“边缘效应”，例：**#define N 2+3**, N 的值是 5。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double a;</span><br><span class="line">a = (float)N/(float)2;</span><br></pre></td></tr></table></figure>

<p>在编译时我们预想 <strong>a&#x3D;2.5</strong>，实际打印结果是 <strong>3.5</strong> 原因是在预处理阶段，编译器将 <strong>a&#x3D;N&#x2F;2</strong> 处理成 <strong>a&#x3D;2+3&#x2F;2</strong>，这就是 <strong>define</strong> 宏的边缘效应，所以我们应该写成 **#define N (2+3)**。</p>
<p><strong>小记：</strong>在 C 语言中，单引号与双引号是有很大区别的。</p>
<p>在 C 语言中没有专门的字符串类型，因此双引号内的字符串会被存储到一个数组中，这个字符串代表指向这个数组起始字符的指针；</p>
<p>而单引号中的内容是一个 char 类型，是一个字符，这个字符对应的是 ASCII 表中的序列值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/12/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github-hexo%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/12/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github-hexo%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2/" class="post-title-link" itemprop="url">如何使用github/hexo发布博客</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-12 16:33:26 / 修改时间：16:49:10" itemprop="dateCreated datePublished" datetime="2023-03-12T16:33:26+08:00">2023-03-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="date-2023-03-12-16-33-26"><a href="#date-2023-03-12-16-33-26" class="headerlink" title="date: 2023-03-12 16:33:26"></a>date: 2023-03-12 16:33:26</h2><p>tags:执行hexo n “如何使用github&#x2F;hexo发布博客” ，就会在blog&#x2F;source&#x2F;_posts路径下生成一个md文件，用markdown工具编辑好之后，御三套（<br><strong>hexo clean</strong><br><strong>hexo g</strong><br><strong>hexo d</strong>）走一波就可以你写的内容啦</p>
<p>使用“—</p>
<p>标题</p>
<p>—”命名标题</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/12/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/12/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-12 14:51:48" itemprop="dateCreated datePublished" datetime="2023-03-12T14:51:48+08:00">2023-03-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">肖汇林</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">肖汇林</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
