<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="选择有时候比努力更重要">
<meta property="og:type" content="website">
<meta property="og:title" content="肖汇林的博客">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="肖汇林的博客">
<meta property="og:description" content="选择有时候比努力更重要">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="肖汇林">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>肖汇林的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖汇林的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/Mysql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/Mysql/" class="post-title-link" itemprop="url">Mysql</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-05 14:59:57" itemprop="dateCreated datePublished" datetime="2023-09-05T14:59:57+08:00">2023-09-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-21 12:30:49" itemprop="dateModified" datetime="2023-09-21T12:30:49+08:00">2023-09-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MySQL是如何执行一条SQL"><a href="#MySQL是如何执行一条SQL" class="headerlink" title="MySQL是如何执行一条SQL"></a>MySQL是如何执行一条SQL</h1><p>Server层按顺序执行sql的步骤为：</p>
<ol>
<li>客户端请求-&gt;</li>
<li>连接器（验证用户身份，给予权限） -&gt;</li>
<li>查询缓存（存在缓存则直接返回，不存在则执行后续操作）-&gt;</li>
<li>分析器（对SQL进行词法分析和语法分析操作） -&gt; </li>
<li>优化器（主要对执行的sql优化选择最优的执行方案方法） -&gt; </li>
<li>执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）-&gt;</li>
<li>去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）</li>
</ol>
<p>简单概括：<br>连接器：管理连接、权限验证；<br>查询缓存：命中缓存则直接返回结果；<br>分析器：对SQL进行词法分析、语法分析；（判断查询的SQL字段是否存在也是在这步）<br>优化器：执行计划生成、选择索引；<br>执行器：操作引擎、返回结果；<br>存储引擎：存储数据、提供读写接口。</p>
<p><img src="/Mysql/image-20230905150235233.png" alt="image-20230905150235233"></p>
<img src="/2023/09/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/Mysql/image-20230905150235233.png" class title="This is an test image">

<h2 id="数据库中的主键、超键、候选键、外键"><a href="#数据库中的主键、超键、候选键、外键" class="headerlink" title="数据库中的主键、超键、候选键、外键"></a>数据库中的主键、超键、候选键、外键</h2><ul>
<li>超键：在关系中能唯一标识元组的属性集称为关系模式的超键 </li>
<li>候选键：不含有多余属性的超键称为候选键。也就是在候选键中，若再删除属性，就不是键了！ </li>
<li>主键：用户选作元组标识的一个候选键程序主键 </li>
<li>外键：如果关系模式R中属性K是其它模式的主键，那么k在模式R中称为外键。</li>
</ul>
<p>主键为候选键的子集，候选键为超键的子集，而外键的确定是相对于主键的。</p>
<h2 id="MySQL的内部构造"><a href="#MySQL的内部构造" class="headerlink" title="MySQL的内部构造"></a>MySQL的内部构造</h2><p>可以分为服务层和存储引擎层两部分，其中： 服务层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及 所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如 存储过程、触发器、视图等。 </p>
<p>存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个 存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认的存储引擎。</p>
<h2 id="Drop、Delete与Truncate的共同点和区别"><a href="#Drop、Delete与Truncate的共同点和区别" class="headerlink" title="Drop、Delete与Truncate的共同点和区别"></a>Drop、Delete与Truncate的共同点和区别</h2><p>Drop、Delete、Truncate都表示删除，但是三者有一些差别：<br>Delete用来删除表的全部或者一部分数据行，执行delete之后，用户需要提交(commmit)或者回滚<br>(rollback)来执行删除或者撤销删除，会触发这个表上所有的delete触发器。<br>Truncate删除表中的所有数据，这个操作不能回滚，也不会触发这个表上的触发器，TRUNCATE比<br>delete更快，占用的空间更小。<br>Drop命令从数据库中删除表，所有的数据行，索引和权限也会被删除，所有的DML触发器也不会被触<br>发，这个命令也不能回滚。<br>因此，在不再需要一张表的时候，用Drop；在想删除部分数据行时候，用Delete；在保留表而删除所有<br>数据的时候用Truncate。</p>
<h2 id="MySQL优化"><a href="#MySQL优化" class="headerlink" title="MySQL优化"></a>MySQL优化</h2><p>为搜索字段创建索引<br>避免使用 Select *，列出需要查询的字段<br>垂直分割分表<br>选择正确的存储引擎</p>
<h1 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h1><ul>
<li><strong>未提交读</strong>，事务中发生了修改，即使没有提交，其他事务也是可见的，比如对于一个数A原来50修改为100，但是我还没有提交修改，另一个事务看到这个修改，而这个时候原事务发生了回滚，这时候A还是50，但是另一个事务看到的A是100.<strong>可能会导致脏读、幻读或不可重复读</strong></li>
<li><strong>提交读</strong>，对于一个事务从开始直到提交之前，所做的任何修改是其他事务不可见的，举例就是对于一个数A原来是50，然后提交修改成100，这个时候另一个事务在A提交修改之前，读取的A是50，刚读取完，A就被修改成100，这个时候另一个事务再进行读取发现A就突然变成100了；<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li>
<li><strong>重复读</strong>，就是对一个记录读取多次的记录是相同的，比如对于一个数A读取的话一直是A，前后两次读取的A是一致的；<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong></li>
<li><strong>可串行化读</strong>，通过强制事务串行执行来实现最高的数据隔离性，在并发情况下，和串行化的读取的结果是一致的，没有什么不同，比如不会发生脏读和幻读；<strong>该级别可以防止脏读、不可重复读以及幻读</strong></li>
</ul>
<p>需要注意的是，隔离级别越高，数据的一致性越好，但可能会对并发性能产生负面影响。因此，在应用开发中，需要根据实际情况选择适合的隔离级别</p>
<p>幻影读（Phantom Read）：幻影读指在一个事务中，当多次查询同一范围的数据时，得到的结果集不一致。通常是由于其他事务在这期间对数据做了插入、更新或删除操作，导致当前事务看到了新增或删除的数据行。幻影读是在可重复读隔离级别下的一种问题。</p>
<p>脏读（Dirty Read）：脏读指一个事务读取到了另一个未提交的事务的数据。换句话说，一个事务可以读取到尚未被其他事务确认的数据，这样的读取可能是不正确或不一致的。脏读是在读未提交隔离级别下的一种问题。</p>
<p>不可重复读（Non-Repeatable Read）是数据库中的一种并发问题，它指在一个事务内，多次读取同一数据得到的结果不一致。</p>
<p><strong>不可重复读的重点是修改，幻读的重点在于新增或者删除。</strong></p>
<p><strong>数据库并发</strong>会带来脏读、幻读、丢弃更改、不可重复读这四个常见问题，其中：</p>
<ul>
<li>脏读：在第一个修改事务和读取事务进行的时候，读取事务读到的数据为100，这是修改之后的数据，但是之后该事务满足一致性等特性而做了回滚操作，那么读取事务得到的结果就是脏数据了。</li>
<li>幻读：一般是T1在某个范围内进行修改操作（增加或者删除），而T2读取该范围导致读到的数据是修改之间的了，强调范围。</li>
<li>丢弃修改：两个写事务T1 T2同时对A&#x3D;0进行递增操作，结果T2覆盖T1，导致最终结果是1 而不是2，事务被覆盖</li>
<li>不可重复读：T2 读取一个数据，然后T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</li>
</ul>
<h1 id="MyISAM和InnoDB实现B树索引方式的区别是什么"><a href="#MyISAM和InnoDB实现B树索引方式的区别是什么" class="headerlink" title="MyISAM和InnoDB实现B树索引方式的区别是什么"></a>MyISAM和InnoDB实现B树索引方式的区别是什么</h1><p>InnoDB(<strong>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎</strong>)和MyISAM是MySQL中两种常见的存储引擎</p>
<ol>
<li>事务: InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。 </li>
<li>并发: MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</li>
<li>外键: InnoDB 支持外键。 </li>
<li>备份: InnoDB 支持在线热备份。</li>
<li>崩溃恢复: MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。 </li>
<li>其它特性: MyISAM 支持压缩表和空间数据索引。</li>
</ol>
<ul>
<li>MyISAM，B+Tree叶节点的<strong>data域存放的是数据记录的地址</strong>，在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录，这被称为“<strong>非聚簇索引</strong>”</li>
<li>InnoDB，其<strong>数据文件本身就是索引文件</strong>，相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，<strong>树的节点data域保存了完整的数据记录</strong>，这个索引的key是数据表的主键，因此<strong>InnoDB表数据文件本身就是主索引</strong>，这被称为“<strong>聚簇索引</strong>”或者聚集索引，而其余的索引都作为辅助索引，<strong>辅助索引的data域存储相应记录主键的值而不是地址</strong>，这也是和MyISAM不同的地方。<br>在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。因此，在设计表的时候，不建议使用过长的字段为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</li>
</ul>
<p>聚簇索引就是按照拼音查询，非聚簇索引就是按照偏旁等来进行查询。</p>
<p>我们把这种正文内容本身就是一种按照一定规则排列的目录称为”聚集索引”</p>
<p>我们把这种目录纯粹是目录，正文纯粹是正文的排序方式称为”非聚集索引”。</p>
<p>非聚集索引和聚集索引的区别在于， 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以 查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据。 聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。 </p>
<p>聚集索引（Innodb）的叶节点就是数据节点，而非聚集索引(MyisAM)的叶节点仍然是索引节点，只不 过其包含一个指向对应数据块的指针。</p>
<h2 id="InnoDB、MyISAM的区别"><a href="#InnoDB、MyISAM的区别" class="headerlink" title="InnoDB、MyISAM的区别"></a>InnoDB、MyISAM的区别</h2><p>1）事务：MyISAM不支持，InnoDB支持<br>2）锁级别： MyISAM 表级锁，InnoDB 行级锁及外键约束<br>3）MyISAM存储表的总行数；InnoDB不存储总行数；<br>4）MyISAM采用非聚集索引，B+树叶子存储指向数据文件的指针。InnoDB主键索引采用聚集索引，B+树叶子存储数据<br>适用场景：<br>MyISAM适合： 插入不频繁，查询非常频繁，如果执行大量的SELECT，MyISAM是更好的选择， 没有<br>事务。<br>InnoDB适合： 可靠性要求比较高，或者要求事务； 表更新和查询都相当的频繁， 大量的INSERT或<br>UPDATE</p>
<h2 id="数据库索引采用B-树而不是B树"><a href="#数据库索引采用B-树而不是B树" class="headerlink" title="数据库索引采用B+树而不是B树"></a>数据库索引采用B+树而不是B树</h2><p>主要原因：B+树只要遍历叶子节点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频 繁的，而B树只能中序遍历所有节点，效率太低。</p>
<h2 id="文件索引和数据库索引为什么使用B-树"><a href="#文件索引和数据库索引为什么使用B-树" class="headerlink" title="文件索引和数据库索引为什么使用B+树"></a>文件索引和数据库索引为什么使用B+树</h2><p>文件与数据库都是需要较大的存储，也就是说，它们都不可能全部存储在内存中，故需要存储到磁盘上。而所谓索引，则为了数据的快速定位与查找，那么索引的结构组织要尽量减少查找过程中磁盘I&#x2F;O 的存取次数，因此B+树相比B树更为合适。数据库系统巧妙利用了局部性原理与磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I&#x2F;O就可以完全载入，而红黑树这种结构，高度明显要深的多，并且由于逻辑上很近的节点(父子)物理上可能很远，无法利用局部性。 </p>
<p>最重要的是，B+树还有一个最大的好处：方便扫库。 B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query(范围查询) 非常方便，而B树不支持，这是数据库选用B+树的最主要原因。 B+树查找效率更加稳定，B树有可能在中间节点找到数据，稳定性不够。 B+tree的磁盘读写代价更低：B+tree的内部结点并没有指向关键字具体信息的指针(红色部分)，因此其内部结点相对B 树更小。</p>
<p>如果把所有同一内部结点的关键字存放在同一块盘中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多，相对来说IO读写次数也就降低了； B+tree的查询效率更加稳定：由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引，所以，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相 同，导致每一个数据的查询效率相当；</p>
<h1 id="视图和游标"><a href="#视图和游标" class="headerlink" title="视图和游标"></a>视图和游标</h1><ol>
<li>视图：视图是数据库中的一个虚拟表，它是基于一个或多个实际表的查询结果集。视图可以对表进行过滤、重命名、聚合等操作，以便提供更简洁、易读的数据展示形式。使用视图可以隐藏底层表结构的复杂性，同时还可以提供额外的安全性，因为只有授权的用户能够访问视图。</li>
<li>游标：游标是一种用于在数据库中遍历和操作结果集的数据库对象。它通常与存储过程或触发器等数据库编程功能一起使用。游标可以将一个结果集保存在内存中，并提供对该结果集的逐行访问。通过游标，可以在结果集中移动、检索和修改数据。游标可用于实现对查询结果的精确控制，甚至可以在结果集上进行随机访问。</li>
</ol>
<p>视图主要用于提供简化和安全的数据访问方式，而游标主要用于对结果集进行编程式的遍历和操作。</p>
<h1 id="MySQL中事务回滚机制"><a href="#MySQL中事务回滚机制" class="headerlink" title="MySQL中事务回滚机制"></a>MySQL中事务回滚机制</h1><p>MySQL的事务是指由一组数据库操作语句构成的逻辑处理单元，它们在数据库中原子性地执行，要么同时成功，要么同时失败，具有一致性和持久性的特征</p>
<p><strong>MySQL的事务实现了四个基本属性，简称ACID</strong>：</p>
<ol>
<li>Atomicity（原子性）：事务可以看做是一组不可分割的操作，要么全部执行成功，要么全部执行失败。当任何一个操作失败时，MySQL会自动回滚所有已经执行的操作，保证数据的一致性。如果所有操作都执行成功，MySQL会将它们提交到数据库中，保证数据的持久性。</li>
<li>Consistency（一致性）：在事务执行期间，不会破坏数据库的完整性和约束条件。这意味着只有满足表中所有的约束条件，事务才可以提交成功。如果任何一个约束条件失败，整个事务会被回滚，以保证所有数据的一致性。</li>
<li>Isolation（隔离性）：多个事务同时运行时，他们的修改互不干扰。MySQL通过使用锁机制来实现隔离性，保证了在并发访问时对数据的正确性和完整性。</li>
<li>Durability（持久性）：一旦事务提交，其所做出的修改将永远保存到数据库中，即使出现系统故障也不会丢失。这是通过在提交事务之前将所有相关数据和日志写入磁盘中来实现的。</li>
</ol>
<p>而在 MySQL 中，恢复机制是通过回滚日志（undo log）实现的，所有事务进行的修改都会先记录到这个 回滚日志中，然后在对数据库中的对应行进行写入。 当事务已经被提交之后，就无法再次回滚了。 </p>
<p>回滚日志作用： </p>
<ul>
<li>能够在发生错误或者用户执行 ROLLBACK 时提供回滚相关的信息 </li>
<li>在整个系统发生崩溃、数据库进程直接被杀死后，当用户再次启动数据库进程时，还能够立刻通过查询回滚日志将之前未完成的事务进行回滚，这也就需要<strong>回滚日志必须先于数据持久化到磁盘</strong>上，是我们需要<strong>先写日志后写数据库</strong>的主要原因。</li>
</ul>
<h1 id="数据库悲观锁和乐观锁"><a href="#数据库悲观锁和乐观锁" class="headerlink" title="数据库悲观锁和乐观锁"></a>数据库悲观锁和乐观锁</h1><p><strong>悲观锁，先获取锁，再进行业务操作</strong>，一般就是利用类似 SELECT … FOR UPDATE 这样的语句(它会获取选定的行的排他锁，以确保在事务中其它会话无法修改或删除这些行。这个功能通常在需要读取数据并且希望保持数据一致性的情况下使用)，对数据加锁，避免其他事务意外修改数据。 当数据库执行SELECT … FOR UPDATE时会获取被select中的数据行的行锁，select for update获取的行锁 会在当前事务结束时自动释放，因此必须在事务中使用。 </p>
<p><strong>乐观锁，先进行业务操作，只在最后实际更新数据时进行检查数据是否被更新过</strong>。Java 并发包中的 AtomicFieldUpdater 类似，也是利用 CAS 机制，并不会对数据加锁，而是通过对比数据的时间戳或者版本号，来实现乐观锁需要的版本判断。</p>
<h1 id="MySQL索引主要使用的两种数据结构"><a href="#MySQL索引主要使用的两种数据结构" class="headerlink" title="MySQL索引主要使用的两种数据结构"></a>MySQL索引主要使用的两种数据结构</h1><ul>
<li><p><strong>哈希索引</strong>，对于哈希索引来说，底层的数据结构肯定是哈希表，因此在<strong>绝大多数需求为单条记录查询</strong> 的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引 </p>
</li>
<li><p><strong>BTree索引</strong>，Mysql的BTree索引使用的是B树中的B+Tree，BTREE索引就是一种将索引值按一定的算 法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获 取leaf。 但对于主要的两种存储引擎（MyISAM和InnoDB）的实现方式是不同的</p>
</li>
</ul>
<h1 id="数据库分库和分表"><a href="#数据库分库和分表" class="headerlink" title="数据库分库和分表"></a>数据库分库和分表</h1><p>分库与分表的目的在于，减小数据库的单库单表负担，提高查询性能，缩短查询时间。</p>
<ol>
<li><p>数据库分库（Sharding）： 数据库分库是将一个大型数据库按照一定规则划分为多个较小的数据库实例。每个数据库实例通常被部署在不同的服务器或节点上，并独立处理自己的数据。这样可以将数据库负载分散到多个节点上，有效提高数据库的并发处理能力和可扩展性。</p>
<p>数据库分库的常见划分策略包括：</p>
<ul>
<li>垂直分库：按照业务功能或数据模块将数据库划分为不同的库，例如将用户信息、订单信息、日志信息等分别存储在不同的库中。</li>
<li>水平分库：按照数据记录的某个属性（如用户ID、时间范围等）将数据库划分为多个库，例如按照用户ID的哈希值划分。</li>
</ul>
</li>
<li><p>数据库分表（Sharding）： 数据库分表是将一个大型表按照一定规则拆分为多个较小的表。每个小表通常分散存储在不同的数据库实例中，以平衡数据负载和提高查询性能。每个小表具有相同的表结构，但包含不同的数据。</p>
<p>数据库分表的常见拆分策略包括：</p>
<ul>
<li>垂直分表：按照业务功能或数据模块将表中的列划分到不同的表中，例如将用户信息中的基本信息和详细信息存储在两个表中。</li>
<li>水平分表：按照数据记录的某个属性（如时间范围、地理位置等）将表中的数据划分到多个表中，例如按照订单创建时间将订单表拆分为多个表。</li>
</ul>
<p>在进行数据库分表时，可以使用一些标识来确定数据应该存储在哪个表中，以便后续查询时可以正确定位到目标表。</p>
</li>
</ol>
<h1 id="MySQL四种索引类型"><a href="#MySQL四种索引类型" class="headerlink" title="MySQL四种索引类型"></a>MySQL四种索引类型</h1><ol>
<li>B-Tree索引（默认索引）： B-Tree（B树）索引是MySQL中最常用的索引类型，适用于各种查询条件和数据类型。B-Tree索引以平衡树的结构存储数据，可以快速地定位到满足查询条件的数据行。它对于范围查询、排序和分组等操作效果较好。</li>
<li>哈希索引： 哈希索引使用哈希算法将索引键值映射为特定的桶（bucket）地址，从而实现快速的查找。哈希索引适合于等值查询，但不支持范围查询，也无法利用索引进行排序操作。此外，哈希索引对于重复键值的处理较为复杂。</li>
<li>全文索引（Full-Text Index）： 全文索引主要用于对文本内容进行搜索，例如文章、日志、博客等。它可以高效地实现全文本关键字的模糊匹配，并支持各种自然语言的搜索功能。全文索引适用于包含大量文本的列，如VARCHAR和TEXT类型的字段。</li>
<li>空间索引（Spatial Index）：包括RTREE， 空间索引用于优化地理空间数据的查询，例如基于位置的搜索和距离计算。空间索引支持各种地理数据类型，如点、线、面等，并提供了丰富的查询函数和操作符来处理地理空间数据。空间索引在处理地理信息系统（GIS）和位置服务等应用中广泛使用。</li>
</ol>
<h2 id="建立数据库索引"><a href="#建立数据库索引" class="headerlink" title="建立数据库索引"></a>建立数据库索引</h2><p>在最频繁使用的、用以缩小查询范围的字段,需要排序的字段上建立索引。 </p>
<p>不宜： </p>
<p>1）对于查询中很少涉及的列或者重复值比较多的列 </p>
<p>2）对于一些特殊的数据类型，不宜建立索引，比如文本字段（text）等。</p>
<p><strong>创建索引时需要注意什么</strong></p>
<p><strong>非空字段</strong>：应该指定列为NOT NULL，除非你想存储NULL。在 MySQL 中，含有空值的列很难进行查 询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者 一个空串代替空值； </p>
<p><strong>取值离散大的字段</strong>：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数 查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高； </p>
<p><strong>索引字段越小越好</strong>：数据库的数据存储以页为单位，一页存储的数据越多一次IO操作获取的数据越大效率 越高。 </p>
<p>唯一、不为空、经常被查询的字段 的字段适合建索引</p>
<h2 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h2><p>索引是对数据库表中一列或多列的值进行排序的一种数据结构，也就是说索引是一种数据结 构。数据库在执行一条Sql语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配 条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中通 过二分法等高效率算法一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增 加查询性能。类似新华字典的目录，如果没有目录的话，我们想要查找一个汉字的话，就必 须检索整本字典，而正因为有了目录，我们只要知道我们所要查找的偏旁或者拼音首字母， 就可以快速地定位到我们想要查找汉字的所在页码。</p>
<h2 id="索引使用的注意事项"><a href="#索引使用的注意事项" class="headerlink" title="索引使用的注意事项"></a>索引使用的注意事项</h2><p>不要在列上使用函数，这将导致索引失效而进行全表扫描</p>
<p>尽量避免使用 !&#x3D; 或 not in或 &lt;&gt; 等否定操作符</p>
<ul>
<li>应该尽量避免在 where 子句中使用 !&#x3D; 或 not in 或 &lt;&gt; 操作符，因为这几个操作符都会导致索引失效而进 行全表扫描。尽量避免使用 or 来连接条件 应该尽量避免在 where 子句中使用 or 来连接条件，因为这会导致索引失效而进行全表扫描。</li>
</ul>
<p>多个单列索引并不是最佳选择 MySQL 只能使用一个索引，会从多个索引中选择一个限制最为严格的索引，因此，为多个列创建单列 索引，并不能提高 MySQL 的查询性能。</p>
<ul>
<li>假设，有两个单列索引，分别为 news_year_idx(news_year) 和 news_month_idx(news_month)。现在，有一个场景需要针对资讯的年份和月份进行查询，那么，SQL 语句可以写成：<code>select * from news where news_year = 2017 and news_month = 1</code> 事 实 上 ， MySQL 只 能 使 用 一 个 单 列 索 引 。 为 了 提 高 性 能 ， 可 以 使 用 复 合 索 引 <code>news_year_month_idx(news_year, news_month)</code> 保证 news_year 和 news_month 两个列都被索引覆盖。</li>
</ul>
<p>复合索引的最左前缀原则</p>
<ul>
<li>复合索引遵守“最左前缀”原则，即在<strong>查询条件中使用了复合索引的第一个字段，索引才会被使用</strong>。因 此，在复合索引中索引列的顺序至关重要。如果不是按照索引的最左列开始查找，则无法使用索引。 假设，有一个场景只需要针对资讯的月份进行查询，那么，SQL 语句可以写成：<code>select * from news where news_month = 1</code>	此时，无法使用 <code>news_year_month_idx(news_year, news_month)</code> 索引，因为遵守“最左前缀”原则，在查询 条件中没有使用复合索引的第一个字段，索引是不会被使用的。</li>
</ul>
<p>覆盖索引的好处</p>
<ul>
<li>如果一个索引包含所有需要的查询的字段的值，直接根据索引的查询结果返回数据，而无需读表，能够 极大的提高性能。因此，可以定义一个让索引包含的额外的列，即使这个列对于索引而言是无用的。</li>
</ul>
<p>范围查询对多列查询的影响</p>
<ul>
<li>查询中的某个列有范围查询，则其右边所有列都无法使用索引优化查找。</li>
</ul>
<p>索引不会包含有NULL值的列</p>
<ul>
<li>只要列中包含有 NULL 值都将不会被包含在索引中，复合索引中只要有一列含有 NULL值，那么这一列 对于此复合索引就是无效的。因此，在数据库设计时，除非有一个很特别的原因使用 NULL 值，不然尽量不要让字段的默认值为 NULL。</li>
</ul>
<p>隐式转换的影响</p>
<ul>
<li>当查询条件左右两侧类型不匹配的时候会发生隐式转换，隐式转换带来的影响就是可能导致索引失效而 进行全表扫描。</li>
</ul>
<p>like 语句的索引失效问题</p>
<ul>
<li>like 的方式进行查询，在 like “value%” 可以使用索引，但是对于 like “%value%” 这样的方式，执行全表查询，这在数据量小的表，不存在性能问题，但是对于海量数据，全表扫描是非常可怕的事情。所以，根据业务需求，考虑使用 ElasticSearch 或 Solr 是个不错的方案。<code>SELECT * FROM table WHERE column LIKE &#39;abc%&#39;</code></li>
</ul>
<h2 id="有哪些索引"><a href="#有哪些索引" class="headerlink" title="有哪些索引"></a>有哪些索引</h2><ol>
<li>普通索引：仅加速查询</li>
<li>唯一索引：加速查询 + 列值唯一（可以有null）</li>
<li>主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个</li>
<li>组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</li>
<li>全文索引：对文本的内容进行分词，进行搜索</li>
<li>索引合并：使用多个单列索引组合搜索</li>
<li>覆盖索引：select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖</li>
<li>聚簇索引：表数据是和主键一起存储的，主键索引的叶结点存储行数据(包含了主键值)，二级索引的叶结点存储行的主键值。使用的是B+树作为索引的存储结构，非叶子节点都是索引关键字，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录(数据内容）</li>
</ol>
<h1 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h1><p>第一范式<br>在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。 所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。简而言之，<strong>第一范式就是无重复的列</strong>。</p>
<p>第二范式<br>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为<strong>主关键字或主键、主码</strong>。 第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是<strong>非主属性非部分依赖于主关键字</strong>。</p>
<p>第三范式<br>满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。<br>简而言之，第三范式就是<strong>属性不依赖于其它非主属性</strong>。</p>
<p>第一范式（1NF）：字段不可分；<br> 第二范式（2NF）：有主键，非主键字段依赖主键；<br> 第三范式（3NF）：非主键字段不能相互依赖。<br>解释：<br> 1NF：原子性。 字段不可再分,否则就不是关系数据库;；<br> 2NF：唯一性 。一个表只说明一个事物；<br> 3NF：每列都与主键有直接关系，不存在传递依赖。</p>
<h1 id="MySQL中CHAR和VARCHAR"><a href="#MySQL中CHAR和VARCHAR" class="headerlink" title="MySQL中CHAR和VARCHAR"></a>MySQL中CHAR和VARCHAR</h1><ul>
<li>char的长度是不可变的，用空格填充到指定长度大小，而varchar的长度是可变的。</li>
<li>char的存取速度还是要比varchar要快得多</li>
<li>char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。</li>
</ul>
<h1 id="数据库表锁和行锁"><a href="#数据库表锁和行锁" class="headerlink" title="数据库表锁和行锁"></a>数据库表锁和行锁</h1><h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><p>不会出现死锁，发生锁冲突几率高，并发低。<br>MyISAM在执行查询语句（select）前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给涉及的表加写锁。</p>
<p>MySQL的表级锁有两种模式：<strong>表共享读锁和表独占写锁</strong>。</p>
<p>读锁会阻塞写，写锁会阻塞读和写</p>
<ul>
<li>对MyISAM表的读操作，不会阻塞其它进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作。</li>
<li>对MyISAM表的写操作，会阻塞其它进程对同一表的读和写操作，只有当写锁释放后，才会执行其它进程的读写操作。</li>
</ul>
<p>MyISAM不适合做写为主表的引擎，因为写锁后，其它线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。</p>
<h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>会出现死锁，发生锁冲突几率低，并发高。 在MySQL的InnoDB引擎支持行锁，与Oracle不同，MySQL的行锁是通过索引加载的，也就是说，行锁 是加在索引响应的行上的，要是对应的SQL语句没有走索引，则会全表扫描，行锁则无法实现，取而代 之的是表锁，此时其它事务无法对当前表进行更新或插入操作。</p>
<p>行锁的实现需要注意：</p>
<ul>
<li>行锁必须有索引才能实现，否则会自动锁全表，那么就不是行锁了。 </li>
<li>两个事务不能锁同一个索引。 </li>
<li>insert，delete，update在事务中都会自动默认加上排它锁。</li>
</ul>
<p>行锁的适用场景： A用户消费，service层先查询该用户的账户余额，若余额足够，则进行后续的扣款操作；这种情况查询 的时候应该对该记录进行加锁。 否则，B用户在A用户查询后消费前先一步将A用户账号上的钱转走，而此时A用户已经进行了用户余额 是否足够的判断，则可能会出现余额已经不足但却扣款成功的情况。 为了避免此情况，需要在A用户操作该记录的时候进行for update加锁</p>
<h1 id="内连接、自连接、外连接（左、右、全）、交叉连接"><a href="#内连接、自连接、外连接（左、右、全）、交叉连接" class="headerlink" title="内连接、自连接、外连接（左、右、全）、交叉连接"></a>内连接、自连接、外连接（左、右、全）、交叉连接</h1><p>内连接：只有两个元素表相匹配的才能在结果集中显示。<br>外连接： 左外连接: 左边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。右外连接:右边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。<br>全外连接：连接的表中不匹配的数据全部会显示出来。<br>交叉连接： 笛卡尔效应，显示的结果是链接表数的乘积。结果集包括了 <code>table1</code> 中的每一行和 <code>table2</code> 中的每一行的所有可能组合。注意，交叉连接可能会生成非常大的结果集，通常需要与其他查询条件一起使用来缩小结果集大小，避免无意义的数据计算和传输。</p>
<h1 id="数据库高并发解决方案"><a href="#数据库高并发解决方案" class="headerlink" title="数据库高并发解决方案"></a>数据库高并发解决方案</h1><ul>
<li>在web服务框架中加入缓存。在服务器与数据库层之间加入缓存层，将高频访问的数据存入缓存中，减少数据库的读取负担。</li>
<li>增加数据库索引，进而提高查询速度。（不过索引太多会导致速度变慢，并且数据库的写入会导致索引的更新，也会导致速度变慢）</li>
<li>主从读写分离，让主服务器负责写，从服务器负责读。</li>
<li>将数据库进行拆分，使得数据库的表尽可能小，提高查询的速度。</li>
<li>使用分布式架构，分散计算压力。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/03/c%E5%92%8Cc++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%EF%BC%883%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/03/c%E5%92%8Cc++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%EF%BC%883%EF%BC%89/" class="post-title-link" itemprop="url">数据结构-（3）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-09-03 21:39:11 / 修改时间：22:05:26" itemprop="dateCreated datePublished" datetime="2023-09-03T21:39:11+08:00">2023-09-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="企业链表"><a href="#企业链表" class="headerlink" title="企业链表"></a>企业链表</h1><p>传统链表包含数据域和指针域，就是我们从课本上学到的那一种。</p>
<p> 而企业链表把 “挂钩” 放在了结构体的首地址，挂钩指向挂钩，从而把表了连接起来。 </p>
<p>linux呢，则是把 ”挂钩“ 放在了底部，那么串的时候就需要自己计算偏移量。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%EF%BC%883%EF%BC%89/image-20230903214441893.png" alt="image-20230903214441893"></p>
<img src="/2023/09/03/c%E5%92%8Cc++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%EF%BC%883%EF%BC%89/image-20230903214441893.png" class title="This is an test image">

<p>首先 ，按照传统的方式去写节点的结构体是这样子的，包含数据域和指针域。在企业链表中，我们定义的时候，仅仅保留指针域，相当于这只是 一个 ”挂钩“</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef struct LINKNODE&#123;</span><br><span class="line">	struct LINKNODE* next;</span><br><span class="line">&#125; LinkNode;</span><br></pre></td></tr></table></figure>

<p>怎么样去使用它呢？ 我们先定义一个自己平时使用的数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct MyData &#123;</span><br><span class="line">	LinkNode node;</span><br><span class="line">	char name[64];</span><br><span class="line">	int age;</span><br><span class="line">&#125;Mydata;</span><br></pre></td></tr></table></figure>

<p>如此一来，我们的每个结构体都包含这个 ”挂钩“ ，而这个 ”挂钩“ 呢，可以指向 ”挂钩“ 类型的数据。</p>
<p>然后呢，我们的 ”挂钩“ 在我们自定义 结构体的首地址。 因此，我们只需要把我们的自定义 结构体<code>Mydata*</code>类型的数据转换成 <code>LinKNode*</code>的数据类型，就可以将各个节点串起来了，具体操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mydata datal;</span><br><span class="line">LinKNode* node = (LinkNode*) &amp;(datal);</span><br></pre></td></tr></table></figure>

<p>这样的类型转换数据并不会丢失，仅仅只是LinKNode类型的指针访问不到我们的Mydata结构体中的其它数据而已，而当我们需要对Mydata中的数据进行操作时，很简单，把类型转换成Mydata指 针类型即可。</p>
<hr>
<p>最小生成树（Minimum Spanning Tree，简称MST）是在无向连通图中的一棵生成树，它包含了图中的所有顶点，并且具有最小的总权值。生成树是图的一个子图，它是一颗树，连接了图中所有的顶点，但没有形成环。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/02/c%E5%92%8Cc++/%E5%AF%B9%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9A%84%E8%A1%A5%E5%85%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/02/c%E5%92%8Cc++/%E5%AF%B9%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9A%84%E8%A1%A5%E5%85%85/" class="post-title-link" itemprop="url">对面试题的补充</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-09-02 15:43:44 / 修改时间：15:50:02" itemprop="dateCreated datePublished" datetime="2023-09-02T15:43:44+08:00">2023-09-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="网络地址和广播地址"><a href="#网络地址和广播地址" class="headerlink" title="网络地址和广播地址"></a>网络地址和广播地址</h2><p>192.168.1.53&#x2F;27 的相应子网掩码是11111111.11111111.11111111.11100000，所有可用的主机数为主机号所剩下的5位掩码中算出</p>
<p>8位主机号减少网络号借去的3位，所剩下5位。即n&#x3D;8-m&#x3D;5。即最多可以容纳的主机数位 32，可用的主机数为 30</p>
<p>减去2是因为用于表示网络和广播地址，最多可以容纳的主机与可用主机数不是一回事。</p>
<p>先把IP地址转换成二进制，然后与二进制的子网掩码进行与运算，得到的就是网络地址。</p>
<p>广播地址是在网络地址的基础上，将网络号右边的表示IP地址的主机部分的二进制全部填上1，再将得到的二进制转化为十进制就可以得到广播地址。</p>
<p><img src="/%E5%AF%B9%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9A%84%E8%A1%A5%E5%85%85/image-20230902154859245.png" alt="image-20230902154859245"></p>
<img src="/2023/09/02/c%E5%92%8Cc++/%E5%AF%B9%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9A%84%E8%A1%A5%E5%85%85/image-20230902154859245.png" class title="This is an test image">

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/02/c%E5%92%8Cc++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/02/c%E5%92%8Cc++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/" class="post-title-link" itemprop="url">数据结构-2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-02 10:52:11" itemprop="dateCreated datePublished" datetime="2023-09-02T10:52:11+08:00">2023-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-01 14:56:21" itemprop="dateModified" datetime="2023-11-01T14:56:21+08:00">2023-11-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="左旋字符串"><a href="#左旋字符串" class="headerlink" title="左旋字符串"></a>左旋字符串</h1><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字 符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结 果”cdefgab”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">char* reverseLeftWords(char* s, int n)&#123;</span><br><span class="line"> 	int i=0;</span><br><span class="line"> 	int len=strlen(s);</span><br><span class="line"> 	char *t=malloc(sizeof(char)*(len+1));</span><br><span class="line"> 	while(i&lt;len)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		t[i++]=s[(n+(i))%len];</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	t[len]=&#x27;\0&#x27;;</span><br><span class="line"> 	return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="reverse反转解法"><a href="#reverse反转解法" class="headerlink" title="reverse反转解法"></a>reverse反转解法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"> 	string reverseLeftWords(string s, int n) &#123;</span><br><span class="line"> 		reverse(s.begin(),s.begin()+n);</span><br><span class="line"> 		reverse(s.begin()+n,s.end());</span><br><span class="line"> 		reverse(s.begin(),s.end());</span><br><span class="line"> 		return s;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h1><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<p>示例 1： 限制：0 &lt;&#x3D; 节点个数 &lt;&#x3D; 1000 </p>
<h2 id="前序递归解法"><a href="#前序递归解法" class="headerlink" title="前序递归解法"></a>前序递归解法</h2><p>使用递归（前序遍历），让每一个节点的左右孩子互换位置 需要注意的是，这种方法必须要检查传入的二叉树是否合法，即该树不为空，否则无法执行。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode* mirrorTree(struct TreeNode* root)&#123;</span><br><span class="line"> 	if(root)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		struct TreeNode* temp=root-&gt;left;</span><br><span class="line"> 		root-&gt;left=root-&gt;right;</span><br><span class="line"> 		root-&gt;right=temp;</span><br><span class="line"> 		mirrorTree(root-&gt;left);</span><br><span class="line"> 		mirrorTree(root-&gt;right);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode* mirrorTree(struct TreeNode* root)&#123;</span><br><span class="line"> 	if(root)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		struct TreeNode *temp=root-&gt;left;</span><br><span class="line"> 		root-&gt;left=mirrorTree(root-&gt;right);</span><br><span class="line"> 		root-&gt;right=mirrorTree(temp);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码简洁，而且可读性强</p>
<h2 id="C-版"><a href="#C-版" class="headerlink" title="C++版"></a>C++版</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"> 	TreeNode* mirrorTree(TreeNode* root) &#123;</span><br><span class="line"> 		if(root)</span><br><span class="line"> 		&#123;</span><br><span class="line"> 			TreeNode *temp=root-&gt;left;</span><br><span class="line"> 			root-&gt;left=mirrorTree(root-&gt;right);</span><br><span class="line"> 			root-&gt;right=mirrorTree(temp);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		return root;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="哈希查找"><a href="#哈希查找" class="headerlink" title="哈希查找"></a>哈希查找</h1><p>哈希查找算法又称散列查找算法，是一种借助哈希表（散列表）查找目标元素的方法，查找效率最高时对应的时间复杂度为 O(1)。</p>
<p>使用数组构建哈希表，最大的好处在于：可以直接将数组下标当作已存储元素的索引，不再需要为每个元素手动配置索引，极大得简化了构建哈希表的难度。</p>
<p>我们知道，在数组中查找一个元素，除非提前知晓它存储位置处的下标，否则只能遍历整个数组。哈希表的解决方案是：各个元素并不从数组的起始位置依次存储，它们的存储位置由专门设计的函数计算得出，我们通常将这样的函数称为哈希函数。</p>
<p>哈希函数类似于数学中的一次函数，我们给它传递一个元素，它反馈给我们一个结果值，这个值就是该元素对应的索引，也就是存储到哈希表中的位置。</p>
<p>举个例子，将 {20, 30, 50, 70, 80} 存储到哈希表中，我们设计的哈希函数为 y&#x3D;x&#x2F;10，最终各个元素的存储位置如下图所示：</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/image-20230902155837486.png" alt="image-20230902155837486"></p>
<img src="/2023/09/02/c%E5%92%8Cc++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/image-20230902155837486.png" class title="This is an test image">

<p>假设我们想查找元素 50，只需将它带入 y&#x3D;x&#x2F;10 这个哈希函数中，计算出它对应的索引值为 5，直接可以在数组中找到它。借助哈希函数，我们提高了数组中数据的查找效率，这就是哈希表存储结构。</p>
<p>构建哈希表时，哈希函数的设计至关重要。假设将 {5, 20, 30, 50, 55} 存储到哈希表中，哈希函数是 y&#x3D;x%10，各个元素在数组中的存储位置如下图所示：</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/image-20230902155932936.png" alt="image-20230902155932936"></p>
<img src="/2023/09/02/c%E5%92%8Cc++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/image-20230902155932936.png" class title="This is an test image">

<p>可以看到，5 和 55 以及 20、30 和 50 对应的索引值是相同的，它们的存储位置发生了冲突，我们习惯称为哈希冲突或者哈希碰撞。设计一个好的哈希函数，可以降低哈希冲突的出现次数。哈希表提供了很多解决哈希冲突的方案，比如线性探测法、再哈希法、链地址法等。</p>
<p>本节我们使用线性探测法解决哈希冲突，解决方法是：当元素的索引值（存储位置）发生冲突时，从当前位置向后查找，直至找到一个空闲位置，作为冲突元素的存储位置。仍以图 3 中的哈希表为例，使用线性探测法解决哈希冲突的过程是：</p>
<ul>
<li>元素 5 最先存储到数组中下标为 5 的位置；</li>
<li>元素 20 最先存储到数组中下标为 0 的位置；</li>
<li>元素 30 的存储位置为 0，和 20 冲突，根据线性探测法，从下标为 0 的位置向后查找，下标为 1 的存储位置空闲，用来存储 30；</li>
<li>元素 50 的存储位置为 0，和 20 冲突，根据线性探测法，从下标为 0 的位置向后查找，下标为 2 的存储位置空闲，用来存储 50；</li>
<li>元素 55 的存储位置为 5，和 5 冲突，根据线性探测法，从下标为 5 的位置向后查找，下标为 6 的存储位置空闲，用来存储 55。</li>
</ul>
<p>借助线性探测法，最终 {5, 20, 30, 50, 55} 存储到哈希表中的状态为：</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/image-20230902160001791.png" alt="image-20230902160001791"></p>
<img src="/2023/09/02/c%E5%92%8Cc++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/image-20230902160001791.png" class title="This is an test image">

<h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><p>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p>
<p>在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。</p>
<p>通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1。</p>
<p>若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。树的根结点权值为其左、右子树根结点权值之和，相对于15，9，5是构造的，不参与权值计数</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/image-20230902162158683.png" alt="image-20230902162158683"></p>
<img src="/2023/09/02/c%E5%92%8Cc++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/image-20230902162158683.png" class title="This is an test image">

<p>树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL。</p>
<p>如上图：数的带权路径长度为：</p>
<p>WPL &#x3D; (2+3) * 3 + 4 * 2 + 6 * 1 &#x3D; 29</p>
<h1 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h1><p>若设二叉树的深度为h，除第 h 层外，其它各层 (1~h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。</p>
<p>完全二叉树是由<strong>满二叉树</strong>而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。满二叉树是一种特殊类型的二叉树，其中每个节点都具有两个子节点，除了叶子节点。换句话说，如果一个二叉树的所有非叶子节点都有两个子节点，那么它就是一个满二叉树。</p>
<p>一棵二叉树至多只有最下面的一层上的结点的度数可以小于2，并且最下层上的结点都集中在该层最左边的若干位置上，而在最后一层上，右边的若干结点缺失的二叉树，则此二叉树成为完全二叉树。</p>
<p>有n个节点的完全二叉树的深度为？</p>
<p>h(n) &#x3D; (log2n)+1计算以 2 为底的对数值，即 log2n</p>
<p>深度为 k 的满二叉树的节点个数：</p>
<p>总节点个数 &#x3D; 2^k - 1</p>
<p>一个完全二叉树的节点为n，则该二叉树的叶子节点为多少？</p>
<ul>
<li><strong>当n为奇数时 n0&#x3D; (n+1)&#x2F;2</strong></li>
<li><strong>当n为偶数</strong> <strong>n0&#x3D; n&#x2F;2</strong></li>
</ul>
<p>对任何一棵二叉树，叶子结点(度为0)的个数比度为2的结点数多一个,则no&#x3D;n2＋1</p>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>假设给定一个组无序数列{100,5,3,11,6,8,7}，带着问题，我们对其进行堆排序操作进行分步操作说明。</p>
<h2 id="创建最大堆"><a href="#创建最大堆" class="headerlink" title="创建最大堆"></a>创建最大堆</h2><p>首先我们将数组我们将数组从上至下按顺序排列，转换成二叉树：一个无序堆。每一个三角关系都是一个堆，上面是父节点，下面两个分叉是子节点，两个子节点俗称左孩子、右孩子；</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/image-20230902171921919.png" alt="image-20230902171921919"></p>
<img src="/2023/09/02/c%E5%92%8Cc++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/image-20230902171921919.png" class title="This is an test image">

<p>转换成无序堆之后，我们要努力让这个无序堆变成最大堆(或是最小堆)，即每个堆里都实现父节点的值都大于任何一个子节点的值</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/image-20230902171947417.png" alt="image-20230902171947417"></p>
<img src="/2023/09/02/c%E5%92%8Cc++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/image-20230902171947417.png" class title="This is an test image">

<p>从最后一个堆开始，即左下角那个没有右孩子的那个堆开始；首先对比左右孩子，由于这个堆没有右孩子，所以只能用左孩子，左孩子的值比父节点的值小所以不需要交换。如果发生交换，要检测子节点是否为其他堆的父节点，如果是，递归进行同样的操作。</p>
<p>第二次对比红色三角形内的堆，取较大的子节点，右孩子8胜出，和父节点比较，右孩子8大于父节点3，升级做父节点，与3交换位置，3的位置没有子节点，这个堆建成最大堆。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/image-20230902172011780.png" alt="image-20230902172011780"></p>
<img src="/2023/09/02/c%E5%92%8Cc++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/image-20230902172011780.png" class title="This is an test image">

<p>对黄色三角形内堆进行排序，过程和上面一样，最终是右孩子33升为父节点，被交换的右孩子下面也没有子节点，所以直接结束对比。</p>
<p>最顶部绿色的堆，堆顶100比左右孩子都大，所以不用交换，至此最大堆创建完成</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/image-20230902172042297.png" alt="image-20230902172042297"></p>
<img src="/2023/09/02/c%E5%92%8Cc++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/image-20230902172042297.png" class title="This is an test image">

<p>堆排序 （heapsort）— O(n log n)非稳定排序,空间复杂度O(1)</p>
<p>按照数组顺序，当前节点i，它的parent&#x3D;(i-1)&#x2F;2，左子节点2i+1，右子节点2i+2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">void heapify(vector&lt;int&gt; &amp;nums, int n, int i) // 对有一定顺序的堆，</span><br><span class="line">// 当前第i个结点取根左右的最大值（这个操作称heapfiy）</span><br><span class="line">&#123;</span><br><span class="line">	if(i&gt;=n)</span><br><span class="line">		return;</span><br><span class="line">	// 计算左右子节点的下标 left=2*i+1 right=2*i+2 parent=(i-1)/2</span><br><span class="line">    int l = i * 2 + 1, r = i * 2 + 2;</span><br><span class="line">    int max = i;</span><br><span class="line">    if (l &lt; n &amp;&amp; nums[l] &gt; nums[max])</span><br><span class="line">        max = l;</span><br><span class="line">    if (r &lt; n &amp;&amp; nums[r] &gt; nums[max])</span><br><span class="line">        max = r;</span><br><span class="line">    if (max != i)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(nums[max], nums[i]);</span><br><span class="line">        heapify(nums, n, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void heapify_build(vector&lt;int&gt; &amp;nums, int n) // 对无顺序的数组建立大根堆，从树的倒数第二层第一个结点开始，</span><br><span class="line">// 对每个结点进行heapify操作，然后向上走</span><br><span class="line">&#123;</span><br><span class="line">	// 初次构建堆，i要从最后一个非叶子节点开始，所以是(n-1-1)/2，0这个位置要加等号</span><br><span class="line">    int temp = (n - 2) / 2;</span><br><span class="line">    for (int i = temp; i &gt;= 0; i--)</span><br><span class="line">        heapify(nums, n, i);</span><br><span class="line">    for (int i = 0; i &lt; nums.size(); i++)</span><br><span class="line">        cout &lt;&lt; nums[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void heapify_sort(vector&lt;int&gt; &amp;nums, int n) // 建立大根堆之后，每次交换最后一个结点和根节点（最大值），堆排序</span><br><span class="line">// 对交换后的根节点继续进行heapify（此时堆的最后一位是最大值，因此不用管他，n变为n-1）</span><br><span class="line">&#123;</span><br><span class="line">    heapify_build(nums, n);</span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(nums.front(), nums[n - i - 1]);//把最大的交换到最后，然后下一步再找最大的左右子节点里面最大的</span><br><span class="line">        heapify(nums, n - i - 1, 0);//最后打印nums就是从小到大的顺序</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最<br>大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void bubbleSort(vector&lt;int&gt;&amp; a, int n) &#123;//使用引用（&amp;）可以避免进行值的拷贝</span><br><span class="line"> 	for (auto i = 0; i &lt; n; ++i) &#123;//auto根据右侧的赋值表达式自动推导出变量类型</span><br><span class="line"> 		for (int j = 0; j &lt; n - i - 1; ++j) &#123;</span><br><span class="line"> 			if (a[j] &gt; a[j + 1])</span><br><span class="line"> 			swap(a[j], a[j + 1]);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度 o(n^2) ，空间 o 1， 原地算法，稳定</strong></p>
<p>假如从开始的第一对到结尾的最后一对，相邻的元素之间都没有发生交换的操作，这意味着右边的元素 总是大于等于左边的元素，此时的数组已经是有序的了，我们无需再对剩余的元素重复比较下去了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void bubbleSort2(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int len = nums.size();</span><br><span class="line">    bool flag = false;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; len; ++i) &#123;</span><br><span class="line">        flag = false;</span><br><span class="line">        </span><br><span class="line">        for (int j = 0; j &lt; len - 1 - i; ++j) &#123;</span><br><span class="line">            if (nums[j] &gt; nums[j + 1]) &#123; </span><br><span class="line">                flag = true;</span><br><span class="line">                swap(nums[j], nums[j + 1]); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (!flag)////说明没有交换，则表明[0,len-i-1]已经是有序的了</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述两个冒泡排序（包括优化版本），均存在一定问题： 1、两种冒泡排序（包括优化版本）都是循环了n次，虽然不影响结果的正确性，但对于n个元素的冒泡 排序躺数， n - 1躺更符合规范理解一些； 2、对于冒泡排序优化版本中，if（!flag）break；这个语句，我觉得有一些疏漏。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void bubbleSort(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line"> 	int n = nums.size();</span><br><span class="line"> 	bool flag = false;</span><br><span class="line"> 	for (int i = 0; i &lt; n - 1; ++i) &#123;//i = 0 起，循环了n - 1趟，更符合规范理解</span><br><span class="line"> 	//for (int i = 0; i &lt; n; ++i) &#123;//i = 0 起，循环了n 趟，不影响结果</span><br><span class="line"> 		flag = false;</span><br><span class="line"> 		for (int j = 0; j &lt; n - 1 - i; ++j) &#123;</span><br><span class="line"> 			if (nums[j] &gt; nums[j + 1]) &#123;</span><br><span class="line"> 			//某一趟排序中，只要发生一次元素交换，flag就从false变为了true</span><br><span class="line"> 			//也即表示这一趟排序还不能确定所剩待排序列是否已经有序，应继续下一趟循环</span><br><span class="line"> 				swap(nums[j], nums[j + 1]);</span><br><span class="line"> 				flag = true;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	//但若某一趟中一次元素交换都没有，即依然为flag = false</span><br><span class="line"> 	//那么表明所剩待排序列已经有序</span><br><span class="line"> 	//不必再进行趟数比较，外层循环应该结束，即此时if (!flag) break; 跳出循环</span><br><span class="line"> 	/* if (flag) &#123; break; &#125; */</span><br><span class="line"> 	if (!flag) &#123; break; &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p><strong>时间复杂度：O(n^2)，空间O（1），非稳定排序，原地排序</strong></p>
<p>选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个 元素不用选择了，因为只剩下它一个最大的元 素了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void selectionSort(vector&lt;int&gt;&amp; a, int n) &#123;</span><br><span class="line"> 	int minIndex;</span><br><span class="line"> 	for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line"> 		minIndex = i;</span><br><span class="line"> 		for (int j = i + 1; j &lt; n; ++j) &#123;</span><br><span class="line"> 			if (a[j] &lt; a[minIndex]) minIndex = j;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		swap(a[i], a[minIndex]); </span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。 当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开 始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直 到找到它该插入的位置。 如果碰见一个和插入元素相 等的，那么插入元素把想插入的元素放在相等元素的后面。</p>
<p>所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是 <strong>稳定的</strong>。</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5<br><strong>时间复杂度 on^2 空间 o1，稳定排序，原地排序</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void insertionSort(vector&lt;int&gt;&amp; a, int n) &#123;//&#123; 9,1,5,6,2,3 &#125;</span><br><span class="line"> 	for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line"> 		if (a[i] &lt; a[i - 1]) &#123; //若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入</span><br><span class="line"> 			int j = i - 1;</span><br><span class="line"> 			int x = a[i]; //复制为哨兵，即存储待排序元素</span><br><span class="line"> 			//a[i] = a[i - 1]; //先后移一个元素，可以不要这一句，跟循环里面的功能重复了</span><br><span class="line"> 			while (j &gt;= 0 &amp;&amp; x &lt; a[j]) &#123; //查找在有序表的插入位置,还必须要保证j是&gt;=0的因为a[j]要合法</span><br><span class="line"> 				a[j + 1] = a[j];</span><br><span class="line"> 				j--; //元素后移</span><br><span class="line"> 			&#125;</span><br><span class="line"> 			a[j + 1] = x; //插入到正确位置</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		</span><br><span class="line"> 		print(a, n, i); //打印每趟排序的结果</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码实现了插入排序算法，可以对给定数组进行排序。如果你传入的数组已经包含了所有需要排序的元素，那么你可以直接调用这段代码进行排序，不需要再进行插入操作。</p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序 （quicksort）— O(n log n)，非稳定排序</p>
<p>算法思想<br>1、选取第一个数为基准<br>2、将比基准小的数交换到前面，比基准大的数交换到后面<br>3、对左右区间重复第二步，直到各区间只有一个数</p>
<p>我们从数组中选择一个元素，我们把这个元素称之为中轴元素吧，然后把数组中所有小于中轴元素的元素放在其左边，所有大于或等于中轴元素的元素放在其右边，显然，此时中轴元素所处的位置的是有序 的。也就是说，我们无需再移动中轴元素的位置。 </p>
<p>从中轴元素那里开始把大的数组切割成两个小的数组(两个数组都不包含中轴元素)，接着我们通过递归 的方式，让中轴元素左边的数组和右边的数组也重复同样的操作，直到数组的大小为1，此时每个元素 都处于有序的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// quick函数实现</span><br><span class="line">void quick_sort(int *arr, int start, int end)</span><br><span class="line">&#123;</span><br><span class="line">    int i = start;</span><br><span class="line">    int j = end;</span><br><span class="line">    int temp = arr[start]; // 默认将数组第一个元素作为基准值</span><br><span class="line">    if (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        while (i &lt; j)//每次只是将比基准大或小的放在两边，动或者不动，没有顺序</span><br><span class="line">        &#123;</span><br><span class="line">            // 从end向start筛选比temp更小的数</span><br><span class="line">            while (i &lt; j &amp;&amp; arr[j] &gt;= temp)</span><br><span class="line">            &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &lt; j)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[i] = arr[j]; // 把这个数放到基准值的左边</span><br><span class="line">            &#125;</span><br><span class="line">            // 从start向end筛选比temp更大的数</span><br><span class="line">            while (i &lt; j &amp;&amp; arr[i] &lt; temp)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &lt; j)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[j] = arr[i]; // 把这个数放到基准值的右边</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = temp; // 将基准值放到正确位置</span><br><span class="line"></span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">        quick_sort(arr, start, i - 1);</span><br><span class="line">        quick_sort(arr, i + 1, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>希尔排序的思想是采用插入排序的方法，先让数组中任意间隔为 h 的元素有序，刚开始 h 的大小可以是 h &#x3D; n &#x2F; 2,接着让 h &#x3D; n &#x2F; 4，让 h 一直缩小，当 h &#x3D; 1 时，也就是此时数组中任意间隔为1的元素有序，此时的数组就是有序的了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void shellSortCore(vector&lt;int&gt; &amp;nums, int gap, int i)</span><br><span class="line">&#123;</span><br><span class="line">    int inserted = nums[i];</span><br><span class="line">    int j;</span><br><span class="line">    // 插入的时候按组进行插入</span><br><span class="line">    for (j = i - gap; j &gt;= 0 &amp;&amp; inserted &lt; nums[j]; j -= gap)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[j + gap] = nums[j];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[j + gap] = inserted;</span><br><span class="line">&#125;</span><br><span class="line">void shellSort(vector&lt;int&gt; &amp;nums)</span><br><span class="line">&#123;</span><br><span class="line">    int len = nums.size();</span><br><span class="line">    // 进行分组，最开始的时候，gap为数组长度一半</span><br><span class="line">    for (int gap = len / 2; gap &gt; 0; gap /= 2)</span><br><span class="line">    &#123;</span><br><span class="line">        // 对各个分组进行插入分组</span><br><span class="line">        for (int i = gap; i &lt; len; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            // 将nums[i]插入到所在分组正确的位置上</span><br><span class="line">            shellSortCore(nums, gap, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (auto a : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序 （merge sort）— O(n log n)稳定排序，空间复杂度O(n)</p>
<p>将一个大的无序数组有序，我们可以把大的数组分成两个，然后对这两个数组分别进行排序，之后在把 这两个数组合并成一个有序的数组。由于两个小的数组都是有序的，所以在合并的时候是很快的。 </p>
<p>通过递归的方式将大的数组一直分割，直到数组的大小为 1，此时只有一个元素，那么该数组就是有序 的了，之后再把两个数组大小为1的合并成一个大小为2的，再把两个大小为2的合并成4的 … 直到全部 小的数组合并起来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">void mergeSortCore(vector&lt;int&gt; &amp;nums, vector&lt;int&gt; &amp;copy, int begin, int end)</span><br><span class="line">&#123;</span><br><span class="line">    if (begin &gt;= end)</span><br><span class="line">        return;</span><br><span class="line">    int mid = begin + (end - begin) / 2;</span><br><span class="line">    int low1 = begin, high1 = mid, low2 = mid + 1, high2 = end;</span><br><span class="line">    mergeSortCore(copy, nums, low1, high1); // 这里减少了copy向nums的赋值部分，千万注意不要把copy 和 nums赋值反了</span><br><span class="line">    mergeSortCore(copy, nums, low2, high2);//因为在往外递归的时候，是利用的nmus排序给临时数组的，每次都要赋值，通过这种就不需要赋值</span><br><span class="line">    int copyIndex = low1;</span><br><span class="line">    while (low1 &lt;= high1 &amp;&amp; low2 &lt;= high2)//将两个子数组中的元素按顺序进行了比较和合并，并放入了 copy 数组</span><br><span class="line">    &#123;//第一个子数组中还有剩余的元素，而第二个子数组已经全部比较完毕。</span><br><span class="line">	//第二个子数组中还有剩余的元素，而第一个子数组已经全部比较完毕。</span><br><span class="line">	//接下来的两个 while 循环用于处理这种情况，将剩余的元素放入 copy 数组</span><br><span class="line">        copy[copyIndex++] = nums[low1] &lt; nums[low2] ? nums[low1++] : nums[low2++];</span><br><span class="line">    &#125;</span><br><span class="line">    while (low1 &lt;= high1)</span><br><span class="line">    &#123;</span><br><span class="line">        copy[copyIndex++] = nums[low1++];</span><br><span class="line">    &#125;</span><br><span class="line">    while (low2 &lt;= high2)</span><br><span class="line">    &#123;</span><br><span class="line">        copy[copyIndex++] = nums[low2++];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; begin &lt;&lt; &quot; &quot; &lt;&lt; end &lt;&lt; endl;</span><br><span class="line">    for (auto a : copy)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void mergeSort(vector&lt;int&gt; nums)</span><br><span class="line">&#123;</span><br><span class="line">    for (auto a : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; copyNums(nums); // 这里要借助一个一模一样的数组的</span><br><span class="line">    mergeSortCore(nums, copyNums, 0, nums.size() - 1);</span><br><span class="line">    nums.assign(copyNums.begin(), copyNums.end()); // 到最后copy数组是排序好的，记得要赋值一下</span><br><span class="line">	</span><br><span class="line">    for (auto a : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>稳定的线性时间排序算法</p>
<p>计数排序统计小于等于该元素值的元素的个数i，于是该元素就放在目标数组的索引i位（i≥0）。</p>
<ul>
<li>计数排序基于一个假设，待排序数列的所有数均为整数，且出现在（0，k）的区间之内。</li>
<li>如果 k（待排数组的最大值） 过大则会引起较大的空间复杂度，一般是用来排序 0 到 100 之间的数字的最好的算法，但是它不适合按字母顺序排序人名。</li>
<li>计数排序不是比较排序，排序的速度快于任何比较排序算法。</li>
</ul>
<p>算法思想：</p>
<ol>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项；</li>
<li>对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）；</li>
<li>向填充目标数组：将每个元素 i 放在新数组的第 C[i] 项，每放一个元素就将 C[i] 减去 1；</li>
</ol>
<p>平均时间复杂度：O(n + k)<br>最佳时间复杂度：O(n + k)<br>最差时间复杂度：O(n + k)<br>空间复杂度：O(n + k)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 计数排序</span><br><span class="line">void CountSort(vector&lt;int&gt; &amp;vecRaw, vector&lt;int&gt; &amp;vecObj)</span><br><span class="line">&#123;</span><br><span class="line">    // 确保待排序容器非空</span><br><span class="line">    if (vecRaw.size() == 0)</span><br><span class="line">        return;</span><br><span class="line">    // 使用 vecRaw 的最大值 + 1 作为计数容器 countVec 的大小</span><br><span class="line">    int vecCountLength = (*max_element(begin(vecRaw), end(vecRaw))) + 1;</span><br><span class="line">    vector&lt;int&gt; vecCount(vecCountLength, 0);</span><br><span class="line">    // 统计每个键值出现的次数</span><br><span class="line">    for (int i = 0; i &lt; vecRaw.size(); i++)</span><br><span class="line">        vecCount[vecRaw[i]]++;</span><br><span class="line"></span><br><span class="line">    // 后面的键值出现的位置为前面所有键值出现的次数之和</span><br><span class="line">    for (int i = 1; i &lt; vecCountLength; i++)</span><br><span class="line">        vecCount[i] += vecCount[i - 1];</span><br><span class="line">    // 将键值放到目标位置</span><br><span class="line">    for (int i = vecRaw.size(); i &gt; 0; i--) // 此处逆序是为了保持相同键值的稳定性</span><br><span class="line">        vecObj[--vecCount[vecRaw[i - 1]]] = vecRaw[i - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有逆序累加操作（即 <code>vecCount[i] += vecCount[i - 1]</code>），则按照键值从小到大的顺序进行累加，最终得到的是每个键值在排序后的结果数组中的起始位置索引。这将会导致在相同键值的情况下，它们的相对顺序被打乱，即不再保持稳定性。</p>
<h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><p>桶排序的核心:使数组的下标具有意义</p>
<p>将值为i的元素放入i号桶，最后依次把桶里的元素倒出来。<br>算法思想：</p>
<ol>
<li>设置一个定量的数组当作空桶子。</li>
<li>寻访序列，并且把项目一个一个放到对应的桶子去。</li>
<li>对每个不是空的桶子进行排序。</li>
<li>从不是空的桶子里把项目再放回原来的序列中。</li>
</ol>
<p>平均时间复杂度：O(n + k)<br>最佳时间复杂度：O(n + k)<br>最差时间复杂度：O(n ^ 2)<br>空间复杂度：O(n * k)<br>稳定性：稳定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">int a[11]; // 下标代表考试的等级int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n, tmp;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; tmp;</span><br><span class="line">        a[tmp]++;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= 10; i++) // i代表等级i</span><br><span class="line">        if (a[i])</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>一种多关键字的排序算法，可用桶排序实现。<br>算法思想：</p>
<ol>
<li>取得数组中的最大数，并取得位数；</li>
<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）</li>
</ol>
<p>时间复杂度：O(k*N)<br>空间复杂度：O(k + N)<br>稳定性：稳定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">int maxbit(int data[], int n) // 辅助函数，求数据的最大位数</span><br><span class="line">&#123;</span><br><span class="line">    int maxData = data[0]; ///&lt; 最大数</span><br><span class="line">    /// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。</span><br><span class="line">    for (int i = 1; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if (maxData &lt; data[i])</span><br><span class="line">            maxData = data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int d = 1;</span><br><span class="line">    int p = 10;</span><br><span class="line">    while (maxData &gt;= p)</span><br><span class="line">    &#123;</span><br><span class="line">        // p *= 10; // Maybe overflow</span><br><span class="line">        maxData /= 10;</span><br><span class="line">        ++d;</span><br><span class="line">    &#125;</span><br><span class="line">    return d;</span><br><span class="line">    /* int d = 1; //保存最大的位数</span><br><span class="line">     int p = 10;</span><br><span class="line">     for(int i = 0; i &lt; n; ++i)</span><br><span class="line">     &#123;</span><br><span class="line">    	 while(data[i] &gt;= p)</span><br><span class="line">     	&#123;</span><br><span class="line">    		 p *= 10;</span><br><span class="line">     		 ++d;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return d;*/</span><br><span class="line">&#125;</span><br><span class="line">void radixsort(int data[], int n) // 基数排序</span><br><span class="line">&#123;</span><br><span class="line">    int d = maxbit(data, n);</span><br><span class="line">    int *tmp = new int[n];</span><br><span class="line">    int *count = new int[10]; // 计数器</span><br><span class="line">    int i, j, k;</span><br><span class="line">    int radix = 1;</span><br><span class="line">    for (i = 1; i &lt;= d; i++) // 进行d次排序</span><br><span class="line">    &#123;</span><br><span class="line">        for (j = 0; j &lt; 10; j++)</span><br><span class="line">            count[j] = 0; // 每次分配前清空计数器</span><br><span class="line">        for (j = 0; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            k = (data[j] / radix) % 10; // 统计每个桶中的记录数</span><br><span class="line">            count[k]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for (j = 1; j &lt; 10; j++)</span><br><span class="line">            count[j] = count[j - 1] + count[j]; // 将tmp中的位置依次分配给每个桶</span><br><span class="line">        for (j = n - 1; j &gt;= 0; j--)            // 将所有桶中记录依次收集到tmp中</span><br><span class="line">        &#123;</span><br><span class="line">            k = (data[j] / radix) % 10;//k是元素最大位所代表的count位置</span><br><span class="line">            tmp[count[k] - 1] = data[j];//count[k] - 1代表第多少个位置的元素，有序的</span><br><span class="line">            count[k]--;//最大位一样个数的元素减一</span><br><span class="line">        &#125;</span><br><span class="line">        for (j = 0; j &lt; n; j++) // 将临时数组的内容复制到data中</span><br><span class="line">            data[j] = tmp[j];</span><br><span class="line">        radix = radix * 10;//可以看出i++代表的是位数，即最大数是两位那么d是2</span><br><span class="line">    &#125;</span><br><span class="line">    delete[] tmp;</span><br><span class="line">    delete[] count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/Redis%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/Redis%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">Redis基本操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-29 20:40:43" itemprop="dateCreated datePublished" datetime="2023-08-29T20:40:43+08:00">2023-08-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-02 15:37:30" itemprop="dateModified" datetime="2023-09-02T15:37:30+08:00">2023-09-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>启动redis:redis-cli</strong></p>
<h1 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h1><p>redis默认有16个数据库，编号为0~15，且默认访问0号数据库</p>
<table>
<thead>
<tr>
<th>select 数据库编号</th>
<th>选择指定数据库</th>
</tr>
</thead>
<tbody><tr>
<td>dbsize</td>
<td>获取当前数据库键值对数量</td>
</tr>
<tr>
<td>flushdb</td>
<td>清空当前数据库</td>
</tr>
<tr>
<td>flushall</td>
<td>清空所有数据库</td>
</tr>
<tr>
<td>save</td>
<td>将数据保存至磁盘</td>
</tr>
<tr>
<td>bgsave</td>
<td>将数据异步保存至磁盘(后台:Background)</td>
</tr>
<tr>
<td>lastsave</td>
<td>获取最后一次成功保存的unix时间</td>
</tr>
</tbody></table>
<h2 id="通用数据操作"><a href="#通用数据操作" class="headerlink" title="通用数据操作"></a>通用数据操作</h2><p>操作范围为当前数据库</p>
<table>
<thead>
<tr>
<th>keys 格式</th>
<th>查看符合指定格式的key，*为通配符</th>
</tr>
</thead>
<tbody><tr>
<td>exists key1 [key2 …]</td>
<td>查看是否存在一至多个指定的key</td>
</tr>
<tr>
<td>type key</td>
<td>按key查看value的数据类型</td>
</tr>
<tr>
<td>del key1 [key2 …]</td>
<td>按key删除一至多个键值对</td>
</tr>
<tr>
<td>rename key1 key1</td>
<td>重命名key1，如果key2已经存在，其值会被覆盖</td>
</tr>
<tr>
<td>renamenx key1 key2</td>
<td>key2不存在时重命名key1</td>
</tr>
<tr>
<td>move key 数据库编号</td>
<td>按key将一个键值对移动到指定数据库</td>
</tr>
<tr>
<td>copy key1 key2</td>
<td>将key1的值拷贝给key2</td>
</tr>
</tbody></table>
<p>Redis 持久化拥有以下三种方式：</p>
<ul>
<li><strong>快照方式</strong>（RDB, Redis DataBase）将某一个时刻的内存数据，以二进制的方式写入磁盘；</li>
<li><strong>文件追加方式</strong>（AOF, Append Only File），记录所有的操作命令，并以文本的形式追加到文件中；</li>
<li><strong>混合持久化方式</strong>，Redis 4.0 之后新增的方式，混合持久化是结合了 RDB 和 AOF 的优点，在写入的时候，先把当前的数据以 RDB 的形式写入文件的开头，再将后续的操作命令以 AOF 的格式存入文件，这样既能保证 Redis 重启时的速度，又能简单数据丢失的风险</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/28/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/28/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-7/" class="post-title-link" itemprop="url">muduo库使用示例_7</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-28 11:22:54" itemprop="dateCreated datePublished" datetime="2023-08-28T11:22:54+08:00">2023-08-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-29 16:13:57" itemprop="dateModified" datetime="2023-08-29T16:13:57+08:00">2023-08-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="高效率多线程异步日志"><a href="#高效率多线程异步日志" class="headerlink" title="高效率多线程异步日志"></a>高效率多线程异步日志</h1><p>线程安全，即多个线程可以并发写日志，两个线程的日志消息不会出现交织。</p>
<ul>
<li>​	用一个全局的mutex保护lO		前者造成全部线程抢占一个锁，就变成串行了</li>
<li>​	每个线程单独写一个日志文件	后者有可能让业务线程阻塞在写磁盘操作上。</li>
<li>​	muduo库的方法是用<strong>一个</strong>背景线程负责收集日志消息，并写入日志文件，其他业务线程只管往这个“日志线程”发送日志消息，这称为“异步日志”。不一定是实时的，但是不影响并发的写日志。非阻塞日志<ul>
<li>使得前端的业务线程与后端的日志线程能够并发，并且，写日志不太频繁，提高了效率。</li>
</ul>
</li>
</ul>
<p><img src="/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-7/image-20230828114049679.png" alt="image-20230828114049679"></p>
<img src="/2023/08/28/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-7/image-20230828114049679.png" class title="This is an test image">

<h2 id="AsyncLogging-h"><a href="#AsyncLogging-h" class="headerlink" title="AsyncLogging.h"></a>AsyncLogging.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_BASE_ASYNCLOGGING_H</span><br><span class="line">#define MUDUO_BASE_ASYNCLOGGING_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/BlockingQueue.h&quot;</span><br><span class="line">#include &quot;muduo/base/BoundedBlockingQueue.h&quot;</span><br><span class="line">#include &quot;muduo/base/CountDownLatch.h&quot;</span><br><span class="line">#include &quot;muduo/base/Mutex.h&quot;</span><br><span class="line">#include &quot;muduo/base/Thread.h&quot;</span><br><span class="line">#include &quot;muduo/base/LogStream.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;atomic&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">//异步日志</span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">class AsyncLogging : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line"></span><br><span class="line">  AsyncLogging(const string&amp; basename,</span><br><span class="line">               off_t rollSize,</span><br><span class="line">               int flushInterval = 3);</span><br><span class="line"></span><br><span class="line">  ~AsyncLogging()</span><br><span class="line">  &#123;</span><br><span class="line">    if (running_)</span><br><span class="line">    &#123;</span><br><span class="line">      stop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //供前端生产者线程调用（日志数据写到缓冲区)</span><br><span class="line">  void append(const char* logline, int len);</span><br><span class="line"></span><br><span class="line">  void start()</span><br><span class="line">  &#123;</span><br><span class="line">    running_ = true;</span><br><span class="line">    thread_.start();//日志线程启动，调用threadFunc</span><br><span class="line">    latch_.wait();//等待线程启动</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void stop() NO_THREAD_SAFETY_ANALYSIS</span><br><span class="line">  &#123;</span><br><span class="line">    running_ = false;</span><br><span class="line">    cond_.notify();</span><br><span class="line">    thread_.join();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  //供后端消费者线程调用（将数据写到日志文件)</span><br><span class="line">  void threadFunc();</span><br><span class="line">  //实例化 FixedBuffer 类模板，并指定模板参数的具体值</span><br><span class="line">  typedef muduo::detail::FixedBuffer&lt;muduo::detail::kLargeBuffer&gt; Buffer;</span><br><span class="line">  typedef std::vector&lt;std::unique_ptr&lt;Buffer&gt;&gt; BufferVector;</span><br><span class="line">  typedef BufferVector::value_type BufferPtr;//可理解为Buffer的智能指针，能管理BufFer的生存期</span><br><span class="line">                                             //BufferVector::value_type 表示 BufferVector 中的元素类型，也就是 std::unique_ptr&lt;Buffer&gt;类型,真备移动语义</span><br><span class="line">                                            //(两个unique_ptr不能指向一个对象，不能进行复制操作只能进行移动操作</span><br><span class="line"> </span><br><span class="line">  const int flushInterval_;//超时时间，在flushInterval_秒内，缓冲区没写满，仍将缓冲区中的数据写到文件中</span><br><span class="line">  std::atomic&lt;bool&gt; running_;</span><br><span class="line">  const string basename_;</span><br><span class="line">  const off_t rollSize_;//日志文件的滚动大小</span><br><span class="line">  muduo::Thread thread_;</span><br><span class="line">  muduo::CountDownLatch latch_;//用于等待线程启动</span><br><span class="line">  muduo::MutexLock mutex_;</span><br><span class="line">  muduo::Condition cond_ GUARDED_BY(mutex_);//条件变量与互斥量配合使用</span><br><span class="line">  BufferPtr currentBuffer_ GUARDED_BY(mutex_);//当前缓冲区，智能指针</span><br><span class="line">  BufferPtr nextBuffer_ GUARDED_BY(mutex_);//预备缓冲区</span><br><span class="line">  BufferVector buffers_ GUARDED_BY(mutex_);//待写入文件的已填满的缓冲区</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_BASE_ASYNCLOGGING_H</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="AsyncLogging-cc"><a href="#AsyncLogging-cc" class="headerlink" title="AsyncLogging.cc"></a>AsyncLogging.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/AsyncLogging.h&quot;</span><br><span class="line">#include &quot;muduo/base/LogFile.h&quot;</span><br><span class="line">#include &quot;muduo/base/Timestamp.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line"></span><br><span class="line">AsyncLogging::AsyncLogging(const string&amp; basename,</span><br><span class="line">                           off_t rollSize,</span><br><span class="line">                           int flushInterval)</span><br><span class="line">  : flushInterval_(flushInterval),</span><br><span class="line">    running_(false),</span><br><span class="line">    basename_(basename),</span><br><span class="line">    rollSize_(rollSize),</span><br><span class="line">    thread_(std::bind(&amp;AsyncLogging::threadFunc, this), &quot;Logging&quot;),</span><br><span class="line">    latch_(1),</span><br><span class="line">    mutex_(),</span><br><span class="line">    cond_(mutex_),</span><br><span class="line">    currentBuffer_(new Buffer),</span><br><span class="line">    nextBuffer_(new Buffer),</span><br><span class="line">    buffers_()</span><br><span class="line">&#123;</span><br><span class="line">  currentBuffer_-&gt;bzero();//清空缓冲区内容</span><br><span class="line">  nextBuffer_-&gt;bzero();</span><br><span class="line">  buffers_.reserve(16);//预留</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AsyncLogging::append(const char* logline, int len)</span><br><span class="line">&#123;</span><br><span class="line">  muduo::MutexLockGuard lock(mutex_);</span><br><span class="line">  if (currentBuffer_-&gt;avail() &gt; len)//当前可用空间</span><br><span class="line">  &#123;</span><br><span class="line">    //当前缓冲区未满，将数据追加到末尾</span><br><span class="line">    currentBuffer_-&gt;append(logline, len);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    //当前缓冲区已满，将当前缓冲区添加到待写入文件的已填满的缓冲区列表</span><br><span class="line">    buffers_.push_back(std::move(currentBuffer_));//currentBuffer_就没指向区域</span><br><span class="line">    //将当前缓冲区设置为预备缓冲区</span><br><span class="line">    if (nextBuffer_)</span><br><span class="line">    &#123;</span><br><span class="line">      currentBuffer_ = std::move(nextBuffer_);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      //这种情况，极少发生，前端写入速度太快，一下子把两块缓冲区都写完</span><br><span class="line">      //那么，只好分配一玦新的缓冲</span><br><span class="line">      currentBuffer_.reset(new Buffer); // Rarely happens</span><br><span class="line">    &#125;</span><br><span class="line">    currentBuffer_-&gt;append(logline, len);</span><br><span class="line">    cond_.notify();//通知后端开始写入日志</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AsyncLogging::threadFunc()</span><br><span class="line">&#123;</span><br><span class="line">  assert(running_ == true);</span><br><span class="line">  latch_.countDown();</span><br><span class="line">  LogFile output(basename_, rollSize_, false);</span><br><span class="line">  BufferPtr newBuffer1(new Buffer);</span><br><span class="line">  BufferPtr newBuffer2(new Buffer);</span><br><span class="line">  newBuffer1-&gt;bzero();</span><br><span class="line">  newBuffer2-&gt;bzero();</span><br><span class="line">  BufferVector buffersToWrite;</span><br><span class="line">  buffersToWrite.reserve(16);</span><br><span class="line">  while (running_)</span><br><span class="line">  &#123;</span><br><span class="line">    assert(newBuffer1 &amp;&amp; newBuffer1-&gt;length() == 0);</span><br><span class="line">    assert(newBuffer2 &amp;&amp; newBuffer2-&gt;length() == 0);</span><br><span class="line">    assert(buffersToWrite.empty());</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      muduo::MutexLockGuard lock(mutex_);</span><br><span class="line">      if (buffers_.empty())  // unusual usage!(注意，这里是一个非常规用法,一般是while)</span><br><span class="line">      &#123;</span><br><span class="line">        //不能解决虚假唤醒spurious wakeup</span><br><span class="line">        //Linux网络编程、spurious wakeup可能是遇到了信号(signal)</span><br><span class="line">        //在多处理器中，pthread_cond_signal可能唤醒多个等待条件变量的线程。</span><br><span class="line">        cond_.waitForSeconds(flushInterval_);//等待前端写满了一个或者多个buffer ,或者一个超时时间到来</span><br><span class="line">      &#125;</span><br><span class="line">      buffers_.push_back(std::move(currentBuffer_));//将当前缓冲区移入buffers</span><br><span class="line">      currentBuffer_ = std::move(newBuffer1);//将空闲的newBuffer1置为当前缓冲区</span><br><span class="line">      buffersToWrite.swap(buffers_);//buffers_与buffersTowrite交换，这样后面的代码可以在临界区之外安全地访问buffersToWrite</span><br><span class="line">      if (!nextBuffer_)</span><br><span class="line">      &#123;</span><br><span class="line">        nextBuffer_ = std::move(newBuffer2);//确保前端始终有一个预备buffer可供调配，</span><br><span class="line">        //减少前端临界区分配内存的概率,缩短前端临界区长度。</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //buffersToWrite.swap这样可以保证前端和后端可以并发 </span><br><span class="line">    assert(!buffersToWrite.empty());</span><br><span class="line">    //消息堆积</span><br><span class="line">    //前端陷入死循环，拼命发送日志消息，超过后端的处理能力,这就是典型的生产速度</span><br><span class="line">    //超过消费速度问题,会造成数据在内存中堆积，严重时引发性能问题或程序崩溃(分配内存失败)</span><br><span class="line">    if (buffersToWrite.size() &gt; 25)</span><br><span class="line">    &#123;</span><br><span class="line">      char buf[256];</span><br><span class="line">      snprintf(buf, sizeof buf, &quot;Dropped log messages at %s, %zd larger buffers\n&quot;,</span><br><span class="line">               Timestamp::now().toFormattedString().c_str(),</span><br><span class="line">               buffersToWrite.size()-2);</span><br><span class="line">      fputs(buf, stderr);</span><br><span class="line">      output.append(buf, static_cast&lt;int&gt;(strlen(buf)));</span><br><span class="line">      buffersToWrite.erase(buffersToWrite.begin()+2, buffersToWrite.end());//丢掉多余日志,以腾出内存,仅保留两块缓冲区</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (const auto&amp; buffer : buffersToWrite)</span><br><span class="line">    &#123;</span><br><span class="line">      // FIXME: use unbuffered stdio FILE ? or use ::writev ?</span><br><span class="line">      output.append(buffer-&gt;data(), buffer-&gt;length());//写入日志，是一个logfile</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (buffersToWrite.size() &gt; 2)</span><br><span class="line">    &#123;</span><br><span class="line">      // drop non-bzero-ed buffers, avoid trashing</span><br><span class="line">      buffersToWrite.resize(2);//buffersToWrite 向量会丢弃多余的元素，从而保持最多只有两个元素</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!newBuffer1)</span><br><span class="line">    &#123;</span><br><span class="line">      assert(!buffersToWrite.empty());</span><br><span class="line">      newBuffer1 = std::move(buffersToWrite.back());//将 buffersToWrite 向量中最后一个元素的所有权转移到 newBuffer1</span><br><span class="line">      buffersToWrite.pop_back();//删除 buffersToWrite 向量中的最后一个元素，即移除已经被移动的缓冲区指针</span><br><span class="line">      newBuffer1-&gt;reset();//重置，只需要移动指针，覆盖就行了</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!newBuffer2)</span><br><span class="line">    &#123;</span><br><span class="line">      assert(!buffersToWrite.empty());</span><br><span class="line">      newBuffer2 = std::move(buffersToWrite.back());</span><br><span class="line">      buffersToWrite.pop_back();</span><br><span class="line">      newBuffer2-&gt;reset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buffersToWrite.clear();</span><br><span class="line">    output.flush();</span><br><span class="line">  &#125;</span><br><span class="line">  output.flush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>void <strong>AsyncLogging</strong>::<strong>threadFunc</strong>()中</p>
<p>在给出的代码中，<code>currentBuffer_</code> 和 <code>nextBuffer_</code> 是智能指针对象，它们的类型是 <code>std::unique_ptr&lt;Buffer&gt;</code>。这些智能指针用于管理 <code>Buffer</code> 对象的生命周期。现在我们来解释 <code>currentBuffer_-&gt;append(logline, len)</code> 和 <code>currentBuffer_.reset(new Buffer)</code> 中箭头运算符 <code>-&gt;</code> 和点运算符 <code>.</code> 的用法。</p>
<ol>
<li>箭头运算符 <code>-&gt;</code> 当智能指针类型是指向类或结构体的指针时，我们使用箭头运算符 <code>-&gt;</code> 来访问其指向对象的成员。正如前面提到的，<code>currentBuffer_</code> 和 <code>nextBuffer_</code> 是智能指针对象，类型为 <code>std::unique_ptr&lt;Buffer&gt;</code>，它们指向 <code>Buffer</code> 类的对象。 因此，在 <code>currentBuffer_-&gt;append(logline, len)</code> 中，<code>currentBuffer_</code> 是一个指向 <code>Buffer</code> 对象的智能指针，通过箭头运算符 <code>-&gt;</code> 可以调用 <code>Buffer</code> 类的 <code>append</code> 成员函数。</li>
<li>点运算符 <code>.</code> 当智能指针类型是实际对象（而不是指向对象的指针）时，我们使用点运算符 <code>.</code> 来访问成员。例如，<code>currentBuffer_.reset(new Buffer)</code> 中的 <code>currentBuffer_</code> 是一个 <code>std::unique_ptr&lt;Buffer&gt;</code> 的对象，我们通过使用点运算符来操作这个智能指针对象，调用 智能指针的<code>reset</code> 成员函数，并将其指向一个新的 <code>Buffer</code> 对象。</li>
</ol>
<p>总结一下，箭头运算符 <code>-&gt;</code> 用于访问智能指针所指向对象的成员函数和成员变量，而点运算符 <code>.</code> 则用于操作智能指针对象本身的成员函数。这样可以方便地在代码中使用智能指针来管理对象的生命周期，并访问其成员。</p>
<h2 id="AsyncLogging-test-cc"><a href="#AsyncLogging-test-cc" class="headerlink" title="AsyncLogging_test.cc"></a>AsyncLogging_test.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/AsyncLogging.h&quot;</span><br><span class="line">#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line">#include &quot;muduo/base/Timestamp.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/resource.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">off_t kRollSize = 500*1000*1000;</span><br><span class="line"></span><br><span class="line">muduo::AsyncLogging* g_asyncLog = NULL;</span><br><span class="line"></span><br><span class="line">void asyncOutput(const char* msg, int len)</span><br><span class="line">&#123;</span><br><span class="line">  g_asyncLog-&gt;append(msg, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bench(bool longLog)</span><br><span class="line">&#123;                                       //void Logger::setOutput(OutputFunc out)</span><br><span class="line">  muduo::Logger::setOutput(asyncOutput);//typedef void (*OutputFunc)(const char* msg, int len);</span><br><span class="line">  //通过这个函数写入日志</span><br><span class="line">  int cnt = 0;</span><br><span class="line">  const int kBatch = 1000;</span><br><span class="line">  muduo::string empty = &quot; &quot;;</span><br><span class="line">  muduo::string longStr(3000, &#x27;X&#x27;);</span><br><span class="line">  longStr += &quot; &quot;;</span><br><span class="line"></span><br><span class="line">  for (int t = 0; t &lt; 30; ++t)</span><br><span class="line">  &#123;</span><br><span class="line">    muduo::Timestamp start = muduo::Timestamp::now();</span><br><span class="line">    for (int i = 0; i &lt; kBatch; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      //因为setOutput(asyncOutput)，所以添加到日志文件当中</span><br><span class="line">      LOG_INFO &lt;&lt; &quot;Hello 0123456789&quot; &lt;&lt; &quot; abcdefghijklmnopqrstuvwxyz &quot;</span><br><span class="line">               &lt;&lt; (longLog ? longStr : empty)</span><br><span class="line">               &lt;&lt; cnt;</span><br><span class="line">      ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    muduo::Timestamp end = muduo::Timestamp::now();</span><br><span class="line">    printf(&quot;%f\n&quot;, timeDifference(end, start)*1000000/kBatch);</span><br><span class="line">    //下面两行注释掉，会加剧消息堆积，日志文件变小</span><br><span class="line">    struct timespec ts = &#123; 0, 500*1000*1000 &#125;;</span><br><span class="line">    nanosleep(&amp;ts, NULL);</span><br><span class="line">    //通过 nanosleep 函数进行延时，暂停程序执行一段时间，具体时间由 ts 中的值决定。这里的延时时间为 500 毫秒（即 50010001000 纳秒）</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;//设置分配最大虚拟内存大小为 2GB</span><br><span class="line">  &#123;//这个设置的目的是为了限制程序所能使用的虚拟内存大小，避免程序占用过多的虚拟内存导致系统资源耗尽或程序异常运行</span><br><span class="line">    // set max virtual memory to 2GB.</span><br><span class="line">    size_t kOneGB = 1000*1024*1024;</span><br><span class="line">    rlimit rl = &#123; 2*kOneGB, 2*kOneGB &#125;;</span><br><span class="line">    setrlimit(RLIMIT_AS, &amp;rl);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printf(&quot;pid = %d\n&quot;, getpid());</span><br><span class="line"></span><br><span class="line">  char name[256] = &#123; &#x27;\0&#x27; &#125;;</span><br><span class="line">  strncpy(name, argv[0], sizeof name - 1);</span><br><span class="line">  muduo::AsyncLogging log(::basename(name), kRollSize);//滚动大小为500M</span><br><span class="line">  log.start();</span><br><span class="line">  g_asyncLog = &amp;log;</span><br><span class="line"></span><br><span class="line">  bool longLog = argc &gt; 1;//根据命令行参数设置是否使用长日志</span><br><span class="line">  bench(longLog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="MySQL-配置"><a href="#MySQL-配置" class="headerlink" title="MySQL 配置"></a>MySQL 配置</h1><ol>
<li><p>在 MySQL 控制台中，您可以执行各种 MySQL 相关的操作和命令。例如，您可以创建数据库、创建用户、授权等。下面是一些常用的命令示例：</p>
<ul>
<li><p>创建数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE database_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建用户并授权：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#x27;username&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;password&#x27;;</span><br><span class="line">//将 &#x27;username&#x27; 替换为您要创建的用户名，并将 &#x27;password&#x27; 替换为用户的密码。</span><br><span class="line">GRANT ALL PRIVILEGES ON database_name.* TO &#x27;username&#x27;@&#x27;localhost&#x27;;</span><br><span class="line">//将 &#x27;database_name&#x27; 替换为您要授权的数据库名称。</span><br><span class="line">//或者，如果您只想为用户授予特定的权限（例如 SELECT、INSERT 等），可以使用以下格式：</span><br><span class="line">//GRANT SELECT, INSERT ON database_name.* TO &#x27;username&#x27;@&#x27;localhost&#x27;;</span><br><span class="line">//如果需要远程访问，可以将 &#x27;localhost&#x27; 替换为允许访问的 IP 地址或主机名，或者使用 &#x27;%&#x27; 表示允许从任何主机进行访问。例如：</span><br><span class="line">//GRANT ALL PRIVILEGES ON database_name.* TO &#x27;username&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;password&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示数据库列表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES;</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示数据表列表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//刷新权限以使更改生效</span><br><span class="line">SHOW TABLES FROM database_name;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>当您完成 MySQL 的配置和操作后，可以使用以下命令退出 MySQL 控制台：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>Linux mysql表名称大小写敏感</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/27/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/27/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-6/" class="post-title-link" itemprop="url">muduo库使用示例_6</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-27 19:51:30" itemprop="dateCreated datePublished" datetime="2023-08-27T19:51:30+08:00">2023-08-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-14 12:40:31" itemprop="dateModified" datetime="2023-09-14T12:40:31+08:00">2023-09-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="限制服务器最大并发连接数"><a href="#限制服务器最大并发连接数" class="headerlink" title="限制服务器最大并发连接数"></a>限制服务器最大并发连接数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  int numConnected_; // should be atomic_int 当前连接数</span><br><span class="line">  const int kMaxConnections_;//允许连接的最大数目</span><br><span class="line">  </span><br><span class="line">  void EchoServer::onConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">  &#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;EchoServer - &quot; &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;</span><br><span class="line">           &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; is &quot;</span><br><span class="line">           &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);</span><br><span class="line"></span><br><span class="line">  if (conn-&gt;connected())</span><br><span class="line">  &#123;</span><br><span class="line">    ++numConnected_;//当前连接数加一</span><br><span class="line">    if (numConnected_ &gt; kMaxConnections_)</span><br><span class="line">    &#123;</span><br><span class="line">      conn-&gt;shutdown();//断开连接</span><br><span class="line">      conn-&gt;forceCloseWithDelay(3.0);  // &gt; round trip of the whole Internet.</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    --numConnected_;//当前连接数减一</span><br><span class="line">  &#125;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;numConnected = &quot; &lt;&lt; numConnected_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="用Timing-wheel（时间轮）踢掉空闲连接"><a href="#用Timing-wheel（时间轮）踢掉空闲连接" class="headerlink" title="用Timing wheel（时间轮）踢掉空闲连接"></a>用Timing wheel（时间轮）踢掉空闲连接</h1><h2 id="main-cc"><a href="#main-cc" class="headerlink" title="main.cc"></a>main.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;examples/idleconnection/echo.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line">#include &quot;muduo/net/EventLoop.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">  // testHash();</span><br><span class="line">  EventLoop loop;</span><br><span class="line">  InetAddress listenAddr(2007);</span><br><span class="line">  int idleSeconds = 10;//环形缓冲区个数分成了10</span><br><span class="line">  if (argc &gt; 1)</span><br><span class="line">  &#123;</span><br><span class="line">    idleSeconds = atoi(argv[1]);</span><br><span class="line">  &#125;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;pid = &quot; &lt;&lt; getpid() &lt;&lt; &quot;, idle seconds = &quot; &lt;&lt; idleSeconds;</span><br><span class="line">  EchoServer server(&amp;loop, listenAddr, idleSeconds);</span><br><span class="line">  server.start();</span><br><span class="line">  loop.loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="echo-h"><a href="#echo-h" class="headerlink" title="echo.h"></a>echo.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_EXAMPLES_IDLECONNECTION_ECHO_H</span><br><span class="line">#define MUDUO_EXAMPLES_IDLECONNECTION_ECHO_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/net/TcpServer.h&quot;</span><br><span class="line">//#include &lt;muduo/base/Types.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;boost/circular_buffer.hpp&gt;</span><br><span class="line"></span><br><span class="line">// RFC 862</span><br><span class="line">class EchoServer</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  EchoServer(muduo::net::EventLoop* loop,</span><br><span class="line">             const muduo::net::InetAddress&amp; listenAddr,</span><br><span class="line">             int idleSeconds);</span><br><span class="line"></span><br><span class="line">  void start();</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  void onConnection(const muduo::net::TcpConnectionPtr&amp; conn);</span><br><span class="line"></span><br><span class="line">  void onMessage(const muduo::net::TcpConnectionPtr&amp; conn,</span><br><span class="line">                 muduo::net::Buffer* buf,</span><br><span class="line">                 muduo::Timestamp time);</span><br><span class="line"></span><br><span class="line">  void onTimer();</span><br><span class="line"></span><br><span class="line">  void dumpConnectionBuckets() const;</span><br><span class="line">  //连接的弱引用</span><br><span class="line">  typedef std::weak_ptr&lt;muduo::net::TcpConnection&gt; WeakTcpConnectionPtr;</span><br><span class="line"></span><br><span class="line">  struct Entry : public muduo::copyable</span><br><span class="line">  &#123;</span><br><span class="line">  //关键字explicit只对一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为explicit</span><br><span class="line">    explicit Entry(const WeakTcpConnectionPtr&amp; weakConn)</span><br><span class="line">      : weakConn_(weakConn)//构造一个Entry对象的时候因为是弱引用，所以计数不会加1</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Entry()</span><br><span class="line">    &#123;</span><br><span class="line">      muduo::net::TcpConnectionPtr conn = weakConn_.lock();</span><br><span class="line">      if (conn)</span><br><span class="line">      &#123;</span><br><span class="line">        conn-&gt;shutdown();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WeakTcpConnectionPtr weakConn_;</span><br><span class="line">  &#125;;</span><br><span class="line">  typedef std::shared_ptr&lt;Entry&gt; EntryPtr;//set中的元素是一个EntryPtr</span><br><span class="line">  typedef std::weak_ptr&lt;Entry&gt; WeakEntryPtr;</span><br><span class="line">  typedef std::unordered_set&lt;EntryPtr&gt; Bucket;//环形缓冲区每个格子存放的是一个hash_set，不会自动排序，提高效率</span><br><span class="line">  typedef boost::circular_buffer&lt;Bucket&gt; WeakConnectionList;//环形缓冲区</span><br><span class="line"> </span><br><span class="line">  muduo::net::TcpServer server_;</span><br><span class="line">  WeakConnectionList connectionBuckets_;//连接队列环形缓冲区</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_EXAMPLES_IDLECONNECTION_ECHO_H</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="echo-cc"><a href="#echo-cc" class="headerlink" title="echo.cc"></a>echo.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;examples/idleconnection/echo.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line">#include &quot;muduo/net/EventLoop.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EchoServer::EchoServer(EventLoop* loop,</span><br><span class="line">                       const InetAddress&amp; listenAddr,</span><br><span class="line">                       int idleSeconds)</span><br><span class="line">  : server_(loop, listenAddr, &quot;EchoServer&quot;),</span><br><span class="line">    connectionBuckets_(idleSeconds)</span><br><span class="line">&#123;</span><br><span class="line">  server_.setConnectionCallback(</span><br><span class="line">      std::bind(&amp;EchoServer::onConnection, this, _1));</span><br><span class="line">  server_.setMessageCallback(</span><br><span class="line">      std::bind(&amp;EchoServer::onMessage, this, _1, _2, _3));</span><br><span class="line">  loop-&gt;runEvery(1.0, std::bind(&amp;EchoServer::onTimer, this));//注册一个1s的定时器</span><br><span class="line">  connectionBuckets_.resize(idleSeconds);</span><br><span class="line">  dumpConnectionBuckets();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void EchoServer::start()</span><br><span class="line">&#123;</span><br><span class="line">  server_.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void EchoServer::onConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;EchoServer - &quot; &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;</span><br><span class="line">           &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; is &quot;</span><br><span class="line">           &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);</span><br><span class="line"></span><br><span class="line">  if (conn-&gt;connected())</span><br><span class="line">  &#123;</span><br><span class="line">    EntryPtr entry(new Entry(conn));</span><br><span class="line">    //connectionBuckets_.back()返回连接队列中的最后一个Bucket</span><br><span class="line">    connectionBuckets_.back().insert(entry);//插入到队尾，这时候引用计数为2</span><br><span class="line">    dumpConnectionBuckets();//将环形缓冲区连接数打印出来</span><br><span class="line">    WeakEntryPtr weakEntry(entry);</span><br><span class="line">    conn-&gt;setContext(weakEntry);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    assert(!conn-&gt;getContext().empty());</span><br><span class="line">    WeakEntryPtr weakEntry(boost::any_cast&lt;WeakEntryPtr&gt;(conn-&gt;getContext()));</span><br><span class="line">    LOG_DEBUG &lt;&lt; &quot;Entry use_count = &quot; &lt;&lt; weakEntry.use_count();//打印一下引用计数</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void EchoServer::onMessage(const TcpConnectionPtr&amp; conn,</span><br><span class="line">                           Buffer* buf,</span><br><span class="line">                           Timestamp time)</span><br><span class="line">&#123;</span><br><span class="line">  string msg(buf-&gt;retrieveAllAsString());</span><br><span class="line">  LOG_INFO &lt;&lt; conn-&gt;name() &lt;&lt; &quot; echo &quot; &lt;&lt; msg.size()</span><br><span class="line">           &lt;&lt; &quot; bytes at &quot; &lt;&lt; time.toString();</span><br><span class="line">  conn-&gt;send(msg);</span><br><span class="line"></span><br><span class="line">  assert(!conn-&gt;getContext().empty());</span><br><span class="line">  WeakEntryPtr weakEntry(boost::any_cast&lt;WeakEntryPtr&gt;(conn-&gt;getContext()));</span><br><span class="line">  EntryPtr entry(weakEntry.lock());//lock()方法将返回一个指向该资源的有效EntryPtr</span><br><span class="line">  //如果资源已经被销毁或者WeakEntryPtr为空，则lock()方法将返回一个空的EntryPtr</span><br><span class="line">  if (entry)</span><br><span class="line">  &#123;</span><br><span class="line">    connectionBuckets_.back().insert(entry);//引用计数加1</span><br><span class="line">    dumpConnectionBuckets();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void EchoServer::onTimer()</span><br><span class="line">&#123;</span><br><span class="line">  //相当于将tail位置原有的Bucket删除了，然后增加了一个空的Bucket</span><br><span class="line">  //如果有entry对象，那引用计数可能会减为0，然后调用析构函数</span><br><span class="line">  connectionBuckets_.push_back(Bucket());</span><br><span class="line">  dumpConnectionBuckets();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void EchoServer::dumpConnectionBuckets() const</span><br><span class="line">&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;size = &quot; &lt;&lt; connectionBuckets_.size();</span><br><span class="line">  int idx = 0;</span><br><span class="line">  for (WeakConnectionList::const_iterator bucketI = connectionBuckets_.begin();</span><br><span class="line">      bucketI != connectionBuckets_.end();</span><br><span class="line">      ++bucketI, ++idx)</span><br><span class="line">  &#123;</span><br><span class="line">    const Bucket&amp; bucket = *bucketI;</span><br><span class="line">    printf(&quot;[%d] len = %zd : &quot;, idx, bucket.size());</span><br><span class="line">    for (const auto&amp; it : bucket)</span><br><span class="line">    &#123;</span><br><span class="line">      bool connectionDead = it-&gt;weakConn_.expired();</span><br><span class="line">      printf(&quot;%p(%ld)%s, &quot;, get_pointer(it), it.use_count(),</span><br><span class="line">          connectionDead ? &quot; DEAD&quot; : &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;&quot;);//在标准输出中打印一个换行符</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>connectionBuckets_</code>是一个环形缓冲区（<code>WeakConnectionList</code>），存储了多个<code>Bucket</code>对象。每个<code>Bucket</code>对象是一个无序集合（<code>unordered_set&lt;EntryPtr&gt;</code>），用于存放一组<code>EntryPtr</code>对象。</p>
<p><code>connectionBuckets_.back()</code>用于获取环形缓冲区中最后一个<code>Bucket</code>对象，即最新的一个存放连接的桶。然后，通过调用<code>insert(entry)</code>将指定的<code>entry</code>插入到这个最新的<code>Bucket</code>中。</p>
<p>这样做的目的是将一个新的连接（即<code>entry</code>）添加到连接队列的环形缓冲区中，以便后续对这些连接进行管理和处理。通过将连接分散到多个桶中，可以提高效率，因为每个桶相当于一个子集，遍历查找特定连接的时间复杂度会相对较低。</p>
<hr>
<p><code>WeakEntryPtr weakEntry(entry)</code>的作用是创建一个<code>weakEntry</code>变量，将<code>entry</code>存储在其中。<code>weakEntry</code> 是一个弱引用，它不增加指向对象的引用计数。在这里，它被用作<code>TcpConnection</code>对象的上下文（context），以便在连接关闭时访问它。</p>
<p>在<code>onConnection</code>函数中，如果新建立了一个连接（<code>conn-&gt;connected()</code>为真），那么将创建一个<code>Entry</code>对象，并将其插入到<code>connectionBuckets_</code>环形缓冲区的最后一个桶中。然后，将<code>weakEntry</code>存储在连接的上下文中，以便在连接关闭时访问它。</p>
<p>在<code>onMessage</code>函数中，通过<code>boost::any_cast</code>从连接的上下文中获取<code>weakEntry</code>对象，然后使用<code>lock()</code>方法获取一个有效的<code>EntryPtr</code>对象。如果获取成功（即<code>entry</code>不为空），则将其重新插入到<code>connectionBuckets_</code>环形缓冲区的最后一个桶中，以延长它的生命周期。这样做是为了确保在每次有活动的消息时，该连接在<code>connectionBuckets_</code>中所在的桶不会被回收。</p>
<hr>
<p>在<code>Entry</code>的析构函数中，会通过<code>weakConn_.lock()</code>方法尝试将弱引用转换为强引用，即获取一个有效的<code>TcpConnectionPtr</code>(称为<code>conn</code>)。如果<code>TcpConnection</code>对象仍然存在，则通过<code>conn-&gt;shutdown()</code>方法关闭连接。</p>
<p>这样设计的目的是，在连接关闭时自动释放与之关联的<code>Entry</code>对象，避免内存泄漏。由于<code>weakConn_</code>是一个弱引用，它不会使<code>TcpConnection</code>的引用计数增加，因此在关闭连接后，如果没有其他强引用指向该连接，<code>conn</code>将为空，<code>Entry</code>对象因此可以安全地被销毁。</p>
<hr>
<p><code>Entry</code>的析构函数会在以下情况下被调用：</p>
<ol>
<li><p>当与 <code>Entry</code> 对象关联的 <code>TcpConnection</code> 连接关闭时，析构函数会被调用。这是因为在 <code>onConnection</code> 函数中，当一个新的连接建立时，会创建一个 <code>Entry</code> 对象，并将其插入到 <code>connectionBuckets_</code> 环形缓冲区的最后一个桶中。当该连接关闭时，<code>TcpConnection</code> 对象的引用计数减为零，<code>TcpConnection</code> 的析构函数被调用，进而引发 <code>Entry</code> 对象的析构函数的调用。</p>
</li>
<li><p>当 <code>EchoServer</code> 对象销毁时，其中所有的 <code>Entry</code> 对象也会随之被销毁，其析构函数会被调用。这是因为 <code>EchoServer</code> 在内部存储了一组 <code>EntryPtr</code>，当 <code>EchoServer</code> 对象被销毁时，它管理的所有 <code>Entry</code> 对象也会被销毁。或者是 <code>EntryPtr entry</code>引用计数为0，调用析构函数。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//相当于将tail位置原有的Bucket删除了，然后增加了一个空的Bucket</span><br><span class="line">//如果有entry对象，那引用计数可能会减为0，然后调用析构函数</span><br><span class="line">connectionBuckets_.push_back(Bucket());</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p>在连接建立时，创建一个Entry对象，把它放到 timing wheel的队尾。另外，我们还需要把 Entry的弱引用保存到TcpConnection的 context里，因为在收到数据的时候还要用到Entry。(思考题:如果TcpConnection:setContext保存的是强引用EntryPtr，会出现什么情况?)</p>
<ul>
<li><p>因为在onMessage中需要用到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakEntryPtr weakEntry(boost::any_cast&lt;WeakEntryPtr&gt;(conn-&gt;getContext()));</span><br></pre></td></tr></table></figure>

<p>在onConnection中需要设置 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn-&gt;setContext(weakEntry);</span><br></pre></td></tr></table></figure>

<p>如果是强引用，计数会加一，到了后面就无法减为0了</p>
<hr>
</li>
</ul>
<p>在收到消息时，从TcpConnection 的 context中取出 Entry的弱引用，把它提升为强引用EntryPtr，然后放到当前的timing wheel队尾。(思考题，为什么要把Entry作为TcpConnection的context保存，如果这里再创建一个新的Entry会有什么后果?)</p>
<ul>
<li><p>如果在onMessage中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//WeakEntryPtr weakEntry(boost::any_cast&lt;WeakEntryPtr&gt;(conn-&gt;getContext()));</span><br><span class="line">//EntryPtr entry(weakEntry.lock());</span><br><span class="line"></span><br><span class="line">EntryPtr entry(new Entry(conn));</span><br></pre></td></tr></table></figure>

<p>是不行的，因为这样虽然关联的同一个TcpConnection，但是是新建的对象，引用计数为1，与上面的没关系。</p>
<hr>
</li>
</ul>
<p><strong>改进</strong>：在现在的实现中，每次收到消息都会往队尾添加EntryPtr (当然, hash set会帮我们去重。) - - 个简单的改进措施是，在TcpConnection里保存“最后一次往队尾添加引用时的tail位置”，然后先检查tail是否变化，若无变化则不重复添加EntryPtr。<br>这样或许能提高效率。</p>
<h1 id="sortedlist-cc"><a href="#sortedlist-cc" class="headerlink" title="sortedlist.cc"></a>sortedlist.cc</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line">#include &quot;muduo/net/EventLoop.h&quot;</span><br><span class="line">#include &quot;muduo/net/TcpServer.h&quot;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">// RFC 862</span><br><span class="line">class EchoServer</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  EchoServer(EventLoop* loop,</span><br><span class="line">             const InetAddress&amp; listenAddr,</span><br><span class="line">             int idleSeconds);</span><br><span class="line"></span><br><span class="line">  void start()</span><br><span class="line">  &#123;</span><br><span class="line">    server_.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  void onConnection(const TcpConnectionPtr&amp; conn);</span><br><span class="line"></span><br><span class="line">  void onMessage(const TcpConnectionPtr&amp; conn,</span><br><span class="line">                 Buffer* buf,</span><br><span class="line">                 Timestamp time);</span><br><span class="line"></span><br><span class="line">  void onTimer();</span><br><span class="line"></span><br><span class="line">  void dumpConnectionList() const;</span><br><span class="line"></span><br><span class="line">  typedef std::weak_ptr&lt;TcpConnection&gt; WeakTcpConnectionPtr;</span><br><span class="line">  typedef std::list&lt;WeakTcpConnectionPtr&gt; WeakConnectionList;</span><br><span class="line"></span><br><span class="line">  struct Node : public muduo::copyable</span><br><span class="line">  &#123;</span><br><span class="line">    Timestamp lastReceiveTime;//该连接最后一次活跃时刻</span><br><span class="line">    WeakConnectionList::iterator position;//该连接在连接列表中的位置</span><br><span class="line">    //position是一个迭代器变量，用于指向WeakConnectionList中的某个位置</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  TcpServer server_;</span><br><span class="line">  int idleSeconds_;</span><br><span class="line">  WeakConnectionList connectionList_;//连接列表</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EchoServer::EchoServer(EventLoop* loop,</span><br><span class="line">                       const InetAddress&amp; listenAddr,</span><br><span class="line">                       int idleSeconds)</span><br><span class="line">  : server_(loop, listenAddr, &quot;EchoServer&quot;),</span><br><span class="line">    idleSeconds_(idleSeconds)</span><br><span class="line">&#123;</span><br><span class="line">  server_.setConnectionCallback(</span><br><span class="line">      std::bind(&amp;EchoServer::onConnection, this, _1));</span><br><span class="line">  server_.setMessageCallback(</span><br><span class="line">      std::bind(&amp;EchoServer::onMessage, this, _1, _2, _3));</span><br><span class="line">  loop-&gt;runEvery(1.0, std::bind(&amp;EchoServer::onTimer, this));</span><br><span class="line">  dumpConnectionList();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void EchoServer::onConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;EchoServer - &quot; &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;</span><br><span class="line">           &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; is &quot;</span><br><span class="line">           &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);</span><br><span class="line"></span><br><span class="line">  if (conn-&gt;connected())</span><br><span class="line">  &#123;</span><br><span class="line">    Node node;</span><br><span class="line">    node.lastReceiveTime = Timestamp::now();</span><br><span class="line">    connectionList_.push_back(conn);</span><br><span class="line">    //将迭代器指向连接列表的最后一个元素，即新添加的连接对象(conn)</span><br><span class="line">    node.position = --connectionList_.end();</span><br><span class="line">    conn-&gt;setContext(node);//将TcpConnection与Node关联，以便得到conn，就能得到node</span><br><span class="line">  &#125;</span><br><span class="line">  else//连接断开</span><br><span class="line">  &#123;</span><br><span class="line">    assert(!conn-&gt;getContext().empty());</span><br><span class="line">    const Node&amp; node = boost::any_cast&lt;const Node&amp;&gt;(conn-&gt;getContext());//通过conn得到node</span><br><span class="line">    connectionList_.erase(node.position);//将node从连接列表中移除</span><br><span class="line">  &#125;</span><br><span class="line">  dumpConnectionList();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void EchoServer::onMessage(const TcpConnectionPtr&amp; conn,</span><br><span class="line">                           Buffer* buf,</span><br><span class="line">                           Timestamp time)</span><br><span class="line">&#123;</span><br><span class="line">  string msg(buf-&gt;retrieveAllAsString());</span><br><span class="line">  LOG_INFO &lt;&lt; conn-&gt;name() &lt;&lt; &quot; echo &quot; &lt;&lt; msg.size()</span><br><span class="line">           &lt;&lt; &quot; bytes at &quot; &lt;&lt; time.toString();</span><br><span class="line">  conn-&gt;send(msg);</span><br><span class="line"></span><br><span class="line">  assert(!conn-&gt;getContext().empty());</span><br><span class="line">  Node* node = boost::any_cast&lt;Node&gt;(conn-&gt;getMutableContext());</span><br><span class="line">  node-&gt;lastReceiveTime = time;</span><br><span class="line">  //是将位于node-&gt;position迭代器指向的位置的元素从connectionList_移动到connectionList_的末尾</span><br><span class="line">  connectionList_.splice(connectionList_.end(), connectionList_, node-&gt;position);</span><br><span class="line">  assert(node-&gt;position == --connectionList_.end());</span><br><span class="line"></span><br><span class="line">  dumpConnectionList();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void EchoServer::onTimer()</span><br><span class="line">&#123;</span><br><span class="line">  dumpConnectionList();</span><br><span class="line">  Timestamp now = Timestamp::now();</span><br><span class="line">  for (WeakConnectionList::iterator it = connectionList_.begin();</span><br><span class="line">      it != connectionList_.end();)</span><br><span class="line">  &#123;</span><br><span class="line">    TcpConnectionPtr conn = it-&gt;lock();</span><br><span class="line">    if (conn)</span><br><span class="line">    &#123;</span><br><span class="line">      Node* n = boost::any_cast&lt;Node&gt;(conn-&gt;getMutableContext());</span><br><span class="line">      double age = timeDifference(now, n-&gt;lastReceiveTime);</span><br><span class="line">      if (age &gt; idleSeconds_)//说明超时了</span><br><span class="line">      &#123;</span><br><span class="line">        if (conn-&gt;connected())</span><br><span class="line">        &#123;</span><br><span class="line">          conn-&gt;shutdown();</span><br><span class="line">          LOG_INFO &lt;&lt; &quot;shutting down &quot; &lt;&lt; conn-&gt;name();</span><br><span class="line">          conn-&gt;forceCloseWithDelay(3.5);  // &gt; round trip of the whole Internet.</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else if (age &lt; 0)</span><br><span class="line">      &#123;</span><br><span class="line">        LOG_WARN &lt;&lt; &quot;Time jump&quot;;</span><br><span class="line">        n-&gt;lastReceiveTime = now;</span><br><span class="line">      &#125;</span><br><span class="line">      else//未超时</span><br><span class="line">      &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      ++it;</span><br><span class="line">    &#125;</span><br><span class="line">    else//it-&gt;lock()提升失败，说明连接已关闭</span><br><span class="line">    &#123;</span><br><span class="line">      LOG_WARN &lt;&lt; &quot;Expired&quot;;</span><br><span class="line">      //将连接列表 connectionList_ 中的迭代器 it 指向的元素删除，并返回指向被删除元素之后位置的迭代器</span><br><span class="line">      it = connectionList_.erase(it);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void EchoServer::dumpConnectionList() const</span><br><span class="line">&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;size = &quot; &lt;&lt; connectionList_.size();</span><br><span class="line"></span><br><span class="line">  for (WeakConnectionList::const_iterator it = connectionList_.begin();</span><br><span class="line">      it != connectionList_.end(); ++it)</span><br><span class="line">  &#123;</span><br><span class="line">    TcpConnectionPtr conn = it-&gt;lock();</span><br><span class="line">    if (conn)</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;conn %p\n&quot;, get_pointer(conn));</span><br><span class="line">      const Node&amp; n = boost::any_cast&lt;const Node&amp;&gt;(conn-&gt;getContext());</span><br><span class="line">      printf(&quot;    time %s\n&quot;, n.lastReceiveTime.toString().c_str());</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;expired\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">  EventLoop loop;</span><br><span class="line">  InetAddress listenAddr(2007);</span><br><span class="line">  int idleSeconds = 10;</span><br><span class="line">  if (argc &gt; 1)</span><br><span class="line">  &#123;</span><br><span class="line">    idleSeconds = atoi(argv[1]);</span><br><span class="line">  &#125;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;pid = &quot; &lt;&lt; getpid() &lt;&lt; &quot;, idle seconds = &quot; &lt;&lt; idleSeconds;</span><br><span class="line">  EchoServer server(&amp;loop, listenAddr, idleSeconds);</span><br><span class="line">  server.start();</span><br><span class="line">  loop.loop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该代码采用了一种时间排列，将最晚到期的放在list容器最后，然后根据age &gt; idleSeconds_判断是否超时，因为是按时间排列的，在onTimer遍历的时候如果到了最后一个没超时的，就不用继续判断了，如果发送了消息，需要更新，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//是将位于node-&gt;position迭代器指向的位置的元素从connectionList_移动到connectionList_的末尾</span><br><span class="line">  connectionList_.splice(connectionList_.end(), connectionList_, node-&gt;position);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/27/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-%E4%BA%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/27/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-%E4%BA%94/" class="post-title-link" itemprop="url">muduo库使用示例_五</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-27 16:03:30 / 修改时间：16:39:40" itemprop="dateCreated datePublished" datetime="2023-08-27T16:03:30+08:00">2023-08-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="测量两台机器网络延迟–RTT"><a href="#测量两台机器网络延迟–RTT" class="headerlink" title="测量两台机器网络延迟–RTT"></a>测量两台机器网络延迟–RTT</h1><p>往返时间&#x2F; round trip time&#x2F; RTT</p>
<p><strong>NTP</strong>是网络时间同步协议<br>用来同步客户端与服务端的时钟</p>
<p><img src="/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-%E4%BA%94/image-20230827160856414.png" alt="image-20230827160856414"></p>
<img src="/2023/08/27/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-%E4%BA%94/image-20230827160856414.png" class title="This is an test image">

<p>RTT&#x3D;(T4-T1)-(T3-T2)</p>
<p>T1 + RTT&#x2F;2 &#x3D; T2 + offset (offset是指客户端与服务器端的时间差)，如果客户端的时钟快了，则offset为正。offset &#x3D; T1 - T2 + RTT&#x2F;2 &#x3D; T1 - T2 +((T4-T1)-(T3-T2))&#x2F;2 &#x3D; ((T4+T1)-(T2+T3))&#x2F;2</p>
<p>设计的<strong>roundtrip</strong>示例程序中，协议有所简化：</p>
<p><img src="/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-%E4%BA%94/image-20230827161556177.png" alt="image-20230827161556177"></p>
<img src="/2023/08/27/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-%E4%BA%94/image-20230827161556177.png" class title="This is an test image">

<p>offset是指服务器端与客户端的时间差</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line">#include &quot;muduo/net/EventLoop.h&quot;</span><br><span class="line">#include &quot;muduo/net/TcpClient.h&quot;</span><br><span class="line">#include &quot;muduo/net/TcpServer.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">const size_t frameLen = 2*sizeof(int64_t);</span><br><span class="line"></span><br><span class="line">void serverConnectionCallback(const TcpConnectionPtr&amp; conn)</span><br><span class="line">&#123;</span><br><span class="line">  LOG_TRACE &lt;&lt; conn-&gt;name() &lt;&lt; &quot; &quot; &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;</span><br><span class="line">        &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; is &quot;</span><br><span class="line">        &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);</span><br><span class="line">  if (conn-&gt;connected())</span><br><span class="line">  &#123;</span><br><span class="line">    conn-&gt;setTcpNoDelay(true);//因为协议是消息一到立刻发送</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void serverMessageCallback(const TcpConnectionPtr&amp; conn,</span><br><span class="line">                           Buffer* buffer,</span><br><span class="line">                           muduo::Timestamp receiveTime)</span><br><span class="line">&#123;</span><br><span class="line">  int64_t message[2];</span><br><span class="line">  while (buffer-&gt;readableBytes() &gt;= frameLen)</span><br><span class="line">  &#123;</span><br><span class="line">    memcpy(message, buffer-&gt;peek(), frameLen);</span><br><span class="line">    buffer-&gt;retrieve(frameLen);</span><br><span class="line">    message[1] = receiveTime.microSecondsSinceEpoch();</span><br><span class="line">    conn-&gt;send(message, sizeof message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void runServer(uint16_t port)</span><br><span class="line">&#123;</span><br><span class="line">  EventLoop loop;</span><br><span class="line">  TcpServer server(&amp;loop, InetAddress(port), &quot;ClockServer&quot;);</span><br><span class="line">  server.setConnectionCallback(serverConnectionCallback);</span><br><span class="line">  server.setMessageCallback(serverMessageCallback);</span><br><span class="line">  server.start();</span><br><span class="line">  loop.loop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpConnectionPtr clientConnection;</span><br><span class="line"></span><br><span class="line">void clientConnectionCallback(const TcpConnectionPtr&amp; conn)</span><br><span class="line">&#123;</span><br><span class="line">  LOG_TRACE &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;</span><br><span class="line">        &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; is &quot;</span><br><span class="line">        &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);</span><br><span class="line">  if (conn-&gt;connected())</span><br><span class="line">  &#123;</span><br><span class="line">    clientConnection = conn;</span><br><span class="line">    conn-&gt;setTcpNoDelay(true);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    clientConnection.reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void clientMessageCallback(const TcpConnectionPtr&amp;,</span><br><span class="line">                           Buffer* buffer,</span><br><span class="line">                           muduo::Timestamp receiveTime)</span><br><span class="line">&#123;</span><br><span class="line">  int64_t message[2];</span><br><span class="line">  while (buffer-&gt;readableBytes() &gt;= frameLen)</span><br><span class="line">  &#123;</span><br><span class="line">    memcpy(message, buffer-&gt;peek(), frameLen);</span><br><span class="line">    buffer-&gt;retrieve(frameLen);</span><br><span class="line">    int64_t send = message[0];//T1</span><br><span class="line">    int64_t their = message[1];//T2</span><br><span class="line">    int64_t back = receiveTime.microSecondsSinceEpoch();//T3</span><br><span class="line">    int64_t mine = (back+send)/2;</span><br><span class="line">    LOG_INFO &lt;&lt; &quot;round trip &quot; &lt;&lt; back - send</span><br><span class="line">             &lt;&lt; &quot; clock error &quot; &lt;&lt; their - mine;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sendMyTime()</span><br><span class="line">&#123;</span><br><span class="line">  if (clientConnection)</span><br><span class="line">  &#123;</span><br><span class="line">    int64_t message[2] = &#123; 0, 0 &#125;;</span><br><span class="line">    message[0] = Timestamp::now().microSecondsSinceEpoch();</span><br><span class="line">    clientConnection-&gt;send(message, sizeof message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void runClient(const char* ip, uint16_t port)</span><br><span class="line">&#123;</span><br><span class="line">  EventLoop loop;</span><br><span class="line">  TcpClient client(&amp;loop, InetAddress(ip, port), &quot;ClockClient&quot;);</span><br><span class="line">  client.enableRetry();</span><br><span class="line">  client.setConnectionCallback(clientConnectionCallback);</span><br><span class="line">  client.setMessageCallback(clientMessageCallback);</span><br><span class="line">  client.connect();</span><br><span class="line">  loop.runEvery(0.2, sendMyTime);</span><br><span class="line">  loop.loop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">  if (argc &gt; 2)</span><br><span class="line">  &#123;</span><br><span class="line">    uint16_t port = static_cast&lt;uint16_t&gt;(atoi(argv[2]));</span><br><span class="line">    if (strcmp(argv[1], &quot;-s&quot;) == 0)</span><br><span class="line">    &#123;</span><br><span class="line">      runServer(port);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      runClient(argv[1], port);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Usage:\n%s -s port\n%s ip port\n&quot;, argv[0], argv[0]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/24/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/24/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-3/" class="post-title-link" itemprop="url">muduo库使用示例-3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-24 19:01:01" itemprop="dateCreated datePublished" datetime="2023-08-24T19:01:01+08:00">2023-08-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-08 12:37:50" itemprop="dateModified" datetime="2023-09-08T12:37:50+08:00">2023-09-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="聊天服务器"><a href="#聊天服务器" class="headerlink" title="聊天服务器"></a>聊天服务器</h1><h2 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h2><p>消息分为包头与包体，每条消息有一个4字节的头部，以网络序存放字符串的长度。包体是一个字符串，字符串也不一定以’\0’结尾。比方说有两条消息”hello”和”chenshuo”，那么打包后的字节流是:0x00,0x00,0x00,0x05,’h’,’e’,’,’l’,’l’,’o’,0x00,0x00,0x00,0x08,’c’,’h’,’e’,’n’,’s’,’h’,’u’,’o’<br>共21字节。</p>
<p>字符串不一定以’\0’结尾是因为在消息传输中，字符串的长度已经通过包头中的4字节进行了明确的指定，所以没有必要使用’\0’来表示字符串的结束。</p>
<p>在网络通信中，消息传输往往使用二进制格式，而不是以C语言风格的以’\0’结尾的字符串。通过包头中的长度信息，接收方可以准确地知道要读取的字节数，从而正确解析出字符串。</p>
<p>由于字符串的长度信息已经被明确传递并解析，没有必要依赖于’\0’作为字符串的结束标志。事实上，在一些特定的应用场景中，字符串内容本身可能会包含’\0’字符，如果字符串以’\0’结尾，则会导致字符串截断，丢失部分数据。</p>
<p>因此，在消息传输中，字符串可以是任意字节的数据序列，并不依赖于’\0’来标识结束。接收方可以根据包头中指定的长度来正确处理和解析字符串</p>
<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p><img src="/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-3/image-20230824193437339.png" alt="image-20230824193437339"></p>
<img src="/2023/08/24/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-3/image-20230824193437339.png" class title="This is an test image">

<p>LengthHeaderCodec是间接层，对消息进行编解码</p>
<h2 id="codec-h"><a href="#codec-h" class="headerlink" title="codec.h"></a>codec.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_EXAMPLES_ASIO_CHAT_CODEC_H</span><br><span class="line">#define MUDUO_EXAMPLES_ASIO_CHAT_CODEC_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line">#include &quot;muduo/net/Buffer.h&quot;</span><br><span class="line">#include &quot;muduo/net/Endian.h&quot;</span><br><span class="line">#include &quot;muduo/net/TcpConnection.h&quot;</span><br><span class="line"></span><br><span class="line">class LengthHeaderCodec : muduo::noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  typedef std::function&lt;void (const muduo::net::TcpConnectionPtr&amp;,</span><br><span class="line">                                const muduo::string&amp; message,</span><br><span class="line">                                muduo::Timestamp)&gt; StringMessageCallback;</span><br><span class="line"></span><br><span class="line">  explicit LengthHeaderCodec(const StringMessageCallback&amp; cb)</span><br><span class="line">    : messageCallback_(cb)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void onMessage(const muduo::net::TcpConnectionPtr&amp; conn,</span><br><span class="line">                 muduo::net::Buffer* buf,</span><br><span class="line">                 muduo::Timestamp receiveTime)</span><br><span class="line">  &#123;</span><br><span class="line">    //用while而不用if，因为不止一条消息</span><br><span class="line">    //粘包问题的处理，TCP是字节流，是无边界的，传输层不处理边界，所以需要在应用层处理</span><br><span class="line">    while (buf-&gt;readableBytes() &gt;= kHeaderLen) // kHeaderLen == 4</span><br><span class="line">    &#123;</span><br><span class="line">      // FIXME: use Buffer::peekInt32()</span><br><span class="line">      const void* data = buf-&gt;peek();</span><br><span class="line">      int32_t be32 = *static_cast&lt;const int32_t*&gt;(data); // SIGBUS</span><br><span class="line">      const int32_t len = muduo::net::sockets::networkToHost32(be32);</span><br><span class="line">      if (len &gt; 65536 || len &lt; 0)//64k</span><br><span class="line">      &#123;</span><br><span class="line">        LOG_ERROR &lt;&lt; &quot;Invalid length &quot; &lt;&lt; len;</span><br><span class="line">        conn-&gt;shutdown();  // FIXME: disable reading</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      else if (buf-&gt;readableBytes() &gt;= len + kHeaderLen)//达到一条完整的消息</span><br><span class="line">      &#123;</span><br><span class="line">        buf-&gt;retrieve(kHeaderLen);</span><br><span class="line">        muduo::string message(buf-&gt;peek(), len);</span><br><span class="line">        messageCallback_(conn, message, receiveTime);</span><br><span class="line">        buf-&gt;retrieve(len);</span><br><span class="line">      &#125;</span><br><span class="line">      else//未达到一条完整的消息</span><br><span class="line">      &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // FIXME: TcpConnectionPtr</span><br><span class="line">  void send(muduo::net::TcpConnection* conn,</span><br><span class="line">            const muduo::StringPiece&amp; message)</span><br><span class="line">  &#123;</span><br><span class="line">    muduo::net::Buffer buf;</span><br><span class="line">    buf.append(message.data(), message.size());</span><br><span class="line">    int32_t len = static_cast&lt;int32_t&gt;(message.size());</span><br><span class="line">    int32_t be32 = muduo::net::sockets::hostToNetwork32(len);</span><br><span class="line">    buf.prepend(&amp;be32, sizeof be32);</span><br><span class="line">    conn-&gt;send(&amp;buf);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  StringMessageCallback messageCallback_;</span><br><span class="line">  const static size_t kHeaderLen = sizeof(int32_t);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_EXAMPLES_ASIO_CHAT_CODEC_H</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="server-cc"><a href="#server-cc" class="headerlink" title="server.cc"></a>server.cc</h2><p>单线程</p>
<p>错误的消息。<br>服务端如何处理这个错误的消息呢。<br>还会带上一个应用层的校验信息的。比如说CRC32校验。<br>校验错误，这条消息就是错误的消息。</p>
<p>第二种方式:<br>服务器端应该有空闲断开功能。在一定时间没有收到客户端的消息，就断开它。</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;examples/asio/chat/codec.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line">#include &quot;muduo/base/Mutex.h&quot;</span><br><span class="line">#include &quot;muduo/net/EventLoop.h&quot;</span><br><span class="line">#include &quot;muduo/net/TcpServer.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">class ChatServer : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  ChatServer(EventLoop* loop,</span><br><span class="line">             const InetAddress&amp; listenAddr)</span><br><span class="line">  : server_(loop, listenAddr, &quot;ChatServer&quot;),</span><br><span class="line">    codec_(std::bind(&amp;ChatServer::onStringMessage, this, _1, _2, _3))</span><br><span class="line">  &#123;</span><br><span class="line">    server_.setConnectionCallback(</span><br><span class="line">        std::bind(&amp;ChatServer::onConnection, this, _1));</span><br><span class="line">    server_.setMessageCallback(</span><br><span class="line">        std::bind(&amp;LengthHeaderCodec::onMessage, &amp;codec_, _1, _2, _3));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void start()</span><br><span class="line">  &#123;</span><br><span class="line">    server_.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  void onConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_INFO &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;</span><br><span class="line">             &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; is &quot;</span><br><span class="line">             &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);</span><br><span class="line"></span><br><span class="line">    if (conn-&gt;connected())</span><br><span class="line">    &#123;</span><br><span class="line">      connections_.insert(conn);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      connections_.erase(conn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void onStringMessage(const TcpConnectionPtr&amp;,</span><br><span class="line">                       const string&amp; message,</span><br><span class="line">                       Timestamp)</span><br><span class="line">  &#123;</span><br><span class="line">    //只有一个IO线程，因而这里的connections_不需要用mutex保护</span><br><span class="line">    //转发消息给所有客户端</span><br><span class="line">    for (ConnectionList::iterator it = connections_.begin();</span><br><span class="line">        it != connections_.end();</span><br><span class="line">        ++it)</span><br><span class="line">    &#123;</span><br><span class="line">      codec_.send(get_pointer(*it), message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  typedef std::set&lt;TcpConnectionPtr&gt; ConnectionList;</span><br><span class="line">  TcpServer server_;</span><br><span class="line">  LengthHeaderCodec codec_;//消息编解码</span><br><span class="line">  ConnectionList connections_;//连接列表，遍历连接列表来转发消息</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;pid = &quot; &lt;&lt; getpid();</span><br><span class="line">  if (argc &gt; 1)</span><br><span class="line">  &#123;</span><br><span class="line">    EventLoop loop;</span><br><span class="line">    uint16_t port = static_cast&lt;uint16_t&gt;(atoi(argv[1]));</span><br><span class="line">    InetAddress serverAddr(port);</span><br><span class="line">    ChatServer server(&amp;loop, serverAddr);</span><br><span class="line">    server.start();</span><br><span class="line">    loop.loop();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Usage: %s port\n&quot;, argv[0]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="client-cc"><a href="#client-cc" class="headerlink" title="client.cc"></a>client.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;examples/asio/chat/codec.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line">#include &quot;muduo/base/Mutex.h&quot;</span><br><span class="line">#include &quot;muduo/net/EventLoopThread.h&quot;</span><br><span class="line">#include &quot;muduo/net/TcpClient.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">class ChatClient : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  ChatClient(EventLoop* loop, const InetAddress&amp; serverAddr)</span><br><span class="line">    : client_(loop, serverAddr, &quot;ChatClient&quot;),</span><br><span class="line">      codec_(std::bind(&amp;ChatClient::onStringMessage, this, _1, _2, _3))</span><br><span class="line">  &#123;</span><br><span class="line">    client_.setConnectionCallback(</span><br><span class="line">        std::bind(&amp;ChatClient::onConnection, this, _1));</span><br><span class="line">    client_.setMessageCallback(</span><br><span class="line">        std::bind(&amp;LengthHeaderCodec::onMessage, &amp;codec_, _1, _2, _3));</span><br><span class="line">    client_.enableRetry();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void connect()</span><br><span class="line">  &#123;</span><br><span class="line">    client_.connect();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void disconnect()</span><br><span class="line">  &#123;</span><br><span class="line">    client_.disconnect();</span><br><span class="line">  &#125;</span><br><span class="line">  //该函数在主线程中执行,因为connection_主线程和IO线程都要访问，所以onConnection中需要保护</span><br><span class="line">  void write(const StringPiece&amp; message)</span><br><span class="line">  &#123;</span><br><span class="line">    //mutex用来保护connection_这个shared_ptr</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    if (connection_)</span><br><span class="line">    &#123;</span><br><span class="line">      codec_.send(get_pointer(connection_), message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line"> //该函数在IO线程中执行，IO线程与主线程不在同一个线程</span><br><span class="line">  void onConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_INFO &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;</span><br><span class="line">             &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; is &quot;</span><br><span class="line">             &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);</span><br><span class="line"></span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    if (conn-&gt;connected())</span><br><span class="line">    &#123;</span><br><span class="line">      connection_ = conn;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      connection_.reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void onStringMessage(const TcpConnectionPtr&amp;,</span><br><span class="line">                       const string&amp; message,</span><br><span class="line">                       Timestamp)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;&lt;&lt;&lt; %s\n&quot;, message.c_str());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  TcpClient client_;</span><br><span class="line">  LengthHeaderCodec codec_;</span><br><span class="line">  MutexLock mutex_;</span><br><span class="line">  TcpConnectionPtr connection_ GUARDED_BY(mutex_);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;pid = &quot; &lt;&lt; getpid();</span><br><span class="line">  if (argc &gt; 2)</span><br><span class="line">  &#123;</span><br><span class="line">    EventLoopThread loopThread;</span><br><span class="line">    uint16_t port = static_cast&lt;uint16_t&gt;(atoi(argv[2]));</span><br><span class="line">    InetAddress serverAddr(argv[1], port);</span><br><span class="line"></span><br><span class="line">    ChatClient client(loopThread.startLoop(), serverAddr);</span><br><span class="line">    client.connect();</span><br><span class="line">    std::string line;</span><br><span class="line">    while (std::getline(std::cin, line))</span><br><span class="line">    &#123;</span><br><span class="line">      client.write(line);</span><br><span class="line">    &#125;</span><br><span class="line">    client.disconnect();</span><br><span class="line">    CurrentThread::sleepUsec(1000*1000);  // wait for disconnect, see ace/logging/client.cc</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Usage: %s host_ip port\n&quot;, argv[0]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="server-threaded-cc"><a href="#server-threaded-cc" class="headerlink" title="server_threaded.cc"></a>server_threaded.cc</h2><p>多线程TcpServer，并用mutex来保护共享数据mutex</p>
<p>由于mutex的存在，多线程并不能并发执行，而是串行的。</p>
<p>因而存在较高的锁竞争。效率比较低。<br>C1向服务器端发送一条消息hello,服务器通过一个IO线程转发给所有客户端，与此同时C2向服务器端发送—条消息hello2，服务器端通过另一个IO线程<br>转发给所有客户端，由于锁的在存在，这两个线程并不能并发执行，而是串行的。这个时候，客户端数目比较大，第二条消息hello2到达各个客户端的延迟也比较大。</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;examples/asio/chat/codec.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line">#include &quot;muduo/base/Mutex.h&quot;</span><br><span class="line">#include &quot;muduo/net/EventLoop.h&quot;</span><br><span class="line">#include &quot;muduo/net/TcpServer.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">class ChatServer : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  ChatServer(EventLoop* loop,</span><br><span class="line">             const InetAddress&amp; listenAddr)</span><br><span class="line">  : server_(loop, listenAddr, &quot;ChatServer&quot;),</span><br><span class="line">    codec_(std::bind(&amp;ChatServer::onStringMessage, this, _1, _2, _3))</span><br><span class="line">  &#123;</span><br><span class="line">    server_.setConnectionCallback(</span><br><span class="line">        std::bind(&amp;ChatServer::onConnection, this, _1));</span><br><span class="line">    server_.setMessageCallback(</span><br><span class="line">        std::bind(&amp;LengthHeaderCodec::onMessage, &amp;codec_, _1, _2, _3));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void setThreadNum(int numThreads)</span><br><span class="line">  &#123;</span><br><span class="line">    server_.setThreadNum(numThreads);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void start()</span><br><span class="line">  &#123;</span><br><span class="line">    server_.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  void onConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_INFO &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;</span><br><span class="line">        &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; is &quot;</span><br><span class="line">        &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);</span><br><span class="line">    //有多个IO线程，因而这里的connections_需要用mutex保护</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    if (conn-&gt;connected())</span><br><span class="line">    &#123;</span><br><span class="line">      connections_.insert(conn);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      connections_.erase(conn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void onStringMessage(const TcpConnectionPtr&amp;,</span><br><span class="line">                       const string&amp; message,</span><br><span class="line">                       Timestamp)</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    for (ConnectionList::iterator it = connections_.begin();</span><br><span class="line">        it != connections_.end();</span><br><span class="line">        ++it)</span><br><span class="line">    &#123;</span><br><span class="line">      codec_.send(get_pointer(*it), message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  typedef std::set&lt;TcpConnectionPtr&gt; ConnectionList;</span><br><span class="line">  TcpServer server_;</span><br><span class="line">  LengthHeaderCodec codec_;</span><br><span class="line">  MutexLock mutex_;</span><br><span class="line">  ConnectionList connections_ GUARDED_BY(mutex_);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;pid = &quot; &lt;&lt; getpid();</span><br><span class="line">  if (argc &gt; 1)</span><br><span class="line">  &#123;</span><br><span class="line">    EventLoop loop;</span><br><span class="line">    uint16_t port = static_cast&lt;uint16_t&gt;(atoi(argv[1]));</span><br><span class="line">    InetAddress serverAddr(port);</span><br><span class="line">    ChatServer server(&amp;loop, serverAddr);</span><br><span class="line">    if (argc &gt; 2)</span><br><span class="line">    &#123;</span><br><span class="line">      server.setThreadNum(atoi(argv[2]));</span><br><span class="line">    &#125;</span><br><span class="line">    server.start();</span><br><span class="line">    loop.loop();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Usage: %s port [thread_num]\n&quot;, argv[0]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="server-threaded-efficient-cc"><a href="#server-threaded-efficient-cc" class="headerlink" title="server_threaded_efficient.cc"></a>server_threaded_efficient.cc</h2><p>借shared_ptr实现copy-on-write的手法来降低锁竞争</p>
<ul>
<li>shared_ptr是引用计数智能指针，如果当前只有一个观察者，那么引用计数为1,可以用shared_ptr::unique()来判断</li>
<li>对于write端，如果发现引用计数为1，这时可以安全地修改对象,不必担心有人在读它。</li>
<li>对于read端，在读之前把引用计数加1，读完之后减1，这样可以保证在读的期间其引用计数大于1，可以阻止并发写。</li>
<li>比较难的是，对于write端，如果发现引用计数大于1，该如何处理，既然要更新数据，肯定要加锁，如果这时候其他线程正在读，那么不能在原来的数据上修改，得创建一个副本，在副本上修改，修改完了再替换。如果没有用户在读，那么可以直接修改。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;examples/asio/chat/codec.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line">#include &quot;muduo/base/Mutex.h&quot;</span><br><span class="line">#include &quot;muduo/net/EventLoop.h&quot;</span><br><span class="line">#include &quot;muduo/net/TcpServer.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">class ChatServer : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  ChatServer(EventLoop* loop,</span><br><span class="line">             const InetAddress&amp; listenAddr)</span><br><span class="line">  : server_(loop, listenAddr, &quot;ChatServer&quot;),</span><br><span class="line">    codec_(std::bind(&amp;ChatServer::onStringMessage, this, _1, _2, _3)),</span><br><span class="line">    connections_(new ConnectionList)</span><br><span class="line">  &#123;</span><br><span class="line">    server_.setConnectionCallback(</span><br><span class="line">        std::bind(&amp;ChatServer::onConnection, this, _1));</span><br><span class="line">    server_.setMessageCallback(</span><br><span class="line">        std::bind(&amp;LengthHeaderCodec::onMessage, &amp;codec_, _1, _2, _3));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void setThreadNum(int numThreads)</span><br><span class="line">  &#123;</span><br><span class="line">    server_.setThreadNum(numThreads);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void start()</span><br><span class="line">  &#123;</span><br><span class="line">    server_.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  void onConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_INFO &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;</span><br><span class="line">        &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; is &quot;</span><br><span class="line">        &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);</span><br><span class="line"></span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    if (!connections_.unique())//说明引用计数大于1</span><br><span class="line">    &#123;</span><br><span class="line">      //reset()函数的作用是用新的对象替换原来的对象，并更新智能指针的引用计数</span><br><span class="line">      //使用一个新的ConnectionList对象的副本替换原来的连接列表对象，并更新智能指针connections_的引用计数为1</span><br><span class="line">      connections_.reset(new ConnectionList(*connections_));</span><br><span class="line">    &#125;</span><br><span class="line">    assert(connections_.unique());</span><br><span class="line">    //在复本上修改，不会影响读者，所以读者在遍历列表的时候，不需要用mutex保护</span><br><span class="line">    if (conn-&gt;connected())</span><br><span class="line">    &#123;</span><br><span class="line">      connections_-&gt;insert(conn);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      connections_-&gt;erase(conn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  typedef std::set&lt;TcpConnectionPtr&gt; ConnectionList;</span><br><span class="line">  typedef std::shared_ptr&lt;ConnectionList&gt; ConnectionListPtr;</span><br><span class="line"></span><br><span class="line">  void onStringMessage(const TcpConnectionPtr&amp;,</span><br><span class="line">                       const string&amp; message,</span><br><span class="line">                       Timestamp)</span><br><span class="line">  &#123;</span><br><span class="line">    //引用计数加1，mutex保护的临界区大大缩短</span><br><span class="line">    //锁竞争大大减小，提高了并发</span><br><span class="line">    ConnectionListPtr connections = getConnectionList();</span><br><span class="line">    for (ConnectionList::iterator it = connections-&gt;begin();</span><br><span class="line">        it != connections-&gt;end();</span><br><span class="line">        ++it)</span><br><span class="line">    &#123;</span><br><span class="line">      //读端指的是在onStringMessage函数中遍历connections_集合中的每个连接，将消息发送给对应的连接</span><br><span class="line">      //写端指的是在不同的地方通过codec_.send函数向连接写入消息</span><br><span class="line">      codec_.send(get_pointer(*it), message);</span><br><span class="line">    &#125;</span><br><span class="line">    //这个断言不一定成立</span><br><span class="line">    //assert(!connections_.unique());</span><br><span class="line">    //当connections这个栈上的变量销毁的时候，引用计数减1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ConnectionListPtr getConnectionList()</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    return connections_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  TcpServer server_;</span><br><span class="line">  LengthHeaderCodec codec_;</span><br><span class="line">  MutexLock mutex_;</span><br><span class="line">  ConnectionListPtr connections_ GUARDED_BY(mutex_);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;pid = &quot; &lt;&lt; getpid();</span><br><span class="line">  if (argc &gt; 1)</span><br><span class="line">  &#123;</span><br><span class="line">    EventLoop loop;</span><br><span class="line">    uint16_t port = static_cast&lt;uint16_t&gt;(atoi(argv[1]));</span><br><span class="line">    InetAddress serverAddr(port);</span><br><span class="line">    ChatServer server(&amp;loop, serverAddr);</span><br><span class="line">    if (argc &gt; 2)</span><br><span class="line">    &#123;</span><br><span class="line">      server.setThreadNum(atoi(argv[2]));</span><br><span class="line">    &#125;</span><br><span class="line">    server.start();</span><br><span class="line">    loop.loop();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Usage: %s port [thread_num]\n&quot;, argv[0]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于读端（即在<code>onStringMessage</code>函数中遍历连接并发送消息），在读之前会先将引用计数加1，表示有其他线程正在访问这个对象。这样做的目的是为了在读取期间阻止其他线程对该对象进行并发写操作，保证数据的一致性和安全性。</p>
<p>而对于写端（即修改对象），只有在发现引用计数为1时，才可以安全地修改该对象。如果引用计数为1，意味着当前线程是唯一一个访问该对象的，不存在其他并发的读操作，因此可以安全地对对象进行修改，不需要担心其他线程正在读取它。</p>
<p>通过对引用计数的控制和判断，可以实现对读写操作的同步和互斥，确保在读操作期间不会发生并发写操作，避免了数据的竞争和冲突。这种方式可以提高并发性能，并保证数据的正确性。</p>
<p>在发现引用计数大于1时：</p>
<ol>
<li>使用<code>MutexLockGuard</code>对临界区进行加锁，以确保并发访问的安全性。</li>
<li>检查<code>connections_</code>的引用计数是否大于1，即通过<code>!connections_.unique()</code>判断。</li>
<li>如果引用计数大于1，说明有其他线程正在读取数据，此时需要创建一个副本，并在副本上进行修改。</li>
<li>使用<code>connections_.reset(new ConnectionList(*connections_))</code>将原始的连接列表对象替换为副本，同时更新智能指针<code>connections_</code>的引用计数为1。</li>
<li>在副本上进行修改操作，确保不会影响到正在读取数据的其他线程。</li>
<li>修改完成后，在<code>onConnection</code>函数中，根据连接的状态（连接建立或断开），更新副本并触发其他操作。</li>
</ol>
<p>这样做可以避免在读取期间对原始对象进行修改，确保数据的一致性和安全性，同时减小了锁的粒度，提高了并发性能。</p>
<p>通过<code>connections_.reset(new ConnectionList(*connections_))</code>操作，实际上是将原始的连接列表对象进行了一次拷贝，并用拷贝后的对象替换了原始对象。这样做的目的是在修改连接列表时操作副本，而保持原始对象不变，以防止其他线程正在读取该对象时的并发冲突。</p>
<h2 id="server-threaded-highperformance-cc"><a href="#server-threaded-highperformance-cc" class="headerlink" title="server_threaded_highperformance.cc"></a>server_threaded_highperformance.cc</h2><p>采用thread local变量实现多线程高效转发</p>
<p>调用 <code>LocalConnections::instance()</code> 函数获取当前线程的线程局部单例对象时，并没有特定的接收者。这个调用的目的是为了在当前线程中创建和获取一个独立的连接列表对象。</p>
<p>线程局部单例模式允许每个线程都有自己独立的实例，这个实例可以在当前线程的任何地方使用，而不需要传递给其他对象或函数。因此，<code>LocalConnections::instance()</code> 的返回值可以直接在当前线程的代码中使用并进行操作，而不需要显式地给一个特定的接收者。</p>
<p>在使用线程局部单例对象时，它的实例可以在当前线程的任何地方使用，主要通过以下两种方式来体现：</p>
<ol>
<li>在当前线程的任意位置直接调用静态成员函数或成员方法：由于线程局部单例对象是针对每个线程独立存在的，因此在当前线程的任意位置都可以直接调用该线程局部单例对象的静态成员函数或成员方法，而无需传递对象的引用或指针。</li>
<li>通过操纵符号 <code>::</code> 访问静态成员：如果线程局部单例对象的静态成员是公有的，可以使用 <code>::</code> 操纵符号直接访问静态成员。这样，在当前线程的任何位置都可以通过线程局部单例类名称和静态成员名称来访问对应的静态成员函数或变量。</li>
</ol>
<p>这种设计模式的好处是，每个线程都有自己独立的实例，不需要显式地传递对象引用或指针给其他对象或函数。这样可以避免多线程环境下的同步和互斥问题，以及减少参数传递的复杂性。线程局部单例对象在当前线程的任何地方都可以使用，并提供了一种方便的方式来共享和访问线程相关的资源或状态。</p>
<p>如果线程局部单例对象的静态成员和静态成员函数是私有的，则无法直接使用 <code>::</code> 操纵符号来访问这些私有成员。<code>::</code> 操纵符号只能用于访问公有的静态成员。</p>
<p>对于私有的静态成员和静态成员函数，只能在线程局部单例类的内部或友元类中进行访问。如果需要在当前线程的任何地方使用这些私有成员，可以考虑提供公有的接口函数或方法来间接访问这些成员，这样其他代码就可以通过调用接口来间接操作线程局部单例对象中的私有静态成员</p>
<p>代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;examples/asio/chat/codec.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line">#include &quot;muduo/base/Mutex.h&quot;</span><br><span class="line">#include &quot;muduo/base/ThreadLocalSingleton.h&quot;</span><br><span class="line">#include &quot;muduo/net/EventLoop.h&quot;</span><br><span class="line">#include &quot;muduo/net/TcpServer.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">class ChatServer : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  ChatServer(EventLoop* loop,</span><br><span class="line">             const InetAddress&amp; listenAddr)</span><br><span class="line">  : server_(loop, listenAddr, &quot;ChatServer&quot;),</span><br><span class="line">    codec_(std::bind(&amp;ChatServer::onStringMessage, this, _1, _2, _3))</span><br><span class="line">  &#123;</span><br><span class="line">    server_.setConnectionCallback(</span><br><span class="line">        std::bind(&amp;ChatServer::onConnection, this, _1));</span><br><span class="line">    server_.setMessageCallback(</span><br><span class="line">        std::bind(&amp;LengthHeaderCodec::onMessage, &amp;codec_, _1, _2, _3));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void setThreadNum(int numThreads)</span><br><span class="line">  &#123;</span><br><span class="line">    server_.setThreadNum(numThreads);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void start()</span><br><span class="line">  &#123;</span><br><span class="line">    server_.setThreadInitCallback(std::bind(&amp;ChatServer::threadInit, this, _1));</span><br><span class="line">    server_.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  void onConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_INFO &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;</span><br><span class="line">             &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; is &quot;</span><br><span class="line">             &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);</span><br><span class="line">    //由于每一个线程都有一个LocalConnections实例，所以不需要锁</span><br><span class="line">    if (conn-&gt;connected())</span><br><span class="line">    &#123;</span><br><span class="line">      LocalConnections::instance().insert(conn);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      LocalConnections::instance().erase(conn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void onStringMessage(const TcpConnectionPtr&amp;,</span><br><span class="line">                       const string&amp; message,</span><br><span class="line">                       Timestamp)</span><br><span class="line">  &#123;</span><br><span class="line">    EventLoop::Functor f = std::bind(&amp;ChatServer::distributeMessage, this, message);</span><br><span class="line">    LOG_DEBUG;</span><br><span class="line"></span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    //转发消息给所有客户端，高效转发(多线程来转发)</span><br><span class="line">    for (std::set&lt;EventLoop*&gt;::iterator it = loops_.begin();</span><br><span class="line">        it != loops_.end();</span><br><span class="line">        ++it)</span><br><span class="line">    &#123;</span><br><span class="line">      //让对应的IO线程来执行distributeMessage</span><br><span class="line">      //distributeMessage放到IO线程队列中执行，因此，这里的mutex_锁竞争大大减小</span><br><span class="line">      //distributeMessage不受mutex_保护</span><br><span class="line">      (*it)-&gt;queueInLoop(f);</span><br><span class="line">    &#125;</span><br><span class="line">    LOG_DEBUG;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  typedef std::set&lt;TcpConnectionPtr&gt; ConnectionList;</span><br><span class="line"></span><br><span class="line">  void distributeMessage(const string&amp; message)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_DEBUG &lt;&lt; &quot;begin&quot;;</span><br><span class="line">    //connections_是thread local变量，所以不需要保护</span><br><span class="line">    for (ConnectionList::iterator it = LocalConnections::instance().begin();</span><br><span class="line">        it != LocalConnections::instance().end();</span><br><span class="line">        ++it)</span><br><span class="line">    &#123;</span><br><span class="line">      codec_.send(get_pointer(*it), message);</span><br><span class="line">    &#125;</span><br><span class="line">    LOG_DEBUG &lt;&lt; &quot;end&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void threadInit(EventLoop* loop)</span><br><span class="line">  &#123;</span><br><span class="line">    assert(LocalConnections::pointer() == NULL);</span><br><span class="line">    //线程局部单例模式允许每个线程都有自己独立的实例，这个实例可以在当前线程的任何地方使用，而不需要传递给其他对象或函数</span><br><span class="line">    LocalConnections::instance();</span><br><span class="line">    assert(LocalConnections::pointer() != NULL);</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    loops_.insert(loop);//将IO线程所对应的EventLoop插入进去</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  TcpServer server_;</span><br><span class="line">  LengthHeaderCodec codec_;</span><br><span class="line">  //线程局部单例变量，每个线程都有一个connections_实例</span><br><span class="line">  typedef ThreadLocalSingleton&lt;ConnectionList&gt; LocalConnections;</span><br><span class="line"></span><br><span class="line">  MutexLock mutex_;</span><br><span class="line">  std::set&lt;EventLoop*&gt; loops_ GUARDED_BY(mutex_);//EventLoop列表</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;pid = &quot; &lt;&lt; getpid();</span><br><span class="line">  if (argc &gt; 1)</span><br><span class="line">  &#123;</span><br><span class="line">    EventLoop loop;</span><br><span class="line">    uint16_t port = static_cast&lt;uint16_t&gt;(atoi(argv[1]));</span><br><span class="line">    InetAddress serverAddr(port);</span><br><span class="line">    ChatServer server(&amp;loop, serverAddr);</span><br><span class="line">    if (argc &gt; 2)</span><br><span class="line">    &#123;</span><br><span class="line">      server.setThreadNum(atoi(argv[2]));</span><br><span class="line">    &#125;</span><br><span class="line">    server.start();</span><br><span class="line">    loop.loop();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Usage: %s port [thread_num]\n&quot;, argv[0]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/24/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/24/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-2/" class="post-title-link" itemprop="url">muduo库使用示例_2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-24 10:32:34 / 修改时间：15:10:29" itemprop="dateCreated datePublished" datetime="2023-08-24T10:32:34+08:00">2023-08-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h1><h2 id="download-cc"><a href="#download-cc" class="headerlink" title="download.cc"></a>download.cc</h2><p>一次性把文件读入内存，一次性调用send(const string&amp;)发送完毕，这个版本满足<strong>除了</strong>“内存消耗只能并发连接数有关，跟文件大小无关”之外的健壮性要求。也就是说跟文件大小有关。</p>
<p>send函数是非阻塞的，立刻返回。不用担心数据什么时候给对等端。这个由网络库muduo负责到底。</p>
<p>fileContent比较大的时候，是没有办法一次性将数据拷到内核缓冲区的,这时候，会将剩余的数据拷贝到应用层的OutputBuffer中。<br>当内核缓冲区中的数据发送出去之后，可写事件产生，muduo就会从OutputBuffer中取出数据发送。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conn-&gt;send(fileContent);</span><br><span class="line">conn-&gt;shutdown();</span><br></pre></td></tr></table></figure>

<p>没有问题<br>shutdown，内部的实现仅仅只是关闭写入这一半。<br>shutdown -&gt;shutdownInLoop();<br>当前不处于发送数据的状态，才会调用socket_-&gt;shutdownwrite() ;</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line">#include &quot;muduo/net/EventLoop.h&quot;</span><br><span class="line">#include &quot;muduo/net/TcpServer.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">const char* g_file = NULL;</span><br><span class="line"></span><br><span class="line">// FIXME: use FileUtil::readFile()</span><br><span class="line">string readFile(const char* filename)</span><br><span class="line">&#123;</span><br><span class="line">  string content;</span><br><span class="line">  FILE* fp = ::fopen(filename, &quot;rb&quot;);</span><br><span class="line">  if (fp)</span><br><span class="line">  &#123;</span><br><span class="line">    // inefficient!!!</span><br><span class="line">    const int kBufSize = 1024*1024;</span><br><span class="line">    char iobuf[kBufSize];</span><br><span class="line">    ::setbuffer(fp, iobuf, sizeof iobuf);//用于将文件fp与名为iobuf的缓冲区相关联，并指定缓冲区的大小为kBufSize字节。</span><br><span class="line">    //通过关联缓冲区，文件读取和写入操作将会先将数据读取到缓冲区中或者从缓冲区中写出数据，而不是直接与磁盘进行交互。这样可以减少频繁的磁盘访问带来的性能损耗，提高读写效率</span><br><span class="line">    char buf[kBufSize];</span><br><span class="line">    size_t nread = 0;</span><br><span class="line">    while ( (nread = ::fread(buf, 1, sizeof buf, fp)) &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      content.append(buf, nread);</span><br><span class="line">    &#125;</span><br><span class="line">    ::fclose(fp);</span><br><span class="line">  &#125;</span><br><span class="line">  return content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void onHighWaterMark(const TcpConnectionPtr&amp; conn, size_t len)</span><br><span class="line">&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;HighWaterMark &quot; &lt;&lt; len;//打印输出当前应用缓冲区的大小是多大</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void onConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;FileServer - &quot; &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;</span><br><span class="line">           &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; is &quot;</span><br><span class="line">           &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);</span><br><span class="line">  if (conn-&gt;connected())</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_INFO &lt;&lt; &quot;FileServer - Sending file &quot; &lt;&lt; g_file</span><br><span class="line">             &lt;&lt; &quot; to &quot; &lt;&lt; conn-&gt;peerAddress().toIpPort();</span><br><span class="line">    //当应用缓冲区的outputbuffer，发送缓冲区超过了64K就回调onHighWaterMark</span><br><span class="line">    conn-&gt;setHighWaterMarkCallback(onHighWaterMark, 64*1024);</span><br><span class="line">    string fileContent = readFile(g_file);</span><br><span class="line">    conn-&gt;send(fileContent);</span><br><span class="line">    conn-&gt;shutdown();</span><br><span class="line">    LOG_INFO &lt;&lt; &quot;FileServer - done&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;pid = &quot; &lt;&lt; getpid();</span><br><span class="line">  if (argc &gt; 1)</span><br><span class="line">  &#123;</span><br><span class="line">    g_file = argv[1];//要下载的文件名称</span><br><span class="line"></span><br><span class="line">    EventLoop loop;</span><br><span class="line">    InetAddress listenAddr(2021);</span><br><span class="line">    TcpServer server(&amp;loop, listenAddr, &quot;FileServer&quot;);</span><br><span class="line">    server.setConnectionCallback(onConnection);</span><br><span class="line">    server.start();</span><br><span class="line">    loop.loop();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    fprintf(stderr, &quot;Usage: %s file_for_downloading\n&quot;, argv[0]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="download2-cc"><a href="#download2-cc" class="headerlink" title="download2.cc"></a>download2.cc</h2><p>一块一块地发送文件，减少内存使用，用到了WriteCompleteCallback，这个版本满足了上述全部健壮性要求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line">#include &quot;muduo/net/EventLoop.h&quot;</span><br><span class="line">#include &quot;muduo/net/TcpServer.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">void onHighWaterMark(const TcpConnectionPtr&amp; conn, size_t len)</span><br><span class="line">&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;HighWaterMark &quot; &lt;&lt; len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const int kBufSize = 64*1024;</span><br><span class="line">const char* g_file = NULL;</span><br><span class="line"></span><br><span class="line">void onConnection(const TcpConnectionPtr&amp; conn)//连接建立或断开时被自动调用</span><br><span class="line">&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;FileServer - &quot; &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;</span><br><span class="line">           &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; is &quot;</span><br><span class="line">           &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);</span><br><span class="line">  if (conn-&gt;connected())</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_INFO &lt;&lt; &quot;FileServer - Sending file &quot; &lt;&lt; g_file</span><br><span class="line">             &lt;&lt; &quot; to &quot; &lt;&lt; conn-&gt;peerAddress().toIpPort();</span><br><span class="line">    conn-&gt;setHighWaterMarkCallback(onHighWaterMark, kBufSize+1);</span><br><span class="line"></span><br><span class="line">    FILE* fp = ::fopen(g_file, &quot;rb&quot;);</span><br><span class="line">    if (fp)</span><br><span class="line">    &#123;</span><br><span class="line">      //将TcpConnection对象与fp绑定</span><br><span class="line">      //通过这种方法，我们就不需要额外再用一个map容器来管理对应关系.</span><br><span class="line">      conn-&gt;setContext(fp);</span><br><span class="line">      char buf[kBufSize];</span><br><span class="line">      size_t nread = ::fread(buf, 1, sizeof buf, fp);//读取一块64K的内容</span><br><span class="line">      conn-&gt;send(buf, static_cast&lt;int&gt;(nread));</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      conn-&gt;shutdown();</span><br><span class="line">      LOG_INFO &lt;&lt; &quot;FileServer - no such file&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    if (!conn-&gt;getContext().empty())</span><br><span class="line">    &#123;</span><br><span class="line">      FILE* fp = boost::any_cast&lt;FILE*&gt;(conn-&gt;getContext());</span><br><span class="line">      if (fp)</span><br><span class="line">      &#123;</span><br><span class="line">        ::fclose(fp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void onWriteComplete(const TcpConnectionPtr&amp; conn)</span><br><span class="line">&#123;</span><br><span class="line">  FILE* fp = boost::any_cast&lt;FILE*&gt;(conn-&gt;getContext());</span><br><span class="line">  char buf[kBufSize];</span><br><span class="line">  size_t nread = ::fread(buf, 1, sizeof buf, fp);</span><br><span class="line">  if (nread &gt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    conn-&gt;send(buf, static_cast&lt;int&gt;(nread));</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    ::fclose(fp);</span><br><span class="line">    fp = NULL;</span><br><span class="line">    conn-&gt;setContext(fp);</span><br><span class="line">    conn-&gt;shutdown();</span><br><span class="line">    LOG_INFO &lt;&lt; &quot;FileServer - done&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;pid = &quot; &lt;&lt; getpid();</span><br><span class="line">  if (argc &gt; 1)</span><br><span class="line">  &#123;</span><br><span class="line">    g_file = argv[1];</span><br><span class="line"></span><br><span class="line">    EventLoop loop;</span><br><span class="line">    InetAddress listenAddr(2021);</span><br><span class="line">    TcpServer server(&amp;loop, listenAddr, &quot;FileServer&quot;);</span><br><span class="line">    server.setConnectionCallback(onConnection);</span><br><span class="line">    server.setWriteCompleteCallback(onWriteComplete);</span><br><span class="line">    server.start();</span><br><span class="line">    loop.loop();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    fprintf(stderr, &quot;Usage: %s file_for_downloading\n&quot;, argv[0]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="download3-cc"><a href="#download3-cc" class="headerlink" title="download3.cc"></a>download3.cc</h2><p>同2，但是采用shared_ptr来管理FILE*，避免手动调用::fclose(3)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">const int kBufSize = 64*1024;</span><br><span class="line">const char* g_file = NULL;</span><br><span class="line">typedef std::shared_ptr&lt;FILE&gt; FilePtr;</span><br><span class="line"></span><br><span class="line">void onConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;FileServer - &quot; &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;</span><br><span class="line">           &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; is &quot;</span><br><span class="line">           &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);</span><br><span class="line">  if (conn-&gt;connected())</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_INFO &lt;&lt; &quot;FileServer - Sending file &quot; &lt;&lt; g_file</span><br><span class="line">             &lt;&lt; &quot; to &quot; &lt;&lt; conn-&gt;peerAddress().toIpPort();</span><br><span class="line">    conn-&gt;setHighWaterMarkCallback(onHighWaterMark, kBufSize+1);</span><br><span class="line"></span><br><span class="line">    FILE* fp = ::fopen(g_file, &quot;rb&quot;);</span><br><span class="line">    if (fp)</span><br><span class="line">    &#123;</span><br><span class="line">      FilePtr ctx(fp, ::fclose);//表示ctx引用计数减为0时候，要销毁fp是通过fclose()来销毁的.</span><br><span class="line">      conn-&gt;setContext(ctx);//那么生存期是一致的</span><br><span class="line">      char buf[kBufSize];</span><br><span class="line">      size_t nread = ::fread(buf, 1, sizeof buf, fp);</span><br><span class="line">      conn-&gt;send(buf, static_cast&lt;int&gt;(nread));</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      conn-&gt;shutdown();</span><br><span class="line">      LOG_INFO &lt;&lt; &quot;FileServer - no such file&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void onWriteComplete(const TcpConnectionPtr&amp; conn)</span><br><span class="line">&#123;</span><br><span class="line">  const FilePtr&amp; fp = boost::any_cast&lt;const FilePtr&amp;&gt;(conn-&gt;getContext());</span><br><span class="line">  char buf[kBufSize];</span><br><span class="line">  //get_pointer 是一个函数模板，它用于返回指向智能指针内部所管理对象的原始指针。</span><br><span class="line">  //在这里，get_pointer 函数被用来获取 FilePtr 智能指针对象 fp 内部所管理的原始 FILE* 指针</span><br><span class="line">  //这样就可以将 buf 作为参数传递给 ::fread 函数进行文件读取操作</span><br><span class="line">  size_t nread = ::fread(buf, 1, sizeof buf, get_pointer(fp));</span><br><span class="line">  if (nread &gt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    conn-&gt;send(buf, static_cast&lt;int&gt;(nread));</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    conn-&gt;shutdown();</span><br><span class="line">    LOG_INFO &lt;&lt; &quot;FileServer - done&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里销毁fp是通过销毁TcpConnection对象，这样引用计数才会减为0</p>
<h2 id="tests-x2F-Filetransfer-test-cc"><a href="#tests-x2F-Filetransfer-test-cc" class="headerlink" title="tests&#x2F;Filetransfer_test.cc"></a>tests&#x2F;Filetransfer_test.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">AtomicInt32 g_disaliveConnections;//原子操作</span><br><span class="line">int g_connections =8;//发起了8个连接</span><br><span class="line">EventLoop* g_loop;//全局变量</span><br><span class="line">class RecvFileClient : boost::noncopyable&#123;</span><br><span class="line">public:</span><br><span class="line">	RecvFileClient(EventLoop* loop, const InetAddress&amp; serverAddr, const string&amp; id)</span><br><span class="line">		:loop_(loop) ,</span><br><span class="line">		client_(loop, serverAddr,&quot;RecvFileClient&quot;)</span><br><span class="line">	&#123;</span><br><span class="line">		client_.setConnectionCallback(</span><br><span class="line">			boost::bind(&amp;RecvFileClient::onConnection,this，_1));</span><br><span class="line">		client_ .setMessageCallback(</span><br><span class="line">			boost::bind(RecvFileClient::onMessage,this,_1._2,_3));</span><br><span class="line">		string filename= &quot;RecvFileClient&quot;+id;</span><br><span class="line">		fp_=::fopen(filename.c_str(),&quot;we&quot;);</span><br><span class="line">		//&quot;we&quot; 指定了以写入模式打开一个新的空文本文件，并允许对文件进行读取和写入操作。如果文件已经存在，则会清空文件内容</span><br><span class="line">		assert(fp_);</span><br><span class="line">	&#125;</span><br><span class="line">	~RecvFileClient()</span><br><span class="line">	&#123;</span><br><span class="line">		::fclose(fp_);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	void connect()</span><br><span class="line">	&#123;</span><br><span class="line">		client_.connect();</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">void onConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_TRACE &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;</span><br><span class="line">        &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; is &quot;</span><br><span class="line">        &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);</span><br><span class="line">    if(conn-&gt;connected())&#123;</span><br><span class="line">    	connection_=conn;</span><br><span class="line">    	if(g_aliveConnections.incrementAndGet()== g_connections)</span><br><span class="line">    		LOG_INFO&lt;&lt;&quot;all connected&quot;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">    	connection_.reset();</span><br><span class="line">		if ((g_aliveConnections.incrementAndGet()==g_connections)</span><br><span class="line">		&#123;</span><br><span class="line">			LOG INFO &lt;&lt;&quot;all disconnected&quot;;</span><br><span class="line">			//g_loop-&gt;quit();有线程安全问题，可能loop循环退出了，但另外两个loopPool.setThreadNum(2);还没退出</span><br><span class="line">			exit(0);//整个进程结束</span><br><span class="line">		&#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void onMessage(const TcpConnectionPtr&amp; conn, Buffer* buf, Timestamp)</span><br><span class="line">  &#123;</span><br><span class="line">    fwrite(buf-&gt;peek(),1,buf-&gt;readableBytes(),fP_);//消息到达时，写入这个文件当中</span><br><span class="line">    buf-&gt;retrieveAll();</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">EventLoop* loop_;</span><br><span class="line">Tcpclient client_;</span><br><span class="line">TcpConnectionPtr connection_;</span><br><span class="line">FILE* fp_;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc,char* argv[])&#123;</span><br><span class="line">	LOG_INFO &lt;&lt; &quot;pid = &quot; &lt;&lt; getpid();</span><br><span class="line">	EventLoop loop;</span><br><span class="line">	g_loop =&amp;loop;</span><br><span class="line">	//用两个I0线程来发起大量的连接</span><br><span class="line">	EventLoopThreadPool loopPool(&amp;loop);</span><br><span class="line">	loopPool.setThreadNum(2);</span><br><span class="line">	loopPool.start();</span><br><span class="line">	boost::ptr_vector&lt;RecvFileClient&gt; clients(g_connections);</span><br><span class="line">	InetAddress serverAddr(&quot;127.0.0.1&quot;，2021);</span><br><span class="line">	for(int i =0; i &lt; g_connections;++i)&#123;</span><br><span class="line">		char buf[32];</span><br><span class="line">		snprintf( buf, sizeof buf,%d&quot;,i+1);</span><br><span class="line">		//选择了一个EventLoopThreadPool对象也就是IO线程来处理客户端相关业务</span><br><span class="line">		clients.push_back(new RecvFileClient(loopPool.getNextLoop(),serverAddr,buf));</span><br><span class="line">		clients[i].connect();</span><br><span class="line">		usleep(200);</span><br><span class="line">	&#125;</span><br><span class="line">	loop.loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个线程发起8个连接，有了8个文件</p>
<p>可以用来进行压力测试</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">肖汇林</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">82</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">肖汇林</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
