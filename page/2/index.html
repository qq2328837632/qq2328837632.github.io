<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="选择有时候比努力更重要">
<meta property="og:type" content="website">
<meta property="og:title" content="肖汇林的博客">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="肖汇林的博客">
<meta property="og:description" content="选择有时候比努力更重要">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="肖汇林">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>肖汇林的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖汇林的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/27/muduo-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/27/muduo-1/" class="post-title-link" itemprop="url">muduo-1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-27 16:19:27" itemprop="dateCreated datePublished" datetime="2023-07-27T16:19:27+08:00">2023-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-08 15:15:42" itemprop="dateModified" datetime="2023-08-08T15:15:42+08:00">2023-08-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="高并发高性能服务器的一些思路"><a href="#高并发高性能服务器的一些思路" class="headerlink" title="高并发高性能服务器的一些思路"></a>高并发高性能服务器的一些思路</h1><p>队列+连接池<br>主要的业务逻辑挪到应用服务器处理，数据库只做辅助的业务处理</p>
<p>缓存<br>缓存更新(缓存同步)缓存time out<br>如果缓存失效重新去数据库查询，实时性比较差<br>一但数据库中数据更新，立即通知前端的缓存更新，实时性比较高。<br>缓存换页内存不够，将不活跃的数据换出内存。一些算法FIFO LRU(least recently used)(最近最少使用)LFU(least frequently used）最不频繁使用</p>
<p>nosql(反sql) key &#x2F; value非关系型数据库<br>分布式缓存<br>redis<br>mencached</p>
<p>数据库读写分离，可以避免锁竞争，提高访问速度</p>
<p>主从服务器</p>
<p>数据库的读操作&gt;写操作<br>对数据库进行负载均衡 replication机制，即写会同步更新到读库<br>比如数据分区(分库、分表)<br>分库 垂直分区     水平分区，更好用，每个类型的数据都有，更好扩展，需要增加一个数据访问层DAL</p>
<p>应用服务器的负载均衡<br>增加一个任务服务器来实现，任务服务器可以监视应用服务器的负载，CPU高、I0高、并发高、内存换页高查询到这些信息之后，选取负载最低的服务器分配任务。应用服务器被动接收任务，不公平，任务处理速度不同。</p>
<p>应用服务器主动到任务服务器接收任务进行处理，即空闲主动。</p>
<p><img src="/muduo-1/image-20230727162947044.png" alt="image-20230727162947044"></p>
<img src="/2023/07/27/muduo-1/image-20230727162947044.png" class title="This is an test image">

<p>服务器性能四大杀手</p>
<ul>
<li>数据拷贝		缓存</li>
<li>环境切换	（理性创建线程)该不该用多线程，单线程好还是多线程好，单核服务器（采用状态机编程，效率最佳，不能并行处理任务，相当于操作系统的进程切换，cpu时间分享给多个进程)，多线程能够充分发挥多核服务器的性能，大量的任务提交到服务器时多线程也不能保证并发，这时候线程间的切换开销大</li>
<li>内存分配		内存池</li>
<li>锁竞争</li>
</ul>
<h1 id="大型网站架构演变过程"><a href="#大型网站架构演变过程" class="headerlink" title="大型网站架构演变过程"></a>大型网站架构演变过程</h1><h2 id="第一步-web-server与数据库分离"><a href="#第一步-web-server与数据库分离" class="headerlink" title="第一步 web server与数据库分离"></a>第一步 web server与数据库分离</h2><p><img src="/muduo-1/image-20230727202043348.png" alt="image-20230727202043348"></p>
<img src="/2023/07/27/muduo-1/image-20230727202043348.png" class title="This is an test image">

<p><img src="/muduo-1/image-20230727202141040.png" alt="image-20230727202141040"></p>
<img src="/2023/07/27/muduo-1/image-20230727202141040.png" class title="This is an test image">

<h2 id="第二部-缓存处理"><a href="#第二部-缓存处理" class="headerlink" title="第二部 缓存处理"></a>第二部 缓存处理</h2><p><img src="/muduo-1/image-20230727202250355.png" alt="image-20230727202250355"></p>
<img src="/2023/07/27/muduo-1/image-20230727202250355.png" class title="This is an test image">

<p>front page cache静态页面</p>
<h2 id="第三步-web-server集群-读写分离"><a href="#第三步-web-server集群-读写分离" class="headerlink" title="第三步 web server集群+读写分离"></a>第三步 web server集群+读写分离</h2><p><img src="/muduo-1/image-20230727202523487.png" alt="image-20230727202523487"></p>
<img src="/2023/07/27/muduo-1/image-20230727202523487.png" class title="This is an test image">

<h2 id="第四步-CDN、分布式缓存、分库分表"><a href="#第四步-CDN、分布式缓存、分库分表" class="headerlink" title="第四步 CDN、分布式缓存、分库分表"></a>第四步 CDN、分布式缓存、分库分表</h2><p>CDN:内容分发网络</p>
<p>不同地区网络速度都得到提升</p>
<p>目前流行分布式缓存方案:memcached、membase、redis等,基本上当前的NoSQL方案都可以用来做分布式缓存方案</p>
<h2 id="第五步-多数据中心-分布式存储与计算"><a href="#第五步-多数据中心-分布式存储与计算" class="headerlink" title="第五步 多数据中心+分布式存储与计算"></a>第五步 多数据中心+分布式存储与计算</h2><p>对一致性要求不高的没必要保存在关系型数据库</p>
<p><img src="/muduo-1/image-20230727203310555.png" alt="image-20230727203310555"></p>
<img src="/2023/07/27/muduo-1/image-20230727203310555.png" class title="This is an test image">

<p>虽然这个本质是b&#x2F;s架构，但是核心本质还是c&#x2F;s，用到socket</p>
<p><img src="/muduo-1/image-20230727203423819.png" alt="image-20230727203423819"></p>
<img src="/2023/07/27/muduo-1/image-20230727203423819.png" class title="This is an test image">

<h1 id="cmake管理过程"><a href="#cmake管理过程" class="headerlink" title="cmake管理过程"></a>cmake管理过程</h1><p>用 <code>build.sh</code> 脚本来进行 CMake 构建。假设项目结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">muduo_test/</span><br><span class="line">	|-build/</span><br><span class="line">		|-bin</span><br><span class="line">	|- build.sh</span><br><span class="line">    |- CMakeLists.txt</span><br><span class="line">    |- src/</span><br><span class="line">         |- bf_test.cpp</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来，我们将依次执行以下步骤：</p>
<ol>
<li>创建 <code>bf_test.cpp</code> 文件并放入 <code>muduo_test/src/</code> 目录下。</li>
<li>编写 <code>CMakeLists.txt</code> 文件用于构建 <code>bf_test.cpp</code>。</li>
<li>创建 <code>build.sh</code> 脚本用于执行 CMake 构建，并将生成的可执行文件放入 <code>muduo_test/build/bin/</code> 目录下。</li>
</ol>
<p>首先，让我们创建 <code>bf_test.cpp</code> 文件。你可以使用编辑器（如 <code>nano</code>、<code>vim</code> 或其他文本编辑器）创建该文件，并将以下内容复制到 <code>bf_test.cpp</code> 中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// bf_test.cpp</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, muduo_test!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，创建 <code>CMakeLists.txt</code> 文件。在 <code>muduo_test/</code> 目录下创建一个名为 <code>CMakeLists.txt</code> 的文件，并将以下内容复制到其中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.10)  # 指定 CMake 最低版本要求</span><br><span class="line">#project() 命令用于定义一个项目。project() 命令的第一个参数是项目的名称，而第二个参数是可选的，用于指定所用的编程语言。</span><br><span class="line">project(muduo_test CXX)  # 设置项目名称，与你的项目名称相同</span><br><span class="line">set(CXX_FLAGS -g -Wall)# 设置编译选项</span><br><span class="line">set(CMAKE_CXX_COMPILER &quot;g++&quot;)# 设置C++编译器为g++</span><br><span class="line"></span><br><span class="line">set(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/bin)# 设置可执行文件输出路径</span><br><span class="line">add_executable(bf_test src/bf_test.cpp)# 添加可执行文件</span><br></pre></td></tr></table></figure>

<p>接下来，编写 <code>build.sh</code> 脚本。确保将脚本放在 <code>muduo_test/</code> 同级目录下，并给予执行权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">set -x</span><br><span class="line"></span><br><span class="line">SOURCE_DIR=$(pwd)</span><br><span class="line">BUILD_DIR=$&#123;SOURCE_DIR&#125;/build</span><br><span class="line"></span><br><span class="line">mkdir -p $BUILD_DIR \</span><br><span class="line">   &amp;&amp; cd $BUILD_DIR \</span><br><span class="line">   &amp;&amp; cmake $SOURCE_DIR \</span><br><span class="line">   &amp;&amp; make $*</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在我们已经准备好一切。并在终端中给予脚本执行权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x build.sh</span><br></pre></td></tr></table></figure>

<p>最后，运行 <code>./build.sh</code> 脚本来进行 CMake 构建：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build.sh</span><br></pre></td></tr></table></figure>

<p>脚本将在 <code>muduo_test/</code> 目录下创建一个名为 <code>build</code> 的目录，并在其中执行 CMake 和 Makefile 构建。然后，生成的可执行文件 <code>bf_test</code> 将被移动到 <code>muduo_test/build/bin/</code> 目录下。</p>
<p>运行 <code>./build/bin/bf_test</code> 即可看到输出</p>
<p>运行<code>./build.sh clean</code> 相当于<code>make clean</code></p>
<h1 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h1><h2 id="LT"><a href="#LT" class="headerlink" title="LT"></a>LT</h2><p>如果内核缓冲区不够了，将未发完的数据添加到应用缓冲区outbuffer,等到内核有空余时就会有connfd的EPOLLOUT事件，如果内核没有数据可以取，却在关注EPOLLOUT事件，就会出现忙等待。</p>
<p><img src="/muduo-1/image-20230728115359271.png" alt="image-20230728115359271"></p>
<img src="/2023/07/27/muduo-1/image-20230728115359271.png" class title="This is an test image">

<p>后面都采用LT模式</p>
<h2 id="ET"><a href="#ET" class="headerlink" title="ET"></a>ET</h2><p><img src="/muduo-1/image-20230728120915832.png" alt="image-20230728120915832"></p>
<img src="/2023/07/27/muduo-1/image-20230728120915832.png" class title="This is an test image">

<p>因为是电平触发，所有一开始就关注EPOLLOUT事件，EAGAIN如果数据未满，应用缓冲区发送给内核，相当于一直高电平，那么就一直不发送了，填满内核，变为低电平状态，如果被接受，就会变成高电平。</p>
<p>EMFILE状态，如果有connfd，返回失败，一直处于高电平，则后面的都接受不了，所以需要人为控制</p>
<h1 id="面向对象编程风格"><a href="#面向对象编程风格" class="headerlink" title="面向对象编程风格"></a>面向对象编程风格</h1><p>继承实现，将基类虚函数实现放到派生类函数来实现，这样调用基类虚函数，会自动调用派生类函数，比如下面的Run函数</p>
<p>Thread.h</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Thread&#123;</span><br><span class="line">public:</span><br><span class="line">	Thread():autoDelete_(false);</span><br><span class="line">	virtual ~Thread()=default;//因为多态的性质决定,是一个虚析构函数</span><br><span class="line">	void Start();</span><br><span class="line">	void Join();</span><br><span class="line">	void SetAutoDelate(bool autoDelete);</span><br><span class="line">	</span><br><span class="line">private:</span><br><span class="line">	static void* ThreadRoutine(void* arg);</span><br><span class="line">	virtual void Run()=0;	</span><br><span class="line">	pthread_t id_;</span><br><span class="line">	bool autoDelete_;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Thread.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Thread::Thread()&#123;</span><br><span class="line">	cout&lt;&lt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Thread::Start()&#123;</span><br><span class="line">	pthread_creat(&amp;id,NULL,ThreadRoutine,this);//this 指向正在创建的 Thread_test 对象。这样，在启动线程时，会在新线程中调用 Thread_test 对象的 Run() 函数</span><br><span class="line">&#125;</span><br><span class="line">void Thread::Join()&#123;</span><br><span class="line">	p_join(id,NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void*  Thread::ThreadRoutine(void* arg)&#123;//静态函数不能调用非静态函数，所以重新th,调用th的Run函数</span><br><span class="line">	thread* th=static_cast&lt;Thread*&gt;(arg);</span><br><span class="line">	th-&gt;Run;</span><br><span class="line">	if(th-&gt;autoDelete_)</span><br><span class="line">		delete th;</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Thread::SetAutoDelate(bool autoDelete)&#123;</span><br><span class="line">	autoDelete_=autoDelete;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Thread_test.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Thread_test: public Thread&#123;</span><br><span class="line">public:</span><br><span class="line">	thread(count):count_(count)&#123;</span><br><span class="line">		cout&lt;&lt;</span><br><span class="line">	&#125;</span><br><span class="line">		~thread()&#123;//派生类如果没有显式地定义析构函数，派生类会继承基类的虚析构函数</span><br><span class="line">		//通过继承基类的虚析构函数，派生类可以保证在销毁对象时正确调用基类和派生类的析构函数，实现正确的资源清理</span><br><span class="line">		cout</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	private:</span><br><span class="line">	void Run()&#123;//私有纯虚函数不能直接在派生类中调用，但是可以通过在派生类中重新声明并实现这些函数，并间接地通过公有函数或其他函数来调用。这样，派生类就能够满足基类的接口要求。</span><br><span class="line">	//派生类必须重新实现基类的纯虚函数，但是在基类中调用纯虚函数时，实际上会调用派生类的实现</span><br><span class="line">		while (count_--)&#123;</span><br><span class="line">			cout&lt;&lt;&quot;&quot;this is a test -..&quot;&lt;&lt;endl;</span><br><span class="line">			sleep(1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int count_ ;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	Thread_test t2 = new Thread_test(5);</span><br><span class="line">	t2-&gt;SetAutoDelate(true);</span><br><span class="line">	t2-&gt;Start();</span><br><span class="line">	t2-&gt;Join();</span><br><span class="line">	for (; ; )</span><br><span class="line">		pause();</span><br><span class="line">	return 8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果基类的run函数变为public，在main函数调用t2-&gt;Run(),则表示在主线程运行。</p>
<h1 id="基于对象编程风格"><a href="#基于对象编程风格" class="headerlink" title="基于对象编程风格"></a>基于对象编程风格</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;boost/function.hpp&gt;</span><br><span class="line">#include &lt;boost/bind.hpp&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Foo</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	void memberFunc(double d, int i, int j)&#123;</span><br><span class="line">		cout &lt;&lt;d&lt;&lt;endl;//打印0.5</span><br><span class="line">		cout &lt;&lt;i &lt;&lt;endl;//打印100</span><br><span class="line">		cout &lt;&lt;j &lt;&lt;endl;//打印10</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">	Foo foo;</span><br><span class="line">	boost::function&lt;void (int)&gt; fp = boost::bind(&amp;Foo::memberFunc,&amp;foo,0.5,_1,10);</span><br><span class="line">	//将Foo的memberFunc(double d, int i, int j)类的成员函数适配成void fp(int)，_1或_加数字表示占位，&amp;不能省略</span><br><span class="line">	fp(100);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>boost bind&#x2F;function库的出现，替代了stl中的mem fun,ptr fun,bind1 st,bin2nd等函数,相当于函数适配器</p>
<p>在 C++ 中，成员函数指针和普通函数指针有一些区别。在使用 <code>boost::bind</code> 绑定成员函数时，需要显式地使用 <code>&amp;</code> 来获得成员函数的地址，而普通函数则不需要。</p>
<p>这是因为在 C++ 中，成员函数有一个隐藏的额外参数，即指向调用成员函数的对象的指针（即 <code>this</code> 指针）。当你使用 <code>&amp;Foo::memberFunc</code> 时，它实际上获取了成员函数 <code>memberFunc</code> 的地址，包括了这个隐藏的 <code>this</code> 指针。所以，通过 <code>&amp;Foo::memberFunc</code> 可以正确地获得成员函数的指针。</p>
<p>然而，对于普通函数，不涉及到隐藏的 <code>this</code> 指针，因此在使用 <code>boost::bind</code> 绑定普通函数时，不需要显式使用 <code>&amp;</code> 来获取函数的地址。</p>
<p>综上所述：</p>
<ul>
<li>对于成员函数，使用 <code>&amp;</code> 是必需的，以获得成员函数的指针，包括隐藏的 <code>this</code> 指针。</li>
<li>对于普通函数，不需要使用 <code>&amp;</code>，因为它们没有隐藏的 <code>this</code> 指针。</li>
</ul>
<p>注意：在 C++11 及以后的标准中，可以使用更现代的方式来绑定函数和成员函数，例如使用 lambda 表达式或 <code>std::bind</code>。这些方法在使用语法上更加简洁和直观。</p>
<p>Thread.h</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Thread&#123;</span><br><span class="line">public:</span><br><span class="line">	typedef boost::function&lt;void ()&gt; ThreadFunc;</span><br><span class="line">	explicit Thread(const ThreadFunc&amp; func);	</span><br><span class="line">	void Start();</span><br><span class="line">	void Join();</span><br><span class="line">	void SetAutoDelate(bool autoDelete);</span><br><span class="line">	</span><br><span class="line">private:</span><br><span class="line">	static void* ThreadRoutine(void* arg);</span><br><span class="line">	void Run();</span><br><span class="line">    ThreadFunc func_;</span><br><span class="line">	pthread_t id_;</span><br><span class="line">	bool autoDelete_;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Thread.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Thread::Thread(const ThreadFunc&amp; func):func_(func),autoDelete_(false)&#123;</span><br><span class="line">	cout&lt;&lt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Thread::Start()&#123;</span><br><span class="line">	pthread_creat(&amp;id,NULL,ThreadRoutine,this);</span><br><span class="line">&#125;</span><br><span class="line">void Thread::Join()&#123;</span><br><span class="line">	p_join(id,NULL);</span><br><span class="line">&#125;</span><br><span class="line">void*  Thread::ThreadRoutine(void* arg)&#123;</span><br><span class="line">	thread* th=static_cast&lt;Thread*&gt;(arg);</span><br><span class="line">	th-&gt;Run;</span><br><span class="line">	if(th-&gt;autoDelete_)</span><br><span class="line">		delete th;</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Thread::Run()&#123;</span><br><span class="line">		func_();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Thread::SetAutoDelate(bool autoDelete)&#123;</span><br><span class="line">	autoDelete_=autoDelete;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Thread_test.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void func(int count)&#123;</span><br><span class="line">	while(--count)&#123;</span><br><span class="line">	cout&lt;&lt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br><span class="line">	</span><br><span class="line">int main()&#123;</span><br><span class="line">	Thread t2(boost::bind(func,3));//利用bind适配，</span><br><span class="line">	t2-&gt;SetAutoDelate(true);</span><br><span class="line">	t2-&gt;Start();</span><br><span class="line">	t2-&gt;Join();</span><br><span class="line">	</span><br><span class="line">	return 8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在C++中，<code>explicit</code>是一个关键字，通常用于修饰单参数的构造函数，用于防止隐式类型转换。当一个构造函数被标记为<code>explicit</code>时，在使用该构造函数进行对象初始化时，编译器不会自动执行隐式的类型转换。</p>
<p>考虑以下示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">public:</span><br><span class="line">    explicit MyClass(int x) &#123;</span><br><span class="line">        // Constructor code</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    MyClass obj1(10);  // 正确，直接调用构造函数</span><br><span class="line">    MyClass obj2 = 20; // 错误，因为构造函数被声明为explicit，禁止隐式类型转换</span><br><span class="line">    //MyClass obj2 = 20;语句试图将一个int类型的整数值20隐式转换为MyClass类型的对象。然而，由于MyClass的构造函数被声明为explicit，编译器不会自动执行这种类型转换</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>MyClass</code>拥有一个带有<code>int</code>参数的构造函数，并且该构造函数被标记为<code>explicit</code>。在<code>main()</code>函数中，创建<code>obj1</code>对象时直接调用了构造函数，这是正确的。然而，在尝试将整数值20赋值给<code>obj2</code>对象时，由于构造函数被声明为<code>explicit</code>，编译器会报错，不允许隐式类型转换。</p>
<p>通过使用<code>explicit</code>关键字，可以防止意外的类型转换，增加代码的清晰性和安全性。不让代码超出预期。</p>
<p><img src="/muduo-1/image-20230729212329032.png" alt="image-20230729212329032"></p>
<img src="/2023/07/27/muduo-1/image-20230729212329032.png" class title="This is an test image">

<h1 id="两种风格关系"><a href="#两种风格关系" class="headerlink" title="两种风格关系"></a>两种风格关系</h1><p>基于对象编程思想（OOP）和面向对象编程思想（OOAD）是紧密相关的概念，而不是互相对立的。下面将解释它们之间的关系以及各自的优势。</p>
<ul>
<li><strong>面向对象编程思想（Object-Oriented Programming Paradigm）</strong> 是一种编程方法论，其中的核心是将问题划分为各个对象，并通过对象之间的交互来解决问题。这种思想强调数据和操作的封装、继承、多态等概念，使得代码更具可重用性、可扩展性和可维护性。</li>
<li><strong>基于对象编程思想（Object-Based Programming Paradigm）</strong> 是指在某些编程语言中使用面向对象编程的部分特性，但不符合纯粹的面向对象编程的要求。它可能缺少某些面向对象编程的特征，如继承、多态等。</li>
</ul>
<p>因此，OOP是一种广义的编程思想，而OOAD则是针对软件系统设计与构建的一种方法。OOAD包括了面向对象编程范式，但它还超越了编程范畴，着重考虑软件开发的整体过程，包括需求分析、系统设计、模块化等方面。</p>
<p>总体而言，OOP和OOAD都有其独特的优势和应用场景：</p>
<ul>
<li>面向对象编程思想（OOP）是一种强大的编程范式，适合构建复杂、可重用和可扩展的软件系统。通过封装、继承和多态等特性，代码变得更易理解、模块化，减少了开发时间和维护成本。</li>
<li>基于对象编程思想（Object-Based Programming Paradigm）可能在某些简单场景下更加适用，特别是对那些不需要复杂继承和多态的问题。</li>
</ul>
<p>因此，选择使用OOP还是OOAD取决于具体的需求和项目要求。对于大型、复杂的软件系统，通常采用面向对象编程思想和面向对象分析设计方法是更好的选择。而在开发小型或简单的应用程序时，基于对象编程思想也可以提供足够的灵活性和效率。</p>
<h1 id="多线程与并发服务器设计"><a href="#多线程与并发服务器设计" class="headerlink" title="多线程与并发服务器设计"></a>多线程与并发服务器设计</h1><h2 id="常见并发服务器方案"><a href="#常见并发服务器方案" class="headerlink" title="常见并发服务器方案"></a>常见并发服务器方案</h2><p><img src="/muduo-1/image-20230807164014354.png" alt="image-20230807164014354"></p>
<img src="/2023/07/27/muduo-1/image-20230807164014354.png" class title="This is an test image">

<p><img src="/muduo-1/image-20230807212000990.png" alt="image-20230807212000990"></p>
<img src="/2023/07/27/muduo-1/image-20230807212000990.png" class title="This is an test image">

<p><img src="/muduo-1/image-20230808110610718.png" alt="image-20230808110610718"></p>
<img src="/2023/07/27/muduo-1/image-20230808110610718.png" class title="This is an test image">

<p><img src="/muduo-1/image-20230808110726418.png" alt="image-20230808110726418"></p>
<img src="/2023/07/27/muduo-1/image-20230808110726418.png" class title="This is an test image">

<p>9当中的多个reactor共享一个线程池，<strong>在Linux下更加推荐9</strong></p>
<p>惊群（Thundering Herd）现象是在多进程（prefork）或者多线程（pre-threaded）服务器模型中可能出现的一个性能问题。当一个监听套接字上的事件（如连接请求）到达时，所有等待处理此事件的进程或线程都会被唤醒，但只有其中一个能够成功地处理这个事件，而其他的进程或线程会在竞争中被阻塞。这会造成资源浪费和性能下降。</p>
<p>例如，假设有多个进程或线程都在等待处理连接请求，当一个连接到达时，多个进程或线程都会被唤醒，但只有一个进程或线程能够接受连接，而其他的进程或线程将会被阻塞在accept调用上。</p>
<p>为了解决惊群现象，可以考虑以下几种方法：</p>
<ol>
<li>使用互斥锁：在接受连接之前，使用互斥锁来保护临界区，确保只有一个进程或线程能够接受连接，其他的进程或线程会在锁上阻塞。这样可以避免多个进程或线程同时处理同一个事件。</li>
<li>使用信号量：类似于互斥锁，信号量也可以用来控制对临界资源的访问。在接受连接之前，可以使用信号量来控制只有一个进程或线程能够进入临界区。</li>
<li>延迟唤醒：让只有一个进程或线程来接受连接，其他进程或线程不进行accept调用，从而避免不必要的唤醒。当有新连接到达时，唤醒一个进程或线程来处理连接，其他进程或线程可以继续等待。</li>
<li>选用更先进的模型：使用更现代的多进程&#x2F;多线程服务器模型，如基于事件驱动的模型（如epoll、kqueue、IOCP等），可以更好地避免惊群现象，因为这些模型能够更精细地控制事件的分发。</li>
</ol>
<h2 id="多线程能提高并发度吗"><a href="#多线程能提高并发度吗" class="headerlink" title="多线程能提高并发度吗"></a>多线程能提高并发度吗</h2><p>如果指的是“并发连接数”，不能。<br>假如单纯采用thread per connection的模型，那么并发连接数大约300，这远远低于基于事件的单线程程序所能轻松达到的并发连接数（几千上万，甚至几万）。所谓“基于事件”，指的是用IO multiplexing event loop的编程模型，又称Reactor模式。</p>
<h2 id="多线程能提高吞吐量吗"><a href="#多线程能提高吞吐量吗" class="headerlink" title="多线程能提高吞吐量吗"></a>多线程能提高吞吐量吗</h2><p>对于计算密集型服务，不能。<br>如果要在一个8核的机器上压缩100个1G的文本文件，每个core的处理能力为200MB&#x2F;s，那么“每次起8个进程，一个进程压缩一个文件”与“只启动一个进程（8个线程并发压缩一个文件）”，这两种方式总耗时相当，但是第二种方式能<strong>较快</strong>的拿到第一个压缩完的文件。</p>
<p>从这个例子可以看出<strong>能提高响应时间</strong></p>
<h2 id="多线程如何让IO和计算重叠"><a href="#多线程如何让IO和计算重叠" class="headerlink" title="多线程如何让IO和计算重叠"></a>多线程如何让IO和计算重叠</h2><p>多线程程序如何让I&#x2F;O和计算重叠，降低latenc迟延)</p>
<ul>
<li>例:日志（logging) ，多个线程写日志，由于文件操作比较慢，服务线程会等在lO上，让CPU空闲，增加响应时间。</li>
<li>解决办法:单独用一个logging线程负责写磁盘文件通过BlockingQueue提供对外接口，别的线程要写日志的时候往队列一塞就行，这样服务线程的计算和logging线程的磁盘IO就可以重叠。</li>
<li>如果异步IO成熟的话，可以用protator模式。</li>
</ul>
<h2 id="线程池大小选择"><a href="#线程池大小选择" class="headerlink" title="线程池大小选择"></a>线程池大小选择</h2><p>如果池中执行任务时，密集计算所占时间比重为P(0&lt;p&lt;&#x3D;1)，而系统一共有C个CPU，为了让C个CPU跑满而不过载,线程池大小的经验公式T&#x3D;C&#x2F;P,即T*P&#x3D;C(让CPU刚好跑满)</p>
<ul>
<li>假设C&#x3D;8，P&#x3D;1.0，线程池的任务完全密集计算，只要8个活动线程就能让CPU饱和</li>
<li>假设C&#x3D;8，P&#x3D;0.5，线程池的任务有一半是计算，一半是lO，那么T&#x3D;16，也就是16个“50%繁忙的线程”能让8个CPU忙个不停。</li>
</ul>
<p><strong>I&#x2F;O操作不耗费CPU</strong>的原因是，当执行I&#x2F;O操作时，CPU可以将控制权交给其他任务或进程，而不需要持续地占用CPU资源。在进行I&#x2F;O操作期间，CPU可以继续执行其他指令，如处理其他进程的计算需求。</p>
<p>当一个程序发起一个I&#x2F;O请求时，它将传递给操作系统，然后操作系统将负责管理这个请求。操作系统可以将该请求放入一个队列中，等待设备准备就绪，并在合适的时候通知程序。这样一来，程序可以继续执行其他任务，而不必等待I&#x2F;O操作完成。</p>
<p>一旦设备准备好，并且I&#x2F;O操作已经完成，操作系统将通知程序，使程序能够继续执行。在这个过程中，CPU并没有被I&#x2F;O操作所阻塞，而是可以执行其他任务。因此，I&#x2F;O操作不会消耗大量的CPU时间。</p>
<p>值得注意的是，尽管I&#x2F;O操作本身可能不耗费CPU，但I&#x2F;O操作可能会导致CPU等待数据的返回。例如，当从硬盘读取文件时，CPU可能会暂停执行，直到数据被读取到内存中才能继续执行。这种情况下，虽然CPU可能会花费一些时间等待I&#x2F;O操作完成，但这并不是CPU主动参与I&#x2F;O操作的结果。</p>
<h2 id="线程分类"><a href="#线程分类" class="headerlink" title="线程分类"></a>线程分类</h2><p>I&#x2F;O线程（这里特指网络I&#x2F;O),reactor模式</p>
<p>计算线程，耗费cpu</p>
<p>第三方库所用线程，如logging,又比如database</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-26 10:19:17" itemprop="dateCreated datePublished" datetime="2023-07-26T10:19:17+08:00">2023-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-01 10:53:20" itemprop="dateModified" datetime="2023-08-01T10:53:20+08:00">2023-08-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h1><h2 id="UML中的关系"><a href="#UML中的关系" class="headerlink" title="UML中的关系"></a>UML中的关系</h2><p>UML中的关系主要包括4种:<br>关联关系(association)<br>依赖关系(dependency)<br>泛化关系(generalization)<br>实现关系(realization)</p>
<h2 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h2><p>(1)用例图(Use Case Diagram):也称为用户模型图，是从软件需求分析到最终实现的第一步，它是从客户的角度来描述系统功能.<br>(2）用例图包含3个基本组件:<br>参与者(Actor):与系统打交道的人或其他系统即使用该系统的人或事物.在UML中参与者用人形图标表示<br>用例(Use Case):代表系统的某项完整的功能.在UML中使用一个椭圆来表示<br>关系:定义用例之间的关系——泛化关系,扩展关系，包含关系</p>
<p>这是一个泛化关系</p>
<p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726103502809.png" alt="image-20230726103502809"></p>
<img src="/2023/07/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726103502809.png" class title="This is an test image">

<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>类图是面向对象系统建模中最常用的图.是定义其他图的基础.<br>类图主要是用来显示系统中的类,接口以及它们之间的关系.<br>类图包含的主要元素有类，接口和关系.其中关系有泛化关系,关联关系，依赖关系和实现关系.在类图中也可以包含注释和约束.</p>
<h3 id="类的表示法"><a href="#类的表示法" class="headerlink" title="类的表示法"></a>类的表示法</h3><p>1.类是类图的主要组件，由3部分组成:类名，属性和方法.在UML中，类用矩形来表示，顶端部分存放类的名称，中间部分存放类的属性，属性的类型及值,底部部分存放类的方法,方法的参数和返回类型.<br>2.在UML中可以根据实际情况有选择的隐藏属性部分或方法部分或两者<br>都隐藏</p>
<p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726103808831.png" alt="image-20230726103808831"></p>
<img src="/2023/07/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726103808831.png" class title="This is an test image">

<h3 id="类之间的关系-泛化关系"><a href="#类之间的关系-泛化关系" class="headerlink" title="类之间的关系-泛化关系"></a>类之间的关系-泛化关系</h3><p>1.在UML中，泛化关系用来表示类与类，接口与接口之间的继承关系.泛化关系有时也称为” is a kind of“关系.<br>2.在UML中泛化关系用一条实线空心箭头有子类指向父类.</p>
<h3 id="类之间的关系-实现关系"><a href="#类之间的关系-实现关系" class="headerlink" title="类之间的关系-实现关系"></a>类之间的关系-实现关系</h3><p>在UML中，实现关系用来表示类与接口之间的实现关系.</p>
<p>在UML中实现关系用一条虚线空心箭头由子类指向父类</p>
<h3 id="类之间的关系-依赖关系"><a href="#类之间的关系-依赖关系" class="headerlink" title="类之间的关系-依赖关系"></a>类之间的关系-依赖关系</h3><p>对于两个相对独立的系统，当一个系统负责构造另一个系统的实例，或者依赖另一个系统的服务时，这两个系统之间体现为依赖关系.</p>
<p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726104109089.png" alt="image-20230726104109089"></p>
<img src="/2023/07/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726104109089.png" class title="This is an test image">

<h3 id="类之间的关系-关联关系"><a href="#类之间的关系-关联关系" class="headerlink" title="类之间的关系-关联关系"></a>类之间的关系-关联关系</h3><p>对于两个相对独立的系统，当一个系统的实例与另一个系统的一些特定实例存在固定的对应关系时，这两个系统之间为关联关系。</p>
<h3 id="常见的类图分为以下几个层级："><a href="#常见的类图分为以下几个层级：" class="headerlink" title="常见的类图分为以下几个层级："></a>常见的类图分为以下几个层级：</h3><ul>
<li>类名</li>
</ul>
<p>类名层不可省略，其他几层可以不存在；</p>
<p>类名是正体字，类是具体的；</p>
<p>类名是斜体字，类是抽象的，或者是接口；</p>
<ul>
<li>属性</li>
</ul>
<p>+代表public；</p>
<p>#代表protected；</p>
<p>-代表private ；</p>
<ul>
<li>方法</li>
</ul>
<p>+代表public；<br>#代表protected；<br>-代表private ；<br>如果方法下面有一道下划线，则表明该方法是静态方法；<br>方法后面带的是返回值类型；</p>
<h1 id="软件设计模式的种类"><a href="#软件设计模式的种类" class="headerlink" title="软件设计模式的种类"></a>软件设计模式的种类</h1><p>GoF提出的设计模式有23个包括︰<br>创建型(Creational)模式:如何创建对象﹔<br>结构型(Structural )模式:如何实现类或对象的组合﹔<br>行为型(Behavioral)模式︰类或对象怎样交互以及怎样分配职责。</p>
<p>有一个“简单工厂模式”不属于GoF 23种设计模式，但大部分的设计模式<br>书籍都会对它进行专门的介绍。</p>
<p>设计模式目前种类:GoF的23种+“简单工厂模式”&#x3D;24种。</p>
<p>设计模式的基础是<strong>多态</strong></p>
<h2 id="设计模式总览图"><a href="#设计模式总览图" class="headerlink" title="设计模式总览图"></a>设计模式总览图</h2><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726104823806.png" alt="image-20230726104823806"></p>
<img src="/2023/07/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726104823806.png" class title="This is an test image">

<p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726104838478.png" alt="image-20230726104838478"></p>
<img src="/2023/07/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726104838478.png" class title="This is an test image">

<p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726104917159.png" alt="image-20230726104917159"></p>
<img src="/2023/07/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726104917159.png" class title="This is an test image">

<p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726104931305.png" alt="image-20230726104931305"></p>
<img src="/2023/07/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726104931305.png" class title="This is an test image">

<p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726104944466.png" alt="image-20230726104944466"></p>
<img src="/2023/07/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726104944466.png" class title="This is an test image">

<p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726104954560.png" alt="image-20230726104954560"></p>
<img src="/2023/07/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726104954560.png" class title="This is an test image">

<h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><p>对于面向对象软件系统的设计而言，在支持可维护性的同时，提高系统的可复用性是一个至关重要的问题,如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。在面向对象设计中，可维护性的复用是以设计原则为基础的。每一个原则都蕴含一些面向对象设计的思想，可以从不同的角度提升一个软件结构的设计水平。</p>
<p>面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。面向对象设计原则也是我们用于评价一个设计模式的使用效果的重要指标之一。</p>
<p>原则的目的:高内聚，低耦合</p>
<p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726105230007.png" alt="image-20230726105230007"></p>
<img src="/2023/07/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726105230007.png" class title="This is an test image">

<p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726105243049.png" alt="image-20230726105243049"></p>
<img src="/2023/07/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726105243049.png" class title="This is an test image">

<p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726105255149.png" alt="image-20230726105255149"></p>
<img src="/2023/07/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726105255149.png" class title="This is an test image">

<p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726105310548.png" alt="image-20230726105310548"></p>
<img src="/2023/07/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726105310548.png" class title="This is an test image">

<p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726105326170.png" alt="image-20230726105326170"></p>
<img src="/2023/07/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726105326170.png" class title="This is an test image">

<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Caculaor&#123;</span><br><span class="line">public:</span><br><span class="line">    Caculaor(int a，int b，string moperator)&#123;</span><br><span class="line">        this-&gt;m_a = a;</span><br><span class="line">        this-&gt;m_b = b;</span><br><span class="line">        this-&gt;m_operator = moperator;</span><br><span class="line">    &#125;</span><br><span class="line">int getResult() &#123;</span><br><span class="line">    if (m_operator.compare(&quot;+&quot;) == 0)&#123;</span><br><span class="line">        return m_a + m_b;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (m_operator.compare(&quot;-&quot;) == 0)&#123;</span><br><span class="line">    	return m_a - m_b;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (m_operator.compare(&quot;*&quot;&quot;) == 0)&#123;</span><br><span class="line">    	return m_a * m_b;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (m_operator.compare(&quot;/&quot;) =0)&#123;</span><br><span class="line">    	return m_a / m_b;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">	int m_a;</span><br><span class="line">	int m_b;</span><br><span class="line">	string m_operator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点:如果增加取模的运算需要修改getResult 成员方法，如果增加新功能的情况下要修改源代码，那么就会有修改出错的可能性。我们应该在增加新的功能时候，不能影响其他已经完成的功能。这就是对修改关闭，对扩展开放，叫做开闭原则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//开闭原则﹑对扩展开放，对修改关闭，增加功能是通过增加代码来实现，而不是去修改源代码</span><br><span class="line">//写一个抽象类</span><br><span class="line">class AbstractCaculator &#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void setOperatorNumber(int,int)=0;</span><br><span class="line">	virtual int getResult() =0;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">//加法计算器类</span><br><span class="line">class PlusCaculator :public AbstractCaculator&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void setOperatorNumber(int a,int b)&#123;</span><br><span class="line">		this-&gt;mA = a;</span><br><span class="line">		this-&gt;mB = b;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual int getResult()&#123;</span><br><span class="line">		return mA + mB;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	int mA;</span><br><span class="line">	int mB;</span><br><span class="line">&#125;;</span><br><span class="line">void test()&#123;</span><br><span class="line">	AbstractCaculator* pca=new PlusCaculator;</span><br><span class="line">	pca-&gt;setOperatorNumber(1,2);</span><br><span class="line">	int a=pca-&gt;getResult();</span><br><span class="line">	cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main ()&#123;</span><br><span class="line">	test();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用这个代码，扩展新功能就很方便，不用修改原有代码。</p>
<p>本质就是利用了多态，父类作为通用接口，扩展需要的子类。</p>
<h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//迪米特法则又叫最少知识原则</span><br><span class="line">c1ass AbstractBuilding &#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void sale() = 0;</span><br><span class="line">	virtual string getQuality() = 0;</span><br><span class="line">&#125;;</span><br><span class="line">//楼盘A</span><br><span class="line">class BuildingA : public AbstractBuilding&#123;</span><br><span class="line">public:</span><br><span class="line">	BuildingA() &#123;</span><br><span class="line">		mQulity =&quot;高品质&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void sale() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;楼盘A&quot;&lt;&lt; mQulity &lt;&lt;&quot;被售卖!&quot;&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	string mQulity;</span><br><span class="line">&#125; ;</span><br><span class="line">//楼盘B</span><br><span class="line">class BuildingB : public AbstractBuilding&#123;</span><br><span class="line">public:</span><br><span class="line">	BuildingB() &#123;</span><br><span class="line">		mQulity =&quot;低品质&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void sale() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;楼盘B&quot;&lt;&lt; mQulity &lt;&lt;&quot;被售卖!&quot;&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	string mQulity;</span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure>

<p>如上图，楼盘AB里应该再添加一个getQuality方法，截图费劲，没截进去了。这样是直接打交道的，客户端直接接触到了楼层类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//中介类</span><br><span class="line">class Mediator&#123;</span><br><span class="line">public:</span><br><span class="line">	Mediator()&#123;</span><br><span class="line">		AbstractBuilding* building = new BuildingA;</span><br><span class="line">		vBuilding. push_back(building) ;</span><br><span class="line">		building = new BuildingB;</span><br><span class="line">		vBuilding.push_back(building);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">//对外提供接口</span><br><span class="line">	AbstractBui1ding* findMyBuilding(string quality) &#123;</span><br><span class="line">		for (vector&lt;AbstractBuilding*&gt; : :iterator it = vBuilding.begin();it!=vBuilding.endl;it++)&#123;</span><br><span class="line">			if ((*it)-&gt;getQuality() == quality)&#123;</span><br><span class="line">				return *it;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	return NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	~Mediator() &#123;</span><br><span class="line">		for (vector&lt;AbstractBuilding*&gt; :: iterator it = vBuilding.begin();it!=vBuilding.endl;it++)</span><br><span class="line">			if (*it != NULL) &#123;</span><br><span class="line">				delete *it;//放指针指向的内存,析构函数的目的是确保释放 vBuilding 向量中的内存资源</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	vector&lt;AbstractBuilding*&gt; vBui1ding;</span><br><span class="line">&#125;</span><br><span class="line">//现在，客户只需要和中介打交道：</span><br><span class="line">//客户端</span><br><span class="line">void test02()&#123;</span><br><span class="line">	Mediator* mediator = new Mediator;</span><br><span class="line">	AbstractBuilding* building =mediator-&gt;findMyBuilding(&quot;高品质&quot;);</span><br><span class="line">	if (building !=NULL)&#123;</span><br><span class="line">		bui1ding-&gt;sale();</span><br><span class="line">	else &#123;</span><br><span class="line">		cout &lt;&lt;&quot;没有符合您条件的楼盘!&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p>就一句话，能用组合就别用继承</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//抽象车</span><br><span class="line">class AbstractCar &#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void run() = 0;</span><br><span class="line">&#125;</span><br><span class="line">//大众车</span><br><span class="line">class Dazhong :public AbstractCar&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void run() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;大众车启动...&quot;&lt;&lt; end1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br><span class="line">//拖拉机</span><br><span class="line">class Tuolaji :public AbstractCar&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void run() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;拖拉机启动...&quot;&lt;&lt;end1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//像上面这种写法，就非常不科学，如果有很多开不同类型车的人，就需要写很多类。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//可以使用组合</span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">	void setCar(AbstractCar* car)&#123;</span><br><span class="line">		this-&gt;car = car;</span><br><span class="line">	&#125;</span><br><span class="line">	void Doufeng ()&#123;</span><br><span class="line">		this-&gt;car-&gt;run() ;</span><br><span class="line">	&#125;</span><br><span class="line">	~person()&#123;</span><br><span class="line">		if(this-&gt;car!=NULL)</span><br><span class="line">			delete this-&gt;car;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	AbstractCar* car;</span><br><span class="line">&#125;;</span><br><span class="line">void test02()&#123;</span><br><span class="line">	Person* p = new Person;</span><br><span class="line">	p-&gt;setCar(new Dazhong);</span><br><span class="line">	p-&gt;Doufeng() ;</span><br><span class="line">	delete p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h2><p>传统的过程式设计倾向于使高层次的模块依赖于低层次的模块，抽象层依赖于具体的层次。</p>
<p>传统的设计过程，高层依赖于中层，中层依赖于底层</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//银行工作人员</span><br><span class="line">class BankWorker &#123;</span><br><span class="line">public:</span><br><span class="line">	void saveService() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;办理存款业务...&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	void payService()&#123;</span><br><span class="line">		cout &lt;&lt;&quot;办理支付业务..&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	void tranferService() &#123;</span><br><span class="line">		cout&lt;&lt;&quot;办理转账业务..&quot;&lt;&lt;endl;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//中层模块</span><br><span class="line">void doSaveBussiness (BankWorker* worker)&#123;</span><br><span class="line">	worker-&gt;saveService() ;</span><br><span class="line">&#125;</span><br><span class="line">void doPayBussiness(BankWorker* worker)&#123;</span><br><span class="line">	worker-&gt;payService();</span><br><span class="line">&#125;</span><br><span class="line">void doTransferBussiness(BankWorker* worker) &#123;</span><br><span class="line">	worker-&gt;tranferService();</span><br><span class="line"> &#125;</span><br><span class="line">void test01()&#123;</span><br><span class="line">	BankWorker* worker = new BankWorker ;</span><br><span class="line">	doSaveBussiness(worker);//办理存款业务</span><br><span class="line">	doPayBussiness(worker);//办理支付业务</span><br><span class="line">	doTransferBussiness(worker) ; //办理转账业务</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面用依赖倒转原则改写上面的业务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//银行工作人员</span><br><span class="line">class AbstractWorker&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void doBusfness() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//专门负责办理存款业务的工作人员</span><br><span class="line">class SaveBankWorer :public AbstractWorker&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void doBusiness() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;办理存款业务...”&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//专门办理支付业务的工作人员</span><br><span class="line">class PayBankWorker : public AbstractWorker&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void doBusiness() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;办理支付业务...&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">//专门办理转账业务的工作人员</span><br><span class="line">class TransferBankWorker : public AbstractWorker&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void doBusiness() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;办理转账业务...&quot; &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">//中层业务</span><br><span class="line">void doNewBusiness(AbstractWorker* worker)&#123;</span><br><span class="line">	worker-&gt;doBusiness() ;</span><br><span class="line">&#125;</span><br><span class="line">void tesat02()&#123;</span><br><span class="line">	AbstractWorker* transfer = new TransferBankWorker;</span><br><span class="line">	doNewBusiness(transfer) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是利用多态，将底层抽象出来，这样顶层就只依赖于抽象层，底层有改动时，也不会改变中层，就不会影响到上层。</p>
<h2 id="简单工厂模式-代码实现"><a href="#简单工厂模式-代码实现" class="headerlink" title="简单工厂模式-代码实现"></a>简单工厂模式-代码实现</h2><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726155959005.png" alt="image-20230726155959005"></p>
<img src="/2023/07/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726155959005.png" class title="This is an test image">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">//抽象水果</span><br><span class="line">class AbstractFruit&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void ShowName () = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//苹果</span><br><span class="line">class Apple : public AbstractFruit&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void ShowName() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;我是苹果!&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//香蕉</span><br><span class="line">class Banana : public AbstractFruit&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void ShowName () &#123;</span><br><span class="line">		cout &lt;&lt;&quot;我是香蕉!&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//鸭梨</span><br><span class="line">class Pear : public AbstractFruit &#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void ShowName() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;我是鸭梨!&quot;&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//水果工厂</span><br><span class="line">class FruitFactory &#123;</span><br><span class="line">public:</span><br><span class="line">	static AbstractFruit* CreateFruit(string flag)&#123;</span><br><span class="line">		if (f1ag == &quot;apple&quot;)&#123;</span><br><span class="line">		return new Apple;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (flag == &quot;banana&quot;)&#123;</span><br><span class="line">			return new Banana;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (flag == &quot;pear&quot;) &#123;</span><br><span class="line">			return new Pear;</span><br><span class="line">		&#125; </span><br><span class="line">		else&#123;</span><br><span class="line">			return NULL;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()&#123;</span><br><span class="line">	FruitFactory* factory = new FruitFactory;</span><br><span class="line">	AbstractFruit* fruit = factory-&gt;CreateFruit(&quot;apple&quot;) ;</span><br><span class="line">	fruit-&gt;ShowName () ;</span><br><span class="line">	delete fruit;</span><br><span class="line">	fruit = factory-&gt;CreateFruit(&quot;banana&quot;);</span><br><span class="line">	fruit-&gt;ShowName() ;</span><br><span class="line">	delete fruit;</span><br><span class="line">	fruit = factory-&gt;CreateFruit(&quot;pear&quot;);</span><br><span class="line">	fruit-&gt;ShowName () ;</span><br><span class="line">	delele fruit;</span><br><span class="line">	delete factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>简单工厂中，工厂不符合开闭原则。这里，再将工厂抽象出来，让工厂也符合开闭原则。</p>
<p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726161204568.png" alt="image-20230726161204568"></p>
<img src="/2023/07/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726161204568.png" class title="This is an test image">

<p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726161226477.png" alt="image-20230726161226477"></p>
<img src="/2023/07/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726161226477.png" class title="This is an test image">

<p>优点:<br>(1)不需要记住具体类名，甚至连具体参数都不用记忆。<br>(2)实现了对象创建和使用的分离。<br>心<br>(3)系统的可扩展性也就变得非常好，无需修改接口和原类。<br>缺点:<br>(1)增加系统中类的个数，复杂度和理解度增加。<br>(2)增加了系统的抽象性和理解难度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//抽象水果</span><br><span class="line">class AbstractFruit&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void ShowName() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//苹果</span><br><span class="line">class Apple : public AbstractFruit&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void ShowName ()&#123;</span><br><span class="line">		cout &lt;&lt;”我是苹果!&quot;”&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//香蕉</span><br><span class="line">class Banana : public AbstractFruit&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void ShowName () &#123;</span><br><span class="line">		cout &lt;&lt;&quot;我是香蕉!”&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">//抽象工厂</span><br><span class="line">class AbstractFruitFactory&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual AbstractFruit* CreateFruit()= 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//苹果工厂</span><br><span class="line">class AppleFactory : public AbstractFruitFactory&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual AbstractFruit* CreateFruit() &#123;</span><br><span class="line">		return new Apple;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01() &#123;</span><br><span class="line">	AbstractFruitFactory* factory = NULL;</span><br><span class="line">	AbstractFruit* fruit = NULL;</span><br><span class="line">	//创建一个苹果工厂</span><br><span class="line">	factory = new AppleFactory;</span><br><span class="line">	fruit = factory-&gt;CreateFruit() ;</span><br><span class="line">	fruit-&gt;ShowName() ;</span><br><span class="line">	delete fruit;</span><br><span class="line">	delete factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简单工厂和工厂方法模式适用场景"><a href="#简单工厂和工厂方法模式适用场景" class="headerlink" title="简单工厂和工厂方法模式适用场景"></a>简单工厂和工厂方法模式适用场景</h3><p>1.客户端不知道它所需要的对象的类。<br>2.抽象工厂类通过其子类来指定创建哪个对象。<br>3.工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。<br>4.客户端只知道传入工厂类的参数，对于如何创建对象并不关心。</p>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726162010494.png" alt="image-20230726162010494"></p>
<img src="/2023/07/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726162010494.png" class title="This is an test image">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">//抽象苹果</span><br><span class="line">class AbstractApple&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void ShowName () = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//中国苹果</span><br><span class="line">class ChinaApple : public AbstractApple &#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void ShowName () &#123;</span><br><span class="line">		cout &lt;&lt;&quot;中国苹果!&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//美国苹果</span><br><span class="line">class USAApple : public AbstractApple &#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void ShowName() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;美国苹果!&quot;&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//抽象香蕉</span><br><span class="line">class AbsrtactBanana&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void ShowName() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//抽象鸭梨</span><br><span class="line">class AbstractPear &#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void ShowName () = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//抽象工厂针对产品族</span><br><span class="line">class AbstracFactory&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual AbstractApple* CreateApple() = 0;</span><br><span class="line">	virtual AbsrtactBanana* CreateBanana() = 0;</span><br><span class="line">	virtual AbstractPear* CreatePear() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//中国工厂</span><br><span class="line">class ChinaFactory : public AbstracFactory &#123;</span><br><span class="line">public:</span><br><span class="line">	virtual AbstractApple* CreateApple()&#123;</span><br><span class="line">		return new ChinaApple;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual AbsrtactBanana* CreateBanana() &#123;</span><br><span class="line">		return new ChinaBanana;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual AbstractPear* CreatePear ()&#123;</span><br><span class="line">		return new ChinaPear;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()&#123;</span><br><span class="line">	AbstracFactory* factory = NULL;</span><br><span class="line">	AbstractApple* apple = NULL;</span><br><span class="line">	AbsrtactBanana* banana = NULL;</span><br><span class="line">	AbstractPear* pear = NULL;</span><br><span class="line">	factory = new ChinaFactory;</span><br><span class="line">	apple = factory-&gt;CreateApple();</span><br><span class="line">	banana = factory-&gt;CreateBanana() ;</span><br><span class="line">	pear = factory-&gt;CreatePear();</span><br><span class="line">	apple-&gt;ShowName();</span><br><span class="line">	delete factory;</span><br><span class="line">	delete apple;</span><br><span class="line">	delete banana;</span><br><span class="line">	delete pear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单例模式-饿汉式和懒汉式创建"><a href="#单例模式-饿汉式和懒汉式创建" class="headerlink" title="单例模式_饿汉式和懒汉式创建"></a>单例模式_饿汉式和懒汉式创建</h2><p>单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">private:</span><br><span class="line">	A()&#123;</span><br><span class="line">		a=new A;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	static A* getInstace() &#123;//静态成员函数只能访问类的静态成员变量和其他静态成员函数，不能直接访问类的非静态成员变量和非静态成员函数，静态成员函数也没有访问权限限定符（public、private、protected）的限制。</span><br><span class="line">		return a;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	static A* a;</span><br><span class="line">&#125;;</span><br><span class="line">int main(void)&#123;</span><br><span class="line">	//A* a = new A;</span><br><span class="line">	A::getInstace();</span><br><span class="line">&#125;</span><br><span class="line">//实现单例步骤</span><br><span class="line">//1.构造函数私有化</span><br><span class="line">//2．增加静态私有的当前类的指针变量</span><br><span class="line">//3．提供静态对外接口，可以让用户获得单例对象</span><br></pre></td></tr></table></figure>

<p>懒汉式，调用getinstance的时候才会去new一个对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//单例分为懒汉式</span><br><span class="line">class Singleton_lazy&#123;</span><br><span class="line">private:</span><br><span class="line">	Singleton_lazy()&#123;&#125;</span><br><span class="line">public:</span><br><span class="line">	static sing1eton_1azy* getInstance() &#123;</span><br><span class="line">			if (pSingleton == NULL)&#123;</span><br><span class="line">				pSing1eton = new Singleton_1azy;</span><br><span class="line">			&#125;</span><br><span class="line">			return pSing1eton;</span><br><span class="line">		&#125;</span><br><span class="line">private:</span><br><span class="line">	static Singleton_lazy* pSingleton;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//类外初始化</span><br><span class="line">Singleton_lazy* Singleton_lazy::pSingleton = NULL;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 饿汉式</span><br><span class="line">class Sing1eton_hungry &#123;</span><br><span class="line">private:</span><br><span class="line">	sing1eton_hungry () &#123;&#125;</span><br><span class="line">public:</span><br><span class="line">	static Singleton_hungry* getInstance()&#123;</span><br><span class="line">		return pSing1eton;</span><br><span class="line">private:</span><br><span class="line">	static Singleton_hungry* pSingleton;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton_hungry* Singleton_hungry::pSingleton = new Singleton_hungry;</span><br></pre></td></tr></table></figure>

<p>其实单例模式的核心就是构造函数私有化，让用户不能自己new一个对象。饿汉式是直接类内new一个对象，懒汉式是在需要访问对象时才实例化。完事儿通过static来保证大家访问的都是同一个实例</p>
<p>单例不需要考虑释放问题</p>
<p>单例模式不需要考虑释放问题的原因是，单例模式中的实例对象是在程序的整个生命周期中存在的，直到程序结束才会被销毁。因此，不需要手动释放单例对象。</p>
<p>单例模式通过将构造函数私有化，并提供一个静态方法来获取唯一实例，确保了只有一个实例存在。实例一旦创建，就会一直存在于内存中，直到程序结束。因为单例对象是全局唯一的，可以在程序的任何地方访问，所以不需要手动释放实例。</p>
<p>如果强制要求释放单例对象，可能会导致程序在继续执行时无法再次获取该实例，从而违背了单例模式的初衷。</p>
<h3 id="单例碰到多线程"><a href="#单例碰到多线程" class="headerlink" title="单例碰到多线程"></a>单例碰到多线程</h3><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726165422048.png" alt="image-20230726165422048"></p>
<img src="/2023/07/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726165422048.png" class title="This is an test image">

<p>在单例模式的懒汉式实现中，实例对象在首次被请求时才会被创建。这种延迟加载的方式会在多线程环境下引发线程安全性问题。</p>
<p>当多个线程同时调用单例模式的懒汉式实现的获取实例的方法时，可能会导致多个线程同时判断实例为空，从而同时创建多个实例。这会破坏单例的唯一性。</p>
<p>在多线程的情况下，假设有两个线程 A 和 B 同时调用 <code>Singleton::getInstance()</code> 方法且此时 <code>instance</code> 为空。线程 A 执行到 <code>instance = new Singleton()</code> 时，它可能会被切换出去，而线程 B 此时也执行到了 <code>instance == nullptr</code> 的判断，于是线程 B 也会创建一个新的实例。这样就在多线程中产生了多个实例。</p>
<p>为了解决这个线程安全性问题，可以考虑使用加锁机制来保证只有一个线程可以同时访问创建实例的代码块。例如，可以使用互斥锁（<code>std::mutex</code>）来实现互斥访问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;mutex&gt;</span><br><span class="line"></span><br><span class="line">class Singleton &#123;</span><br><span class="line">private:</span><br><span class="line">    static Singleton* instance;</span><br><span class="line">    static std::mutex mtx;</span><br><span class="line">    </span><br><span class="line">    Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    static Singleton* getInstance() &#123;</span><br><span class="line">        if (instance == nullptr) &#123;</span><br><span class="line">            std::lock_guard&lt;std::mutex&gt; lock(mtx);  // 加锁</span><br><span class="line">            if (instance == nullptr) &#123;  // 再次判断是否为空</span><br><span class="line">                instance = new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">            //解锁</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = nullptr;</span><br><span class="line">std::mutex Singleton::mtx;</span><br></pre></td></tr></table></figure>

<h2 id="代理概念理解案例"><a href="#代理概念理解案例" class="headerlink" title="代理概念理解案例"></a>代理概念理解案例</h2><p>代理模式的定义∶为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//提供一种代理来控制对其他对象的访问</span><br><span class="line">c1ass AbstractCommonInterface&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void run() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//我已经写好的系统</span><br><span class="line">class MySystem : public AbstractCommonInterface&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void run() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;系统启动...&quot;&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//必须有要权限验证，不是所有人都能来启动我的启动，提供用户名和密码</span><br><span class="line">class MySystemProxy : public AbstractCommonInterface &#123;</span><br><span class="line">public:</span><br><span class="line">	MySystemProxy (string username,string password)&#123;</span><br><span class="line">		this-&gt;mUsername = username;</span><br><span class="line">		this-&gt;mPassword = password;</span><br><span class="line">		pSystem = new MySystem;</span><br><span class="line">	&#125;</span><br><span class="line">	bool checkUsernameAndPassoword() &#123;</span><br><span class="line">		if (mUsername == &quot; admin&quot; &amp;&amp; mPassword == &quot;admin&quot;)&#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;else</span><br><span class="line">			return false;</span><br><span class="line"></span><br><span class="line">	virtual void run () &#123;</span><br><span class="line">		if (checkUsernameAndPassoword ())</span><br><span class="line">			cout &lt;&lt;&quot;用户名和密码正确，验证通过...&lt;&lt;this-&gt;pSystem-&gt;run();</span><br><span class="line">		else&#123;</span><br><span class="line">			cout &lt;&lt;用户名或者密码错误,权限不足...&quot;&lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test()&#123;</span><br><span class="line">	MySystemProxy* mys=new MySystemProxy(&quot;admin&quot;,&quot;admin&quot;);</span><br><span class="line">	mys-&gt;run;</span><br><span class="line">	delete mys;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>web服务器在验证用户连接信息时，使用代理服务器，不然既要验证信息，又要数据传输，服务器压力会过大。</p>
<h2 id="外观模式-概念"><a href="#外观模式-概念" class="headerlink" title="外观模式_概念"></a>外观模式_概念</h2><p>根据迪米特法则，如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。<br>Facade模式也叫外观模式，是由GoF提出的23种设计模式中的一种。Facade模式为一组具有类似功能的类群，比如类库，子系统等等，提供一个一致的简单的界面。这个一致的简单的界面被称作facade。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">外观模式就是将复杂的子类系统抽象到同一个的接口进行管理</span><br><span class="line">，外界只需要通过此接口与子类系统进行交互，而不必要直接与复杂的子类系统进行交互</span><br><span class="line">*/</span><br><span class="line">//子系统1</span><br><span class="line">class SubSysteml &#123;</span><br><span class="line">public:</span><br><span class="line">	void run() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;子系统一运行...&quot; &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; ;</span><br><span class="line">//子系统2</span><br><span class="line">class SubSystem2&#123;</span><br><span class="line">public:</span><br><span class="line">	void run()&#123;</span><br><span class="line">		cout &lt;&lt;&quot;子系统二运行...&quot;&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//子系统3</span><br><span class="line">class SubSystem3&#123;</span><br><span class="line">public:</span><br><span class="line">	void run() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;子系统三运行...&quot;&lt;&lt; endl ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//子系统4</span><br><span class="line">class SubSystem4&#123;</span><br><span class="line">public:</span><br><span class="line">	void run() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;子系统四运行...&quot; &lt;&lt; endl ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//外观类</span><br><span class="line">class Facede&#123;</span><br><span class="line">public:</span><br><span class="line">	Facede() &#123;</span><br><span class="line">		pSysteml = new SubSysteml;</span><br><span class="line">		pSystem2 = new SubSystem2;</span><br><span class="line">		pSystem3 = new SubSystem3;</span><br><span class="line">		pSystem4 = new SubSystem4;</span><br><span class="line">	&#125;</span><br><span class="line">	~Facede() &#123;</span><br><span class="line">	//销毁</span><br><span class="line">	&#125;</span><br><span class="line">	void runSystem() &#123;</span><br><span class="line">		pSysteml-&gt;run();</span><br><span class="line">		pSystem2-&gt;run();</span><br><span class="line">		pSystem3-&gt;run();</span><br><span class="line">		pSystem4-&gt;run();</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	SubSysteml* pSysteml ;</span><br><span class="line">	SubSystem2* pSystem2;</span><br><span class="line">	SubSystem3* pSystem3;</span><br><span class="line">	SubSystem4* pSystem4;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()&#123;</span><br><span class="line">	Facede* facede = new Facede;</span><br><span class="line">	facede-&gt;runSystem() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在不同情况下，可能分不同模式的外观，即系统的不同状态需要重新定义外观类。</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//这函数我已经写好</span><br><span class="line">struct MyPrint &#123;</span><br><span class="line">	void operator() (int vl,int v2)&#123;</span><br><span class="line">		cout &lt;&lt; vl + v2 &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//定义目标接口我要是配偶适配成什么样的</span><br><span class="line">class Target&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void operator () (int v) = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//写适配器</span><br><span class="line">class Adapter : public Target &#123;</span><br><span class="line">public:</span><br><span class="line">	Adapter(int pram)&#123;</span><br><span class="line">		this-&gt;pram=pram;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void operator() (int v)&#123;</span><br><span class="line">		print(v,pram) ;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	MyPrint print;</span><br><span class="line">	int pram;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">	vector&lt;int&gt; v;</span><br><span class="line">	for (int i = 0; i &lt; 10;i++)</span><br><span class="line">		v.push_back(i) ;</span><br><span class="line">	for_each(v.begin(),v.end(),Adapter(10));//Adapter(10)是可以调用构造函数的</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//抽象模板</span><br><span class="line">class DrinkTemplate&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void BoilWater() = 0;//煮开水</span><br><span class="line">	virtual void Brew() = 0;//冲泡</span><br><span class="line">	virtual void PourInCup() = 0;//倒入杯中</span><br><span class="line">	virtual void AddSonmething() = 0;//加料</span><br><span class="line">&#125;;</span><br><span class="line">//模板方法</span><br><span class="line">void Make() &#123;</span><br><span class="line">	this-&gt;BoilWater();</span><br><span class="line">	this-&gt;Brew() ;</span><br><span class="line">	this-&gt;PourInCup() ;</span><br><span class="line">	this-&gt;AddSonmething();</span><br><span class="line">&#125;</span><br><span class="line">//制作茶水</span><br><span class="line">class Tea : public DrinkTemplate&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void BoilWater()&#123;</span><br><span class="line">		cout &lt;&lt;&quot;煮开水!&quot;&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void Brew()&#123;</span><br><span class="line">		cout &lt;&lt;&quot;冲泡茶叶!&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void PourInCup()&#123;</span><br><span class="line">		cout &lt;&lt;&quot;茶水倒入杯中!&quot;&lt;&lt; endl ;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void AddSonmething()&#123;</span><br><span class="line">		cout &lt;&lt;“加入柠檬!&quot;”&lt;&lt;endl ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">优点:</span><br><span class="line">(1)在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序。</span><br><span class="line">(2)模板方法模式是一种代码复用技术，它在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中,而通过其子类来实现不同的行为，它鼓励我们恰当使用继承来实现代码复用。</span><br><span class="line">(3)可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否要执行。</span><br><span class="line">(4)在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则。</span><br></pre></td></tr></table></figure>

<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式定义了一系列的算法，并将每一个算法封装起来而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//武器策略</span><br><span class="line">class WeaponStrategy&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void UseWeapon() =0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//匕首策略</span><br><span class="line">class KnifeStrategy : public WeaponStrategy&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void UseWeapon() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;使用匕首!&quot;&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Character &#123;</span><br><span class="line">public:</span><br><span class="line">	//设置武器策略</span><br><span class="line">	void setWeaponStrategy(WeaponStrategy* weaponStrategy) &#123;</span><br><span class="line">		pWeaponStrategy = weaponStrategy;</span><br><span class="line">	&#125;</span><br><span class="line">	void UseWeapon() &#123;</span><br><span class="line">		WeaponStrategy-&gt;UseWeapon() ;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	WeaponStrategy* pWeaponStrategy;</span><br><span class="line">&#125;;</span><br><span class="line">void test02()&#123;</span><br><span class="line">	Character* character = new Character;//创建角色</span><br><span class="line">	WeaponStrategy* strategy = NULL;//武器策略</span><br><span class="line">	cout &lt;&lt; &quot;---------------使用匕首策略--——-----------&quot; &lt;&lt; endl;</span><br><span class="line">	strategy = new KnifeStrategy;//创建匕首策略</span><br><span class="line">	character-&gt;setWeaponStrategy(strategy); //设置武器策略为匕首策略</span><br><span class="line">	character-&gt;UseWeapon() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化;对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。<br>命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">//协议处理类</span><br><span class="line">class HandleClientProtocol&#123;</span><br><span class="line">public:</span><br><span class="line">	//处理增加金币</span><br><span class="line">	void AddMoney() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;给玩家增加金币!&quot; &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	//处理增加钻石</span><br><span class="line">	void AddDiamond() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;给玩家增加钻石!&quot;&lt;&lt;end1;</span><br><span class="line">	&#125;</span><br><span class="line">	//处理玩家装备</span><br><span class="line">	void AddEquipment () &#123;</span><br><span class="line">		cout &lt;&lt;&quot;给玩家穿装备! &quot; &lt;&lt;end1;</span><br><span class="line">	&#125;</span><br><span class="line">	//处理玩家升级</span><br><span class="line">	void addLeve1() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;给玩家升级!&quot;&lt;&lt; end1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//命令接口</span><br><span class="line">class AbstractCommand&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void handle() = 0;//处理客户端请求的接口</span><br><span class="line">&#125;</span><br><span class="line">//处理增加金币请求</span><br><span class="line">c1ass AddMoneyCommand :public AbstractCommand &#123;</span><br><span class="line">public:</span><br><span class="line">	AddMoneyCommand(HandleClientProtocol* protocol)&#123;</span><br><span class="line">		this-&gt;pProtocol = protocol;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void handle() &#123;</span><br><span class="line">		this-&gt;pProtoco1-&gt;AddMoney() ;</span><br><span class="line">public:</span><br><span class="line">	HandleClientProtocol* pProtoco1;</span><br><span class="line">&#125;;</span><br><span class="line">//处理增加钻石的请求</span><br><span class="line">class AddDiamondCommand :public AbstractCommand &#123;</span><br><span class="line">public:</span><br><span class="line">	AddDiamondCommand(HandleClientProtocol* protoco1)&#123;</span><br><span class="line">		this-&gt;pProtocol = protocol;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void handle() &#123;</span><br><span class="line">		this-&gt;pProtoco1-&gt;AddDiamond () ;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	HandleClientProtocol* pProtocol;</span><br><span class="line">&#125;;</span><br><span class="line">//服务器程序</span><br><span class="line">class Serser&#123;</span><br><span class="line">public:</span><br><span class="line">	void addRequest(AbstractCommand* command)&#123;</span><br><span class="line">		mCommands. push(command) ;</span><br><span class="line">	&#125;</span><br><span class="line">	void startHandle() &#123;</span><br><span class="line">		while (!mCommands.empty())&#123;</span><br><span class="line">			AbstractCommand* command =mCommands.front() ;</span><br><span class="line">			command-&gt;handle();</span><br><span class="line">			mCommands.pop();</span><br><span class="line">		&#125;</span><br><span class="line">public:</span><br><span class="line">	queue&lt;AbstractCommand*&gt; mCommands;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()&#123;</span><br><span class="line">	HandleClientProtocol* protocol = new HandleClientProtocol;</span><br><span class="line">	//客户端增加金币的请求</span><br><span class="line">	AbstractCommand* addmoney = new AddMoneyCommand(protocol);</span><br><span class="line">	//客户端增加钻石的请求</span><br><span class="line">	AbstractCommand* adddiamond = new AddDiamondCommand(protocol);</span><br><span class="line">	addmoney-&gt;handle();</span><br><span class="line">	adddiamond-&gt;handle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>随着交通信号灯的变化，汽车的行为也将随之而变化，一盏交通信号灯可以指挥多辆汽车。<br>观察者模式是用于建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象,其他对象将相应作出反应。在观察者模式中，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">class AbstractHero&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void Update()= 0;</span><br><span class="line">&#125;;</span><br><span class="line">class HeroA : public AbstractHero&#123;</span><br><span class="line">public:</span><br><span class="line">	HeroA() &#123;</span><br><span class="line">		cout &lt;&lt;“英雄A正在措BOSs ...&quot;&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void Update() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;英雄A停止打,待机状态...&quot; &lt;&lt; end1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class HeroB :public AbstractHero&#123;</span><br><span class="line">public:</span><br><span class="line">	HeroB() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;英雄B正在打BOSs ...&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void Update() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;英雄B停止打,待机状态...&quot;&lt;&lt; end1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//观察目标抽象</span><br><span class="line">class AbstractBoss&#123;</span><br><span class="line">public:</span><br><span class="line">//添加观察者</span><br><span class="line">	virtual void addHero(AbstractHero* hero)= 0;//删除观察者</span><br><span class="line">	virtual void deleteHero(AbstractHero* hero) = 0;//通知所有观察者</span><br><span class="line">	virtual void notify() = 0;</span><br><span class="line">&#125;;</span><br><span class="line">//具体的观察者BOSSA</span><br><span class="line">class BOSSA : public AbstractBoss&#123; </span><br><span class="line">public:</span><br><span class="line">	virtual void addHero(AbstractHero* hero)&#123;</span><br><span class="line">		pHeroList.push_back(hero);</span><br><span class="line">	&#125;</span><br><span class="line">//删除观察者</span><br><span class="line">	virtual void deleteHero(AbstractHero* hero)&#123;</span><br><span class="line">		pHeroList.remove(hero) ;</span><br><span class="line">	&#125;</span><br><span class="line">//通知所有观察者</span><br><span class="line">	virtual void notify() &#123;</span><br><span class="line">		for (list&lt;AbstractHero*&gt; ::iterator it = pHeroList.begin(); it != pHeroList.end();it++)</span><br><span class="line">			(*it)-&gt;Update();</span><br><span class="line">public:</span><br><span class="line">	list&lt;AbstractHero*&gt; pHeroList;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()&#123;</span><br><span class="line">	//创建观察者</span><br><span class="line">	AbstractHero* heroA = new HeroA;</span><br><span class="line">	AbstractHero* heroB = new HeroB;</span><br><span class="line">	AbstractHero* heroC= new HeroC;</span><br><span class="line">	AbstractHero* heroD= new HeroD;</span><br><span class="line">	AbstractHero* heroE = new HeroE; </span><br><span class="line">	//创建观察目标</span><br><span class="line">	AbstractBoss* bossA = new BOSSA;</span><br><span class="line">	bossA-&gt;addHero(heroA);</span><br><span class="line">	bossA-&gt;addHero(heroB);</span><br><span class="line">	bossA-&gt;addHero(heroC);</span><br><span class="line">	bossA-&gt;addHero(heroD);</span><br><span class="line">	bossA-&gt;addHero(heroE);</span><br><span class="line">	cout &lt;&lt; &quot;heroC阵亡...&quot; &lt;&lt;endl;</span><br><span class="line">	bossA-&gt;deleteHero(heroC);</span><br><span class="line">	cout &lt;&lt; &quot;Boss死了...通知其他英雄停止攻击，抢装备...&quot;&lt;&lt; end1;</span><br><span class="line">	bossA-&gt;notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>装饰模式又叫包装模式，通过一种对客户端透明的方式来扩展对象功能，是继承关系的一种替代。<br>装饰模式就是把要附加的功能努别放在单独的类中，并让这个类包含它要装饰的对象，当需要执行时，客户端就可以有选择的、按顺序的使用装饰功能包装对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">//一般情况下用继承实现类的功能拓展/装饰模式可以动态给一个类增加功能</span><br><span class="line">//抽象英雄</span><br><span class="line">class AbstractHero&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void ShowStatus() = 0;</span><br><span class="line">public:</span><br><span class="line">	int mHp;</span><br><span class="line">	int mMp;</span><br><span class="line">	int mAt;</span><br><span class="line">	int mDf ;</span><br><span class="line">&#125;;</span><br><span class="line">//具体英雄</span><br><span class="line">class HeroA : public AbstractHero&#123;</span><br><span class="line">public:</span><br><span class="line">	HeroA()&#123;</span><br><span class="line">		mHp= 0 ;</span><br><span class="line">		mMp= 0 ;</span><br><span class="line">		mAt= 0 ;</span><br><span class="line">		mDf= 0 ;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	virtual void ShowStatus() &#123;</span><br><span class="line">		cout&lt;&quot;血量:&quot;&lt;&lt; mHp &lt;&lt; end1;</span><br><span class="line">		cout &lt;&lt;&quot;魔法:&quot;&lt;&lt; mMp &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt;&quot;攻击:&quot;&lt;&lt; mAt&lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt;&quot;防御:&quot;&lt;&lt; mDf&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//英雄穿上某个装饰物那么他还是个英雄</span><br><span class="line">class AbstractEquipment : public AbstractHero&#123;</span><br><span class="line">public:</span><br><span class="line">	AbstractEquipment(AbstractHero* hero)&#123;</span><br><span class="line">		this-&gt;pHero = hero;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void ShowStatus() &#123;&#125;</span><br><span class="line">public:</span><br><span class="line">	AbstractHero* pHero;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//狂徒</span><br><span class="line">class KuangtuEquipment : public AbstractEquipment &#123;</span><br><span class="line">public:</span><br><span class="line">	KuangtuEquipment(AbstractHero* hero) :AbstractEquipment(hero)&#123;&#125;//依赖基类的构造函数来完成部分数据成员的初始化</span><br><span class="line">	//增加额外功能</span><br><span class="line">	void AddKuangtu() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;英雄穿上狂徒之后...&quot;&lt;&lt;endl;</span><br><span class="line">		this-&gt;mHp = this-&gt;pHero-&gt;mHp ;</span><br><span class="line">		this-&gt;mMpI= this-&gt;pHero-&gt;mMp ;</span><br><span class="line">		this-&gt;mAt = this-&gt;pHero-&gt;mAt ;</span><br><span class="line">		this-&gt;mDf = this-&gt;pHero-&gt;mDf + 30;</span><br><span class="line">		delete this-&gt;pHero;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void ShowStatus() &#123;</span><br><span class="line">		AddKuangtu();//额外增加功能</span><br><span class="line">		cout &lt;&lt;&quot;血量:&quot;&lt;&lt; mHp &lt;&lt; endl;</span><br><span class="line">		cout&lt;&lt;&quot;魔法:&quot;&lt;&lt; mMp &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt;&quot;攻击:&quot;&lt;&lt; mAt &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt;&quot;&quot;防御:&quot;&lt;&lt; mDf &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test01 ()&#123;</span><br><span class="line">	AbstractHero* hero = new HeroA;</span><br><span class="line">	hero-&gt;ShowStatus() ;</span><br><span class="line">	cout &lt;&lt; &quot;—------―----&quot; &lt;&lt; endl;</span><br><span class="line">	//给裸奔的英雄穿上衣服</span><br><span class="line">	hero = new KuangtuEquipment (hero);</span><br><span class="line">	hero-&gt;ShowStatus () ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/18/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/18/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/" class="post-title-link" itemprop="url">Linux网络编程-web大练习-B/S</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-18 15:10:55" itemprop="dateCreated datePublished" datetime="2023-07-18T15:10:55+08:00">2023-07-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-20 17:10:28" itemprop="dateModified" datetime="2023-07-20T17:10:28+08:00">2023-07-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="http协议请求、应答协议基础格式"><a href="#http协议请求、应答协议基础格式" class="headerlink" title="http协议请求、应答协议基础格式"></a>http协议请求、应答协议基础格式</h2><h3 id="HITP协议基础"><a href="#HITP协议基础" class="headerlink" title="HITP协议基础"></a>HITP协议基础</h3><p>HTTP，超文本传输协议（ HyperText Transfer Protocol )。互联网应用最为广泛的一种网络应用层协议。它可以减少网络传输，使浏览器更加高效。</p>
<p>通常HTTP消息包括客户机向服务器的请求消息和服务器向客户机的响应消息。</p>
<h3 id="请求消息-Request"><a href="#请求消息-Request" class="headerlink" title="请求消息(Request)"></a>请求消息(Request)</h3><p>浏览器—&gt;发给—&gt;服务器。主旨内容包含4部分: </p>
<ul>
<li>请求行:说明请求类型，要访问的资源，以及使用的http版本。                                                                                                                                         </li>
<li>请求头:说明服务器要使用的附加信息</li>
<li>空行:必须!，即使没有请求数据</li>
<li>请求数据:也叫主体，可以添加任意的其他数据</li>
</ul>
<p><img src="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230718151435496.png" alt="image-20230718151435496"></p>
<img src="/2023/07/18/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230718151435496.png" class title="This is an test image">

<h3 id="响应消息-Response"><a href="#响应消息-Response" class="headerlink" title="响应消息(Response)"></a>响应消息(Response)</h3><p>服务器―&gt;发给―&gt;浏览器。主旨内容包含4部分: </p>
<ul>
<li>状态行:包括http协议版本号，状态码，状态信息</li>
<li>消息报头:说明客户端要使用的一些附加信息</li>
<li>空行:必须!</li>
<li>响应正文:服务器返回给客户端的文本信息</li>
</ul>
<p><img src="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230718151614718.png" alt="image-20230718151614718"></p>
<img src="/2023/07/18/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230718151614718.png" class title="This is an test image">

<p><img src="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230718151728604.png" alt="image-20230718151728604"></p>
<img src="/2023/07/18/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230718151728604.png" class title="This is an test image">

<h2 id="服务器框架复习和getline函数"><a href="#服务器框架复习和getline函数" class="headerlink" title="服务器框架复习和getline函数"></a>服务器框架复习和getline函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;netinet/in.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">#include &lt;sys/wait.h&gt;  </span><br><span class="line">#include &lt;sys/types.h&gt;  </span><br><span class="line">#include &lt;sys/epoll.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;fcntl.h&gt;  </span><br><span class="line">  </span><br><span class="line">#define MAXSIZE 2048  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">int init_listen_fd(int port, int epfd)  </span><br><span class="line">&#123;  </span><br><span class="line">    //　创建监听的套接字 lfd  </span><br><span class="line">    int lfd = socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">    if (lfd == -1) &#123;      </span><br><span class="line">        perror(&quot;socket error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">    // 创建服务器地址结构 IP+port  </span><br><span class="line">    struct sockaddr_in srv_addr;  </span><br><span class="line">      </span><br><span class="line">    bzero(&amp;srv_addr, sizeof(srv_addr));  </span><br><span class="line">    srv_addr.sin_family = AF_INET;  </span><br><span class="line">    srv_addr.sin_port = htons(port);  </span><br><span class="line">    srv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">  </span><br><span class="line">    // 端口复用  </span><br><span class="line">    int opt = 1;  </span><br><span class="line">    setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt));  </span><br><span class="line">      </span><br><span class="line">    // 给 lfd 绑定地址结构  </span><br><span class="line">    int ret = bind(lfd, (struct sockaddr*)&amp;srv_addr, sizeof(srv_addr));  </span><br><span class="line">    if (ret == -1) &#123;     </span><br><span class="line">        perror(&quot;bind error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">    // 设置监听上限  </span><br><span class="line">    ret = listen(lfd, 128);  </span><br><span class="line">    if (ret == -1) &#123;   </span><br><span class="line">        perror(&quot;listen error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    // lfd 添加到 epoll 树上  </span><br><span class="line">    struct epoll_event ev;  </span><br><span class="line">    ev.events = EPOLLIN;  </span><br><span class="line">    ev.data.fd = lfd;  </span><br><span class="line">      </span><br><span class="line">    ret = epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;ev);  </span><br><span class="line">    if (ret == -1) &#123;   </span><br><span class="line">        perror(&quot;epoll_ctl add lfd error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return lfd;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void do_accept(int lfd, int epfd)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct sockaddr_in clt_addr;  </span><br><span class="line">    socklen_t clt_addr_len = sizeof(clt_addr);  </span><br><span class="line">      </span><br><span class="line">    int cfd = accept(lfd, (struct sockaddr*)&amp;clt_addr, &amp;clt_addr_len);  </span><br><span class="line">    if (cfd == -1) &#123;     </span><br><span class="line">        perror(&quot;accept error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // 打印客户端IP+port  </span><br><span class="line">    char client_ip[64] = &#123;0&#125;;  </span><br><span class="line">    printf(&quot;New Client IP: %s, Port: %d, cfd = %d\n&quot;,  </span><br><span class="line">           inet_ntop(AF_INET, &amp;clt_addr.sin_addr.s_addr, client_ip, sizeof(client_ip)),  </span><br><span class="line">           ntohs(clt_addr.sin_port), cfd);  </span><br><span class="line">  </span><br><span class="line">    // 设置 cfd 非阻塞  </span><br><span class="line">    int flag = fcntl(cfd, F_GETFL);  </span><br><span class="line">    flag |= O_NONBLOCK;  </span><br><span class="line">    fcntl(cfd, F_SETFL, flag);  </span><br><span class="line">  </span><br><span class="line">    // 将新节点cfd 挂到 epoll 监听树上  </span><br><span class="line">    struct epoll_event ev;  </span><br><span class="line">    ev.data.fd = cfd;  </span><br><span class="line">      </span><br><span class="line">    // 边沿非阻塞模式  </span><br><span class="line">    ev.events = EPOLLIN | EPOLLET;  </span><br><span class="line">      </span><br><span class="line">    int ret = epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;ev);  </span><br><span class="line">    if (ret == -1)  &#123;  </span><br><span class="line">        perror(&quot;epoll_ctl add cfd error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void do_read(int cfd, int epfd)  </span><br><span class="line">&#123;  </span><br><span class="line">    // read cfd 小 -- 大 write 回  </span><br><span class="line">    // 读取一行http协议， 拆分， 获取 get 文件名 协议号  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void epoll_run(int port)  </span><br><span class="line">&#123;  </span><br><span class="line">    int i = 0;  </span><br><span class="line">    struct epoll_event all_events[MAXSIZE];  </span><br><span class="line">  </span><br><span class="line">    // 创建一个epoll监听树根  </span><br><span class="line">    int epfd = epoll_create(MAXSIZE);  </span><br><span class="line">    if (epfd == -1) &#123;   </span><br><span class="line">        perror(&quot;epoll_create error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    // 创建lfd，并添加至监听树  </span><br><span class="line">    int lfd = init_listen_fd(port, epfd);  </span><br><span class="line">     </span><br><span class="line">    while (1) &#123;  </span><br><span class="line">        // 监听节点对应事件  </span><br><span class="line">        int ret = epoll_wait(epfd, all_events, MAXSIZE, -1);  </span><br><span class="line">        if (ret == -1) &#123;        </span><br><span class="line">            perror(&quot;epoll_wait error&quot;);  </span><br><span class="line">            exit(1);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        for (i=0; i&lt;ret; ++i) &#123;  </span><br><span class="line">                  </span><br><span class="line">            // 只处理读事件, 其他事件默认不处理  </span><br><span class="line">            struct epoll_event *pev = &amp;all_events[i];  </span><br><span class="line">              </span><br><span class="line">            // 不是读事件  </span><br><span class="line">            if (!(pev-&gt;events &amp; EPOLLIN)) &#123;                       </span><br><span class="line">                continue;  </span><br><span class="line">            &#125;  </span><br><span class="line">            if (pev-&gt;data.fd == lfd) &#123;       // 接受连接请求     </span><br><span class="line">                  </span><br><span class="line">                do_accept(lfd, epfd);  </span><br><span class="line">                  </span><br><span class="line">            &#125; else &#123;                        // 读数据  </span><br><span class="line">                  </span><br><span class="line">                do_read(pev-&gt;data.fd, epfd);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;   </span><br><span class="line">    // 命令行参数获取 端口 和 server提供的目录  </span><br><span class="line">    if (argc &lt; 3)   </span><br><span class="line">    &#123;  </span><br><span class="line">        printf(&quot;./server port path\n&quot;);   </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    // 获取用户输入的端口   </span><br><span class="line">    int port = atoi(argv[1]);  </span><br><span class="line">      </span><br><span class="line">    // 改变进程工作目录  </span><br><span class="line">    int ret = chdir(argv[2]);  </span><br><span class="line">    if (ret != 0) &#123;  </span><br><span class="line">        perror(&quot;chdir error&quot;);    </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // 启动 epoll监听  </span><br><span class="line">    epoll_run(port);  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="单文件通信流程分析"><a href="#单文件通信流程分析" class="headerlink" title="单文件通信流程分析"></a>单文件通信流程分析</h2><ol>
<li><p>getline() 获取 http协议的第一行。</p>
</li>
<li><p>从首行中拆分  GET、文件名、协议版本。 获取用户请求的文件名。</p>
</li>
<li><p>判断文件是否存在。 stat()</p>
</li>
<li><p>判断是文件还是目录。</p>
</li>
<li><p>是文件– open – read – 写回给浏览器</p>
</li>
<li><p>先写 http 应答协议头 ： 	http&#x2F;1.1 200 ok</p>
<pre><code>         Content-Type：text/plain; charset=iso-8859-1
</code></pre>
</li>
</ol>
<h3 id="正则表达式获取文件名"><a href="#正则表达式获取文件名" class="headerlink" title="正则表达式获取文件名"></a>正则表达式获取文件名</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void do_read(int cfd, int epfd)  </span><br><span class="line">&#123;  </span><br><span class="line">    // 读取一行http协议， 拆分， 获取 get 文件名 协议号     </span><br><span class="line">    char line[1024] = &#123;0&#125;;  </span><br><span class="line">    char method[16], path[256], protocol[16];   </span><br><span class="line">      </span><br><span class="line">    int len = get_line(cfd, line, sizeof(line)); //读 http请求协议首行 GET /hello.c HTTP/1.1  </span><br><span class="line">    if (len == 0) &#123;  </span><br><span class="line">        printf(&quot;服务器，检查到客户端关闭....\n&quot;);     </span><br><span class="line">        disconnect(cfd, epfd);  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">                  </span><br><span class="line">        sscanf(line, &quot;%[^ ] %[^ ] %[^ ]&quot;, method, path, protocol);    //%[^ ]取遇到空格为止的字符串</span><br><span class="line">        printf(&quot;method=%s, path=%s, protocol=%s\n&quot;, method, path, protocol);  </span><br><span class="line">          </span><br><span class="line">        while (1) &#123;  </span><br><span class="line">            char buf[1024] = &#123;0&#125;;  </span><br><span class="line">            len = get_line(cfd, buf, sizeof(buf));    </span><br><span class="line">            if (buf[0] == &#x27;\n&#x27;) &#123;  </span><br><span class="line">                break;    </span><br><span class="line">            &#125; else if (len == -1)  </span><br><span class="line">                break;  </span><br><span class="line">        &#125;     </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    if (strncasecmp(method, &quot;GET&quot;, 3) == 0)  </span><br><span class="line">    &#123;  </span><br><span class="line">        char *file = path+1;   // 取出 客户端要访问的文件名  </span><br><span class="line">          </span><br><span class="line">        http_request(cfd, file);  </span><br><span class="line">          </span><br><span class="line">        disconnect(cfd, epfd);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230719143817230.png" alt="image-20230719143817230"></p>
<img src="/2023/07/18/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230719143817230.png" class title="This is an test image">

<h3 id="判断文件是否存在"><a href="#判断文件是否存在" class="headerlink" title="判断文件是否存在"></a>判断文件是否存在</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 处理http请求， 判断文件是否存在， 回发  </span><br><span class="line">void http_request(int cfd, const char *file)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct stat sbuf;  </span><br><span class="line">      </span><br><span class="line">    // 判断文件是否存在  </span><br><span class="line">    int ret = stat(file, &amp;sbuf);  </span><br><span class="line">    if (ret != 0) &#123;  </span><br><span class="line">        // 回发浏览器 404 错误页面  </span><br><span class="line">        perror(&quot;stat&quot;);  </span><br><span class="line">        exit(1);      </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    if(S_ISREG(sbuf.st_mode)) &#123;     // 是一个普通文件  </span><br><span class="line">          </span><br><span class="line">        // 回发 http协议应答  </span><br><span class="line">        //send_respond(cfd, 200, &quot;OK&quot;, &quot; Content-Type: text/plain; charset=iso-8859-1&quot;, sbuf.st_size);     </span><br><span class="line">        send_respond(cfd, 200, &quot;OK&quot;, &quot;Content-Type:image/jpeg&quot;, -1);  </span><br><span class="line">        //send_respond(cfd, 200, &quot;OK&quot;, &quot;audio/mpeg&quot;, -1);  </span><br><span class="line">          </span><br><span class="line">        // 回发 给客户端请求数据内容。  </span><br><span class="line">        send_file(cfd, file);  </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="写出http应答协议头"><a href="#写出http应答协议头" class="headerlink" title="写出http应答协议头"></a>写出http应答协议头</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">	// 客户端端的fd, 错误号，错误描述，回发文件类型， 文件长度   </span><br><span class="line">void send_respond(int cfd, int no, char *disp, char *type, int len)  </span><br><span class="line">&#123;  </span><br><span class="line">    char buf[4096] = &#123;0&#125;;  </span><br><span class="line">      </span><br><span class="line">    sprintf(buf, &quot;HTTP/1.1 %d %s\r\n&quot;, no, disp);  </span><br><span class="line">    send(cfd, buf, strlen(buf), 0);  </span><br><span class="line">      </span><br><span class="line">    sprintf(buf, &quot;Content-Type: %s\r\n&quot;, type);  </span><br><span class="line">    sprintf(buf+strlen(buf), &quot;Content-Length:%d\r\n&quot;, len);  </span><br><span class="line">    send(cfd, buf, strlen(buf), 0);  </span><br><span class="line">      </span><br><span class="line">    send(cfd, &quot;\r\n&quot;, 2, 0);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="写数据给浏览器"><a href="#写数据给浏览器" class="headerlink" title="写数据给浏览器"></a>写数据给浏览器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 发送服务器本地文件 给浏览器  </span><br><span class="line">void send_file(int cfd, const char *file)  </span><br><span class="line">&#123;  </span><br><span class="line">    int n = 0, ret;  </span><br><span class="line">    char buf[4096] = &#123;0&#125;;  </span><br><span class="line">      </span><br><span class="line">    // 打开的服务器本地文件。  --- cfd 能访问客户端的 socket  </span><br><span class="line">    int fd = open(file, O_RDONLY);  </span><br><span class="line">    if (fd == -1) &#123;  </span><br><span class="line">        // 404 错误页面  </span><br><span class="line">        perror(&quot;open error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    while ((n = read(fd, buf, sizeof(buf))) &gt; 0) &#123;         </span><br><span class="line">        ret = send(cfd, buf, n, 0);  </span><br><span class="line">        if (ret == -1) &#123;  </span><br><span class="line">            perror(&quot;send error&quot;);     </span><br><span class="line">            exit(1);  </span><br><span class="line">        &#125;  </span><br><span class="line">        if (ret &lt; 4096)        </span><br><span class="line">            printf(&quot;-----send ret: %d\n&quot;, ret);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    close(fd);        </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="错误页面展示"><a href="#错误页面展示" class="headerlink" title="错误页面展示"></a>错误页面展示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void send_error(int cfd, int status, char *title, char *text)  </span><br><span class="line">&#123;  </span><br><span class="line">    char buf[4096] = &#123;0&#125;;  </span><br><span class="line">  </span><br><span class="line">    sprintf(buf, &quot;%s %d %s\r\n&quot;, &quot;HTTP/1.1&quot;, status, title);  </span><br><span class="line">    sprintf(buf+strlen(buf), &quot;Content-Type:%s\r\n&quot;, &quot;text/html&quot;);  </span><br><span class="line">    sprintf(buf+strlen(buf), &quot;Content-Length:%d\r\n&quot;, -1);  </span><br><span class="line">    sprintf(buf+strlen(buf), &quot;Connection: close\r\n&quot;);  </span><br><span class="line">    send(cfd, buf, strlen(buf), 0);  </span><br><span class="line">    send(cfd, &quot;\r\n&quot;, 2, 0);  </span><br><span class="line">  </span><br><span class="line">    memset(buf, 0, sizeof(buf));  </span><br><span class="line">  </span><br><span class="line">    sprintf(buf, &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;%d %s&lt;/title&gt;&lt;/head&gt;\n&quot;, status, title);  </span><br><span class="line">    sprintf(buf+strlen(buf), &quot;&lt;body bgcolor=\&quot;#cc99cc\&quot;&gt;&lt;h2 align=\&quot;center\&quot;&gt;%d %s&lt;/h4&gt;\n&quot;, status, title);  </span><br><span class="line">    sprintf(buf+strlen(buf), &quot;%s\n&quot;, text);  </span><br><span class="line">    sprintf(buf+strlen(buf), &quot;&lt;hr&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n&quot;);  </span><br><span class="line">    send(cfd, buf, strlen(buf), 0);  </span><br><span class="line">      </span><br><span class="line">    return ;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="浏览器请求目录"><a href="#浏览器请求目录" class="headerlink" title="浏览器请求目录"></a>浏览器请求目录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// http请求处理  </span><br><span class="line">void http_request(const char* request, int cfd)  </span><br><span class="line">&#123;  </span><br><span class="line">    // 拆分http请求行  </span><br><span class="line">    char method[12], path[1024], protocol[12];  </span><br><span class="line">    sscanf(request, &quot;%[^ ] %[^ ] %[^ ]&quot;, method, path, protocol);  </span><br><span class="line">    printf(&quot;method = %s, path = %s, protocol = %s\n&quot;, method, path, protocol);  </span><br><span class="line">  </span><br><span class="line">    // 转码 将不能识别的中文乱码 -&gt; 中文  </span><br><span class="line">    // 解码 %23 %34 %5f  </span><br><span class="line">    decode_str(path, path);  </span><br><span class="line">          </span><br><span class="line">    char* file = path+1; // 去掉path中的/ 获取访问文件名  </span><br><span class="line">      </span><br><span class="line">    // 如果没有指定访问的资源, 默认显示资源目录中的内容  </span><br><span class="line">    if(strcmp(path, &quot;/&quot;) == 0) &#123;      </span><br><span class="line">        // file的值, 资源目录的当前位置  </span><br><span class="line">        file = &quot;./&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // 获取文件属性  </span><br><span class="line">    struct stat st;  </span><br><span class="line">    int ret = stat(file, &amp;st);  </span><br><span class="line">    if(ret == -1) &#123;   </span><br><span class="line">        send_error(cfd, 404, &quot;Not Found&quot;, &quot;NO such file or direntry&quot;);       </span><br><span class="line">        return;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // 判断是目录还是文件  </span><br><span class="line">    if(S_ISDIR(st.st_mode)) &#123;       // 目录   S_ISDIR是stat的内置函数可以用来判断</span><br><span class="line">        // 发送头信息  </span><br><span class="line">        send_respond_head(cfd, 200, &quot;OK&quot;, get_file_type(&quot;.html&quot;), -1);  </span><br><span class="line">        // 发送目录信息  </span><br><span class="line">        send_dir(cfd, file);  </span><br><span class="line">    &#125; else if(S_ISREG(st.st_mode)) &#123; // 文件          </span><br><span class="line">        // 发送消息报头  </span><br><span class="line">        send_respond_head(cfd, 200, &quot;OK&quot;, get_file_type(file), st.st_size);  </span><br><span class="line">        // 发送文件内容  </span><br><span class="line">        send_file(cfd, file);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="判断文件类型"><a href="#判断文件类型" class="headerlink" title="判断文件类型"></a>判断文件类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 通过文件名获取文件的类型  </span><br><span class="line">const char *get_file_type(const char *name)  </span><br><span class="line">&#123;  </span><br><span class="line">    char* dot;  </span><br><span class="line">  </span><br><span class="line">    // 自右向左查找‘.’字符, 如不存在返回NULL  </span><br><span class="line">    dot = strrchr(name, &#x27;.&#x27;);     </span><br><span class="line">    if (dot == NULL)  </span><br><span class="line">        return &quot;text/plain; charset=utf-8&quot;;  </span><br><span class="line">    if (strcmp(dot, &quot;.html&quot;) == 0 || strcmp(dot, &quot;.htm&quot;) == 0)  </span><br><span class="line">        return &quot;text/html; charset=utf-8&quot;;  </span><br><span class="line">    if (strcmp(dot, &quot;.jpg&quot;) == 0 || strcmp(dot, &quot;.jpeg&quot;) == 0)  </span><br><span class="line">        return &quot;image/jpeg&quot;;  </span><br><span class="line">    if (strcmp(dot, &quot;.gif&quot;) == 0)  </span><br><span class="line">        return &quot;image/gif&quot;;  </span><br><span class="line">    if (strcmp(dot, &quot;.png&quot;) == 0)  </span><br><span class="line">        return &quot;image/png&quot;;  </span><br><span class="line">    if (strcmp(dot, &quot;.css&quot;) == 0)  </span><br><span class="line">        return &quot;text/css&quot;;  </span><br><span class="line">    if (strcmp(dot, &quot;.au&quot;) == 0)  </span><br><span class="line">        return &quot;audio/basic&quot;;  </span><br><span class="line">    if (strcmp( dot, &quot;.wav&quot; ) == 0)  </span><br><span class="line">        return &quot;audio/wav&quot;;  </span><br><span class="line">    if (strcmp(dot, &quot;.avi&quot;) == 0)  </span><br><span class="line">        return &quot;video/x-msvideo&quot;;  </span><br><span class="line">    if (strcmp(dot, &quot;.mov&quot;) == 0 || strcmp(dot, &quot;.qt&quot;) == 0)  </span><br><span class="line">        return &quot;video/quicktime&quot;;  </span><br><span class="line">    if (strcmp(dot, &quot;.mpeg&quot;) == 0 || strcmp(dot, &quot;.mpe&quot;) == 0)  </span><br><span class="line">        return &quot;video/mpeg&quot;;  </span><br><span class="line">    if (strcmp(dot, &quot;.vrml&quot;) == 0 || strcmp(dot, &quot;.wrl&quot;) == 0)  </span><br><span class="line">        return &quot;model/vrml&quot;;  </span><br><span class="line">    if (strcmp(dot, &quot;.midi&quot;) == 0 || strcmp(dot, &quot;.mid&quot;) == 0)  </span><br><span class="line">        return &quot;audio/midi&quot;;  </span><br><span class="line">    if (strcmp(dot, &quot;.mp3&quot;) == 0)  </span><br><span class="line">        return &quot;audio/mpeg&quot;;  </span><br><span class="line">    if (strcmp(dot, &quot;.ogg&quot;) == 0)  </span><br><span class="line">        return &quot;application/ogg&quot;;  </span><br><span class="line">    if (strcmp(dot, &quot;.pac&quot;) == 0)  </span><br><span class="line">        return &quot;application/x-ns-proxy-autoconfig&quot;;  </span><br><span class="line">  </span><br><span class="line">    return &quot;text/plain; charset=utf-8&quot;;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230720165731522.png" alt="image-20230720165731522"></p>
<img src="/2023/07/18/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230720165731522.png" class title="This is an test image">

<p><img src="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230720165803959.png" alt="image-20230720165803959"></p>
<img src="/2023/07/18/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230720165803959.png" class title="This is an test image">

<h3 id="汉字字符编码和解码"><a href="#汉字字符编码和解码" class="headerlink" title="汉字字符编码和解码"></a>汉字字符编码和解码</h3><p>URL中的汉字默认是存为Unicode码</p>
<p><img src="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230720165842142.png" alt="image-20230720165842142"></p>
<img src="/2023/07/18/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230720165842142.png" class title="This is an test image">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// 16进制数转化为10进制</span><br><span class="line">int hexit(char c)</span><br><span class="line">&#123;</span><br><span class="line">    if (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;)</span><br><span class="line">        return c - &#x27;0&#x27;;</span><br><span class="line">    if (c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;f&#x27;)</span><br><span class="line">        return c - &#x27;a&#x27; + 10;</span><br><span class="line">    if (c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;F&#x27;)</span><br><span class="line">        return c - &#x27;A&#x27; + 10;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> *  这里的内容是处理%20之类的东西！是&quot;解码&quot;过程。</span><br><span class="line"> *  %20 URL编码中的‘ ’(space)</span><br><span class="line"> *  %21 &#x27;!&#x27; %22 &#x27;&quot;&#x27; %23 &#x27;#&#x27; %24 &#x27;$&#x27;</span><br><span class="line"> *  %25 &#x27;%&#x27; %26 &#x27;&amp;&#x27; %27 &#x27;&#x27;&#x27; %28 &#x27;(&#x27;......</span><br><span class="line"> *  相关知识html中的‘ ’(space)是&amp;nbsp</span><br><span class="line"> */</span><br><span class="line">void encode_str(char* to, int tosize, const char* from)</span><br><span class="line">&#123;</span><br><span class="line">    int tolen;</span><br><span class="line"></span><br><span class="line">    for (tolen = 0; *from != &#x27;\0&#x27; &amp;&amp; tolen + 4 &lt; tosize; ++from) &#123;    </span><br><span class="line">        if (isalnum(*from) || strchr(&quot;/_.-~&quot;, *from) != (char*)0) &#123;      </span><br><span class="line">            *to = *from;</span><br><span class="line">            ++to;</span><br><span class="line">            ++tolen;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sprintf(to, &quot;%%%02x&quot;, (int) *from &amp; 0xff);</span><br><span class="line">            to += 3;</span><br><span class="line">            tolen += 3;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *to = &#x27;\0&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void decode_str(char *to, char *from)</span><br><span class="line">&#123;</span><br><span class="line">    for ( ; *from != &#x27;\0&#x27;; ++to, ++from  ) &#123;     </span><br><span class="line">        if (from[0] == &#x27;%&#x27; &amp;&amp; isxdigit(from[1]) &amp;&amp; isxdigit(from[2])) &#123;       </span><br><span class="line">            *to = hexit(from[1])*16 + hexit(from[2]);</span><br><span class="line">            from += 2;                      </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            *to = *from;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *to = &#x27;\0&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="浏览器请求ico"><a href="#浏览器请求ico" class="headerlink" title="浏览器请求ico"></a>浏览器请求ico</h2><p>准备一个favicon.ico文件放置到服务器提供访问的资源目录中。<br>浏览器在请求图片的同时，会请求一个ico图标，用于浏览器<code>&lt;title&gt;</code>标签文字部分前端的小图标显示。<br>这个ico的文件名固定——favicon.ico。因此自行准备一个ico文件,放置于服务器提供给浏览器访问的目标目录即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">favicon.ico 图标用于收藏夹图标和浏览器标签上的显示，如果不设置，浏览器会请求网站根目录的这个图标，如果网站根目录也没有这图标会产生 404。出于优化的考虑，要么就有这个图标，要么就禁止产生这个请求。</span><br><span class="line">在做 H5 混合应用的时候，不希望产生 favicon.ico 的请求。</span><br><span class="line">可以在页面的 &lt;head&gt; 区域，加上如下代码实现屏蔽：</span><br><span class="line">&lt;link rel=&quot;icon&quot; href=&quot;data:;base64,=&quot;&gt;，或者详细一点&lt;link rel=&quot;icon&quot; href=&quot;data:image/ico;base64,aWNv&quot;&gt;，当然，既然是 dataURL 方式，IE &lt; 8 等 old brower 就别想了</span><br></pre></td></tr></table></figure>

<h3 id="容错处理"><a href="#容错处理" class="headerlink" title="容错处理"></a>容错处理</h3><p>返回值一定要检查!!!.<br>尤其是 read、write、recv、send、recvfrom、sendto函数，返回的errno为 EINTR和EAGAIN时，不代表是一个错误，但会严重影响程序运行结果!通常使用continue来处理这种情况即可。</p>
<h2 id="快捷遍历目录scandir"><a href="#快捷遍历目录scandir" class="headerlink" title="快捷遍历目录scandir()"></a>快捷遍历目录scandir()</h2><p>服务器端，可以使用文件操作时”递归遍历目录的”源码，实现遍历目录内文件名，回显给浏览器。另外标准C库中,提供了scandir函数,可以便捷的实现该功能。函数原型如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int scandir(const char *dirp, struct dirent ***namelist,int (*filter)(const struct dirent *),int (*compar)(const struct dirent **, const struct dirent **));+</span><br><span class="line">scandir(待操作的目录，&amp;子目录项列表数组，过滤器(通常NULL)， alphasort) dirp:待访问的目录名称</span><br><span class="line">struct dirent类型:(参考readdir()函数)。</span><br></pre></td></tr></table></figure>

<p><img src="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230720155912787.png" alt="image-20230720155912787"></p>
<img src="/2023/07/18/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230720155912787.png" class title="This is an test image">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">compar:参数取如下函数即可:</span><br><span class="line">int alphasort(const void *a, const void *b);默认是由的排序算法。</span><br><span class="line">调用:struct dirent** namelist;</span><br><span class="line">int num = scandir(dirname,&amp;namlelist,NULL, alphasort);</span><br><span class="line">for (i = 0;i &lt; num;++i)</span><br><span class="line">	char* name = namelist[i]-&gt;d_name;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">// 发送目录内容</span><br><span class="line">void send_dir(int cfd, const char* dirname)</span><br><span class="line">&#123;</span><br><span class="line">    int i, ret;</span><br><span class="line"></span><br><span class="line">    // 拼一个html页面&lt;table&gt;&lt;/table&gt;</span><br><span class="line">    char buf[4094] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">    sprintf(buf, &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;目录名: %s&lt;/title&gt;&lt;/head&gt;&quot;, dirname);</span><br><span class="line">    sprintf(buf+strlen(buf), &quot;&lt;body&gt;&lt;h1&gt;当前目录: %s&lt;/h1&gt;&lt;table&gt;&quot;, dirname);</span><br><span class="line"></span><br><span class="line">    char enstr[1024] = &#123;0&#125;;</span><br><span class="line">    char path[1024] = &#123;0&#125;;</span><br><span class="line">    </span><br><span class="line">    // 目录项二级指针</span><br><span class="line">    struct dirent** ptr;</span><br><span class="line">    int num = scandir(dirname, &amp;ptr, NULL, alphasort);</span><br><span class="line">    </span><br><span class="line">    // 遍历</span><br><span class="line">    for(i = 0; i &lt; num; ++i) &#123;</span><br><span class="line">    </span><br><span class="line">        char* name = ptr[i]-&gt;d_name;</span><br><span class="line"></span><br><span class="line">        // 拼接文件的完整路径</span><br><span class="line">        sprintf(path, &quot;%s/%s&quot;, dirname, name);</span><br><span class="line">        printf(&quot;path = %s ===================\n&quot;, path);</span><br><span class="line">        struct stat st;</span><br><span class="line">        stat(path, &amp;st);</span><br><span class="line"></span><br><span class="line">		// 编码生成 %E5 %A7 之类的东西</span><br><span class="line">        encode_str(enstr, sizeof(enstr), name);</span><br><span class="line">        </span><br><span class="line">        // 如果是文件</span><br><span class="line">        if(S_ISREG(st.st_mode)) &#123;       </span><br><span class="line">            sprintf(buf+strlen(buf), </span><br><span class="line">                    &quot;&lt;tr&gt;&lt;td&gt;&lt;a href=\&quot;%s\&quot;&gt;%s&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;&quot;,</span><br><span class="line">                    enstr, name, (long)st.st_size);</span><br><span class="line">        &#125; else if(S_ISDIR(st.st_mode)) &#123;		// 如果是目录       </span><br><span class="line">            sprintf(buf+strlen(buf), </span><br><span class="line">                    &quot;&lt;tr&gt;&lt;td&gt;&lt;a href=\&quot;%s/\&quot;&gt;%s/&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;&quot;,</span><br><span class="line">                    enstr, name, (long)st.st_size);</span><br><span class="line">        &#125;</span><br><span class="line">        ret = send(cfd, buf, strlen(buf), 0);</span><br><span class="line">        if (ret == -1) &#123;</span><br><span class="line">            if (errno == EAGAIN) &#123;</span><br><span class="line">                perror(&quot;send error:&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125; else if (errno == EINTR) &#123;</span><br><span class="line">                perror(&quot;send error:&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                perror(&quot;send error:&quot;);</span><br><span class="line">                exit(1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memset(buf, 0, sizeof(buf));</span><br><span class="line">        // 字符串拼接</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sprintf(buf+strlen(buf), &quot;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;&quot;);</span><br><span class="line">    send(cfd, buf, strlen(buf), 0);</span><br><span class="line"></span><br><span class="line">    printf(&quot;dir message send OK!!!!\n&quot;);</span><br><span class="line">#if 0</span><br><span class="line">    // 打开目录</span><br><span class="line">    DIR* dir = opendir(dirname);</span><br><span class="line">    if(dir == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;opendir error&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 读目录</span><br><span class="line">    struct dirent* ptr = NULL;</span><br><span class="line">    while( (ptr = readdir(dir)) != NULL )</span><br><span class="line">    &#123;</span><br><span class="line">        char* name = ptr-&gt;d_name;</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dir);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="telnet调试"><a href="#telnet调试" class="headerlink" title="telnet调试"></a>telnet调试</h2><p><img src="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230720171014596.png" alt="image-20230720171014596"></p>
<img src="/2023/07/18/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230720171014596.png" class title="This is an test image">

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/15/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/15/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent/" class="post-title-link" itemprop="url">Linux网络编程-libevent</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-15 16:35:58" itemprop="dateCreated datePublished" datetime="2023-07-15T16:35:58+08:00">2023-07-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-26 16:08:35" itemprop="dateModified" datetime="2023-07-26T16:08:35+08:00">2023-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="static修饰的函数作用与意义"><a href="#static修饰的函数作用与意义" class="headerlink" title="static修饰的函数作用与意义"></a>static修饰的函数作用与意义</h2><p>static修饰的函数叫做静态函数，静态函数有两种，根据其出现的地方来分类：</p>
<p>如果这个静态函数出现在类里，那么它是一个静态成员函数；<br>        静态成员函数的作用在于：<strong>调用这个函数不会访问或者修改任何对象（非static）数据成员。</strong></p>
<p>​    其实很好理解，类的静态成员(变量和方法)属于类本身，在类加载的时候就会分配内存，可以通过类名直接去访问；非静态成员（变量和方法）属于类的对象，所以只有在类的对象产生（创建类的实例）时才会分配内存，然后通过类的对象（实例）去访问。</p>
<p>如果它不是出现在类中，那么它是一个普通的全局的静态函数。<br>        这样的static函数与普通函数的区别是：用static修饰的函数，限定在本源码文件中，不能被本源码文件以外的代码文件调用。而普通的函数，默认是extern的，也就是说它可以被其它代码文件调用。<br>　　在函数的返回类型前加上关键字static，函数就被定义成为静态函数。普通 函数的定义和声明默认情况下是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。因此定义静态函数有以下好处：<br>　　&lt;1&gt; 其他文件中可以定义相同名字的函数，不会发生冲突。<br>　　&lt;2&gt; 静态函数不能被其他文件所用。</p>
<p>在C++中，静态成员函数（static function）是与类关联的函数，而不是与类的实例对象关联的。它们可以直接通过类名调用，无需创建类的实例。</p>
<p>静态成员函数在以下几种情况下被调用：</p>
<ol>
<li>通过类名调用：静态成员函数可以通过类名直接调用，而不需要通过类的实例对象。这样调用时，它们与普通的全局函数类似，没有隐含的 this 指针。例如：<code>ClassName::staticFunction()</code>。</li>
<li>在类内部调用：静态成员函数可以在类的其他成员函数中被调用，包括其他静态成员函数和非静态成员函数。</li>
<li>在类的派生类中调用：派生类可以通过类名或派生类名直接调用继承的静态成员函数。</li>
</ol>
<p>需要注意的是，静态成员函数只能访问类的静态成员变量和其他静态成员函数，不能直接访问类的非静态成员变量和非静态成员函数。静态成员函数也没有访问权限限定符（public、private、protected）的限制。</p>
<p>静态成员函数的主要作用是为了某些与类相关的功能提供一个公共的接口，不依赖于类的实例化。常见的用途包括实现工具函数、访问类的静态成员变量等</p>
<h2 id="libevent简介"><a href="#libevent简介" class="headerlink" title="libevent简介"></a>libevent简介</h2><p>libevent库</p>
<p>  开源。精简。跨平台（Windows、Linux、maxos、unix）。专注于网络通信。</p>
<p>源码包安装： 参考 README、readme</p>
<p>  .&#x2F;configure    检查安装环境 生成 makefile</p>
<p>  make     生成 .o 和 可执行文件 </p>
<p>  sudo make install 将必要的资源cp置系统指定目录。</p>
<p>  进入 sample 目录，运行demo验证库安装使用情况。 </p>
<p>  编译使用库的 .c 时，需要加 -levent 选项。 </p>
<p>  库名 libevent.so –&gt; &#x2F;usr&#x2F;local&#x2F;lib  查看的到。</p>
<p>特性：</p>
<p>  基于“事件”异步通信模型。— 回调。</p>
<h2 id="libevent封装的框架思想"><a href="#libevent封装的框架思想" class="headerlink" title="libevent封装的框架思想"></a>libevent封装的框架思想</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">libevent框架：</span><br><span class="line"></span><br><span class="line">	1. 创建 event_base		(乐高底座)</span><br><span class="line">	2. 创建 事件evnet	</span><br><span class="line">	3. 将事件 添加到 base上	</span><br><span class="line">	4. 循环监听事件满足</span><br><span class="line">	5. 释放 event_base</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 创建 event_base		(乐高底座)</span><br><span class="line"></span><br><span class="line">		struct event_base *event_base_new(void);</span><br><span class="line"></span><br><span class="line">		struct event_base *base = event_base_new();</span><br><span class="line"></span><br><span class="line">2. 创建 事件evnet	</span><br><span class="line"></span><br><span class="line">		常规事件 event	--&gt; event_new(); </span><br><span class="line"></span><br><span class="line">		bufferevent --&gt; bufferevent_socket_new();</span><br><span class="line"></span><br><span class="line">3. 将事件 添加到 base上	</span><br><span class="line"></span><br><span class="line">		int event_add(struct event *ev, const struct timeval *tv)</span><br><span class="line"></span><br><span class="line">4. 循环监听事件满足</span><br><span class="line"></span><br><span class="line">		int event_base_dispatch(struct event_base *base);</span><br><span class="line"></span><br><span class="line">			event_base_dispatch(base);</span><br><span class="line"></span><br><span class="line">5. 释放 event_base</span><br><span class="line"></span><br><span class="line">		event_base_free(base);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="一些不常用相关函数了解"><a href="#一些不常用相关函数了解" class="headerlink" title="一些不常用相关函数了解"></a>一些不常用相关函数了解</h2><p>查看支持哪些多路IO<br><code>const char **event_get_supported_methods(void);</code></p>
<p>查看当前用的多路lO<br><code>const char * event_base_get_method(const struct event_base *base);</code></p>
<p>查看fork 后子进程使用的event_base<br><code>int event_reinit(struct event_base *base);</code><br>成功︰0，失败︰ -1<br>使用该函数后，父创建的base才能在子进程中生效。”</p>
<p><code>int event_base_loopexit(struct event_base *base, const struct timeval *tv);</code><br>在指定时间后停止循环。</p>
<p><code>int event_base_loopbreak(struct event_base *base);</code><br>立即停止循环。</p>
<h2 id="创建事件对象"><a href="#创建事件对象" class="headerlink" title="创建事件对象"></a>创建事件对象</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">创建事件event：</span><br><span class="line"></span><br><span class="line">	struct event *ev；</span><br><span class="line"></span><br><span class="line">	struct event *event_new(struct event_base *base，evutil_socket_t fd，short what，event_callback_fn cb;  void *arg);</span><br><span class="line"></span><br><span class="line">		base： event_base_new()返回值。</span><br><span class="line"></span><br><span class="line">		 fd： 绑定到 event 上的 文件描述符</span><br><span class="line"></span><br><span class="line">		what：对应的事件（r、w、e）</span><br><span class="line"></span><br><span class="line">			EV_READ		一次 读事件</span><br><span class="line"></span><br><span class="line">			EV_WRTIE	一次 写事件</span><br><span class="line"></span><br><span class="line">			EV_PERSIST	持续触发。 结合 event_base_dispatch 函数使用，生效。</span><br><span class="line"></span><br><span class="line">		cb：一旦事件满足监听条件，回调的函数。</span><br><span class="line"></span><br><span class="line">		typedef void (*event_callback_fn)(evutil_socket_t fd,  short,  void *)	</span><br><span class="line"></span><br><span class="line">		arg： 回调的函数的参数。</span><br><span class="line"></span><br><span class="line">		返回值：成功创建的 event</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="事件event操作"><a href="#事件event操作" class="headerlink" title="事件event操作"></a>事件event操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">添加事件到 event_base</span><br><span class="line"></span><br><span class="line">	int event_add(struct event *ev, const struct timeval *tv);</span><br><span class="line"></span><br><span class="line">		ev: event_new() 的返回值。</span><br><span class="line"></span><br><span class="line">		tv：NULL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">销毁事件</span><br><span class="line"></span><br><span class="line">	int event_free(struct event *ev);</span><br><span class="line"></span><br><span class="line">		ev: event_new() 的返回值。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用fifo的读写"><a href="#使用fifo的读写" class="headerlink" title="使用fifo的读写"></a>使用fifo的读写</h2><p>读端的代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;sys/types.h&gt;  </span><br><span class="line">#include &lt;sys/stat.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;fcntl.h&gt;  </span><br><span class="line">#include &lt;event2/event.h&gt;  </span><br><span class="line">  </span><br><span class="line">// 对操作处理函数  </span><br><span class="line">void read_cb(evutil_socket_t fd, short what, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    // 读管道  </span><br><span class="line">    char buf[1024] = &#123;0&#125;;  </span><br><span class="line">      </span><br><span class="line">    int len = read(fd, buf, sizeof(buf));  </span><br><span class="line">      </span><br><span class="line">    printf(&quot;read event: %s \n&quot;, what &amp; EV_READ ? &quot;Yes&quot; : &quot;No&quot;);  </span><br><span class="line">    printf(&quot;data len = %d, buf = %s\n&quot;, len, buf);  </span><br><span class="line">      </span><br><span class="line">    sleep(1);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">// 读管道  </span><br><span class="line">int main(int argc, const char* argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">    unlink(&quot;myfifo&quot;);  </span><br><span class="line">  </span><br><span class="line">    //创建有名管道  </span><br><span class="line">    mkfifo(&quot;myfifo&quot;, 0664);  </span><br><span class="line">  </span><br><span class="line">    // open file  </span><br><span class="line">    int fd = open(&quot;myfifo&quot;, O_RDONLY | O_NONBLOCK);//因为libevent是基于epoll反应堆实现的，所以是非阻塞的 </span><br><span class="line">    //int fd = open(&quot;myfifo&quot;, O_RDONLY);  </span><br><span class="line">    if(fd == -1)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(&quot;open error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // 创建个event_base  </span><br><span class="line">    struct event_base* base = NULL;  </span><br><span class="line">    base = event_base_new();  </span><br><span class="line">  </span><br><span class="line">    // 创建事件  </span><br><span class="line">    struct event* ev = NULL;  </span><br><span class="line">    ev = event_new(base, fd, EV_READ | EV_PERSIST, read_cb, NULL);  </span><br><span class="line">  </span><br><span class="line">    // 添加事件  </span><br><span class="line">    event_add(ev, NULL);  </span><br><span class="line">  </span><br><span class="line">    // 事件循环  </span><br><span class="line">    event_base_dispatch(base);  // while（1） &#123; epoll();&#125;  </span><br><span class="line">  </span><br><span class="line">    // 释放资源  </span><br><span class="line">    event_free(ev);  </span><br><span class="line">    event_base_free(base);  </span><br><span class="line">    close(fd);  </span><br><span class="line">      </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>写管道代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;sys/types.h&gt;  </span><br><span class="line">#include &lt;sys/stat.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;fcntl.h&gt;  </span><br><span class="line">#include &lt;event2/event.h&gt;  </span><br><span class="line">  </span><br><span class="line">// 对操作处理函数  </span><br><span class="line">void write_cb(evutil_socket_t fd, short what, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    // write管道  </span><br><span class="line">    char buf[1024] = &#123;0&#125;;  </span><br><span class="line">      </span><br><span class="line">    static int num = 0;  </span><br><span class="line">    sprintf(buf, &quot;hello,world-%d\n&quot;, num++);  </span><br><span class="line">    write(fd, buf, strlen(buf)+1);  </span><br><span class="line">      </span><br><span class="line">    sleep(1);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">// 写管道  </span><br><span class="line">int main(int argc, const char* argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">    // open file  </span><br><span class="line">    //int fd = open(&quot;myfifo&quot;, O_WRONLY | O_NONBLOCK);  </span><br><span class="line">    int fd = open(&quot;myfifo&quot;, O_WRONLY);  </span><br><span class="line">    if(fd == -1)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(&quot;open error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // 写管道  </span><br><span class="line">    struct event_base* base = NULL;  </span><br><span class="line">    base = event_base_new();  </span><br><span class="line">  </span><br><span class="line">    // 创建事件  </span><br><span class="line">    struct event* ev = NULL;  </span><br><span class="line">    // 检测的写缓冲区是否有空间写  </span><br><span class="line">    //ev = event_new(base, fd, EV_WRITE , write_cb, NULL);  </span><br><span class="line">    ev = event_new(base, fd, EV_WRITE | EV_PERSIST, write_cb, NULL);  </span><br><span class="line">  </span><br><span class="line">    // 添加事件  </span><br><span class="line">    event_add(ev, NULL);  </span><br><span class="line">  </span><br><span class="line">    // 事件循环  </span><br><span class="line">    event_base_dispatch(base);  </span><br><span class="line">  </span><br><span class="line">    // 释放资源  </span><br><span class="line">    event_free(ev);  </span><br><span class="line">    event_base_free(base);  </span><br><span class="line">    close(fd);  </span><br><span class="line">      </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个也说明不一定只能在网络上才能用libevent库</p>
<h2 id="未决和非未决"><a href="#未决和非未决" class="headerlink" title="未决和非未决"></a>未决和非未决</h2><p>未决和非未决： </p>
<p>  非未决: 没有资格被处理</p>
<p>  未决： 有资格被处理，但尚未被处理</p>
<p>  event_new –&gt; event —&gt; 非未决 –&gt; event_add –&gt; 未决 –&gt; dispatch() &amp;&amp; 监听事件被触发 –&gt; 激活态 </p>
<p>  –&gt; 执行回调函数 –&gt; 处理态 –&gt; 非未决 event_add &amp;&amp; EV_PERSIST –&gt; 未决 –&gt; event_del –&gt; 非未决</p>
<p><img src="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent/image-20230716114206318.png" alt="image-20230716114206318"></p>
<img src="/2023/07/15/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent/image-20230716114206318.png" class title="This is an test image">

<h2 id="bufferevent特性"><a href="#bufferevent特性" class="headerlink" title="bufferevent特性"></a>bufferevent特性</h2><p><img src="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent/image-20230717161012885.png" alt="image-20230717161012885"></p>
<img src="/2023/07/15/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent/image-20230717161012885.png" class title="This is an test image">

<p>带缓冲区的事件 bufferevent</p>
<p>  <code>#include &lt;event2/bufferevent.h&gt;</code>  </p>
<p>  <code>read/write 两个缓冲. 借助 队列.</code></p>
<h3 id="bufferevent事件对象创建、销毁"><a href="#bufferevent事件对象创建、销毁" class="headerlink" title="bufferevent事件对象创建、销毁"></a>bufferevent事件对象创建、销毁</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">创建、销毁bufferevent：</span><br><span class="line"></span><br><span class="line">	struct bufferevent *ev；</span><br><span class="line"></span><br><span class="line">	struct bufferevent *bufferevent_socket_new(struct event_base *base, evutil_socket_t fd, enum bufferevent_options options);</span><br><span class="line"></span><br><span class="line">		base： event_base</span><br><span class="line"></span><br><span class="line">		fd:	封装到bufferevent内的 fd</span><br><span class="line"></span><br><span class="line">		options：BEV_OPT_CLOSE_ON_FREE（设置它在关闭的时候释放相应的这个套件对象）</span><br><span class="line"></span><br><span class="line">	返回： 成功创建的 bufferevent事件对象。</span><br><span class="line">void  bufferevent_socket_free(struct bufferevent *ev);</span><br></pre></td></tr></table></figure>

<h3 id="给bufferevent事件对象设置回调"><a href="#给bufferevent事件对象设置回调" class="headerlink" title="给bufferevent事件对象设置回调"></a>给bufferevent事件对象设置回调</h3><p><code>bufferevent_flush()</code> 函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cCopy Codeint bufferevent_flush(struct bufferevent *bufev, short iotype, enum bufferevent_flush_mode mode);</span><br></pre></td></tr></table></figure>

<p>该函数用于将缓冲区中的数据写入底层传输机制，以确保数据尽快发送出去。</p>
<p>参数说明：</p>
<ul>
<li><code>bufev</code>：指向 <code>struct bufferevent</code> 结构体的指针，表示要刷新的缓冲事件。</li>
<li><code>iotype</code>：表示刷新操作的类型，可以是 <code>EV_READ</code>、<code>EV_WRITE</code> 或它们的按位或运算结果。如果指定了 <code>EV_READ</code>，则刷新读缓冲区；如果指定了 <code>EV_WRITE</code>，则刷新写缓冲区。</li>
<li><code>mode</code>：表示刷新模式，可以是 <code>BEV_NORMAL</code>、<code>BEV_FLUSH</code> 或 <code>BEV_FINISHED</code>。<code>BEV_NORMAL</code> 表示正常模式，<code>BEV_FLUSH</code> 表示强制刷新缓冲区，<code>BEV_FINISHED</code> 表示刷新完毕。</li>
</ul>
<p>函数返回值为 0 表示成功，-1 表示失败。</p>
<p>通过调用 <code>bufferevent_flush()</code> 函数，可以显式地触发将缓冲区中的数据发送到底层传输机制。需要注意的是，该函数只是将数据写入底层传输机制，并不保证立即发送到对端，实际的发送可能受到底层传输机制和网络状况的影响。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">给bufferevent设置回调：</span><br><span class="line">	</span><br><span class="line">	对比event：	event_new( fd, callback );  					event_add() -- 挂到 event_base 上。</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">			bufferevent_socket_new（fd）  bufferevent_setcb（ callback ）</span><br><span class="line"></span><br><span class="line">	void bufferevent_setcb(struct bufferevent * bufev,</span><br><span class="line">				bufferevent_data_cb readcb,</span><br><span class="line">				bufferevent_data_cb writecb,</span><br><span class="line">				bufferevent_event_cb eventcb,</span><br><span class="line">				void *cbarg );</span><br><span class="line"></span><br><span class="line">	bufev： bufferevent_socket_new() 返回值</span><br><span class="line"></span><br><span class="line">	readcb： 设置 bufferevent 读缓冲，对应回调  read_cb&#123;  bufferevent_read() 读数据  &#125;</span><br><span class="line"></span><br><span class="line">	writecb： 设置 bufferevent 写缓冲，对应回调 write_cb &#123;  &#125; -- 给调用者，发送写成功通知。  可以 NULL,因为它是写成功才调用，很鸡肋</span><br><span class="line"></span><br><span class="line">	eventcb： 设置 事件回调。   也可传NULL</span><br><span class="line"></span><br><span class="line">		typedef void (*bufferevent_event_cb)(struct bufferevent *bev,  short events, void *ctx);</span><br><span class="line"></span><br><span class="line">		void event_cb(struct bufferevent *bev,  short events, void *ctx)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			。。。。。</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		events： BEV_EVENT_CONNECTED</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cbarg：	上述回调函数使用的 参数。</span><br><span class="line"></span><br><span class="line">	read 回调函数类型：</span><br><span class="line"></span><br><span class="line">		typedef void (*bufferevent_data_cb)(struct bufferevent *bev, void*ctx);</span><br><span class="line"></span><br><span class="line">		void read_cb(struct bufferevent *bev, void *cbarg )</span><br><span class="line">		&#123;</span><br><span class="line">			.....</span><br><span class="line">			bufferevent_read();   --- read();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	bufferevent_read()函数的原型：</span><br><span class="line"></span><br><span class="line">		size_t bufferevent_read(struct bufferevent *bev, void *buf, size_t bufsize);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	write 回调函数类型：</span><br><span class="line"></span><br><span class="line">		int bufferevent_write(struct bufferevent *bufev, const void *data,  size_t size);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="缓冲区开启和关闭"><a href="#缓冲区开启和关闭" class="headerlink" title="缓冲区开启和关闭"></a>缓冲区开启和关闭</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">启动、关闭 bufferevent的 缓冲区：</span><br><span class="line"></span><br><span class="line">	void bufferevent_enable(struct bufferevent *bufev, short events);   启动	</span><br><span class="line"></span><br><span class="line">		events： EV_READ、EV_WRITE、EV_READ|EV_WRITE</span><br><span class="line"></span><br><span class="line">		默认write 缓冲是 enable、read 缓冲是 disable</span><br><span class="line"></span><br><span class="line">			bufferevent_enable(evev, EV_READ);		-- 开启读缓冲。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="客户端和服务器连接和监听"><a href="#客户端和服务器连接和监听" class="headerlink" title="客户端和服务器连接和监听"></a>客户端和服务器连接和监听</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">连接客户端：</span><br><span class="line"></span><br><span class="line">	socket();connect();</span><br><span class="line"></span><br><span class="line">	int bufferevent_socket_connect(struct bufferevent *bev, struct sockaddr *address, int addrlen);</span><br><span class="line"></span><br><span class="line">		bev: bufferevent 事件对象（封装了fd）</span><br><span class="line"></span><br><span class="line">		address、len：等同于 connect() 参2/3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">创建监听服务器：</span><br><span class="line"></span><br><span class="line">	------ socket();bind();listen();accept();</span><br><span class="line"></span><br><span class="line">	struct evconnlistener * listner</span><br><span class="line"></span><br><span class="line">	struct evconnlistener *evconnlistener_new_bind (	</span><br><span class="line">		struct event_base *base,</span><br><span class="line">		evconnlistener_cb cb, </span><br><span class="line">		void *ptr, </span><br><span class="line">		unsigned flags,</span><br><span class="line">		int backlog,</span><br><span class="line">		const struct sockaddr *sa,</span><br><span class="line">		int socklen);</span><br><span class="line"></span><br><span class="line">	base： event_base</span><br><span class="line"></span><br><span class="line">	cb: 回调函数。 一旦被回调，说明在其内部应该与客户端完成， 数据读写操作，进行通信。</span><br><span class="line"></span><br><span class="line">	ptr： 回调函数的参数</span><br><span class="line"></span><br><span class="line">	flags： LEV_OPT_CLOSE_ON_FREE | LEV_OPT_REUSEABLE</span><br><span class="line"></span><br><span class="line">	backlog： listen() 2参。 -1 表最大值</span><br><span class="line"></span><br><span class="line">	sa：服务器自己的地址结构体</span><br><span class="line"></span><br><span class="line">	socklen：服务器自己的地址结构体大小。</span><br><span class="line"></span><br><span class="line">	返回值：成功创建的监听器。</span><br><span class="line">释放监听服务器:</span><br><span class="line"></span><br><span class="line">	void evconnlistener_free(struct evconnlistener *lev);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="libevent实现TCP服务器流程"><a href="#libevent实现TCP服务器流程" class="headerlink" title="libevent实现TCP服务器流程"></a>libevent实现TCP服务器流程</h2><p>服务器端 libevent 创建TCP连接：</p>
<ol>
<li>创建event_base</li>
<li>创建bufferevent事件对象。bufferevent_socket_new();</li>
<li>使用bufferevent_setcb() 函数给 bufferevent的 read、write、event 设置回调函数。</li>
<li>当监听的 事件满足时，read_cb会被调用， 在其内部 bufferevent_read();读</li>
<li>使用 evconnlistener_new_bind 创建监听服务器， 设置其回调函数，当有客户端成功连接时，这个回调函数会被调用。</li>
<li>封装 listner_cb() 在函数内部。完成与客户端通信。 </li>
<li>设置读缓冲、写缓冲的 使能状态 enable、disable</li>
<li>启动循环 event_base_dispath();</li>
<li>释放连接。</li>
</ol>
<p>服务器源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;sys/types.h&gt;  </span><br><span class="line">#include &lt;sys/stat.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;event2/event.h&gt;  </span><br><span class="line">#include &lt;event2/listener.h&gt;  </span><br><span class="line">#include &lt;event2/bufferevent.h&gt;  </span><br><span class="line">  </span><br><span class="line">// 读缓冲区回调  </span><br><span class="line">void read_cb(struct bufferevent *bev, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    char buf[1024] = &#123;0&#125;;     </span><br><span class="line">    bufferevent_read(bev, buf, sizeof(buf));  </span><br><span class="line">    printf(&quot;client say: %s\n&quot;, buf);  </span><br><span class="line">  </span><br><span class="line">    char *p = &quot;我是服务器, 已经成功收到你发送的数据!&quot;;  </span><br><span class="line">    // 发数据给客户端  </span><br><span class="line">    bufferevent_write(bev, p, strlen(p)+1);  </span><br><span class="line">    sleep(1);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// 写缓冲区回调  </span><br><span class="line">void write_cb(struct bufferevent *bev, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    printf(&quot;I&#x27;m服务器, 成功写数据给客户端,写缓冲区回调函数被回调...\n&quot;);   </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// 事件  </span><br><span class="line">void event_cb(struct bufferevent *bev, short events, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    if (events &amp; BEV_EVENT_EOF)  </span><br><span class="line">    &#123;  </span><br><span class="line">        printf(&quot;connection closed\n&quot;);    </span><br><span class="line">    &#125;  </span><br><span class="line">    else if(events &amp; BEV_EVENT_ERROR)     </span><br><span class="line">    &#123;  </span><br><span class="line">        printf(&quot;some other error\n&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    bufferevent_free(bev);      </span><br><span class="line">    printf(&quot;buffevent 资源已经被释放...\n&quot;);   </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"> // 被回调，说明有客户端成功连接， cfd已经传入该参数内部。 创建bufferevent事件对象 </span><br><span class="line"> // 与客户端完成读写操作。  </span><br><span class="line">void cb_listener(  </span><br><span class="line">        struct evconnlistener *listener,   </span><br><span class="line">        evutil_socket_t fd,   </span><br><span class="line">        struct sockaddr *addr,   </span><br><span class="line">        int len, void *ptr)  </span><br><span class="line">&#123;  </span><br><span class="line">   printf(&quot;connect new client\n&quot;);  </span><br><span class="line">  </span><br><span class="line">   struct event_base* base = (struct event_base*)ptr;  </span><br><span class="line">   // 通信操作  </span><br><span class="line">   // 添加新事件  </span><br><span class="line">   struct bufferevent *bev;  </span><br><span class="line">   bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);  //将fd封装进去bev</span><br><span class="line">  </span><br><span class="line">   // 给bufferevent缓冲区设置回调  </span><br><span class="line">   bufferevent_setcb(bev, read_cb, write_cb, event_cb, NULL);  //write_cb和event_cb甚至可以传NULL</span><br><span class="line">   // 启动 read 缓冲区的 使能状态</span><br><span class="line">   bufferevent_enable(bev, EV_READ);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">int main(int argc, const char* argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">  </span><br><span class="line">    // init server   </span><br><span class="line">    struct sockaddr_in serv;  </span><br><span class="line">  </span><br><span class="line">    memset(&amp;serv, 0, sizeof(serv));  </span><br><span class="line">    serv.sin_family = AF_INET;  </span><br><span class="line">    serv.sin_port = htons(9876);  </span><br><span class="line">    serv.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">  </span><br><span class="line">    struct event_base* base;  </span><br><span class="line">    base = event_base_new();  </span><br><span class="line">    // 创建套接字  </span><br><span class="line">    // 绑定  </span><br><span class="line">    // 接收连接请求  </span><br><span class="line">    struct evconnlistener* listener;  </span><br><span class="line">    listener = evconnlistener_new_bind(base, cb_listener, base,   </span><br><span class="line">                                  LEV_OPT_CLOSE_ON_FREE | LEV_OPT_REUSEABLE,   </span><br><span class="line">                                  36, (struct sockaddr*)&amp;serv, sizeof(serv));  </span><br><span class="line">  </span><br><span class="line">    event_base_dispatch(base);  </span><br><span class="line">  </span><br><span class="line">    evconnlistener_free(listener);  </span><br><span class="line">    event_base_free(base);  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="客户端流程简析和回顾"><a href="#客户端流程简析和回顾" class="headerlink" title="客户端流程简析和回顾"></a>客户端流程简析和回顾</h3><p><img src="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent/image-20230717162404576.png" alt="image-20230717162404576"></p>
<img src="/2023/07/15/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent/image-20230717162404576.png" class title="This is an test image">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;sys/types.h&gt;  </span><br><span class="line">#include &lt;sys/stat.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;event2/bufferevent.h&gt;  </span><br><span class="line">#include &lt;event2/event.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">  </span><br><span class="line">void read_cb(struct bufferevent *bev, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    char buf[1024] = &#123;0&#125;;   </span><br><span class="line">    bufferevent_read(bev, buf, sizeof(buf));  </span><br><span class="line">  </span><br><span class="line">    printf(&quot;fwq say:%s\n&quot;, buf);  </span><br><span class="line">  </span><br><span class="line">    bufferevent_write(bev, buf, strlen(buf)+1);  </span><br><span class="line">    sleep(1);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void write_cb(struct bufferevent *bev, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    printf(&quot;----------我是客户端的写回调函数,没卵用\n&quot;);   </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void event_cb(struct bufferevent *bev, short events, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    if (events &amp; BEV_EVENT_EOF)  </span><br><span class="line">    &#123;  </span><br><span class="line">        printf(&quot;connection closed\n&quot;);    </span><br><span class="line">    &#125;  </span><br><span class="line">    else if(events &amp; BEV_EVENT_ERROR)     </span><br><span class="line">    &#123;  </span><br><span class="line">        printf(&quot;some other error\n&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">    else if(events &amp; BEV_EVENT_CONNECTED)  </span><br><span class="line">    &#123;  </span><br><span class="line">        printf(&quot;已经连接服务器...\\(^o^)/...\n&quot;);  </span><br><span class="line">        return;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    // 释放资源  </span><br><span class="line">    bufferevent_free(bev);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// 客户端与用户交互，从终端读取数据写给服务器  </span><br><span class="line">void read_terminal(evutil_socket_t fd, short what, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    // 读数据  </span><br><span class="line">    char buf[1024] = &#123;0&#125;;  </span><br><span class="line">    int len = read(fd, buf, sizeof(buf));  </span><br><span class="line">  </span><br><span class="line">    struct bufferevent* bev = (struct bufferevent*)arg;  </span><br><span class="line">    // 发送数据  </span><br><span class="line">    bufferevent_write(bev, buf, len+1);  //将len增加1，确保缓冲区中包含字符串的终止符，这在处理字符串时非常重要。</span><br><span class="line"></span><br><span class="line">//如果不包括终止符，接收方可能会在读取数据时出现问题，因为它们可能没有办法确定何时停止读取字符串。因此，确保缓冲区的末尾有一个终止符可以提供字符串的正确性和完整性。</span><br><span class="line"></span><br><span class="line">//总之，使用len+1而不是简单的len确保了传输的字符串在缓冲区中正确终止，避免了潜在的错误和问题。</span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int main(int argc, const char* argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">    struct event_base* base = NULL;  </span><br><span class="line">    base = event_base_new();  </span><br><span class="line">  </span><br><span class="line">    int fd = socket(AF_INET, SOCK_STREAM, 0);  //没有服务器那边监听器，所以需要创建fd</span><br><span class="line">  </span><br><span class="line">    // 通信的fd放到bufferevent中  </span><br><span class="line">    struct bufferevent* bev = NULL;  </span><br><span class="line">    bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);  //将fd封装进bev</span><br><span class="line">  </span><br><span class="line">    // init server info  </span><br><span class="line">    struct sockaddr_in serv;  </span><br><span class="line">    memset(&amp;serv, 0, sizeof(serv));  </span><br><span class="line">    serv.sin_family = AF_INET;  </span><br><span class="line">    serv.sin_port = htons(9876);  </span><br><span class="line">    inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;serv.sin_addr.s_addr);  </span><br><span class="line">  </span><br><span class="line">    // 连接服务器  </span><br><span class="line">    bufferevent_socket_connect(bev, (struct sockaddr*)&amp;serv, sizeof(serv));  </span><br><span class="line">  </span><br><span class="line">    // 设置回调  </span><br><span class="line">    bufferevent_setcb(bev, read_cb, write_cb, event_cb, NULL);  </span><br><span class="line">  </span><br><span class="line">    // 设置读回调生效  </span><br><span class="line">    // bufferevent_enable(bev, EV_READ);  </span><br><span class="line">  </span><br><span class="line">    // 创建事件  </span><br><span class="line">    struct event* ev = event_new(base, STDIN_FILENO, EV_READ | EV_PERSIST,  </span><br><span class="line">                                 read_terminal, bev);  </span><br><span class="line">    // 添加事件                       </span><br><span class="line">    event_add(ev, NULL);  </span><br><span class="line">  </span><br><span class="line">    event_base_dispatch(base);  </span><br><span class="line">  </span><br><span class="line">    event_free(ev);  </span><br><span class="line">      </span><br><span class="line">    event_base_free(base);  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="还有一些函数"><a href="#还有一些函数" class="headerlink" title="还有一些函数"></a>还有一些函数</h2><h3 id="evsignal-new"><a href="#evsignal-new" class="headerlink" title="evsignal_new"></a>evsignal_new</h3><p><code>evsignal_new</code> 是一个函数，用于创建一个新的 libevent 信号事件对象。 libevent 是一个开源的高性能网络库，用于事件驱动的编程。</p>
<p><code>evsignal_new</code> 的声明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct event *evsignal_new(struct event_base *base, int signo,</span><br><span class="line">                           void (*cb)(evutil_socket_t, short, void *), void *arg);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>base</code>：指向事件基础结构体（<code>event_base</code>）的指针。</li>
<li><code>signo</code>：要监听的信号编号。</li>
<li><code>cb</code>：当信号触发时调用的回调函数。</li>
<li><code>arg</code>：传递给回调函数的参数。</li>
</ul>
<p>该函数成功创建并返回一个新的 <code>event</code> 结构体指针，或者返回 <code>NULL</code> 表示创建失败。</p>
<p>一般情况下，使用 <code>evsignal_new</code> 函数后，还需要调用 <code>event_add</code> 将事件添加到事件循环中，并调用 <code>event_base_dispatch</code> 开始事件循环。</p>
<h3 id="strcasecmp"><a href="#strcasecmp" class="headerlink" title="strcasecmp"></a>strcasecmp</h3><p><code>strcasecmp()</code> 是一个字符串比较函数，它忽略字符串的大小写差异进行比较。</p>
<p>语法形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cCopy Codeint strcasecmp(const char *str1, const char *str2);</span><br></pre></td></tr></table></figure>

<p>参数 <code>str1</code> 和 <code>str2</code> 分别是要比较的两个字符串。函数会将这两个字符串进行比较，并返回一个整数值，用于表示比较结果。</p>
<p>返回值的含义如下：</p>
<ul>
<li>如果 <code>str1</code> 等于 <code>str2</code>（不区分大小写），则返回值为 0。</li>
<li>如果 <code>str1</code> 大于 <code>str2</code>（忽略大小写），则返回值大于 0。</li>
<li>如果 <code>str1</code> 小于 <code>str2</code>（忽略大小写），则返回值小于 0。</li>
</ul>
<p>在给定的代码中，<code>strcasecmp(method, &quot;GET&quot;) == 0</code> 表达式用于判断字符串 <code>method</code> 是否等于 <code>&quot;GET&quot;</code>（不区分大小写）。如果相等，条件表达式的结果为真（非零），执行相应的代码块。否则，条件表达式的结果为假（零），代码块将被跳过。</p>
<p>因此，所给代码段用于检查 <code>method</code> 是否为 <code>&quot;GET&quot;</code>，并执行与之相关的处理逻辑。</p>
<h3 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h3><p><code>stat()</code> 函数被调用来获取指定文件的状态信息并存储在 <code>sb</code> 结构体中。<code>stat()</code> 函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cCopy Codeint stat(const char *path, struct stat *buf);</span><br></pre></td></tr></table></figure>

<p>参数 <code>path</code> 是要获取状态信息的文件路径，<code>buf</code> 是一个指向 <code>struct stat</code> 结构体的指针，用于存储获取到的状态信息。</p>
<p>函数返回值为 0 表示成功，-1 表示失败。</p>
<p>接下来，通过判断 <code>stat(pf, &amp;sb) &lt; 0</code> 来检查 <code>stat()</code> 函数是否执行失败。如果执行失败，说明无法获取文件的状态信息，这时会输出错误信息到标准错误流（使用 <code>perror()</code> 函数），发送错误响应（使用 <code>send_error()</code> 函数），并返回 -1，表示函数执行出错。</p>
<p>“状态”在这里指的是文件的状态信息，而不是文件的结尾。</p>
<p><code>stat()</code> 函数用于获取文件的状态信息，包括文件的权限、大小、修改时间等。通过 <code>struct stat</code> 结构体来存储这些信息。在给定的代码中，<code>stat()</code> 函数将获取到的文件状态信息存储在 <code>sb</code> 结构体中。</p>
<p>这些状态信息可以用于判断文件的类型（如普通文件、目录、符号链接等）、访问权限以及其他属性。通过检查这些状态信息，可以在程序中进行相应的逻辑处理，例如根据文件类型进行不同的操作或者判断文件是否存在等。</p>
<p>文件的结尾字符实际上是文件内容的一部分，而不是文件的状态信息。要读取文件的内容，可以使用文件操作函数如 <code>fread()</code> 或者相关的系统调用如 <code>read()</code> 来读取文件的字节流数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct stat sb;</span><br><span class="line">        if(stat(pf,&amp;sb) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;open file err:&quot;);</span><br><span class="line">            send_error(bev);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(S_ISDIR(sb.st_mode))//处理目录</span><br><span class="line">        &#123;</span><br><span class="line">            //应该显示目录列表</span><br><span class="line">            send_header(bev, 200, &quot;OK&quot;, get_file_type(&quot;.html&quot;), -1);</span><br><span class="line">            send_dir(bev, pf);</span><br><span class="line">        &#125;</span><br><span class="line">        else //处理文件</span><br><span class="line">        &#123;</span><br><span class="line">            send_header(bev, 200, &quot;OK&quot;, get_file_type(pf), sb.st_size);</span><br><span class="line">            send_file_to_http(pf, bev);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<h3 id="scandir"><a href="#scandir" class="headerlink" title="scandir"></a>scandir</h3><p><code>scandir()</code> 函数用于扫描指定目录中的文件，并将文件列表存储在一个目录项数组中。</p>
<p>具体解释如下：</p>
<ol>
<li><p><code>scandir()</code> 函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cCopy Codeint scandir(const char *dir, struct dirent ***namelist,</span><br><span class="line">            int (*filter)(const struct dirent *),</span><br><span class="line">            int (*compar)(const struct dirent **, const struct dirent **));</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数解析：</p>
<ul>
<li><code>dir</code>：要扫描的目录路径。</li>
<li><code>namelist</code>：指向一个结构体指针的指针，用于存储扫描结果的目录项数组。每个目录项都包含文件名等信息。</li>
<li><code>filter</code>：可选的过滤函数，用于过滤不满足特定条件的目录项。在给定的代码中，设置为 <code>NULL</code>，表示不进行过滤。</li>
<li><code>compar</code>：可选的比较函数，用于排序目录项数组。在给定的代码中，设置为 <code>alphasort</code>，表示按字母顺序排序。</li>
</ul>
</li>
<li><p>函数返回值：</p>
<ul>
<li>如果成功调用 <code>scandir()</code> 函数，则返回扫描到的目录项数量（包括隐藏文件和特殊文件）。</li>
<li>如果调用失败，则返回 -1，并设置相应的错误码。</li>
</ul>
</li>
</ol>
<p>在给定的代码中，通过 <code>int num = scandir(dirname, &amp;dirinfo, NULL, alphasort);</code>，将 <code>dirname</code> 目录中的文件列表扫描到 <code>dirinfo</code> 目录项数组中，并将扫描到的目录项数量存储在整型变量 <code>num</code> 中。这些目录项可以通过 <code>dirinfo</code> 数组进行访问和处理。</p>
<h3 id="strftime"><a href="#strftime" class="headerlink" title="strftime"></a>strftime</h3><p><code>strftime()</code> 函数用于将时间信息格式化为指定的字符串形式。</p>
<p>具体解释如下：</p>
<ol>
<li><p><code>strftime()</code> 函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cCopy Codesize_t strftime(char *s, size_t maxsize, const char *format, const struct tm *timeptr);</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数解析：</p>
<ul>
<li><code>s</code>：指向一个字符数组的指针，用于存储格式化后的时间字符串。</li>
<li><code>maxsize</code>：指定 <code>s</code> 数组的大小，用于避免溢出。</li>
<li><code>format</code>：指定输出时间字符串的格式。例如，在给定的代码中，格式化字符串为 <code>&quot;  %d  %b   %Y  %H:%M&quot;</code>，表示以两个空格开头，然后依次为日期（日），月份（缩写），年份，小时和分钟，之间用空格分隔。</li>
<li><code>timeptr</code>：指向一个 <code>struct tm</code> 结构体的指针，包含了要格式化的时间信息。在给定的代码中，使用 <code>localtime(&amp;sb.st_mtime)</code> 获取文件的最后修改时间，并将其转换为本地时间的 <code>struct tm</code> 结构体。</li>
</ul>
</li>
<li><p>函数返回值：</p>
<ul>
<li>返回生成的时间字符串的长度，不包括 null 终止符。</li>
<li>如果格式化失败或输出字符串超过了 <code>maxsize</code> 的限制，则返回 0。</li>
</ul>
</li>
</ol>
<p>在给定的代码中，通过 <code>strftime(timestr, sizeof(timestr), &quot;  %d  %b   %Y  %H:%M&quot;, localtime(&amp;sb.st_mtime));</code> 将 <code>sb.st_mtime</code> 所表示的最后修改时间格式化为 <code>&quot;  %d  %b   %Y  %H:%M&quot;</code> 的字符串形式，并将结果存储在 <code>timestr</code> 字符数组中。这样，<code>timestr</code> 就保存了文件的最后修改时间的格式化字符串。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/14/Linux-%E7%BA%BF%E7%A8%8B%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/14/Linux-%E7%BA%BF%E7%A8%8B%E6%B1%A0/" class="post-title-link" itemprop="url">Linux-线程池</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-14 22:06:00" itemprop="dateCreated datePublished" datetime="2023-07-14T22:06:00+08:00">2023-07-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-15 14:31:56" itemprop="dateModified" datetime="2023-07-15T14:31:56+08:00">2023-07-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ctags使用"><a href="#ctags使用" class="headerlink" title="ctags使用"></a>ctags使用</h1><p><img src="/Linux-%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230714220627268.png" alt="image-20230714220627268"></p>
<img src="/2023/07/14/Linux-%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230714220627268.png" class title="This is an test image">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">在使用 ctags 时，它本身并没有提供直接在屏幕左侧列出文件列表的功能。但你可以使用其他工具结合 ctags 来实现类似的效果。</span><br><span class="line"></span><br><span class="line">一种常见的方法是使用类似于 NERDTree 插件的文件浏览器插件。NERDTree 是 Vim 编辑器中一个流行的插件，可以在 Vim 的侧边栏中显示和导航文件列表。你可以按照以下步骤在 Vim 中使用 NERDTree 插件：</span><br><span class="line"></span><br><span class="line">确保你已经安装了 pathogen 或者 vim-plug 这样的 Vim 插件管理器。</span><br><span class="line">根据你所选择的插件管理器，在你的 Vim 配置文件（通常是 ~/.vimrc）中添加相应的配置。</span><br><span class="line">安装 NERDTree 插件。对于 pathogen，可以将插件克隆到 ~/.vim/bundle/ 目录下。对于 vim-plug，可以在 ~/.vimrc 中添加插件的配置，并执行 :PlugInstall 命令进行安装。</span><br><span class="line">重启 Vim，并执行 :NERDTreeToggle 命令来打开或关闭 NERDTree 窗口。你可以将其映射为方便的快捷键。</span><br><span class="line">当你生成了 ctags 标签文件后，通过打开 NERDTree 窗口，你就可以在屏幕的左侧列出文件列表了。</span><br><span class="line"></span><br><span class="line">请注意，这只是一个示例插件，并且适用于 Vim 编辑器。对于其他编辑器或 IDE，你可能需要找到相应的文件浏览器插件或特定的功能来实现类似的效果。</span><br><span class="line"></span><br><span class="line">要在屏幕右边列出函数列表，你可以使用类似于 Tagbar 插件的工具。Tagbar 是一个常用的 Vim 插件，用于显示当前文件中定义的函数、类、变量等符号列表，并且可以将其放置在编辑窗口的侧边栏。</span><br><span class="line"></span><br><span class="line">以下是在 Vim 中使用 Tagbar 插件的简要步骤：</span><br><span class="line"></span><br><span class="line">确保你已经安装了 Vim 插件管理器，如 pathogen 或 vim-plug。</span><br><span class="line">根据你选择的插件管理器，在你的 Vim 配置文件（一般是 ~/.vimrc）中添加相应的配置。</span><br><span class="line">安装 Tagbar 插件。对于 pathogen，可以将插件克隆到 ~/.vim/bundle/ 目录下。对于 vim-plug，可以在 ~/.vimrc 中添加插件的配置，并执行 :PlugInstall 命令进行安装。</span><br><span class="line">重新启动 Vim，并执行 :TagbarToggle 命令来打开或关闭 Tagbar 窗口。你也可以将其映射为方便的快捷键。</span><br><span class="line">当你打开 Tagbar 窗口时，它将会在屏幕的右侧列出当前文件中的函数列表。</span><br><span class="line"></span><br><span class="line">请注意，这只是一个示例插件，适用于 Vim 编辑器。对于其他编辑器或 IDE，你可以搜索类似的插件或查看相关的功能来实现类似的效果。</span><br></pre></td></tr></table></figure>

<h1 id="线程池模型原理分析"><a href="#线程池模型原理分析" class="headerlink" title="线程池模型原理分析"></a>线程池模型原理分析</h1><p><img src="/Linux-%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230715143147311.png" alt="image-20230715143147311"></p>
<img src="/2023/07/14/Linux-%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230715143147311.png" class title="This is an test image">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">struct threadpool_t &#123;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_t lock;               /* 用于锁住本结构体 */    </span><br><span class="line">    pthread_mutex_t thread_counter;     /* 记录忙状态线程个数de琐 -- busy_thr_num */</span><br><span class="line"></span><br><span class="line">    pthread_cond_t queue_not_full;      /* 当任务队列满时，添加任务的线程阻塞，等待此条件变量 */</span><br><span class="line">    pthread_cond_t queue_not_empty;     /* 任务队列里不为空时，通知等待任务的线程 */</span><br><span class="line"></span><br><span class="line">    pthread_t *threads;                 /* 存放线程池中每个线程的tid。数组 */</span><br><span class="line">    pthread_t adjust_tid;               /* 存管理线程tid */</span><br><span class="line">    threadpool_task_t *task_queue;      /* 任务队列(数组首地址) */</span><br><span class="line"></span><br><span class="line">    int min_thr_num;                    /* 线程池最小线程数 */</span><br><span class="line">    int max_thr_num;                    /* 线程池最大线程数 */</span><br><span class="line">    int live_thr_num;                   /* 当前存活线程个数 */</span><br><span class="line">    int busy_thr_num;                   /* 忙状态线程个数 */</span><br><span class="line">    int wait_exit_thr_num;              /* 要销毁的线程个数 */</span><br><span class="line"></span><br><span class="line">    int queue_front;                    /* task_queue队头下标 */</span><br><span class="line">    int queue_rear;                     /* task_queue队尾下标 */</span><br><span class="line">    int queue_size;                     /* task_queue队中实际任务数 */</span><br><span class="line">    int queue_max_size;                 /* task_queue队列可容纳任务数上限 */</span><br><span class="line"></span><br><span class="line">    int shutdown;                       /* 标志位，线程池使用状态，true或false */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line"></span><br><span class="line">    void *(*function)(void *);          /* 函数指针，回调函数 */</span><br><span class="line">	void *arg;                          /* 上面函数的参数 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="线程池main架构"><a href="#线程池main架构" class="headerlink" title="线程池main架构"></a>线程池main架构</h2><ol>
<li>main();</li>
</ol>
<p>​    创建线程池。</p>
<p>​    向线程池中添加任务。 借助回调处理任务。</p>
<p>​    销毁线程池。</p>
<h2 id="线程池-pthreadpool-create"><a href="#线程池-pthreadpool-create" class="headerlink" title="线程池-pthreadpool_create"></a>线程池-pthreadpool_create</h2><ol start="2">
<li>pthreadpool_create();</li>
</ol>
<p>​    创建线程池结构体 指针。</p>
<p>​    初始化线程池结构体 { N 个成员变量 }</p>
<p>​    创建 N 个任务线程。</p>
<p>​    创建 1 个管理者线程。</p>
<p>​    失败时，销毁开辟的所有空间。（释放）</p>
<h2 id="子线程回调函数"><a href="#子线程回调函数" class="headerlink" title="子线程回调函数"></a>子线程回调函数</h2><ol start="3">
<li>threadpool_thread（）</li>
</ol>
<p>​    进入子线程回调函数。</p>
<p>​    接收参数 void *arg –》 pool 结构体</p>
<p>​    加锁 –》lock –》 整个结构体锁</p>
<p>​    判断条件变量 –》 wait</p>
<h2 id="管理者线程"><a href="#管理者线程" class="headerlink" title="管理者线程"></a>管理者线程</h2><ol start="4">
<li>adjust_thread（）</li>
</ol>
<p>​    循环 10 s 执行一次。</p>
<p>​    进入管理者线程回调函数</p>
<p>​    接收参数 void *arg –》 pool 结构体</p>
<p>​    加锁 –》lock –》 整个结构体锁</p>
<p>​    获取管理线程池要用的到 变量。  task_num, live_num, busy_num</p>
<p>​    根据既定算法，使用上述3变量，判断是否应该 创建、销毁线程池中 指定步长的线程。</p>
<h2 id="threadpool-add函数"><a href="#threadpool-add函数" class="headerlink" title="threadpool_add函数"></a>threadpool_add函数</h2><ol start="5">
<li>threadpool_add ()</li>
</ol>
<p>​    总功能：</p>
<p>​      模拟产生任务。  num[20]</p>
<p>​      设置回调函数， 处理任务。 sleep（1） 代表处理完成。</p>
<p>​    内部实现：</p>
<p>​      加锁</p>
<p>​      初始化 任务队列结构体成员。  回调函数 function， arg</p>
<p>​      利用环形队列机制，实现添加任务。 借助队尾指针挪移 % 实现。</p>
<p>​      唤醒阻塞在 条件变量上的线程。</p>
<p>​      解锁</p>
<h2 id="条件满足，子线程wait被唤醒后处理任务"><a href="#条件满足，子线程wait被唤醒后处理任务" class="headerlink" title="条件满足，子线程wait被唤醒后处理任务"></a>条件满足，子线程wait被唤醒后处理任务</h2><ol start="6">
<li>从 3. 中的wait之后继续执行，处理任务。</li>
</ol>
<p>​    加锁</p>
<p>​    </p>
<p>​    获取 任务处理回调函数，及参数</p>
<p>​    利用环形队列机制，实现处理任务。 借助队头指针挪移 % 实现。</p>
<p>​    唤醒阻塞在 条件变量 上的 server。</p>
<p>​    解锁</p>
<p>​    加锁</p>
<p>​    改忙线程数++</p>
<p>​    解锁</p>
<p>​    执行处理任务的线程</p>
<p>​    加锁</p>
<p>​    改忙线程数——</p>
<p>​    解锁</p>
<h2 id="线程池扩容和销毁"><a href="#线程池扩容和销毁" class="headerlink" title="线程池扩容和销毁"></a>线程池扩容和销毁</h2><ol start="7">
<li>创建 销毁线程</li>
</ol>
<p>​    管理者线程根据 task_num, live_num, busy_num </p>
<p>​    根据既定算法，使用上述3变量，判断是否应该 创建、销毁线程池中 指定步长的线程。</p>
<p>​    如果满足 创建条件</p>
<p>​      pthread_create();  回调 任务线程函数。    live_num++</p>
<p>​    如果满足 销毁条件</p>
<p>​      wait_exit_thr_num &#x3D; 10; </p>
<p>​      signal 给 阻塞在条件变量上的线程 发送 假条件满足信号  </p>
<p>​      跳转至 –170 wait阻塞线程会被 假信号 唤醒。判断： wait_exit_thr_num &gt; 0 pthread_exit();</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/12/Linux-%E5%A4%9A%E8%B7%AFI-O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/12/Linux-%E5%A4%9A%E8%B7%AFI-O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/" class="post-title-link" itemprop="url">Linux-多路I/O转接服务器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-12 14:56:57" itemprop="dateCreated datePublished" datetime="2023-07-12T14:56:57+08:00">2023-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-28 12:09:04" itemprop="dateModified" datetime="2023-07-28T12:09:04+08:00">2023-07-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="多路IO转接服务器设计思路"><a href="#多路IO转接服务器设计思路" class="headerlink" title="多路IO转接服务器设计思路"></a>多路IO转接服务器设计思路</h2><p><img src="/Linux-%E5%A4%9A%E8%B7%AFI-O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230711110952097.png" alt="image-20230711110952097"></p>
<img src="/2023/07/12/Linux-%E5%A4%9A%E8%B7%AFI-O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230711110952097.png" class title="This is an test image">

<h2 id="select函数参数简介"><a href="#select函数参数简介" class="headerlink" title="select函数参数简介"></a>select函数参数简介</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout);</span><br><span class="line"></span><br><span class="line">		nfds：监听的所有文件描述符中，最大文件描述符+1</span><br><span class="line"></span><br><span class="line">		readfds： 读 文件描述符监听集合。	传入、传出参数</span><br><span class="line"></span><br><span class="line">		writefds：写 文件描述符监听集合。	传入、传出参数		NULL</span><br><span class="line"></span><br><span class="line">		exceptfds：异常 文件描述符监听集合	传入、传出参数		NULL</span><br><span class="line"></span><br><span class="line">		timeout： 	&gt; 0: 	设置监听超时时长。</span><br><span class="line"></span><br><span class="line">				NULL:	阻塞监听</span><br><span class="line"></span><br><span class="line">				0：	非阻塞监听，轮询</span><br><span class="line">		返回值：</span><br><span class="line"></span><br><span class="line">			&gt; 0:	所有监听集合（3个）中， 满足对应事件的总数。</span><br><span class="line"></span><br><span class="line">			0：	没有满足监听条件的文件描述符</span><br><span class="line"></span><br><span class="line">			-1： 	errno</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="select相关函数参数分析"><a href="#select相关函数参数分析" class="headerlink" title="select相关函数参数分析"></a>select相关函数参数分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void FD_CLR(int fd, fd_set *set)		把某一个fd清除出去</span><br><span class="line">int FD_ISSET(int fd, fd_set *set)		判定某个fd是否在位图中</span><br><span class="line">void FD_SET(int fd, fd_set *set)		把某一个fd添加到位图</span><br><span class="line">void FD_ZERO(fd_set *set)				位图所有二进制位置零</span><br><span class="line"></span><br><span class="line">select多路IO转接：</span><br><span class="line"></span><br><span class="line">	原理：  借助内核， select 来监听， 客户端连接、数据通信事件。</span><br><span class="line"></span><br><span class="line">	void FD_ZERO(fd_set *set);	--- 清空一个文件描述符集合。</span><br><span class="line"></span><br><span class="line">		fd_set rset;</span><br><span class="line"></span><br><span class="line">		FD_ZERO(&amp;rset);</span><br><span class="line"></span><br><span class="line">	void FD_SET(int fd, fd_set *set);	--- 将待监听的文件描述符，添加到监听集合中</span><br><span class="line"></span><br><span class="line">		FD_SET(3, &amp;rset);	FD_SET(5, &amp;rset);	FD_SET(6, &amp;rset);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	void FD_CLR(int fd, fd_set *set);	--- 将一个文件描述符从监听集合中 移除。</span><br><span class="line"></span><br><span class="line">		FD_CLR（4， &amp;rset）;</span><br><span class="line"></span><br><span class="line">	int  FD_ISSET(int fd, fd_set *set);	--- 判断一个文件描述符是否在监听集合中。</span><br><span class="line"></span><br><span class="line">		返回值： 在：1；不在：0；</span><br><span class="line"></span><br><span class="line">		FD_ISSET（4， &amp;rset）;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="select实现多路IO转接设计思路"><a href="#select实现多路IO转接设计思路" class="headerlink" title="select实现多路IO转接设计思路"></a>select实现多路IO转接设计思路</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">思路分析：</span><br><span class="line"></span><br><span class="line">	int maxfd = 0；</span><br><span class="line"></span><br><span class="line">	lfd = socket() ;			创建套接字</span><br><span class="line"></span><br><span class="line">	maxfd = lfd；</span><br><span class="line"></span><br><span class="line">	bind();					绑定地址结构</span><br><span class="line"></span><br><span class="line">	listen();				设置监听上限</span><br><span class="line"></span><br><span class="line">	fd_set rset， allset;			创建r监听集合</span><br><span class="line"></span><br><span class="line">	FD_ZERO(&amp;allset);				将r监听集合清空</span><br><span class="line"></span><br><span class="line">	FD_SET(lfd, &amp;allset);			将 lfd 添加至读集合中。</span><br><span class="line"></span><br><span class="line">	while（1） &#123;</span><br><span class="line"></span><br><span class="line">		rset = allset；			保存监听集合</span><br><span class="line">	</span><br><span class="line">		ret  = select(lfd+1， &amp;rset， NULL， NULL， NULL);		监听文件描述符集合对应事件。</span><br><span class="line"></span><br><span class="line">		if（ret &gt; 0） &#123;							有监听的描述符满足对应事件</span><br><span class="line">		</span><br><span class="line">			if (FD_ISSET(lfd, &amp;rset)) &#123;				// 1 在。 0不在。</span><br><span class="line"></span><br><span class="line">				cfd = accept（）；				建立连接，返回用于通信的文件描述符</span><br><span class="line"></span><br><span class="line">				maxfd = cfd；</span><br><span class="line"></span><br><span class="line">				FD_SET(cfd, &amp;allset);				添加到监听通信描述符集合中。</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			for （i = lfd+1； i &lt;= 最大文件描述符; i++）&#123;</span><br><span class="line"></span><br><span class="line">				FD_ISSET(i, &amp;rset)				有read、write事件</span><br><span class="line"></span><br><span class="line">				read（）</span><br><span class="line"></span><br><span class="line">				小 -- 大</span><br><span class="line"></span><br><span class="line">				write();</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="select实现多路IO转接-代码review"><a href="#select实现多路IO转接-代码review" class="headerlink" title="select实现多路IO转接-代码review"></a>select实现多路IO转接-代码review</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">#include &lt;ctype.h&gt;  </span><br><span class="line"></span><br><span class="line">#include &quot;wrap.h&quot;  </span><br><span class="line"></span><br><span class="line">#define SERV_PORT 6666  </span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">    int i, j, n, nready;  </span><br><span class="line"></span><br><span class="line">    int maxfd = 0;  </span><br><span class="line"></span><br><span class="line">    int listenfd, connfd;  </span><br><span class="line"></span><br><span class="line">    char buf[BUFSIZ];         /* #define INET_ADDRSTRLEN 16 */  </span><br><span class="line"></span><br><span class="line">    struct sockaddr_in clie_addr, serv_addr;  </span><br><span class="line">    socklen_t clie_addr_len;  </span><br><span class="line"></span><br><span class="line">    listenfd = Socket(AF_INET, SOCK_STREAM, 0);    </span><br><span class="line">    int opt = 1;  </span><br><span class="line">    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, (void *)&amp;opt, sizeof(opt));  </span><br><span class="line">    </span><br><span class="line">    bzero(&amp;serv_addr, sizeof(serv_addr));  </span><br><span class="line">    serv_addr.sin_family= AF_INET;  </span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">    serv_addr.sin_port= htons(SERV_PORT);  </span><br><span class="line">    Bind(listenfd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr));  </span><br><span class="line">    Listen(listenfd, 128);  </span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">    fd_set rset, allset;                            /* rset 读事件文件描述符集合 allset用来暂存 */  </span><br><span class="line">  </span><br><span class="line">    maxfd = listenfd;  </span><br><span class="line">  </span><br><span class="line">    FD_ZERO(&amp;allset);  </span><br><span class="line">    FD_SET(listenfd, &amp;allset);                                  /* 构造select监控文件描述符集 */  </span><br><span class="line">  </span><br><span class="line">    while (1) &#123;     </span><br><span class="line">        rset = allset;                                          /* 每次循环时都从新设置select监控信号集 */  </span><br><span class="line">        nready = select(maxfd+1, &amp;rset, NULL, NULL, NULL);  </span><br><span class="line">        if (nready &lt; 0)  </span><br><span class="line">            perr_exit(&quot;select error&quot;);  </span><br><span class="line">  </span><br><span class="line">        if (FD_ISSET(listenfd, &amp;rset)) &#123;                        /* 说明有新的客户端链接请求 */  </span><br><span class="line">  </span><br><span class="line">            clie_addr_len = sizeof(clie_addr);  </span><br><span class="line">            connfd = Accept(listenfd, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);       /* Accept 不会阻塞 */  </span><br><span class="line">  </span><br><span class="line">            FD_SET(connfd, &amp;allset);                            /* 向监控文件描述符集合allset添加新的文件描述符connfd */  </span><br><span class="line">  </span><br><span class="line">            if (maxfd &lt; connfd)  </span><br><span class="line">                maxfd = connfd;  </span><br><span class="line">  </span><br><span class="line">            if (0 == --nready)                                  /* 只有listenfd有事件, 后续的 for 不需执行 */  </span><br><span class="line">                continue;  </span><br><span class="line">        &#125;   </span><br><span class="line">  </span><br><span class="line">        for (i = listenfd+1; i &lt;= maxfd; i++) &#123;                 /* 检测哪个clients 有数据就绪 */  </span><br><span class="line">  </span><br><span class="line">            if (FD_ISSET(i, &amp;rset)) &#123;  </span><br><span class="line">  </span><br><span class="line">                if ((n = Read(i, buf, sizeof(buf))) == 0) &#123;    /* 当client关闭链接时,服务器端也关闭对应链接 */  </span><br><span class="line">                    Close(i);  </span><br><span class="line">                    FD_CLR(i, &amp;allset);                        /* 解除select对此文件描述符的监控 */  </span><br><span class="line">                    &#125; else if (n &gt; 0) &#123;  </span><br><span class="line">	  </span><br><span class="line">	                    for (j = 0; j &lt; n; j++)  </span><br><span class="line">	                        buf[j] = toupper(buf[j]);  </span><br><span class="line">	                    Write(i, buf, n);  </span><br><span class="line">	                &#125;  </span><br><span class="line">	            &#125;  </span><br><span class="line">	        &#125;  </span><br><span class="line">	    &#125;  </span><br><span class="line">	  </span><br><span class="line">	    Close(listenfd);  </span><br><span class="line">	  </span><br><span class="line">	    return 0;  </span><br><span class="line">	&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用 Ctrl+Z 组合键是一种在命令行界面下停止（暂停）进程的方法，而不是正确关闭连接或套接字。</p>
<p>在大多数操作系统中，Ctrl+Z 组合键用于发送一个 SIGTSTP 信号给当前运行的进程，以暂停其执行。这通常是在后台运行的进程或任务中使用的，如在 Linux 或 UNIX 系统中运行的程序。通过按下 Ctrl+Z，您可以使进程进入后台挂起状态，并返回到命令行提示符，从而可以执行其他操作。</p>
<p>然而，Ctrl+Z 并不会主动关闭连接或套接字，它只是将进程暂停，但连接可能仍然处于活动状态。如果您希望正确关闭连接或套接字，应该在适当的时间调用相应的方法或函数来明确地关闭它们。具体取决于所使用的编程语言和网络库。</p>
<p>对于大多数命令行界面，使用 <strong>Ctrl+C</strong> 组合键是一种常用的方法来停止正在运行的进程或程序，包括网络连接和套接字。</p>
<p>按下 Ctrl+C 组合键会发送一个 SIGINT 信号给当前运行的进程，这通常会中断进程的执行并终止它。在网络编程中，当您想要停止正在进行的连接时，可以按下 Ctrl+C 组合键来关闭连接并终止与该连接相关的进程。</p>
<p>需要注意的是，按下 Ctrl+C 组合键将会立即终止进程，可能导致一些未完成的操作无法正确处理。因此，在关闭连接或套接字之前，建议在适当的时机进行必要的清理和处理操作，以确保数据的完整性和资源的正确释放。</p>
<p>总而言之，Ctrl+C 是一种常见且有效的方式来停止正在运行的进程，包括关闭网络连接和套接字。但请谨慎使用，确保在终止进程之前进行必要的清理和处理操作，以避免可能的问题。</p>
<h3 id="select优缺点"><a href="#select优缺点" class="headerlink" title="select优缺点"></a>select优缺点</h3><p>select优缺点：</p>
<p>  缺点： 监听上限受文件描述符限制。 最大 1024.</p>
<p>​    检测满足条件的fd， 自己添加业务逻辑提高小。 提高了编码难度。</p>
<p>  优点： 跨平台。win、linux、macOS、Unix、类Unix、mips</p>
<ol>
<li><p>select能监听的文件描述符个数受限于FD_SETSIZE,一般为1024，单纯改变进程打开的文件描述符个数并不能改变select监听文件个数</p>
</li>
<li><p>解决1024以下客户端时使用select是很合适的，但如果链接客户端过多，select采用的是轮询模型，会大大降低服务器响应效率，不应在select上投入更多精力</p>
</li>
</ol>
<p>select代码里有个可以优化的地方，用数组存下文件描述符，这样就不需要每次扫描一大堆无关文件描述符了</p>
<h2 id="添加一个自定义数组提高效率"><a href="#添加一个自定义数组提高效率" class="headerlink" title="添加一个自定义数组提高效率"></a>添加一个自定义数组提高效率</h2><p>这里就是改进之前代码的问题，之前的代码，如果最大fd是1023，每次确定有事件发生的fd时，就要扫描3-1023的所有文件描述符，这看起来很蠢。于是定义一个数组，把要监听的文件描述符存下来，每次扫描这个数组就行了。看起来科学得多。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">1.	#include &lt;stdio.h&gt;  </span><br><span class="line">2.	#include &lt;stdlib.h&gt;  </span><br><span class="line">3.	#include &lt;unistd.h&gt;  </span><br><span class="line">4.	#include &lt;string.h&gt;  </span><br><span class="line">5.	#include &lt;arpa/inet.h&gt;  </span><br><span class="line">6.	#include &lt;ctype.h&gt;  </span><br><span class="line">7.	  </span><br><span class="line">8.	#include &quot;wrap.h&quot;  </span><br><span class="line">9.	  </span><br><span class="line">10.	#define SERV_PORT 6666  </span><br><span class="line">11.	  </span><br><span class="line">12.	int main(int argc, char *argv[])  </span><br><span class="line">13.	&#123;  </span><br><span class="line">14.	    int i, j, n, maxi;  </span><br><span class="line">15.	  </span><br><span class="line">16.	    int nready, client[FD_SETSIZE];                 /* 自定义数组client, 防止遍历1024个文件描述符  FD_SETSIZE默认为1024 */  </span><br><span class="line">17.	    int maxfd, listenfd, connfd, sockfd;  </span><br><span class="line">18.	    char buf[BUFSIZ], str[INET_ADDRSTRLEN];         /* #define INET_ADDRSTRLEN 16 */  </span><br><span class="line">19.	  </span><br><span class="line">20.	    struct sockaddr_in clie_addr, serv_addr;  </span><br><span class="line">21.	    socklen_t clie_addr_len;  </span><br><span class="line">22.	    fd_set rset, allset;                            /* rset 读事件文件描述符集合 allset用来暂存 */  </span><br><span class="line">23.	  </span><br><span class="line">24.	    listenfd = Socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">25.	  </span><br><span class="line">26.	    int opt = 1;  </span><br><span class="line">27.	    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt));  </span><br><span class="line">28.	  </span><br><span class="line">29.	    bzero(&amp;serv_addr, sizeof(serv_addr));  </span><br><span class="line">30.	    serv_addr.sin_family= AF_INET;  </span><br><span class="line">31.	    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">32.	    serv_addr.sin_port= htons(SERV_PORT);  </span><br><span class="line">33.	  </span><br><span class="line">34.	    Bind(listenfd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr));  </span><br><span class="line">35.	    Listen(listenfd, 128);  </span><br><span class="line">36.	  </span><br><span class="line">37.	    maxfd = listenfd;                                           /* 起初 listenfd 即为最大文件描述符 */  </span><br><span class="line">38.	  </span><br><span class="line">39.	    maxi = -1;                                                  /* 将来用作client[]的下标, 初始值指向0个元素之前下标位置 */  </span><br><span class="line">40.	    for (i = 0; i &lt; FD_SETSIZE; i++)  </span><br><span class="line">41.	        client[i] = -1;                                         /* 用-1初始化client[] */  </span><br><span class="line">42.	  </span><br><span class="line">43.	    FD_ZERO(&amp;allset);  </span><br><span class="line">44.	    FD_SET(listenfd, &amp;allset);                                  /* 构造select监控文件描述符集 */  </span><br><span class="line">45.	  </span><br><span class="line">46.	    while (1) &#123;     </span><br><span class="line">47.	        rset = allset;                                          /* 每次循环时都重新设置select监控信号集 */  </span><br><span class="line">48.	  </span><br><span class="line">49.	        nready = select(maxfd+1, &amp;rset, NULL, NULL, NULL);  //2  1--lfd  1--connfd  </span><br><span class="line">50.	        if (nready &lt; 0)  </span><br><span class="line">51.	            perr_exit(&quot;select error&quot;);  </span><br><span class="line">52.	  </span><br><span class="line">53.	        if (FD_ISSET(listenfd, &amp;rset)) &#123;                        /* 说明有新的客户端链接请求 */  </span><br><span class="line">54.	  </span><br><span class="line">55.	            clie_addr_len = sizeof(clie_addr);  </span><br><span class="line">56.	            connfd = Accept(listenfd, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);       /* Accept 不会阻塞 */  </span><br><span class="line">57.	            printf(&quot;received from %s at PORT %d\n&quot;,  </span><br><span class="line">58.	                    inet_ntop(AF_INET, &amp;clie_addr.sin_addr, str, sizeof(str)),  </span><br><span class="line">59.	                    ntohs(clie_addr.sin_port));  </span><br><span class="line">60.	  </span><br><span class="line">61.	            for (i = 0; i &lt; FD_SETSIZE; i++)  </span><br><span class="line">62.	                if (client[i] &lt; 0) &#123;                            /* 找client[]中没有使用的位置 */  </span><br><span class="line">63.	                    client[i] = connfd;                         /* 保存accept返回的文件描述符到client[]里 */  </span><br><span class="line">64.	                    break;  </span><br><span class="line">65.	                &#125;  </span><br><span class="line">66.	  </span><br><span class="line">67.	            if (i == FD_SETSIZE) &#123;                              /* 达到select能监控的文件个数上限 1024 */  </span><br><span class="line">68.	                fputs(&quot;too many clients\n&quot;, stderr);  </span><br><span class="line">69.	                exit(1);  </span><br><span class="line">70.	            &#125;  </span><br><span class="line">71.	  </span><br><span class="line">72.	            FD_SET(connfd, &amp;allset);                            /* 向监控文件描述符集合allset添加新的文件描述符connfd */  </span><br><span class="line">73.	  </span><br><span class="line">74.	            if (connfd &gt; maxfd)  </span><br><span class="line">75.	                maxfd = connfd;                                 /* select第一个参数需要 */  </span><br><span class="line">76.	  </span><br><span class="line">77.	            if (i &gt; maxi)  </span><br><span class="line">78.	                maxi = i;                                       /* 保证maxi存的总是client[]最后一个元素下标 */  </span><br><span class="line">79.	  </span><br><span class="line">80.	            if (--nready == 0)  //在后面的原因，如果有请求，lfd有FD_ISSET(listenfd, &amp;rset)，再进行accept，无阻塞</span><br><span class="line">81.	                continue;  </span><br><span class="line">82.	        &#125;   </span><br><span class="line">83.	  </span><br><span class="line">84.	        for (i = 0; i &lt;= maxi; i++) &#123;                               /* 检测哪个clients 有数据就绪 */  </span><br><span class="line">85.	  </span><br><span class="line">86.	            if ((sockfd = client[i]) &lt; 0)  </span><br><span class="line">87.	                continue;  </span><br><span class="line">88.	            if (FD_ISSET(sockfd, &amp;rset)) &#123;  </span><br><span class="line">89.	  </span><br><span class="line">90.	                if ((n = Read(sockfd, buf, sizeof(buf))) == 0) &#123;    /* 当client关闭链接时,服务器端也关闭对应链接 */  </span><br><span class="line">91.	                    Close(sockfd);  </span><br><span class="line">92.	                    FD_CLR(sockfd, &amp;allset);                        /* 解除select对此文件描述符的监控 */  </span><br><span class="line">93.	                    client[i] = -1;  </span><br><span class="line">94.	                &#125; else if (n &gt; 0) &#123;  </span><br><span class="line">95.	                    for (j = 0; j &lt; n; j++)  </span><br><span class="line">96.	                        buf[j] = toupper(buf[j]);  </span><br><span class="line">97.	                    Write(sockfd, buf, n);  </span><br><span class="line">98.	                    Write(STDOUT_FILENO, buf, n);  </span><br><span class="line">99.	                &#125;  </span><br><span class="line">100.	                if (--nready == 0)  </span><br><span class="line">101.	                    break;                                          /* 跳出for, 但还在while中 */  </span><br><span class="line">102.	            &#125;  </span><br><span class="line">103.	        &#125;  </span><br><span class="line">104.	    &#125;  </span><br><span class="line">105.	    Close(listenfd);  </span><br><span class="line">106.	    return 0;  </span><br><span class="line">107.	&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="poll函数原型分析"><a href="#poll函数原型分析" class="headerlink" title="poll函数原型分析"></a>poll函数原型分析</h2><p>poll是对select的改进，但是它是个半成品，相对select提升不大。最终版本是epoll，所以poll了解一下就完事儿，重点掌握epoll。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">poll：</span><br><span class="line">	int poll(struct pollfd *fds, nfds_t nfds, int timeout);</span><br><span class="line"></span><br><span class="line">		fds：监听的文件描述符【数组】</span><br><span class="line"></span><br><span class="line">			struct pollfd &#123;</span><br><span class="line">				</span><br><span class="line">				int fd：	待监听的文件描述符</span><br><span class="line">				</span><br><span class="line">				short events：	待监听的文件描述符对应的监听事件</span><br><span class="line"></span><br><span class="line">						取值：POLLIN、POLLOUT、POLLERR</span><br><span class="line"></span><br><span class="line">				short revnets：	传入时， 给0。如果满足对应事件的话， 返回 非0 --&gt; POLLIN、POLLOUT、POLLERR</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		nfds: 监听数组的，实际有效监听个数。</span><br><span class="line"></span><br><span class="line">		timeout:  &gt; 0:  超时时长。单位：毫秒。</span><br><span class="line"></span><br><span class="line">			  -1:	阻塞等待</span><br><span class="line"></span><br><span class="line">			  0：  不阻塞</span><br><span class="line"></span><br><span class="line">		返回值：返回满足对应监听事件的文件描述符 总个数。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  优点：</p>
<p>​    自带数组结构。 可以将 监听事件集合 和 返回事件集合 分离。</p>
<p>​    拓展 监听上限。 超出 1024限制。</p>
<p>  缺点：</p>
<p>​    不能跨平台。 Linux</p>
<p>​    无法直接定位满足监听事件的文件描述符， 编码难度较大。</p>
<h3 id="poll函数实现服务器"><a href="#poll函数实现服务器" class="headerlink" title="poll函数实现服务器"></a>poll函数实现服务器</h3><p>这个东西用得少，基本都用epoll</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">1.	/* server.c */  </span><br><span class="line">2.	#include &lt;stdio.h&gt;  </span><br><span class="line">3.	#include &lt;stdlib.h&gt;  </span><br><span class="line">4.	#include &lt;string.h&gt;  </span><br><span class="line">5.	#include &lt;netinet/in.h&gt;  </span><br><span class="line">6.	#include &lt;arpa/inet.h&gt;  </span><br><span class="line">7.	#include &lt;poll.h&gt;  </span><br><span class="line">8.	#include &lt;errno.h&gt;  </span><br><span class="line">9.	#include &quot;wrap.h&quot;  </span><br><span class="line">10.	  </span><br><span class="line">11.	#define MAXLINE 80  </span><br><span class="line">12.	#define SERV_PORT 6666  </span><br><span class="line">13.	#define OPEN_MAX 1024  </span><br><span class="line">14.	  </span><br><span class="line">15.	int main(int argc, char *argv[])  </span><br><span class="line">16.	&#123;  </span><br><span class="line">17.	    int i, j, maxi, listenfd, connfd, sockfd;  </span><br><span class="line">18.	    int nready;  </span><br><span class="line">19.	    ssize_t n;  </span><br><span class="line">20.	    char buf[MAXLINE], str[INET_ADDRSTRLEN];  </span><br><span class="line">21.	    socklen_t clilen;  </span><br><span class="line">22.	    struct pollfd client[OPEN_MAX];  </span><br><span class="line">23.	    struct sockaddr_in cliaddr, servaddr;  </span><br><span class="line">24.	  </span><br><span class="line">25.	    listenfd = Socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">26.	  </span><br><span class="line">27.	    bzero(&amp;servaddr, sizeof(servaddr));  </span><br><span class="line">28.	    servaddr.sin_family = AF_INET;  </span><br><span class="line">29.	    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">30.	    servaddr.sin_port = htons(SERV_PORT);  </span><br><span class="line">31.	  </span><br><span class="line">32.	    Bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));  </span><br><span class="line">33.	  </span><br><span class="line">34.	    Listen(listenfd, 20);  </span><br><span class="line">35.	  </span><br><span class="line">36.	    client[0].fd = listenfd;  </span><br><span class="line">37.	    client[0].events = POLLRDNORM;                  /* listenfd监听普通读事件 */  </span><br><span class="line">38.	  </span><br><span class="line">39.	    for (i = 1; i &lt; OPEN_MAX; i++)  </span><br><span class="line">40.	        client[i].fd = -1;                          /* 用-1初始化client[]里剩下元素 */  </span><br><span class="line">41.	    maxi = 0;                                       /* client[]数组有效元素中最大元素下标 */  </span><br><span class="line">42.	  </span><br><span class="line">43.	    for ( ; ; ) &#123;  </span><br><span class="line">44.	        nready = poll(client, maxi+1, -1);          /* 阻塞 */  </span><br><span class="line">45.	        if (client[0].revents &amp; POLLRDNORM) &#123;       /* 有客户端链接请求 */  </span><br><span class="line">46.	            clilen = sizeof(cliaddr);  </span><br><span class="line">47.	            connfd = Accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;clilen);  </span><br><span class="line">48.	            printf(&quot;received from %s at PORT %d\n&quot;,  </span><br><span class="line">49.	                    inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, sizeof(str)),  </span><br><span class="line">50.	                    ntohs(cliaddr.sin_port));  </span><br><span class="line">51.	            for (i = 1; i &lt; OPEN_MAX; i++) &#123;  </span><br><span class="line">52.	                if (client[i].fd &lt; 0) &#123;  </span><br><span class="line">53.	                    client[i].fd = connfd;  /* 找到client[]中空闲的位置，存放accept返回的connfd */  </span><br><span class="line">54.	                    break;  </span><br><span class="line">55.	                &#125;  </span><br><span class="line">56.	            &#125;  </span><br><span class="line">57.	  </span><br><span class="line">58.	            if (i == OPEN_MAX)  </span><br><span class="line">59.	                perr_exit(&quot;too many clients&quot;);  </span><br><span class="line">60.	  </span><br><span class="line">61.	            client[i].events = POLLRDNORM;      /* 设置刚刚返回的connfd，监控读事件 */  </span><br><span class="line">62.	            if (i &gt; maxi)  </span><br><span class="line">63.	                maxi = i;                       /* 更新client[]中最大元素下标 */  </span><br><span class="line">64.	            if (--nready &lt;= 0)  </span><br><span class="line">65.	                continue;                       /* 没有更多就绪事件时,继续回到poll阻塞 */  </span><br><span class="line">66.	        &#125;  </span><br><span class="line">67.	        for (i = 1; i &lt;= maxi; i++) &#123;            /* 检测client[] */  </span><br><span class="line">68.	            if ((sockfd = client[i].fd) &lt; 0)  </span><br><span class="line">69.	                continue;  </span><br><span class="line">70.	            if (client[i].revents &amp; (POLLRDNORM | POLLERR)) &#123;  </span><br><span class="line">71.	                if ((n = Read(sockfd, buf, MAXLINE)) &lt; 0) &#123;  </span><br><span class="line">72.	                    if (errno == ECONNRESET) &#123; /* 当收到 RST标志时 */  </span><br><span class="line">73.	                        /* connection reset by client */  </span><br><span class="line">74.	                        printf(&quot;client[%d] aborted connection\n&quot;, i);  </span><br><span class="line">75.	                        Close(sockfd);  </span><br><span class="line">76.	                        client[i].fd = -1;  </span><br><span class="line">77.	                    &#125; else &#123;  </span><br><span class="line">78.	                        perr_exit(&quot;read error&quot;);  </span><br><span class="line">79.	                    &#125;  </span><br><span class="line">80.	                &#125; else if (n == 0) &#123;  </span><br><span class="line">81.	                    /* connection closed by client */  </span><br><span class="line">82.	                    printf(&quot;client[%d] closed connection\n&quot;, i);  </span><br><span class="line">83.	                    Close(sockfd);  </span><br><span class="line">84.	                    client[i].fd = -1;  </span><br><span class="line">85.	                &#125; else &#123;  </span><br><span class="line">86.	                    for (j = 0; j &lt; n; j++)  </span><br><span class="line">87.	                        buf[j] = toupper(buf[j]);  </span><br><span class="line">88.	                        Writen(sockfd, buf, n);  </span><br><span class="line">89.	                &#125;  </span><br><span class="line">90.	                if (--nready &lt;= 0)  </span><br><span class="line">91.	                    break;              /* no more readable descriptors */  </span><br><span class="line">92.	            &#125;  </span><br><span class="line">93.	        &#125;  </span><br><span class="line">94.	    &#125;  </span><br><span class="line">95.	    return 0;  </span><br><span class="line">96.	&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="epoll函数实现的多路IO转接"><a href="#epoll函数实现的多路IO转接" class="headerlink" title="epoll函数实现的多路IO转接"></a>epoll函数实现的多路IO转接</h2><h3 id="突破1024文件描述符设置"><a href="#突破1024文件描述符设置" class="headerlink" title="突破1024文件描述符设置"></a>突破1024文件描述符设置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">突破 1024 文件描述符限制：</span><br><span class="line"></span><br><span class="line">	cat /proc/sys/fs/file-max  --&gt; 当前计算机所能打开的最大文件个数。 受硬件影响。</span><br><span class="line"></span><br><span class="line">	ulimit -a 	——&gt; 当前用户下的进程，默认打开文件描述符个数。  缺省为 1024</span><br><span class="line"></span><br><span class="line">	修改：</span><br><span class="line">		打开 sudo vi /etc/security/limits.conf， 写入：</span><br><span class="line"></span><br><span class="line">		* soft nofile 65536			--&gt; 设置默认值， 可以直接借助命令修改。 【注销用户，使其生效】</span><br><span class="line"></span><br><span class="line">		* hard nofile 100000			--&gt; 命令修改上限。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cat /proc/sys/fs/file-max		查看最大文件描述符上限</span><br><span class="line">ulimit -a 	来查看open files</span><br><span class="line">sudo vi /etc/security/limits.conf  修改上限，修改之后，注销用户重新登录，查看文件描述符上限</span><br><span class="line">如果使用ulimit -n  来修改，会受到之前设置的hard的限制</span><br><span class="line">用ulimit -n设置之后，往下调可以，往上调需要注销用户再登录。</span><br></pre></td></tr></table></figure>

<h3 id="epoll-create和epoll-ctl"><a href="#epoll-create和epoll-ctl" class="headerlink" title="epoll_create和epoll_ctl"></a>epoll_create和epoll_ctl</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">epoll：</span><br><span class="line">	int epoll_create(int size);						创建一棵监听红黑树</span><br><span class="line"></span><br><span class="line">		size：创建的红黑树的监听节点数量。（仅供内核参考。）</span><br><span class="line"></span><br><span class="line">		返回值：指向新创建的红黑树的根节点的 fd。 </span><br><span class="line"></span><br><span class="line">			失败： -1 errno</span><br><span class="line"></span><br><span class="line">	int epoll_create1(int flags);</span><br><span class="line">		If  flags  is 0, then, other than the fact that the obsolete size argument is dropped, epoll_create1() is the same</span><br><span class="line">       as epoll_create().  The following value can be included in flags to obtain different behavior:</span><br><span class="line"></span><br><span class="line">       EPOLL_CLOEXEC</span><br><span class="line">              Set the close-on-exec (FD_CLOEXEC) flag on the new file descriptor.  See the description of  the  O_CLOEXEC</span><br><span class="line">              flag in open(2) for reasons why this may be useful.</span><br><span class="line">              相当于上面的多调用了一次f_cntl函数指定为O_CLOEXEC，节点数量依赖于系统的资源</span><br><span class="line">              </span><br><span class="line">	int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);	操作监听红黑树</span><br><span class="line"></span><br><span class="line">		epfd：epoll_create 函数的返回值。 epfd</span><br><span class="line"></span><br><span class="line">		op：对该监听红黑数所做的操作。</span><br><span class="line"></span><br><span class="line">			EPOLL_CTL_ADD 添加fd到 监听红黑树</span><br><span class="line"></span><br><span class="line">			EPOLL_CTL_MOD 修改fd在 监听红黑树上的监听事件。</span><br><span class="line"></span><br><span class="line">			EPOLL_CTL_DEL 将一个fd 从监听红黑树上摘下（取消监听）</span><br><span class="line"></span><br><span class="line">		fd：</span><br><span class="line">			待监听的fd</span><br><span class="line"></span><br><span class="line">		event：	本质 struct epoll_event 结构体 地址</span><br><span class="line"></span><br><span class="line">			成员 events：</span><br><span class="line">	</span><br><span class="line">				EPOLLIN / EPOLLOUT / EPOLLERR</span><br><span class="line"></span><br><span class="line">			成员 data： 联合体（共用体）：</span><br><span class="line"></span><br><span class="line">				int fd;	  对应监听事件的 fd</span><br><span class="line"></span><br><span class="line">				void *ptr； </span><br><span class="line"></span><br><span class="line">				uint32_t u32;</span><br><span class="line"></span><br><span class="line">				uint64_t u64;		</span><br><span class="line"></span><br><span class="line">		返回值：成功 0； 失败： -1 errno</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="epoll-wait函数"><a href="#epoll-wait函数" class="headerlink" title="epoll_wait函数"></a>epoll_wait函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); 	 阻塞监听。</span><br><span class="line"></span><br><span class="line">		epfd：epoll_create 函数的返回值。 epfd</span><br><span class="line"></span><br><span class="line">		events：传出参数，【数组】， 满足监听条件的 那些 fd 结构体。</span><br><span class="line"></span><br><span class="line">		maxevents：数组 元素的总个数。 1024</span><br><span class="line">				</span><br><span class="line">			struct epoll_event events[1024]</span><br><span class="line">		timeout：</span><br><span class="line"></span><br><span class="line">			-1: 阻塞</span><br><span class="line"></span><br><span class="line">			0： 不阻塞</span><br><span class="line"></span><br><span class="line">			&gt;0: 超时时间 （毫秒）</span><br><span class="line"></span><br><span class="line">		返回值：</span><br><span class="line"></span><br><span class="line">			&gt; 0: 满足监听的 总个数。 可以用作循环上限。</span><br><span class="line"></span><br><span class="line">			0： 没有fd满足监听事件</span><br><span class="line"></span><br><span class="line">			-1：失败。 errno</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &quot;wrap.h&quot;</span><br><span class="line"></span><br><span class="line">#define MAXLINE 80</span><br><span class="line">#define SERV_PORT 6666</span><br><span class="line">#define OPEN_MAX 1024</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int i, j, listenfd, connfd, sockfd;</span><br><span class="line">	int nready, efd, res;</span><br><span class="line">	ssize_t n;</span><br><span class="line">	char buf[MAXLINE], str[INET_ADDRSTRLEN];</span><br><span class="line">	socklen_t clilen;</span><br><span class="line">	</span><br><span class="line">	struct sockaddr_in cliaddr, servaddr;</span><br><span class="line">	struct epoll_event tep, ep[OPEN_MAX];//tep: epoll_ctl参数  ep[] : epoll_wait参数</span><br><span class="line"></span><br><span class="line">	listenfd = Socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">	int opt = 1;  </span><br><span class="line">	setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt));      //端口复用</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, sizeof(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">	Bind(listenfd, (struct sockaddr *) &amp;servaddr, sizeof(servaddr));</span><br><span class="line"></span><br><span class="line">	Listen(listenfd, 20);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	efd = epoll_create(OPEN_MAX);//创建epoll模型, efd指向红黑树根节点 </span><br><span class="line">	if (efd == -1)</span><br><span class="line">		perr_exit(&quot;epoll_create&quot;);</span><br><span class="line"></span><br><span class="line">	tep.events = EPOLLIN; </span><br><span class="line">	tep.data.fd = listenfd; //指定lfd的监听时间为&quot;读&quot;</span><br><span class="line"></span><br><span class="line">	res = epoll_ctl(efd, EPOLL_CTL_ADD, listenfd, &amp;tep);//将lfd及对应的结构体设置到树上,efd可找到该树  </span><br><span class="line">	if (res == -1)</span><br><span class="line">		perr_exit(&quot;epoll_ctl&quot;);</span><br><span class="line"></span><br><span class="line">	while (1) &#123;/*epoll为server阻塞监听事件, ep为struct epoll_event类型数组, OPEN_MAX为数组容量, -1表永久阻塞*/  </span><br><span class="line">		nready = epoll_wait(efd, ep, OPEN_MAX, -1);			 /* 阻塞监听 */</span><br><span class="line">		if (nready == -1)</span><br><span class="line">			perr_exit(&quot;epoll_wait&quot;);</span><br><span class="line"></span><br><span class="line">		for (i = 0; i &lt; nready; i++) &#123;</span><br><span class="line">			if (!(ep[i].events &amp; EPOLLIN))//如果不是&quot;读&quot;事件, 继续循环 </span><br><span class="line">				continue;</span><br><span class="line">			if (ep[i].data.fd == listenfd) &#123;//判断满足事件的fd是不是lfd    </span><br><span class="line">				clilen = sizeof(cliaddr);</span><br><span class="line">				connfd = Accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;clilen);//接受链接 </span><br><span class="line">				printf(&quot;received from %s at PORT %d\n&quot;, </span><br><span class="line">						inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, sizeof(str)), </span><br><span class="line">						ntohs(cliaddr.sin_port));</span><br><span class="line">				</span><br><span class="line">				</span><br><span class="line"></span><br><span class="line">				tep.events = EPOLLIN; </span><br><span class="line">				tep.data.fd = connfd;</span><br><span class="line">				res = epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &amp;tep);//加入红黑树</span><br><span class="line">				if (res == -1)</span><br><span class="line">					perr_exit(&quot;epoll_ctl&quot;);</span><br><span class="line">			&#125; else &#123;  															//不是lfd</span><br><span class="line">				sockfd = ep[i].data.fd;</span><br><span class="line">				n = Read(sockfd, buf, MAXLINE);</span><br><span class="line">				if (n == 0) &#123;										//读到0,说明客户端关闭链接</span><br><span class="line">					</span><br><span class="line">					res = epoll_ctl(efd, EPOLL_CTL_DEL, sockfd, NULL);  //将该文件描述符从红黑树摘</span><br><span class="line">					if (res == -1)</span><br><span class="line">						perr_exit(&quot;epoll_ctl&quot;);</span><br><span class="line"></span><br><span class="line">					Close(sockfd);									 //关闭与该客户端的链接 </span><br><span class="line">					printf(&quot;client[%d] closed connection\n&quot;, j);</span><br><span class="line">				&#125; else &#123;	//实际读到了字节数</span><br><span class="line">					for (j = 0; j &lt; n; j++)	</span><br><span class="line">						buf[j] = toupper(buf[j]);</span><br><span class="line">					Writen(sockfd, buf, n);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	close(listenfd);</span><br><span class="line">	close(efd);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="read函数返回值"><a href="#read函数返回值" class="headerlink" title="read函数返回值:"></a>read函数返回值:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; 0:实际读到的字节数</span><br><span class="line">=0:</span><br><span class="line">	socket中，表示对端关闭。close ()</span><br><span class="line">-1:</span><br><span class="line">    如果errno == EINTR被异常终端。 需要重启。</span><br><span class="line">    如果errno = EAGIN或EYOULDBLOCK以非阻塞方式读数据，但是没有数据。需要， 再次读。</span><br><span class="line">    如果errno == ECONNRESET说明连接被 重置。需要close ()，移除监听队列。</span><br><span class="line">    错误。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">while( (len = read(fd, buf, sizeof(buf))) &gt; 0 ) &#123;   </span><br><span class="line">        // 发送读出的数据</span><br><span class="line">        ret = send(cfd, buf, len, 0);</span><br><span class="line">        if (ret == -1) &#123;</span><br><span class="line">            if (errno == EAGAIN) &#123;</span><br><span class="line">                perror(&quot;send error:&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125; else if (errno == EINTR) &#123;</span><br><span class="line">                perror(&quot;send error:&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                perror(&quot;send error:&quot;);</span><br><span class="line">                exit(1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="ET和LT模式"><a href="#ET和LT模式" class="headerlink" title="ET和LT模式"></a>ET和LT模式</h2><p>epoll是Linux下多路复用IO接口select&#x2F;poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率，因为它会复用文件描述符集合来传递结果而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合，另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。</p>
<p><img src="/Linux-%E5%A4%9A%E8%B7%AFI-O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230713145435478.png" alt="image-20230713145435478"></p>
<img src="/2023/07/12/Linux-%E5%A4%9A%E8%B7%AFI-O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230713145435478.png" class title="This is an test image">

<p>EPOLL事件有两种模型：</p>
<p>​	Edge Triggered (ET) 边缘触发只有数据到来才触发，不管缓存区中是否还有数据。</p>
<p>​	Level Triggered (LT) 水平触发只要有数据都会触发。</p>
<p>用一个子进程来写内容，用ET和LT模式来读取，结果很能说明问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;sys/epoll.h&gt;  </span><br><span class="line">#include &lt;errno.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">  </span><br><span class="line">#define MAXLINE 10  </span><br><span class="line">  </span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">    int efd, i;  </span><br><span class="line">    int pfd[2];  </span><br><span class="line">    pid_t pid;  </span><br><span class="line">    char buf[MAXLINE], ch = &#x27;a&#x27;;  </span><br><span class="line">  </span><br><span class="line">    pipe(pfd);  //管道</span><br><span class="line">    pid = fork();  </span><br><span class="line">  </span><br><span class="line">    if (pid == 0) &#123;             //子 写  </span><br><span class="line">        close(pfd[0]);  </span><br><span class="line">        while (1) &#123;  </span><br><span class="line">            //aaaa\n  </span><br><span class="line">            for (i = 0; i &lt; MAXLINE/2; i++)  </span><br><span class="line">                buf[i] = ch;  </span><br><span class="line">            buf[i-1] = &#x27;\n&#x27;;  </span><br><span class="line">            ch++;  </span><br><span class="line">            //bbbb\n  </span><br><span class="line">            for (; i &lt; MAXLINE; i++)  </span><br><span class="line">                buf[i] = ch;  </span><br><span class="line">            buf[i-1] = &#x27;\n&#x27;;  </span><br><span class="line">            ch++;  </span><br><span class="line">            //aaaa\nbbbb\n  </span><br><span class="line">            write(pfd[1], buf, sizeof(buf));  </span><br><span class="line">            sleep(5);  </span><br><span class="line">        &#125;  </span><br><span class="line">        close(pfd[1]);  </span><br><span class="line">  </span><br><span class="line">    &#125; else if (pid &gt; 0) &#123;       //父 读  </span><br><span class="line">        struct epoll_event event;  </span><br><span class="line">        struct epoll_event resevent[10];        //epoll_wait就绪返回event  </span><br><span class="line">        int res, len;  </span><br><span class="line">  </span><br><span class="line">        close(pfd[1]);  </span><br><span class="line">        efd = epoll_create(10);  </span><br><span class="line">  </span><br><span class="line">        event.events = EPOLLIN | EPOLLET;     // ET 边沿触发  </span><br><span class="line">       // event.events = EPOLLIN;                 // LT 水平触发 (默认)  </span><br><span class="line">        event.data.fd = pfd[0];  </span><br><span class="line">        epoll_ctl(efd, EPOLL_CTL_ADD, pfd[0], &amp;event);  </span><br><span class="line">  </span><br><span class="line">        while (1) &#123;  </span><br><span class="line">            res = epoll_wait(efd, resevent, 10, -1);  </span><br><span class="line">            printf(&quot;res %d\n&quot;, res);  </span><br><span class="line">            if (resevent[0].data.fd == pfd[0]) &#123;  </span><br><span class="line">                len = read(pfd[0], buf, MAXLINE/2);  </span><br><span class="line">                write(STDOUT_FILENO, buf, len);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        close(pfd[0]);  </span><br><span class="line">        close(efd);  </span><br><span class="line">  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        perror(&quot;fork&quot;);  </span><br><span class="line">        exit(-1);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>简单理解就是，水平触发就是有数据就触发，边沿触发是有新数据进来才触发。</p>
<h2 id="网络中ET和LT模式"><a href="#网络中ET和LT模式" class="headerlink" title="网络中ET和LT模式"></a>网络中ET和LT模式</h2><p>server代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;netinet/in.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">#include &lt;signal.h&gt;  </span><br><span class="line">#include &lt;sys/wait.h&gt;  </span><br><span class="line">#include &lt;sys/types.h&gt;  </span><br><span class="line">#include &lt;sys/epoll.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">  </span><br><span class="line">#define MAXLINE 10  </span><br><span class="line">#define SERV_PORT 9000  </span><br><span class="line">  </span><br><span class="line">int main(void)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct sockaddr_in servaddr, cliaddr;  </span><br><span class="line">    socklen_t cliaddr_len;  </span><br><span class="line">    int listenfd, connfd;  </span><br><span class="line">    char buf[MAXLINE];  </span><br><span class="line">    char str[INET_ADDRSTRLEN];  </span><br><span class="line">    int efd;  </span><br><span class="line">  </span><br><span class="line">    listenfd = socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">  </span><br><span class="line">    bzero(&amp;servaddr, sizeof(servaddr));  </span><br><span class="line">    servaddr.sin_family = AF_INET;  </span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);  </span><br><span class="line">  </span><br><span class="line">    bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));  </span><br><span class="line">  </span><br><span class="line">    listen(listenfd, 20);  </span><br><span class="line">  </span><br><span class="line">    struct epoll_event event;  </span><br><span class="line">    struct epoll_event resevent[10];  </span><br><span class="line">    int res, len;  </span><br><span class="line">  </span><br><span class="line">    efd = epoll_create(10);  </span><br><span class="line">    event.events = EPOLLIN | EPOLLET;     /* ET 边沿触发 */  </span><br><span class="line">    //event.events = EPOLLIN;                 /* 默认 LT 水平触发 */  </span><br><span class="line">  </span><br><span class="line">    printf(&quot;Accepting connections ...\n&quot;);  </span><br><span class="line">  </span><br><span class="line">    cliaddr_len = sizeof(cliaddr);  </span><br><span class="line">    connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);  </span><br><span class="line">    printf(&quot;received from %s at PORT %d\n&quot;,  </span><br><span class="line">            inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, sizeof(str)),  </span><br><span class="line">            ntohs(cliaddr.sin_port));  </span><br><span class="line">  </span><br><span class="line">    event.data.fd = connfd;  </span><br><span class="line">    epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &amp;event);  </span><br><span class="line">  </span><br><span class="line">    while (1) &#123;  </span><br><span class="line">        res = epoll_wait(efd, resevent, 10, -1);  </span><br><span class="line">  </span><br><span class="line">        printf(&quot;res %d\n&quot;, res);  </span><br><span class="line">        if (resevent[0].data.fd == connfd) &#123;  </span><br><span class="line">            len = read(connfd, buf, MAXLINE/2);         //readn(500)     </span><br><span class="line">            write(STDOUT_FILENO, buf, len);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>client代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">#include &lt;netinet/in.h&gt;  </span><br><span class="line">  </span><br><span class="line">#define MAXLINE 10  </span><br><span class="line">#define SERV_PORT 9000  </span><br><span class="line">  </span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">    struct sockaddr_in servaddr;  </span><br><span class="line">    char buf[MAXLINE];  </span><br><span class="line">    int sockfd, i;  </span><br><span class="line">    char ch = &#x27;a&#x27;;  </span><br><span class="line">  </span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">  </span><br><span class="line">    bzero(&amp;servaddr, sizeof(servaddr));  </span><br><span class="line">    servaddr.sin_family = AF_INET;  </span><br><span class="line">    inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;servaddr.sin_addr);  </span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);  </span><br><span class="line">  </span><br><span class="line">    connect(sockfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));  </span><br><span class="line">  </span><br><span class="line">    while (1) &#123;  </span><br><span class="line">        //aaaa\n  </span><br><span class="line">        for (i = 0; i &lt; MAXLINE/2; i++)  </span><br><span class="line">            buf[i] = ch;  </span><br><span class="line">        buf[i-1] = &#x27;\n&#x27;;  </span><br><span class="line">        ch++;  </span><br><span class="line">        //bbbb\n  </span><br><span class="line">        for (; i &lt; MAXLINE; i++)  </span><br><span class="line">            buf[i] = ch;  </span><br><span class="line">        buf[i-1] = &#x27;\n&#x27;;  </span><br><span class="line">        ch++;  </span><br><span class="line">        //aaaa\nbbbb\n  </span><br><span class="line">        write(sockfd, buf, sizeof(buf));  </span><br><span class="line">        sleep(5);  </span><br><span class="line">    &#125;  </span><br><span class="line">    close(sockfd);  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行后，每过5秒钟服务器才输出一组字符，这是就是边沿触发的效果</p>
<p>更改服务器为水平触发模式，运行程序，运行后，每5秒输出两组字符串，这是因为只写入了两组，这个模式的服务器，缓冲区有多少读多少。</p>
<h3 id="epoll的ET非阻塞模式"><a href="#epoll的ET非阻塞模式" class="headerlink" title="epoll的ET非阻塞模式"></a>epoll的ET非阻塞模式</h3><p>readn调用的阻塞，比如设定读500个字符，但是只读到498，完事儿阻塞了，等另剩下的2个字符，然而在server代码里，一旦read变为readn阻塞了，它就不会被唤醒了，因为epoll_wait因为readn的阻塞不会循环执行，读不到新数据。有点死锁的意思，差俩字符所以阻塞，因为阻塞，读不到新字符。</p>
<p>LT(level triggered)：LT是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的select&#x2F;poll都是这种模型的代表。</p>
<p>ET(edge-triggered)：ET是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知。请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once).</p>
<p>用fcntl设置阻塞</p>
<p>非阻塞epoll的服务器代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;netinet/in.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">#include &lt;sys/wait.h&gt;  </span><br><span class="line">#include &lt;sys/types.h&gt;  </span><br><span class="line">#include &lt;sys/epoll.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;fcntl.h&gt;  </span><br><span class="line">  </span><br><span class="line">#define MAXLINE 10  </span><br><span class="line">#define SERV_PORT 8000  </span><br><span class="line">  </span><br><span class="line">int main(void)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct sockaddr_in servaddr, cliaddr;  </span><br><span class="line">    socklen_t cliaddr_len;  </span><br><span class="line">    int listenfd, connfd;  </span><br><span class="line">    char buf[MAXLINE];  </span><br><span class="line">    char str[INET_ADDRSTRLEN];  </span><br><span class="line">    int efd, flag;  </span><br><span class="line">  </span><br><span class="line">    listenfd = socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">  </span><br><span class="line">    bzero(&amp;servaddr, sizeof(servaddr));  </span><br><span class="line">    servaddr.sin_family = AF_INET;  </span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);  </span><br><span class="line">  </span><br><span class="line">    bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));  </span><br><span class="line">  </span><br><span class="line">    listen(listenfd, 20);  </span><br><span class="line">  </span><br><span class="line">    ///////////////////////////////////////////////////////////////////////  </span><br><span class="line">    struct epoll_event event;  </span><br><span class="line">    struct epoll_event res_event[10];  </span><br><span class="line">    int res, len;  </span><br><span class="line">  </span><br><span class="line">    efd = epoll_create(10);  </span><br><span class="line">  </span><br><span class="line">    event.events = EPOLLIN | EPOLLET;     /* ET 边沿触发，默认是水平触发 */  </span><br><span class="line">  </span><br><span class="line">    //event.events = EPOLLIN;  </span><br><span class="line">    printf(&quot;Accepting connections ...\n&quot;);  </span><br><span class="line">    cliaddr_len = sizeof(cliaddr);  </span><br><span class="line">    connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);  </span><br><span class="line">    printf(&quot;received from %s at PORT %d\n&quot;,  </span><br><span class="line">            inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, sizeof(str)),  </span><br><span class="line">            ntohs(cliaddr.sin_port));  </span><br><span class="line">  </span><br><span class="line">    flag = fcntl(connfd, F_GETFL);          /* 修改connfd为非阻塞读 */  </span><br><span class="line">    flag |= O_NONBLOCK;  </span><br><span class="line">    fcntl(connfd, F_SETFL, flag);  </span><br><span class="line">  </span><br><span class="line">    event.data.fd = connfd;  </span><br><span class="line">    epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &amp;event);      //将connfd加入监听红黑树  </span><br><span class="line">    while (1) &#123;  </span><br><span class="line">        printf(&quot;epoll_wait begin\n&quot;);  </span><br><span class="line">        res = epoll_wait(efd, res_event, 10, -1);        //最多10个, 阻塞监听  </span><br><span class="line">        printf(&quot;epoll_wait end res %d\n&quot;, res);  </span><br><span class="line">  </span><br><span class="line">        if (res_event[0].data.fd == connfd) &#123;  </span><br><span class="line">            while ((len = read(connfd, buf, MAXLINE/2)) &gt;0 )    //非阻塞读, 轮询  </span><br><span class="line">                write(STDOUT_FILENO, buf, len);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其实就是多了这几行：</p>
<pre><code>flag = fcntl(connfd, F_GETFL);          /* 修改connfd为非阻塞读 */  
flag |= O_NONBLOCK;  
fcntl(connfd, F_SETFL, flag);  
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">结论：</span><br><span class="line">		epoll 的 ET模式， 高效模式，但是只支持 非阻塞模式。 --- 忙轮询。</span><br><span class="line"></span><br><span class="line">		struct epoll_event event;</span><br><span class="line"></span><br><span class="line">		event.events = EPOLLIN | EPOLLET;</span><br><span class="line">		event.data.fd = connfd;</span><br><span class="line"></span><br><span class="line">		epoll_ctl(epfd, EPOLL_CTL_ADD, connfd， &amp;event);	</span><br><span class="line"></span><br><span class="line">		int flg = fcntl(cfd, F_GETFL);	</span><br><span class="line"></span><br><span class="line">		flg |= O_NONBLOCK;</span><br><span class="line"></span><br><span class="line">		fcntl(cfd, F_SETFL, flg);</span><br><span class="line"></span><br><span class="line">	优点：</span><br><span class="line"></span><br><span class="line">		高效。突破1024文件描述符。</span><br><span class="line"></span><br><span class="line">	缺点：</span><br><span class="line">		不能跨平台。 Linux。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">后面使用epoll就用这种非阻塞的</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="epoll反应堆模型总述"><a href="#epoll反应堆模型总述" class="headerlink" title="epoll反应堆模型总述"></a>epoll反应堆模型总述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">epoll 反应堆模型：</span><br><span class="line"></span><br><span class="line">	epoll ET模式 + 非阻塞、轮询 + void *ptr。</span><br><span class="line"></span><br><span class="line">	原来：	socket、bind、listen -- epoll_create 创建监听 红黑树 --  返回 epfd -- epoll_ctl() 向树上添加一个监听fd -- while（1）--</span><br><span class="line"></span><br><span class="line">		-- epoll_wait 监听 -- 对应监听fd有事件产生 -- 返回 监听满足数组。 -- 判断返回数组元素 -- lfd满足 -- Accept -- cfd 满足 </span><br><span class="line"></span><br><span class="line">		-- read() --- 小-&gt;大 -- write回去。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">反应堆：不但要监听 cfd 的读事件、还要监听cfd的写事件。</span><br><span class="line"></span><br><span class="line">		socket、bind、listen -- epoll_create 创建监听 红黑树 --  返回 epfd -- epoll_ctl() 向树上添加一个监听fd -- while（1）--</span><br><span class="line"></span><br><span class="line">		-- epoll_wait 监听 -- 对应监听fd有事件产生 -- 返回 监听满足数组。 -- 判断返回数组元素 -- lfd满足 -- Accept -- cfd 满足 </span><br><span class="line"></span><br><span class="line">		-- read() --- 小-&gt;大 -- cfd从监听红黑树上摘下 -- EPOLLOUT -- 回调函数 -- epoll_ctl() -- EPOLL_CTL_ADD 重新放到红黑上监听写事件</span><br><span class="line"></span><br><span class="line">		-- 等待 epoll_wait 返回 -- 说明 cfd 可写 -- write回去 -- cfd从监听红黑树上摘下 -- EPOLLIN </span><br><span class="line"></span><br><span class="line">		-- epoll_ctl() -- EPOLL_CTL_ADD 重新放到红黑上监听读事件 -- epoll_wait 监听</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">反应堆的理解：加入IO转接之后，有了事件，server才去处理，这里反应堆也是这样，由于网络环境复杂，服务器处理数据之后，可能并不能直接写回去，比如遇到网络繁忙或者对方缓冲区已经满了这种情况，就不能直接写回给客户端。反应堆就是在处理数据之后，监听写事件，能写会客户端了，才去做写回操作。写回之后，再改为监听读事件。如此循环。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="epoll反应堆main逻辑"><a href="#epoll反应堆main逻辑" class="headerlink" title="epoll反应堆main逻辑"></a>epoll反应堆main逻辑</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> *epoll基于非阻塞I/O事件驱动 </span><br><span class="line"> */  </span><br><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;sys/socket.h&gt;  </span><br><span class="line">#include &lt;sys/epoll.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">#include &lt;fcntl.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;errno.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;time.h&gt;  </span><br><span class="line">  </span><br><span class="line">#define MAX_EVENTS  1024                                    //监听上限数  </span><br><span class="line">#define BUFLEN 4096  </span><br><span class="line">#define SERV_PORT   8080  </span><br><span class="line">  </span><br><span class="line">void recvdata(int fd, int events, void *arg);  </span><br><span class="line">void senddata(int fd, int events, void *arg);  </span><br><span class="line">  </span><br><span class="line">/* 描述就绪文件描述符相关信息 */  </span><br><span class="line">  </span><br><span class="line">struct myevent_s &#123;  </span><br><span class="line">    int fd;                                                 //要监听的文件描述符  </span><br><span class="line">    int events;                                             //对应的监听事件  </span><br><span class="line">    void *arg;                                              //泛型参数  </span><br><span class="line">    void (*call_back)(int fd, int events, void *arg);       //回调函数  </span><br><span class="line">    int status;                                             //是否在监听:1-&gt;在红黑树上(监听), 0-&gt;不在(不监听)  </span><br><span class="line">    char buf[BUFLEN];  </span><br><span class="line">    int len;  </span><br><span class="line">    long last_active;                                       //记录每次加入红黑树 g_efd 的时间值  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">int g_efd;                                                  //全局变量, 保存epoll_create返回的文件描述符  </span><br><span class="line">struct myevent_s g_events[MAX_EVENTS+1];                    //自定义结构体类型数组. +1--&gt;listen fd  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">/*将结构体 myevent_s 成员变量 初始化*/  </span><br><span class="line">  </span><br><span class="line">void eventset(struct myevent_s *ev, int fd, void (*call_back)(int, int, void *), void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    ev-&gt;fd = fd;  </span><br><span class="line">    ev-&gt;call_back = call_back;  </span><br><span class="line">    ev-&gt;events = 0;  </span><br><span class="line">    ev-&gt;arg = arg;  </span><br><span class="line">    ev-&gt;status = 0;  </span><br><span class="line">    memset(ev-&gt;buf, 0, sizeof(ev-&gt;buf));  </span><br><span class="line">    ev-&gt;len = 0;  </span><br><span class="line">    ev-&gt;last_active = time(NULL);                       //调用eventset函数的时间  </span><br><span class="line">  </span><br><span class="line">    return;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">/* 向 epoll监听的红黑树 添加一个 文件描述符 */  </span><br><span class="line">  </span><br><span class="line">//eventadd(efd, EPOLLIN, &amp;g_events[MAX_EVENTS]);  </span><br><span class="line">void eventadd(int efd, int events, struct myevent_s *ev)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct epoll_event epv = &#123;0, &#123;0&#125;&#125;;  </span><br><span class="line">    int op;  </span><br><span class="line">    epv.data.ptr = ev;  </span><br><span class="line">    epv.events = ev-&gt;events = events;       //EPOLLIN 或 EPOLLOUT  </span><br><span class="line">  </span><br><span class="line">    if (ev-&gt;status == 0) &#123;                                          //已经在红黑树 g_efd 里  </span><br><span class="line">        op = EPOLL_CTL_ADD;                 //将其加入红黑树 g_efd, 并将status置1  </span><br><span class="line">        ev-&gt;status = 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    if (epoll_ctl(efd, op, ev-&gt;fd, &amp;epv) &lt; 0)                       //实际添加/修改  </span><br><span class="line">        printf(&quot;event add failed [fd=%d], events[%d]\n&quot;, ev-&gt;fd, events);  </span><br><span class="line">    else  </span><br><span class="line">        printf(&quot;event add OK [fd=%d], op=%d, events[%0X]\n&quot;, ev-&gt;fd, op, events);  </span><br><span class="line">  </span><br><span class="line">    return ;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">/* 从epoll 监听的 红黑树中删除一个 文件描述符*/  </span><br><span class="line">  </span><br><span class="line">void eventdel(int efd, struct myevent_s *ev)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct epoll_event epv = &#123;0, &#123;0&#125;&#125;;  </span><br><span class="line">  </span><br><span class="line">    if (ev-&gt;status != 1)                                        //不在红黑树上  </span><br><span class="line">        return ;  </span><br><span class="line">  </span><br><span class="line">    //epv.data.ptr = ev;  </span><br><span class="line">    epv.data.ptr = NULL;  </span><br><span class="line">    ev-&gt;status = 0;                                             //修改状态  </span><br><span class="line">    epoll_ctl(efd, EPOLL_CTL_DEL, ev-&gt;fd, &amp;epv);                //从红黑树 efd 上将 ev-&gt;fd 摘除  </span><br><span class="line">  </span><br><span class="line">    return ;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">/*  当有文件描述符就绪, epoll返回, 调用该函数 与客户端建立链接 */  </span><br><span class="line">  </span><br><span class="line">void acceptconn(int lfd, int events, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct sockaddr_in cin;  </span><br><span class="line">    socklen_t len = sizeof(cin);  </span><br><span class="line">    int cfd, i;  </span><br><span class="line">  </span><br><span class="line">    if ((cfd = accept(lfd, (struct sockaddr *)&amp;cin, &amp;len)) == -1) &#123;  </span><br><span class="line">        if (errno != EAGAIN &amp;&amp; errno != EINTR) &#123;  </span><br><span class="line">            /* 暂时不做出错处理 */  </span><br><span class="line">        &#125;  </span><br><span class="line">        printf(&quot;%s: accept, %s\n&quot;, __func__, strerror(errno));  </span><br><span class="line">        return ;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    do &#123;  </span><br><span class="line">        for (i = 0; i &lt; MAX_EVENTS; i++)                                //从全局数组g_events中找一个空闲元素  </span><br><span class="line">            if (g_events[i].status == 0)                                //类似于select中找值为-1的元素  </span><br><span class="line">                break;                                                  //跳出 for  </span><br><span class="line">  </span><br><span class="line">        if (i == MAX_EVENTS) &#123;  </span><br><span class="line">            printf(&quot;%s: max connect limit[%d]\n&quot;, __func__, MAX_EVENTS);  </span><br><span class="line">            break;                                                      //跳出do while(0) 不执行后续代码  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        int flag = 0;  </span><br><span class="line">        if ((flag = fcntl(cfd, F_SETFL, O_NONBLOCK)) &lt; 0) &#123;             //将cfd也设置为非阻塞  </span><br><span class="line">            printf(&quot;%s: fcntl nonblocking failed, %s\n&quot;, __func__, strerror(errno));  </span><br><span class="line">            break;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        /* 给cfd设置一个 myevent_s 结构体, 回调函数 设置为 recvdata */  </span><br><span class="line">        eventset(&amp;g_events[i], cfd, recvdata, &amp;g_events[i]);     </span><br><span class="line">        eventadd(g_efd, EPOLLIN, &amp;g_events[i]);                         //将cfd添加到红黑树g_efd中,监听读事件  </span><br><span class="line">  </span><br><span class="line">    &#125; while(0);  </span><br><span class="line">  </span><br><span class="line">    printf(&quot;new connect [%s:%d][time:%ld], pos[%d]\n&quot;,   </span><br><span class="line">            inet_ntoa(cin.sin_addr), ntohs(cin.sin_port), g_events[i].last_active, i);  </span><br><span class="line">    return ;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void recvdata(int fd, int events, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct myevent_s *ev = (struct myevent_s *)arg;  </span><br><span class="line">    int len;  </span><br><span class="line">  </span><br><span class="line">    len = recv(fd, ev-&gt;buf, sizeof(ev-&gt;buf), 0);            //读文件描述符, 数据存入myevent_s成员buf中  </span><br><span class="line">  </span><br><span class="line">    eventdel(g_efd, ev);        //将该节点从红黑树上摘除  </span><br><span class="line">  </span><br><span class="line">    if (len &gt; 0) &#123;  </span><br><span class="line">  </span><br><span class="line">        ev-&gt;len = len;  </span><br><span class="line">        ev-&gt;buf[len] = &#x27;\0&#x27;;                                //手动添加字符串结束标记  </span><br><span class="line">        printf(&quot;C[%d]:%s\n&quot;, fd, ev-&gt;buf);  </span><br><span class="line">  </span><br><span class="line">        eventset(ev, fd, senddata, ev);                     //设置该 fd 对应的回调函数为 senddata  </span><br><span class="line">        eventadd(g_efd, EPOLLOUT, ev);                      //将fd加入红黑树g_efd中,监听其写事件  </span><br><span class="line">  </span><br><span class="line">    &#125; else if (len == 0) &#123;  </span><br><span class="line">        close(ev-&gt;fd);  </span><br><span class="line">        /* ev-g_events 地址相减得到偏移元素位置 */  </span><br><span class="line">        printf(&quot;[fd=%d] pos[%ld], closed\n&quot;, fd, ev-g_events);  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        close(ev-&gt;fd);  </span><br><span class="line">        printf(&quot;recv[fd=%d] error[%d]:%s\n&quot;, fd, errno, strerror(errno));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void senddata(int fd, int events, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct myevent_s *ev = (struct myevent_s *)arg;  </span><br><span class="line">    int len;  </span><br><span class="line">  </span><br><span class="line">    len = send(fd, ev-&gt;buf, ev-&gt;len, 0);                    //直接将数据 回写给客户端。未作处理  </span><br><span class="line">  </span><br><span class="line">    eventdel(g_efd, ev);                                //从红黑树g_efd中移除  </span><br><span class="line">  </span><br><span class="line">    if (len &gt; 0) &#123;  </span><br><span class="line">  </span><br><span class="line">        printf(&quot;send[fd=%d], [%d]%s\n&quot;, fd, len, ev-&gt;buf);  </span><br><span class="line">        eventset(ev, fd, recvdata, ev);                     //将该fd的 回调函数改为 recvdata  </span><br><span class="line">        eventadd(g_efd, EPOLLIN, ev);                       //从新添加到红黑树上， 设为监听读事件  </span><br><span class="line">  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        close(ev-&gt;fd);                                      //关闭链接  </span><br><span class="line">        printf(&quot;send[fd=%d] error %s\n&quot;, fd, strerror(errno));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return ;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">/*创建 socket, 初始化lfd */  </span><br><span class="line">  </span><br><span class="line">void initlistensocket(int efd, short port)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct sockaddr_in sin;  </span><br><span class="line">  </span><br><span class="line">    int lfd = socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">    fcntl(lfd, F_SETFL, O_NONBLOCK);                                            //将socket设为非阻塞  </span><br><span class="line">  </span><br><span class="line">    memset(&amp;sin, 0, sizeof(sin));                                               //bzero(&amp;sin, sizeof(sin))  </span><br><span class="line">    sin.sin_family = AF_INET;  </span><br><span class="line">    sin.sin_addr.s_addr = INADDR_ANY;  </span><br><span class="line">    sin.sin_port = htons(port);  </span><br><span class="line">  </span><br><span class="line">    bind(lfd, (struct sockaddr *)&amp;sin, sizeof(sin));  </span><br><span class="line">  </span><br><span class="line">    listen(lfd, 20);  </span><br><span class="line">  </span><br><span class="line">    /* void eventset(struct myevent_s *ev, int fd, void (*call_back)(int, int, void *), void *arg);  */  </span><br><span class="line">    eventset(&amp;g_events[MAX_EVENTS], lfd, acceptconn, &amp;g_events[MAX_EVENTS]);  </span><br><span class="line">  </span><br><span class="line">    /* void eventadd(int efd, int events, struct myevent_s *ev) */  </span><br><span class="line">    eventadd(efd, EPOLLIN, &amp;g_events[MAX_EVENTS]);  </span><br><span class="line">  </span><br><span class="line">    return ;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned short port = SERV_PORT;  </span><br><span class="line">  </span><br><span class="line">    if (argc == 2)  </span><br><span class="line">        port = atoi(argv[1]);                           //使用用户指定端口.如未指定,用默认端口,把参数 str 所指向的字符串转换为一个整数（类型为 int 型）  </span><br><span class="line">  </span><br><span class="line">    g_efd = epoll_create(MAX_EVENTS+1);                 //创建红黑树,返回给全局 g_efd   </span><br><span class="line">    if (g_efd &lt;= 0)  </span><br><span class="line">        printf(&quot;create efd in %s err %s\n&quot;, __func__, strerror(errno));  </span><br><span class="line">  </span><br><span class="line">    initlistensocket(g_efd, port);                      //初始化监听socket  </span><br><span class="line">  </span><br><span class="line">    struct epoll_event events[MAX_EVENTS+1];            //保存已经满足就绪事件的文件描述符数组   </span><br><span class="line">    printf(&quot;server running:port[%d]\n&quot;, port);  </span><br><span class="line">  </span><br><span class="line">    int checkpos = 0, i;  </span><br><span class="line">    while (1) &#123;  </span><br><span class="line">        /* 超时验证，每次测试100个链接，不测试listenfd 当客户端60秒内没有和服务器通信，则关闭此客户端链接 */  </span><br><span class="line">  </span><br><span class="line">        long now = time(NULL);                          //当前时间  </span><br><span class="line">        for (i = 0; i &lt; 100; i++, checkpos++) &#123;         //一次循环检测100个。 使用checkpos控制检测对象  </span><br><span class="line">            if (checkpos == MAX_EVENTS)  </span><br><span class="line">                checkpos = 0;  </span><br><span class="line">            if (g_events[checkpos].status != 1)         //不在红黑树 g_efd 上  </span><br><span class="line">                continue;  </span><br><span class="line">  </span><br><span class="line">            long duration = now - g_events[checkpos].last_active;       //客户端不活跃的世间  </span><br><span class="line">  //用一个last_active存储上次活跃时间，完事儿用当前时间和上次活跃时间来计算不活跃时间长度，不活跃时间超过一定阈值，就踢掉这个客户端。</span><br><span class="line">            if (duration &gt;= 60) &#123;  </span><br><span class="line">                close(g_events[checkpos].fd);                           //关闭与该客户端链接  </span><br><span class="line">                printf(&quot;[fd=%d] timeout\n&quot;, g_events[checkpos].fd);  </span><br><span class="line">                eventdel(g_efd, &amp;g_events[checkpos]);                   //将该客户端 从红黑树 g_efd移除  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        /*监听红黑树g_efd, 将满足的事件的文件描述符加至events数组中, 1秒没有事件满足, 返回 0*/  </span><br><span class="line">        int nfd = epoll_wait(g_efd, events, MAX_EVENTS+1, 1000);  </span><br><span class="line">        if (nfd &lt; 0) &#123;  </span><br><span class="line">            printf(&quot;epoll_wait error, exit\n&quot;);  </span><br><span class="line">            break;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        for (i = 0; i &lt; nfd; i++) &#123;  </span><br><span class="line">            /*使用自定义结构体myevent_s类型指针, 接收 联合体data的void *ptr成员*/  </span><br><span class="line">            struct myevent_s *ev = (struct myevent_s *)events[i].data.ptr;    </span><br><span class="line">  </span><br><span class="line">            if ((events[i].events &amp; EPOLLIN) &amp;&amp; (ev-&gt;events &amp; EPOLLIN)) &#123;           //读就绪事件  </span><br><span class="line">                ev-&gt;call_back(ev-&gt;fd, events[i].events, ev-&gt;arg);  </span><br><span class="line">                //lfd  EPOLLIN    </span><br><span class="line">            &#125;  </span><br><span class="line">            if ((events[i].events &amp; EPOLLOUT) &amp;&amp; (ev-&gt;events &amp; EPOLLOUT)) &#123;         //写就绪事件  </span><br><span class="line">                ev-&gt;call_back(ev-&gt;fd, events[i].events, ev-&gt;arg);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /* 退出前释放所有资源 */  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>main逻辑：创建套接字—》初始化连接—》超时验证—》监听—》处理读事件和写事件</p>
<p>eventset函数指定了不同事件对应的回调函数，所以虽然读写事件都用的call_back来回调，但实际上调用的是不同的函数。</p>
<p>eventset函数：</p>
<p>​    设置回调函数。  lfd –》 acceptconn()</p>
<p>​       cfd –&gt; recvdata();</p>
<p>​      cfd –&gt; senddata();</p>
<p>eventadd函数： </p>
<p>​    将一个fd， 添加到 监听红黑树。 设置监听 read事件，还是监听写事件。</p>
<p>网络编程中：   read — recv()</p>
<p>​      write — send();</p>
<hr>
<h2 id="accept返回EMFILE的处理"><a href="#accept返回EMFILE的处理" class="headerlink" title="accept返回EMFILE的处理"></a>accept返回EMFILE的处理</h2><p><img src="/Linux-%E5%A4%9A%E8%B7%AFI-O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230727221452876.png" alt="image-20230727221452876"></p>
<img src="/2023/07/12/Linux-%E5%A4%9A%E8%B7%AFI-O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230727221452876.png" class title="This is an test image">

<p>如果文件描述符不够用了</p>
<p>准备一个空闲的文件描述符。遇到这种情况，先关闭这个空闲文件，获得一个文件描述符名额;再accept (2)拿到socket连接的文件描述符;随后立刻close(2)，这样就优雅地断开了与客户端的连接;最后重新打开空闲文件，把“坑”填上，以备再次出现这种情况时使用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/09/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/09/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">Linux高性能服务器编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-09 19:40:17" itemprop="dateCreated datePublished" datetime="2023-07-09T19:40:17+08:00">2023-07-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-17 21:52:19" itemprop="dateModified" datetime="2023-07-17T21:52:19+08:00">2023-07-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第1章TCP-x2F-IP协议族"><a href="#第1章TCP-x2F-IP协议族" class="headerlink" title="第1章	TCP&#x2F;IP协议族"></a>第1章	TCP&#x2F;IP协议族</h1><p>TCP&#x2F;IP协议族是一个四层协议系统，自底而上分别是数据链路层、网络层、传输层和应用层。每一层完成不同的功能，且通过若干协议来实现，上层协议使用下层协议提供的服务，如图1-1所示。</p>
<p><img src="/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230709194157137.png" alt="image-20230709194157137"></p>
<img src="/2023/07/09/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230709194157137.png" class title="This is an test image">

<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>数据链路层两个常用的协议是ARP协议(Address Resolve Protocol，地址解析协议）和RARP协议(Reverse Address Resolve Protocol，逆地址解析协议)。它们实现了IP地址和机器物理地址（通常是MAC地址，以太网、令牌环和802.11无线网络都使用MAC地址）之间的相互转换。</p>
<p>网络层使用IP地址寻址一台机器，而数据链路层使用物理地址寻址一台机器，因此网络层必须先将目标机器的IP地址转化成其物理地址，才能使用数据链路层提供的服务，这就是ARP协议的用途。RARP协议仅用于网络上的某些无盘工作站。因为缺乏存储设备，无盘工作站无法记住自己的IP地址，但它们可以利用网卡上的物理地址来向网络管理者（服务器或网络管理软件）查询自身的IP地址。运行RARP服务的网络管理者通常存有该网络上所有机器的物理地址到IP地址的映射。</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>网络层实现数据包的选路和转发。WAN (Wide Area Network，广域网）通常使用众多分级的路由器来连接分散的主机或LAN (Local Area Network，局域网)，因此，通信的两台主机一般不是直接相连的，而是通过多个中间节点（路由器）连接的。网络层的任务就是选择这些中间节点，以确定两台主机之间的通信路径。同时，网络层对上层协议隐藏了网络拓扑连接的细节，使得在传输层和网络应用程序看来，通信的双方是直接相连的。</p>
<p>网络层最核心的协议是IP协议（Internet Protocol，因特网协议)。IP协议根据数据包的目的IP地址来决定如何投递它。如果数据包不能直接发送给目标主机，那么IP协议就为它寻找一个合适的下一跳(next hop）路由器，并将数据包交付给该路由器来转发。多次重复这一过程，数据包最终到达目标主机，或者由于发送失败而被丢弃。可见，IP协议使用逐跳( hop by hop）的方式确定通信路径。</p>
<p>网络层另外一个重要的协议是ICMP协议(Internet Control Message Protocol，因特网控制报文协议)。它是IP协议的重要补充，主要用于检测网络连接。</p>
<p>需要指出的是，ICMP协议并非严格意义上的网络层协议，因为它使用处于同一层的IP协议提供的服务（一般来说，上层协议使用下层协议提供的服务)。</p>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>传输层为两台主机上的应用程序提供端到端(end to end）的通信。与网络层使用的逐跳通信方式不同，传输层只关心通信的起始端和目的端，而不在乎数据包的中转过程。图1-3展示了传输层和网络层的这种区别。</p>
<p><img src="/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230709194848882.png" alt="image-20230709194848882"></p>
<img src="/2023/07/09/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230709194848882.png" class title="This is an test image">

<p>图1-3中，垂直的实线箭头表示TCP&#x2F;IP协议族各层之间的实体通信（数据包确实是沿着这些线路传递的)，而水平的虚线箭头表示逻辑通信线路。该图中还附带描述了不同物理网络的连接方法。可见，数据链路层（驱动程序）封装了物理网络的电气细节；网络层封装了网络连接的细节；传输层则为应用程序封装了一条端到端的逻辑通信链路，它负责数据的收发、链路的超时重连等。</p>
<p>传输层协议主要有三个:TCP协议、UDP协议和SCTP协议。</p>
<p>TCP协议（Transmission Control Protocol，传输控制协议）为应用层提供可靠的、面向连接的和基于流〈 stream）的服务。TCP协议使用超时重传、数据确认等方式来确保数据包被正确地发送至目的端，因此TCP服务是可靠的。使用TCP协议通信的双方必须先建立TCP连接，并在内核中为该连接维持一些必要的数据结构，比如连接的状态、读写缓冲区,以及诸多定时器等。当通信结束时，双方必须关闭连接以释放这些内核数据。TCP服务是基于流的。基于流的数据没有边界（长度）限制，它源源不断地从通信的一端流入另一端。发送端可以逐个字节地向数据流中写人数据，接收端也可以逐个字节地将它们读出。</p>
<p>UDP协议(User Datagram Protocol，用户数据报协议）则与TCP协议完全相反，它为应用层提供不可靠、无连接和基于数据报的服务。“不可靠”意味着UDP协议无法保证数据从发送端正确地传送到目的端。如果数据在中途丢失，或者目的端通过数据校验发现数据错误而将其丢弃，则UDP协议只是简单地通知应用程序发送失败。因此，使用UDP协议的应用程序通常要自己处理数据确认、超时重传等逻辑。UDP协议是无连接的，即通信双方不保持一个长久的联系，因此应用程序每次发送数据都要明确指定接收端的地址（IP地址等信息)。基于数据报的服务，是相对基于流的服务而言的。每个UDP数据报都有一个长度，接收端必须以该长度为最小单位将其所有内容一次性读出，否则数据将被截断。</p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层负责处理应用程序的逻辑。数据链路层、网络层和传输层负责处理网络通信细节，这部分必须既稳定又高效，因此它们都在内核空间中实现，如图1-1所示。而应用层则在用户空间实现，因为它负责处理众多逻辑，比如文件传输、名称查询和网络管理等。如果应用层也在内核中实现，则会使内核变得非常庞大。当然，也有少数服务器程序是在内核中实现的，这样代码就无须在用户空间和内核空间来回切换（主要是数据的复制)，极大地提高了工作效率。不过这种代码实现起来较复杂，不够灵活，且不便于移植。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>上层协议是如何使用下层协议提供的服务的呢?其实这是通过封装（encapsulation）实现的。应用程序数据在发送到物理网络上之前，将沿着协议栈从上往下依次传递。每层协议都将在上层数据的基础上加上自己的头部信息（有时还包括尾部信息)，以实现该层的功能,这个过程就称为封装，如图1-4所示。</p>
<p><img src="/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230709204438647.png" alt="image-20230709204438647"></p>
<img src="/2023/07/09/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230709204438647.png" class title="This is an test image">

<p>帧才是最终在物理网络上传送的字节序列。</p>
<h2 id="分用"><a href="#分用" class="headerlink" title="分用"></a>分用</h2><p>当帧到达目的主机时，将沿着协议栈自底向上依次传递。各层协议依次处理帧中本层负责的头部数据，以获取所需的信息，并最终将处理后的帧交给目标应用程序。这个过程称为分用(demultiplexing)。分用是依靠头部信息中的类型字段实现的。标准文档RFC 1700定义了所有标识上层协议的类型字段以及每个上层协议对应的数值。图1-7显示了以太网帧的分用过程。</p>
<p><img src="/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230709204638829.png" alt="image-20230709204638829"></p>
<img src="/2023/07/09/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230709204638829.png" class title="This is an test image">

<p>因为IP协议、ARP协议和RARP协议都使用帧传输数据，所以帧的头部需要提供某个字段（具体情况取决于帧的类型）来区分它们。以以太网帧为例，它使用2字节的类型字段来标识上层协议（见图1-6)。如果主机接收到的以太网帧类型字段的值为0x800，则帧的数据部分为IP数据报（见图1-4)，以太网驱动程序就将帧交付给IP模块﹔若类型字段的值为0x806，则帧的数据部分为ARP请求或应答报文，以太网驱动程序就将帧交付给ARP模块;若类型字段的值为0x835，则帧的数据部分为RARP请求或应答报文，以太网驱动程序就将帧交付给RARP模块。</p>
<p>同样，因为ICMP 协议、TCP协议和UDP协议都使用IP协议，所以IP数据报的头部采用16位的协议（protocol）字段来区分它们。</p>
<p>TCP报文段和UDP数据报则通过其头部中的16位的端口号(port number）字段来区分上层应用程序。比如 DNS协议对应的端口号是53，HTTP协议（Hyper-Text TransferProtocol，超文本传送协议）对应的端口号是80。所有知名应用层协议使用的端口号都可在letcl&#x2F;services 文件中找到。</p>
<p>帧通过上述分用步骤后，最终将封装前的原始数据送至目标服务（图1-7中的ARP服务、RARP服务、ICMP服务或者应用程序)。这样，在顶层目标服务看来，封装和分用似乎没有发生过。</p>
<h2 id="Linux下访问DNS服务"><a href="#Linux下访问DNS服务" class="headerlink" title="Linux下访问DNS服务"></a>Linux下访问DNS服务</h2><p>我们要访问DNS服务，就必须先知道DNS服务器的IP地址。Linux使用&#x2F;etc&#x2F;reso1conf文件来存放DNS服务器的IP地址。机器ernest-laptop上，该文件的内容如下:<br><code>#Generated by Network Manager</code><br><code>nameserver 219.239.26.42</code><br><code>narmeserver 124.207.160.106</code><br>其中的两个IP地址分别是首选 DNS服务器地址和备选DNS服务器地址。文件中的注释语句“Generated by Network Manager”告诉我们，这两个DNS服务器地址是由网络管理程序写入的。<br>Linux 下一个常用的访问DNS服务器的客户端程序是host，比如下面的命令是向首选DNS服务器219.239.26.42查询机器<code>www.baidu.com</code>的IP地址:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xiaohuilin@Ubuntu:~$ host -t A www.baidu.com</span><br><span class="line">www.baidu.com is an alias for www.a.shifen.com.</span><br><span class="line">www.a.shifen.com has address 14.119.104.254</span><br><span class="line">www.a.shifen.com has address 14.119.104.189</span><br></pre></td></tr></table></figure>

<p>host命令的输出告诉我们，机器名<code>www.baidu.com</code>是<code>www.a.shifen.com</code>的别名，并且该机器名对应两个IP地址。host命令使用DNS协议和DNS服务器通信，其-t选项告诉DNS 协议使用哪种查询类型。我们这里使用的是A类型，即通过机器的域名获得其IP地址(但实际上返回的资源记录中还包含机器的别名)。关于host命令的详细使用方法，请参考其man手册。</p>
<h1 id="第2章-IP协议详解"><a href="#第2章-IP协议详解" class="headerlink" title="第2章 IP协议详解"></a>第2章 IP协议详解</h1><h2 id="IP服务特点"><a href="#IP服务特点" class="headerlink" title="IP服务特点"></a>IP服务特点</h2><p>IP协议是TCP&#x2F;IP协议族的动力，它为上层协议提供无状态、无连接、不可靠的服务。</p>
<p>无状态（ stateless）是指IP通信双方不同步传输数据的状态信息，因此所有IP数据报的发送、传输和接收都是相互独立、没有上下文关系的。这种服务最大的缺点是无法处理乱序和重复的IP数据报。比如发送端发送出的第N个IP数据报可能比第N+1个IP数据报后到达接收端，而同一个IP数据报也可能经过不同的路径多次到达接收端。在这两种情况下，接收端的IP模块无法检测到乱序和重复，因为这些IP数据报之间没有任何上下文关系。接收端的P模块只要收到了完整的IP数据报（如果是IP分片的话，IP模块将先执行重组)，就将其数据部分（TCP报文段、UDP数据报或者ICMP报文）上交给上层协议。那么从上层协议来看，这些数据就可能是乱序的、重复的。面向连接的协议，比如TCP协议，则能够自己处理乱序的、重复的报文段，它递交给上层协议的内容绝对是有序的、正确的。</p>
<p>虽然IP数据报头部提供了一个标识字段（见后文）用以唯一标识一个IP数据报，但它是被用来处理IP分片和重组的，而不是用来指示接收顺序的。</p>
<p>无状态服务的优点也很明显:简单、高效。我们无须为保持通信的状态而分配一些内核资源，也无须每次传输数据时都携带状态信息。在网络协议中，无状态是很常见的，比如UDP协议和HTTP协议都是无状态协议。以HTTP协议为例，一个浏览器的连续两次网页请求之间没有任何关联，它们将被Web 服务器独立地处理。</p>
<p>无连接(connectionless）是指IP通信双方都不长久地维持对方的任何信息。这样，上层协议每次发送数据的时候，都必须明确指定对方的IP地址。</p>
<p>不可靠是指IP协议不能保证IP数据报准确地到达接收端，它只是承诺尽最大努力(best effort)。很多种情况都能导致IP数据报发送失败。比如，某个中转路由器发现IP数据报在网络上存活的时间太长（根据IP数据报头部字段TTL判断，见后文)，那么它将丢弃之，并返回一个ICMP错误消息（超时错误）给发送端。又比如，接收端发现收到的IP数据报不正确（通过校验机制)，它也将丢弃之，并返回一个ICMP错误消息（IP头部参数错误)给发送端。无论哪种情况，发送端的IP模块一旦检测到IP数据报发送失败，就通知上层协议发送失败，而不会试图重传。因此，使用IP服务的上层协议（比如TCP协议）需要自己实现数据确认、超时重传等机制以达到可靠传输的目的。</p>
<h2 id="IP路由"><a href="#IP路由" class="headerlink" title="IP路由"></a>IP路由</h2><p><img src="/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230711223803620.png" alt="image-20230711223803620"></p>
<img src="/2023/07/09/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230711223803620.png" class title="This is an test image">

<p>我们从右往左来分析图2-3。当IP模块接收到来自数据链路层的IP数据报时，它首先对该数据报的头部做CRC校验，确认无误之后就分析其头部的具体信息。</p>
<p>如果该IP数据报的头部设置了源站选路选项（松散源路由选择或严格源路由选择)，则IP模块调用数据报转发子模块来处理该数据报。如果该IP数据报的头部中目标IP地址是本机的某个IP地址，或者是广播地址，即该数据报是发送给本机的，则IP模块就根据数据报头部中的协议字段来决定将它派发给哪个上层应用（分用)。如果IP模块发现这个数据报不是发送给本机的，则也调用数据报转发子模块来处理该数据报。</p>
<p>数据报转发子模块将首先检测系统是否允许转发，如果不允许,IP模块就将数据报丢弃。如果允许，数据报转发子模块将对该数据报执行一些操作，然后将它交给IP数据报输出子模块。我们将在后面讨论数据报转发的具体过程。</p>
<p>IP数据报应该发送至哪个下一跳路由（或者目标机器)，以及经过哪个网卡来发送，就是P路由过程，即图2-3中“计算下一跳路由”子模块。IP模块实现数据报路由的核心数据结构是路由表。这个表按照数据报的目标IP地址分类，同一类型的IP数据报将被发往相同的下一跳路由器（或者目标机器)。我们将在后面讨论IP路由过程。</p>
<p>IP输出队列中存放的是所有等待发送的IP数据报，其中除了需要转发的IP数据报外，还包括封装了本机上层数据（ICMP报文、TCP报文段和UDP数据报）的IP数据报。</p>
<p>图2-3中的虚线箭头显示了路由表更新的过程。这一过程是指通过路由协议或者route命令调整路由表，使之更适应最新的网络拓扑结构，称为IP路由策略。</p>
<h2 id="IP转发"><a href="#IP转发" class="headerlink" title="IP转发"></a>IP转发</h2><p>对于允许IP数据报转发的系统（主机或路由器)，数据报转发子模块将对期望转发的数据报执行如下操作:<br>1）检查数据报头部的TTL值。如果 TTL值已经是0，则丢弃该数据报。<br>2〉查看数据报头部的严格源路由选择选项。如果该选项被设置，则检测数据报的目标IP地址是否是本机的某个IP地址。如果不是，则发送一个ICMP源站选路失败报文给发送端。<br>3）如果有必要，则给源端发送一个ICMP重定向报文，以告诉它一个更合理的下一跳路由器。<br>4）将TTL值减1。</p>
<p>5）处理IP头部选项。<br>6）如果有必要，则执行IP分片操作。</p>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p><img src="/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230711224117951.png" alt="image-20230711224117951"></p>
<img src="/2023/07/09/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230711224117951.png" class title="This is an test image">

<h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p>IPv6协议是网络层技术发展的必然趋势。它不仅解决了IPv4地址不够用的问题，还做了很大的改进。比如，增加了多播和流的功能，为网络上多媒体内容的质量提供精细的控制;引入自动配置功能，使得局域网管理更方便﹔增加了专门的网络安全功能等。</p>
<p>注意:IPv6协议并不是IPv4协议的简单扩展，而是完全独立的协议。用以太网帧封装的IPv6数据报和IPv4数据报具有不同的类型值。第1章提到，IPv4数据报的以太网帧封装类型值是0x800，而IPv6数据报的以太网帧封装类型值是0x86dd (见RFC2464)。</p>
<h1 id="第5章"><a href="#第5章" class="headerlink" title="第5章"></a>第5章</h1><h2 id="带外标记"><a href="#带外标记" class="headerlink" title="带外标记"></a>带外标记</h2><p>在实际应用中，我们通常无法预期带外数据何时到来。好在 Linux内核检测到TCP紧急标志时，将通知应用程序有带外数据需要接收。内核通知应用程序带外数据到达的两种常见方式是:IO复用产生的异常事件和SIGURG信号。但是，即使应用程序得到了有带外数据需要接收的通知，还需要知道带外数据在数据流中的具体位置，才能准确接收带外数据。这一点可通过如下系统调用实现:<br><code>#include &lt;sys / socket.h&gt;</code><br><code>int sockatmark (int sockfd ) ;</code><br>sockatmark 判断sockfd是否处于带外标记，即下一个被读取到的数据是否是带外数据。如果是，sockatmark返回1，此时我们就可以利用带MSG_OOB标志的recv调用来接收带外数据。如果不是，则sockatmark返回0。</p>
<h2 id="地址信息函数"><a href="#地址信息函数" class="headerlink" title="地址信息函数"></a>地址信息函数</h2><p>在某些情况下，我们想知道一个连接socket的本端socket地址，以及远端的socket地址。下面这两个函数正是用于解决这个问题:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sysl/socket.h&gt;</span><br><span class="line">int getsockname( int sockfd，struct sockaddr* address，socklen_t* address_len );</span><br><span class="line">int getpeername( int sockfd，struct sockaddr* address，socklen_t* address_len );</span><br></pre></td></tr></table></figure>

<p>getsockname获取sockfd对应的本端socket地址，并将其存储于address参数指定的内存中，该socket地址的长度则存储于address_len参数指向的变量中。如果实际socket地址的长度大于address所指内存区的大小，那么该socket地址将被截断。getsockname成功时返回0，失败返回-1并设置errno。</p>
<p>getpeername获取sockfd对应的远端socket地址，其参数及返回值的含义与getsockname的参数及返回值相同。</p>
<h2 id="socket选项"><a href="#socket选项" class="headerlink" title="socket选项"></a>socket选项</h2><p>如果说fcntl系统调用是控制文件描述符属性的通用POSIX方法，那么下面两个系统调用则是专门用来读取和设置socket文件描述符属性的方法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">include &lt;sys/ socket.h&gt;</span><br><span class="line">int getsockopt ( int sockfd，int level， int option_name，void* option_value,socklen_t* restrict option_len ) ;</span><br><span class="line">int setsockopt ( int sockfd， int level, int option_name，const void* option_value, socklen_t option_len ) ;</span><br></pre></td></tr></table></figure>

<p>sockfd参数指定被操作的目标 socket。level参数指定要操作哪个协议的选项（即属性),比如IPv4、IPv6、TCP等。option_name参数则指定选项的名字。</p>
<p><img src="/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230717210935135.png" alt="image-20230717210935135"></p>
<img src="/2023/07/09/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230717210935135.png" class title="This is an test image">

<p>getsockopt和 setsockopt这两个函数成功时返回0，失败时返回-1并设置errno.</p>
<p>值得指出的是，对服务器而言，有部分socket选项只能在调用listen系统调用前针对监听socket（确切地说，socket在执行listen调用前是不能称为监听socket的，此处是指将执行listen调用的sockete）设置才有效。这是因为连接socket只能由accept调用返回，而accept 从 listen监听队列中接受的连接至少已经完成了TC三次握手的前两个步骤（因为listen监听队列中的连接至少已进入SYN_RCVD状态)，这说明服务器已经往被接受连接上发送出了TCP同步报文段。但有的socket选项却应该在TCP同步报文段中设置，比如TCP最大报文段选项。对这种情况，Linux给开发人员提供的解决方案是:对监听socket设置这些socket选项那么accept返回的连接socket将自动继承这些选项。</p>
<h2 id="网络信息API"><a href="#网络信息API" class="headerlink" title="网络信息API"></a>网络信息API</h2><h3 id="gethostbyname和gethostbyaddr"><a href="#gethostbyname和gethostbyaddr" class="headerlink" title="gethostbyname和gethostbyaddr"></a>gethostbyname和gethostbyaddr</h3><p>gethostbyname函数根据主机名称获取主机的完整信息，gethostbyaddr 函数根据IP地址获取主机的完整信息。gethostbyname函数通常先在本地的&#x2F;etc&#x2F;hosts 配置文件中食找主机，如果没有找到，再去访问 DNS服务器。这些在前面章节中都讨论过。这两个函数的定义如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;netdb.h&gt;</span><br><span class="line">struct hostent* gethostbyname ( const char* name ) ;</span><br><span class="line">struct hostent* gethostbyaddr( const void* addr，size_t len，int type );</span><br></pre></td></tr></table></figure>

<p>name参数指定目标主机的主机名，addr参数指定目标主机的IP地址，len参数指定addr所指IP地址的长度，type参数指定addr所指IP地址的类型，其合法取值包括AF_INET（用于IPv4地址）和AF_INET6（用于IPv6地址)。<br>这两个函数返回的都是hostent结构体类型的指针，hostent结构体的定义如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">include &lt;netdb.h&gt;</span><br><span class="line">struct hostent</span><br><span class="line">&#123;</span><br><span class="line">    char* h_name;			 /*主机名*/</span><br><span class="line">    char** h_aliases;		 /*主机别名列表，可能有多个* /</span><br><span class="line">    int h_addrtype;			 / *地址类型（地址族)*/</span><br><span class="line">    int h_length;			 /*地址长度*/</span><br><span class="line">    char** h_addr_list    	 /*按网络字节序列出的主机IР地址列表* /</span><br><span class="line">) ;</span><br></pre></td></tr></table></figure>

<h3 id="getservbyname和getservbyport"><a href="#getservbyname和getservbyport" class="headerlink" title="getservbyname和getservbyport"></a>getservbyname和getservbyport</h3><p>getservbyname函数根据名称获取某个服务的完整信息，getservbyport函数根据端口号获取某个服务的完整信息。它们实际上都是通过读取letc&#x2F;services文件来获取服务的信息的。这两个函数的定义如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;netdb.h&gt;</span><br><span class="line">struct servent* getservbyname ( const char* name，const char* proto );</span><br><span class="line">struct servent* getservbyport( int port,const char* proto );</span><br></pre></td></tr></table></figure>

<p>name参数指定目标服务的名字，port参数指定目标服务对应的端口号。proto参数指定服务类型，给它传递“tcp”表示获取流服务，给它传递“udp”表示获取数据报服务，给它传递NULL则表示获取所有类型的服务。<br>这两个函数返回的都是servent结构体类型的指针，结构体servent的定义如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;netdb.h&gt;</span><br><span class="line">struct servent</span><br><span class="line">&#123;</span><br><span class="line">    char* s_name;	/*服务名称*/</span><br><span class="line">    char** s_aliases;/*服务的别名列表，可能有多个*/</span><br><span class="line">    int s_port;		 /*端口号*/</span><br><span class="line">    char* s_proto;   /*服务类型，通常是tcp或者udp * /</span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure>

<p>需要指出的是，上面讨论的4个函数都是不可重入的，即非线程安全的。不过netdb.h头文件给出了它们的可重入版本。正如Linux下所有其他函数的可重入版本的命名规则那样，这些函数的函数名是在原函数名尾部加上_r (re-entrant)。</p>
<p>可重入函数是设计用于多线程环境的函数，它们通过使用线程本地存储（Thread Local Storage，TLS）等技术来确保在并发执行的情况下保持数据的一致性和线程安全性。与非可重入函数相比，可重入函数在多线程环境下更加安全，因为它们不会共享全局变量或静态变量。</p>
<h3 id="getaddrinfo"><a href="#getaddrinfo" class="headerlink" title="getaddrinfo"></a>getaddrinfo</h3><p>gctaddrinfo函数既能通过主机名获得IP地址（内部使用的是gethostbyname<br>也能通过服务名获得端口号（内部使用的是getservbyname函数)。它是否可重入取决于其内部调用的 gethostbyname和 getservbyname 函数是否是它们的可重入版本。该函数的定义如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include &lt;netdb.h&gt;</span><br><span class="line">int getaddrinfo( const char* hostname，const char* service,const struct addrinfo* hints, struct addrinfo** result ) ;</span><br></pre></td></tr></table></figure>

<p>hostname参数可以接受主机名，也可以接受字符串表示的IP地址（IPv4采用点分十进制字符串，IPv6采用十六进制字符串）。同样,service参数可以接收服务名，也可以接受字符串表示的十进制端口号。hints参数是应用程序给getaddrinfo的一个提示，以对getaddrinfo的输出进行更精确的控制。hints参数可以被设置为NULL，表示允许getaddrinfo反馈任何可用的结果。result参数指向一个链表，该链表用于存储getaddrinfo反馈的结果。<br>getaddrinfo反馈的每一条结果都是addrinfo结构体类型的对象，结构体addrinfo的定义如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct addrinfo</span><br><span class="line">&#123;</span><br><span class="line">    int ai_flags;/*见后文*/</span><br><span class="line">    </span><br><span class="line">    int ai_family; /*地址族*/</span><br><span class="line">   </span><br><span class="line">    int ai_socktype; /*服务类型，socK_STREAM或SOCK_DGRAM* /</span><br><span class="line">   </span><br><span class="line">    int ai_protocol; /*见后文*/</span><br><span class="line">   </span><br><span class="line">    socklen_tai_addrlen;/*socket地址ai_addr的长度*/</span><br><span class="line">    </span><br><span class="line">    char* ai_canonname;/*主机的别名*/</span><br><span class="line">    </span><br><span class="line">    struct sockaddr* ai_addr; /* 指向socket地址*/</span><br><span class="line">   </span><br><span class="line">    struct addrinfo* ai_next;/* 指向下一个sockinfo结构的对象*/</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该结构体中，ai protocol成员是指具体的网络协议，其含义和socket系统调用的第三个参数相同，它通常被设置为0。</p>
<p>当我们使用hints参数的时候，可以设置其ai_flags，ai_family，ai_socktype和ai_protocol四个字段，其他字段则必须被设置为NULL。</p>
<p><img src="/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230717214610436.png" alt="image-20230717214610436"></p>
<img src="/2023/07/09/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230717214610436.png" class title="This is an test image">

<p>从代码清单5-13中我们能分析出，getaddrinfo将隐式地分配堆内存（可以通过valgrind等工具查看)，因为res指针原本是没有指向一块合法内存的，所以，getaddrinfo调用结束后，我们必须使用如下配对函数来释放这块内存:<br><code>#include &lt;netdb.h&gt;</code><br><code>void freeaddrinfo ( struct addrinfo*res ) ;</code></p>
<h3 id="getnameinfo"><a href="#getnameinfo" class="headerlink" title="getnameinfo"></a>getnameinfo</h3><p>getnameinfo函数能通过socket地址同时获得以字符串表示的主机名（内部使用的是gethostbyaddr函数）和服务名（内部使用的是getservbyport函数)。它是否可重入取决于其内部调用的gethostbyaddr和 getservbyport函数是否是它们的可重入版本。该函数的定义如下:<br><code>#include &lt;netdb.h&gt;</code><br><code>int getnameinfo( const struct sockaddr* sockaddr，socklen_t addrlen，char*</code><br><code>host,socklen_t hostlen，char* serv,socklen_t servlen，int flags );</code><br>getnameinfo将返回的主机名存储在host参数指向的缓存中，将服务名存储在serv参数指向的缓存中，hostlen和 servlen参数分别指定这两块缓存的长度。flags参数控制getnameinfo的行为，它可以接收表5-7中的选项。</p>
<p><img src="/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230717214940802.png" alt="image-20230717214940802"></p>
<img src="/2023/07/09/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230717214940802.png" class title="This is an test image">

<p>getaddrinfo和 getnameinfo函数成功时返回0，失败则返回错误码，可能的错误码如表5-8所示。</p>
<p><img src="/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230717215212111.png" alt="image-20230717215212111"></p>
<img src="/2023/07/09/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230717215212111.png" class title="This is an test image">

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/" class="post-title-link" itemprop="url">深入理解计算机系统-第七章-链接</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-07 16:48:11" itemprop="dateCreated datePublished" datetime="2023-07-07T16:48:11+08:00">2023-07-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-08 19:55:27" itemprop="dateModified" datetime="2023-07-08T19:55:27+08:00">2023-07-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="编译器驱动程序"><a href="#编译器驱动程序" class="headerlink" title="编译器驱动程序"></a>编译器驱动程序</h2><p>考虑图7-1中的C语言程序。它将作为贯穿本章的一个小的运行示例，帮助我们说明关于链接是如何工作的一些重要知识点。</p>
<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/image-20230707164930218.png" alt="image-20230707164930218"></p>


<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/image-20230707165006374.png" alt="image-20230707165006374"></p>


<p>驱动程序经过相同的过程生成sum.o。最后，它运行链接器程序ld，将main.o和sum.o以及一些必要的系统目标文件组合起来，创建一个可执行目标文件(executable ob-ject file)prog:<br><code>ld -o prog [system object files and args]  /tmp/main.o /tmp/sum.o</code><br>要运行可执行文件 prog，我们在Linux shell的命令行上输入它的名字:</p>
<p>linux&gt; .&#x2F;prog</p>
<p>shell调用操作系统中一个叫做加载器(loader)的函数，它将可执行文件prog中的代码和数据复制到内存，然后将控制转移到这个程序的开头。</p>
<h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>像Linux LD程序这样的静态链接器(static linker)以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的代码和数据节(section)组成，每一节都是一个连续的字节序列。指令在一节中，初始化了的全局变量在另一节中，而未初始化的变量又在另外一节中。</p>
<p>为了构造可执行文件，链接器必须完成两个主要任务:</p>
<ul>
<li>符号解析(symbol resolution)。目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或一个静态变量(即C语言中任何以static属性声明的变量)。符号解析的目的是将每个符号引用正好和一个符号定义关联起来。</li>
<li>重定位(relocation)。编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置。链接器使用汇编器产生的重定位条目(relocation entry)的详细指令，不加甄别地执行这样的重定位。</li>
</ul>
<h2 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h2><p>目标文件有三种形式:</p>
<ul>
<li>可重定位目标文件。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。</li>
<li>可执行目标文件。包含二进制代码和数据，其形式可以被直接复制到内存并执行。</li>
<li>共享目标文件。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。</li>
</ul>
<p>编译器和汇编器生成可重定位目标文件(包括共享目标文件)。链接器生成可执行目标文件。从技术上来说，一个目标模块(object module)就是一个字节序列，而一个目标文件(ob-ject file)就是一个以文件形式存放在磁盘中的目标模块。不过，我们会互换地使用这些术语。</p>
<p>目标文件是按照特定的目标文件格式来组织的，各个系统的目标文件格式都不相同。</p>
<p>从贝尔实验室诞生的第一个Unix系统使用的是 a.out格式(直到今天，可执行文件仍然称为a.out 文件)。Windows使用可移植可执行(Portable Executable，PE)格式。MacOS-X使用Mach-O格式。现代x86-64 Linux和Unix系统使用可执行可链接格式(Execut-able and Linkable Format，ELF)。尽管我们的讨论集中在ELF上，但是不管是哪种格式，基本的概念是相似的。</p>
<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/image-20230708195433833.png" alt="image-20230708195433833"></p>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/07/Linux-socket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/07/Linux-socket/" class="post-title-link" itemprop="url">Linux-socket</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-07 14:12:22" itemprop="dateCreated datePublished" datetime="2023-07-07T14:12:22+08:00">2023-07-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-14 14:58:55" itemprop="dateModified" datetime="2023-08-14T14:58:55+08:00">2023-08-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h2><p>网络字节序：</p>
<p>  小端法：（pc本地存储）  高位存高地址。地位存低地址。  int a &#x3D; 0x12345678</p>
<p>  大端法：（网络存储） 高位存低地址。低位存高地址 </p>
<p>  htonl –&gt; 本地–》网络 （IP）     192.168.1.11 –&gt; string –&gt; atoi –&gt; int –&gt; htonl –&gt; 网络字节序   将32位主机字节序的整数转换为网络字节序（big-endian）</p>
<p>  htons –&gt; 本地–》网络 (port)        将16位主机字节序的短整数（通常是端口号）转换为网络字节序（big-endian）</p>
<p>  ntohl –&gt; 网络–》 本地（IP）</p>
<p>  ntohs –&gt; 网络–》 本地（Port）</p>
<p>ntohl函数用于字节顺序转换，将32位整数从网络字节顺序转换为主机字节顺序，对应于网络编程中的网络字节顺序的转换。它接收一个32位整数（网络字节顺序是大端法因为是tcp，早期大型机采用的是大端字节序，而大部分网络协议设计也遵循了这个约定）并返回主机字节顺序(一般是小端法)的整数。上面是POSIX标准的函数，可以在windows下使用，有移植效果。</p>
<hr>
<p>只能在Linux使用<code>htobe64</code>、<code>htobe32</code>、<code>htobe16</code>、<code>be64toh</code>、<code>be32toh</code>、<code>be16toh</code> 来完成实际的字节序转换操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">inline uint64_t hostToNetwork64(uint64_t host64)</span><br><span class="line">&#123;</span><br><span class="line">  return htobe64(host64);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline uint32_t hostToNetwork32(uint32_t host32)</span><br><span class="line">&#123;</span><br><span class="line">  return htobe32(host32);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline uint16_t hostToNetwork16(uint16_t host16)</span><br><span class="line">&#123;</span><br><span class="line">  return htobe16(host16);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline uint64_t networkToHost64(uint64_t net64)</span><br><span class="line">&#123;</span><br><span class="line">  return be64toh(net64);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline uint32_t networkToHost32(uint32_t net32)</span><br><span class="line">&#123;</span><br><span class="line">  return be32toh(net32);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline uint16_t networkToHost16(uint16_t net16)</span><br><span class="line">&#123;</span><br><span class="line">  return be16toh(net16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不可移植的</p>
<h2 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h2><p>IP地址转换函数：</p>
<p>  <code>int inet_pton(int af, const char *src, void *dst);</code>   本地字节序（string IP） —&gt; 网络字节序</p>
<p>​    af：AF_INET、AF_INET6</p>
<p>​    src：传入，IP地址（点分十进制）</p>
<p>​    dst：传出，转换后的 网络字节序的 IP地址。 </p>
<p>​    返回值：</p>
<p>​      成功： 1</p>
<p>​      异常： 0， 说明src指向的不是一个有效的ip地址。</p>
<p>​      失败：-1</p>
<p>​    <code>const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);</code> 网络字节序 —&gt; 本地字节序（string IP）</p>
<p>   参数说明：</p>
<ul>
<li><code>af</code>：地址族，即地址的类型，可以是 <code>AF_INET</code>（IPv4）或 <code>AF_INET6</code>（IPv6）。</li>
<li><code>src</code>：指向存储 IP 地址的字节序列的指针。</li>
<li><code>dst</code>：用于存储转换后的 IP 地址字符串的缓冲区。</li>
<li><code>size</code>：缓冲区 <code>dst</code> 的大小。</li>
</ul>
<p><code>inet_ntop</code> 函数会根据地址族和提供的字节序列，将 IP 地址转换成字符串，并存储在 <code>dst</code> 缓冲区中。它返回一个指向 <code>dst</code> 的指针，指向转换后的 IP 地址字符串。</p>
<h2 id="sockaddr地址结构"><a href="#sockaddr地址结构" class="headerlink" title="sockaddr地址结构"></a>sockaddr地址结构</h2><p><img src="/Linux-socket/image-20230707141717803.png" alt="image-20230707141717803"></p>
<img src="/2023/07/07/Linux-socket/image-20230707141717803.png" class title="This is an test image">

<p>sockaddr地址结构：  IP + port –&gt; 在网络环境中唯一标识一个进程。</p>
<p>  struct sockaddr_in addr;</p>
<p>  addr.sin_family &#x3D; AF_INET&#x2F;AF_INET6      man 7 ip</p>
<p>  addr.sin_port &#x3D; htons(9527);</p>
<p>​    <code>int dst;</code></p>
<p>​    <code>inet_pton(AF_INET, &quot;192.157.22.45&quot;, (void *)&amp;dst);</code></p>
<p>  <code>addr.sin_addr.s_addr = dst;</code>相当于addr.sin_addr.s_addr &#x3D; htonl(INADDR_ANY);一般用后者简单</p>
<p>  <code>【*】addr.sin_addr.s_addr = htonl(INADDR_ANY);</code>    取出系统中有效的任意IP地址。二进制类型。</p>
<p>  <code>bind(fd, (struct sockaddr *)&amp;addr, size);</code></p>
<p><img src="/Linux-socket/image-20230713205816024.png" alt="image-20230713205816024"></p>
<img src="/2023/07/07/Linux-socket/image-20230713205816024.png" class title="This is an test image">

<h3 id="socket和bind"><a href="#socket和bind" class="headerlink" title="socket和bind"></a>socket和bind</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">socket函数：</span><br><span class="line"></span><br><span class="line">	#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">	int socket(int domain, int type, int protocol);		创建一个 套接字</span><br><span class="line"></span><br><span class="line">		domain：AF_INET、AF_INET6、AF_UNIX</span><br><span class="line"></span><br><span class="line">		type：SOCK_STREAM（传输层使用tcp协议）、SOCK_DGRAM（传输层使用udp协议）</span><br><span class="line"></span><br><span class="line">		protocol: 0 </span><br><span class="line">		protocol参数是在前两个参数构成的协议集合下，再选择一个具体的协议。不过这个值通常都是唯一的（前两个参数已经完全决定了它的值)。几乎在所有情况下，我们都应该把它设置为0，表示使用默认协议。</span><br><span class="line"></span><br><span class="line">		返回值：</span><br><span class="line">	</span><br><span class="line">			成功： 新套接字所对应文件描述符</span><br><span class="line"></span><br><span class="line">			失败: -1 errno</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">值得指出的是，自Linux内核版本2.6.17起，type参数可以接受上述服务类型与下面两个重要的标志相与的值:SOCK_NONBLOCK和SOCK_CLOEXEC。它们分别表示将新创建的socket 设为非阻塞的，以及用fork调用创建子进程时在子进程中关闭该socket。在内核版本2.6.17之前的Linux中，文件描述符的这两个属性都需要使用额外的系统调用（比如fcntl）来设置。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">	 int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);		给socket绑定一个 地址结构 (IP+port)</span><br><span class="line"></span><br><span class="line">		sockfd: socket 函数返回值</span><br><span class="line"></span><br><span class="line">			struct sockaddr_in addr;</span><br><span class="line"></span><br><span class="line">			addr.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line">			addr.sin_port = htons(8888);</span><br><span class="line"></span><br><span class="line">			addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">		addr: 传入参数(struct sockaddr *)&amp;addr</span><br><span class="line"></span><br><span class="line">		addrlen: sizeof(addr) 地址结构的大小。</span><br><span class="line"></span><br><span class="line">		返回值：</span><br><span class="line"></span><br><span class="line">			成功：0</span><br><span class="line"></span><br><span class="line">			失败：-1 errno</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="listen和accept"><a href="#listen和accept" class="headerlink" title="listen和accept"></a>listen和accept</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">int listen(int sockfd, int backlog);		设置同时与服务器建立连接的上限数。（同时进行3次握手的客户端数量）</span><br><span class="line"></span><br><span class="line">		sockfd: socket 函数返回值</span><br><span class="line"></span><br><span class="line">		backlog：上限数值。最大值 128.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		返回值：</span><br><span class="line"></span><br><span class="line">			成功：0</span><br><span class="line"></span><br><span class="line">			失败：-1 errno	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);	阻塞等待客户端建立连接，成功的话，返回一个与客户端成功连接的socket文件描述符。</span><br><span class="line"></span><br><span class="line">		sockfd: socket 函数返回值</span><br><span class="line"></span><br><span class="line">		addr：传出参数。成功与服务器建立连接的那个客户端的地址结构（IP+port）</span><br><span class="line"></span><br><span class="line">			socklen_t clit_addr_len = sizeof(addr);</span><br><span class="line"></span><br><span class="line">		addrlen：传入传出。 &amp;clit_addr_len</span><br><span class="line"></span><br><span class="line">			 入：addr的大小。 出：客户端addr实际大小。</span><br><span class="line"></span><br><span class="line">		返回值：</span><br><span class="line"></span><br><span class="line">			成功：能与客户端进行数据通信的 socket 对应的文件描述。</span><br><span class="line"></span><br><span class="line">			失败： -1 ， errno</span><br><span class="line">		</span><br></pre></td></tr></table></figure>

<h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);	  使用现有的 socket 与服务器建立连接</span><br><span class="line"></span><br><span class="line">		sockfd： socket 函数返回值</span><br><span class="line"></span><br><span class="line">			struct sockaddr_in srv_addr;		// 服务器地址结构</span><br><span class="line"></span><br><span class="line">			srv_addr.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line">			srv_addr.sin_port = 9527 	跟服务器bind时设定的 port 完全一致。</span><br><span class="line"></span><br><span class="line">			inet_pton(AF_INET, &quot;服务器的IP地址&quot;，&amp;srv_adrr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">		addr：传入参数。服务器的地址结构</span><br><span class="line"></span><br><span class="line">			</span><br><span class="line">		addrlen：服务器的地址结构的大小</span><br><span class="line"></span><br><span class="line">		返回值：</span><br><span class="line"></span><br><span class="line">			成功：0</span><br><span class="line"></span><br><span class="line">			失败：-1 errno</span><br><span class="line"></span><br><span class="line">		如果不使用bind绑定客户端地址结构, 采用&quot;隐式绑定&quot;.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="CS模型的TCP通信分析"><a href="#CS模型的TCP通信分析" class="headerlink" title="CS模型的TCP通信分析"></a>CS模型的TCP通信分析</h2><p>TCP通信流程分析:</p>
<p>server:<br>    1. socket()	创建socket</p>
<ol start="2">
<li><p>bind()	绑定服务器地址结构</p>
</li>
<li><p>listen()	设置监听上限</p>
</li>
<li><p>accept()	阻塞监听客户端连接</p>
</li>
<li><p>read(fd)	读socket获取客户端数据</p>
</li>
<li><p>小–大写	toupper()</p>
</li>
<li><p>write(fd)</p>
</li>
<li><p>close();</p>
</li>
</ol>
<p>client:</p>
<ol>
<li><p>socket()	创建socket</p>
</li>
<li><p>connect();	与服务器建立连接</p>
</li>
<li><p>write()	写数据到 socket</p>
</li>
<li><p>read()	读转换后的数据。</p>
</li>
<li><p>显示读取结果</p>
</li>
<li><p>close()</p>
</li>
</ol>
<h2 id="server的实现"><a href="#server的实现" class="headerlink" title="server的实现"></a>server的实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include &lt;ctype.h&gt;  </span><br><span class="line">#include &lt;sys/socket.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;errno.h&gt;  </span><br><span class="line">#include &lt;pthread.h&gt;  </span><br><span class="line">#define SERV_PORT 9527  </span><br><span class="line"></span><br><span class="line">void sys_err(const char *str)  </span><br><span class="line">&#123;  </span><br><span class="line">        perror(str);  </span><br><span class="line">        exit(1);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">        int lfd = 0, cfd = 0;  </span><br><span class="line">        int ret, i;  </span><br><span class="line">        char buf[BUFSIZ], client_IP[1024]; //[+d查看系统定义的BUFSIZ的大小 </span><br><span class="line"></span><br><span class="line">        struct sockaddr_in serv_addr, clit_addr;  // 定义服务器地址结构 和 客户端地址结构  </span><br><span class="line">        socklen_t clit_addr_len;                  // 客户端地址结构大小  </span><br><span class="line"></span><br><span class="line">        serv_addr.sin_family = AF_INET;             // IPv4  </span><br><span class="line">        serv_addr.sin_port = htons(SERV_PORT);      // 转为网络字节序的 端口号  </span><br><span class="line">        serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  // 获取本机任意有效IP  </span><br><span class="line"></span><br><span class="line">        lfd = socket(AF_INET, SOCK_STREAM, 0);      //创建一个 socket  </span><br><span class="line">        if (lfd == -1) &#123;  </span><br><span class="line">                sys_err(&quot;socket error&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        bind(lfd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr));//给服务器socket绑定地址结构（IP+port)  </span><br><span class="line"></span><br><span class="line">        listen(lfd, 128);                   //  设置监听上限  </span><br><span class="line"></span><br><span class="line">        clit_addr_len = sizeof(clit_addr);  //  获取客户端地址结构大小  </span><br><span class="line"></span><br><span class="line">        cfd = accept(lfd, (struct sockaddr *)&amp;clit_addr, &amp;clit_addr_len);   // 阻塞等待客户端连接请求  </span><br><span class="line">        if (cfd == -1)  </span><br><span class="line">                sys_err(&quot;accept error&quot;);  </span><br><span class="line"></span><br><span class="line">        printf(&quot;client ip:%s port:%d\n&quot;,   </span><br><span class="line">                        inet_ntop(AF_INET, &amp;clit_addr.sin_addr.s_addr, client_IP, sizeof(client_IP)),                        ntohs(clit_addr.sin_port));         // 根据accept传出参数，获取客户端 ip 和 port  </span><br><span class="line"></span><br><span class="line">        while (1) &#123;  </span><br><span class="line">                ret = read(cfd, buf, sizeof(buf));      // 读客户端数据 ssize_t read(int fd, void *buf, size_t count); </span><br><span class="line">                //read函数的返回值是读取到的字节数，将其赋给ret变量。</span><br><span class="line">                write(STDOUT_FILENO, buf, ret);         // 写到屏幕查看  ssize_t write(int fd, const void *buf, size_t count);</span><br><span class="line"></span><br><span class="line">                for (i = 0; i &lt; ret; i++)                // 小写 -- 大写  </span><br><span class="line">                        buf[i] = toupper(buf[i]);  </span><br><span class="line"></span><br><span class="line">                write(cfd, buf, ret);                   // 将大写，写回给客户端。  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        close(lfd);  </span><br><span class="line">        close(cfd);  </span><br><span class="line"></span><br><span class="line">        return 0;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="获取客户端地址结构"><a href="#获取客户端地址结构" class="headerlink" title="获取客户端地址结构"></a>获取客户端地址结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cfd = accept(lfd, (struct sockaddr *)&amp;clit_addr, &amp;clit_addr_len);</span><br><span class="line">accept函数中的clit_addr传出的就是客户端地址结构，IP+port</span><br><span class="line"></span><br><span class="line">于是，在代码中增加此段代码，可获取客户端信息：</span><br><span class="line">printf(&quot;client ip:%s port:%d\n&quot;, </span><br><span class="line">            inet_ntop(AF_INET,&amp;clit_addr.sin_addr.s_addr, client_IP, sizeof(client_IP)), </span><br><span class="line">            ntohs(clit_addr.sin_port));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="client的实现"><a href="#client的实现" class="headerlink" title="client的实现"></a>client的实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;sys/socket.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;errno.h&gt;  </span><br><span class="line">#include &lt;pthread.h&gt;  </span><br><span class="line"></span><br><span class="line">#define SERV_PORT 9527  </span><br><span class="line"></span><br><span class="line">void sys_err(const char* str)  </span><br><span class="line">&#123;  </span><br><span class="line">    perror(str);  </span><br><span class="line">    exit(1);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">    int cfd;  </span><br><span class="line">    int conter = 10;  </span><br><span class="line">    char buf[BUFSIZ];  </span><br><span class="line">    </span><br><span class="line">    struct sockaddr_in serv_addr;          //服务器地址结构  </span><br><span class="line"></span><br><span class="line">    serv_addr.sin_family = AF_INET;  </span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);  </span><br><span class="line">    //inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;serv_addr.sin_addr.s_addr);  </span><br><span class="line">    inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;serv_addr.sin_addr);  </span><br><span class="line"></span><br><span class="line">    cfd = socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">    if (cfd == -1)  </span><br><span class="line">        sys_err(&quot;socket error&quot;);  </span><br><span class="line"></span><br><span class="line">    int ret = connect(cfd, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr));  </span><br><span class="line">    if (ret != 0)  </span><br><span class="line">        sys_err(&quot;connect err&quot;);  </span><br><span class="line"></span><br><span class="line">    while (--conter) &#123;  </span><br><span class="line">        write(cfd, &quot;hello\n&quot;, 6);  </span><br><span class="line">        ret = read(cfd, buf, sizeof(buf));  </span><br><span class="line">        write(STDOUT_FILENO, buf, ret);  </span><br><span class="line">        sleep(1);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    close(cfd);  </span><br><span class="line"></span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里遇到过一个问题，如果之前运行server，用Ctrl+z终止进程，ps aux列表里会有服务器进程残留，这个会影响当前服务器。解决方法是kill掉这些服务器进程。不然端口被占用，当前运行的服务器进程接收不到东西，没有回显。</p>
<h2 id="错误处理函数的封装思路"><a href="#错误处理函数的封装思路" class="headerlink" title="错误处理函数的封装思路"></a>错误处理函数的封装思路</h2><p>wrap.h文件如下，就是包裹函数的声明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __WRAP_H_  </span><br><span class="line">#define __WRAP_H_  </span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">void perr_exit(const char* s);</span><br><span class="line">int Accept(int fd, struct sockaddr* sa, socklen_t* salenptr);</span><br><span class="line">int Bind(int fd, const struct sockaddr* sa, socklen_t salen);</span><br><span class="line">int Connect(int fd, const struct sockaddr* sa, socklen_t salen);</span><br><span class="line">int Listen(int fd, int backlog);</span><br><span class="line">int Socket(int family, int type, int protocol);</span><br><span class="line">ssize_t Read(int fd, void* ptr, size_t nbytes);</span><br><span class="line">ssize_t Write(int fd, const void* ptr, size_t nbytes);</span><br><span class="line">int Close(int fd);</span><br><span class="line">ssize_t Readn(int fd, void* vptr, size_t n);</span><br><span class="line">ssize_t Writen(int fd, const void* vptr, size_t n);</span><br><span class="line">ssize_t my_read(int fd, char* ptr);</span><br><span class="line">ssize_t Readline(int fd, void* vptr, size_t maxlen);</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>wrap.c随便取一部分，如下，就是包裹函数的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;wrap.h&quot;</span><br><span class="line"></span><br><span class="line">void perr_exit(const char *s)</span><br><span class="line">&#123;</span><br><span class="line">	perror(s);</span><br><span class="line">	exit(1);</span><br><span class="line">&#125;</span><br><span class="line">int Accept(int fd, struct sockaddr *sa, socklen_t *salenptr)</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	again:</span><br><span class="line">	if ( (n = accept(fd, sa, salenptr)) &lt; 0) &#123;</span><br><span class="line">		if ((errno == ECONNABORTED) || (errno == EINTR))</span><br><span class="line">			goto again;</span><br><span class="line">		else</span><br><span class="line">			perr_exit(&quot;accept error&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br><span class="line">int Bind(int fd, const struct sockaddr *sa, socklen_t salen)</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	if ((n = bind(fd, sa, salen)) &lt; 0)</span><br><span class="line">		perr_exit(&quot;bind error&quot;);</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br><span class="line">int Connect(int fd, const struct sockaddr *sa, socklen_t salen)</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	if ((n = connect(fd, sa, salen)) &lt; 0)</span><br><span class="line">		perr_exit(&quot;connect error&quot;);</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br><span class="line">int Listen(int fd, int backlog)</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	if ((n = listen(fd, backlog)) &lt; 0)</span><br><span class="line">		perr_exit(&quot;listen error&quot;);</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br><span class="line">int Socket(int family, int type, int protocol)</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	if ( (n = socket(family, type, protocol)) &lt; 0)</span><br><span class="line">		perr_exit(&quot;socket error&quot;);</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br><span class="line">ssize_t Read(int fd, void *ptr, size_t nbytes)</span><br><span class="line">&#123;</span><br><span class="line">	ssize_t n;</span><br><span class="line">again:</span><br><span class="line">	if ( (n = read(fd, ptr, nbytes)) == -1) &#123;</span><br><span class="line">		if (errno == EINTR)</span><br><span class="line">			goto again;</span><br><span class="line">		else</span><br><span class="line">			return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br><span class="line">ssize_t Write(int fd, const void *ptr, size_t nbytes)</span><br><span class="line">&#123;</span><br><span class="line">	ssize_t n;</span><br><span class="line">again:</span><br><span class="line">	if ( (n = write(fd, ptr, nbytes)) == -1) &#123;</span><br><span class="line">		if (errno == EINTR)</span><br><span class="line">			goto again;</span><br><span class="line">		else</span><br><span class="line">			return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br><span class="line">int Close(int fd)</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	if ((n = close(fd)) == -1)</span><br><span class="line">		perr_exit(&quot;close error&quot;);</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br><span class="line">ssize_t Readn(int fd, void *vptr, size_t n)</span><br><span class="line">&#123;</span><br><span class="line">	size_t nleft;</span><br><span class="line">	ssize_t nread;</span><br><span class="line">	char *ptr;</span><br><span class="line"></span><br><span class="line">	ptr = vptr;</span><br><span class="line">	nleft = n;</span><br><span class="line"></span><br><span class="line">	while (nleft &gt; 0) &#123;</span><br><span class="line">		if ( (nread = read(fd, ptr, nleft)) &lt; 0) &#123;</span><br><span class="line">			if (errno == EINTR)</span><br><span class="line">				nread = 0;</span><br><span class="line">			else</span><br><span class="line">				return -1;</span><br><span class="line">		&#125; else if (nread == 0)</span><br><span class="line">			break;</span><br><span class="line">		nleft -= nread;</span><br><span class="line">		ptr += nread;</span><br><span class="line">	&#125;</span><br><span class="line">	return n - nleft;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ssize_t Writen(int fd, const void *vptr, size_t n)</span><br><span class="line">&#123;</span><br><span class="line">	size_t nleft;</span><br><span class="line">	ssize_t nwritten;</span><br><span class="line">	const char *ptr;</span><br><span class="line"></span><br><span class="line">	ptr = vptr;</span><br><span class="line">	nleft = n;</span><br><span class="line"></span><br><span class="line">	while (nleft &gt; 0) &#123;</span><br><span class="line">		if ( (nwritten = write(fd, ptr, nleft)) &lt;= 0) &#123;</span><br><span class="line">			if (nwritten &lt; 0 &amp;&amp; errno == EINTR)</span><br><span class="line">				nwritten = 0;</span><br><span class="line">			else</span><br><span class="line">				return -1;</span><br><span class="line">		&#125;</span><br><span class="line">		nleft -= nwritten;</span><br><span class="line">		ptr += nwritten;</span><br><span class="line">	&#125;</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ssize_t my_read(int fd, char *ptr)</span><br><span class="line">&#123;</span><br><span class="line">	static int read_cnt;</span><br><span class="line">	static char *read_ptr;</span><br><span class="line">	static char read_buf[100];</span><br><span class="line"></span><br><span class="line">	if (read_cnt &lt;= 0) &#123;</span><br><span class="line">again:</span><br><span class="line">		if ((read_cnt = read(fd, read_buf, sizeof(read_buf))) &lt; 0) &#123;</span><br><span class="line">			if (errno == EINTR)</span><br><span class="line">				goto again;</span><br><span class="line">			return -1;	</span><br><span class="line">		&#125; else if (read_cnt == 0)</span><br><span class="line">			return 0;</span><br><span class="line">		read_ptr = read_buf;</span><br><span class="line">	&#125;</span><br><span class="line">	read_cnt--;</span><br><span class="line">	*ptr = *read_ptr++;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ssize_t Readline(int fd, void *vptr, size_t maxlen)</span><br><span class="line">&#123;</span><br><span class="line">	ssize_t n, rc;</span><br><span class="line">	char c, *ptr;</span><br><span class="line">	ptr = vptr;</span><br><span class="line"></span><br><span class="line">	for (n = 1; n &lt; maxlen; n++) &#123;</span><br><span class="line">		if ( (rc = my_read(fd, &amp;c)) == 1) &#123;</span><br><span class="line">			*ptr++ = c;</span><br><span class="line">			if (c == &#x27;\n&#x27;)</span><br><span class="line">				break;</span><br><span class="line">		&#125; else if (rc == 0) &#123;</span><br><span class="line">			*ptr = 0;</span><br><span class="line">			return n - 1;</span><br><span class="line">		&#125; else</span><br><span class="line">			return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	*ptr = 0;</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里原函数和包裹函数的函数名差异只有首字母大写，这是因为man page对字母大小写不敏感，同名的包裹函数一样可以跳转至man page</p>
<hr>
<p>错误处理函数： </p>
<p>  封装目的：</p>
<p>​    在 server.c 编程过程中突出逻辑，将出错处理与逻辑分开，可以直接跳转man手册。</p>
<p>  【wrap.c】             【wrap.h】</p>
<p>  存放网络通信相关常用 自定义函数         存放 网络通信相关常用 自定义函数原型(声明)。</p>
<p>  命名方式：系统调用函数首字符大写, 方便查看man手册</p>
<p>​     如：Listen()、Accept();</p>
<p>  函数功能：调用系统调用函数，处理出错场景。</p>
<p>  在 server.c 和 client.c 中调用 自定义函数 </p>
<p>  联合编译 server.c 和 wrap.c 生成 server</p>
<p>​     			client.c 和 wrap.c 生成 client </p>
<p>readn：</p>
<p>  读 N 个字节 </p>
<p>readline：</p>
<p>  读一行</p>
<h2 id="TCP和UDP通信优缺点"><a href="#TCP和UDP通信优缺点" class="headerlink" title="TCP和UDP通信优缺点"></a>TCP和UDP通信优缺点</h2><p>TCP通信和UDP通信各自的优缺点：</p>
<p>  TCP： 面向连接的，可靠数据包传输。对于不稳定的网络层，采取完全弥补的通信方式。 丢包重传。</p>
<p>​    优点：</p>
<p>​      稳定。   </p>
<p>​       数据流量稳定、速度稳定、顺序</p>
<p>​    缺点：</p>
<p>​      传输速度慢。相率低。开销大。</p>
<p>​    使用场景：数据的完整型要求较高，不追求效率。</p>
<p>​       大数据传输、文件传输。</p>
<p>  UDP： 无连接的，不可靠的数据报传递。对于不稳定的网络层，采取完全不弥补的通信方式。 默认还原网络状况</p>
<p>​    优点：</p>
<p>​      传输速度块。相率高。开销小。</p>
<p>​    缺点：</p>
<p>​      不稳定。</p>
<p>​       数据流量。速度。顺序。</p>
<p>​    使用场景：对时效性要求较高场合。稳定性其次。</p>
<p>​       游戏、视频会议、视频电话。    腾讯、华为、阿里 — 应用层数据校验协议，弥补udp的不足。</p>
<h2 id="UDP通信server和client流程"><a href="#UDP通信server和client流程" class="headerlink" title="UDP通信server和client流程"></a>UDP通信server和client流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">UDP实现的 C/S 模型：直接就支持多路IO</span><br><span class="line"></span><br><span class="line">	recv()/send() 只能用于 TCP 通信。 替代 read、write</span><br><span class="line"></span><br><span class="line">	accpet(); ---- Connect(); ---被舍弃</span><br><span class="line"></span><br><span class="line">	server：</span><br><span class="line"></span><br><span class="line">		lfd = socket(AF_INET, STREAM, 0);	SOCK_DGRAM --- 报式协议。</span><br><span class="line"></span><br><span class="line">		bind();</span><br><span class="line"></span><br><span class="line">		listen();  --- 可有可无</span><br><span class="line"></span><br><span class="line">		while（1）&#123;</span><br><span class="line"></span><br><span class="line">			read(cfd, buf, sizeof) --- 被替换 --- recvfrom（） --- 涵盖accept传出地址结构。</span><br><span class="line">小-- 大</span><br><span class="line">				</span><br><span class="line">			write();--- 被替换 --- sendto（）---- connect</span><br><span class="line">		&#125;</span><br><span class="line">		close();</span><br><span class="line"></span><br><span class="line">client：</span><br><span class="line"></span><br><span class="line">		connfd = socket(AF_INET, SOCK_DGRAM, 0);</span><br><span class="line"></span><br><span class="line">		sendto（‘服务器的地址结构’， 地址结构大小）</span><br><span class="line"></span><br><span class="line">		recvfrom（）</span><br><span class="line"></span><br><span class="line">		写到屏幕</span><br><span class="line"></span><br><span class="line">		close();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="recvfrom和sendto函数"><a href="#recvfrom和sendto函数" class="headerlink" title="recvfrom和sendto函数"></a>recvfrom和sendto函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,struct sockaddr *src_addr, socklen_t *addrlen);</span><br><span class="line"></span><br><span class="line">					sockfd： 套接字</span><br><span class="line"></span><br><span class="line">					buf：缓冲区地址</span><br><span class="line"></span><br><span class="line">					len：缓冲区大小</span><br><span class="line"></span><br><span class="line">					flags： 0</span><br><span class="line"></span><br><span class="line">					src_addr：（struct sockaddr *）&amp;addr 传出。 对端地址结构</span><br><span class="line"></span><br><span class="line">					addrlen：传入传出。</span><br><span class="line"></span><br><span class="line">				返回值： 成功接收数据字节数。 失败：-1 errn。 0： 对端关闭。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,const struct sockaddr *dest_addr, socklen_t addrlen);</span><br><span class="line"></span><br><span class="line">					sockfd： 套接字</span><br><span class="line"></span><br><span class="line">					buf：存储数据的缓冲区</span><br><span class="line"></span><br><span class="line">					len：数据长度</span><br><span class="line"></span><br><span class="line">					flags： 0</span><br><span class="line"></span><br><span class="line">					src_addr：（struct sockaddr *）&amp;addr 传入。 目标地址结构</span><br><span class="line"></span><br><span class="line">					addrlen：地址结构长度。</span><br><span class="line"></span><br><span class="line">				返回值：成功写出数据字节数。 失败 -1， errno		</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="UDP实现的并发服务器和客户端"><a href="#UDP实现的并发服务器和客户端" class="headerlink" title="UDP实现的并发服务器和客户端"></a>UDP实现的并发服务器和客户端</h3><p>服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">#include &lt;ctype.h&gt;  </span><br><span class="line">  </span><br><span class="line">#define SERV_PORT 8000  </span><br><span class="line">  </span><br><span class="line">int main(void)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct sockaddr_in serv_addr, clie_addr;  </span><br><span class="line">    socklen_t clie_addr_len;  </span><br><span class="line">    int sockfd;  </span><br><span class="line">    char buf[BUFSIZ];  </span><br><span class="line">    char str[INET_ADDRSTRLEN];  </span><br><span class="line">    int i, n;  </span><br><span class="line">  </span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, 0);  </span><br><span class="line">  </span><br><span class="line">    bzero(&amp;serv_addr, sizeof(serv_addr));  </span><br><span class="line">    serv_addr.sin_family = AF_INET;  </span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);  </span><br><span class="line">  </span><br><span class="line">    bind(sockfd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr));  </span><br><span class="line">  </span><br><span class="line">    printf(&quot;Accepting connections ...\n&quot;);  </span><br><span class="line">    while (1) &#123;  </span><br><span class="line">        clie_addr_len = sizeof(clie_addr);  </span><br><span class="line">        n = recvfrom(sockfd, buf, BUFSIZ,0, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);  </span><br><span class="line">        if (n == -1)  </span><br><span class="line">            perror(&quot;recvfrom error&quot;);  </span><br><span class="line">  </span><br><span class="line">        printf(&quot;received from %s at PORT %d\n&quot;,  </span><br><span class="line">                inet_ntop(AF_INET, &amp;clie_addr.sin_addr, str, sizeof(str)),  </span><br><span class="line">                ntohs(clie_addr.sin_port));  </span><br><span class="line">  </span><br><span class="line">        for (i = 0; i &lt; n; i++)  </span><br><span class="line">            buf[i] = toupper(buf[i]);  </span><br><span class="line">  </span><br><span class="line">        n = sendto(sockfd, buf, n, 0, (struct sockaddr *)&amp;clie_addr, sizeof(clie_addr));  </span><br><span class="line">        if (n == -1)  </span><br><span class="line">            perror(&quot;sendto error&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    close(sockfd);  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">#include &lt;ctype.h&gt;  </span><br><span class="line">  </span><br><span class="line">#define SERV_PORT 8000  </span><br><span class="line">  </span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">    struct sockaddr_in servaddr;  </span><br><span class="line">    int sockfd, n;  </span><br><span class="line">    char buf[BUFSIZ];  </span><br><span class="line">  </span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, 0);  </span><br><span class="line">  </span><br><span class="line">    bzero(&amp;servaddr, sizeof(servaddr));  </span><br><span class="line">    servaddr.sin_family = AF_INET;  </span><br><span class="line">    inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;servaddr.sin_addr);  </span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);  </span><br><span class="line">  </span><br><span class="line">    bind(sockfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));  </span><br><span class="line">  </span><br><span class="line">    while (fgets(buf, BUFSIZ, stdin) != NULL) &#123;  </span><br><span class="line">        n = sendto(sockfd, buf, strlen(buf), 0, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));  </span><br><span class="line">        if (n == -1)  </span><br><span class="line">            perror(&quot;sendto error&quot;);  </span><br><span class="line">  </span><br><span class="line">        n = recvfrom(sockfd, buf, BUFSIZ, 0, NULL, 0);         //NULL:不关心对端信息  </span><br><span class="line">        if (n == -1)  </span><br><span class="line">            perror(&quot;recvfrom error&quot;);  </span><br><span class="line">  </span><br><span class="line">        write(STDOUT_FILENO, buf, n);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    close(sockfd);  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="多进程并发服务器思路分析"><a href="#多进程并发服务器思路分析" class="headerlink" title="多进程并发服务器思路分析"></a>多进程并发服务器思路分析</h2><p>在一个多进程并发服务器中，通常会有一个父进程负责监听新的连接请求，而子进程负责处理具体的连接。这种架构被称为”预派生”或”预分叉”模型。当子进程已经派生并开始处理连接时，父进程的监听套接字（用于接受新的连接）以及子进程不再需要的其他资源都应该被关闭，以避免资源泄漏和冲突。</p>
<ol>
<li><strong>子进程关闭监听套接字：</strong> 子进程派生后，<strong>会继承父进程的文件描述符</strong>，包括监听套接字。由于每个套接字需要一个独立的进程去处理连接，因此子进程需要关闭不再使用的监听套接字。这样可以确保每个子进程只处理属于它的连接，并防止不必要的资源占用。</li>
<li><strong>父进程关闭已连接的套接字：</strong> 在并发服务器中，父进程在派生子进程后，不再处理具体的连接，而是将连接交给子进程处理。因此，父进程应该关闭已连接的套接字，即已经建立连接并交给子进程处理的套接字。这样可以避免不同进程之间对同一套接字资源的冲突。</li>
</ol>
<p>总之，关闭不再使用的套接字可以避免资源泄漏和进程间的竞争问题，确保并发服务器的稳定运行。</p>
<h3 id="多进程并发服务器实现"><a href="#多进程并发服务器实现" class="headerlink" title="多进程并发服务器实现"></a>多进程并发服务器实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;ctype.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;sys/wait.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;strings.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;errno.h&gt;  </span><br><span class="line">#include &lt;signal.h&gt;  </span><br><span class="line">#include &lt;sys/socket.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">#include &lt;pthread.h&gt;  </span><br><span class="line"></span><br><span class="line">#include &quot;wrap.h&quot;  </span><br><span class="line"></span><br><span class="line">#define SRV_PORT 9999  </span><br><span class="line">//在每个子进程退出时，内核会发送 SIGCHLD 信号，然后调用 catch_child 函数进行处理。在 catch_child 函数内部，使用 waitpid 函数来回收已经退出的子进程，防止其成为僵尸进程。循环调用 waitpid 是为了确保一次性处理所有已退出的子进程</span><br><span class="line">void catch_child(int signum)  //当子进程退出时，父进程收到信号，就会去回收子进程了，不会出现僵尸进程</span><br><span class="line">&#123;  </span><br><span class="line">    while ((waitpid(0, NULL, WNOHANG)) &gt; 0);  </span><br><span class="line">    return;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;</span><br><span class="line">    int lfd, cfd;  </span><br><span class="line">    pid_t pid;  </span><br><span class="line">    struct sockaddr_in srv_addr, clt_addr;  </span><br><span class="line">    socklen_t clt_addr_len;   </span><br><span class="line">    char buf[BUFSIZ];  </span><br><span class="line">    int ret, i;  </span><br><span class="line">    </span><br><span class="line">    //memset(&amp;srv_addr, 0, sizeof(srv_addr));                 // 将地址结构清零  </span><br><span class="line">    bzero(&amp;srv_addr, sizeof(srv_addr));  </span><br><span class="line">    </span><br><span class="line">    srv_addr.sin_family = AF_INET;  </span><br><span class="line">    srv_addr.sin_port = htons(SRV_PORT);  </span><br><span class="line">    srv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">    </span><br><span class="line">    lfd = Socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">    </span><br><span class="line">    Bind(lfd, (struct sockaddr *)&amp;srv_addr, sizeof(srv_addr));  </span><br><span class="line">    </span><br><span class="line">    Listen(lfd, 128);  </span><br><span class="line">    </span><br><span class="line">    clt_addr_len = sizeof(clt_addr);  </span><br><span class="line">    </span><br><span class="line">    while (1) &#123;  </span><br><span class="line">    </span><br><span class="line">        cfd = Accept(lfd, (struct sockaddr *)&amp;clt_addr, &amp;clt_addr_len);  </span><br><span class="line">    </span><br><span class="line">        pid = fork();  </span><br><span class="line">        if (pid &lt; 0) &#123;  </span><br><span class="line">            perr_exit(&quot;fork error&quot;);  </span><br><span class="line">        &#125; else if (pid == 0) &#123;  //子进程</span><br><span class="line">            close(lfd);  </span><br><span class="line">            break;          </span><br><span class="line">        &#125; else &#123;  //父进程</span><br><span class="line">            struct sigaction act;  </span><br><span class="line">    </span><br><span class="line">            act.sa_handler = catch_child;  </span><br><span class="line">            sigemptyset(&amp;act.sa_mask);  </span><br><span class="line">            act.sa_flags = 0;  </span><br><span class="line">    </span><br><span class="line">            ret = sigaction(SIGCHLD, &amp;act, NULL);  </span><br><span class="line">            if (ret != 0) &#123;  </span><br><span class="line">               perr_exit(&quot;sigaction error&quot;);  </span><br><span class="line">            &#125;  </span><br><span class="line">            close(cfd);   </span><br><span class="line">            continue;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    if (pid == 0) &#123;  </span><br><span class="line">        for (;;) &#123;  </span><br><span class="line">            ret = Read(cfd, buf, sizeof(buf));  </span><br><span class="line">            if (ret == 0) &#123;  </span><br><span class="line">                close(cfd);  </span><br><span class="line">                exit(1);  </span><br><span class="line">            &#125;   </span><br><span class="line">    </span><br><span class="line">            for (i = 0; i &lt; ret; i++)  </span><br><span class="line">                buf[i] = toupper(buf[i]);  </span><br><span class="line">    </span><br><span class="line">            write(cfd, buf, ret);  </span><br><span class="line">            write(STDOUT_FILENO, buf, ret);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    return 0；</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>使用桥接模式，让自己主机和其他人主机处于同一个网段</p>
<p><img src="/Linux-socket/image-20230709110056462.png" alt="image-20230709110056462"></p>
<img src="/2023/07/07/Linux-socket/image-20230709110056462.png" class title="This is an test image">

<p><img src="/Linux-socket/image-20230709110238005.png" alt="image-20230709110238005"></p>
<img src="/2023/07/07/Linux-socket/image-20230709110238005.png" class title="This is an test image">

<p>然后再断开再桥接连一下，这个是你自己取的名字。</p>
<h3 id="服务器程序上传外网服务器并访问"><a href="#服务器程序上传外网服务器并访问" class="headerlink" title="服务器程序上传外网服务器并访问"></a>服务器程序上传外网服务器并访问</h3><p>scp -r 命令，将本地文件拷贝至远程服务器上目标位置</p>
<p>scp -r 源地址 目标地址</p>
<h2 id="多线程服务器代码review"><a href="#多线程服务器代码review" class="headerlink" title="多线程服务器代码review"></a>多线程服务器代码review</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">多线程并发服务器： server.c </span><br><span class="line"></span><br><span class="line">	1. Socket();		创建 监听套接字 lfd</span><br><span class="line"></span><br><span class="line">	2. Bind()		绑定地址结构 Strcut scokaddr_in addr;</span><br><span class="line"></span><br><span class="line">	3. Listen();		</span><br><span class="line"></span><br><span class="line">	4. while (1) &#123;		</span><br><span class="line"></span><br><span class="line">		cfd = Accept(lfd, );</span><br><span class="line"></span><br><span class="line">		pthread_create(&amp;tid, NULL, tfn, (void *)cfd);</span><br><span class="line"></span><br><span class="line">		pthread_detach(tid);  				// pthead_join(tid, void **);  新线程---专用于回收子线程。</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	5. 子线程：</span><br><span class="line"></span><br><span class="line">		void *tfn(void *arg) </span><br><span class="line">		&#123;</span><br><span class="line">			// close(lfd)			不能关闭。 主线程要使用lfd</span><br><span class="line"></span><br><span class="line">			read(cfd)</span><br><span class="line"></span><br><span class="line">			小--大</span><br><span class="line"></span><br><span class="line">			write(cfd)</span><br><span class="line"></span><br><span class="line">			pthread_exit（(void *)10）;	</span><br><span class="line">		&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;ctype.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;wrap.h&quot;</span><br><span class="line"></span><br><span class="line">#define MAXLINE 8192</span><br><span class="line">#define SERV_PORT 8000</span><br><span class="line"></span><br><span class="line">struct s_info &#123;											//定义一个结构体, 将地址结构跟cfd捆绑</span><br><span class="line">    struct sockaddr_in cliaddr;</span><br><span class="line">    int connfd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void *do_work(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    int n, i;</span><br><span class="line">    struct s_info *ts = (struct s_info *) arg;</span><br><span class="line">    char buf[MAXLINE];</span><br><span class="line">    char str[INET_ADDRSTRLEN];				//#define INET_ADDRSTRLEN 16  可用&quot;[+d&quot;查看</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        n = Read(ts-&gt;connfd, buf, MAXLINE);	//读客户端</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            printf(&quot;the client %d closed...\n&quot;, ts-&gt;connfd);</span><br><span class="line">            break;							//跳出循环,关闭cfd </span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;received from %s at PORT %d\n&quot;,</span><br><span class="line">               inet_ntop(AF_INET, &amp;(*ts).cliaddr.sin_addr, str, sizeof(str)),</span><br><span class="line">               ntohs((*ts).cliaddr.sin_port));			//打印客户端信息(IP/PORT)</span><br><span class="line"></span><br><span class="line">        for (i = 0; i &lt; n; i++)</span><br><span class="line">            buf[i] = toupper(buf[i]);					  //小写--&gt;大写  </span><br><span class="line"></span><br><span class="line">        Write(STDOUT_FILENO, buf, n);					//写出至屏幕  </span><br><span class="line">        Write(ts-&gt;connfd, buf, n);						  //回写给客户端 </span><br><span class="line">    &#125;</span><br><span class="line">    Close(ts-&gt;connfd);</span><br><span class="line"></span><br><span class="line">    return (void *) 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    struct sockaddr_in servaddr, cliaddr;</span><br><span class="line">    socklen_t cliaddr_len;</span><br><span class="line">    int listenfd, connfd;</span><br><span class="line">    pthread_t tid;</span><br><span class="line"></span><br><span class="line">    struct s_info ts[256];								 //创建结构体数组</span><br><span class="line">    int i = 0;</span><br><span class="line">	</span><br><span class="line">    listenfd = Socket(AF_INET, SOCK_STREAM, 0);			//创建一个socket, 得到lfd  </span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, sizeof(servaddr));					//地址结构清零	</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);					//指定本地任意IP  </span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);				    //指定端口号   </span><br><span class="line"></span><br><span class="line">    Bind(listenfd, (struct sockaddr *) &amp;servaddr, sizeof(servaddr)); //绑定  	</span><br><span class="line"></span><br><span class="line">    Listen(listenfd, 128);		     //设置同一时刻链接服务器上限数  </span><br><span class="line"></span><br><span class="line">    printf(&quot;Accepting client connect ...\n&quot;);</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        cliaddr_len = sizeof(cliaddr);</span><br><span class="line">        connfd = Accept(listenfd, (struct sockaddr *) &amp;cliaddr, &amp;cliaddr_len); //阻塞监听客户端链接请求  </span><br><span class="line">        ts[i].cliaddr = cliaddr;</span><br><span class="line">        ts[i].connfd = connfd;</span><br><span class="line"></span><br><span class="line">        pthread_create(&amp;tid, NULL, do_work, (void *) &amp;ts[i]);//这里可以传地址是因为不会改变</span><br><span class="line">        pthread_detach(tid);			  //子线程分离,防止僵线程产生.  </span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	</p>
<h2 id="C语言C-中assert的用法"><a href="#C语言C-中assert的用法" class="headerlink" title="C语言C++中assert的用法"></a>C语言C++中assert的用法</h2><p><code>void assert(int expression);</code></p>
<p>assert宏的原型定义在&lt;assert.h&gt;中，其作用是先计算表达式expression的值为假(即为0),那么它就先向stderr打印一条出错信息，然后通过条用abort来终止程序；</p>
<p>使用assert的缺点是，频繁的调用会极大的影响程序的性能，增加额外的开销。</p>
<p>在调试结束后，可以通过在包含#include 的语句之前插入 #define NDEBUG 来禁用assert调用，示例代码如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 #include </span><br><span class="line">2 #define NDEBUG </span><br><span class="line">3 #include</span><br></pre></td></tr></table></figure>

<p>根据提示我们很快就能定位到错误点，就在assert(i++)处；既然assert这么便于定位出错点，在工程中使用它就显得很有必要；但其也有一定的使用规则；</p>
<p>断言语句不会永远被执行，可以屏蔽也可以启用，这就要求assert不管是在屏蔽还是启用状态下都不能对我们本身代码有所影响，这样刚才我们在代码中使用的<code>assert(i++)</code>就不行，因为如果禁用了<code>assert</code>,那i++就不能执行；正确的做法应该是：<code>assert(i);i++;</code></p>
<h2 id="本地套接字和网络套接字比较"><a href="#本地套接字和网络套接字比较" class="headerlink" title="本地套接字和网络套接字比较"></a>本地套接字和网络套接字比较</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">本地套接字：</span><br><span class="line"></span><br><span class="line">	IPC： pipe、fifo、mmap、信号、本地套（domain）--- CS模型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	对比网络编程 TCP C/S模型， 注意以下几点：</span><br><span class="line"></span><br><span class="line">	1. int socket(int domain, int type, int protocol); 参数 domain：AF_INET --&gt; AF_UNIX/AF_LOCAL </span><br><span class="line">	</span><br><span class="line">							     type: SOCK_STREAM/SOCK_DGRAM  都可以。	</span><br><span class="line">	2. 地址结构：  sockaddr_in --&gt; sockaddr_un</span><br><span class="line"></span><br><span class="line">		struct sockaddr_in srv_addr; --&gt; struct sockaddr_un srv_adrr;</span><br><span class="line"></span><br><span class="line">		srv_addr.sin_family = AF_INET;  --&gt; srv_addr.sun_family = AF_UNIX;</span><br><span class="line">·</span><br><span class="line">		srv_addr.sin_port = htons(8888);    strcpy(srv_addr.sun_path, &quot;srv.socket&quot;)</span><br><span class="line"></span><br><span class="line">		srv_addr.sin_addr.s_addr = htonl(INADDR_ANY);			len = offsetof(struct sockaddr_un, sun_path) + strlen(&quot;srv.socket&quot;);//offsetof用于求结构体成员较首地址偏移，第一个是AF_UNIX，第二个是sun_path</span><br><span class="line">	</span><br><span class="line">		bind(fd, (struct sockaddr *)&amp;srv_addr, sizeof(srv_addr));  --&gt; 	bind(fd, (struct sockaddr *)&amp;srv_addr, len); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	3. bind()函数调用成功，会创建一个 socket。因此为保证bind成功，通常我们在 bind之前， 可以使用 unlink(&quot;srv.socket&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	4. 客户端不能依赖 “隐式绑定”。并且应该在通信建立过程中，创建且初始化2个地址结构：</span><br><span class="line"></span><br><span class="line">		1） client_addr --&gt; bind()</span><br><span class="line"></span><br><span class="line">		2)  server_addr --&gt; connect();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="本地套接字通信"><a href="#本地套接字通信" class="headerlink" title="本地套接字通信"></a>本地套接字通信</h3><p>服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;sys/socket.h&gt;  </span><br><span class="line">#include &lt;strings.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;ctype.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">#include &lt;sys/un.h&gt;  </span><br><span class="line">#include &lt;stddef.h&gt;  </span><br><span class="line">  </span><br><span class="line">#include &quot;wrap.h&quot;  </span><br><span class="line">  </span><br><span class="line">#define SERV_ADDR  &quot;serv.socket&quot;  //没有了IP和port，改成伪文件，实际是没有大小的</span><br><span class="line">  </span><br><span class="line">int main(void)  </span><br><span class="line">&#123;  </span><br><span class="line">    int lfd, cfd, len, size, i;  </span><br><span class="line">    struct sockaddr_un servaddr, cliaddr;  </span><br><span class="line">    char buf[4096];  </span><br><span class="line">  </span><br><span class="line">    lfd = Socket(AF_UNIX, SOCK_STREAM, 0);  </span><br><span class="line">  </span><br><span class="line">    bzero(&amp;servaddr, sizeof(servaddr));  </span><br><span class="line">    servaddr.sun_family = AF_UNIX;  </span><br><span class="line">    strcpy(servaddr.sun_path, SERV_ADDR);  </span><br><span class="line">  </span><br><span class="line">    len = offsetof(struct sockaddr_un, sun_path) + strlen(servaddr.sun_path);     /* servaddr total len */  </span><br><span class="line">  </span><br><span class="line">    unlink(SERV_ADDR);                              /* 确保bind之前serv.sock文件不存在,bind会创建该文件 */  </span><br><span class="line">    Bind(lfd, (struct sockaddr *)&amp;servaddr, len);           /* 参3不能是sizeof(servaddr) */  </span><br><span class="line">  </span><br><span class="line">    Listen(lfd, 20);  </span><br><span class="line">  </span><br><span class="line">    printf(&quot;Accept ...\n&quot;);  </span><br><span class="line">    while (1) &#123;  </span><br><span class="line">        len = sizeof(cliaddr);  //AF_UNIX大小+108B  </span><br><span class="line">  </span><br><span class="line">        cfd = Accept(lfd, (struct sockaddr *)&amp;cliaddr, (socklen_t *)&amp;len);  </span><br><span class="line">  </span><br><span class="line">        len -= offsetof(struct sockaddr_un, sun_path);      /* 得到文件名的长度 */  </span><br><span class="line">        cliaddr.sun_path[len] = &#x27;\0&#x27;;                       /* 确保打印时,没有乱码出现 */  </span><br><span class="line">  </span><br><span class="line">        printf(&quot;client bind filename %s\n&quot;, cliaddr.sun_path);  </span><br><span class="line">  </span><br><span class="line">        while ((size = read(cfd, buf, sizeof(buf))) &gt; 0) &#123;  </span><br><span class="line">            for (i = 0; i &lt; size; i++)  </span><br><span class="line">                buf[i] = toupper(buf[i]);  </span><br><span class="line">            write(cfd, buf, size);  </span><br><span class="line">        &#125;  </span><br><span class="line">        close(cfd);  </span><br><span class="line">    &#125;  </span><br><span class="line">    close(lfd);  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;sys/types.h&gt;           </span><br><span class="line">#include &lt;sys/socket.h&gt;  </span><br><span class="line">#include &lt;strings.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;ctype.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">#include &lt;sys/un.h&gt;  </span><br><span class="line">#include &lt;stddef.h&gt;  </span><br><span class="line">  </span><br><span class="line">#include &quot;wrap.h&quot;  </span><br><span class="line">  </span><br><span class="line">#define SERV_ADDR &quot;serv.socket&quot;  </span><br><span class="line">#define CLIE_ADDR &quot;clie.socket&quot;  </span><br><span class="line">  </span><br><span class="line">int main(void)  </span><br><span class="line">&#123;  </span><br><span class="line">    int  cfd, len;  </span><br><span class="line">    struct sockaddr_un servaddr, cliaddr;  </span><br><span class="line">    char buf[4096];  </span><br><span class="line">  </span><br><span class="line">    cfd = Socket(AF_UNIX, SOCK_STREAM, 0);  </span><br><span class="line">  </span><br><span class="line">    bzero(&amp;cliaddr, sizeof(cliaddr));  </span><br><span class="line">    cliaddr.sun_family = AF_UNIX;  </span><br><span class="line">    strcpy(cliaddr.sun_path,CLIE_ADDR);  </span><br><span class="line">  </span><br><span class="line">    len = offsetof(struct sockaddr_un, sun_path) + strlen(cliaddr.sun_path);     /* 计算客户端地址结构有效长度 */  </span><br><span class="line">  </span><br><span class="line">    unlink(CLIE_ADDR);  </span><br><span class="line">    Bind(cfd, (struct sockaddr *)&amp;cliaddr, len);                                 /* 客户端也需要bind, 不能依赖自动绑定*/  </span><br><span class="line">  </span><br><span class="line">      </span><br><span class="line">    bzero(&amp;servaddr, sizeof(servaddr));                                          /* 构造server 地址 */  </span><br><span class="line">    servaddr.sun_family = AF_UNIX;  </span><br><span class="line">    strcpy(servaddr.sun_path, SERV_ADDR);  </span><br><span class="line">  </span><br><span class="line">    len = offsetof(struct sockaddr_un, sun_path) + strlen(servaddr.sun_path);   /* 计算服务器端地址结构有效长度 */  </span><br><span class="line">  </span><br><span class="line">    Connect(cfd, (struct sockaddr *)&amp;servaddr, len);  </span><br><span class="line">  </span><br><span class="line">    while (fgets(buf, sizeof(buf), stdin) != NULL) &#123;  </span><br><span class="line">        write(cfd, buf, strlen(buf));  </span><br><span class="line">        len = read(cfd, buf, sizeof(buf));  </span><br><span class="line">        write(STDOUT_FILENO, buf, len);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    close(cfd);  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="对比本地套接字和网络套接字"><a href="#对比本地套接字和网络套接字" class="headerlink" title="对比本地套接字和网络套接字"></a>对比本地套接字和网络套接字</h3><p><img src="/Linux-socket/image-20230715144754541.png" alt="image-20230715144754541"></p>
<img src="/2023/07/07/Linux-socket/image-20230715144754541.png" class title="This is an test image">

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/06/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/06/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Linux-网络基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-06 10:44:33" itemprop="dateCreated datePublished" datetime="2023-07-06T10:44:33+08:00">2023-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-10 15:25:03" itemprop="dateModified" datetime="2023-07-10T15:25:03+08:00">2023-07-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是协议"><a href="#什么是协议" class="headerlink" title="什么是协议"></a>什么是协议</h2><p>从应用的角度出发，协议可理解为“规则”，是数据传输和数据的解释的规则。</p>
<p>假设，A、B双方欲传输文件。规定：</p>
<p>第一次，传输文件名，接收方接收到文件名，应答OK给传输方；</p>
<p>第二次，发送文件的尺寸，接收方接收到该数据再次应答一个OK；</p>
<p>第三次，传输文件内容。同样，接收方接收数据完成后应答OK表示文件内容接收成功。</p>
<p>由此，无论A、B之间传递何种文件，都是通过三次数据传输来完成。A、B之间形成了一个最简单的数据传输规则。双方都按此规则发送、接收数据。A、B之间达成的这个相互遵守的规则即为协议。</p>
<p>这种仅在A、B之间被遵守的协议称之为<strong>原始协议</strong>。当此协议被更多的人采用，不断的增加、改进、维护、完善。最终形成一个稳定的、完整的文件传输协议，被广泛应用于各种文件传输过程中。该协议就成为一个<strong>标准协议</strong>。最早的ftp协议就是由此衍生而来。</p>
<p>TCP协议注重数据的传输。http协议着重于数据的解释。</p>
<p><img src="/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230706104601518.png" alt="image-20230706104601518"></p>
<img src="/2023/07/06/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230706104601518.png" class title="This is an test image">

<h2 id="7层模型和4层模型及代表协议"><a href="#7层模型和4层模型及代表协议" class="headerlink" title="7层模型和4层模型及代表协议"></a>7层模型和4层模型及代表协议</h2><p>分层模型结构： </p>
<p>  OSI七层模型： 物、数、网、传、会、表、应</p>
<p>  TCP&#x2F;IP 4层模型：网（链路层&#x2F;网络接口层）、网、传、应</p>
<p>​    应用层：http、ftp、nfs、ssh、telnet。。。</p>
<p>​    传输层：TCP、UDP</p>
<p>​    网络层：IP、ICMP、IGMP</p>
<p>​    链路层：以太网帧协议、ARP</p>
<p><img src="/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230706104711613.png" alt="image-20230706104711613"></p>
<img src="/2023/07/06/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230706104711613.png" class title="This is an test image">

<p>网络传输流程： </p>
<p>  数据没有封装之前，是不能在网络中传递。</p>
<p>  数据-》应用层-》传输层-》网络层-》链路层 — 网络环境</p>
<h2 id="以太网帧和ARP请求"><a href="#以太网帧和ARP请求" class="headerlink" title="以太网帧和ARP请求"></a>以太网帧和ARP请求</h2><p><img src="/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230706104959831.png" alt="image-20230706104959831"></p>
<img src="/2023/07/06/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230706104959831.png" class title="This is an test image">

<p>以太网帧协议：</p>
<p>  ARP协议：根据 Ip 地址获取 mac 地址。</p>
<p>  以太网帧协议：根据mac地址，完成数据包传输。</p>
<h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p>IP协议：  </p>
<p>  版本： IPv4、IPv6 – 4位</p>
<p>  TTL： time to live 。 设置数据包在路由节点中的跳转上限。每经过一个路由节点，该值-1， 减为0的路由，有义务将该数据包丢弃</p>
<p>  源IP： 32位。— 4字节   192.168.1.108 — 点分十进制 IP地址（string） — 二进制 </p>
<p>  目的IP：32位。— 4字节</p>
<h2 id="端口号和UDP协议"><a href="#端口号和UDP协议" class="headerlink" title="端口号和UDP协议"></a>端口号和UDP协议</h2><p>UDP：</p>
<p>  16位：源端口号。 2^16 &#x3D; 65536 </p>
<p>  16位：目的端口号。</p>
<p>IP地址：可以在网络环境中，唯一标识一台主机。</p>
<p>端口号：可以网络的一台主机上，唯一标识一个进程。</p>
<p>ip地址+端口号：可以在网络环境中，唯一标识一个进程。</p>
<h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><p>TCP协议：</p>
<p>  16位：源端口号。 2^16 &#x3D; 65536 </p>
<p>  16位：目的端口号。</p>
<p>  32序号;</p>
<p>  32确认序号。 </p>
<p>  6个标志位。</p>
<p>  16位窗口大小。  2^16 &#x3D; 65536</p>
<h2 id="BS和CS模型对比"><a href="#BS和CS模型对比" class="headerlink" title="BS和CS模型对比"></a>BS和CS模型对比</h2><p>c&#x2F;s模型： </p>
<p>  client-server </p>
<p>b&#x2F;s模型： </p>
<p>  browser-server </p>
<p>​      C&#x2F;S        																																				B&#x2F;S</p>
<p>  优点： 缓存大量数据、协议选择灵活、速度快、迭代快（只需要发布再client就行）    				 安全性、跨平台、开发工作量较小</p>
<p>  缺点： 安全性、跨平台、开发工作量较大    						 																不能缓存大量数据、严格遵守 http</p>
<h2 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h2><p>网络套接字： socket</p>
<p>  一个文件描述符指向一个套接字（该套接字内部由内核借助两个缓冲区实现。）</p>
<p>  在通信过程中， 套接字一定是成对出现的。</p>
<h2 id="三次握手建立连接"><a href="#三次握手建立连接" class="headerlink" title="三次握手建立连接"></a>三次握手建立连接</h2><p><img src="/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230708145906727.png" alt="image-20230708145906727"></p>
<img src="/2023/07/06/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230708145906727.png" class title="This is an test image">

<p><img src="/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230708145932093.png" alt="image-20230708145932093"></p>
<img src="/2023/07/06/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230708145932093.png" class title="This is an test image">

<h2 id="数据通信"><a href="#数据通信" class="headerlink" title="数据通信"></a>数据通信</h2><p><img src="/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230708150003066.png" alt="image-20230708150003066"></p>
<img src="/2023/07/06/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230708150003066.png" class title="This is an test image">

<p>并不是一次发送，一次应答。也可以批量应答</p>
<h2 id="四次挥手关闭连接"><a href="#四次挥手关闭连接" class="headerlink" title="四次挥手关闭连接"></a>四次挥手关闭连接</h2><p><img src="/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230708150114631.png" alt="image-20230708150114631"></p>
<img src="/2023/07/06/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230708150114631.png" class title="This is an test image">

<p>完成两次挥手后，不是说两端的连接断开了，主动端关闭了写缓冲区，不能再向对端发送数据，被动端关闭了读缓冲区，不能再从对端读取数据。然而主动端还是能够读取对端发来的数据。</p>
<h2 id="滑动窗口和TCP数据包格式"><a href="#滑动窗口和TCP数据包格式" class="headerlink" title="滑动窗口和TCP数据包格式"></a>滑动窗口和TCP数据包格式</h2><p><img src="/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230708150203279.png" alt="image-20230708150203279"></p>
<img src="/2023/07/06/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230708150203279.png" class title="This is an test image">

<p>滑动窗口： </p>
<p>  发送给连接对端，本端的缓冲区大小（实时），保证数据不会丢失。</p>
<p>也就是这里win4096,注意几个阶段win可能含义不同。</p>
<p><img src="/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230708150611193.png" alt="image-20230708150611193"></p>
<img src="/2023/07/06/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230708150611193.png" class title="This is an test image">

<h2 id="通信时序与代码对应关系"><a href="#通信时序与代码对应关系" class="headerlink" title="通信时序与代码对应关系"></a>通信时序与代码对应关系</h2><p><img src="/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230708150636465.png" alt="image-20230708150636465"></p>
<img src="/2023/07/06/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230708150636465.png" class title="This is an test image">

<p>三次握手：</p>
<p>  主动发起连接请求端，发送 SYN 标志位，请求建立连接。 携带序号号、数据字节数(0)、滑动窗口大小。</p>
<p>  被动接受连接请求端，发送 ACK 标志位，同时携带 SYN 请求标志位。携带序号、确认序号、数据字节数(0)、滑动窗口大小。</p>
<p>  主动发起连接请求端，发送 ACK 标志位，应答服务器连接请求。携带确认序号。</p>
<p>四次挥手：</p>
<p>  主动关闭连接请求端， 发送 FIN 标志位。 </p>
<p>  被动关闭连接请求端， 应答 ACK 标志位。      —– 半关闭完成。</p>
<p>  被动关闭连接请求端， 发送 FIN 标志位。</p>
<p>  主动关闭连接请求端， 应答 ACK 标志位。   —– 连接全部关闭</p>
<p>滑动窗口：</p>
<p>  发送给连接对端，本端的缓冲区大小（实时），保证数据不会丢失。</p>
<h2 id="TCP状态"><a href="#TCP状态" class="headerlink" title="TCP状态"></a>TCP状态</h2><p><img src="/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230710142750740.png" alt="image-20230710142750740"></p>
<img src="/2023/07/06/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230710142750740.png" class title="This is an test image">

<p>实线是主动发起连接和关闭连接请求的一端，虚线是被动发起和关闭连接请求的一端。</p>
<p><code>netstat -apn | grep client</code>  查看客户端网络连接状态</p>
<p><code>netstat -apn | grep port</code>   查看端口的网络连接状态</p>
<p><img src="/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230710142832690.png" alt="image-20230710142832690"></p>
<img src="/2023/07/06/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230710142832690.png" class title="This is an test image">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">TCP状态时序图：</span><br><span class="line"></span><br><span class="line">	结合三次握手、四次挥手 理解记忆。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	1. 主动发起连接请求端：	CLOSE -- 发送SYN -- SEND_SYN -- 接收 ACK、SYN -- SEND_SYN -- 发送 ACK -- ESTABLISHED（数据通信态）</span><br><span class="line"></span><br><span class="line">	2. 主动关闭连接请求端： ESTABLISHED（数据通信态） -- 发送 FIN -- FIN_WAIT_1 -- 接收ACK -- FIN_WAIT_2（半关闭）</span><br><span class="line"></span><br><span class="line">				-- 接收对端发送 FIN -- FIN_WAIT_2（半关闭）-- 回发ACK -- TIME_WAIT（只有主动关闭连接方，会经历该状态）</span><br><span class="line"></span><br><span class="line">				-- 等 2MSL时长 -- CLOSE </span><br><span class="line"></span><br><span class="line">	3. 被动接收连接请求端： CLOSE -- LISTEN -- 接收 SYN -- LISTEN -- 发送 ACK、SYN -- SYN_RCVD -- 接收ACK -- ESTABLISHED（数据通信态）</span><br><span class="line"></span><br><span class="line">	4. 被动关闭连接请求端： ESTABLISHED（数据通信态） -- 接收 FIN -- ESTABLISHED（数据通信态） -- 发送ACK </span><br><span class="line"></span><br><span class="line">				-- CLOSE_WAIT (说明对端【主动关闭连接端】处于半关闭状态) -- 发送FIN -- LAST_ACK -- 接收ACK -- CLOSE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	重点记忆： ESTABLISHED、FIN_WAIT_2 &lt;--&gt; CLOSE_WAIT、TIME_WAIT（2MSL）</span><br><span class="line"></span><br><span class="line">	netstat -apn | grep  端口号</span><br><span class="line"></span><br><span class="line">2MSL时长：</span><br><span class="line"></span><br><span class="line">	一定出现在【主动关闭连接请求端】。 --- 对应 TIME_WAIT 状态。</span><br><span class="line"></span><br><span class="line">	保证，最后一个 ACK 能成功被对端接收。（等待期间，对端没收到我发的ACK，对端会再次发送FIN请求。）</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="端口复用函数"><a href="#端口复用函数" class="headerlink" title="端口复用函数"></a>端口复用函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">端口复用:</span><br><span class="line"></span><br><span class="line">	int opt = 1;		// 设置端口复用。</span><br><span class="line"></span><br><span class="line">	setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, (void *)&amp;opt, sizeof(opt))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以直接套的模板，复用的意思是这个端口是TIME_WAIT（一定出现在【主动关闭连接请求端】），即服务端close，防止等待时间太长，可以连续用这个端口。</p>
<h2 id="半关闭及shutdown函数"><a href="#半关闭及shutdown函数" class="headerlink" title="半关闭及shutdown函数"></a>半关闭及shutdown函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">半关闭：</span><br><span class="line"></span><br><span class="line">	通信双方中，只有一端关闭通信。  --- FIN_WAIT_2</span><br><span class="line"></span><br><span class="line">	close（cfd）;</span><br><span class="line"></span><br><span class="line">	shutdown(int fd, int how);	</span><br><span class="line"></span><br><span class="line">		how: 	SHUT_RD	关读端</span><br><span class="line"></span><br><span class="line">			SHUT_WR	关写端</span><br><span class="line"></span><br><span class="line">			SHUT_RDWR 关读写</span><br><span class="line"></span><br><span class="line">	shutdown在关闭多个文件描述符应用的文件时，采用全关闭方法。close，只关闭一个。即dup2多个文件描述符指向同一个时，shutdown关闭一个会将指向同一个的都关闭。</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">肖汇林</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">肖汇林</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
