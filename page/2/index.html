<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="选择有时候比努力更重要">
<meta property="og:type" content="website">
<meta property="og:title" content="肖汇林的博客">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="肖汇林的博客">
<meta property="og:description" content="选择有时候比努力更重要">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="肖汇林">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>肖汇林的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖汇林的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/14/Linux%E4%B8%8Agcc%E7%BC%96%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/14/Linux%E4%B8%8Agcc%E7%BC%96%E8%AF%91/" class="post-title-link" itemprop="url">Linux上gcc编译</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-14 10:41:46" itemprop="dateCreated datePublished" datetime="2023-05-14T10:41:46+08:00">2023-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-21 10:34:55" itemprop="dateModified" datetime="2023-05-21T10:34:55+08:00">2023-05-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="gcc-编译-4-步骤"><a href="#gcc-编译-4-步骤" class="headerlink" title="gcc 编译 4 步骤"></a>gcc 编译 4 步骤</h1><p>GCC（GNU Compiler Collection）是由 GNU 开发的编程语言编译器。 GCC最初代表“GNU C Compiler”，当时只支持C语言。 后来又扩展能够支持更多编程语言，包括 C++、Fortran 和 Java 等。</p>
<p>GCC 编译工具链在编译一个C源文件时需要经过以下 4 步：</p>
<ul>
<li>预处理：为把头文件的代码、宏之类的内容转换成生成的.i文件，还是C代码。</li>
<li>编译：把预处理后的.i文件通过编译成.s文件，汇编语言。</li>
<li>汇编：将汇编语言文件生成目标文件.o文件，机器码。</li>
<li>链接：将每个源文件对应的.o文件链接起来，就生成一个可执行程序文件</li>
</ul>
<p><strong>（1）预处理阶段</strong></p>
<p>预处理过程中，对源代码文件中的文件包含 (include)、 预编译语句 (如宏定义define等)进行展开，生成 .i 文件。 可理解为把头文件的代码、宏之类的内容转换成更纯粹的C代码，不过生成的文件以.i为后缀。</p>
<p>使用GCC的参数 “-E”，可以让编译器生成 .i 文件，参数 “-o”，可以指定输出文件的名字。</p>
<p>具体命令如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 预处理，可理解为把头文件的代码汇总成C代码，把*.c转换得到*.i文件</span><br><span class="line">gcc –E hello.c –o hello.i</span><br></pre></td></tr></table></figure>

<p><strong>（2）编译阶段</strong>（消耗时间、系统资源最多）</p>
<p>把预处理后的.i文件通过编译成为汇编语言，生成.s文件，即把代码从C语言转换成汇编语言，这是GCC编译器完成的工作。在这个过程，GCC会检查各个源文件的语法，即使我们调用了一个没有定义的函数，也不会报错。</p>
<p>GCC可以使用-S选项，让编译程序生成汇编语言的代码文件（.s后缀）。</p>
<p>warning时如果有行号，说明是编译阶段出错。</p>
<p>具体命令如下:</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译，可理解为把C代码转换为汇编代码，把*.i转换得到*.s文件</span></span><br><span class="line">gcc –S hello.i –o hello.s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以直接以C文件作为输入进行编译，与上面的命令是等价的</span></span><br><span class="line">gcc –S hello.c –o hello.s</span><br></pre></td></tr></table></figure>

<p><strong>（3）汇编阶段</strong></p>
<p>将汇编语言文件经过汇编，生成目标文件.o文件，每一个源文件都对应一个目标文件。即把汇编语言的代码转换成机器码，这是as汇编器完成的工作。</p>
<p>GCC的参数“c”表示只编译(compile)源文件但不链接，会将源程序编译成目标文件（.o后缀）。计算机只认识0或者1，不懂得C语言，也不懂得汇编语言，经过编译汇编之后，生成的目标文件包含着机器代码，这部分代码就可以直接被计算机执行。一般情况下，可以直接使用参数“c”，跳过上述的两个过程，具体命令 如下：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 汇编，可理解为把汇编代码转换为机器码，把*.s转换得到*.o，即目标文件</span></span><br><span class="line">gcc –c hello.s –o hello.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以直接以C文件作为输入进行汇编，与上面的命令是等价的</span></span><br><span class="line">gcc –c hello.c –o hello.o</span><br></pre></td></tr></table></figure>

<p>Linux下生成的 <em>.o目标文件、</em>so动态库文件以及下一小节链接阶段生成最终的可执行文件都是elf格式的， 可以使用“readelf”工具来查看它们的内容。</p>
<p><strong>（4）链接阶段</strong></p>
<p>最后将每个源文件对应的目标.o文件链接起来，就生成一个可执行程序文件，这是链接器ld完成的工作。</p>
<p>例如一个工程里包含了A和B两个代码文件，在链接阶段， 链接过程需要把A和B之间的函数调用关系理顺，也就是说要告诉A在哪里能够调用到fun函数， 建立映射关系，所以称之为链接。若链接过程中找不到fun函数的具体定义，则会链接报错。</p>
<p>虽然本示例只有一个hello.c文件，但它调用了C标准代码库的printf函数， 所以链接器会把它和printf函数链接起来，生成最终的可执行文件。</p>
<p>链接分为两种：</p>
<ul>
<li>动态链接：GCC编译时的默认选项。动态是指在应用程序运行时才去加载外部的代码库，不同的程序可以共用代码库。 所以动态链接生成的程序比较小，占用较少的内存。</li>
<li>静态链接：链接时使用选项 “–static”，它在编译阶段就会把所有用到的库打包到自己的可执行程序中。 所以静态链接的优点是具有较好的兼容性，不依赖外部环境，但是生成的程序比较大。</li>
</ul>
<p>执行如下命令体验静态链接与动态链接的区别：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在hello.o所在的目录执行如下命令</span></span><br><span class="line"><span class="comment"># 动态链接，生成名为hello的可执行文件</span></span><br><span class="line">//<span class="literal">-o</span>是用来指定生成文件的名字</span><br><span class="line">gcc hello.o –o hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以直接使用C文件一步生成，与上面的命令等价</span></span><br><span class="line">gcc hello.c <span class="literal">-o</span> hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># 静态链接，使用--static参数，生成名为hello_static的可执行文件</span></span><br><span class="line">gcc hello.o –o hello_static <span class="literal">--static</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以直接使用C文件一步生成，与上面的命令等价</span></span><br><span class="line">gcc hello.c <span class="literal">-o</span> hello_static <span class="literal">--static</span></span><br></pre></td></tr></table></figure>

<h2 id="当头文件和源码不在一个目录下时，需要指定头文件"><a href="#当头文件和源码不在一个目录下时，需要指定头文件" class="headerlink" title="当头文件和源码不在一个目录下时，需要指定头文件"></a>当头文件和源码不在一个目录下时，需要指定头文件</h2><p>gcc -I .&#x2F;hellodir hello.c -o hello 其中-I 参数指定头文件所在位置，位置可以在编译文件前，也可以在后面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-I 指定头文件所在目录位置</span><br><span class="line">-c 只做预处理，编译，汇编。得到二进制文件</span><br><span class="line">-g 编译时添加调试文件，用于 gdb 调试</span><br><span class="line">-Wall 显示所有警告信息</span><br><span class="line">-D 向程序中“动态”注册宏定义，一般可以用在调试，制作一个开关，比如ifdef,发布的时候就可以不用删除调试信息</span><br><span class="line">-l 指定动态库库名</span><br><span class="line">-L 指定动态库路径</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="动态库和静态库理论对比"><a href="#动态库和静态库理论对比" class="headerlink" title="动态库和静态库理论对比"></a>动态库和静态库理论对比</h2><p>静态库在文件中静态展开，所以有多少文件就展开多少次，非常吃内存，100M 展开 100 次，就是 1G， 但是这样的好处就是静态加载的速度快 </p>
<p>使用动态库会将动态库加载到内存，10 个文件也只需要加载一次，然后这些文件用到库的时候临时去加载，速度慢一些，但是很省内存 </p>
<p>动态库和静态库各有优劣，根据实际情况合理选用即可。</p>
<ul>
<li>1.动态库是否加载到内存,取决于程序是否运行</li>
<li>2.动态库每次加载的位置不固定</li>
<li>3.动、静态库共存时,编译器默认使用动态库</li>
</ul>
<h3 id="静态库制作"><a href="#静态库制作" class="headerlink" title="静态库制作"></a>静态库制作</h3><p>静态库名字以 lib 开头，以.a 结尾 ，.a是ELF文件，可重定位目标文件。</p>
<p>例如：<code>libmylib.a</code> </p>
<p>静态库生成指令 <code>ar rcs libmylib.a file1.o</code></p>
<p>步骤一： 写好源代码</p>
<p>步骤二： 编译源代码生成.o 文件</p>
<p>步骤三： 制作静态库 ar rcs libname.a file1.o file2.o …</p>
<p>静态库的使用： gcc test.c lib 库名.a -o a.out</p>
<h3 id="动态库制作-生成与位置无关代码"><a href="#动态库制作-生成与位置无关代码" class="headerlink" title="动态库制作-生成与位置无关代码"></a>动态库制作-生成与位置无关代码</h3><p>写在源代码里的函数，相对 main 函数偏移是一定的，链接时，回填 main 函数地址之后，其他源代码里的函数也就得到了地址。 </p>
<p>动态库里的函数会用一个@plt 来标识，当动态库加载到内存时，再用加载进去的地址将@plt 替换掉。</p>
<p>制作动态库的步骤 </p>
<ol>
<li>生成位置无关的.o 文件 <code>gcc -c add.c -o add.o -fPIC</code> 使用这个参数过后，生成的函数就和位置无关，挂上@plt 标识，等待动态绑定 </li>
<li>使用 gcc -shared 制作动态库 <code>gcc -shared -o lib 库名.so add.o sub.o div.o</code> </li>
<li>编译可执行程序时指定所使用的动态库。-l:指定库名 -L:指定库路径 <code>gcc test.c -o a.out -l mymath -L ./lib</code> </li>
<li>运行可执行程序.&#x2F;a.out</li>
</ol>
<h4 id="动态库加载错误原因及解决方式"><a href="#动态库加载错误原因及解决方式" class="headerlink" title="动态库加载错误原因及解决方式"></a>动态库加载错误原因及解决方式</h4><p>出错原因分析： </p>
<p>连接器： 工作于链接阶段，工作时需要 -l 和 -L </p>
<p>动态链接器： 工作于程序运行阶段，工作时需要提供动态库所在目录位置 </p>
<p>指定动态库路径并使其生效，然后再执行文件 </p>
<p>通过环境变量指定动态库所在位置：<code>export LD_LIBRARY_PATH=动态库路径</code></p>
<p>当关闭终端，再次执行 a.out 时，又报错。 </p>
<p>这是因为，环境变量是进程的概念，关闭终端之后再打开，是两个进程，环境变量发生了变化。 </p>
<p>要想永久生效，需要修改 bash 的配置文件：<code>vi ~./bashrc</code> </p>
<p>修改后要使配置文件立即生效：<code>. .bashrc</code> 或者 <code>source .bashrc</code> 或者重开终端让其自己加载 这下再执行 a.out 就不会报错</p>
<h4 id="动态库加载错误原因及解决方式-2"><a href="#动态库加载错误原因及解决方式-2" class="headerlink" title="动态库加载错误原因及解决方式 2"></a>动态库加载错误原因及解决方式 2</h4><p>解决方式： </p>
<p>【1】 通过环境变量： <code>export LD_LIBRARY_PATH=动态库路径</code></p>
<p> .&#x2F;a.out 成功！！！ （临时生效， 终端重启环境变量失效） </p>
<p>【2】 永久生效： 写入 终端配置文件。 .bashrc 建议使用绝对路径。 </p>
<pre><code>1) vi ~/.bashrc
2) 写入 export LD_LIBRARY_PATH=动态库路径 保存 
3) ..bashrc/ source .bashrc / 重启 终端 (三种方法都可以)---&gt; 让修改后的.bashrc 生效 
4) ./a.out 成功！！！ 
</code></pre>
<p>【3】 拷贝自定义动态库 到 &#x2F;lib (标准 C 库所在目录位置) </p>
<p>【4】 配置文件法 </p>
<ul>
<li>sudo vi &#x2F;etc&#x2F;ld.so.conf</li>
<li>写入 动态库绝对路径 保存 </li>
<li>sudo ldconfig -v 使配置文件生效。 </li>
<li>.&#x2F;a.out 成功！！！— 使用 ldd a.out 查看</li>
</ul>
<h3 id="数据段合并"><a href="#数据段合并" class="headerlink" title="数据段合并"></a>数据段合并</h3><p>在链接阶段完成，节省空间，将同样工作（例如只读）的数据段合并。</p>
<h2 id="头文件守卫："><a href="#头文件守卫：" class="headerlink" title="头文件守卫："></a>头文件守卫：</h2><p>防止头文件被重复包含 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ifndef _HEAD_H_ </span><br><span class="line">#define _HEAD_H_ </span><br><span class="line">...... </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h2 id="gdb-调试基础指令"><a href="#gdb-调试基础指令" class="headerlink" title="gdb 调试基础指令"></a>gdb 调试基础指令</h2><p>使用 gdb 之前，要求对文件进行编译时增加-g 参数，加了这个参数过后生成的编译文件会大一些， 这是因为增加了 gdb 调试内容 </p>
<p>gdb 调试工具： 大前提：程序是你自己写的。 —逻辑错误 </p>
<p>基础指令： </p>
<p>​	-g：使用该参数编译可以执行文件，得到调试表。 </p>
<p>​	gdb .&#x2F;a.out </p>
<p>​	list： list 1 列出源码。根据源码指定 行号设置断点。 断点那一行不会执行</p>
<p>​	b： b 20 在 20 行位置设置断点。 </p>
<p>​	run&#x2F;r: 运行程序 </p>
<p>​	n&#x2F;next: 下一条指令（会越过函数） </p>
<p>​	next&#x2F;n :下一个，调用函数就跑 </p>
<p>​	step&#x2F;s :单步，会进入调用的函数 </p>
<p>​	要注意的是，如果是系统函数，按 s 就出不来了，这时用 until+行号直接执行到行号处</p>
<p>​	s&#x2F;step: 下一条指令（会进入函数） </p>
<p>​	p&#x2F;print：p i 查看变量的值。 </p>
<p>​	continue：继续执行断点后续指令。 </p>
<p>​	finish：结束当前函数调用。 </p>
<p>​	quit：退出 gdb 当前调试。 </p>
<p>其他指令： </p>
<p>​	run：使用 run 查找段错误出现位置。 </p>
<p>​	set args： 设置 main 函数命令行参数 （在 start、run 之前） </p>
<p>​	run 字串 1 字串 2 …: 设置 main 函数命令行参数 </p>
<p>​	info b: 查看断点信息表 </p>
<p>​	b 20 if i &#x3D; 5： 设置条件断点。 </p>
<p>​	ptype：查看变量类型。 </p>
<p>​	bt：列出当前程序正存活着的栈帧。 </p>
<p>​	frame： 根据栈帧编号，切换栈帧。 </p>
<p>​	display：设置跟踪变量 </p>
<p>​	undisplay：取消设置跟踪变量。 使用跟踪变量的编号。</p>
<p>没有符号被读取—编译时没加-g 参数 </p>
<p>file 后面加使用-g 编译的文件，可以不用退出，gdb 直接读取后进行调试。</p>
<h2 id="makefile-基础规则"><a href="#makefile-基础规则" class="headerlink" title="makefile 基础规则"></a>makefile 基础规则</h2><p>makefile： 管理项目。 </p>
<p>命名：makefile 	Makefile — make 命令 </p>
<p>1 个规则： </p>
<p>目标：依赖条件 </p>
<p>​	（一个 tab 缩进）命令 </p>
<ol>
<li>目标的时间必须晚于依赖条件的时间，否则，更新目标 </li>
<li>依赖条件如果不存在，找寻新的规则去产生依赖条件。</li>
</ol>
<p>ALL：指定 makefile 的终极目标（第一行）。</p>
<p>2 个函数：</p>
<p>​    src &#x3D; $(wildcard .&#x2F;*.c): 匹配当前工作目录下的所有.c 文件。将文件名组成列表，赋值给变量 src。 src &#x3D; add.c sub.c div1.c </p>
<p>​    obj &#x3D; $(patsubst %.c, %.o, $(src)): 将参数3中，包含参数1的部分，替换为参数2。 obj &#x3D; add.o sub.o div1.o</p>
<p>  clean: (没有依赖)</p>
<p>​    -rm -rf $(obj) a.out “-”：作用是，删除不存在文件时，不报错。顺序执行结束。</p>
<p>  3 个自动变量：</p>
<p>​    $@: 在规则的命令中，表示规则中的目标。</p>
<p>​    $^: 在规则的命令中，表示所有依赖条件。</p>
<p>​    $&lt;: 在规则的命令中，表示第一个依赖条件。如果将该变量应用在模式规则中，它可将依赖条件列表中的依赖依次取出，套用模式规则。</p>
<p>  模式规则：</p>
<p>​    %.o:%.c</p>
<p>​      gcc -c $&lt; -o %@</p>
<p>  静态模式规则：</p>
<p>​    $(obj):%.o:%.c</p>
<p>​      gcc -c $&lt; -o %@  </p>
<p>  伪目标：</p>
<p>​    .PHONY: clean ALL</p>
<p>  参数：</p>
<p>​    -n：模拟执行make、make clean 命令。</p>
<p>​    -f：指定文件执行 make 命令。       xxxx.mk</p>
<p> makefile检测原理：</p>
<p>修改文件后，文件的修改时间发生变化，会出现目标文件的时间早于作为依赖材料的时间，出现这种情况的文件会重新编译。</p>
<p>修改sub.c后，sub.o的时间就早于sub.c ，a.out的时间也早于sub.o的时间了，于是重新编译这俩文件了。</p>
<h2 id="makefile两个函数和clean"><a href="#makefile两个函数和clean" class="headerlink" title="makefile两个函数和clean"></a>makefile两个函数和clean</h2><p>src &#x3D; $(wildcard *.c)</p>
<p>找到当前目录下所有后缀为.c的文件，赋值给src</p>
<p>obj &#x3D; $(patsubset %.c,%.o, $(src))</p>
<p>把src变量里所有后缀为.c的文件替换成.o</p>
<p>rm前面的-，代表出错依然执行。比如，待删除文件集合是5个，已经手动删除了1个，就只剩下4个，然而删除命令里面还是5个的集合，就会有删除不存在文件的问题，不加这-，就会报错，告诉你有一个文件找不到。加了-就不会因为这个报错。</p>
<h2 id="makefile3个自动变量和模式规则"><a href="#makefile3个自动变量和模式规则" class="headerlink" title="makefile3个自动变量和模式规则"></a>makefile3个自动变量和模式规则</h2><p>3个自动变量</p>
<p>$@ ：在规则命令中，表示规则中的目标</p>
<p>$&lt; ：在规则命令中，表示规则中的第一个条件，如果将该变量用在模式规则中，它可以将依赖条件列表中的依赖依次取出，套用模式规则</p>
<p>$^ ：在规则命令中，表示规则中的所有条件，组成一个列表，以空格隔开，如果这个列表中有重复项，则去重</p>
<p>模式规则：</p>
<p>%.o:%.c</p>
<p>  gcc -c $&lt; -o $@</p>
<h2 id="静态模式规则"><a href="#静态模式规则" class="headerlink" title="静态模式规则"></a>静态模式规则</h2><p>继续优化makefile，使用静态模式规则，就是指定模式规则给谁用，这里指定模式规则给obj用，以后文件多了，文件集合会有很多个，就需要指定哪个文件集合用什么规则</p>
<p>$(obj):%.o:%.c</p>
<p>gcc -c $&lt; -o $@</p>
<p>再来一个扩展</p>
<p>当前文件夹下有ALL文件或者clean文件时，会导致makefile瘫痪，如下所示，make clean没有工作</p>
<p>用伪目标来解决，添加一行  .PHONY: clean ALL</p>
<p>还有一个扩展就是，编译时的参数，-g,-Wall这些，可以放在makefile里面</p>
<p>主要是注意%的匹配理解，只匹配文件名，目录位置要手动添加</p>
<p>如果makefile的名字变化一下，比如，叫m6</p>
<p>用m6执行makefile，   make -f m6</p>
<p>用m6执行clean      make -f m6 clean</p>
<p>源码 add.c,sub.c 这些在 src 目录下，.o 文件要放在 obj 目录下，头文件 head.h 在 inc 目录下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">src = $(wildcard ./src/*.c)	# ./src/add.c ./src/ sub.c...</span><br><span class="line">obj = $(patsubst ./src/%.c, ./obj/%.o，$(src))</span><br><span class="line">inc_path = ./inc</span><br><span class="line">myArgs = -Wall -g</span><br><span class="line">ALL:a.out</span><br><span class="line">$(obj):./obj/%.o:./src/%.c</span><br><span class="line">	gcc -c $&lt; -o $@ $(myArgs) -I $(inc_path)</span><br><span class="line">a.out: $(obj)</span><br><span class="line">	gcc $^ -o $@ $(myArgs)</span><br><span class="line">clean:</span><br><span class="line">	-rm -rf $(obj) a.out</span><br><span class="line">.PHONY: clean ALL</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/" class="post-title-link" itemprop="url">深入理解计算机系统 第三章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-13 11:28:04" itemprop="dateCreated datePublished" datetime="2023-05-13T11:28:04+08:00">2023-05-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-28 11:04:18" itemprop="dateModified" datetime="2023-05-28T11:04:18+08:00">2023-05-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第3章程序的机器级表示"><a href="#第3章程序的机器级表示" class="headerlink" title="第3章程序的机器级表示"></a>第3章程序的机器级表示</h1><h2 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h2><p>其中一些关于机器代码和它的反汇编表示的特性值得注意:</p>
<ul>
<li>x86-64的指令长度从1到15个字节不等。常用的指令以及操作数较少的指令所需的字节数少，而那些不太常用或操作数较多的指令所需字节数较多。</li>
<li>设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。例如，只有指令pushq %rbx是以字节值53开头的。</li>
<li>反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码。</li>
<li>反汇编器使用的指令命名规则与GCC生成的汇编代码使用的有些细微的差别。在我们的示例中，它省略了很多指令结尾的‘q’。这些后缀是大小指示符，在大多数情况中可以省略。相反，反汇编器给call和ret 指令添加了‘q’后缀，同样，省略这些后缀也没有问题。</li>
</ul>
<p>虽然C编译器在把程序中表达的计算转换到机器代码方面表现出色，但是仍然有一些机器特性是C程序访问不到的。例如，每次 x86-64处理器执行算术或逻辑运算时，如果得到的运算结果的低8位中有偶数个1，那么就会把一个名为PF的1位条件码(condition code)标志设置为1，否则就设置为0。这里的PF表示“parity flag(奇偶标志)”。在C语言中计算这个信息需要至少7次移位、掩码和异或运算。即使作为每次算术或逻辑运算的一部分，硬件都完成了这项计算，而C程序却无法知道PF条件码标志的值。在程序中插入几条汇编代码指令就能很容易地完成这项任务。</p>
<p>在C程序中插入汇编代码有两种方法。第一种是，我们可以编写完整的函数，放进一个独立的汇编代码文件中，让汇编器和链接器把它和用C语言书写的代码合并起来。第二种方法是，我们可以使用GCC的内联汇编(inline assembly)特性，用asm伪指令可以在C程序中包含简短的汇编代码。这种方法的好处是减少了与机器相关的代码量。</p>
<p>当然，在C程序中包含汇编代码使得这些代码与某类特殊的机器相关(例如x86-64)，所以只应该在想要的特性只能以此种方式才能访问到时才使用它。</p>
<h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><p>由于是从16位体系结构扩展成32位的，Intel用术语“字(word)”表示16位数据类型。因此，称32位数为“双字(double words)”，称64位数为“四字(quad words)”。C语言基本数据类型对应的x86-64表示。标准int值存储为双字(32位)。指针(在此用char *表示)存储为8字节的四字，64位机器本来就预期如此。</p>
<table>
<thead>
<tr>
<th>C声明</th>
<th>Intel数据类型</th>
<th>汇编代码后缀</th>
<th>大小(字节)</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>字节</td>
<td>b</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td>字</td>
<td>w</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>双字</td>
<td>l</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>四字</td>
<td>q</td>
<td>8</td>
</tr>
<tr>
<td>char*</td>
<td>四字</td>
<td>q</td>
<td>8</td>
</tr>
<tr>
<td>float</td>
<td>单精度</td>
<td>s</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>双精度</td>
<td>l</td>
<td>8</td>
</tr>
</tbody></table>
<h2 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h2><p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20230515185054534.jpg" alt="image-20230515185054534"></p>
<img src="/2023/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20230515185054534.jpg" class title="This is an test image">

<h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p>MOV指令源和目的类型的组合。记住，<strong>第一个是源操作数，第二个是目的操作数。</strong></p>
<p>源操作数指定的值是一个立即数，存储在寄存器中或者内存中。目的操作数指定一个位置，要么是一个寄存器或者，要么是一个内存地址。</p>
<p>寄存器部分的大小必须与指令最后一个字符(‘b’，‘w’，‘1’或‘q’)指定的大小匹配。大多数情况中，MOV指令只会更新目的操作数指定的那些寄存器字节或内存位置。唯一的例外是movl指令以寄存器作为目的时，它会把该寄存器的高位4字节设置为0。造成这个例外的原因是x86-64采用的惯例，即任何为寄存器生成32位值的指令都会把该寄存器的高位部分置成0。</p>
<p>常规的movq指令只能以表示为32位补码数字的立即数作为源操作数，然后把这个值符号扩展得到64位的值，放到目的位置。movabsq指令能够以任意64位立即数值作为源操作数，并且只能以寄存器作为目的。</p>
<p>所有这些指令都把数据从源(在寄存器或内存中)复制到目的寄存器。MOVZ类中的指令把目的中剩余的字节填充为0，而MOVS类中的指令通过符号扩展来填充，把源操作的最高位进行复制。可以观察到，每条指令名字的最后两个字符都是大小指示符:第一个字符指定源的大小，而第二个指明目的的大小。</p>
<p><strong>局部变量通常是保存在寄存器中</strong>，而不是内存中。访问寄存器比访问内存要快得多。</p>
<h2 id="算术和逻辑操作"><a href="#算术和逻辑操作" class="headerlink" title="算术和逻辑操作"></a>算术和逻辑操作</h2><h3 id="加载有效地址"><a href="#加载有效地址" class="headerlink" title="加载有效地址"></a>加载有效地址</h3><p>加载有效地址(load effective address)指令leaq实际上是movq指令的变形。它的指令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。它的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读人数据，而是将有效地址写入到目的操作数。</p>
<h3 id="二元操作"><a href="#二元操作" class="headerlink" title="二元操作"></a>二元操作</h3><p>二元操作，其中，第二个操作数既是源又是目的。这种语法让人想起C语言中的赋值运算符，例如x-&#x3D;y。不过，要注意，源操作数是第一-个，目的操作数是第二个,对于不可交换操作来说，这看上去很奇特。例如，指令<code>subq %rax,%rdx</code>使寄存器%rdx的值减去%rax中的值。(将指令解读成“从%rdx中减去%rax”会有所帮助。)第一个操作数可以是立即数、寄存器或是内存位置。第二个操作数可以是<strong>寄存器或是内存位置</strong>。注意,当第二个操作数为内存地址(如果是寄存器地址加操作数格式则表示内存位置)时，处理器必须从内存读出值，执行操作，再把结果写回内存。</p>
<p>通常，编译器产生的代码中，会用一个寄存器存放多个程序值，还会在寄存器之间传送程序值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xorq %rdx, %rdx</span><br></pre></td></tr></table></figure>

<p>但是在产生这段汇编代码的 C 代码中，并没有出现 EXCLUSIVE-OR 操作。</p>
<p>A. 解释这条特殊的 EXCLUSIVE-OR 指令的效果，它实现了什么有用的操作。</p>
<p>B. 更直接地表达这个操作的汇编代码是什么？</p>
<p>C. 比较同样一个操作的两种不同实现的编码字节长度。</p>
<blockquote>
<p>A. 这个指令用来将寄存器 % rdx 设置为 0，运用了对任意 x，x^x&#x3D;0 这一属性。它对应于 C 语句 x&#x3D;0 。</p>
<p>B. 将寄存器 % rdx 设置为 0 的更直接的方法是用指令 movq $0, % rdx 。</p>
<p>C. 汇编和反汇编这段代码，我们发现使用 xorq 的版本只需要 3 个字节，而使用 movq 的版本需要 7 个字节。其他将 % rdx 设置为 0 的方法都依赖于这样一个属性，即任何更新低位 4 字节的指令都会把高位字节设置为 0 。因此，我们可以使用 xorl % edx, % edx（2 字节）或 movl $0, % edx（5 字节）。</p>
</blockquote>
<h3 id="特殊的算术操作"><a href="#特殊的算术操作" class="headerlink" title="特殊的算术操作"></a>特殊的算术操作</h3><p>此外，x86-64 指令集还提供了两条不同的“单操作数”乘法指令，以计算两个64位值的全128位乘积——一个是无符号数乘法(mulq)，而另一个是补码乘法(imulq)。这两条指令都要求一个参数必须在寄存器%rax中，而另一个作为指令的源操作数给出。然后乘积存放在寄存器%rdx(高64位)和%rax(低64位)中。虽然imulq这个名字可以用于两个不同的乘法操作，但是汇编器能够通过计算操作数的数目，分辨出想用哪条指令。</p>
<p>有符号除法指令idivl将寄存器%rdx(高64位)和%rax(低64位)中的128位数作为被除数，而除数作为指令的操作数给出。指令将商存储在寄存器%rax中，将余数存储在寄存器%rdx中。</p>
<p>对于大多数64位除法应用来说，除数也常常是一个64位的值。这个值应该存放在%rax中，%rdx的位应该设置为全0(无符号运算)或者%rax的符号位(有符号运算)。后面这个操作可以用指令cqto来完成。这条指令不需要操作数—它隐含读出%rax的符号位，并将它复制到%rdx的所有位。即汇编代码中除法前一行就是cqto.</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>为了提高空间和时间效率，x86-64过程只分配自己所需要的栈帧部分。例如，许多过程有6个或者更少的参数，那么所有的参数都可以通过寄存器传递。因此，某些栈帧部分可以省略。实际上，许多函数甚至根本不需要栈帧。当所有的局部变量都可以保存在寄存器中，而且该函数不会调用任何其他函数(有时称之为叶子过程，此时把过程调用看做树结构)时，就可以这样处理。</p>
<p>x86-64 中，可以通过寄存器最多传递6个整型(例如整数和指针)参数。寄存器的使用是有特殊顺序的，寄存器使用的名字取决于要传递的数据类型的大小，如果一个函数有大于6个整型参数，超出6个的部分就要通过栈来传递。</p>
<p>T2（callq）是子程序调用指令，这条指令会：</p>
<ol>
<li>调整栈寄存器 (%rsp-8 -&gt; %rsp）</li>
<li>把下一条指令的地址放到栈里（0x40054e-&gt;*%rsp)</li>
<li>以上两步简单来说就是把下一条指令的地址入栈（push）</li>
<li>然后子程序的地址（0x400540）加载至rip</li>
</ol>
<p>然后子程序开始执行。子程序以retq结束会执行出栈（pop）操作：</p>
<ol>
<li>当前的栈内容放入%rip</li>
<li>调整栈寄存器（%rsp+8 -&gt; %rsp）</li>
</ol>
<p>程序从0x40054e继续执行（之前入栈的地址）<strong>栈区的地址分配是从内存的高地址开始向低地址分配；</strong></p>
<h3 id="栈上的局部存储"><a href="#栈上的局部存储" class="headerlink" title="栈上的局部存储"></a>栈上的局部存储</h3><p>到目前为止我们看到的大多数过程示例都不需要超出寄存器大小的本地存储区域。不过有些时候，局部数据必须存放在内存中，常见的情况包括:</p>
<ul>
<li>寄存器不足够存放所有的本地数据。</li>
<li>对一个局部变量使用地址运算符‘&amp;’，因此必须能够为它产生一个地址（用leaq指令生成到这些位置的指针）。</li>
<li>某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到。在描述数组和结构分配时，我们会讨论这个问题。</li>
</ul>
<p>一般来说，过程通过减小栈指针在栈上分配空间。分配的结果作为栈帧的一部分，标号为“局部变量”。</p>
<h3 id="寄存器的局部存储空间"><a href="#寄存器的局部存储空间" class="headerlink" title="寄存器的局部存储空间"></a>寄存器的局部存储空间</h3><p>根据惯例，寄存器rbx、%rbp和%r12～%r15被划分为被调用者保存寄存器。当过程P调用过程Q时，Q必须保存这些寄存器的值，保证它们的值在Q返回到P时与Q被调用时是一样的。过程Q保存一个寄存器的值不变，要么就是根本不去改变它，要么就是把原始值压入栈中，改变寄存器的值，然后在返回前从栈中弹出旧值。压人寄存器的值会在栈帧中创建标号为“保存的寄存器”的一部分。有了这条惯例，P的代码就能安全地把值存在被调用者保存寄存器中(当然，要先把之前的值保存到栈上)，调用Q,然后继续使用寄存器中的值,不用担心值被破坏。</p>
<h2 id="异数的数据结构"><a href="#异数的数据结构" class="headerlink" title="异数的数据结构"></a>异数的数据结构</h2><h3 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h3><p>还可以观察到，一个联合的总的大小等于它最大字段的大小。<br>在一些下上文中，联合十分有用。但是，它也能引起一些讨厌的错误，因为它们绕过了C语言类型系统提供的安全措施。一种应用情况是，我们事先知道对一个数据结构中的两个不同字段的使用是互斥的，那么将这两个字段声明为联合的一部分，而不是结构的一部分，会减小分配空间的总量。</p>
<p>开始的跳转表的汇编代码声明在第2行包含下面这样的命令:<br>.align 8<br>这就保证了它后面的数据(在此，是跳转表的开始)的起始地址是8的倍数。因为每个表项长8个字节，后面的元素都会遵守8字节对齐的限制。</p>
<h2 id="在机器级程序中将控制与数据结合起来"><a href="#在机器级程序中将控制与数据结合起来" class="headerlink" title="在机器级程序中将控制与数据结合起来"></a>在机器级程序中将控制与数据结合起来</h2><h3 id="理解指针"><a href="#理解指针" class="headerlink" title="理解指针"></a>理解指针</h3><p>leaq指令是设计用来计算内存引用的地址的，&amp;运算符的机器代码实现常常用这条指令来计算表达式的值。</p>
<h3 id="GDB命令"><a href="#GDB命令" class="headerlink" title="GDB命令"></a>GDB命令</h3><p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20230524151520753.png" alt="image-20230524151520753"></p>
<img src="/2023/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20230524151520753.png" class title="This is an test image">

<p>GDB的命令语法有点晦涩，但是在线帮助信息(用GDB的 help命令调用)能克服这些毛病。相对于使用命令行接口来访问GDB，许多程序员更愿意使用DDD，它是 GDB的一个扩展，提供了图形用户界面。</p>
<h3 id="内存越界引用和缓冲区溢出"><a href="#内存越界引用和缓冲区溢出" class="headerlink" title="内存越界引用和缓冲区溢出"></a>内存越界引用和缓冲区溢出</h3><p>更好一点的版本是使用fgets函数，它包括一个参数，限制<strong>待读入的最大字节数</strong>。通常，使用gets或其他任何能导致存储溢出的函数，都是不好的编程习惯。不幸的是，很多常用的库函数，包括strcpy、strcat和 sprintf都有一个属性——不需要告诉它们目标缓冲区的大小，就产生一个字节序列[97]。超过待读入最大字节数就可能发生错误，这样的情况就会导致缓冲区溢出漏洞。</p>
<p>如在栈上分配了24个字节，待读入最大字节为8</p>
<p>echo执行时栈的组织。该程序把栈指针减去了24，在栈上分配了24个字节。字符数组buf位于栈顶，可以看到,%rsp被复制到%rdi作为调用gets和puts 的参数。这个调用的参数和存储的返回指针之间的16字节是未被使用的。只要用户输人不超过7个字符，gets返回的字符串(包括结尾的null)就能够放进为buf分配的空间里。不过，长一些的字符串就会导致gets覆盖栈上存储的某些信息。随着字符串变长，下面的信息会被破坏:</p>
<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20230525102612348.png" alt="image-20230525102612348"></p>
<img src="/2023/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20230525102612348.png" class title="This is an test image">

<h2 id="浮点代码"><a href="#浮点代码" class="headerlink" title="浮点代码"></a>浮点代码</h2><p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20230527153556717.png" alt="image-20230527153556717"></p>
<img src="/2023/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20230527153556717.png" class title="This is an test image">

<p>在x86-64 中，XMM寄存器用来向函数传递浮点参数，以及从函数返回浮点值。如图3-45所示，可以看到如下规则:</p>
<ul>
<li>XMM寄存器%xmm0～%xmm7最多可以传递8个浮点参数。按照参数列出的顺序使用这些寄存器。可以通过栈传递额外的浮点参数。</li>
<li>函数使用寄存器%xmm0来返回浮点值。</li>
<li>所有的XMM寄存器都是调用者保存的。被调用者可以不用保存就覆盖这些寄存器中任意一个。</li>
</ul>
<p>当函数包含指针、整数和浮点数混合的参数时，指针和整数通过通用寄存器传递，而浮点值通过XMM寄存器传递。也就是说，参数到寄存器的映射取决于它们的类型和排列的顺序。下面是一些例子:<br><code>double f1(int x,double y, long z);</code><br>这个函数会把x存放在% edi中，y放在%xmm0中，而z放在%rsi中。<br><code>double f2(double y, int x，long z);</code><br>这个函数的寄存器分配与函数f1相同。<br><code>double f1(float x, double *y，long*z);</code><br>这个函数会将x放在%xmm0中，y放在%rdi中，而z放在%rsi中。</p>
<h3 id="定义和使用浮点常数"><a href="#定义和使用浮点常数" class="headerlink" title="定义和使用浮点常数"></a>定义和使用浮点常数</h3><p>和整数运算操作不同，AVX浮点操作不能以立即数值作为操作数。相反，编译器必须为所有的常量值分配和初始化存储空间。然后代码在把这些值从内存读人。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">深入理解计算机系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-05 16:12:22" itemprop="dateCreated datePublished" datetime="2023-05-05T16:12:22+08:00">2023-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-11 17:40:00" itemprop="dateModified" datetime="2023-05-11T17:40:00+08:00">2023-05-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第2章-信息的表示和处理"><a href="#第2章-信息的表示和处理" class="headerlink" title="第2章 信息的表示和处理"></a>第2章 信息的表示和处理</h1><h4 id="文字编码的Unicode标准"><a href="#文字编码的Unicode标准" class="headerlink" title="文字编码的Unicode标准"></a>文字编码的Unicode标准</h4><p>基本编码，称为Unicode的“统一字符集”，使用32位来表示字符。这好像要求文本串中每个字符要占用4个字节。不过，可以有一些替代编码，常见的字符只需要1个或2个字节，而不太常用的字符需要多一些的字节数。特别地，UTF-8表示将每个字符编码为一个字节序列，<strong>这样标准ASCII字符还是使用和它们在ASCII 中一样的单字节编码</strong>，这也就意味着所有的ASCII字节序列用ASCII码表示和用UTF-8表示是一样的。</p>
<p>Java编程语言使用Unicode来表示字符串。对于C语言也有支持 Unicode的程序库。</p>
<p>在使用ASCII码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关。因而，<strong>文本数据比二进制数据具有更强的平台独立性</strong>。</p>
<p>不同的机器类型使用不同的且不兼容的指令和编码方式。即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。</p>
<h2 id="c语言的移位运算"><a href="#c语言的移位运算" class="headerlink" title="c语言的移位运算"></a>c语言的移位运算</h2><p>C语言标准并没有明确定义对于有符号数应该使用哪种类型的右移–算术右移或者<strong>逻辑右移</strong>（不管符号均补0）都可以。不幸地，这就意味着任何假设一种或者另一种右移形式的代码都可能会遇到可移植性问题。然而，实际上，几乎所有的编译器&#x2F;机器组合都对有符号数使用<strong>算术右移</strong>（有符号时最高位是1补1），且许多程序员也都假设机器会使用这种右移。另一方面，对于无符号数，右移必须是逻辑的。<br>与C相比，Java对于如何进行右移有明确的定义。表达是x&gt;&gt;k会将x算术右移k个位置，而x&gt;&gt;&gt;k会对x做逻辑右移。</p>
<h3 id="移动k-位，这里k-很大"><a href="#移动k-位，这里k-很大" class="headerlink" title="移动k 位，这里k 很大"></a>移动k 位，这里k 很大</h3><p>对于一个由w位组成的数据类型，如果要移动k≥w位会得到什么结果呢?例如，计算下面的表达式会得到什么结果，假设数据类型int为w&#x3D;32:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">intlval =OxFEDCBA98&lt;&lt; 32;</span><br><span class="line">intaval =OxFEDCBA98&gt;&gt;36;</span><br><span class="line">unsigned uval =OxFEDCBA98u &gt;&gt;40;</span><br></pre></td></tr></table></figure>

<p>C语言标准很小心地规避了说明在这种情况下该如何做。在许多机器上，当移动一个w位的值时，移位指令只考虑位移量的低 log2 w位，因此实际上位移量就是通过计算k mod w得到的。例如，当w&#x3D;32时，上面三个移位运算分别是移动0、4和8位，得到结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lval 0xFEDCBA98</span><br><span class="line">aval 0xFFEDCBA9</span><br><span class="line">uval 0x00FEDCBA</span><br></pre></td></tr></table></figure>

<p>不过这种行为对于C程序来说是没有保证的，所以应该保持位移量小于待移位值的位数。另一方面，Java 特别要求位移数量应该按照我们前面所讲的求模的方法来计算。</p>
<h2 id="补码编码"><a href="#补码编码" class="headerlink" title="补码编码"></a>补码编码</h2><p>采用补码表示的32位大端法机器（符合习惯，先输出低地址的高位）上输出打印16进制时：是看补码来转换。</p>
<p>原理:补码编码的定义<br><img src="/2023/05/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Users\86191\AppData\Roaming\Typora\typora-user-images\image-20230507151108343.png" alt="image-20230507151108343"></p>
<p>例如1001（-1）的补码是1111可以根据上面计算-8+7&#x3D;-1</p>
<p><strong>负数的补码，是能够和其相反数相加通过溢出从而使计算机内计算结果变为0的二进制码</strong>。这是补码设计的初衷，具体目标就是让1+（-1）&#x3D;0，这利用原码是无法得到的</p>
<p>对于大多数C语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是:数值可能会改变，但是<strong>位模式不变</strong>。</p>
<p>无符号表示中的UMax竟有着和补码表示的-1相同的位模式。我们在这两个数之间也能看到这种关系<br>$$<br>:1+UMax_w&#x3D;2^w<br>$$<br>原理:补码转换为无符号数<br>对满足TMin_x≤x≤TMax_w的x有:<br>$$<br>T2U_w(x)&#x3D;\begin{cases} x+2^w,x&lt;0\ x,x&gt;&#x3D;0\end{cases}<br>$$<br>一个无符号数u和与之对应的有符号数U2T_w(u)之间的关系:</p>
<p>原理:无符号数转换为补码</p>
<p>对满足0≤u≤UMax _w的u有:<br>$$<br>U2T_w(u)&#x3D;\begin{cases} u-2^w,u&gt;TMax_w\ u,x&lt;&#x3D;TMax_w\end{cases}<br>$$<br>总结一下，我们考虑无符号与补码表示之间互相转换的结果。对于在范围0≤T&lt;TMax_w之内的值x而言，我们得到T2U_w(x)&#x3D;x和U2T_w(x)&#x3D;x。也就是说，在这个范围内的数字有相同的无符号和补码表示。对于这个范围以外的数值，转换需要加上或者减去2^w。例如，我们有<br>$$<br>T2U_w(-1)&#x3D;-1+2^w&#x3D;UMax_w<br>$$<br>—-最靠近0的负数映射为最大的无符号数</p>
<h2 id="c语言里面TMin不能写成-2147483648的原因"><a href="#c语言里面TMin不能写成-2147483648的原因" class="headerlink" title="c语言里面TMin不能写成-2147483648的原因"></a>c语言里面TMin不能写成-2147483648的原因</h2><p>C语言中，将TMin（32位有符号整数的最小值）写成 <strong>-2147483647-1</strong>，而不是简单地写成 -2147483648 或 0x80000000 。</p>
<p>可见如果不发生溢出，整型常量的值总是非负数。如果前面<strong>出现符号</strong>，则是对整型常量使用的一元运算符，而不是整型常量的一部分。</p>
<p>如果将TMin32写成-2147483648并且将代码在一个32位的机器上面编译，当编译器遇到**-X<strong>形式的数值，它首先会确定</strong>X<strong>的数据类型和值，然后取</strong>X**的。</p>
<p>由于-2147483648超过了int所能够表示的范围，编译器就会再次选择一种可以正确的表示此值的类型。然后它就会按照第一个表格（十进制）的顺序往下继续尝试类型，再假设编译器采用的标准是ISO C90，int-&gt;long-&gt;unsigned，然后就发现unsigned是第一个合适的数据类型。正如我们知道的，2147483648和-2147483648在32位数值上拥有同样的位表示，使得此常量的最终数据类型是unsigned且值为2147483648。这对于16进制的0x80000000也是相同的结果。</p>
<p>用一句话来解释C语言中TMin32的古怪写法的原因：虽然-2147483648 这个数值能够用int类型(4字节)来表示，但在C语言中却没法写出对应这个数值的int类型常量。</p>
<h2 id="补码的非"><a href="#补码的非" class="headerlink" title="补码的非"></a>补码的非</h2><p>原理:补码的非<br>对满足TMin_w≤x≤TMax_w 的x，其补码的非-^t_wx由下式给出<br>$$<br>-^t_wx&#x3D;\begin{cases}TMin_w,x&#x3D;TMin_w\-x,x&gt;TMin_w\end{cases}<br>$$<br>此处设w&#x3D;4，用补码可表示的范围就是[-8,7]，对于-8，它的“补码的非”还是-8,而[-7,7]补码的非就是原数的负数，比如说-4的“补码的非”是-4取负，即：4，而3的“补码的非”是3取负，即：-3。这是“补码的非”的定义；注意：“补码的非”并不是把“一个数的补码按位取非”</p>
<p>TMin_w&#x3D;-2^w-1</p>
<p>执行位级补码非的第一种方法是对每一位求反，再对结果加1。在C语言中，我们可以说，对于任意整数值x，计算表达式-x和~x+1得到的结果完全一样。</p>
<h2 id="对TMin-w-x3D-2-w-1的解释"><a href="#对TMin-w-x3D-2-w-1的解释" class="headerlink" title="对TMin_w&#x3D;-2^w-1的解释"></a>对TMin_w&#x3D;-2^w-1的解释</h2><p>如w&#x3D;4的-8&#x3D;1000，可以参考-2为例</p>
<p>[-2]原 &#x3D; 1 0010    [-2]补 &#x3D; 11110</p>
<p>如我所说，没有符号位，那么11110就是30，也就是说 -2的补码是30（%2^5）</p>
<h2 id="补码移位"><a href="#补码移位" class="headerlink" title="补码移位"></a>补码移位</h2><p>移位也是运算，需要将负数的原码变成补码移位</p>
<p>对无符号运算使用移位是非常简单的，部分原因是由于无符号数的右移一定是逻辑右移（不管最高位符号）。对于x大于等于0的有符号一样逻辑右移。</p>
<p>负数在执行算术右移之前加上一个适当的偏置量是可以导致结果正确舍入的。</p>
<p>补码除以2的幂(<strong>右移之前加上一个偏量</strong>，结果就向零舍入了).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int optarith(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    int t = x;</span><br><span class="line">    x &lt;&lt;= 5;</span><br><span class="line">    x -= t;</span><br><span class="line">    if (y &lt; 0)</span><br><span class="line">        y += 7;//加上一个适当的偏置量111,是为了正确右移3位，若右移4位，则加15（1111）</span><br><span class="line">    y &gt;&gt;= 3; /* Arithmetic shift */</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IEEE浮点标准"><a href="#IEEE浮点标准" class="headerlink" title="IEEE浮点标准"></a>IEEE浮点标准</h2><p>IEEE浮点标准用<br>$$<br>V&#x3D;（-1）^s<em>M</em>2^E<br>$$<br> 的形式来表示一个数，符号s，尾数M，阶码E</p>
<p>C语言中，单精度（float）的s为1b，E为8b，M为23b，双精度（double）的s为1b，E为11b，M为52b。</p>
<p>阶码的值<strong>E&#x3D;e-Bias</strong>，e是无符号数，Bias为偏置值，等于 2^(k-1)−1 (float为127，double为1023)</p>
<h3 id="计算-IEEE-754-标准浮点数的真值"><a href="#计算-IEEE-754-标准浮点数的真值" class="headerlink" title="计算 IEEE 754 标准浮点数的真值"></a>计算 IEEE 754 标准浮点数的真值</h3><p>在上述内容的分析之后，再通过观察分析以下这个 IEEE 754 单精度浮点数格式表示的数，系统性了解如何计算出 IEEE 754 标准浮点数的真值：</p>
<p>1 100 0000 1010 0000 0000 0000 0000 0000<br>上数分别对应图1-1的中 S（符号码，0 正，1 负），E (阶码) ，M (尾数数值)为：</p>
<p>S (红色部分) ：1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1，表示这个浮点数是个负数；</span><br></pre></td></tr></table></figure>

<p>E (蓝色部分) ：100 0000 1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100 0000 1，阶码，其真值为 ：移码 - 偏置值 =&gt; 1000 0001 - 0111 1111 = 0000 0010 = 2D；（对应下面的2^2D）</span><br></pre></td></tr></table></figure>

<p>M (黑色部分) ：010 0000 0000 0000 0000 0000</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">010 0000 0000 0000 0000 0000 表示这个浮点数的尾数部分，其真值为：被隐含的最高位1 + 0.尾数部分 =&gt; 1 + 0.01 = 1.01B;</span><br></pre></td></tr></table></figure>

<p>通过对 S，E，M 的分析，我们可以计算出该浮点数的真值，即：</p>
<p>-1.01B * 2^10B &#x3D; 1.25D （-1.01B）* 2^2D &#x3D; -5.0D</p>
<hr>
<p>十进制数12345具有二进制[0011 0000 0011 1001]（0x3039），通过将二进制小数点左移13位，得到这个数的一个规格化表示 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12345=1.1000000111001_2×2^13 </span><br></pre></td></tr></table></figure>

<p>，为了使用IEEE单精度（float）形式来编码，我们丢弃开头的1，并且在末尾增加10个0（单精度的尾数位23位，13+10&#x3D;23），来构造小数字段，得到二进制[1000000111001<em>0000000000</em>]，为了得到阶码字段，将13加上偏置量127，得到140，二进制表示为[10001100]，加上符号位0，得到12345.0的二进制浮点数[0100 0110 0100 0000 1110 0100 0000 0000]（0x4640E400），比较整数12345（0x3039）和浮点数12345.0（0x4640E400）的位级表示：</p>
<p>（0x00003039）0000000000000000001<em><strong>1000000111001</strong></em></p>
<p>（0x4640E400）010001100<em><strong>1000000111001</strong></em>0000000000</p>
<p>阶码的值E&#x3D;e-Bias,产生指数的取值范围，对于单精度是一126～＋127，而对于双精度是一1022~+1023。</p>
<h3 id="十进制数转为-IEEE-754-浮点数格式"><a href="#十进制数转为-IEEE-754-浮点数格式" class="headerlink" title="十进制数转为 IEEE 754 浮点数格式"></a>十进制数转为 IEEE 754 浮点数格式</h3><p>同样地再用一个例子 十进制数转为 IEEE 754 浮点数的例子，加深对 十进制数 与 IEEE 754 浮点数之间的转换的理解。</p>
<p> 例如：将十进制数 -0.75 转为 IEEE 754 的单精度浮点数格式表示，分析过程如下：</p>
<p>过程A： -0.75D &#x3D; -0.11B &#x3D; -1.1B * 2^(-1B)<br>S：1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-0.75 为负数，故 S 符号码为 1</span><br></pre></td></tr></table></figure>

<p>E：0111 1110</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由 过程A 得，阶码的真值为 -0000 0001(因为是2^(-1B)，与上面例子一致) ，其移码为：-0000 0001 + 0111 1111 = 0111 1110</span><br></pre></td></tr></table></figure>

<p>M：100 0000 0000 0000 0000 0000</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由 过程A 得，尾数码真值为：-1.1，隐含最高位 1 ，取小数部分，得100 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>

<p>最终结果为：</p>
<p>1 011 1111 0100 0000 0000 0000 0000 0000</p>
<h2 id="向偶数舍人在大多数现实情况中避免了这种统计偏差。"><a href="#向偶数舍人在大多数现实情况中避免了这种统计偏差。" class="headerlink" title="向偶数舍人在大多数现实情况中避免了这种统计偏差。"></a><strong>向偶数舍人在大多数现实情况中避免了这种统计偏差</strong>。</h2><p>在50%的时间里，它将向上舍人，而在50%的时间里，它将向下舍入。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/24/c-%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/24/c-%E7%B1%BB/" class="post-title-link" itemprop="url">c++类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-24 09:39:59 / 修改时间：15:12:34" itemprop="dateCreated datePublished" datetime="2023-04-24T09:39:59+08:00">2023-04-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>C++要求对一般的内置函数要用关键字inline声明，但对类内定义的成员函数，可以省略inline，因为<strong>这些成员函数已经被隐含地指定为内置函数了</strong>。</p>
<p>类的隐式内联和显式内联：</p>
<ul>
<li>类内部的内联函数：类内部只要定义在函数其实都是默认inline的（即通常我们说的尽量不要往.h中类定义的地方直接定义函数，最好只是做一个申明，这个说法其实不太好，因为这会破坏隐藏内联的功能）。</li>
<li>虽然说即便是隐藏的内联，也不一定是内联的，最后还是编译器决定，但是定义在.cpp中的内容，等于是放弃了内联功能，这种可能性降低的写法其实是不推荐的。</li>
<li>另外，也可以用inline放在开头，进行显式的内联，但是仍然需要注意：类内部成员函数的申明和最终的成员函数的定义（可以放在类定义的外部，但是还是要在同一个.h中，否则inline不会生效）。所以，从这个角度看，基本上可以引出一条规定：一些简单的函数、构造函数、析构函数，推荐在类内部进行直接定义，这样能够用到inline功能，对于性能来说更加有利的。至于可读性方面的考虑，完全可以加一些范围的注释、分类，将需要inline的定义在一撮，另外需要在cpp中实现的“复杂”函数，申明在另外一撮。</li>
</ul>
<h2 id="C-中常量成员函数"><a href="#C-中常量成员函数" class="headerlink" title="C++中常量成员函数"></a>C++中常量成员函数</h2><p>可以将C++中类的成员函数声明为常量，这种成员函数叫做常量成员函数（const member function）。</p>
<h3 id="1-声明"><a href="#1-声明" class="headerlink" title="1 声明"></a>1 声明</h3><p>将const关键字放在类成员函数的参数列表之后，表示该函数为常量成员函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class MyClass</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">int consFunc() const;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">int m_MyNum;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-定义"><a href="#2-定义" class="headerlink" title="2 定义"></a>2 定义</h3><p>可以在类内定义consFunc()函数，也可以在类外定义。不管是在类内还是类外定义该函数，都要使用关键字const。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int MyClass::consFunc() const</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">return this-&gt;m_MyNum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-含义"><a href="#3-含义" class="headerlink" title="3 含义"></a>3 含义</h3><p>在“2定义”中定义的consFunc()函数中，如果不添加const关键字，此时constFunc()是普通的成员函数，此时this的类型是MyClass* const，即this本身是常量，但是其指向的类型是非常量。这就意味着我们不能把this绑定到一个常量对象上。如果要把this绑定到一个常量对象上，必须要把this定义成const MyClass* const，即指向常量的常量。在类成员函数的参数列表之后添加const关键字，就相当于把this定义成const MyClass* const。</p>
<h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4 注意事项"></a>4 注意事项</h3><h4 id="4-1-常量对象必须调用常量成员函数"><a href="#4-1-常量对象必须调用常量成员函数" class="headerlink" title="4.1 常量对象必须调用常量成员函数"></a>4.1 常量对象必须调用常量成员函数</h4><p>正如“3 含义”中提到的，如果通过常量对象调用类的成员函数，该成员函数必须是常量成员函数。</p>
<h4 id="4-2-非常量对象可以调用常量成员函数"><a href="#4-2-非常量对象可以调用常量成员函数" class="headerlink" title="4.2 非常量对象可以调用常量成员函数"></a>4.2 非常量对象可以调用常量成员函数</h4><p>因为可以将一个非常量赋值给常量，所以非常量对象可以调用常量成员函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass myclass;</span><br><span class="line"></span><br><span class="line">myclass.consFunc();</span><br></pre></td></tr></table></figure>



<h4 id="4-3-常量成员函数中不能修改成员变量"><a href="#4-3-常量成员函数中不能修改成员变量" class="headerlink" title="4.3 常量成员函数中不能修改成员变量"></a>4.3 常量成员函数中不能修改成员变量</h4><p>因为常量成员函数中的this类型是const MyClass* const，所以不能通过this来修改成员变量。</p>
<p>如果consFunc()函数的定义改为如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int MyClass::consFunc() const</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">return this-&gt;m_MyNum++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则此时程序会报错，error C3490: 由于正在通过常量对象访问“m_MyNum”，因此无法对其进行修改。</p>
<hr>
<p>编译器分两步处理类:首先编译成员的声明，然后才轮到成员函数体（如果有的话)。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/23/linux%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/23/linux%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">linux基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-23 14:32:54" itemprop="dateCreated datePublished" datetime="2023-04-23T14:32:54+08:00">2023-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-03 16:31:18" itemprop="dateModified" datetime="2023-07-03T16:31:18+08:00">2023-07-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Linux的目录结构"><a href="#Linux的目录结构" class="headerlink" title="Linux的目录结构"></a>Linux的目录结构</h1><p>是一个树型结构<br>Windows系统可以拥有多个盘符,如C盘、D盘、E盘<br>Linux没有盘符这个概念,只有一个根目录&#x2F;，所有文件都在它下面</p>
<p>在Linux系统中，路径之间的层级关系，使用:&#x2F;来表示</p>
<p>在Windows系统中，路径之间的层级关系，使用:\来表示</p>
<p>D:\data\work\hello.txt<br>注意:<br>D:表示D盘 ,\表示层级关系</p>
<p>&#x2F;usr&#x2F;local&#x2F;hello.txt<br>注意:<br>开头的&#x2F;表示根目录,后面的&#x2F;表示层级关系</p>
<h2 id="ctrl-l清屏"><a href="#ctrl-l清屏" class="headerlink" title="ctrl+l清屏"></a>ctrl+l清屏</h2><h2 id="crtl-c中断"><a href="#crtl-c中断" class="headerlink" title="crtl+c中断"></a>crtl+c中断</h2><h2 id="crtl-d退出或登出"><a href="#crtl-d退出或登出" class="headerlink" title="crtl+d退出或登出"></a>crtl+d退出或登出</h2><ul>
<li>可以通过快捷键:ctrl + d,退出账户的登录</li>
<li>或者退出某些特定程序的专属页面，比如python</li>
</ul>
<h1 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h1><h2 id="Linux命令基础格式"><a href="#Linux命令基础格式" class="headerlink" title="Linux命令基础格式"></a>Linux命令基础格式</h2><p>无论是什么命令，用于什么用途，在Linux中，命令有其通用的格式:</p>
<p>command [-options] [parameter]</p>
<ul>
<li>command:命令本身</li>
<li>-options:[可选,非必填]命令的一些<strong>选项</strong>,可以通过选项控制命令的行为细节 </li>
<li>parameter: [可选，非必填]命令的<strong>参数</strong>，多数用于命令的指向目标等</li>
</ul>
<p>语法中的[]表示可选的意思</p>
<h3 id="ls命令的参数的作用"><a href="#ls命令的参数的作用" class="headerlink" title="ls命令的参数的作用"></a>ls命令的参数的作用</h3><ul>
<li>可以指定要查看的文件夹(目录)的内容,如果不给定参数,就查看当前工作目录的内容</li>
</ul>
<h4 id="ls命令的选项"><a href="#ls命令的选项" class="headerlink" title="ls命令的选项:"></a>ls命令的选项:</h4><ul>
<li>-a选项,可以展示出隐藏的内容</li>
<li>以.开头的文件或文件夹默认被隐藏，需要-a才能显示出来</li>
<li>-l选项,以列表的形式展示内容，并展示更多细节</li>
<li>-h选项,需要和-l选项搭配使用，以更加人性化的方式显示文件的大小单位</li>
</ul>
<h4 id="命令的选项组合使用"><a href="#命令的选项组合使用" class="headerlink" title="命令的选项组合使用"></a>命令的选项组合使用</h4><ul>
<li>命令的选项是可以组合使用的,比如: ls -lah,等同于ls -a -l -h</li>
</ul>
<h3 id="cd切换工作目录"><a href="#cd切换工作目录" class="headerlink" title="cd切换工作目录"></a>cd切换工作目录</h3><p>当Linux终端（命令行）打开的时候，会默认以用户的HOME目录作为当前的工作目录我们可以通过cd命令，更改当前所在的工作目录。<br>cd命令来自英文:Change Directory<br>语法: <code>cd [Linux路径]</code></p>
<ul>
<li>cd命令无需选项，只有参数，表示要切换到哪个目录下</li>
<li>cd命令直接执行，不写参数，表示回到用户的HOME目录</li>
</ul>
<h3 id="pwd查看当前工作目录"><a href="#pwd查看当前工作目录" class="headerlink" title="pwd查看当前工作目录"></a>pwd查看当前工作目录</h3><p>通过ls来验证当前的工作目录，其实是不恰当的。</p>
<p>我们可以通过pwd命令，来查看当前所在的工作目录。</p>
<p>pwd命令来自:Print Work Directory</p>
<p>语法:pwd</p>
<ul>
<li>pwd命令，无选项，无参数，直接输入pwd即可</li>
</ul>
<h3 id="特殊路径符"><a href="#特殊路径符" class="headerlink" title="特殊路径符:"></a>特殊路径符:</h3><ul>
<li>. 表示当前目录，比如cd .&#x2F;Desktop表示切换到当前目录下的Desktop目录内，和cd Desktop效果一致</li>
<li>.. 表示上一级目录，比如: cd .. 即可切换到上一级目录，cd ..&#x2F; ..切换到上二级的目录</li>
<li>~ 表示HOME目录，比如:cd~ 即可切换到HOME目录或cd ~&#x2F;Desktop,切换到HOME内的Desktop目录</li>
</ul>
<h3 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h3><p>通过mkdir命令可以创建新的目录（文件夹)</p>
<p>mkdir来自英文:Make Directory<br>语法:<code>mkdir [-p] Linux路径</code></p>
<ul>
<li>参数必填，表示Linux路径，即要创建的文件夹路径，相对路径或绝对路径均可</li>
<li>-p选项可选，表示自动创建不存在的父目录，适用于创建连续多层级的目录</li>
</ul>
<p>注意︰创建文件夹需要修改权限，请确保操作均在HOME目录内，不要在HOME外操作涉及到权限问题，HOME外无法成功</p>
<h3 id="touch创建文件"><a href="#touch创建文件" class="headerlink" title="touch创建文件"></a>touch创建文件</h3><p>可以通过touch命令创建文件</p>
<p>语法: <code>touch Linux路径</code></p>
<ul>
<li>touch命令无选项，参数必填，表示要创建的文件路径，相对、绝对、特殊路径符均可以使用</li>
</ul>
<h3 id="cat命令查看文件内容"><a href="#cat命令查看文件内容" class="headerlink" title="cat命令查看文件内容"></a>cat命令查看文件内容</h3><p>准备好文件内容后，可以通过cat查看内容。</p>
<p>语法:<code>cat Linux路径</code></p>
<ul>
<li><p>cat同样没有选项，只有必填参数，参数表示:被查看的文件路径，相对、绝对,</p>
<p>特殊路径符都可以使用</p>
</li>
</ul>
<h3 id="more命令查看文件内容"><a href="#more命令查看文件内容" class="headerlink" title="more命令查看文件内容"></a>more命令查看文件内容</h3><p>more命令同样可以查看文件内容，同cat不同的是:. </p>
<ul>
<li>cat是直接将内容全部显示出来</li>
<li>more支持翻页，如果文件内容过多，可以一页页的展示</li>
</ul>
<p>语法:<code>more Linux路径</code></p>
<ul>
<li>同样没有选项，只有必填参数，参数表示:被查看的文件路径，相对、绝对、特殊路径符都可以使用</li>
</ul>
<p>Linux系统内置有一个文件，路径为:&#x2F;etc&#x2F;services，可以使用more命令查看<br>more &#x2F;etc&#x2F;services</p>
<ul>
<li>在查看的过程中，通过空格翻页。</li>
<li>通过q退出查看</li>
</ul>
<h3 id="cp命令复制文件文件夹"><a href="#cp命令复制文件文件夹" class="headerlink" title="cp命令复制文件文件夹"></a>cp命令复制文件文件夹</h3><p>cp命令可以用于复制文件&#x2F;文件夹，cp命令来自英文单词: copy</p>
<p>语法: cp [-r] 参数1参数2</p>
<ul>
<li>-r选项，可选，用于复制文件夹使用，表示递归。</li>
<li>参数1,Linux路径，表示被复制的文件或文件夹。</li>
<li>参数2，Linux路径，表示要复制去的地方</li>
</ul>
<h3 id="mv移动文件或文件夹"><a href="#mv移动文件或文件夹" class="headerlink" title="mv移动文件或文件夹"></a>mv移动文件或文件夹</h3><p>mv命令可以用于移动文件\文件夹，mv命令来自英文单词:move</p>
<p>语法:<code>mv参数1参数2</code></p>
<ul>
<li>参数1,Linux路径，表示被移动的文件或文件夹</li>
<li>参数2，Linux路径，表示要移动去的地方，如果目标不存在，则进行改名，确保目标存在</li>
</ul>
<h3 id="rm删除文件、文件夹"><a href="#rm删除文件、文件夹" class="headerlink" title="rm删除文件、文件夹"></a>rm删除文件、文件夹</h3><p>rm命令可用于删除文件、文件夹</p>
<p>rm命令来自英文单词:remove</p>
<p>语法: <code>rm [-r -f] 参数1参数2 ......参数N</code></p>
<ul>
<li>同cp命令一样，-r选项用于删除文件夹</li>
<li>-f表示force，强制删除（不会弹出提示确认信息)<ul>
<li>普通用户删除内容不会弹出提示，只有root管理员用户删除内容会有提示</li>
<li>所以一般普通用户用不到-f选项</li>
</ul>
</li>
<li>参数1、参数2、…….、参数N表示要删除的文件或文件夹路径，按照空格隔开</li>
</ul>
<p>rm命令支持通配符 * ，用来做模糊匹配</p>
<ul>
<li><p>符号 * 表示通配符，即匹配任意内容（包含空)，示例:.</p>
</li>
<li><p>test*，表示匹配任何以test开头的内容</p>
</li>
<li><p>*test，表示匹配任何以test结尾的内容 </p>
</li>
<li><p>*test *，表示匹配任何包含test的内容</p>
</li>
<li><p>演示强制删除，-f选项</p>
</li>
<li><p>可以通过 su - root，并输入密码123456（和普通用户默认一样）临时切换到root用户体验</p>
</li>
<li><p>通过输入exit命令，退回普通用户,也可以回退到root用户。也可以使用ctrl+d</p>
</li>
</ul>
<h3 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h3><p>我们在前面学习的Linux命令，其实它们的本体就是一个个的二进制可执行程序。和Windows系统中的.exe文件，是一个意思。</p>
<p>我们可以通过which命令，查看所使用的一系列<strong>命令</strong>的程序文件存放在哪里</p>
<p>语法: <code>which 要查找的命令</code></p>
<h3 id="find命令–按文件名查找文件"><a href="#find命令–按文件名查找文件" class="headerlink" title="find命令–按文件名查找文件"></a>find命令–按文件名查找文件</h3><p>同样，在Linux系统中，我们可以通过find命令去搜索指定的文件。</p>
<p>语法:<code>find 起始路径 -name  &quot;被查找文件名&quot;</code></p>
<p>被查找文件名，支持使用通配符*来做模糊查询。</p>
<h3 id="find命令-按文件大小查找文件"><a href="#find命令-按文件大小查找文件" class="headerlink" title="find命令-按文件大小查找文件"></a>find命令-按文件大小查找文件</h3><p>语法: <code>find 起始路径 -size  +/-n[kMG]</code></p>
<ul>
<li>+、-表示大于和小于</li>
<li>n表示大小数字</li>
<li>kMG表示大小单位，k(小写字母)表示kb，M表示MB，G表示GB</li>
</ul>
<p>示例:</p>
<ul>
<li>查找小于10KB的文件: find  &#x2F; -size  -10k</li>
<li>查找大于100MB的文件: find &#x2F; -size +100M</li>
<li>查找大于1GB的文件: find &#x2F; -size +1G</li>
</ul>
<h3 id="grep命令-按文件大小查找文件内容"><a href="#grep命令-按文件大小查找文件内容" class="headerlink" title="grep命令-按文件大小查找文件内容"></a>grep命令-按文件大小查找文件内容</h3><p>可以通过grep命令，从文件中通过关键字过滤<strong>文件行</strong>。</p>
<p>ps aux | grep ‘cupsd’ – 检索进程结果集。 使用 grep 搜索进程，有一条结果是搜索进程本身</p>
<p><code>find … | xargs ls -l</code> 对 find 操作的结果集进行操作 </p>
<p>等价于 <code>find … -exec ls -l &#123;&#125; \；</code> 两者差别在于当结果集合很大的时候，xargs 会对结果进行分段处理，所以性能好些 </p>
<p>但 xargs 也有缺陷，xargs 默认用空格来分割结果集，当文件名有空格的时候，会因为文件名被切割 失效</p>
<p>-xargs：将 find 搜索的结果集执行某一指定命令。 当结果集数量过大时，可以分片映射。 <code>find /usr/ -name &#39;*tmp*&#39; | xargs ls -ld</code></p>
<p>解决 xargs 的缺陷，指定切分符号位 null </p>
<p>-print0： <code>find /usr/ -name &#39;*tmp*&#39; -print0 | xargs -print0 ls -l</code> 第一个 print0 指定结果集分隔为 null，第二个 print0 指定 xargs 分隔为 null</p>
<p>语法: <code>grep [-n] 关键字文件路径</code></p>
<ul>
<li>选项-n，可选，表示在结果中显示匹配的行的行号。</li>
<li>参数，关键字，必填，表示过滤的关键字，带有空格或其它特殊符号，建议使用” ”将关键字包围起来。</li>
<li>参数，文件路径，必填，表示要过滤内容的文件路径，可作为内容输入端口</li>
</ul>
<h3 id="wc命令做数量统计"><a href="#wc命令做数量统计" class="headerlink" title="wc命令做数量统计"></a>wc命令做数量统计</h3><p>可以通过wc命令统计文件的行数、单词数量等</p>
<p>语法: <code>wc [-c -m -l -w] 文件路径</code></p>
<ul>
<li>选项，-c，统计bytes数量。</li>
<li>选项，-m，统计字符数量</li>
<li>选项，-l，统计行数</li>
<li>选项，-w，统计单词数量</li>
<li>参数，文件路径，被统计的文件，可作为内容输入端口</li>
</ul>
<h3 id="管道符"><a href="#管道符" class="headerlink" title="管道符"></a>管道符</h3><p>管道符:l<br>管道符的含义是:将管道符左边命令的结果，作为右边命令的输入</p>
<ul>
<li>cat itheima.txt的输出结果（文件内容)。</li>
<li>作为右边grep命令的输入（被过滤文件)</li>
</ul>
<p><code>cat itheima.txt | grep itheima</code>还可以嵌套</p>
<h3 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h3><p>可以使用echo命令在命令行内输出指定内容</p>
<p>语法:<code>echo 输出的内容</code></p>
<ul>
<li><p>无需选项，只有一个参数，表示要输出的内容，复杂内容可以用” ”包围</p>
</li>
<li><p>带有空格或\等特殊符号，建议使用双引号包围</p>
</li>
<li><p>因为不包围的话，空格后很容易被识别为参数2，尽管echo不受影响，但是要养成习惯哦</p>
</li>
</ul>
<h3 id="反引号-96"><a href="#反引号-96" class="headerlink" title="反引号&#96;"></a>反引号&#96;</h3><p>本意是想，输出当前的工作路径，但是pwd被作为普通字符输出了。<br>我们可以通过将命令用反引号（通常也称之为飘号) &#96; 将其包围<br>被   飘号包围的内容，会被作为命令执行，而非普通字符</p>
<h3 id="重定向符"><a href="#重定向符" class="headerlink" title="重定向符"></a>重定向符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;,将左侧命令的结果，覆盖写入到符号右侧指定的文件中</span><br><span class="line">&gt;&gt;,将左侧命令的结果，追加写入到符号右侧指定的文件中</span><br></pre></td></tr></table></figure>

<h3 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h3><p>使用tail命令，可以查看文件尾部内容，跟踪文件的最新更改，</p>
<p>语法如下:<code>tail [-f -num ] Linux路径</code></p>
<ul>
<li>参数，Linux路径，表示被跟踪的文件路径。</li>
<li>选项，-f，表示持续跟踪</li>
<li>选项，-num，表示，查看尾部多少行，不填默认10行</li>
</ul>
<h3 id="vi-vim编辑器介绍"><a href="#vi-vim编辑器介绍" class="headerlink" title="vi\vim编辑器介绍"></a>vi\vim编辑器介绍</h3><p>vi\vim是visual interface的简称，是Linux中最经典的文本编辑器</p>
<p>同图形化界面中的文本编辑器一样，vi是命令行下对文本文件进行编辑的绝佳选择</p>
<p>vim是vi的加强版本，兼容vi的所有指令，不仅能编辑文本，而且还具有shell程序编辑的功能，可以不同颜色的字体来辨别语法的正确性，极大方便了程序的设计和编辑性。</p>
<h4 id="vi-vim编辑器的三种工作模式"><a href="#vi-vim编辑器的三种工作模式" class="headerlink" title="vi\vim编辑器的三种工作模式"></a>vi\vim编辑器的三种工作模式</h4><p>命令模式(Command mode)，最开始状态</p>
<ul>
<li>命令模式下，所敲的按键编辑器都理解为命令，以命令驱动执行不同的功能，此模型下，不能自由进行文本编辑。输入i o a进入输入模式，退出输入<strong>：wq</strong></li>
</ul>
<p>输入模式(lnsert mode)</p>
<ul>
<li>也就是所谓的编辑模式、插入模式。此模式下，可以对文件内容进行自由编辑。ESC键进入命令模式</li>
</ul>
<p>底线命令模式(Last line mode)</p>
<ul>
<li>以**:**开始，通常用于文件的保存、退出。命令以回车结束运行</li>
</ul>
<ol>
<li>如果文件路径表示的文件不存在，那么此命令会用于编辑新文件</li>
<li>如果文件路径表示的文件存在，那么此命令用于编辑已有文件</li>
</ol>
<table>
<thead>
<tr>
<th>模式</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>命令模式</td>
<td>i</td>
<td>在当前光标位置进入输入模式</td>
</tr>
<tr>
<td>命令模式</td>
<td>a</td>
<td>在当前光标位置之后进入输入模式</td>
</tr>
<tr>
<td>命令模式</td>
<td>I</td>
<td>在当前行的开头，进入输入模式</td>
</tr>
<tr>
<td>命令模式</td>
<td>A</td>
<td>在当前行的结尾，进入输入模式</td>
</tr>
<tr>
<td>命令模式</td>
<td>o</td>
<td>在当前光标下一行进入输入模式</td>
</tr>
<tr>
<td>命令模式</td>
<td>O</td>
<td>在当前光标上一行进入输入模式</td>
</tr>
<tr>
<td>输入模式</td>
<td>esc</td>
<td>任何情况下输入esc都能回到命令模式</td>
</tr>
<tr>
<td>命令模式</td>
<td>0</td>
<td>移动光标到当前行的开头</td>
</tr>
<tr>
<td>命令模式</td>
<td>$</td>
<td>移动光标到当前行的结尾</td>
</tr>
<tr>
<td>命令模式</td>
<td>pageup( Pgup)</td>
<td>向上翻页</td>
</tr>
<tr>
<td>命令模式</td>
<td>pangdown( PgDn)</td>
<td>向下翻页</td>
</tr>
<tr>
<td>命令模式</td>
<td>&#x2F;</td>
<td>进入搜索模式</td>
</tr>
<tr>
<td>命令模式</td>
<td>n</td>
<td>向下继续搜索</td>
</tr>
<tr>
<td>命令模式</td>
<td>N</td>
<td>向上继续搜索</td>
</tr>
<tr>
<td>命令模式</td>
<td>dd</td>
<td>删除光标所在行的内容</td>
</tr>
<tr>
<td>命令模式</td>
<td>ndd</td>
<td>n是数字，表示删除当前光标向下n行</td>
</tr>
<tr>
<td>命令模式</td>
<td>yy</td>
<td>复制当前行</td>
</tr>
<tr>
<td>命令模式</td>
<td>nyy</td>
<td>n是数字，复制当前行和下面的n行</td>
</tr>
<tr>
<td>命令模式</td>
<td>p</td>
<td>粘贴复制的内容</td>
</tr>
<tr>
<td>命令模式</td>
<td>u</td>
<td>撤销修改</td>
</tr>
<tr>
<td>命令模式</td>
<td>crtl+r</td>
<td>反向撤销修改</td>
</tr>
<tr>
<td>命令模式</td>
<td>gg</td>
<td>跳到首行</td>
</tr>
<tr>
<td>命令模式</td>
<td>G</td>
<td>跳到行尾</td>
</tr>
<tr>
<td>命令模式</td>
<td>dG</td>
<td>从当前行开始，向下全部删除</td>
</tr>
<tr>
<td>命令模式</td>
<td>dgg</td>
<td>从当前行开始，向上全部删除</td>
</tr>
<tr>
<td>命令模式</td>
<td>d$</td>
<td>从当前光标开始，删除到本行的结尾</td>
</tr>
<tr>
<td>命令模式</td>
<td>d0</td>
<td>从当前光标开始，删除到本行的开头</td>
</tr>
<tr>
<td>底线命令模式</td>
<td>:wq</td>
<td>保存并退出</td>
</tr>
<tr>
<td>底线命令模式</td>
<td>:q</td>
<td>仅退出</td>
</tr>
<tr>
<td>底线命令模式</td>
<td>:q!</td>
<td>强制退出</td>
</tr>
<tr>
<td>底线命令模式</td>
<td>:w</td>
<td>仅保存</td>
</tr>
<tr>
<td>底线命令模式</td>
<td>:set nu</td>
<td>显示行号</td>
</tr>
<tr>
<td>底线命令模式</td>
<td>:set paste</td>
<td>设置粘贴模式,主要是为了保证外部复制不会格式错乱</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>分屏，末行模式下 </p>
<ul>
<li>:sp 水平分屏</li>
<li>:vsp 竖直分屏 </li>
<li>分屏命令+filename，分屏并打开这个文件 </li>
<li>分屏后屏幕切换，Ctrl-w-w </li>
<li>使用:q 退出光标所在窗口 </li>
<li>使用:qall 退出所有窗口</li>
</ul>
<p>从 vim 中跳转 manpage，命令模式下 </p>
<p>将光标放在待查看单词上，按 K，默认看第一卷 n+K，查看第 n 卷 </p>
<p>查看宏定义：命令模式 </p>
<p>光标放在待查看词上，[+d 即可查看</p>
<p>vim 下使用 shell 命令：末行模式 :! + 命令 操作后，会切换至终端显示结果，按 Enter 后回到 vim 界面</p>
<h3 id="vim下自动排版命令"><a href="#vim下自动排版命令" class="headerlink" title="vim下自动排版命令"></a>vim下自动排版命令</h3><p>在命令行模式下：</p>
<p>1、使用“gg”将光标移动到文档开头</p>
<p>2、使用“v”切换到可视模式</p>
<p>3、再用“G”将光标移动到文档尾部（相当于全选）</p>
<p>4、最后使用“&#x3D;”，即可完成整个文档的自动排版。</p>
<h3 id="sudo命令"><a href="#sudo命令" class="headerlink" title="sudo命令"></a>sudo命令</h3><p>Su命令</p>
<ul>
<li>可以切换用户，语法:<code>su [-] [用户名]</code></li>
<li>-表示切换后加载环境变量,建议带上</li>
<li>用户可以省略,省略默认切换到root</li>
</ul>
<p>在我们得知root密码的时候，可以通过su命令切换到root得到最大权限。但是我们不建议长期使用root用户，避免带来系统损坏。</p>
<p>我们可以使用sudo命令，为普通的命令授权,临时以root身份执行。</p>
<p>语法:<code>sudo 其它命令</code></p>
<ul>
<li>在其它命令之前，带上sudo,即可为这一条命令临时赋予root授权</li>
<li>但是并不是所有的用户，都有权利使用sudo，我们需要为普通用户配置sudo认证</li>
</ul>
<h4 id="为普通用户配置sudo认证"><a href="#为普通用户配置sudo认证" class="headerlink" title="为普通用户配置sudo认证"></a>为普通用户配置sudo认证</h4><ul>
<li>切换到root用户,执行visudo命令，会自动通过vi编辑器打开:&#x2F;etc&#x2F;sudoers。</li>
<li>在文件的最后添加:<br><code>itheima ALL=(ALL)		NOPASSWD: ALL</code><br>其中最后的NOPASSWD:ALL表示使用sudo命令，无需输入密码，itheima是用户名</li>
<li>最后通过wq保存</li>
<li>切换回普通用户<br><code>[itheima@localhost ~]$ sudo ls /root</code></li>
<li><code>anaconda-ks.cfg	original-ks.cfg</code></li>
<li><code>[itheima@localhost ~]$ sudo mkdir /test</code></li>
<li><code>[itheima@localhost ~]$</code></li>
<li>执行的命令，均以root运行</li>
</ul>
<h2 id="用户、用户组"><a href="#用户、用户组" class="headerlink" title="用户、用户组"></a>用户、用户组</h2><p>Linux系统中可以:</p>
<ul>
<li>配置多个用户</li>
<li>配置多个用户组</li>
<li>用户可以加入多个用户组中</li>
</ul>
<h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>以下命令需root用户执行。</p>
<ul>
<li><p>创建用户</p>
<p>​	useradd [-g -d]用户名<br>​		选项: -g指定用户的组，不指定-g，会创建同名组并自动加入，指定-g需要组已经存在，如已存在同名组，必须使用-g</p>
<p>​		选项:-d指定用户HOME路径，不指定，HOME目录默认在:&#x2F;home&#x2F;用户名</p>
</li>
<li><p>删除用户</p>
<ul>
<li>​	userdel [-r]用户名<br>​		选项:-r，删除用户的HOME目录，不使用-r，删除用户时，HOME目录保留</li>
</ul>
</li>
<li><p>查看用户所属组</p>
<ul>
<li><p>id[用户名]</p>
<p>​	参数:用户名，被查看的用户，如果不提供则查看自身。</p>
</li>
</ul>
</li>
<li><p>修改用户所属组</p>
<ul>
<li>usermod -aG 用户组 用户名，将指定用户加入指定用户组，一个用户可以在多个用户组。</li>
</ul>
</li>
</ul>
<h3 id="getent"><a href="#getent" class="headerlink" title="getent"></a>getent</h3><p>使用getent命令，可以查看当前系统中有哪些用户</p>
<p>语法: getent passwd</p>
<p>共有7份信息，分别是:<br>用户名:密码(x):用户ID:组ID:描述信息(无用):HOME目录:执行终端(默认bash)</p>
<p>使用getent命令,同样可以查看当前系统中有哪些用户组</p>
<p>语法:getent group</p>
<p>包含3份信息,组名称:组认证(显示为x):组ID</p>
<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>ls -l后</p>
<p>drwxr-xr-x 2 xiaohuilin xiaohuilin 4096 9月  12  2021 公共的</p>
<p>举例: d rwx r-x r-x，表示:</p>
<ul>
<li>这是一个文件夹，首字母d表示( -表示文件 d表示文件夹 I表示软链接)</li>
<li>所属用户（第一个xiaohuilin）对d的权限是:有r有w有x, rwx</li>
<li>所属用户组（第二个xiaohuilin）的权限是:有r无w有x, r-x( -表示无此权限)</li>
<li>其它用户的权限是：有r无w有x,r-x</li>
</ul>
<p>rwx代表什么</p>
<p>r表示读权限</p>
<p>w表示写权限</p>
<p>x表示执行权限</p>
<p>针对文件、文件夹的不同，rwx的含义有细微差别</p>
<ul>
<li>r ,针对文件可以查看文件内容<ul>
<li>针对文件夹，可以查看文件夹内容，如ls命令</li>
</ul>
</li>
<li>w，针对文件表示可以修改此文件<ul>
<li>针对文件夹，可以在文件夹内:创建、删除、改名等操作</li>
</ul>
</li>
<li>x,针对文件表示可以将文件作为程序执行<ul>
<li>针对文件夹，表示可以更改工作目录到此文件夹，即cd进入</li>
</ul>
</li>
</ul>
<h2 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h2><p>我们可以使用chmod命令，修改文件、文件夹的权限信息。</p>
<p>注意，只有文件、文件夹的所属用户或root用户可以修改。</p>
<p>语法: <code>chmod [-R] 权限 文件或文件夹</code></p>
<ul>
<li>选项:-R，对文件夹内的全部内容应用同样的操作</li>
</ul>
<p>示例:</p>
<ul>
<li>chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;x hello.txt，将文件权限修改为:rwxr-x–x<ul>
<li>其中:u表示user所属用户权限, g表示group组权限,o表示other其它用户权限</li>
</ul>
</li>
<li>chmod -R u&#x3D;rwx,g&#x3D;rx,0&#x3D;x test,将文件夹test以及文件夹内全部内容权限设置为:rwxr-x–x</li>
</ul>
<p>除此之外，还有快捷写法: chmod 751 hello.txt<br>将hello.txt的权限修改为751,r记为4, w记为2,x记为1</p>
<h2 id="chown命令"><a href="#chown命令" class="headerlink" title="chown命令"></a>chown命令</h2><p>使用chown命令，可以修改文件、文件夹的所属用户和用户组<br>普通用户无法修改所属为其它用户或组，所以此命令只适用于root用户执行</p>
<p>语法: <code>chown[-R] [用户][:][用户组] 文件或文件夹</code></p>
<ul>
<li>选项，-R，同chmod,对文件夹内全部内容应用相同规则</li>
<li>选项，用户，修改所属用户</li>
<li>选项，用户组,修改所属用户组</li>
<li>:用于分隔用户和用户组</li>
</ul>
<p>示例:</p>
<ul>
<li>chown root hello.txt,将hello.txt所属用户修改为root</li>
<li>chown :root hello.txt,将hello.txt所属用户组修改为root</li>
<li>chown root:itheima hello.txt,将hello.txt所属用户修改为root,用户组修改为itheima</li>
<li>chown -R root test,将文件夹test的所属用户修改为root并对文件夹内全部内容应用同样规则</li>
</ul>
<h2 id="历史命令搜索"><a href="#历史命令搜索" class="headerlink" title="历史命令搜索"></a>历史命令搜索</h2><p><code>history</code></p>
<ul>
<li>可以通过:!命令前缀，自动执行上次匹配前缀的命令</li>
<li>可以通过快捷键:ctrl + r,输入内容去匹配历史命令</li>
</ul>
<p>如果搜索到的内容是你需要的，那么∶</p>
<ul>
<li>回车键可以直接执行</li>
<li>键盘左右键，可以得到此命令（不执行)</li>
</ul>
<h2 id="光标移动快捷键"><a href="#光标移动快捷键" class="headerlink" title="光标移动快捷键"></a>光标移动快捷键</h2><ul>
<li>ctrl+ a,跳到命令开头</li>
<li>ctrl+e,跳到命令结尾</li>
<li>ctrl＋键盘左键,向左跳一个单词</li>
<li>ctrl＋键盘右键,向右跳一个单词</li>
</ul>
<h2 id="清屏"><a href="#清屏" class="headerlink" title="清屏"></a>清屏</h2><ul>
<li><p>通过快捷键ctrl+l，可以清空终端内容</p>
</li>
<li><p>或通过命令clear得到同样效果</p>
</li>
</ul>
<h2 id="systemctl命令"><a href="#systemctl命令" class="headerlink" title="systemctl命令"></a>systemctl命令</h2><p>Linux系统很多软件(内置或第三方)均支持使用systemctl命令控制:启动、停止、开机自启</p>
<p>能够被systemctl管理的软件，一般也称之为:服务</p>
<p>语法: <code>systemctl start | stop | status | enable | disable 服务名</code></p>
<ul>
<li><p>start启动</p>
</li>
<li><p>stop关闭</p>
</li>
<li><p>status查看状态</p>
</li>
<li><p>enable开启开机自启</p>
</li>
<li><p>disable关闭开机自启</p>
</li>
</ul>
<p>系统内置的服务比较多，比如:</p>
<ul>
<li><p>NetworkManager,主网络服务</p>
</li>
<li><p>network,副网络服务</p>
</li>
<li><p>firewalld，防火墙服务</p>
</li>
<li><p>sshd, ssh服务(FinalShell远程登录Linux使用的就是这个服务)</p>
</li>
</ul>
<h2 id="ln命令创建软连接"><a href="#ln命令创建软连接" class="headerlink" title="ln命令创建软连接"></a>ln命令创建软连接</h2><p>在系统中创建软链接,可以将文件、文件夹链接到其它位置。</p>
<p>类似windows系统中的《快捷方式》</p>
<p>语法: <code>ln -s 参数1参数2</code></p>
<ul>
<li>-s选项,创建软连接</li>
<li>参数1:被链接的文件或文件夹</li>
<li>参数2:要链接去的目的地</li>
</ul>
<p>实例:</p>
<ul>
<li>ln -s &#x2F;etc&#x2F;yum.conf ~&#x2F;yum.conf</li>
<li>ln -s &#x2F;etc&#x2F;yum ~&#x2F;yum</li>
</ul>
<h2 id="date命令"><a href="#date命令" class="headerlink" title="date命令"></a>date命令</h2><p>通过date命令可以在命令行中查看系统的时间</p>
<p>语法: <code>date [-d][+格式化字符串]</code></p>
<ul>
<li><p>-d按照给定的字符串显示日期，一般用于日期计算</p>
</li>
<li><p>格式化字符串:通过特定的字符串标记,来控制显示的日期格式</p>
<ul>
<li><p>%Y	年</p>
</li>
<li><p>%y	年份后两位数字(00..99)</p>
</li>
<li><p>%m	月份(01..12)</p>
</li>
<li><p>%d	日(01..31)</p>
</li>
<li><p>%H	小时(00..23)</p>
</li>
<li><p>%M	分钟(00..59)</p>
</li>
<li><p>%S	秒(00..60)</p>
</li>
<li><p>%s	自1970-01-01	00::00::00 UTC到现在的秒数</p>
</li>
</ul>
</li>
</ul>
<h2 id="特殊IP地址"><a href="#特殊IP地址" class="headerlink" title="特殊IP地址"></a>特殊IP地址</h2><ul>
<li>127.0.0.1，这个IP地址用于指代本机</li>
<li>0.0.0.0,特殊lP地址<ul>
<li>可以用于指代本机</li>
<li>可以在端口绑定中用来确定绑定关系（后续讲解)</li>
<li>在一些IP地址限制中，表示所有IP的意思,如放行规则设置为0.0.0.0,表示允许任意IP访问</li>
</ul>
</li>
</ul>
<h2 id="在Linux中修改主机名"><a href="#在Linux中修改主机名" class="headerlink" title="在Linux中修改主机名"></a>在Linux中修改主机名</h2><ul>
<li>可以使用命令:hostname查看主机名</li>
<li>可以使用命令: hostnamectl set-hostname主机名,修改主机名（需root)</li>
</ul>
<p>什么是域名解析（主机名映射)</p>
<ul>
<li>可以通过主机名找到对应计算机的IP地址,这就是主机名映射（域名解析)</li>
<li>先通过系统本地的记录去查找，如果找不到就联网去公开DNS服务器去查找</li>
</ul>
<h2 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h2><p>可以通过ping命令,检查指定的网络服务器是否是可联通状态</p>
<p>语法: <code>ping [-c num] ip或主机名</code></p>
<ul>
<li>选项:-c，检查的次数，不使用-c选项,将无限次数持续检查</li>
<li>参数: ip或主机名，被检查的服务器的ip地址或主机名地址</li>
</ul>
<h2 id="wget命令"><a href="#wget命令" class="headerlink" title="wget命令"></a>wget命令</h2><p>wget是非交互式的文件下载器,可以在命令行内下载网络文件</p>
<p>语法: <code>wget [-b] url</code></p>
<ul>
<li>选项: -b，可选，后台下载,会将日志写入到当前工作目录的wget-log文件</li>
<li>参数: url，下载链接</li>
</ul>
<h2 id="curl命令"><a href="#curl命令" class="headerlink" title="curl命令"></a>curl命令</h2><p>curl可以发送http网络请求,可用于:下载文件、获取信息等</p>
<p>语法: <code>curl [-O] url</code></p>
<ul>
<li>选项:-O，用于下载文件，当url是下载链接时,可以使用此选项保存文件</li>
<li>参数: url，要发起请求的网络地址</li>
</ul>
<h2 id="使用top命令可以"><a href="#使用top命令可以" class="headerlink" title="使用top命令可以:"></a>使用top命令可以:</h2><p>类似Windows任务售理器·查看CPU、内存、进程的信息</p>
<h2 id="使用df命令可以"><a href="#使用df命令可以" class="headerlink" title="使用df命令可以:"></a>使用df命令可以:</h2><p>查看磁盘使用率</p>
<h2 id="使用iostat可以"><a href="#使用iostat可以" class="headerlink" title="使用iostat可以:"></a>使用iostat可以:</h2><p>查看磁盘速率等信息</p>
<h2 id="使用sar-n-DEV命令可以"><a href="#使用sar-n-DEV命令可以" class="headerlink" title="使用sar -n DEV命令可以:"></a>使用sar -n DEV命令可以:</h2><p>查看网络情况</p>
<h2 id="什么是环境变量"><a href="#什么是环境变量" class="headerlink" title="什么是环境变量"></a>什么是环境变量</h2><p>环境变量是一组信息记录,类型是KeyValue型(名称&#x3D;值)，用于操作系统运行的时候记录关键信息</p>
<h2 id="通过env命令可以查看当前系统配置的环境变量信息"><a href="#通过env命令可以查看当前系统配置的环境变量信息" class="headerlink" title="通过env命令可以查看当前系统配置的环境变量信息"></a>通过env命令可以查看当前系统配置的环境变量信息</h2><h2 id="通过-符号，可以取出环境变量的值"><a href="#通过-符号，可以取出环境变量的值" class="headerlink" title="通过$符号，可以取出环境变量的值"></a>通过$符号，可以取出环境变量的值</h2><h2 id="什么是PATH，作用是"><a href="#什么是PATH，作用是" class="headerlink" title="什么是PATH，作用是"></a>什么是PATH，作用是</h2><p>环境变量PATH会记录一组目录，目录之间用**:**隔开。这里记录的是命令的搜索路径，当执行命令会从记录中记录的目录中挨个搜索要执行的命令并执行。<br>可以通过修改这个项目的值,加入自定义的命令搜索路径<br>如<code>export PATH=$PATH:自定义路径</code></p>
<h2 id="如何修改环境变量"><a href="#如何修改环境变量" class="headerlink" title="如何修改环境变量"></a>如何修改环境变量</h2><ul>
<li>临时生效: export名称&#x3D;值</li>
<li>永久生效:<ul>
<li>针对用户:~&#x2F;bashrc文件中配置</li>
<li>针对全部用户:&#x2F;etc&#x2F;profile文件中配置。</li>
<li>配置完成，可以通过source命令立刻生效</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/16/c%E5%92%8Cc++/%E5%85%B3%E4%BA%8Evscode%E5%A6%82%E4%BD%95%E5%AF%B9%E5%A4%9A%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/16/c%E5%92%8Cc++/%E5%85%B3%E4%BA%8Evscode%E5%A6%82%E4%BD%95%E5%AF%B9%E5%A4%9A%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/" class="post-title-link" itemprop="url">关于vscode如何对多文件进行调试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-16 16:48:07" itemprop="dateCreated datePublished" datetime="2023-04-16T16:48:07+08:00">2023-04-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-08 15:24:15" itemprop="dateModified" datetime="2023-07-08T15:24:15+08:00">2023-07-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Vscode默认配置文件只能编译单cpp文件。若是需要多文件编译或者需要分别设置Include头文件夹、Source资源文件夹，则需要修改配置三个.json文件(tasks.json、launch.json、c_cpp_properties.json )</p>
<p>注：个人习惯将.h头文件放到Include目录、.c.cpp源文件放到Source文件夹下面，输出文件.exe文件放到out文件夹下面</p>
<ul>
<li>.vscode文件夹存放.json文件夹，实际使用中可以直接拷贝过来使用，而没必要每次都新建修改一遍</li>
<li>c_cpp_properties.json配置文件默认是不会产生的，快捷键ctrl+shift+p 再输入configuration便会出现</li>
<li>默认工作空间只有.vscode文件夹，.cpp文件直接放在工作空间根目录的。示例中include、source以及out文件夹可以利用Create C++ project创建工程模板才能在.json中修改配置</li>
</ul>
<h2 id="tasks-json文件"><a href="#tasks-json文件" class="headerlink" title="tasks.json文件"></a>tasks.json文件</h2><p>需要修改的地方主要有三处，可直接复制使用</p>
<ul>
<li>修改 -g后面的目录</li>
<li>修改-o后面的目录</li>
<li>添加 -I 及后面的目录</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;tasks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;,        //任务执行的是shell命令</span><br><span class="line">            &quot;label&quot;: &quot;C/C++: g++.exe build active file&quot;,   	//和launch.josn 中的 preLaunchTask 必须一样</span><br><span class="line">            &quot;command&quot;: &quot;C:\\c\\software\\mingw64\\bin\\g++.exe&quot;,  //命令是g++，也可以直接写g++</span><br><span class="line">            &quot;args&quot;: [  </span><br><span class="line">                &quot;-g&quot;,    //生成和调试有关的信息</span><br><span class="line">                &quot;-Wall&quot;, // 开启额外警告 </span><br><span class="line">				&quot;$&#123;workspaceFolder&#125;\\src\\*.cpp&quot;,  //当前工作空间下文件夹source目录名下的所有cpp文件。 source对应工程目录下的source文件夹名字，可自行修改   </span><br><span class="line">                &quot;-I&quot;,&quot;$&#123;workspaceFolder&#125;\\include&quot;,      // 参数-I 和工程路径 指明了项目中要引用的非标准头文件的位置。 include对应工程目录下的include文件夹名字，可自行修改                   </span><br><span class="line">                &quot;-o&quot;,                      </span><br><span class="line">                &quot;$&#123;workspaceFolder&#125;\\bulid\\$&#123;fileBasenameNoExtension&#125;.exe&quot;, //指定输出的文件名为out，默认a.exe。out对应工程目录下的out文件夹名字，可自行修改 </span><br><span class="line">                &quot;-std=c++17&quot;,                                      //使用c++17标准编译</span><br><span class="line">                &quot;-finput-charset=UTF-8&quot;,                           //输入编译器默认文本编码 默认为utf-8</span><br><span class="line">                &quot;-fexec-charset=GB18030&quot;,                          //输出exe文件编码 </span><br><span class="line">            ],</span><br><span class="line">            &quot;options&quot;: &#123;</span><br><span class="line">                &quot;cwd&quot;: &quot;C:\\c\\software\\mingw64\\bin&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;problemMatcher&quot;: [</span><br><span class="line">                &quot;$gcc&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;group&quot;: &#123;</span><br><span class="line">                &quot;kind&quot;: &quot;build&quot;,</span><br><span class="line">                &quot;isDefault&quot;: true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;version&quot;: &quot;2.0.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="launch-json文件"><a href="#launch-json文件" class="headerlink" title="launch.json文件"></a>launch.json文件</h2><p>需要修改的地方有以下：</p>
<ol>
<li>“program”目录</li>
<li>“cwd”</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;g++.exe &quot;,  // 该调试任务的名字，启动调试时会在待选列表中显示</span><br><span class="line">            &quot;type&quot;: &quot;cppdbg&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;\\build\\$&#123;fileBasenameNoExtension&#125;.exe&quot;,  //需要运行/调试的是当前打开文件的目录中，名字和当前文件相同，但扩展名为exe的程序。和tasks.json中-o后面的目录一样的</span><br><span class="line">            &quot;args&quot;: [],</span><br><span class="line">            &quot;stopAtEntry&quot;: false,  // 这一项控制是否在入口处暂停，默认false不暂停，改为true暂停</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;\\build&quot;, //调试程序时的工作目录 。out对应工程目录下的out文件夹</span><br><span class="line">            &quot;environment&quot;: [],</span><br><span class="line">            &quot;externalConsole&quot;: false,  // 这一项控制是否启动外部控制台（独立的黑框）运行程序，默认false表示在集成终端中运行</span><br><span class="line">            &quot;MIMode&quot;: &quot;gdb&quot;,</span><br><span class="line">            &quot;miDebuggerPath&quot;: &quot;C:\\c\\software\\mingw64\\bin\\gdb.exe&quot;,  // 调试器路径，必须与你自己的电脑相符</span><br><span class="line">            &quot;setupCommands&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;,</span><br><span class="line">                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,</span><br><span class="line">                    &quot;ignoreFailures&quot;: true</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;preLaunchTask&quot;: &quot;g++.exe build active file&quot;  // 调试会话开始前执行的任务，一般为编译程序，c++为g++, c为gcc 这个名字一定要跟tasks.json中的任务名字大小写一致</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="c-cpp-properties-json"><a href="#c-cpp-properties-json" class="headerlink" title="c_cpp_properties.json"></a>c_cpp_properties.json</h2><p>默认不会产生。快捷键ctrl+shift+p 再输入configuration便会出现。<br>修改的地方只有一处：</p>
<p>“includePath” 将include文件夹添加进去即可，注意格式！！<br>注：“compilerPath” 同launch.json。为编译器文件目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Win32&quot;,</span><br><span class="line">            &quot;includePath&quot;: [</span><br><span class="line">                &quot;$&#123;workspaceFolder&#125;/**&quot;,</span><br><span class="line">                &quot;$&#123;workspaceFolder&#125;\\include\\**&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;defines&quot;: [</span><br><span class="line">                &quot;_DEBUG&quot;,</span><br><span class="line">                &quot;UNICODE&quot;,</span><br><span class="line">                &quot;_UNICODE&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;cStandard&quot;: &quot;c17&quot;,</span><br><span class="line">            &quot;cppStandard&quot;: &quot;c++17&quot;,</span><br><span class="line">            &quot;compilerPath&quot;: &quot;C:\\c\\software\\mingw64\\bin\\gdb.exe&quot;,</span><br><span class="line">            &quot;intelliSenseMode&quot;: &quot;windows-gcc-x64&quot;,</span><br><span class="line">            &quot;configurationProvider&quot;: &quot;ms-vscode.makefile-tools&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;version&quot;: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结</p>
<ul>
<li>这三个配置文件可以各拷贝一份，新建工程时，直接放.vscode下面。软件在打开时会直接读取.json文件。</li>
<li>.vscode通常就是放配置文件的，除这三个常用的之外还有settings.json，用来配置编辑器等外观性质的东西。</li>
<li>VSCode下c++多文件夹项目编译调试还可以用makefile、cmake等工具实现，适用于大型项目文件时使用</li>
</ul>
<p><img src="/2023/04/16/c%E5%92%8Cc++/%E5%85%B3%E4%BA%8Evscode%E5%A6%82%E4%BD%95%E5%AF%B9%E5%A4%9A%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/Users\86191\OneDrive\图片\屏幕快照\2023-04-16.png" alt="2023-04-16"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/13/c%E5%92%8Cc++/c-%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/13/c%E5%92%8Cc++/c-%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">c++ 函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-13 16:38:09" itemprop="dateCreated datePublished" datetime="2023-04-13T16:38:09+08:00">2023-04-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-29 15:00:00" itemprop="dateModified" datetime="2023-05-29T15:00:00+08:00">2023-05-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><h3 id="指针或引用形参与const"><a href="#指针或引用形参与const" class="headerlink" title="指针或引用形参与const"></a>指针或引用形参与const</h3><p>形参的初始化方式和变量的初始化方式是一样的,所以回顾通用的初始化规则有助于理解本节知识。我们可以使用非常量初始化一个底层const对象，但是反过来不行;同时一个普通的引用必须用同类型的对象初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int i = 42;</span><br><span class="line">const int *cp = &amp;i;//正确:但是cp不能改变i</span><br><span class="line">const int &amp;r = i;//正确:但是r不能改变i</span><br><span class="line">const int &amp;r2 = 42;//正确:</span><br><span class="line">int *p=cp;//错误:p的类型和cp的类型不匹配</span><br><span class="line">int &amp;r3 = r;//错误:r3的类型和r的类型不匹配</span><br><span class="line">int &amp;r4=42;//错误:不能用字面值初始化一个非常量引用</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;arr两端的括号必不可少</span><br><span class="line">	f(int &amp;arr[10])//错误:将arr声明成了引用的数组</span><br><span class="line">	f(int (&amp;arr)[10])//正确:arr是具有10个整数的整型数组的引用</span><br></pre></td></tr></table></figure>

<h3 id="main-处理命令行选项"><a href="#main-处理命令行选项" class="headerlink" title="main:处理命令行选项"></a>main:处理命令行选项</h3><p>main函数是演示C++程序如何向函数传递数组的好例子。到目前为止，我们定义的main函数都只有空形参列表:<br>int main()[ …}</p>
<p>然而，有时我们确实需要给main传递实参，一种常见的情况是用户通过设置一组选项来确定函数所要执行的操作。例如，假定 main函数位于可执行文件prog之内，我们可以向程序传递下面的选项:<br><code>prog -d -o ofile data0</code><br>这些命令行选项通过两个（可选的）形参传递给main函数:</p>
<p>int main(int argc,char  * argv[]){…}<br>第二个形参argv是一个数组，它的元素是指向C风格字符串的指针:第一个形参arge表示数组中字符串的数量。因为第二个形参是数组，所以main函数也可以定义成:<br>int main(int arge,char  * * argv) { …}<br>其中argv指向char*。</p>
<p>当实参传给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。<br>以上面提供的<strong>命令行</strong>为例，argc应该等于5，argv应该包含如下的C风格字符串:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">argv[0] = &quot;prog&quot; ;//或者argv [0]也可以指向一个空字符串</span><br><span class="line">argv[1] = &quot;-d&quot;;</span><br><span class="line">argv[2] = &quot;-o&quot; ;</span><br><span class="line">argv[3] = &quot;ofile&quot; ;</span><br><span class="line">argv[4]= &quot;data0&quot;;</span><br><span class="line">argv [5] = 0;</span><br></pre></td></tr></table></figure>

<p>当使用argv中的实参时,一定要记得可选的实参从argv[1]开始; </p>
<p>argv[0]保存程序的名字，而非用户输入。</p>
<h3 id="含有可变形参的函数"><a href="#含有可变形参的函数" class="headerlink" title="含有可变形参的函数"></a>含有可变形参的函数</h3><p>为了编写能处理不同数量实参的函数，C++11新标准提供了两种主要的方法:如果所有的实参类型相同,可以传递一个名为initializer_list的标准库类型;如果实参的类型不同，我们可以编写一种特殊的函数，也就是所谓的可变参数模板</p>
<p>和vector一样，initializer_list也是一种模板类型(参见3.3节,第86页)。定义initializer_list对象时，必须说明列表中所含元素的类型:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">initializer_list&lt;string&gt; ls;// initializer_list的元素类型是stringinitializer_list&lt;int&gt; li;// initializer_list的元素类型是int</span><br></pre></td></tr></table></figure>

<p>和 vector不一样的是，initializer_list对象中的元素永远是常量值，我们无法改变initializer_list对象中元素的值。</p>
<p>编写一个函数，它的参数是initializer_list类型的对象，函数的功能是计算列表中所有元素的和。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;initializer_list&gt;</span><br><span class="line"></span><br><span class="line">int counter_int(std::initializer_list&lt;int&gt; il)</span><br><span class="line">&#123;</span><br><span class="line">	int cnt_i = 0;</span><br><span class="line">	for(auto e : il)</span><br><span class="line">		cnt_i += e;</span><br><span class="line">	return cnt_i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; counter_int(&#123;1,2,3,4,5&#125;) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="省略符形参"><a href="#省略符形参" class="headerlink" title="省略符形参"></a>省略符形参</h3><p>省略符形参是为了便于C++程序访问某些特殊的C代码而设置的,这些代码使用了名为varargs的C标准库功能。通常，省略符形参不应用于其他目的。你的C编译器文档会描述如何使用varargs。</p>
<p>省略符形参应该仅仅用于C和C++通用的类型。特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。</p>
<p>省略符形参只能出现在形参列表的最后一个位置，它的形式无外乎以下两种:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void foo (parm_list, ...);</span><br><span class="line">void foo(.. .);</span><br></pre></td></tr></table></figure>

<p>第一种形式指定了 foo函数的部分形参的类型，对应于这些形参的实参将会执行正常的类型检查。<strong>省略符形参所对应的实参无须类型检查</strong>。在第一种形式中，形参声明后面的逗号是可选的。</p>
<h3 id="引用返回左值"><a href="#引用返回左值" class="headerlink" title="引用返回左值"></a>引用返回左值</h3><p>函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值，其他返回类型得到右值。可以像使用其他左值那样来使用返回引用的函数的调用，特别是，我们能为返回类型是非常量引用的函数的结果赋值:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">char &amp;get_val(string &amp;str, string::size_type ix)</span><br><span class="line">&#123;</span><br><span class="line">	return str[ix];//get_val假定索引值是有效的</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	string s( &quot;a value&quot;);</span><br><span class="line">	cout &lt;&lt;s&lt; endl;//输出a value</span><br><span class="line">	get_val(s,0）=&#x27;A&#x27;;//将s[0]的值改为A</span><br><span class="line">	cout c&lt;s&lt;c endl ;//输出A value</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把函数调用放在赋值语句的左侧可能看起来有点奇怪，但其实这没什么特别的。返回值是引用，因此调用是个左值，和其他左值一样它也能出现在赋值运算符的左侧。</p>
<p>如果返回类型是常量引用，我们不能给调用的结果赋值，这一点和我们熟悉的情况是一样的。</p>
<h3 id="列表初始化返回值"><a href="#列表初始化返回值" class="headerlink" title="列表初始化返回值"></a>列表初始化返回值</h3><p>C++11新标准规定，函数可以返回花括号包围的值的列表。类似于其他返回结果，此处的列表也用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化；否则，返回的值由函数的返回类型决定。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;strings process()</span><br><span class="line">&#123;</span><br><span class="line">	// ...</span><br><span class="line">	//expected和actual是string对象</span><br><span class="line">	if (expected.empty())</span><br><span class="line">		return &#123;&#125;;//返回一个空vector对象</span><br><span class="line">	else if (expected -= actual)</span><br><span class="line">		return &#123;&quot;functionx&quot;，&quot;okay&quot;&#125;;//返回列表初始化的vector对象</span><br><span class="line">	else</span><br><span class="line">		return &#123; &quot;functionx&quot;,expected,actual&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="主函数main的返回值"><a href="#主函数main的返回值" class="headerlink" title="主函数main的返回值"></a>主函数main的返回值</h3><p>任何返回类型不是void的函数都必须返回一个值，但此规则的一个例外情况：允许main没有返回值就可结束。如果程序控制执行到主函数main的最后一个语句都还没有返回，那么编译器会隐式地插入返回0的语句。<br>关于main返回的另一个特别之处在于如何处理它的返回值。可将main返回值视为状态指示器。返回0表示程序运行成功，其他大部分返回值则失败。非0返回值的意义因机器不同而不同，为使返回值独立于机器，头文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define EXIT_SUCCESS    0</span><br><span class="line">#define EXIT_FAILURE    1</span><br></pre></td></tr></table></figure>

<h2 id="返回数组指针"><a href="#返回数组指针" class="headerlink" title="返回数组指针"></a>返回数组指针</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int( *func (int i))[10];</span><br></pre></td></tr></table></figure>

<p>可以按照以下的顺序来逐层理解该声明的含义:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func(int i)表示调用func函数时需要一个int类型的实参。</span><br><span class="line">(*func(int i))意味着我们可以对函数调用的结果执行解引用操作。</span><br><span class="line">(*func(int i))[10]表示解引用func 的调用将得到一个大小是10的数组。</span><br><span class="line">int (*func(int i))[10]表示数组中的元素是int类型。</span><br></pre></td></tr></table></figure>

<h3 id="使用尾置返回类型"><a href="#使用尾置返回类型" class="headerlink" title="使用尾置返回类型"></a>使用尾置返回类型</h3><p>在C++11新标准中还有一种可以<strong>简化上述func声明</strong>的方法,就是使用尾置返回类型(trailing return type)。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。尾置返回类型跟在形参列表后面并以一个-&gt;符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组</span><br><span class="line">auto func(int i)-&gt; int(*)[10];</span><br></pre></td></tr></table></figure>

<p>因为我们把函数的返回类型放在了形参列表之后，所以可以清楚地看到 func函数返回的是一个指针,并且该指针指向了含有10个整数的数组。</p>
<h3 id="使用decltype"><a href="#使用decltype" class="headerlink" title="使用decltype"></a>使用decltype</h3><p>还有一种情况，如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。例如，下面的函数返回一个指针，该指针根据参数i的不同指向两个已知数组中的某一个:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int odd[] =&#123; 1,3,5, 7,9&#125;;</span><br><span class="line">int even[] =&#123;0,2,4,6,8&#125;;</span><br><span class="line">//返回一个指针,该指针指向含有5个整数的数组</span><br><span class="line">decltype(odd) *arrPtr(int i)</span><br><span class="line">&#123;</span><br><span class="line">	return (i%2) ? &amp;odd : &amp;even;//返回一个指向数组的指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一个地方需要注意:decltype并不负责把数组类型转换成对应的指针，所以decltype 的结果是个数组，要想表示 arrPtr返回指针还必须在函数声明时加一个*符号。</p>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><h3 id="重载和const形参"><a href="#重载和const形参" class="headerlink" title="重载和const形参"></a>重载和const形参</h3><p>顶层const不影响传入函数的对象。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Record lookup (Phone) ;</span><br><span class="line">Record lookup (const Phone);//重复声明了Record lookup (Phone)</span><br><span class="line">Record lookup (Phone*);</span><br><span class="line">Record lookup (Phone* const);//重复声明了Record lookup(Phone* )</span><br></pre></td></tr></table></figure>

<p>在这两组函数声明中，每一组的第二个声明和第一个声明是等价的。</p>
<p>另一方面，如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//对于接受引用或指针的函数来说，对象是常量还是非常量对应的形参不同</span><br><span class="line">//定义了4个独立的重载函数</span><br><span class="line">Record lookup(Account&amp;) ;//函数作用于Account的引用</span><br><span class="line">Record lookup(const Account&amp;);//新函数，作用于常量引用</span><br><span class="line">Record lookup(Account*);//新函数，作用于指向Account的指针</span><br><span class="line">Record lookup(const Account*);//新函数，作用于指向常量的指针</span><br></pre></td></tr></table></figure>

<h3 id="const-cast和重载"><a href="#const-cast和重载" class="headerlink" title="const_cast和重载"></a>const_cast和重载</h3><p>const_cast在重载函数的情景中最有用。举个例子，shorterString函数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//比较两个string对象的长度，返回较短的那个引用</span><br><span class="line">const string &amp;shorterString(const string &amp;sl,const string &amp;s2)&#123;</span><br><span class="line">	return sl.size(&lt;=s2.size() ? s1: s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的参数和返回类型都是 const string的引用。我们可以对两个非常量的string 实参调用这个函数，但返回的结果仍然是const string的引用。因此我们需要一种新的shorterstring函数，当它的实参不是常量时，得到的结果是一个普通的引用，使用const_cast可以做到这一点:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string &amp;shorterString(string &amp;sl,string &amp;s2)</span><br><span class="line">&#123;</span><br><span class="line">	auto &amp;r = shorterString(const_cast&lt;const string6&gt;(s1)，</span><br><span class="line">						const cast&lt;const string &amp;&gt;(s2));</span><br><span class="line">	return constcast&lt;string&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个版本的函数中，首先将它的实参强制转换成对const的引用，然后调用了shorterString函数的const版本。const版本返回对const string 的引用，这个引用事实上绑定在了某个初始的非常量实参上。因此，我们可以再将其转换回一个普通的string&amp;，这显然是安全的。</p>
<h2 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h2><h3 id="内联函数和-constexpr函数"><a href="#内联函数和-constexpr函数" class="headerlink" title="内联函数和 constexpr函数"></a>内联函数和 constexpr函数</h3><p>使用shorterstring 函数也存在一个潜在的缺点:调用函数一般比求等价表达式的值要慢一些。在大多数机器上，一次函数调用其实包含着一系列工作:调用前要先保存寄存器，并在返回时恢复:可能需要拷贝实参;程序转向一个新的位置继续执行。</p>
<h4 id="内联函数可避免函数调用的开销"><a href="#内联函数可避免函数调用的开销" class="headerlink" title="内联函数可避免函数调用的开销"></a>内联函数可避免函数调用的开销</h4><p>将函数指定为内联函数（inline)，通常就是将它在每个调用点上“内联地”展开。假设我们把shorterString函数定义成内联函数，则如下调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; shorterstring (s1, s2)&lt;&lt;endl;</span><br><span class="line">//将在编译过程中展开成类似于下面的形式</span><br><span class="line">cout&lt;&lt;(s1.size()&lt; s2.size()?sl : s2)&lt;&lt; endl;</span><br><span class="line">//从而消除了shorterString函数的运行时开销。</span><br></pre></td></tr></table></figure>

<p>在shorterstring函数的返回类型前面加上关键字inline,这样就可以将它声明成内联函数了:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//内联版本:寻找两个string对象中较短的那个</span><br><span class="line">inline const string &amp;</span><br><span class="line">shorterString(const string &amp;s1,const string &amp;s2)</span><br><span class="line">&#123;</span><br><span class="line">	return s1.size() &lt;= s2.size() ?sl: s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。很多编译器都不支持内联递归函数，而且一个75行的函数也不大可能在调用点内联地展开。</p>
<h4 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h4><p>constexpr函数(constexpr function)是指能用于常量表达式(的函数。定义constexpr函数的方法与其他函数类似，不过要遵循几项约定:<strong>函数的返回类型及所有形参的类型都得是字面值类型(<strong>到目前为止接触过的数据类型中，算术类型、引用和指针都属于字面值类型。自定义类sales item、IO库、string 类型则不属于字面值类型，也就不能被定义成constexpr。其他一些字面值类型将在后面介绍)，而且函数体中</strong>必须有且只有一条return语句</strong>（constexpr函数不一定返回常量表达式）:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">constexpr int new_sz() &#123; return 42;&#125;</span><br><span class="line">constexpr int foo = new_sz();//正确:foo是一个常量表达式</span><br></pre></td></tr></table></figure>

<p>我们把new _sz定义成无参数的 constexpr函数。因为编译器能在程序编译时验证new_sz 函数返回的是常量表达式，所以可以用new_sz函数初始化constexpr类型的变量foo.</p>
<p>执行该初始化任务时，编译器把对constexpr函数的调用替换成其结果值。为了能在编译过程中随时展开，<strong>constexpr函数被隐式地指定为内联函数</strong>。</p>
<p>constexpr函数体内也可以包含其他语句，只要这些语句在运行时不执行任何操作就行。例如，constexpr函数中可以有空语句、类型别名以及using声明。</p>
<h3 id="把内联函数和constexpr函数放在头文件内"><a href="#把内联函数和constexpr函数放在头文件内" class="headerlink" title="把内联函数和constexpr函数放在头文件内"></a>把内联函数和constexpr函数放在头文件内</h3><p>和其他函数不一样，内联函数和 constexpr函数可以在程序中<strong>多次定义</strong>。毕竟，编译器要想展开函数仅有函数声明是不够的，还需要函数的定义。不过，对于某个给定的内联函数或者constexpr函数来说，它的多个定义必须完全一致。基于这个原因，内联函数和 constexpr函数通常定义在头文件中。</p>
<h2 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h2><p>C+程序员有时会用到一种类似于头文件保护的技术，以便有选择地执行调试代码。基本思想是，程序可以包含一些用于调试的代码，但是这些代码只在开发程序时使用。当应用程序编写完成准备发布时，要先屏蔽掉调试代码。这种方法用到两项预处理功能:assert和 NDEBUG。</p>
<h3 id="assert预处理宏"><a href="#assert预处理宏" class="headerlink" title="assert预处理宏"></a>assert预处理宏</h3><p>assert是一种预处理宏( preprocessor marco)。所谓预处理宏其实是一个预处理变量,它的行为有点类似于内联函数。assert宏使用一个表达式作为它的条件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert (expr) ;</span><br></pre></td></tr></table></figure>

<p>首先对expr求值，如果表达式为假(即0)，assert输出信息并终止程序的执行。如果表达式为真（即非0)，assert什么也不做。</p>
<p>assert宏定义在cassert头文件中。如我们所知，预处理名字由预处理器而非编译器管理,因此我们可以直接使用预处理名字而无须提供using声明。也就是说，我们应该使用assert而不是std::assert，也不需要为assert提供using声明。</p>
<p>assert宏常用于检查“不能发生”的条件。例如，一个对输入文本进行操作的程序可能要求所有给定单词的长度都大于某个阈值。此时,程序可以包含一条如下所示的语句:<br><code>assert(word.size(&gt;threshold);</code></p>
<h3 id="NDEBUG-预处理变量"><a href="#NDEBUG-预处理变量" class="headerlink" title="NDEBUG 预处理变量"></a>NDEBUG 预处理变量</h3><p>assert 的行为依赖于一个名为NDEBUG 的预处理变量的状态。如果定义了NDEBUG,则assert什么也不做。默认状态下没有定义NDEBUG,此时assert将执行运行时检查。</p>
<p>我们可以使用一个#define语句定义 NDEBUG，从而关闭调试状态。同时，很多编译器都提供了一个命令行选项使我们可以定义预处理变量:<br><code>$ cc-D NDEBUG main.C # use/D with the Microsoft compiler</code></p>
<p>这条命令的作用等价于在main.c文件的一开始写#define NDEBUG。</p>
<p>定义NDEBUG能避免检查各种条件所需的运行时开销,当然此时根本就不会执行运行时检查。因此，assert应该仅用于验证那些确实不可能发生的事情。我们可以把assert当成调试程序的一种辅助手段，但是不能用它替代真正的运行时逻辑检查，也不能替代程序本身应该包含的错误检查。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_ _ func _ _是编译器定义的一个局部静态变量，用于存放函数的名字</span><br><span class="line"></span><br><span class="line">_ _ FILE  _ _ 存放文件名的字符串字面值。</span><br><span class="line"></span><br><span class="line">_ _ LINE _ _ 存放当前行号的整型字面值。</span><br><span class="line"></span><br><span class="line">_ _ TIME _ _ 存放文件编译时间的字符串字面值。</span><br><span class="line"></span><br><span class="line">_ _ DATE_ _ 存放文件编译日期的字符串字面值。</span><br></pre></td></tr></table></figure>

<p>可以使用这些常量在错误消息中提供更多信息</p>
<p>练习6.48:说明下面这个循环的含义，它对assert的使用合理吗?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">while (cin &gt;&gt;S&amp;&amp;S!=sought)&#123;]//空函数体</span><br><span class="line">assert (cin);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">这不是一个好的assert用法。assert宏通常用于检查“不能发生”的条件。但是assert总是在用户直接输入EOF时发生，所以检查是没有意义的。使用assert(!cin || s == sought)更好</span><br><span class="line">【出题思路】</span><br><span class="line">assert是一种预处理宏，当assert的条件为真时什么也不做，当它的条件为假时输出信息并终止程序。</span><br><span class="line">【解答】</span><br><span class="line">该程序对assert 的使用有不合理之处。在调试器打开的情况下，当用户输入字符串 s并且s 的内容与 sought不相等时，执行循环体，否则继续执行assert(cin);语句。换句话说，程序执行到assert的原因可能有两个，一是用户终止了输入，二是用户输入的内容正好与sought 的内容一样。如果用户尝试终止输入（事实上用户总有停止输入结束程序的时候)，则assert的条件为假，输出错误信息，这与程序的原意是不相符的。</span><br><span class="line">当调试器关闭时，assert 什么也不做。</span><br></pre></td></tr></table></figure>

<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//比较两个string对象的长度</span><br><span class="line">bool lengthCompare(const string &amp;,const string &amp;);</span><br></pre></td></tr></table></figure>

<p>该函数的类型是bool(const string&amp;,const string&amp;)。要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// pf指向一个函数，该函数的参数是两个const string的引用，返回值是bool类型</span><br><span class="line">bool (*pf) (const string &amp;,const string &amp;);//未初始化</span><br></pre></td></tr></table></figure>

<p>从我们声明的名字开始观察，pf前面有个*，因此pf是指针;右侧是形参列表，表示pf指向的是函数;再观察左侧，发现函数的返回类型是布尔值。因此，pf 就是一个指向函数的指针，其中该函数的参数是两个const string 的引用，返回值是bool类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*pf两端的括号必不可少。如果不写这对括号，则pf是一个返回值为bool指针的函数:</span><br><span class="line">//声明一个名为pf的函数，该函数返回bool*</span><br><span class="line">bool *pf(const string &amp;, const string &amp;);</span><br></pre></td></tr></table></figure>

<h3 id="使用函数指针"><a href="#使用函数指针" class="headerlink" title="使用函数指针"></a>使用函数指针</h3><p>当我们把函数名作为一个值使用时，该函数自动地转换成指针。例如，按照如下形式我们可以将lengthCompare的地址赋给pf:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pf = lengthCompare;//pf指向名为lengthCompare的函数</span><br><span class="line">pf=&amp;lengthCompare;//等价的赋值语句:取地址符是可选的</span><br></pre></td></tr></table></figure>

<p>此外，我们还能直接使用指向函数的指针调用该函数，无须提前解引用指针(*..):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool bl = pf( &quot;hello&quot;, &quot;goodbye&quot; );//调用lengthCompare函数</span><br><span class="line">bool b2= (*pf) ( &quot;hello&quot;, &quot;goodbye&quot; );//一个等价的调用</span><br><span class="line">bool b3= lengthCompare (&quot;hello&quot;,&quot;goodbye&quot;);//另一个等价的调用</span><br></pre></td></tr></table></figure>

<h3 id="函数指针形参"><a href="#函数指针形参" class="headerlink" title="函数指针形参"></a>函数指针形参</h3><p>和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上却是当成指针使用:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//第三个形参是函数类型，它会自动地转换成指向函数的指针</span><br><span class="line">void useBigger(const string &amp;s1,const string &amp;s2,</span><br><span class="line">	bool pf(const string &amp;,const string &amp;));</span><br><span class="line">//等价的声明;显式地将形参定义成指向函数的指针</span><br><span class="line">void useBigger(const string &amp;s1,const string &amp;s2，</span><br><span class="line">	bool (*pf) (const string &amp;,const string &amp;));</span><br></pre></td></tr></table></figure>

<p>我们可以直接把函数作为实参使用，此时它会<strong>自动转换成指针</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//自动将函数lengthCompare转换成指向该函数的指针</span><br><span class="line">useBigger(sl, s2, lengthCompare) ;</span><br></pre></td></tr></table></figure>

<p>正如 useBigger的声明语句所示，直接使用函数指针类型显得冗长而烦琐。类型别名和decltype能让我们简化使用了函数指针的代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//Func和Func2是函数类型</span><br><span class="line">typedef bool Func(const string&amp;,const string&amp;) ;</span><br><span class="line">typedef decltype(lengthcompare) Func2;//等价的类型</span><br><span class="line">// FuncP和FuncP2是指向函数的指针</span><br><span class="line">typedef bool(*FuncP) (const string&amp;,const string&amp;);</span><br><span class="line">typedef decltype(lengthCompare) *FuncP2;</span><br><span class="line">//等价的类型</span><br></pre></td></tr></table></figure>

<p>我们使用typedef定义自己的类型。Func和 Func2是函数类型，而FuncP和 FuncP2是指针类型。需要注意的是，decltype返回函数类型，此时不会将函数类型自动转换成指针类型。因为decltype的结果是函数类型,所以只有在结果前面加上*才能得到指针。</p>
<h3 id="返回指向函数的指针"><a href="#返回指向函数的指针" class="headerlink" title="返回指向函数的指针"></a>返回指向函数的指针</h3><p>和数组类似，虽然不能返回一个函数，但是能返回指向函数类型的指针。然而，我们必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。与往常一样，要想声明一个返回函数指针的函数，最简单的办法是使用类型别名:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">using F= int(int*,int);//F是函数类型，不是指针</span><br><span class="line">using PF = int(*)(int*, int);//PF是指针类型</span><br><span class="line">其中我们使用类型别名将F定义成函数类型，将PF定义成指向函数类型的指针。必须时刻注意的是，和函数类型的形参不一样，返回类型不会自动地转换成指针。我们必须显式地将返回类型指定为指针:</span><br><span class="line">PF f1 (int);//正确:PF是指向函数的指针,f1返回指向函数的指针</span><br><span class="line">F f1(int);//错误:F是函数类型，f1不能返回一个函数</span><br><span class="line">F*f1(int) ;//正确:显式地指定返回类型是指向函数的指针</span><br><span class="line">当然，我们也能用下面的形式直接声明f1:</span><br><span class="line">int(*f1 (int))(int*, int);</span><br></pre></td></tr></table></figure>

<p>按照由内向外的顺序阅读这条声明语句:我们看到f1有形参列表，所以f1是个函数;f1前面有*，所以f1返回一个指针;进一步观察发现，指针的类型本身也包含形参列表,因此指针指向函数，该函数的返回类型是int。</p>
<p>出于完整性的考虑,有必要提醒读者我们还可以使用尾置返回类型的方式声明一个返回函数指针的函数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto f1(int) -&gt; int (*)(int*,int);</span><br></pre></td></tr></table></figure>

<h3 id="将auto和decltype用于函数指针类型"><a href="#将auto和decltype用于函数指针类型" class="headerlink" title="将auto和decltype用于函数指针类型"></a>将auto和decltype用于函数指针类型</h3><p>如果我们明确知道返回的函数是哪一个，就能使用decltype简化书写函数指针返回类型的过程。例如假定有两个函数，它们的返回类型都是 string ::size_type，并且各有两个 const strings类型的形参，此时我们可以编写第三个函数，它接受一个string类型的参数，返回一个指针，该指针指向<strong>前两个函数中的一个</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string::size_type sumLength(const string&amp;,const string&amp;);</span><br><span class="line">string::size_type largerLength (const string&amp;,const string&amp;);</span><br><span class="line">//根据其形参的取值，getFcn函数返回指向sumLength或者largerLength 的指针decltype (sumLength) *getFcn(const string &amp;);</span><br><span class="line">//getFcn有形参列表，所以getFcn是个函数</span><br><span class="line"></span><br><span class="line">//声明 getFcn 唯一需要注意的地方是，牢记当我们将decltype作用于某个函数时，它返回函数类型而非指针类型。因此，我们显式地加上*以表明我们需要返回指针，而非函数本身。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decltype(*p)`得到的类型是`int &amp;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/12/c%E5%92%8Cc++/%E7%AC%AC%E5%8D%81%E5%A4%A9-c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/12/c%E5%92%8Cc++/%E7%AC%AC%E5%8D%81%E5%A4%A9-c/" class="post-title-link" itemprop="url">第十天 c++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-12 14:36:10" itemprop="dateCreated datePublished" datetime="2023-04-12T14:36:10+08:00">2023-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-14 20:24:17" itemprop="dateModified" datetime="2023-04-14T20:24:17+08:00">2023-04-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="find-if"><a href="#find-if" class="headerlink" title="find_if"></a>find_if</h3><p>函数原型:<br>find_if(iterator beg，iterator end，_Pred);</p>
<ul>
<li>&#x2F;&#x2F;按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</li>
<li>&#x2F;&#x2F; beg 开始迭代器</li>
<li>&#x2F;&#x2F; end结束迭代器</li>
<li>&#x2F;&#x2F;_Pred 函数或者谓词(返回bool类型的仿函数)</li>
</ul>
<h3 id="adjacent-find"><a href="#adjacent-find" class="headerlink" title="adjacent_find"></a>adjacent_find</h3><p>功能描述:</p>
<ul>
<li>查找相邻重复元素</li>
</ul>
<p>函数原型:<br>adjacent_find(iterator beg， iterator end) ;</p>
<ul>
<li>&#x2F;&#x2F;查找相邻重复元素,返回相邻元素的第一个位置的迭代器</li>
<li>&#x2F;&#x2F; beg开始迭代器</li>
<li>&#x2F;&#x2F; end结束迭代器</li>
</ul>
<p>总结:面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法</p>
<h3 id="binary-search"><a href="#binary-search" class="headerlink" title="binary_search"></a>binary_search</h3><p>功能描述:</p>
<ul>
<li>查找指定元素是否存在,二分法</li>
</ul>
<p>函数原型:<br>bool binary_search(iterator beg, iterator end，value);</p>
<ul>
<li>&#x2F;&#x2F;查找指定的元素，查到返回true否则false</li>
<li>&#x2F;&#x2F;注意:在无序序列中不可用</li>
<li>&#x2F;&#x2F; beg开始迭代器</li>
<li>&#x2F;&#x2F; end结束迭代器</li>
<li>&#x2F;&#x2F; value查找的元素</li>
</ul>
<h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p>功能描述:</p>
<ul>
<li>统计元素个数</li>
</ul>
<p>函数原型:<br>count(iterator beg, iterator end，value) ;</p>
<ul>
<li>&#x2F;&#x2F;统计元素出现次数</li>
<li>&#x2F;&#x2F;beg 开始迭代器</li>
<li>&#x2F;&#x2F;end结束迭代器</li>
<li>&#x2F;&#x2F;value统计的元素</li>
</ul>
<p>自定义数据类型与find方法一致</p>
<h3 id="count-if"><a href="#count-if" class="headerlink" title="count_if"></a>count_if</h3><p>函数原型:<br>count_if(iterator beg, iterator end，_Pred ) ;</p>
<ul>
<li>&#x2F;&#x2F;按条件统计元素出现次数</li>
<li>&#x2F;&#x2F; beg开始迭代器</li>
<li>&#x2F;&#x2F;end结束迭代器</li>
<li>&#x2F;&#x2F; _Pred谓词</li>
</ul>
<h2 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h2><ul>
<li>sort	&#x2F;&#x2F;对容器内元素进行排序</li>
<li>random_shuffle	&#x2F;&#x2F;洗牌指定范围内的元素随机调整次序</li>
<li>merge	&#x2F;&#x2F;容器元素合并，并存储到另一容器中</li>
<li>reverse	&#x2F;&#x2F;反转指定范围的元素</li>
</ul>
<p>函数原型:<br>sort(iterator beg, iterator end，_Pred) ;</p>
<ul>
<li>&#x2F;&#x2F;按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</li>
<li>&#x2F;&#x2F;beg开始迭代器</li>
<li>&#x2F;&#x2F; end结束迭代器</li>
<li>&#x2F;&#x2F; _Pred 谓词</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//从大到小排序,没有pred默认是从小到大</span><br><span class="line">sort(v.begin(), v.end (), greater&lt;int&gt;());// greater&lt;int&gt;()头文件在functional</span><br></pre></td></tr></table></figure>

<p>函数原型:</p>
<p>random_shuffle(iterator beg, iterator end) ;</p>
<ul>
<li>&#x2F;&#x2F;指定范围内的元素随机调整次序</li>
<li>&#x2F;&#x2F; beg 开始迭代器</li>
<li>&#x2F;&#x2F; end结束迭代器</li>
</ul>
<p>总结:random_shuffle洗牌算法比较实用，使用时记得加随机数种子（srand((unsigned int)time(NULL)) ;）</p>
<ul>
<li>函数原型:<br>merge(iterator beg1，iterator end1， iterator beg2，iterator end2， iterator dest);</li>
<li><ul>
<li>&#x2F;&#x2F;容器元素合并，并存储到另一容器中</li>
<li>&#x2F;&#x2F; 注意:两个容器必须是有序的</li>
<li>&#x2F;&#x2F; beg1容器1开始迭代器</li>
<li>&#x2F;&#x2F; end1容器1结束迭代器</li>
<li>&#x2F;&#x2F; beg2容器2开始迭代器</li>
<li>&#x2F;&#x2F; end2容器2结束迭代器</li>
<li>&#x2F;&#x2F; dest目标容器开始迭代器</li>
</ul>
</li>
</ul>
<p>函数原型:<br>reverse(iterator beg, iterator end );</p>
<ul>
<li>&#x2F;&#x2F;反转指定范围的元素</li>
<li>&#x2F;&#x2F; beg开始迭代器</li>
<li>&#x2F;&#x2F; end结束迭代器</li>
</ul>
<h2 id="常用拷贝和替换算法"><a href="#常用拷贝和替换算法" class="headerlink" title="常用拷贝和替换算法"></a>常用拷贝和替换算法</h2><p>算法简介:</p>
<ul>
<li>copy	&#x2F;&#x2F;容器内指定范围的元素拷贝到另—容器中</li>
<li>replace	&#x2F;&#x2F;将容器内指定范围的旧元素修改为新元素</li>
<li>replace_if	&#x2F;&#x2F;容器内指定范围满足条件的元素替换为新元素</li>
<li>swap	&#x2F;&#x2F;互换两个容器的元素</li>
</ul>
<p>函数原型:<br>copy(iterator beg, iterator end，iterator dest) ;</p>
<ul>
<li>&#x2F;&#x2F;按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</li>
<li>&#x2F;&#x2F;beg开始迭代器</li>
<li>&#x2F;&#x2F; end结束迭代器</li>
<li>&#x2F;&#x2F;dest目标容器开始迭代器</li>
</ul>
<p>函数原型:<br>replace(iterator beg, iterator end，oldvalue,newvalue) ;</p>
<ul>
<li>&#x2F;&#x2F;将区间内旧元素替换成新元素</li>
<li>&#x2F;&#x2F;beg开始迭代器</li>
<li>&#x2F;&#x2F; end结束迭代器</li>
<li>&#x2F;&#x2F;oldvalue旧元素</li>
<li>&#x2F;&#x2F;newvalue新元素</li>
</ul>
<p>函数原型:<br>replace_if(iterator beg, iterator end，_pred,newvalue) ;</p>
<ul>
<li>&#x2F;&#x2F;按条件替换元素，满足条件的替换成指定元素</li>
<li>&#x2F;&#x2F;beg开始迭代器</li>
<li>&#x2F;&#x2F; end结束迭代器</li>
<li>&#x2F;&#x2F;_pred谓词</li>
<li>&#x2F;&#x2F;newvalue替换的新元素</li>
</ul>
<p>函数原型:<br>swap(container c1, container c2);</p>
<p>&#x2F;&#x2F;互换两个相同类型容器的元素<br>&#x2F;&#x2F; c1容器1<br>&#x2F;&#x2F; c2容器2</p>
<h2 id="常用算术生成算法"><a href="#常用算术生成算法" class="headerlink" title="常用算术生成算法"></a>常用算术生成算法</h2><p>注意:<br>算术生成算法属于小型算法，使用时包含的头文件为#include <numeric></numeric></p>
<p>算法简介:</p>
<ul>
<li>accumplate	&#x2F;&#x2F;计算容器元素累计总和</li>
<li>fill	&#x2F;&#x2F;向容器中添加元素</li>
</ul>
<p>函数原型:<br>accumplate(iterator beg, iterator end，value) ;</p>
<ul>
<li>&#x2F;&#x2F;计算容器元素累计总和</li>
<li>&#x2F;&#x2F;beg开始迭代器</li>
<li>&#x2F;&#x2F;end结束迭代器</li>
<li>&#x2F;&#x2F;value起始值</li>
</ul>
<p>函数原型:<br>fill(iterator beg, iterator end，value) ;</p>
<ul>
<li>&#x2F;&#x2F;向容器中填充元素</li>
<li>&#x2F;&#x2F;beg开始迭代器</li>
<li>&#x2F;&#x2F;end结束迭代器</li>
<li>&#x2F;&#x2F;value填充的值</li>
</ul>
<h2 id="常用集合算法"><a href="#常用集合算法" class="headerlink" title="常用集合算法"></a>常用集合算法</h2><p>算法简介:</p>
<ul>
<li>set_intersection	&#x2F;&#x2F;求两个容器的交集</li>
<li>set_union	&#x2F;&#x2F;求两个容器的并集</li>
<li>set_difference	&#x2F;&#x2F;求两个容器的差集</li>
</ul>
<p>函数原型:<br>set_intersection(iterator beg1，iterator end1， iterator beg2，iterator end2， iterator dest);</p>
<ul>
<li>&#x2F;&#x2F;求两个集合的交集</li>
<li>&#x2F;&#x2F; 注意:两个容器必须是有序的</li>
<li>&#x2F;&#x2F; beg1容器1开始迭代器</li>
<li>&#x2F;&#x2F; end1容器1结束迭代器</li>
<li>&#x2F;&#x2F; beg2容器2开始迭代器</li>
<li>&#x2F;&#x2F; end2容器2结束迭代器</li>
<li>&#x2F;&#x2F; dest目标容器开始迭代器</li>
<li>&#x2F;&#x2F;set_intersection返回值既是交集中最后一个元素的位置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//最特殊情况大容器包含小容器开辟空间取小容器的size即可vTarget.resize(mih(v1.size(), v2.size())) ;</span><br></pre></td></tr></table></figure>

<p>函数原型:<br>set_union(iterator beg1，iterator end1， iterator beg2，iterator end2， iterator dest);</p>
<ul>
<li>&#x2F;&#x2F;求两个集合的并集</li>
<li>&#x2F;&#x2F; 注意:两个容器必须是有序的</li>
<li>&#x2F;&#x2F; beg1容器1开始迭代器</li>
<li>&#x2F;&#x2F; end1容器1结束迭代器</li>
<li>&#x2F;&#x2F; beg2容器2开始迭代器</li>
<li>&#x2F;&#x2F; end2容器2结束迭代器</li>
<li>&#x2F;&#x2F; dest目标容器开始迭代器</li>
</ul>
<p>函数原型:<br>set_difference(iterator beg1，iterator end1， iterator beg2，iterator end2， iterator dest);</p>
<ul>
<li>&#x2F;&#x2F;求两个集合的差集</li>
<li>&#x2F;&#x2F; 注意:两个容器必须是有序的</li>
<li>&#x2F;&#x2F; beg1容器1开始迭代器</li>
<li>&#x2F;&#x2F; end1容器1结束迭代器</li>
<li>&#x2F;&#x2F; beg2容器2开始迭代器</li>
<li>&#x2F;&#x2F; end2容器2结束迭代器</li>
<li>&#x2F;&#x2F; dest目标容器开始迭代器</li>
</ul>
<p>总结:</p>
<ul>
<li>求差集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要从两个容器取较大值</li>
<li>set_difference返回值既是差集中最后一个元素的位置</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/11/c%E5%92%8Cc++/%E7%AC%AC%E4%B9%9D%E5%A4%A9-c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/11/c%E5%92%8Cc++/%E7%AC%AC%E4%B9%9D%E5%A4%A9-c/" class="post-title-link" itemprop="url">第九天 c++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-11 16:39:12" itemprop="dateCreated datePublished" datetime="2023-04-11T16:39:12+08:00">2023-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-12 15:05:48" itemprop="dateModified" datetime="2023-04-12T15:05:48+08:00">2023-04-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="STL-函数对象"><a href="#STL-函数对象" class="headerlink" title="STL-函数对象"></a>STL-函数对象</h1><h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><h3 id="函数对象概念"><a href="#函数对象概念" class="headerlink" title="函数对象概念"></a>函数对象概念</h3><p>概念:</p>
<ul>
<li>重载函数调用操作符的类，其对象常称为函数对象</li>
<li>函数对象使用重载的()时，行为类似函数调用，也叫仿函数</li>
</ul>
<p>本质:</p>
<ul>
<li>函数对象(仿函数)是一个类，不是一个函数</li>
</ul>
<h3 id="函数对象使用"><a href="#函数对象使用" class="headerlink" title="函数对象使用"></a>函数对象使用</h3><p>特点:</p>
<ul>
<li>函数对象在使用时，可以像普通函数那样调用,可以有参数，可以有返回值</li>
<li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li>
<li>函数对象可以作为参数传递</li>
</ul>
<h2 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h2><h3 id="谓词概念"><a href="#谓词概念" class="headerlink" title="谓词概念"></a>谓词概念</h3><p>概念:</p>
<ul>
<li>返回bool类型的仿函数称为谓词</li>
<li>如果operator()接受一个参数，那么叫做一元谓词</li>
<li>如果operator()接受两个参数，那么叫做二元谓词</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">//1.一元谓词</span><br><span class="line">class GreaterFive&#123;</span><br><span class="line">public:</span><br><span class="line">	bool operator()(int val) &#123;</span><br><span class="line">		return val &gt; 5;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test01() &#123;</span><br><span class="line">	vector&lt;int&gt; v;</span><br><span class="line">	for (int i =0; i &lt; 10; i++)&#123;</span><br><span class="line">		v.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;int&gt; : :iterator it = find_if(v.begin(), v.end()，GreaterFive());//匿名形式</span><br><span class="line">	//GreaterFive如果括号里有常量，则这个与仿函数内部定义的量相对应，而重载的val与容器值对应，无需传入</span><br><span class="line">	if (it == v.end()) &#123;</span><br><span class="line">		cout &lt;&lt;&quot;没找到!”&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		cout &lt;&lt;“找到:” &lt;&lt;*it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">//二元谓词</span><br><span class="line">class MyCompare&#123;</span><br><span class="line">public:</span><br><span class="line">	bool operator( )(int num1,int num2)&#123;</span><br><span class="line">		return num1 &gt; num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()&#123;</span><br><span class="line">	vector&lt;int&gt; v;</span><br><span class="line">	v.push_back(10);</span><br><span class="line">	v.push_back(40);</span><br><span class="line">	v.push_back(20);</span><br><span class="line">	v.push_back(30);</span><br><span class="line">	v.push_back(50) ;</span><br><span class="line">	//默认从小到大</span><br><span class="line">	sort(v.begin(), v.end() );</span><br><span class="line">	for (vector&lt;int&gt; : :iterator it = v.begin(); it != v.end(); it++)&#123;</span><br><span class="line">		cout &lt;&lt;*it &lt;&lt;” &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;------------&quot; &lt;&lt;endl;</span><br><span class="line">	//使用函数对象改变算法策略，排序从大到小</span><br><span class="line">	sort(v.begin(), v.end( ), MyCompare( ) );</span><br><span class="line">	for (vector&lt;int&gt; ::iterator it = v.begin(); it != v.end(); it++)&#123;</span><br><span class="line">		cout &lt;&lt;*it &lt;&lt;&quot;&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:参数只有两个的谓词，称为二元谓词</p>
<h1 id="内建函数对象"><a href="#内建函数对象" class="headerlink" title="内建函数对象"></a>内建函数对象</h1><h2 id="内建函数对象意义"><a href="#内建函数对象意义" class="headerlink" title="内建函数对象意义"></a>内建函数对象意义</h2><p>概念:</p>
<ul>
<li>STL内建了一些函数对象</li>
</ul>
<p>分类:</p>
<ul>
<li>算术仿函数</li>
<li>关系仿函数</li>
<li>逻辑仿函数</li>
</ul>
<p>用法:</p>
<ul>
<li>这些仿函数所产生的对象，用法和一般函数完全相同</li>
<li>使用内建函数对象，需要引入头文件#include<functional></functional></li>
</ul>
<h2 id="算术仿函数"><a href="#算术仿函数" class="headerlink" title="算术仿函数"></a>算术仿函数</h2><p>功能描述:</p>
<ul>
<li>实现四则运算</li>
</ul>
<p>其中negate是一元运算，其他都是二元运算仿函数原型:</p>
<ul>
<li><p>template<class t> T plus<T>&#x2F;&#x2F;加法仿函数</T></class></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plus&lt;int&gt; p;</span><br><span class="line">cout &lt;&lt; p( 10，20) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>


</li>
<li><p>template<class t> T minus<T>&#x2F;&#x2F;减法仿函数</T></class></p>
</li>
<li><p>template<class t> T multiplies<T>&#x2F;&#x2F;乘法仿函数</T></class></p>
</li>
<li><p>template<class t> T divides<T>&#x2F;&#x2F;除法仿函数</T></class></p>
</li>
<li><p>template<class t> T modulus<T>&#x2F;&#x2F;取模仿函数</T></class></p>
</li>
<li><p>template<class t> T negate<T>&#x2F;&#x2F;取反仿函数</T></class></p>
</li>
</ul>
<h2 id="关系仿函数"><a href="#关系仿函数" class="headerlink" title="关系仿函数"></a>关系仿函数</h2><p>功能描述:</p>
<ul>
<li>实现关系对比</li>
</ul>
<p>仿函数原型:</p>
<ul>
<li><p>template<class t> bool equal_to<T>&#x2F;&#x2F;等于</T></class></p>
</li>
<li><p>template<class t> bool not_equal_to<T>&#x2F;&#x2F;不等于</T></class></p>
</li>
<li><p>template<class t> bool greater<T>&#x2F;&#x2F;大于</T></class></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//降序</span><br><span class="line">// sort(v.begin(), v.end()，MyCompare() ) ;</span><br><span class="line">sort(v.begin()， v.end(),greater&lt;int&gt;());</span><br></pre></td></tr></table></figure>


</li>
<li><p>template<class t> bool greater_equal<T>&#x2F;&#x2F;大于等于</T></class></p>
</li>
<li><p>template<class t> bool less<T>&#x2F;&#x2F;小于</T></class></p>
</li>
<li><p>template<class t> bool less_equal<T>&#x2F;&#x2F;小于等于</T></class></p>
</li>
</ul>
<p>总结:关系仿函数中最常用的就是greater&lt;&gt;大于,因为默认是less小于</p>
<h2 id="逻辑仿函数"><a href="#逻辑仿函数" class="headerlink" title="逻辑仿函数"></a>逻辑仿函数</h2><p>功能描述:</p>
<ul>
<li>实现逻辑运算</li>
</ul>
<p>函数原型:</p>
<ul>
<li>template<class t> bool logical_and<T>&#x2F;&#x2F;逻辑与</T></class></li>
<li>template<class t> bool logical_or<T>&#x2F;&#x2F;逻辑或</T></class></li>
<li>template<class t> bool logical_not<T>&#x2F;&#x2F;逻辑非</T></class></li>
</ul>
<h1 id="STL-常用算法"><a href="#STL-常用算法" class="headerlink" title="STL-常用算法"></a>STL-常用算法</h1><p>概述:</p>
<ul>
<li>算法主要是由头文件<algorithm><functional><numeric>组成。</numeric></functional></algorithm></li>
<li><algorithm>是所有STL头文件中最大的一个，范围涉及到比较、交换、查找、遍历操作、复制、修改等等<numeric>体积很小，只包括几个在序列上面进行简单数学运算的模板函数</numeric></algorithm></li>
<li><functional>定义了一些模板类,用以声明函数对象。</functional></li>
</ul>
<h2 id="常用遍历算法"><a href="#常用遍历算法" class="headerlink" title="常用遍历算法"></a>常用遍历算法</h2><p>算法简介:</p>
<ul>
<li>for_each&#x2F;&#x2F;遍历容器</li>
<li>transform&#x2F;&#x2F;搬运容器到另一个容器中</li>
</ul>
<h2 id="for-each"><a href="#for-each" class="headerlink" title="for_each"></a>for_each</h2><p>函数原型:</p>
<ul>
<li>for_each(iterator beg, iterator end，_func);</li>
</ul>
<p>​	&#x2F;&#x2F;遍历算法遍历容器元素<br>​	&#x2F;&#x2F;beg开始迭代器<br>​	&#x2F;&#x2F;end结束迭代器<br>​	&#x2F;&#x2F; _func函数或者函数对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">//普通函数</span><br><span class="line">void print01(int val)&#123;</span><br><span class="line">	cout &lt;&lt;val &lt;&lt; &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">//函数对象</span><br><span class="line">class print02&#123;</span><br><span class="line">public :</span><br><span class="line">	void operator()(int val)&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt;&quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//for_each算法基本用法</span><br><span class="line">void test01()&#123;</span><br><span class="line">	vector&lt;int&gt; v;</span><br><span class="line">	for (int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">		v.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	//遍历算法</span><br><span class="line">	for_each(v.begin(), v.end( ), print01);//相当于传入了一个函数指针</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	for_each(v.begin(), v.end(), print02());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h2><p>函数原型:</p>
<ul>
<li>transform(iterator beg1, iterator end1， iterator beg2，_func);</li>
</ul>
<p>​	&#x2F;&#x2F;beg1源容器开始迭代器</p>
<p>​	&#x2F;&#x2F;end1源容器结束迭代器</p>
<p>​	&#x2F;&#x2F;beg2目标容器开始迭代器</p>
<p>​	&#x2F;&#x2F;_func函数或者函数对象</p>
<p>总结:搬运的目标容器必须要提前开辟空间，否则无法正常搬运</p>
<h2 id="常用查找算法"><a href="#常用查找算法" class="headerlink" title="常用查找算法"></a>常用查找算法</h2><p>算法简介:</p>
<ul>
<li>find&#x2F;&#x2F;查找元素</li>
<li>find_if&#x2F;&#x2F;按条件查找元素</li>
<li>adjacent_find&#x2F;&#x2F;查找相邻重复元素</li>
<li>binary_search&#x2F;&#x2F;二分查找法</li>
<li>count&#x2F;&#x2F;统计元素个数</li>
<li>count_if&#x2F;&#x2F;按条件统计元素个数</li>
</ul>
<p>函数原型:<br>find(iterator beg, iterator end,value ) ;</p>
<ul>
<li>&#x2F;&#x2F;按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</li>
<li>&#x2F;&#x2F;beg开始迭代器</li>
<li>&#x2F;&#x2F;end结束迭代器</li>
<li>&#x2F;&#x2F;value查找的元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">void test01() &#123;</span><br><span class="line">	vector&lt;int&gt; v;</span><br><span class="line">	for (int i =0; i &lt; 10; i++)&#123;</span><br><span class="line">		v.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;int&gt; : :iterator it = find(v.begin(), v.end()，5);//查找容器中是否有5这个元素</span><br><span class="line">	if (it == v.end()) &#123;</span><br><span class="line">		cout &lt;&lt;&quot;没找到!”&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		cout &lt;&lt;“找到:” &lt;&lt;*it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">	Person( string name，int age)&#123;</span><br><span class="line">		this-&gt;m_Name = name;</span><br><span class="line">		this-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	//重载==,是find底层的==</span><br><span class="line">	bool operato==(const Person&amp; p)&#123;</span><br><span class="line">		if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)&#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	string m_Name ;</span><br><span class="line">	int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line">void test02()&#123;</span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line">	//创建数据</span><br><span class="line">	Person p1( &quot;aaa&quot;, 10);</span><br><span class="line">	Person p2(&quot;bbb&quot;,20);</span><br><span class="line">	Person p3(&quot;cce&quot;, 30);</span><br><span class="line">	Person p4( &quot;ddd&quot;,40);</span><br><span class="line">	v.push_back(p1);</span><br><span class="line">	v.push_back(p2);</span><br><span class="line">	v.push_back(p3);</span><br><span class="line">	v.push_back(p4);</span><br><span class="line">	Person pp=(&quot;ads&quot;,11);</span><br><span class="line">	vector&lt;Person&gt; : :iterator it = find(v.begin(), v.end(), pp);</span><br><span class="line">	if (it == v.end())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt;&quot;没有找到!&quot;&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		cout &lt;&lt;&quot;找到姓名:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt;”年龄: &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:利用find可以在容器中找指定的元素，返回值是迭代器</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/10/c%E5%92%8Cc++/%E7%AC%AC%E5%85%AB%E5%A4%A9-c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/10/c%E5%92%8Cc++/%E7%AC%AC%E5%85%AB%E5%A4%A9-c/" class="post-title-link" itemprop="url">第八天 c++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-10 16:38:50" itemprop="dateCreated datePublished" datetime="2023-04-10T16:38:50+08:00">2023-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-16 13:41:42" itemprop="dateModified" datetime="2023-04-16T13:41:42+08:00">2023-04-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="stack容器"><a href="#stack容器" class="headerlink" title="stack容器"></a>stack容器</h2><h3 id="stack基本概念"><a href="#stack基本概念" class="headerlink" title="stack基本概念"></a>stack基本概念</h3><p>概念: stack是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口</p>
<p>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p>
<h3 id="stack常用接口"><a href="#stack常用接口" class="headerlink" title="stack常用接口"></a>stack常用接口</h3><p>功能描述:栈容器常用的对外接口</p>
<p>构造函数:</p>
<ul>
<li>stack<T> stk;&#x2F;&#x2F;stack采用模板类实现, stack对象的默认构造形式</T></li>
<li>stack( const stack &amp;stk);&#x2F;&#x2F;拷贝构造函数</li>
</ul>
<p>赋值操作:</p>
<ul>
<li>stack&amp; operator&#x3D;(const stack &amp;stk);&#x2F;&#x2F;重载等号操作符</li>
</ul>
<p>数据存取:</p>
<ul>
<li>push(elem);&#x2F;&#x2F;向栈顶添加元素</li>
<li>pop();&#x2F;&#x2F;从栈顶移除第一个元素</li>
<li>top();&#x2F;&#x2F;返回栈顶元素</li>
</ul>
<p>大小操作:</p>
<ul>
<li>empty();&#x2F;&#x2F;判断堆栈是否为空</li>
<li>size();&#x2F;&#x2F;返回栈的大小</li>
</ul>
<h2 id="queue容器"><a href="#queue容器" class="headerlink" title="queue容器"></a>queue容器</h2><h3 id="queue基本概念"><a href="#queue基本概念" class="headerlink" title="queue基本概念"></a>queue基本概念</h3><p>概念:Queud是一种先进先出(First ln First Out,FIFO)的数据结构，它有两个出口</p>
<ul>
<li>队列容器允许从一端新增元素，从另一端移除元素</li>
<li>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</li>
<li>队列中进数据称为—入队push</li>
<li>队列中出数据称为—出队pop</li>
</ul>
<h3 id="queue-常用接口"><a href="#queue-常用接口" class="headerlink" title="queue 常用接口"></a>queue 常用接口</h3><p>功能描述:栈容器常用的对外接口</p>
<p>构造函数:</p>
<ul>
<li>queue<T> que;&#x2F;&#x2F;queue采用模板类实现，queue对象的默认构造形式</T></li>
<li>queue(const queue &amp;que) ;&#x2F;&#x2F;拷贝构造函数</li>
</ul>
<p>赋值操作:</p>
<ul>
<li>queue&amp; operator&#x3D;(const queue &amp;que) ;&#x2F;&#x2F;重载等号操作符</li>
</ul>
<p>数据存取:</p>
<ul>
<li>push(elem) ;&#x2F;&#x2F;往队尾添加元素</li>
<li>pop();&#x2F;&#x2F;从队头移除第一个元素</li>
<li>back();&#x2F;&#x2F;返回最后一个元素</li>
<li>front();&#x2F;&#x2F;返回第一个元素</li>
</ul>
<p>大小操作:</p>
<ul>
<li>empty();&#x2F;&#x2F;判断堆栈是否为空</li>
<li>size();&#x2F;&#x2F;返回栈的大小</li>
</ul>
<h2 id="list容器"><a href="#list容器" class="headerlink" title="list容器"></a>list容器</h2><h3 id="list基本概念"><a href="#list基本概念" class="headerlink" title="list基本概念"></a>list基本概念</h3><p>功能:将数据进行链式存储</p>
<p>链表(list)是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p>
<p>链表的组成:链表由一系列结点组成</p>
<p>结点的组成:一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域</p>
<p>STL中的链表是一个双向循环链表</p>
<p>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器</p>
<p>list的优点:</p>
<ul>
<li>采用动态存储分配，不会造成内存浪费和溢出</li>
<li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li>
</ul>
<p>list的缺点:</p>
<ul>
<li>链表灵活，但是空间(指针域)和时间(遍历额外耗费较大</li>
</ul>
<p>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</p>
<p>总结:STL中List和vector是两个最常被使用的容器，各有优缺点</p>
<h3 id="list构造函数"><a href="#list构造函数" class="headerlink" title="list构造函数"></a>list构造函数</h3><p>函数原型:</p>
<ul>
<li>list<T> lst;&#x2F;&#x2F;list采用采用模板类实现,对象的默认构造形式:</T></li>
<li>list(beg,end) ;&#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。</li>
<li>list(n,elem) ;&#x2F;&#x2F;构造函数将n个elem拷贝给本身。</li>
<li>list(const list &amp;lst);&#x2F;&#x2F;拷贝构造函数。</li>
</ul>
<p>总结:list构造方式同其他几个STL常用容器，熟练掌握即可</p>
<h3 id="list赋值和交换"><a href="#list赋值和交换" class="headerlink" title="list赋值和交换"></a>list赋值和交换</h3><p>函数原型:</p>
<ul>
<li>assign(beg,_end) ;&#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li>assign(n, eiem) ;&#x2F;&#x2F;将n个elem拷贝赋值给本身。</li>
<li>list&amp; operator&#x3D;(const list &amp;lst);&#x2F;&#x2F;重载等号操作符</li>
<li>swap(lst);&#x2F;&#x2F;将lst与本身的元素互换。</li>
</ul>
<h3 id="list大小操作"><a href="#list大小操作" class="headerlink" title="list大小操作"></a>list大小操作</h3><p>函数原型:</p>
<ul>
<li>size();&#x2F;&#x2F;返回容器中元素的个数</li>
<li>empty();&#x2F;&#x2F;判断容器是否为空</li>
<li>resize(num ) ;&#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。&#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</li>
<li>resize(num，elem);&#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。&#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</li>
</ul>
<h3 id="list插入和删除"><a href="#list插入和删除" class="headerlink" title="list插入和删除"></a>list插入和删除</h3><p>函数原型:</p>
<ul>
<li>push_back(elem);&#x2F;&#x2F;在容器尾部加入一个元素.</li>
<li>pop_back();&#x2F;&#x2F;删除容器中最后一个元素</li>
<li>push_front(elem);&#x2F;&#x2F;在容器开头插入一个元素.</li>
<li>pop_front();&#x2F;&#x2F;从容器开头移除第一个元素</li>
<li>insert(pos,elem);&#x2F;&#x2F;在pos位置插elem元素的拷贝，返回新数据的位置。</li>
<li>insert(pos,n,elem);&#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。</li>
<li>insert(pos,beg,end);&#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。</li>
<li>clear();&#x2F;&#x2F;移除容器的所有数据</li>
<li>erase(beg,end);&#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。</li>
<li>erase(pos);&#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。</li>
<li>remove(elem);&#x2F;&#x2F;删除容器中所有与elem值匹配的元素。</li>
</ul>
<h3 id="list数据存取"><a href="#list数据存取" class="headerlink" title="list数据存取"></a>list数据存取</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//L1[0]不可以用[]访问list容器中的元素</span><br><span class="line">//L1.at(O)不可以用at方式访问list容器中的元素</span><br><span class="line">//原因是list本质链表，不是用连续线性空间存储数据，迭代器也是不支持随机访问的</span><br><span class="line">cout &lt;&lt;&quot;第一个元素为:&quot;&lt;&lt; L1.front() &lt;&lt; endl;</span><br><span class="line">cout&lt;&lt;&quot;最后一个元素为:&quot;&lt;&lt; L1. back() &lt;&lt; endl ;</span><br><span class="line">//验证迭代器是不支持随机访问的</span><br><span class="line">list&lt;int&gt; : :iterator it = L1. begin();</span><br><span class="line">it++;//支持双向,可以用来判断其它容器是否支持双向访问，随机访问也一样</span><br><span class="line">it--;</span><br><span class="line">//it = it + 1;//不支持随机访问</span><br></pre></td></tr></table></figure>

<p>总结:</p>
<ul>
<li>list容器中不可以通过[]或者at方式访问数据</li>
<li>返回第一个元素— front</li>
<li>返回最后一个元素— back</li>
</ul>
<h3 id="list反转和排序"><a href="#list反转和排序" class="headerlink" title="list反转和排序"></a>list反转和排序</h3><p>函数原型:</p>
<ul>
<li>reverse();&#x2F;&#x2F;反转链表</li>
<li>sort(); &#x2F;&#x2F;链表排序</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//指定排序规则</span><br><span class="line">bool mycompare( int val1 , int val2)&#123;</span><br><span class="line">	return val1 &gt; val2;</span><br><span class="line">&#125;</span><br><span class="line">//所有不支持随机访问迭代器的容器，不可以用标准算法</span><br><span class="line">//不支持随机访问迭代器的容器，内部会提供对应一些算法</span><br><span class="line">//sort(L1.begin()，L1.end() ) ;</span><br><span class="line">L1.sort();//默认排序规则从小到大升序</span><br><span class="line">L.sort( myCompare); //指定规则，从大到小</span><br></pre></td></tr></table></figure>

<p>总结:</p>
<ul>
<li><p>对于自定义数据类型，必须要指定排序规则(</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool mycompare( int val1 , int val2)&#123;</span><br><span class="line">	return val1 &gt; val2;</span><br><span class="line">&#125;//val可以是任何类型，注意引用</span><br></pre></td></tr></table></figure>

<p>)，否则编译器不知道如何进行排序</p>
</li>
<li><p>高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂</p>
</li>
</ul>
<h2 id="set-x2F-multiset容器"><a href="#set-x2F-multiset容器" class="headerlink" title="set&#x2F; multiset容器"></a>set&#x2F; multiset容器</h2><h3 id="set基本概念"><a href="#set基本概念" class="headerlink" title="set基本概念"></a>set基本概念</h3><p>简介:</p>
<ul>
<li>所有元素都会在插入时自动被排序</li>
</ul>
<p>本质:</p>
<ul>
<li>set&#x2F;multiset属于关联式容器，底层结构是用二叉树实现。</li>
</ul>
<p>set和multiset区别:</p>
<ul>
<li>set不允许容器中有重复的元素（无resize）</li>
<li>multiset允许容器中有重复的元素</li>
</ul>
<p>总结:</p>
<ul>
<li>set容器插入数据时用insert</li>
<li>set容器插入数据的数据会自动排序</li>
</ul>
<p>总结:</p>
<ul>
<li>统计大小— size</li>
<li>判断是否为空— empty</li>
<li>交换容器— swap</li>
</ul>
<p>函数原型:</p>
<ul>
<li><p>insert(elem);&#x2F;&#x2F;在容器中插入元素。</p>
</li>
<li><p>clear();&#x2F;&#x2F;清除所有元素</p>
</li>
<li><p>erase(pos);&#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。</p>
</li>
<li><p>erase(beg, end);&#x2F;&#x2F;删除区间[beg,end)的所有元素，返回下一个元素的迭代器。</p>
</li>
<li><p>erase(elem);&#x2F;&#x2F;删除容器中值为elem的元素。</p>
</li>
<li><p>find(key ) ;&#x2F;&#x2F;查找key是否存在,若存在，返回该键的元素的迭代器;若不存在，返回set.end();</p>
</li>
<li><p>count(key);&#x2F;&#x2F;统计key的元素个数,对于set而言统计结果要么是0要么是1</p>
</li>
</ul>
<h3 id="set和multiset区别"><a href="#set和multiset区别" class="headerlink" title="set和multiset区别"></a>set和multiset区别</h3><p>区别:</p>
<ul>
<li>set不可以插入重复数据，而multiset可以</li>
<li>set插入数据的同时会返回插入结果，表示插入是否成功. multiset不会检测数据，因此可以插入重复数据</li>
</ul>
<p>总结:</p>
<ul>
<li>如果不允许插入重复数据可以利用set</li>
<li>如果需要插入重复数据利用multiset</li>
</ul>
<h3 id="pair对组创建"><a href="#pair对组创建" class="headerlink" title="pair对组创建"></a>pair对组创建</h3><p>功能描述:</p>
<ul>
<li>成对出现的数据，利用对组可以返回两个数据</li>
</ul>
<p>两种创建方式:</p>
<ul>
<li>pair&lt;type, tyie&gt; p ( value1, value2 );</li>
<li>pair&lt;type, type&gt; p &#x3D; make_pair( value1，value2 );</li>
</ul>
<h3 id="set容器排序"><a href="#set容器排序" class="headerlink" title="set容器排序"></a>set容器排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class MyCompare&#123;</span><br><span class="line">public:</span><br><span class="line">	bool operator()(int v1,int v2)//重载（），//自定义数据类型都会指定排序规则</span><br><span class="line">	&#123;</span><br><span class="line">		return v1 &gt; v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test()&#123;</span><br><span class="line">	set&lt;int，MyCompare&gt;s2;//要放在插入之前，int与上面传入的数据类型一致,MyCompare是仿函数</span><br><span class="line">	s2.insert(10) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:利用仿函数可以指定set容器的排序规则</p>
<p>总结:<br>对于自定义数据类型，set必须指定排序规则才可以插入数据</p>
<h2 id="map-x2F-multimap容器"><a href="#map-x2F-multimap容器" class="headerlink" title="map&#x2F;multimap容器"></a>map&#x2F;multimap容器</h2><h3 id="map基本概念"><a href="#map基本概念" class="headerlink" title="map基本概念"></a>map基本概念</h3><p>简介:</p>
<ul>
<li>map中所有元素都是pair</li>
<li>pair中第一个元素为key(键值)，起到索引作期，第二个元素为value(实值)·所有元素都会</li>
</ul>
<p>本质:</p>
<ul>
<li>map&#x2F;multimap属于关联式容器，底层结构是用二叉树实现。</li>
</ul>
<p>优点:</p>
<ul>
<li>可以根据key值快速找到value值</li>
</ul>
<p>map和multimap区别:</p>
<ul>
<li>map不允许容器中有重复key值元素</li>
<li>multimap允许容器中有重复key值元素</li>
</ul>
<h3 id="map构造和赋值"><a href="#map构造和赋值" class="headerlink" title="map构造和赋值"></a>map构造和赋值</h3><p>构造:</p>
<ul>
<li>map&lt;T1，T2&gt; mp;&#x2F;&#x2F;map默认构造函数:</li>
<li>map(const ma &amp;mp );&#x2F;&#x2F;拷贝构造函数</li>
</ul>
<p>赋值:</p>
<ul>
<li>map&amp; operator&#x3D;(const map &amp;mp);&#x2F;&#x2F;重载等号操作符</li>
</ul>
<p>总结: map中所有元素都是成对出现，插入数据时候要使用对组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map&lt;int,int&gt;m;//默认构造</span><br><span class="line">m.insert(pair&lt;int, int&gt;(1，10));</span><br></pre></td></tr></table></figure>

<ul>
<li><p>统计大小— size</p>
</li>
<li><p>判断是否为空— empty</p>
</li>
<li><p>交换容器— swap</p>
</li>
<li><p>insert(elem);&#x2F;&#x2F;在容器中插入元素。</p>
</li>
<li><p>clear();&#x2F;&#x2F;清除所有元素</p>
</li>
<li><p>erase(pos);&#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。</p>
</li>
<li><p>erase(beg, end);&#x2F;&#x2F;删除区间[beg,end)的所有元素，返回下一个元素的迭代器。</p>
</li>
<li><p>erase(key);&#x2F;&#x2F;删除容器中值为elem的元素。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m[4] = 40;</span><br><span class="line">//[]不建议插入，用途	可以利用key访问到value</span><br><span class="line">cout &lt;&lt; m[4]&lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<ul>
<li>find(key ) ;&#x2F;&#x2F;查找key是否存在,若存在，返回该键的元素的迭代器;若不存在，返回set.end();返回迭代器，需要迭代器接受map&lt;int,int&gt;: :iterator pos &#x3D; m. find(3) ;</li>
<li>count(key);&#x2F;&#x2F;统计key的元素个数,对于set而言统计结果要么是0要么是1</li>
</ul>
<p>map不允许插入重复key元素，count统计而言结果要么是0要么是1</p>
<p>multimap的count统计可能大于1</p>
<h3 id="map容器排序"><a href="#map容器排序" class="headerlink" title="map容器排序"></a>map容器排序</h3><p>学习目标:</p>
<ul>
<li>map容器默认排序规则为按照key值进行从小到大排序，掌握如何改变排序规则</li>
</ul>
<p>主要技术点:</p>
<ul>
<li>利用仿函数，可以改变排序规则</li>
</ul>
<p>总结:</p>
<ul>
<li>利用仿函数可以指定map容器的排序规则</li>
<li>对于自定义数据类型，map必须要指定排序规则，同set容器</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">肖汇林</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">肖汇林</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
