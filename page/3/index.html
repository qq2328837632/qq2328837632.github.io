<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="选择有时候比努力更重要">
<meta property="og:type" content="website">
<meta property="og:title" content="肖汇林的博客">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="肖汇林的博客">
<meta property="og:description" content="选择有时候比努力更重要">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="肖汇林">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>肖汇林的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖汇林的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/16/%E7%AC%AC%E4%BA%8C%E5%A4%A9-c%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/16/%E7%AC%AC%E4%BA%8C%E5%A4%A9-c%E8%AF%AD%E8%A8%80/" class="post-title-link" itemprop="url">第二天 c语言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-16 10:02:10 / 修改时间：10:03:19" itemprop="dateCreated datePublished" datetime="2023-03-16T10:02:10+08:00">2023-03-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C-存储类"><a href="#C-存储类" class="headerlink" title="C 存储类"></a>C 存储类</h1><p>存储类定义 C 程序中变量&#x2F;函数的的存储位置、生命周期和作用域。</p>
<p>这些说明符放置在它们所修饰的类型之前。</p>
<p>下面列出 C 程序中可用的存储类：</p>
<p>auto</p>
<p>register</p>
<p>static</p>
<p>extern</p>
<h2 id="auto-存储类"><a href="#auto-存储类" class="headerlink" title="auto 存储类"></a>auto 存储类</h2><p><strong>auto</strong> 存储类是所有局部变量默认的存储类。</p>
<p><strong>auto</strong>  普通局部栈变量，是自动存储，这种对象会自动创建和销毁 ，建议这个变量要放在堆栈上面，调用函数时分配内存，函数结束时释放内存。一般隐藏auto默认为自动存储类别。我们程序变量大多是自动变量。</p>
<h2 id="register-存储类"><a href="#register-存储类" class="headerlink" title="register 存储类"></a>register 存储类</h2><p><strong>register</strong> 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个字），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。</p>
<p>register 存储类定义存储在寄存器，所以变量的访问速度更快，但是它不能直接取地址，因为它不是存储在 RAM 中的。在需要频繁访问的变量上使用 register 存储类可以提高程序的运行速度。</p>
<h2 id="static-存储类"><a href="#static-存储类" class="headerlink" title="static 存储类"></a>static 存储类</h2><p><strong>static</strong> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</p>
<p>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。</p>
<p>全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。</p>
<p>静态变量在程序中只被初始化一次，即使函数被调用多次，该变量的值也不会重置。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">/* 函数声明 */</span><br><span class="line">void func1(void);</span><br><span class="line"> </span><br><span class="line">static int count=10;        /* 全局变量 - static 是默认的 */</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  while (count--) &#123;</span><br><span class="line">      func1();</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void func1(void)</span><br><span class="line">&#123;</span><br><span class="line">/* &#x27;thingy&#x27; 是 &#x27;func1&#x27; 的局部变量 - 只初始化一次</span><br><span class="line"> * 每次调用函数 &#x27;func1&#x27; &#x27;thingy&#x27; 值不会被重置。</span><br><span class="line"> */                </span><br><span class="line">  static int thingy=5;</span><br><span class="line">  thingy++;</span><br><span class="line">  printf(&quot; thingy 为 %d ， count 为 %d\n&quot;, thingy, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例中 count 作为全局变量可以在函数内使用，thingy 使用 static 修饰后，不会在每次调用时重置。</p>
<h2 id="extern-存储类"><a href="#extern-存储类" class="headerlink" title="extern 存储类"></a>extern 存储类</h2><p><strong>extern</strong> 存储类用于定义在其他文件中声明的全局变量或函数。当使用 extern 关键字时，不会为变量分配任何存储空间，而只是指示编译器该变量在其他文件中定义。</p>
<p><strong>extern</strong> 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 <strong>extern</strong> 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p>
<p>当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 <em>extern</em> 来得到已定义的变量或函数的引用。可以这么理解，<em>extern</em> 是用来在另一个文件中声明一个全局变量或函数。</p>
<p>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：</p>
<p><strong>第一个文件：main.c</strong></p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int count ;</span><br><span class="line">extern void write_extern();</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   count = 5;</span><br><span class="line">   write_extern();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二个文件：support.c</strong></p>
<h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">extern int count;</span><br><span class="line"> </span><br><span class="line">void write_extern(void)</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;count is %d\n&quot;, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>1、auto存储类型的变量只能在某个程序范围内使用,他采用堆栈的方式分配空间。</p>
<p>  在定义变量时,auto是可以省略的,如:auto  int  i;等效于int  i.</p>
<p>2、全局变量不允许声明为auto变量，register不适用于全局变量。</p>
<p>3、register是不能取址的。比如 int i；(自动为auto)int *p&#x3D;&amp;i;是对的，但register int j; int *p &#x3D; &amp;j;是错的，因为无法对寄存器的定址。</p>
<p>4、声明变量为register,编译器并不一定会将它处理为寄存器变量，毕竟，资源是有限的。</p>
<p>5、实际上现在一般的编译器都忽略auto和register申明，现在的编译器自己能够区分最好将那些变量放置在寄存器中，那些放置在堆栈中；甚至于将一些变量有时存放在堆栈，有时存放在寄存器中。</p>
<p>6、auto register 是用来修饰变量的,static extern 变量函数都可以。</p>
<p>7、Extern外部变量：如果我们希望该外部变量只能在本文件内使用，而不能被其他文件引用可以在外部变量定义时加static声明。防止别人写的模块误用。</p>
<p>8、全局变量会被初始化为空, 而局部变量在没有赋值前是一个垃圾值。</p>
<p>9、static 关键字: 修饰的局部变量是静态局部变量; 静态局部变量存值如同全局变量, 区别在于它只属于拥有它的函数; 它也会被初始化为空。</p>
<p>10、静态全局变量也具有全局作用域，它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。因此static 这个说明符在不同的地方所起的作用是不同的。应予以注意。</p>
<p><strong>Tips:</strong></p>
<p> A.若全局变量仅在单个C文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度；</p>
<p> B.若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度；</p>
<p> C.设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑重入问题，因为他们都放在静态数据存储区，全局可见；</p>
<p> D.如果我们需要一个可重入的函数，那么，我们一定要避免函数中使用static变量(这样的函数被称为：带”内部存储器”功能的的函数)</p>
<p> E.函数中必须要使用static变量情况:比如当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类型，则返回为错指针。</p>
<h4 id="利用异或-来交换两个数的值，而且不引入其他变量。"><a href="#利用异或-来交换两个数的值，而且不引入其他变量。" class="headerlink" title="利用异或 ^ 来交换两个数的值，而且不引入其他变量。"></a>利用异或 <strong>^</strong> 来交换两个数的值，而且不引入其他变量。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unsigned int a=60;  //0011 1100</span><br><span class="line">unsigned int b=13;  //0000 1101</span><br><span class="line">a=a^b;              //a=a^b=0011 0001</span><br><span class="line">b=a^b;              //b=a^b=0011 1100  相当于b1=(a^b)^b</span><br><span class="line">a=a^b;              //a=a^b=0000 1101  相当于a1=(a^b)^((a^b)^b)</span><br></pre></td></tr></table></figure>

<p>当然，这种利用位运算的交换方法只适用于整型变量，不能用于浮点型变量!</p>
<p>利用位与 <strong>&amp;</strong> 运算，判断一个整数是否是2的整数次幂。利用这一特点，即可判断一个整数是否是2的整数次幂。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int func(int num)</span><br><span class="line">&#123;</span><br><span class="line">    return ((num &gt; 0) &amp;&amp; ((num &amp; (num - 1)) == 0));//2的n次幂大于0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回值为 1，则输入的正整数为 2 的整数次幂，返回值为 0 则不是。</p>
<p>我们将 <strong>||</strong> 和 <strong>&amp;&amp;</strong> 定义为逻辑运算符，而 <strong>|</strong> 和 <strong>&amp;</strong> 定义为位运算符。</p>
<p><strong>&amp;&amp;</strong> 如果两个操作数都非零，则条件为真；</p>
<p><strong>||</strong> 如果两个操作数中有任意一个非零，则条件为真。可以看出 &amp; 和 &amp;&amp; 在判断语句中都可以实现“和”这个功能，不过区别在于 &amp; 两边都运算，而 &amp;&amp; 先算 &amp;&amp; 左侧，若左侧为 false 那么右侧就不运算了。因此从效率上来说，判断语句中推荐使用 &amp;&amp;（换句话就是逻辑运算就老老实实用逻辑运算符，不然它为啥叫逻辑运算符呢？）</p>
<table>
<thead>
<tr>
<th><strong>&amp;</strong></th>
<th><strong>返回变量的地址。</strong></th>
<th><strong>&amp;a; 将给出变量的实际地址。</strong></th>
</tr>
</thead>
<tbody><tr>
<td>*****</td>
<td><strong>指向一个变量。</strong></td>
<td>*<strong>a; 将指向一个变量。</strong></td>
</tr>
</tbody></table>
<p>根据函数能否被其他源文件调用，将函数区分为内部函数和外部函数。</p>
<p>tips:</p>
<ul>
<li><p>对数组元素 a[i]的引用也可以写成*(a+i)这种形式。</p>
</li>
<li><p>赋值语句 p&#x3D;&amp;a[0] 也可以写成下列形式: p&#x3D;a。</p>
</li>
<li><p>p 是个指针，p[i]与*(p+i)是等价的。</p>
</li>
<li><p>&#96;&#96;&#96;<br>int a[10];</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">数组名是指向数组首个元素的指针常量，*a==a[0]，*(a+1)==a[1]，其类型应该为指向 **int** 类型的指针：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>int *;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  对数组名取地址：&amp;a，得到的应该是整个数组的地址。这时可以认为 **a** 是整个数组的变量名，对变量名进行取地址操作：&amp;，会得到该变量的地址；</span><br><span class="line"></span><br><span class="line">  操作：(&amp;a+1) 得到的是增大整个数组内存大小的地址：增大 **4\*10**。</span><br><span class="line"></span><br><span class="line">## 内部函数</span><br><span class="line"></span><br><span class="line">如果一个函数只能被本文件中其他函数所调用，它称为内部函数。在定义内部函数时，在函数名和函数类型的前面加 static，即</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>static 类型名 函数名 （形参表）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例如，函数的首行：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>static int max(int a,int b)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">内部函数又称静态函数。使用内部函数，可以使函数的作用域只局限于所在文件。即使在不同的文件中有同名的内部函数，也互不干扰。提高了程序的可靠性。</span><br><span class="line"></span><br><span class="line">## 外部函数</span><br><span class="line"></span><br><span class="line">如果在定义函数时，在函数的首部的最左端加关键字 extern，则此函数是外部函数，可供其它文件调用。</span><br><span class="line"></span><br><span class="line">如函数首部可以为</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>extern int max (int a,int b)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">C 语言规定，如果在定义函数时省略 extern，则默认为外部函数。</span><br><span class="line"></span><br><span class="line">在需要调用此函数的其他文件中，需要对此函数作声明（不要忘记，即使在本文件中调用一个函数，也要用函数原型来声明）。在对此函数作声明时，要加关键字 extern，表示该函数是在其他文件中定义的外部函数。</span><br><span class="line"></span><br><span class="line">## 实例</span><br><span class="line"></span><br><span class="line">以下实例通过多个文件的函数实现输入一串字符串，然后删除指定的字符：</span><br><span class="line"></span><br><span class="line">file1.c(文件1)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>#include &lt;stdio.h&gt;</p>
<p>static void delete_string(char str[],char ch);<br>int main()<br>{<br>    extern void enter(char str[]); &#x2F;&#x2F; 对函数的声明<br>    extern void print(char str[]); &#x2F;&#x2F; 对函数的声明<br>    char c,str[100];<br>    enter(str);<br>    scanf(“%c”,&amp;c);<br>    delete_string(str,c);<br>    print(str);<br>    return 0;<br>}</p>
<p>static void delete_string(char str[],char ch)&#x2F;&#x2F;内部函数<br>{<br>    int i,j;<br>    for(i&#x3D;j&#x3D;0;str[i]!&#x3D;’\0’;i++)<br>    if(str[i]!&#x3D;ch)<br>    str[j++]&#x3D;str[i];<br>    str[j]&#x3D;’\0’;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">file2.c(文件2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#include &lt;stdio.h&gt;</p>
<p>void enter(char str[100]) &#x2F;&#x2F; 定义外部函数 enter<br>{<br>    fgets(str, 100, stdin); &#x2F;&#x2F; 向字符数组输入字符串<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">file3.c(文件3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#include &lt;stdio.h&gt;</p>
<p>void print(char str[]) &#x2F;&#x2F; 定义外部函数 print<br>{<br>    printf(“%s\n”,str);<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输入字符串&quot;abcdef&quot;，给字符数组 str，在输入要删去的字符&#x27;d&#x27;。 运行结果:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$ gcc file1.c file2.c file3.c<br>$ .&#x2F;a.out<br>abcdef                   # 输入的字符串<br>d                        # 要删除的字符<br>abcef                    # 删除后的字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## **关于 main 函数的参数**</span><br><span class="line"></span><br><span class="line">在有些很专业的书会看到如下代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>int main( int argc, char *argv[] )</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上面的代码中 main 函数带了参数。</span><br><span class="line"></span><br><span class="line">但是有时又会看见main函数没有参数，如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>int main()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**那么 main 函数到底有没有参数，有没有参数会不会有什么影响？**</span><br><span class="line"></span><br><span class="line">main 函数其实与我们写的函数没有什么区别，它也会有自己的参数。</span><br><span class="line"></span><br><span class="line">argc 和 argv 是 main 函数的形式参数。</span><br><span class="line"></span><br><span class="line">这两个形式参数的类型是系统规定的。如果 main 函数要带参数，就是这两个类型的参数；否则main函数就没有参数。</span><br><span class="line"></span><br><span class="line">变量名称argc和argv是常规的名称，当然也可以换成其他名称。在传入参数后main函数收到参数后就会做自己的事。那么，实际参数是如何传递给main函数的argc和argv的呢？我们知道，C程序在编译和链接后，都生成一个exe文件，执行该exe文件时，可以直接执行；也可以在命令行下带参数执行，命令行执行的形式为：可执行文件名称 参数1 参数2 ... ... 参数n。可执行文件名称和参数、参数之间均使用空格隔开。</span><br><span class="line"></span><br><span class="line">如果按照这种方法执行，命令行字符串将作为实际参数传递给main函数。具体为：</span><br><span class="line"></span><br><span class="line">-  (1) 可执行文件名称和所有参数的个数之和传递给 argc；</span><br><span class="line">-  (2) 可执行文件名称（包括路径名称）作为一个字符串，首地址被赋给 argv[0]，参数1也作为一个字符串，首地址被赋给 argv[1]，... ...依次类推。</span><br><span class="line"></span><br><span class="line">## 占位符</span><br><span class="line"></span><br><span class="line">就是先占住一个固定的位置，等着你再往里面添加内容的符号，广泛用于计算机中各类文档的编辑。</span><br><span class="line"></span><br><span class="line">格式占位符(%)是在C/C++语言中格式输入函数，如 scanf、printf 等函数中使用。其意义就是起到格式占位的意思，表示在该位置有输入或者输出。</span><br><span class="line"></span><br><span class="line">-  **%d, %i** 代表整数</span><br><span class="line">-  **%f** 浮点</span><br><span class="line">-  **%s** 字符串</span><br><span class="line">-  **%c** char</span><br><span class="line">-  **%p** 指针</span><br><span class="line">-  **%fL** 长log</span><br><span class="line">-  **%e** 科学计数</span><br><span class="line">-  **%g** 小数或科学计数。</span><br><span class="line">-  **%a,%A** 读入一个浮点值(仅C99有效)。</span><br><span class="line">-  **%c** 读入一个字符。</span><br><span class="line">-  **%d** 读入十进制整数。</span><br><span class="line">-  **%i** 读入十进制，八进制，十六进制整数。</span><br><span class="line">-  **%o** 读入八进制整数。</span><br><span class="line">-  **%x,%X** 读入十六进制整数。</span><br><span class="line">-  **%s** 读入一个字符串，遇空格、制表符或换行符结束。</span><br><span class="line">-  **%f,%F,%e,%E,%g,%G** 用来输入实数，可以用小数形式或指数形式输入。</span><br><span class="line">-  **%p** 读入一个指针。</span><br><span class="line">-  **%u** 读入一个无符号十进制整数。</span><br><span class="line">-  **%n** 至此已读入值的等价字符数。</span><br><span class="line">-  **%[]** 扫描字符集合。</span><br><span class="line">-  **%%** 读 % 符号</span><br><span class="line"></span><br><span class="line">## **全局变量与局部变量在内存中的区别**：</span><br><span class="line"></span><br><span class="line">全局变量保存在内存的全局存储区中，占用静态的存储单元；</span><br><span class="line"></span><br><span class="line">局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。</span><br><span class="line"></span><br><span class="line">## 初始化局部变量和全局变量</span><br><span class="line"></span><br><span class="line">当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动对其初始化，如下所示：</span><br><span class="line"></span><br><span class="line">| 数据类型 | 初始化默认值 |</span><br><span class="line">| :------- | :----------- |</span><br><span class="line">| int      | 0            |</span><br><span class="line">| char     | &#x27;\0&#x27;         |</span><br><span class="line">| float    | 0            |</span><br><span class="line">| double   | 0            |</span><br><span class="line">| pointer  | NULL         |</span><br><span class="line"></span><br><span class="line">正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果，因为未初始化的变量会导致一些在内存位置中已经可用的垃圾值。</span><br><span class="line"></span><br><span class="line">除了函数是有作用域外，其实在 **if、for、do-while** 中也是有作用域的，若在这些语句块中初始化的话，到了其外部就无法访问。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#include &lt;stdio.h&gt;</p>
<p>int main()<br>{<br>    for (int i &#x3D; 0; i &lt; 1; i++) {<br>        int a &#x3D; 1;<br>    }<br>    if (1) {<br>        int a &#x3D; 1;<br>    }<br>    int b &#x3D; 1;<br>    while (b) {<br>        b–;<br>        int a;<br>    }<br>    switch (b) {<br>        case 0:<br>            int a &#x3D; 0;<br>            break;<br>    }<br>    do {<br>        b–;<br>        int a &#x3D; 0;<br>    } while (b &#x3D;&#x3D; 0);<br>    int c &#x3D; 0;<br>    if (1) {<br>        int c &#x3D; 10;<br>    }<br>    printf(“%d”,a);&#x2F;&#x2F;错误，提示未定义标识符a<br>    printf(“%d”, c);&#x2F;&#x2F;输出“0”<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## C 指向数组的指针</span><br><span class="line"></span><br><span class="line">数组名是一个指向数组中第一个元素的常量指针。因此，在下面的声明中：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>double balance[50];</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**balance** 是一个指向 &amp;balance[0] 的指针，即数组 balance 的第一个元素的地址。因此，下面的程序片段把 **p** 赋值为 **balance** 的第一个元素的地址：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>double *p;<br>double balance[10];</p>
<p>p &#x3D; balance;</p>
<pre><code>
使用数组名作为常量指针是合法的，反之亦然。因此，*(balance + 4) 是一种访问 balance[4] 数据的合法方式。

一旦您把第一个元素的地址存储在 p 中，您就可以使用 *p、*(p+1)、*(p+2) 等来访问数组元素。
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/13/%E7%AC%AC%E4%B8%80%E5%A4%A9-c%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/13/%E7%AC%AC%E4%B8%80%E5%A4%A9-c%E8%AF%AD%E8%A8%80/" class="post-title-link" itemprop="url">第一天 c语言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-13 14:53:57 / 修改时间：16:30:54" itemprop="dateCreated datePublished" datetime="2023-03-13T14:53:57+08:00">2023-03-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="C-中的变量声明"><a href="#C-中的变量声明" class="headerlink" title="C 中的变量声明"></a>C 中的变量声明</h2><p>变量声明向编译器保证变量以指定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。</p>
<p>变量的声明有两种情况：</p>
<ul>
<li>1、一种是需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。</li>
<li>2、另一种是不需要建立存储空间的，通过使用extern关键字声明变量名而不定义它。 例如：extern int a 其中变量 a 可以在别的文件中定义的。</li>
<li>除非有extern关键字，否则都是变量的定义。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i; <span class="comment">//声明，不是定义</span></span><br><span class="line"><span class="type">int</span> i; <span class="comment">//声明，也是定义</span></span><br></pre></td></tr></table></figure>

<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>尝试下面的实例，其中，变量在头部就已经被声明，但是定义与初始化在主函数内：</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">// 函数外定义变量 x 和 y</span><br><span class="line">int x;</span><br><span class="line">int y;</span><br><span class="line">int addtwonum()</span><br><span class="line">&#123;</span><br><span class="line">    // 函数内声明变量 x 和 y 为外部变量</span><br><span class="line">    extern int x;</span><br><span class="line">    extern int y;</span><br><span class="line">    // 给外部变量（全局变量）x 和 y 赋值</span><br><span class="line">    x = 1;</span><br><span class="line">    y = 2;</span><br><span class="line">    return x+y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int result;</span><br><span class="line">    // 调用函数 addtwonum</span><br><span class="line">    result = addtwonum();</span><br><span class="line">    </span><br><span class="line">    printf(&quot;result 为: %d&quot;,result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result 为: 3</span><br></pre></td></tr></table></figure>

<p>如果需要在一个源文件中引用另外一个源文件中定义的变量，我们只需在引用的文件中将变量加上 extern 关键字的声明即可。</p>
<h2 id="addtwonum-c-文件代码："><a href="#addtwonum-c-文件代码：" class="headerlink" title="addtwonum.c 文件代码："></a>addtwonum.c 文件代码：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">/*外部变量声明*/</span><br><span class="line">extern int x ;</span><br><span class="line">extern int y ;</span><br><span class="line">int addtwonum()</span><br><span class="line">&#123;</span><br><span class="line">    return x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="test-c-文件代码："><a href="#test-c-文件代码：" class="headerlink" title="test.c 文件代码："></a>test.c 文件代码：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">  </span><br><span class="line">/*定义两个全局变量*/</span><br><span class="line">int x=1;</span><br><span class="line">int y=2;</span><br><span class="line">int addtwonum();</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int result;</span><br><span class="line">    result = addtwonum();</span><br><span class="line">    printf(&quot;result 为: %d\n&quot;,result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc addtwonum.c test.c -o main</span><br><span class="line">$ ./main</span><br><span class="line">result 为: 3</span><br></pre></td></tr></table></figure>

<h3 id="c-x2F-c-中的lvaues-左值-和rvalues-右值"><a href="#c-x2F-c-中的lvaues-左值-和rvalues-右值" class="headerlink" title="c&#x2F;c++中的lvaues(左值)和rvalues(右值)"></a>c&#x2F;c++中的lvaues(左值)和rvalues(右值)</h3><p>lvaues本质“就是指一些对象、或者是表达式。这些对象、表达式必须代表一块内存区域”。换句话说，lvaues就是代表一块内存区域的对象(object)或者是表达式(expression)。</p>
<p> rvalues 被定义为“除了lvaues以外的所有对象、或者表达式”。其实，本质是“不能表示一块内存区域”。</p>
<p>总结：</p>
<p>1、 当需要保存数据的时候，需要lvalues。</p>
<p>2、 当需要读取数据的时候，需要rvalues。</p>
<h4 id="lvalues和rvalues角色的相互转换"><a href="#lvalues和rvalues角色的相互转换" class="headerlink" title="lvalues和rvalues角色的相互转换"></a>lvalues和rvalues角色的相互转换</h4><p>1、 根据表达式的上下文情况，lvalues在需要rvalues的地方会自动转换为rvalues。例如，</p>
<p>int n;</p>
<p>int m;</p>
<p>m &#x3D; n+2;&#x2F;&#x2F;这个表达式里n是rvalues</p>
<p>2、 rvalues永远不能转换为lvalues</p>
<p><strong>变量的内存寻址(与系统有关)</strong></p>
<p>(1)内存寻址由大到小，优先分配内存地址比较大的字节给变量，所以说变量越先定义，内存地址就越大。 如下面代码，先定义变量 a,再定义变量 b,打印出 a 的地址是 0x7fff5fbff828,b 的值是 0x7fff5fbff824。a 的地址比 b 的地址大 4 字节。栈的内存地址生长方向与堆相反，由高到底，所以后定义的变量地址低于先定义的变量，比如代码中变量 b的地址小于变量 a 的地址.</p>
<p>栈（stack）：由编译器进行管理，自动分配和释放，存放函数调用过程中的各种参数、局部变量、返回值以及函数返回地址。操作方式类似数据结构中的栈。</p>
<p>(2)变量地址的获取方式：&amp; 变量名。</p>
<p>(3)输出地址的方式：%p。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">  </span><br><span class="line">int main()   </span><br><span class="line">&#123;  </span><br><span class="line">      </span><br><span class="line">    int a;  </span><br><span class="line">    int b;  </span><br><span class="line">  </span><br><span class="line">    printf(&quot;a的地址是%p\nb的地址是%p\n&quot;,&amp;a,&amp;b);  </span><br><span class="line">    return 0;  </span><br><span class="line">     </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>(4)一个变量一定要先初始化才可以使用，因为 c 语言中默认一个没有初始化的变量值是一个不可知的很大值。如下面所示，a 没有初始化，打印出 a 的值是 -858993460。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">  </span><br><span class="line">int main()   </span><br><span class="line">&#123;  </span><br><span class="line">      </span><br><span class="line">    int a;  </span><br><span class="line">  </span><br><span class="line">    printf(&quot;a的值是%d\n&quot;,a);  </span><br><span class="line">    return 0;  </span><br><span class="line">     </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>全局变量和局部变量在内存中的区别</strong></p>
<p>全局变量保存在内存的全局存储区中，占用静态的存储单元；局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。</p>
<p>C语言经过编译之后将内存分为以下几个区域：</p>
<ul>
<li>（1）栈（stack）：由编译器进行管理，自动分配和释放，存放函数调用过程中的各种参数、局部变量、返回值以及函数返回地址。操作方式类似数据结构中的栈。</li>
<li>（2）堆（heap）：用于程序动态申请分配和释放空间。C语言中的malloc和free，C++中的new和delete均是在堆中进行的。正常情况下，程序员申请的空间在使用结束后应该释放，若程序员没有释放空间，则程序结束时系统自动回收。注意：这里的“堆”并不是数据结构中的“堆”。</li>
<li>（3）全局（静态）存储区：分为DATA段和BSS段。DATA段（全局初始化区）存放初始化的全局变量和静态变量；BSS段（全局未初始化区）存放未初始化的全局变量和静态变量。程序运行结束时自动释放。其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。</li>
<li>（4）文字常量区：存放常量字符串。程序结束后由系统释放。</li>
<li>（5）程序代码区：存放程序的二进制代码。</li>
</ul>
<p>显然，C语言中的全局变量和局部变量在内存中是有区别的。C语言中的全局变量包括外部变量和静态变量，均是保存在全局存储区中，占用永久性的存储单元；局部变量，即自动变量，保存在栈中，只有在所在函数被调用时才由系统动态在栈中分配临时性的存储单元。</p>
<p>栈的内存地址生长方向与堆相反，由高到底，所以后定义的变量地址低于先定义的变量.</p>
<p>堆的内存地址生长方向与栈相反，由低到高，但需要注意的是，后申请的内存空间并不一定在先申请的内存空间的后面，即 p2 指向的地址并不一定大于 p1 所指向的内存地址，原因是先申请的内存空间一旦被释放，后申请的内存空间则会利用先前被释放的内存，从而导致先后分配的内存空间在地址上不存在先后关系。堆中存储的数据若未释放，则其生命周期等同于程序的生命周期。</p>
<p>关于堆上内存空间的分配过程，首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序。另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确地释放本内存空间。由于找到的堆节点的大小不一定正好等于申请的大小，系统会自动地将多余的那部分重新放入空闲链表。</p>
<p><strong>变量定义：</strong>用于为变量分配存储空间，还可为变量指定初始值。程序中，变量有且仅有一个定义。</p>
<p><strong>变量声明</strong>：用于向程序表明变量的类型和名字。</p>
<p><strong>定义也是声明：</strong>当定义变量时我们声明了它的类型和名字。</p>
<p><strong>extern 声明不是定义：</strong>通过使用 extern 关键字声明变量名而不定义它。</p>
<p><strong>[注意]</strong></p>
<p>变量在使用前就要被定义或者声明。</p>
<p>在一个程序中，变量只能定义一次，却可以声明多次。</p>
<p>定义分配存储空间，而声明不会。</p>
<h2 id="堆与栈区别"><a href="#堆与栈区别" class="headerlink" title="堆与栈区别"></a>堆与栈区别</h2><p>堆与栈实际上是操作系统对进程占用的内存空间的两种管理方式，主要有如下几种区别：<br>（1）管理方式不同。栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏；</p>
<p>（2）空间大小不同。每个进程拥有的栈大小要远远小于堆大小。理论上，进程可申请的堆大小为虚拟内存大小，进程栈的大小 64bits 的 Windows 默认 1MB，64bits 的 Linux 默认 10MB；</p>
<p>（3）生长方向不同。堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低。</p>
<p>（4）分配方式不同。堆都是动态分配的，没有静态分配的堆。栈有 2 种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。动态分配由<code>alloca()</code>函数分配，但是栈的动态分配和堆是不同的，它的动态分配是由操作系统进行释放，无需我们手工实现。</p>
<p>（5）分配效率不同。栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是由C&#x2F;C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。</p>
<p>（6）存放内容不同。栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等。当主函数调用另外一个函数的时候，要对当前函数执行断点进行保存，需要使用栈来实现，首先入栈的是主函数下一条语句的地址，即扩展指针寄存器的内容（EIP），然后是当前栈帧的底部地址，即扩展基址指针寄存器内容（EBP），再然后是被调函数的实参等，一般情况下是按照从右向左的顺序入栈，之后是被调函数的局部变量，注意静态变量是存放在数据段或者BSS段，是不入栈的。出栈的顺序正好相反，最终栈顶指向主函数下一条语句的地址，主程序又从该地址开始执行。堆，一般情况堆顶使用一个字节的空间来存放堆的大小，而堆中具体存放内容是由程序员来填充的。</p>
<p>从以上可以看到，堆和栈相比，由于大量malloc()&#x2F;free()或new&#x2F;delete的使用，容易造成大量的内存碎片，并且可能引发用户态和核心态的切换，效率较低。栈相比于堆，在程序中应用较为广泛，最常见的是函数的调用过程由栈来实现，函数返回地址、EBP、实参和局部变量都采用栈的方式存放。虽然栈有众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，主要还是用堆。</p>
<p>无论是堆还是栈，在内存使用时都要防止非法越界，越界导致的非法内存访问可能会摧毁程序的堆、栈数据，轻则导致程序运行处于不确定状态，获取不到预期结果，重则导致程序异常崩溃，这些都是我们编程时与内存打交道时应该注意的问题。</p>
<p><strong>关于无符号的理解</strong></p>
<p>C语言中无符号字符型其实就是是长度为1个字节的整数，从本质上说也是整数类型，通常用来存放ASCII码。</p>
<p>整型分为无符号（unsigned）和有符号（signed）两种类型，默认整型变量是有符号的类型，char有点特别。需声明无符号类型就要在类型前加上unsigned。</p>
<p>无符号整型和有符号整型的区别在于无符号类型可以存放的正数范围比有符号整型中的范围大一倍，因为有符号类型将最高位储存符号，而无符号类型全都储存数字。</p>
<h3 id="const-关键字"><a href="#const-关键字" class="headerlink" title="const 关键字"></a>const 关键字</h3><p>您可以使用 <strong>const</strong> 前缀声明指定类型的常量，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const type variable = value;</span><br></pre></td></tr></table></figure>

<p>请注意，把常量定义为大写字母形式，是一个很好的编程习惯。</p>
<p><strong>#define</strong> 是宏定义，它不能定义常量，但宏定义可以实现在字面意义上和其它定义常量相同的功能，本质的区别就在于 <strong>#define</strong> 不为宏名分配内存，而 <strong>const</strong> 也不为常量分配内存，怎么回事呢，其实 <strong>const</strong> 并不是去定义一个常量，而是去改变一个变量的存储类，把该变量所占的内存变为只读！</p>
<p><strong>const</strong> 定义的是变量不是常量，只是这个变量的值不允许改变是常变量！带有类型。编译运行的时候起作用存在类型检查。</p>
<p><strong>define</strong> 定义的是不带类型的常数，只进行简单的字符替换。在预编译的时候起作用，不存在类型检查。</p>
<h2 id="1、两者的区别"><a href="#1、两者的区别" class="headerlink" title="1、两者的区别"></a>1、两者的区别</h2><p><strong>(1) 编译器处理方式不同</strong></p>
<ul>
<li>#define 宏是在预处理阶段展开。</li>
<li>const 常量是编译运行阶段使用。</li>
</ul>
<p><strong>(2) 类型和安全检查不同</strong></p>
<ul>
<li>#define 宏没有类型，不做任何类型检查，仅仅是展开。</li>
<li>const 常量有具体的类型，在编译阶段会执行类型检查。</li>
</ul>
<p><strong>(3) 存储方式不同</strong></p>
<ul>
<li>#define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。（宏定义不分配内存，变量定义分配内存。）</li>
<li>const常量会在内存中分配(可以是堆中也可以是栈中)。</li>
</ul>
<p><strong>(4) const 可以节省空间，避免不必要的内存分配。 例如：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define NUM 3.14159 //常量宏</span><br><span class="line">const doulbe Num = 3.14159; //此时并未将Pi放入ROM中 ......</span><br><span class="line">double i = Num; //此时为Pi分配内存，以后不再分配！</span><br><span class="line">double I= NUM; //编译期间进行宏替换，分配内存</span><br><span class="line">double j = Num; //没有内存分配</span><br><span class="line">double J = NUM; //再进行宏替换，又一次分配内存！</span><br></pre></td></tr></table></figure>

<p>const 定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象 #define 一样给出的是立即数，所以，const 定义的常量在程序运行过程中只有一份拷贝（因为是全局的只读变量，存在静态区），而 #define 定义的常量在内存中有若干个拷贝。</p>
<p><strong>(5) 提高了效率。 编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。</strong></p>
<p><strong>(6) 宏替换只作替换，不做计算，不做表达式求解;</strong></p>
<p>宏预编译时就替换了，程序运行时，并不分配内存。</p>
<p><strong>注：</strong></p>
<p>define 注意“边缘效应”，例：**#define N 2+3**, N 的值是 5。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double a;</span><br><span class="line">a = (float)N/(float)2;</span><br></pre></td></tr></table></figure>

<p>在编译时我们预想 <strong>a&#x3D;2.5</strong>，实际打印结果是 <strong>3.5</strong> 原因是在预处理阶段，编译器将 <strong>a&#x3D;N&#x2F;2</strong> 处理成 <strong>a&#x3D;2+3&#x2F;2</strong>，这就是 <strong>define</strong> 宏的边缘效应，所以我们应该写成 **#define N (2+3)**。</p>
<p><strong>小记：</strong>在 C 语言中，单引号与双引号是有很大区别的。</p>
<p>在 C 语言中没有专门的字符串类型，因此双引号内的字符串会被存储到一个数组中，这个字符串代表指向这个数组起始字符的指针；</p>
<p>而单引号中的内容是一个 char 类型，是一个字符，这个字符对应的是 ASCII 表中的序列值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/12/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github-hexo%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/12/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github-hexo%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2/" class="post-title-link" itemprop="url">如何使用github/hexo发布博客</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-12 16:33:26 / 修改时间：16:49:10" itemprop="dateCreated datePublished" datetime="2023-03-12T16:33:26+08:00">2023-03-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="date-2023-03-12-16-33-26"><a href="#date-2023-03-12-16-33-26" class="headerlink" title="date: 2023-03-12 16:33:26"></a>date: 2023-03-12 16:33:26</h2><p>tags:执行hexo n “如何使用github&#x2F;hexo发布博客” ，就会在blog&#x2F;source&#x2F;_posts路径下生成一个md文件，用markdown工具编辑好之后，御三套（<br><strong>hexo clean</strong><br><strong>hexo g</strong><br><strong>hexo d</strong>）走一波就可以你写的内容啦</p>
<p>使用“—</p>
<p>标题</p>
<p>—”命名标题</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/12/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/12/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-12 14:51:48" itemprop="dateCreated datePublished" datetime="2023-03-12T14:51:48+08:00">2023-03-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">肖汇林</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">肖汇林</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
