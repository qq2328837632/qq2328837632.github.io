<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="选择有时候比努力更重要">
<meta property="og:type" content="website">
<meta property="og:title" content="肖汇林的博客">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="肖汇林的博客">
<meta property="og:description" content="选择有时候比努力更重要">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="肖汇林">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>肖汇林的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖汇林的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">Linux进程相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-01 21:35:45" itemprop="dateCreated datePublished" datetime="2023-06-01T21:35:45+08:00">2023-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-17 15:19:14" itemprop="dateModified" datetime="2023-06-17T15:19:14+08:00">2023-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="进程和程序以及-CPU-相关"><a href="#进程和程序以及-CPU-相关" class="headerlink" title="进程和程序以及 CPU 相关"></a>进程和程序以及 CPU 相关</h2><p>进程：<br>        程序：死的。只占用磁盘空间。 ——剧本。<br>        进程；活的。运行起来的程序。占用内存、cpu 等系统资源。 ——戏。<br>并发和并行：并行是宏观上并发，微观上串行</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230601213825110.png" alt="image-20230601213825110"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230601213825110.png" class title="This is an test image">

<h2 id="虚拟内存和物理内存映射关系"><a href="#虚拟内存和物理内存映射关系" class="headerlink" title="虚拟内存和物理内存映射关系"></a>虚拟内存和物理内存映射关系</h2><p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230601215722575.png" alt="image-20230601215722575"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230601215722575.png" class title="This is an test image">

<p>Linux下只有两级。从用户空间到内核空间进的时候，需要借助mmu，帮助完成全级切换。</p>
<h2 id="pcb-进程控制块"><a href="#pcb-进程控制块" class="headerlink" title="pcb 进程控制块"></a>pcb 进程控制块</h2><p>PCB 进程控制块：进程 id<br>文件描述符表<br>进程状态： 初始态、就绪态、运行态、挂起态、终止态。<br>进程工作目录位置<br>*umask 掩码 （进程的概念）<br>信号相关信息资源。<br>用户 id 和组 id<br>ps aux 返回结果里，第二列是进程 id</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609212449400.png" alt="image-20230609212449400"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609212449400.png" class title="This is an test image">

<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH 查看环境变量</span><br><span class="line">path 环境变量里记录了一系列的值，当运行一个可执行文件时，系统会去环境变量记录的位置里查</span><br><span class="line">找这个文件并执行。</span><br><span class="line">echo $TERM 查看终端</span><br><span class="line">echo $LANG 查看语言</span><br><span class="line">env 查看所有环境变量</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="fork-函数原理"><a href="#fork-函数原理" class="headerlink" title="fork 函数原理"></a>fork 函数原理</h2><p>fork 函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pid_t fork(void)</span><br><span class="line">创建子进程。父子进程各自返回。父进程返回子进程 pid。 子进程返回 0.</span><br><span class="line">getpid();getppid();</span><br><span class="line">循环创建 N 个子进程模型。 每个子进程标识自己的身份。</span><br></pre></td></tr></table></figure>

<p>父子进程相同： 刚 fork 后。 data 段、text 段、堆、栈、环境变量、全局变量、宿主目录位置、进程工作目录位 置、信号处理方式</p>
<p>父子进程不同： 进程 id、返回值、各自的父进程、进程创建时间、闹钟、未决信号集</p>
<p>父子进程共享： 读时共享、写时复制。———————— 全局变量。 1. 文件描述符 2. mmap 映射区</p>
<h2 id="fork-创建子进程"><a href="#fork-创建子进程" class="headerlink" title="fork 创建子进程"></a>fork 创建子进程</h2><p>下面是一个 fork 函数的例子，代码如下：</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609212838706.png" alt="image-20230609212838706"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609212838706.png" class title="This is an test image">

<p>fork 之前的代码，父子进程都有，但是只有父进程执行了，子进程没有执行，fork 之后的代码，父子进程都有机会执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">两个函数：</span><br><span class="line">pid_t getpid() 获取当前进程 id</span><br><span class="line">pid_t getppid() 获取当前进程的父进程 id</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609212951089.png" alt="image-20230609212951089"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609212951089.png" class title="This is an test image">

<h2 id="循环创建多个子进程"><a href="#循环创建多个子进程" class="headerlink" title="循环创建多个子进程"></a>循环创建多个子进程</h2><p>所以，直接用个 for 循环是要出事情的，因为子进程也会 fork 新的进程 这里，对调用 fork 的进程进行判定，只让父进程 fork 新的进程就行，代码如下：</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609213428815.png" alt="image-20230609213428815"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609213428815.png" class title="This is an test image">

<p>出现了问题：进程多了一个，而且不是按顺序来的。这里多出的一个，是父进程，因为父进程才有 i&#x3D;5 跳出循环这一步。所以，对父进程进行判定并处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(i=5)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;parent&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">	printf(&quot;..&quot;,i+1);</span><br></pre></td></tr></table></figure>

<p>现在还有两个问题，<br>    一个就是包括父进程在内的所有进程不是按顺序出现，多运行几次，发现是随机序列出现的。这<br>是要因为，对操作系统而言，这几个子进程几乎是同时出现的，它们和父进程一起争夺 cpu，谁抢到，<br>谁打印，所以出现顺序是随机的。<br>    第二问题就是终端提示符混在了输出里，这个是因为，loop_fork 是终端的子进程，一旦<br>loop_fork 执行完，终端就会打印提示符。就像之前没有子进程的程序，一旦执行完，就出现了终端<br>提示符。这里也就是这个道理，loop_fork 执行完了，终端提示符出现，然而 loop_fork 的子进程还<br>没执行完，所以输出就混在一起了。</p>
<p>通过 sleep 延时来解决父进程先结束这个问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(i=5)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;parent&quot;);</span><br><span class="line">	sleep(1);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">	printf(&quot;..&quot;,i+1);</span><br></pre></td></tr></table></figure>

<p>最后来解决子进程乱序输出的问题，解决方法很简单，让第 1 个子进程少等，第二个子进程多等， 后面子进程等待时间依次增加，这样就能实现有序输出。</p>
<h2 id="父子进程共享哪些内容"><a href="#父子进程共享哪些内容" class="headerlink" title="父子进程共享哪些内容"></a>父子进程共享哪些内容</h2><p>父子进程相同： 刚 fork 后。 data 段、text 段、堆、栈、环境变量、全局变量、宿主目录位置、进程工作目录位 置、信号处理方式</p>
<p>父子进程不同： 进程 id、返回值、各自的父进程、进程创建时间、闹钟、未决信号集</p>
<p>父子进程共享： 读时共享、写时复制。———————— 全局变量。如果只是读，则公用一个地址，写，则复制一份，不一起。</p>
<ol>
<li>文件描述符 2. mmap 映射区</li>
</ol>
<h2 id="父子进程-gdb-调试"><a href="#父子进程-gdb-调试" class="headerlink" title="父子进程 gdb 调试"></a>父子进程 gdb 调试</h2><p>gdb 调试：<br>设置父进程调试路径：set follow-fork-mode parent (默认)<br>设置子进程调试路径：set follow-fork-mode child<br>注意，一定要在 fork 函数调用之前设置才有效。</p>
<h2 id="exec-函数族"><a href="#exec-函数族" class="headerlink" title="exec 函数族"></a>exec 函数族</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">exec 函数族：</span><br><span class="line">使进程执行某一程序。成功无返回值，失败返回 -1</span><br><span class="line">int execlp(const char *file, const char *arg, ...); 借助 PATH 环境变量找寻待执</span><br><span class="line">行程序</span><br><span class="line">参 1： 程序名</span><br><span class="line">参 2： argv0</span><br><span class="line">参 3： argv1</span><br><span class="line">...： argvN</span><br><span class="line">哨兵：NULL</span><br><span class="line">int execl(const char *path, const char *arg, ...); 自己指定待执行程序路径。</span><br><span class="line">int execvp();</span><br><span class="line">ps ajx --&gt; pid ppid gid sid</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>fork创建子进程后执行的是和父进程相同的程序（但有可能执行不同的代码分支)，子进程往往要调用一种 exec函数以执行另一个程序。当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用exec并不创建新进程，所以调用exec前后该进程的id并未改变。<br>将当前进程的.text、.data替换为所要加载的程序的.text、.data，然后让进程从新的.text第一条指令开始执行，但进程ID不变，换核不换壳。即exec后面的子进程代码不执行了，因为进入了新的程序。</p>
<h3 id="execlp-和-ececl-函数"><a href="#execlp-和-ececl-函数" class="headerlink" title="execlp 和 ececl 函数"></a>execlp 和 ececl 函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int execlp(const char *file, const char *arg, …)</span><br><span class="line">成功，无返回，失败返回-1</span><br><span class="line">参数 1：要加载的程序名字，该函数需要配合 PATH 环境变量来使用，当 PATH 所有目录搜素后没</span><br><span class="line">有参数 1 则返回出错。</span><br><span class="line">该函数通常用来调用系统程序。如 ls、date、cp、cat 命令。</span><br><span class="line">execlp 这里面的 p，表示要借助环境变量来加载可执行文件</span><br></pre></td></tr></table></figure>

<p>示例代码，通过 execlp 让子进程去执行 ls 命令：</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215110094.png" alt="image-20230610215110094"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215110094.png" class title="This is an test image">

<p>只有父进程正确执行并输出了，子进程的 ls 输出有问题。 问题出在参数上，可变参数那里，是从 argv[0]开始计算的。 修改代码，就是将缺失的 argv[0]补上，然后让父进程延时 1 秒，保证终端提示符不和输出干扰。如 下：</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215242121.png" alt="image-20230610215242121"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215242121.png" class title="This is an test image">

<p>下面使用 execl 来让子程序调用自定义的程序。 int execl(const char *path, const char *arg, …) 这里要注意，和 execlp 不同的是，第一个参数是路径，不是文件名。 这个路径用相对路径和绝对路径都行。</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215316774.png" alt="image-20230610215316774"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215316774.png" class title="This is an test image">

<p>用 execl 也能执行 ls 这些，把路径给出来就行，但是这样麻烦，所以对于系统指令一般还是用 execlp</p>
<h2 id="exec-函数族特性"><a href="#exec-函数族特性" class="headerlink" title="exec 函数族特性"></a>exec 函数族特性</h2><p>写一个程序，使用 execlp 执行进程查看，并将结果输出到文件里。 要用到 open, execlp, dup2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">        int fd;</span><br><span class="line">        fd = open( &quot;ps.out&quot;, O_WRONLY|O_CREAT|O_TRUNC,0644);</span><br><span class="line">        if(fd &lt; 0)&#123;</span><br><span class="line">                perror(&quot;open ps.out error&quot;);</span><br><span class="line">                exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        dup2(fd,STDOUT_FILENO);</span><br><span class="line">        execlp(&quot;ps&quot;,&quot;ps&quot;,&quot;aux&quot;,NULL);</span><br><span class="line">        close(fd); //have no need to</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>exec 函数族一般规律： </p>
<p>exec 函数一旦调用成功，即执行新的程序，不返回。只有失败才返回，错误值-1，所以通常我们直接在 exec 函数调用后直接调用 perror()，和 exit()，无需 if 判断。</p>
<p>事实上，只有 execve 是真正的系统调用，其他 5 个函数最终都调用 execve，是库函数，所以 execve 在 man 手册第二节，其它函数在 man 手册第 3 节。</p>
<h2 id="孤儿进程和僵尸进程"><a href="#孤儿进程和僵尸进程" class="headerlink" title="孤儿进程和僵尸进程"></a>孤儿进程和僵尸进程</h2><p>孤儿进程：<br>父进程先于子进终止，子进程沦为“孤儿进程”，会被 init 进程领养。<br>僵尸进程：<br>子进程终止，父进程尚未对子进程进行回收，在此期间，子进程为“僵尸进程”。 kill 对其<br>无效。这里要注意，每个进程结束后都必然会经历僵尸态，时间长短的差别而已。<br>子进程终止时，子进程残留资源 PCB 存放于内核中，PCB 记录了进程结束原因，进程回收就是回<br>收 PCB。回收僵尸进程，得 kill 它的父进程，让孤儿院去回收它。</p>
<h2 id="wait-回收子进程"><a href="#wait-回收子进程" class="headerlink" title="wait 回收子进程"></a>wait 回收子进程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">wait 函数： 回收子进程退出资源， 阻塞回收任意一个。</span><br><span class="line">pid_t wait(int *status)</span><br><span class="line">参数：（传出） 回收进程的状态。</span><br><span class="line">返回值：成功： 回收进程的 pid</span><br><span class="line">失败： -1， errno</span><br><span class="line">函数作用 1： 阻塞等待子进程退出</span><br><span class="line">函数作用 2： 清理子进程残留在内核的 pcb 资源</span><br><span class="line">函数作用 3： 通过传出参数，得到子进程结束状态</span><br><span class="line">获取子进程正常终止值：</span><br><span class="line">WIFEXITED(status) --》 为真 --》调用 WEXITSTATUS(status) --》 得到 子进程 退出值。</span><br><span class="line">获取导致子进程异常终止信号：</span><br><span class="line">WIFSIGNALED(status) --》 为真 --》调用 WTERMSIG(status) --》 得到 导致子进程异常</span><br><span class="line">终止的信号编号。</span><br><span class="line">一个进程终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的 PCB 还保留着，内</span><br><span class="line">核在其中保存了一些信息：如果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程</span><br><span class="line">终止的信号是哪个。这个进程的父进程可以调用 wait 或者 waitpid 获取这些信息，然后彻底清除掉</span><br><span class="line">这个进程。我们知道一个进程的退出状态可以在 shell 中用特殊变量$？查看，因为 shell 是它的父</span><br><span class="line">进程，当它终止时，shell 调用 wait 或者 waitpid 得到它的退出状态，同时彻底清除掉这个进程。</span><br><span class="line">pid_t wait(int *status)</span><br><span class="line">其中 status 是传出参数</span><br></pre></td></tr></table></figure>

<p>下面这个例子，使用 wait 来阻塞回收子进程</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215813155.png" alt="image-20230610215813155"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215813155.png" class title="This is an test image">

<h2 id="获取子进程退出值和异常终止信号"><a href="#获取子进程退出值和异常终止信号" class="headerlink" title="获取子进程退出值和异常终止信号"></a>获取子进程退出值和异常终止信号</h2><p>获取子进程正常终止值：<br>WIFEXITED(status) –》 为真 –》调用 WEXITSTATUS(status) –》 得到 子进程 退出值。<br>获取导致子进程异常终止信号：<br>WIFSIGNALED(status) –》 为真 –》调用 WTERMSIG(status) –》 得到 导致子进程异常<br>终止的信号编号。</p>
<p>下面这个代码捕获程序异常终止的信号并打印：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;unistd.h&gt;</span><br><span class="line">4. #include &lt;sys/wait.h&gt;</span><br><span class="line">5.</span><br><span class="line">6. int main(void)</span><br><span class="line">7. &#123;</span><br><span class="line">8. pid_t pid, wpid;</span><br><span class="line">9. int status;</span><br><span class="line">10.</span><br><span class="line">11. pid = fork();</span><br><span class="line">12. if (pid == 0) &#123;</span><br><span class="line">13. printf(&quot;---child, my id= %d, going to sleep 10s\n&quot;, getpid());</span><br><span class="line">14. sleep(10);</span><br><span class="line">15. printf(&quot;-------------child die--------------\n&quot;);</span><br><span class="line">16. return 73;</span><br><span class="line">17. &#125; else if (pid &gt; 0) &#123;</span><br><span class="line">18. //wpid = wait(NULL); // 不关心子进程结束原因</span><br><span class="line">19. wpid = wait(&amp;status); // 如果子进程未终止,父进程阻塞在这个函数上</span><br><span class="line">20. if (wpid == -1) &#123;</span><br><span class="line">21. perror(&quot;wait error&quot;);</span><br><span class="line">22. exit(1);</span><br><span class="line">23. &#125;</span><br><span class="line">24. if (WIFEXITED(status)) &#123; //为真,说明子进程正常终止.</span><br><span class="line">25. printf(&quot;child exit with %d\n&quot;, WEXITSTATUS(status));</span><br><span class="line">26.</span><br><span class="line">27. &#125;</span><br><span class="line">28. if (WIFSIGNALED(status)) &#123; //为真,说明子进程是被信号终止.</span><br><span class="line">29.</span><br><span class="line">30. printf(&quot;child kill with signal %d\n&quot;, WTERMSIG(status));</span><br><span class="line">31. &#125;</span><br><span class="line">32.</span><br><span class="line">33. printf(&quot;------------parent wait finish: %d\n&quot;, wpid);</span><br><span class="line">34. &#125; else &#123;</span><br><span class="line">35. perror(&quot;fork&quot;);</span><br><span class="line">36. return 1;</span><br><span class="line">37. &#125;</span><br><span class="line">38.</span><br><span class="line">39. return 0;</span><br><span class="line">40. &#125;</span><br></pre></td></tr></table></figure>

<p>下面发送信号使得子进程异常退出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 id</span><br></pre></td></tr></table></figure>

<h2 id="waitpid-回收子进程"><a href="#waitpid-回收子进程" class="headerlink" title="waitpid 回收子进程"></a>waitpid 回收子进程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">waitpid 函数： 指定某一个进程进行回收。可以设置非阻塞。</span><br><span class="line">waitpid(-1, &amp;status, 0) == wait(&amp;status);</span><br><span class="line">	pid_t waitpid(pid_t pid, int *status, int options)</span><br><span class="line">	参数：</span><br><span class="line">		pid：指定回收某一个子进程 pid</span><br><span class="line">		&gt; 0: 待回收的子进程 pid</span><br><span class="line">		-1：任意子进程</span><br><span class="line">		0：同组的子进程。</span><br><span class="line">		status：（传出） 回收进程的状态。</span><br><span class="line">		options：WNOHANG 指定回收方式为，非阻塞。</span><br><span class="line">	返回值：</span><br><span class="line">		&gt; 0 : 表成功回收的子进程 pid</span><br><span class="line">		0 : 函数调用时， 参 3 指定了 WNOHANG， 并且，没有子进程结束。</span><br><span class="line">		-1: 失败。errno</span><br><span class="line">	一次 wait/waitpid 函数调用，只能回收一个子进程。上一个例子，父进程产生了 5 个子进程，wait 会随机回收一个，捡到哪个算哪个。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ps ajx –&gt; pid ppid gid sid</p>
<p>在演示回收指定子进程的代码时出了问题，这里问题原因在于指定子进程的 pid 传递。父进程里 的 pid 变量和子进程 pid 变量并不是同一个。子进程结束时，父进程的 pid 还是原来的 0。 </p>
<p>原来的代码没有使用 fork 的返回值，导致父进程没有得到指定回收子进程的 pid。</p>
<p>默认情况下，父进程 fork 出来的子进程都属于同一个组。</p>
<p>错误代码如下图所示，它不能回收指定的第 3 个子进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">1. //指定回收一个子进程错误示例</span><br><span class="line">2. #include &lt;stdio.h&gt;</span><br><span class="line">3. #include &lt;stdlib.h&gt;</span><br><span class="line">4. #include &lt;string.h&gt;</span><br><span class="line">5. #include &lt;unistd.h&gt;</span><br><span class="line">6. #include &lt;sys/wait.h&gt;</span><br><span class="line">7. #include &lt;pthread.h&gt;</span><br><span class="line">8.</span><br><span class="line">9. int main(int argc, char *argv[])</span><br><span class="line">10. &#123;</span><br><span class="line">11. int i;</span><br><span class="line">12. pid_t pid, wpid;</span><br><span class="line">13.</span><br><span class="line">14. for (i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">15. if (fork() == 0) &#123; // 循环期间, 子进程不 fork</span><br><span class="line">16. if (i == 2) &#123;</span><br><span class="line">17. pid = getpid();</span><br><span class="line">18. printf(&quot;------pid = %d\n&quot;, pid);</span><br><span class="line">19. &#125;</span><br><span class="line">20. break;</span><br><span class="line">21. &#125;</span><br><span class="line">22. &#125;</span><br><span class="line">23.</span><br><span class="line">24. if (5 == i) &#123; // 父进程, 从 表达式 2 跳出</span><br><span class="line">25. sleep(5);</span><br><span class="line">26.</span><br><span class="line">27. //wait(NULL); // 一次 wait/waitpid 函数调用,只能回收一个子进程.</span><br><span class="line">28. //wpid = waitpid(-1, NULL, WNOHANG); //回收任意子进程,没有结束的子进程,父进程直接返回 0</span><br><span class="line">29. //wpid = waitpid(pid, NULL, WNOHANG); //指定一个进程回收</span><br><span class="line">30.</span><br><span class="line">31. printf(&quot;------in parent , before waitpid, pid= %d\n&quot;, pid);</span><br><span class="line">32. wpid = waitpid(pid, NULL, 0); //指定一个进程回收，这里因为是进的父进程，没有pid的值</span><br><span class="line">33. if (wpid == -1) &#123;</span><br><span class="line">34. perror(&quot;waitpid error&quot;);</span><br><span class="line">35. exit(1);</span><br><span class="line">36. &#125;</span><br><span class="line">37. printf(&quot;I&#x27;m parent, wait a child finish : %d \n&quot;, wpid);</span><br><span class="line">38.</span><br><span class="line">39. &#125; else &#123; // 子进程, 从 break 跳出</span><br><span class="line">40. sleep(i);</span><br><span class="line">41. printf(&quot;I&#x27;m %dth child, pid= %d\n&quot;, i+1, getpid());</span><br><span class="line">42. &#125;</span><br><span class="line">43.</span><br><span class="line">44. return 0;</span><br><span class="line">45. &#125;</span><br></pre></td></tr></table></figure>

<p>这个代码错误如之前所述，父进程里的 pid 还是 0，因为父进程里没有获取指定子进程的 pid， 于是父进程里的 pid 还保持默认值。</p>
<p>下面是正确的示例，循环 fork 出 5 个子进程，并回收指定的子进程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;sys/wait.h&gt;</span><br><span class="line">6. #include &lt;pthread.h&gt;</span><br><span class="line">7.</span><br><span class="line">8.</span><br><span class="line">9. int main(int argc, char *argv[])</span><br><span class="line">10. &#123;</span><br><span class="line">11. int i;</span><br><span class="line">12. pid_t pid, wpid, tmpid;</span><br><span class="line">13.</span><br><span class="line">14. for (i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">15. pid = fork();</span><br><span class="line">16. if (pid == 0) &#123; // 循环期间, 子进程不 fork</span><br><span class="line">17. break;</span><br><span class="line">18. &#125;</span><br><span class="line">19. if (i == 2) &#123;//这里是父进程</span><br><span class="line">20. tmpid = pid;</span><br><span class="line">21. printf(&quot;--------pid = %d\n&quot;, tmpid);</span><br><span class="line">22. &#125;</span><br><span class="line">23. &#125;</span><br><span class="line">24.</span><br><span class="line">25. if (5 == i) &#123; // 父进程, 从 表达式 2 跳出</span><br><span class="line">26. // sleep(5);</span><br><span class="line">27.</span><br><span class="line">28. //wait(NULL); // 一次 wait/waitpid 函数调用,只能回收一个子进程.</span><br><span class="line">29. //wpid = waitpid(-1, NULL, WNOHANG); //回收任意子进程,没有结束的子进程,父进程直接返回 0</span><br><span class="line">30. //wpid = waitpid(tmpid, NULL, 0); //指定一个进程回收, 阻塞等待</span><br><span class="line">31. printf(&quot;i am parent , before waitpid, pid = %d\n&quot;, tmpid);</span><br><span class="line">32.</span><br><span class="line">33. //wpid = waitpid(tmpid, NULL, WNOHANG); //指定一个进程回收, 不阻塞</span><br><span class="line">34. wpid = waitpid(tmpid, NULL, 0); //指定一个进程回收, 阻塞回收</span><br><span class="line">35. if (wpid == -1) &#123;</span><br><span class="line">36. perror(&quot;waitpid error&quot;);</span><br><span class="line">37. exit(1);</span><br><span class="line">38. &#125;</span><br><span class="line">39. printf(&quot;I&#x27;m parent, wait a child finish : %d \n&quot;, wpid);</span><br><span class="line">40.</span><br><span class="line">41. &#125; else &#123; // 子进程, 从 break 跳出</span><br><span class="line">42. sleep(i);</span><br><span class="line">43. printf(&quot;I&#x27;m %dth child, pid= %d\n&quot;, i+1, getpid());</span><br><span class="line">44. &#125;</span><br><span class="line">45.</span><br><span class="line">46. return 0;</span><br><span class="line">47. &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>指定回收的第三个进程，就回收的第三个。这里实现由两种，一个是阻塞等待回收指定 进程，一个是非阻塞，但是用 sleep 延时父进程，以保证待回收的指定子进程已经执行结束。上面这 个代码使用的阻塞回收，这个方案的问题在于终端提示符会和输出混杂在一起。使用非阻塞回收 +延时的方法，这样终端提示符就不会混在输出里。</p>
<h2 id="waitpid-回收多个子进程"><a href="#waitpid-回收多个子进程" class="headerlink" title="waitpid 回收多个子进程"></a>waitpid 回收多个子进程</h2><p>一次 wait&#x2F;waitpid 函数调用，只能回收一个子进程。上一个例子，父进程产生了 5 个子进程， wait 会随机回收一个，捡到哪个算哪个</p>
<p>总结： wait、waitpid 一次调用，回收一个子进程。 想回收多个。while</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if (5 == i) &#123; // 父进程, 从 表达式 2 跳出</span><br><span class="line"> 	/* </span><br><span class="line"> 	while ((wpid = waitpid(-1, NULL, 0))) &#123; // 使用阻塞方式回收子进程</span><br><span class="line">		printf(&quot;wait child %d \n&quot;, wpid);</span><br><span class="line">	&#125;</span><br><span class="line">	*/</span><br><span class="line">	while ((wpid = waitpid(-1, NULL, WNOHANG)) != -1) &#123; //使用非阻塞方式,回收子进程.</span><br><span class="line">		if (wpid &gt; 0) &#123;</span><br><span class="line">			printf(&quot;wait child %d \n&quot;, wpid);</span><br><span class="line">		&#125; else if (wpid == 0) &#123;</span><br><span class="line">			sleep(1);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程间通信常见方式"><a href="#进程间通信常见方式" class="headerlink" title="进程间通信常见方式"></a>进程间通信常见方式</h2><p>IPC(InterProcess Communication)进程间通信</p>
<p>进程间通信的常用方式，特征： </p>
<p>管道：简单 </p>
<p>信号：开销小 </p>
<p>mmap 映射：非血缘关系进程间 </p>
<p>socket（本地套接字）：稳定</p>
<h2 id="管道的特质"><a href="#管道的特质" class="headerlink" title="管道的特质"></a>管道的特质</h2><p>管道：<br>实现原理： 内核借助环形队列机制，使用内核缓冲区实现。<br>特质； </p>
<p>​	1. 伪文件</p>
<ol start="2">
<li>管道中的数据只能一次读取。</li>
<li>数据在管道中，只能单向流动。</li>
</ol>
<p>局限性：</p>
<ol>
<li>自己写，不能自己读。</li>
<li>数据不可以反复读。</li>
<li>半双工通信。</li>
<li>血缘关系进程间可用。</li>
</ol>
<h2 id="管道的基本用法"><a href="#管道的基本用法" class="headerlink" title="管道的基本用法"></a>管道的基本用法</h2><p>pipe 函数： 创建，并打开管道。<br>    int pipe(int fd[2]);<br>        参数： fd[0]: 读端。<br>                    fd[1]: 写端。<br>        返回值： 成功： 0<br>                        失败： -1 errno</p>
<p>一个管道通信的示例，父进程往管道里写，子进程从管道读，然后打印读取的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;errno.h&gt;</span><br><span class="line">6. #include &lt;pthread.h&gt;</span><br><span class="line">7.</span><br><span class="line">8. void sys_err(const char *str)</span><br><span class="line">9. &#123;</span><br><span class="line">10. perror(str);</span><br><span class="line">11. exit(1);</span><br><span class="line">12. &#125;</span><br><span class="line">13.</span><br><span class="line">14. int main(int argc, char *argv[])</span><br><span class="line">15. &#123;</span><br><span class="line">16. int ret;</span><br><span class="line">17. int fd[2];</span><br><span class="line">18. pid_t pid;</span><br><span class="line">19.</span><br><span class="line">20. char *str = &quot;hello pipe\n&quot;;</span><br><span class="line">21. char buf[1024];</span><br><span class="line">22.</span><br><span class="line">23. ret = pipe(fd);</span><br><span class="line">24. if (ret == -1)</span><br><span class="line">25. sys_err(&quot;pipe error&quot;);</span><br><span class="line">26.</span><br><span class="line">27. pid = fork();</span><br><span class="line">28. if (pid &gt; 0) &#123;</span><br><span class="line">29. close(fd[0]); // 父进程关闭读段</span><br><span class="line">30. //sleep(3);</span><br><span class="line">31. write(fd[1], str, strlen(str));</span><br><span class="line">32. close(fd[1]);</span><br><span class="line">33. &#125; else if (pid == 0) &#123;</span><br><span class="line">34. close(fd[1]); // 子进程关闭写段</span><br><span class="line">35. ret = read(fd[0], buf, sizeof(buf));</span><br><span class="line">36. printf(&quot;child read ret = %d\n&quot;, ret);</span><br><span class="line">37. write(STDOUT_FILENO, buf, ret);</span><br><span class="line">38.</span><br><span class="line">39. close(fd[0]);</span><br><span class="line">40. &#125;</span><br><span class="line">41.</span><br><span class="line">42. return 0;</span><br><span class="line">43. &#125;</span><br></pre></td></tr></table></figure>

<h2 id="管道读写行为"><a href="#管道读写行为" class="headerlink" title="管道读写行为"></a>管道读写行为</h2><p>管道的读写行为：<br>读管道：</p>
<ol>
<li>管道有数据，read 返回实际读到的字节数。</li>
<li>管道无数据： 1）无写端，read 返回 0 （类似读到文件尾）<br> 2）有写端，read 阻塞等待。</li>
</ol>
<p>写管道：</p>
<ol>
<li>无读端， 异常终止。 （SIGPIPE 导致的）</li>
<li>有读端： 1） 管道已满， 阻塞等待<br> 2） 管道未满， 返回写出的字节个数。</li>
</ol>
<p>普通文件，目录，软链接，这三个要占磁盘空间 </p>
<p>管道，套接字，字符设备，块设备，不占磁盘空间，伪文件</p>
<p>磁盘访问需要open和read,内存访问用地址，即使用指针访问。</p>
<h2 id="父子进程-lswc-l"><a href="#父子进程-lswc-l" class="headerlink" title="父子进程 lswc-l"></a>父子进程 lswc-l</h2><p>练习：使用管道实现父子进程间通信，完成：ls | wc -l 假定父进程实现 ls，子进程实现 wc<br>ls 命令正常会将结果集写到 stdout，但现在会写入管道写端<br>wc -l 命令正常应该从 stdin 读取数据，但此时会从管道的读端读。<br>要用到 pipe dup2 exec<br>代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;errno.h&gt;</span><br><span class="line">6. #include &lt;pthread.h&gt;</span><br><span class="line">7.</span><br><span class="line">8. void sys_err(const char *str)</span><br><span class="line">9. &#123;</span><br><span class="line">10. perror(str);</span><br><span class="line">11. exit(1);</span><br><span class="line">12. &#125;</span><br><span class="line">13. int main(int argc, char *argv[])</span><br><span class="line">14. &#123;</span><br><span class="line">15. int fd[2];</span><br><span class="line">16. int ret;</span><br><span class="line">17. pid_t pid;</span><br><span class="line">18.</span><br><span class="line">19. ret = pipe(fd); // 父进程先创建一个管道,持有管道的读端和写端</span><br><span class="line">20. if (ret == -1) &#123;</span><br><span class="line">21. sys_err(&quot;pipe error&quot;);</span><br><span class="line">22. &#125;</span><br><span class="line">23.</span><br><span class="line">24. pid = fork(); // 子进程同样持有管道的读和写端</span><br><span class="line">25. if (pid == -1) &#123;</span><br><span class="line">26. sys_err(&quot;fork error&quot;);</span><br><span class="line">27. &#125;</span><br><span class="line">28. else if (pid &gt; 0) &#123; // 父进程 读, 关闭写端</span><br><span class="line">29. close(fd[1]);</span><br><span class="line">30. dup2(fd[0], STDIN_FILENO); // 重定向 stdin 到 管道的 读端</span><br><span class="line">31. execlp(&quot;wc&quot;, &quot;wc&quot;, &quot;-l&quot;, NULL); // 执行 wc -l 程序</span><br><span class="line">32. sys_err(&quot;exclp wc error&quot;);</span><br><span class="line">33. &#125;</span><br><span class="line">34. else if (pid == 0) &#123;</span><br><span class="line">35. close(fd[0]);</span><br><span class="line">36. dup2(fd[1], STDOUT_FILENO); // 重定向 stdout 到 管道写端</span><br><span class="line">37. execlp(&quot;ls&quot;, &quot;ls&quot;, NULL); // 子进程执行 ls 命令</span><br><span class="line">38. sys_err(&quot;exclp ls error&quot;);</span><br><span class="line">39. &#125;</span><br><span class="line">40.</span><br><span class="line">41. return 0;</span><br><span class="line">42. &#125;</span><br></pre></td></tr></table></figure>

<h2 id="兄弟进程间通信"><a href="#兄弟进程间通信" class="headerlink" title="兄弟进程间通信"></a>兄弟进程间通信</h2><p>练习题：兄弟进程间通信<br>兄：ls<br>弟：wc -l<br>父：等待回收子进程<br>要求，使用循环创建 N 个子进程模型创建兄弟进程，使用循环因子 i 标识，注意管道读写行为<br>测试：<br>是否允许，一个 pipe 有一个写端多个读端 可<br>是否允许，一个 pipe 有多个写端一个读端 可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;sys/wait.h&gt;</span><br><span class="line">5. #include &lt;unistd.h&gt;</span><br><span class="line">6. #include &lt;errno.h&gt;</span><br><span class="line">7. #include &lt;pthread.h&gt;</span><br><span class="line">8.</span><br><span class="line">9. void sys_err(const char *str)</span><br><span class="line">10. &#123;</span><br><span class="line">11. perror(str);</span><br><span class="line">12. exit(1);</span><br><span class="line">13. &#125;</span><br><span class="line">14. int main(int argc, char *argv[])</span><br><span class="line">15. &#123;</span><br><span class="line">16. int fd[2];</span><br><span class="line">17. int ret, i;</span><br><span class="line">18. pid_t pid;</span><br><span class="line">19.</span><br><span class="line">20. ret = pipe(fd);</span><br><span class="line">21. if (ret == -1) &#123;</span><br><span class="line">22. sys_err(&quot;pipe error&quot;);</span><br><span class="line">23. &#125;</span><br><span class="line">24.</span><br><span class="line">25. for(i = 0; i &lt; 2; i++) &#123; // 表达式 2 出口,仅限父进程使用</span><br><span class="line">26. pid = fork();</span><br><span class="line">27. if (pid == -1) &#123;</span><br><span class="line">28. sys_err(&quot;fork error&quot;);</span><br><span class="line">29. &#125;</span><br><span class="line">30. if (pid == 0) // 子进程,出口</span><br><span class="line">31. break;</span><br><span class="line">32. &#125;</span><br><span class="line">33.</span><br><span class="line">34. if (i == 2) &#123; // 父进程 . 不参与管道使用.</span><br><span class="line">35. close(fd[0]); // 关闭管道的 读端/写端.</span><br><span class="line">36. close(fd[1]);</span><br><span class="line">37.</span><br><span class="line">38. wait(NULL); // 回收子进程</span><br><span class="line">39. wait(NULL);</span><br><span class="line">40. &#125; else if (i == 0) &#123; // 哥哥</span><br><span class="line">41. close(fd[0]);</span><br><span class="line">42. dup2(fd[1], STDOUT_FILENO); // 重定向 stdout</span><br><span class="line">43. execlp(&quot;ls&quot;, &quot;ls&quot;, NULL);</span><br><span class="line">44. sys_err(&quot;exclp ls error&quot;);</span><br><span class="line">45. &#125; else if (i == 1) &#123; //弟弟</span><br><span class="line">46. close(fd[1]);</span><br><span class="line">47. dup2(fd[0], STDIN_FILENO); // 重定向 stdin</span><br><span class="line">48. execlp(&quot;wc&quot;, &quot;wc&quot;, &quot;-l&quot;, NULL);</span><br><span class="line">49. sys_err(&quot;exclp wc error&quot;);</span><br><span class="line">50. &#125;</span><br><span class="line">51.</span><br><span class="line">52. return 0;</span><br><span class="line">53. &#125;</span><br></pre></td></tr></table></figure>

<p>这个代码需要注意一点，父进程不使用管道，所以一定要关闭父进程的管道，保证数据单向流动。</p>
<h2 id="多个读写端操作管道和管道缓冲区大小"><a href="#多个读写端操作管道和管道缓冲区大小" class="headerlink" title="多个读写端操作管道和管道缓冲区大小"></a>多个读写端操作管道和管道缓冲区大小</h2><p>下面是一个父进程读，俩子进程写的例子，也就是一个读端多个写端。需要调控写入顺序才行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;unistd.h&gt;</span><br><span class="line">3. #include &lt;sys/wait.h&gt;</span><br><span class="line">4. #include &lt;string.h&gt;</span><br><span class="line">5. #include &lt;stdlib.h&gt;</span><br><span class="line">6.</span><br><span class="line">7. int main(void)</span><br><span class="line">8. &#123;</span><br><span class="line">9. pid_t pid;</span><br><span class="line">10. int fd[2], i, n;</span><br><span class="line">11. char buf[1024];</span><br><span class="line">12.</span><br><span class="line">13. int ret = pipe(fd);</span><br><span class="line">14. if(ret == -1)&#123;</span><br><span class="line">15. perror(&quot;pipe error&quot;);</span><br><span class="line">16. exit(1);</span><br><span class="line">17. &#125;</span><br><span class="line">18.</span><br><span class="line">19. for(i = 0; i &lt; 2; i++)&#123;</span><br><span class="line">20. if((pid = fork()) == 0)</span><br><span class="line">21. break;</span><br><span class="line">22. else if(pid == -1)&#123;</span><br><span class="line">23. perror(&quot;pipe error&quot;);</span><br><span class="line">24. exit(1);</span><br><span class="line">25. &#125;</span><br><span class="line">26. &#125;</span><br><span class="line">27.</span><br><span class="line">28. if (i == 0) &#123;</span><br><span class="line">29. close(fd[0]);</span><br><span class="line">30. write(fd[1], &quot;1.hello\n&quot;, strlen(&quot;1.hello\n&quot;));</span><br><span class="line">31. &#125; else if(i == 1) &#123;</span><br><span class="line">32. close(fd[0]);</span><br><span class="line">33. write(fd[1], &quot;2.world\n&quot;, strlen(&quot;2.world\n&quot;));</span><br><span class="line">34. &#125; else &#123;</span><br><span class="line">35. close(fd[1]); //父进程关闭写端,留读端读取数据</span><br><span class="line">36. sleep(1);</span><br><span class="line">37. n = read(fd[0], buf, 1024); //从管道中读数据</span><br><span class="line">38. write(STDOUT_FILENO, buf, n);</span><br><span class="line">39.</span><br><span class="line">40. for(i = 0; i &lt; 2; i++) //两个儿子 wait 两次</span><br><span class="line">41. wait(NULL);</span><br><span class="line">42. &#125;</span><br><span class="line">43.</span><br><span class="line">44. return 0;</span><br><span class="line">45. &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个例子需要注意，父进程必须等一下，不然可能俩子进程只写了一个，父进程就读完跑路了。 </p>
<p>管道大小，默认 4096</p>
<h2 id="命名管道-fifo-的创建和原理图"><a href="#命名管道-fifo-的创建和原理图" class="headerlink" title="命名管道 fifo 的创建和原理图"></a>命名管道 fifo 的创建和原理图</h2><p>管道的优劣：<br>优点：简单，相比信号，套接字实现进程通信，简单很多<br>缺点：1.只能单向通信，双向通信需建立两个管道<br> 2.只能用于有血缘关系的进程间通信。该问题后来使用 fifo 命名管道解决。</p>
<p>fifo 管道：可以用于无血缘关系的进程间通信。<br>命名管道： mkfifo<br>无血缘关系进程间通信：<br>读端，open fifo O_RDONLY<br>写端，open fifo O_WRONLY<br>fifo 操作起来像文件<br>下面的代码创建一个 fifo：</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612214052445.png" alt="image-20230612214052445"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612214052445.png" class title="This is an test image">

<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612215028041.png" alt="image-20230612215028041"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612215028041.png" class title="This is an test image">

<h2 id="fifo-实现非血缘关系进程间通信"><a href="#fifo-实现非血缘关系进程间通信" class="headerlink" title="fifo 实现非血缘关系进程间通信"></a>fifo 实现非血缘关系进程间通信</h2><p>下面这个例子，一个写 fifo，一个读 fifo，操作起来就像文件一样的：</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612214842946.png" alt="image-20230612214842946"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612214842946.png" class title="This is an test image">

<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612214916095.png" alt="image-20230612214916095"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612214916095.png" class title="This is an test image">

<p>编译执行，如图：<img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612215107477.png" alt="image-20230612215107477"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612215107477.png" class title="This is an test image">

<p>测试一个写端多个读端的时候，由于数据一旦被读走就没了，所以多个读端的并集才是写端的写 入数据。</p>
<h2 id="文件用于进程间通信"><a href="#文件用于进程间通信" class="headerlink" title="文件用于进程间通信"></a>文件用于进程间通信</h2><p>文件实现进程间通信： 打开的文件是内核中的一块缓冲区。多个无血缘关系的进程，可以同时访问该文件。</p>
<p><strong>socket套接字也是一种文件格式，和管道文件一样，它是一种伪文件</strong>，存在于内核的缓冲区中，大小不变，一直是0。</p>
<h2 id="mmap-函数原型"><a href="#mmap-函数原型" class="headerlink" title="mmap 函数原型"></a>mmap 函数原型</h2><p>磁盘访问需要open和read,内存访问用地址，即使用指针访问。</p>
<p>内核缓冲区是位于内核空间的一块特定内存区域，用于临时存储和处理数据。在 Linux 内核中，访问内核缓冲区通常需要使用相应的系统调用或函数。一种常见的方式是使用 I&#x2F;O 操作函数来读取或写入内核缓冲区的内容。例如，在文件 I&#x2F;O 中，我们可以使用系统调用 <code>read()</code> 和 <code>write()</code> 来分别从内核缓冲区读取数据到用户空间或将数据从用户空间写入到内核缓冲区。</p>
<p>存储映射 I&#x2F;O(Memory-mapped I&#x2F;O) 使一个磁盘文件与存储空间中的一个缓冲区相映射。于是从缓冲区中取数据，就相当于读文件中的相应字节。与此类似，将数据存入缓冲区，则相应的字节就自动写入文件。这样，就可在不使用 read 和 write 函数的情况下，使地址指针完成 I&#x2F;O 操作。<br>使用这种方法，首先应该通知内核，将一个指定文件映射到存储区域中。这个映射工作可以通过mmap 函数来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</span><br><span class="line">创建共享内存映射</span><br><span class="line">参数：</span><br><span class="line">    addr： 指定映射区的首地址。通常传 NULL，表示让系统自动分配</span><br><span class="line">    length：共享内存映射区的大小。（&lt;= 文件的实际大小）</span><br><span class="line">    prot： 共享内存映射区的读写属性。PROT_READ、PROT_WRITE、PROT_READ|PROT_WRITE</span><br><span class="line">    flags： 标注共享内存的共享属性。MAP_SHARED、MAP_PRIVATE</span><br><span class="line">    fd: 用于创建共享内存映射区的那个文件的 文件描述符。</span><br><span class="line">    offset：默认 0，表示映射文件全部。偏移位置。需是 4k 的整数倍。</span><br><span class="line">返回值：</span><br><span class="line">    成功：映射区的首地址。</span><br><span class="line">    失败：MAP_FAILED (void*(-1))， errno</span><br><span class="line">   flags 里面的 shared 意思是修改会反映到磁盘上</span><br><span class="line">     private 表示修改不反映到磁盘上</span><br><span class="line"> int munmap(void *addr, size_t length); 释放映射区。</span><br><span class="line">    addr：mmap 的返回值</span><br><span class="line">    length：大小</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>出现段错误，gdb然后run停止的地方就是段错误。</p>
<h2 id="mmap-建立映射区"><a href="#mmap-建立映射区" class="headerlink" title="mmap 建立映射区"></a>mmap 建立映射区</h2><p>下面这个示例代码，使用 mmap 创建一个映射区（共享内存），并往映射区里写入内容：</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230614113240142.png" alt="image-20230614113240142"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230614113240142.png" class title="This is an test image">

<h2 id="mmap-使用注意事项"><a href="#mmap-使用注意事项" class="headerlink" title="mmap 使用注意事项"></a>mmap 使用注意事项</h2><p>使用注意事项：</p>
<ol>
<li>用于创建映射区的文件大小为 0，实际指定非 0 大小创建映射区，出 “总线错误”。</li>
<li>用于创建映射区的文件大小为 0，实际制定 0 大小创建映射区， 出 “无效参数”。</li>
<li>用于创建映射区的文件读写属性为，只读。映射区属性为 读、写。 出 “无效参数”。</li>
<li>创建映射区，需要 read 权限。当访问权限指定为 “共享”MAP_SHARED 时， mmap 的读写权限，应该 &lt;&#x3D;文件的 open 权限。 只写不行。</li>
<li>文件描述符 fd，在 mmap 创建映射区完成即可关闭。后续访问文件，用 地址访问。</li>
<li>offset 必须是 4096 的整数倍。（MMU 映射的最小单位 4k ）</li>
<li>对申请的映射区内存，不能越界访问。</li>
<li>munmap 用于释放的 地址，必须是 mmap 申请返回的地址。</li>
<li>映射区访问权限为 “私有”MAP_PRIVATE, 对内存所做的所有修改，只在内存有效，不会反应到物理磁盘上。</li>
<li>映射区访问权限为 “私有”MAP_PRIVATE, 只需要 open 文件时，有读权限，用于创建映射区即可。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mmap 函数的保险调用方式：</span><br><span class="line">1. fd = open（&quot;文件名&quot;， O_RDWR）;</span><br><span class="line">2. mmap(NULL, 有效文件大小， PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);</span><br></pre></td></tr></table></figure>

<p>mmap 总结 </p>
<ol>
<li>创建映射区的过程中，隐含着一次对映射文件的读操作</li>
<li>当 MAP_SHARED 时，要求：映射区的权限应该&lt;&#x3D;文件打开的权限（出于对映射区的保护）。而MAP_PRIVATE 则无所谓，因为 mmap 中的权限是对内存的限制</li>
<li>映射区的释放与文件关闭无关。只要映射建立成功，文件可以立即关闭</li>
<li>特别注意，当映射文件大小为 0 时，不能创建映射区。所以：用于映射的文件必须要有实际大小！！mmap 使用时常常会出现总线错误，通常是由于共享文件存储空间大小引起的。如，400 字节大小的文件，在简历映射区时，offset4096 字节，则会报出总线错误</li>
<li>munmap 传入的地址一定是 mmap 返回的地址。坚决杜绝指针++操作,会改变地址，在指针本身上操作</li>
<li>文件偏移量必须为 4K 的整数倍</li>
<li>mmap 创建映射区出错概率非常高，一定要检查返回值，确保映射区建立成功再进行后续操作。</li>
</ol>
<h2 id="父子进程间-mmap-通信"><a href="#父子进程间-mmap-通信" class="headerlink" title="父子进程间 mmap 通信"></a>父子进程间 mmap 通信</h2><p>父子进程使用 mmap 进程间通信：<br>父进程 先 创建映射区。 <code>open（ O_RDWR） mmap( MAP_SHARED );</code><br>指定 MAP_SHARED 权限<br>fork() 创建子进程。<br>一个进程读， 另外一个进程写</p>
<p>下面这段代码，父子进程 mmap 通信，共享内存是一个 int 变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;unistd.h&gt;</span><br><span class="line">4. #include &lt;fcntl.h&gt;</span><br><span class="line">5. #include &lt;sys/mman.h&gt;</span><br><span class="line">6. #include &lt;sys/wait.h&gt;</span><br><span class="line">7.</span><br><span class="line">8. int var = 100;</span><br><span class="line">9.</span><br><span class="line">10. int main(void)</span><br><span class="line">11. &#123;</span><br><span class="line">12. int *p;</span><br><span class="line">13. pid_t pid;</span><br><span class="line">14.</span><br><span class="line">15. int fd;</span><br><span class="line">16. fd = open(&quot;temp&quot;, O_RDWR|O_CREAT|O_TRUNC, 0644);</span><br><span class="line">17. if(fd &lt; 0)&#123;</span><br><span class="line">18. perror(&quot;open error&quot;);</span><br><span class="line">19. exit(1);</span><br><span class="line">20. &#125;</span><br><span class="line">21. ftruncate(fd, 4);</span><br><span class="line">22.</span><br><span class="line">23. p = (int *)mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);</span><br><span class="line">24. //p = (int *)mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);</span><br><span class="line">25. if(p == MAP_FAILED)&#123; //注意:不是 p == NULL</span><br><span class="line">26. perror(&quot;mmap error&quot;);</span><br><span class="line">27. exit(1);</span><br><span class="line">28. &#125;</span><br><span class="line">29. close(fd); //映射区建立完毕,即可关闭文件</span><br><span class="line">30.</span><br><span class="line">31. pid = fork(); //创建子进程</span><br><span class="line">32. if(pid == 0)&#123;</span><br><span class="line">33. *p = 7000; // 写共享内存</span><br><span class="line">34. var = 1000;</span><br><span class="line">35. printf(&quot;child, *p = %d, var = %d\n&quot;, *p, var);</span><br><span class="line">36. &#125; else &#123;</span><br><span class="line">37. sleep(1);</span><br><span class="line">38. printf(&quot;parent, *p = %d, var = %d\n&quot;, *p, var); // 读共享内存</span><br><span class="line">39. wait(NULL);</span><br><span class="line">40.</span><br><span class="line">41. int ret = munmap(p, 4); //释放映射区</span><br><span class="line">42. if (ret == -1) &#123;</span><br><span class="line">43. perror(&quot;munmap error&quot;);</span><br><span class="line">44. exit(1);</span><br><span class="line">45. &#125;</span><br><span class="line">46. &#125;</span><br><span class="line">47.</span><br><span class="line">48. return 0;</span><br><span class="line">49. &#125;</span><br></pre></td></tr></table></figure>

<h2 id="无血缘关系进程间-mmap-通信"><a href="#无血缘关系进程间-mmap-通信" class="headerlink" title="无血缘关系进程间 mmap 通信"></a>无血缘关系进程间 mmap 通信</h2><p>无血缘关系进程间 mmap 通信：<br>两个进程 打开同一个文件，创建映射区。<br>指定 flags 为 MAP_SHARED。<br>一个进程写入，另外一个进程读出。<br>【注意】：无血缘关系进程间通信。mmap：数据可以重复读取。<br>fifo：数据只能一次读取。</p>
<p>下面是两个无血缘关系的通信代码，先是写进程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;sys/stat.h&gt;</span><br><span class="line">3. #include &lt;sys/types.h&gt;</span><br><span class="line">4. #include &lt;fcntl.h&gt;</span><br><span class="line">5. #include &lt;unistd.h&gt;</span><br><span class="line">6. #include &lt;stdlib.h&gt;</span><br><span class="line">7. #include &lt;sys/mman.h&gt;</span><br><span class="line">8. #include &lt;string.h&gt;</span><br><span class="line">9.</span><br><span class="line">10. struct STU &#123;</span><br><span class="line">11. int id;</span><br><span class="line">12. char name[20];</span><br><span class="line">13. char sex;</span><br><span class="line">14. &#125;;</span><br><span class="line">15.</span><br><span class="line">16. void sys_err(char *str)</span><br><span class="line">17. &#123;</span><br><span class="line">18. perror(str);</span><br><span class="line">19. exit(1);</span><br><span class="line">20. &#125;</span><br><span class="line">21.</span><br><span class="line">22. int main(int argc, char *argv[])</span><br><span class="line">23. &#123;</span><br><span class="line">24. int fd;</span><br><span class="line">25. struct STU student = &#123;10, &quot;xiaoming&quot;, &#x27;m&#x27;&#125;;</span><br><span class="line">26. char *mm;</span><br><span class="line">27.</span><br><span class="line">28. if (argc &lt; 2) &#123;</span><br><span class="line">29. printf(&quot;./a.out file_shared\n&quot;);</span><br><span class="line">30. exit(-1);</span><br><span class="line">31. &#125;</span><br><span class="line">32.</span><br><span class="line">33. fd = open(argv[1], O_RDWR | O_CREAT, 0664);</span><br><span class="line">34. ftruncate(fd, sizeof(student));</span><br><span class="line">35.</span><br><span class="line">36. mm = mmap(NULL, sizeof(student), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);</span><br><span class="line">37. if (mm == MAP_FAILED)</span><br><span class="line">38. sys_err(&quot;mmap&quot;);</span><br><span class="line">39.</span><br><span class="line">40. close(fd);</span><br><span class="line">41.</span><br><span class="line">42. while (1) &#123;</span><br><span class="line">43. memcpy(mm, &amp;student, sizeof(student));</span><br><span class="line">44. student.id++;</span><br><span class="line">45. sleep(1);</span><br><span class="line">46. &#125;</span><br><span class="line">47.</span><br><span class="line">48. munmap(mm, sizeof(student));</span><br><span class="line">49.</span><br><span class="line">50. return 0;</span><br><span class="line">51. &#125;</span><br></pre></td></tr></table></figure>

<p>然后是读进程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;sys/stat.h&gt;</span><br><span class="line">3. #include &lt;fcntl.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;stdlib.h&gt;</span><br><span class="line">6. #include &lt;sys/mman.h&gt;</span><br><span class="line">7. #include &lt;string.h&gt;</span><br><span class="line">8.</span><br><span class="line">9. struct STU &#123;</span><br><span class="line">10. int id;</span><br><span class="line">11. char name[20];</span><br><span class="line">12. char sex;</span><br><span class="line">13. &#125;;</span><br><span class="line">14.</span><br><span class="line">15. void sys_err(char *str)</span><br><span class="line">16. &#123;</span><br><span class="line">17. perror(str);</span><br><span class="line">18. exit(-1);</span><br><span class="line">19. &#125;</span><br><span class="line">20.</span><br><span class="line">21. int main(int argc, char *argv[])</span><br><span class="line">22. &#123;</span><br><span class="line">23. int fd;</span><br><span class="line">24. struct STU student;</span><br><span class="line">25. struct STU *mm;</span><br><span class="line">26.</span><br><span class="line">27. if (argc &lt; 2) &#123;</span><br><span class="line">28. printf(&quot;./a.out file_shared\n&quot;);</span><br><span class="line">29. exit(-1);</span><br><span class="line">30. &#125;</span><br><span class="line">31.</span><br><span class="line">32. fd = open(argv[1], O_RDONLY);</span><br><span class="line">33. if (fd == -1)</span><br><span class="line">34. sys_err(&quot;open error&quot;);</span><br><span class="line">35.</span><br><span class="line">36. mm = mmap(NULL, sizeof(student), PROT_READ, MAP_SHARED, fd, 0);</span><br><span class="line">37. if (mm == MAP_FAILED)</span><br><span class="line">38. sys_err(&quot;mmap error&quot;);</span><br><span class="line">39.</span><br><span class="line">40. close(fd);</span><br><span class="line">41.</span><br><span class="line">42. while (1) &#123;</span><br><span class="line">43. printf(&quot;id=%d\tname=%s\t%c\n&quot;, mm-&gt;id, mm-&gt;name, mm-&gt;sex);</span><br><span class="line">44. sleep(2);</span><br><span class="line">45. &#125;</span><br><span class="line">46. munmap(mm, sizeof(student));</span><br><span class="line">47.</span><br><span class="line">48. return 0;</span><br><span class="line">49. &#125;</span><br></pre></td></tr></table></figure>

<p>如图，一读一写，问题不大。 多个写端一个读端也没问题，打开多个写进程即可，完事儿读进程会读到所有写进程写入的内容。 这里要注意一个，内容被读走之后不会消失，所以如果读进程的读取时间间隔短，它会读到很多重复内容，就是因为写进程没来得及写入新内容。</p>
<h2 id="mmap-匿名映射区"><a href="#mmap-匿名映射区" class="headerlink" title="mmap 匿名映射区"></a>mmap 匿名映射区</h2><p>匿名映射：只能用于 血缘关系进程间通信。 </p>
<p><code>p = (int *)mmap(NULL, 40, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/31/%E5%85%B3%E4%BA%8Evim%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/31/%E5%85%B3%E4%BA%8Evim%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">关于vim的一些配置问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-31 09:39:24 / 修改时间：10:42:27" itemprop="dateCreated datePublished" datetime="2023-05-31T09:39:24+08:00">2023-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/%E5%85%B3%E4%BA%8Evim%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/image-20230531094409134.png" alt="image-20230531094409134"></p>
<img src="/2023/05/31/%E5%85%B3%E4%BA%8Evim%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/image-20230531094409134.png" class title="This is an test image">

<p><img src="/%E5%85%B3%E4%BA%8Evim%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/image-20230531094456531.png" alt="image-20230531094456531"></p>
<img src="/2023/05/31/%E5%85%B3%E4%BA%8Evim%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/image-20230531094456531.png" class title="This is an test image">

<p>总之语法补全我用的是YouCompleteMe，通过插件管理器Vundle来进行安装，需要先git,再正确初始化YouCompleteMe插件的子模块</p>
<p>安装 YouCompleteMe（ycm）插件需要使用 Clang 编译器及其相关组件，因为 ycm 的自动补全和语义分析功能都是基于 Clang 提供的编译器前端实现的。具体来说，ycm 依赖以下的软件&#x2F;库：</p>
<ul>
<li>Python 解释器和开发工具包</li>
<li>Clang 编译器和其相关组件：Libclang、Clangd 等</li>
<li>CMake 构建工具</li>
<li>LLVM 代码生成框架</li>
</ul>
<p>因此，在安装 YouCompleteMe 插件之前，您需要先安装上述软件&#x2F;库，并确保它们能够正常工作。此外，YouCompleteMe 更支持直接使用系统自带的 Clang，不需要单独安装。</p>
<p><img src="/%E5%85%B3%E4%BA%8Evim%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/image-20230531094926944.png" alt="image-20230531094926944"></p>
<img src="/2023/05/31/%E5%85%B3%E4%BA%8Evim%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/image-20230531094926944.png" class title="This is an test image">

<p>如果你需要配置vim，只需在Home目录创建一个**<del>&#x2F;.vimrc**文件即可以配置vim了，如需安装插件，在</del>&#x2F;.vim目录下创建一个bundle文件夹，插件装在里面。我通过Vundle管理插件，这里YouCompleteMe插件需要前面的git，无法直接安装。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">YouCompleteMe是一个基于Python编写的Vim自动补全插件，它需要使用C++编译器和Python 3.x运行时才能正常工作。这是因为插件的代码本身是使用C++编写的，但是它需要使用Python来启动和管理插件进程，并在后台执行代码分析等任务。</span><br><span class="line"></span><br><span class="line">具体来说，ycm 依赖以下的软件/库：</span><br><span class="line"></span><br><span class="line">Python 解释器和开发工具包</span><br><span class="line">Clang 编译器和其相关组件：Libclang、Clangd 等</span><br><span class="line">CMake 构建工具</span><br><span class="line">LLVM 代码生成框架</span><br><span class="line">因此，在安装 YouCompleteMe 插件之前，您需要先安装上述软件/库，并确保它们能够正常工作。此外，YouCompleteMe 更支持直接使用系统自带的 Clang，不需要单独安装。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CMake 是一款独立的构建工具，并不是一个命令行工具，因此您需要在 CMakeLists.txt 文件中定义项目的配置、编译规则和安装步骤等。一般情况下，在终端中运行 cmake 命令来生成对应平台的 Makefile 或 IDE 项目文件，然后使用 make 或者 Visual Studio 等工具来实际编译执行。</span><br><span class="line"></span><br><span class="line">以下是你可以在终端中使用的常用 CMake 命令：</span><br><span class="line"></span><br><span class="line">cmake: 根据当前目录下的 CMakeLists.txt 文件生成 makefiles 或 IDE 项目文件；</span><br><span class="line">cmake-gui: 使用 GUI 界面进行配置和生成构建系统（Windows 和 macOS）；</span><br><span class="line">cmake --build: 调用底层构建系统（如 make 或 Visual Studio）来编译项目；</span><br><span class="line">cmake --install: 安装构建好的程序或库到指定的位置；</span><br><span class="line">ctest: 运行测试套件并输出测试结果；</span><br><span class="line">cpack: 将已构建好的项目打包成单个、可移植的二进制发行版。</span><br><span class="line">需要注意的是，上述命令中的参数和具体用法可能会因不同的项目而有所区别，请根据具体文档来参考使用。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">这个错误提示意味着您的电脑没有安装CMake或者CMake可执行文件的路径没有加入到系统环境变量中。请按照以下步骤来解决此问题：</span><br><span class="line"></span><br><span class="line">如果您没有安装CMake，请先安装最新版的CMake。您可以在Linux上使用包管理器，在终端输入以下命令：</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install cmake</span><br><span class="line">如果您使用的是其他操作系统，请参考相关文档安装CMake。</span><br><span class="line"></span><br><span class="line">确认CMake是否已经添加到系统环境变量中。如果没有，请将CMake的可执行文件路径添加到环境变量中，方法如下：</span><br><span class="line"></span><br><span class="line">在终端中运行以下命令打开.bashrc或.zshrc文件编辑器：</span><br><span class="line"></span><br><span class="line">vim ~/.bashrc # 或者vim ~/.zshrc（取决于您使用的shell）</span><br><span class="line">将以下内容添加到文件末尾，并保存退出：</span><br><span class="line"></span><br><span class="line">export PATH=&quot;$PATH:/path/to/cmake/bin&quot;</span><br><span class="line">运行以下命令使更改生效：</span><br><span class="line"></span><br><span class="line">source ~/.bashrc # 或者source ~/.zshrc</span><br><span class="line">注意替换/path/to/cmake/bin为您自己的CMake可执行文件路径。</span><br><span class="line"></span><br><span class="line">再次执行构建YouCompleteMe插件的命令，并添加--verbose参数以获取更详细的错误信息：</span><br><span class="line"></span><br><span class="line">/usr/bin/python3 /home/xiaohuilin/.vim/bundle/YouCompleteMe/third_party/ycmd/build.py --clang-completer --verbose</span><br><span class="line">总之，以上步骤可以帮助您解决在Linux上构建YouCompleteMe插件时遇到的CMake可执行文件未找到问题。</span><br></pre></td></tr></table></figure>

<p><strong>总之问题注意有些插件需要去git仓库</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NoExtraConfDetected:No.ycm_extra_conf.py file detected,so no compile flags are available.Thus no semantic support for c/c++/objcc++.GoREAD THE DOCS *NOW*,DON&#x27;T file a bug report</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这是 YouCompleteMe 编辑器插件在寻找编译器标志文件时的一种提示。YouCompleteMe 是一个为多种编辑器准备的自动补全和语义补充工具，其中包含对 C/C++/Objective-C 等语言的支持，并可以通过指定编译标志来提供更高级别的语法分析和代码补全功能。</span><br><span class="line"></span><br><span class="line">上述错误信息表明 YouCompleteMe 没有找到名为 ycm_extra_conf.py 的配置文件，因而无法获得程序的编译标志等元数据信息，从而无法提供 C/C++/Objective-C 的地道补全、跳转等方面的支持。</span><br><span class="line"></span><br><span class="line">要解决这个问题，你需要按照 YouCompleteMe 的文档说明中所讲述的，在当前项目根目录下建立名为 ycm_extra_conf.py 的文件，并进行适当的配置修改或编写，以便可以向 YouCompleteMe 提供关于项目代码及编译环境的相关信息。如果还有问题，请参考官方文档或联系相关技术支持。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">没有这个就无法判断头文件吗</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">并非如此。即使没有 ycm_extra_conf.py 文件，YouCompleteMe 也能大概率猜测出头文件的位置。不过在这种情况下，YouCompleteMe 无法准确知道要使用哪些编译选项和库依赖关系，这可能会导致代码补全、错误提示等功能出现误报或不生效。</span><br><span class="line"></span><br><span class="line">如果您不想手动编写 ycm_extra_conf.py 文件，也可以尝试通过其它方式来提供项目信息。比如使用 CMake 来生成 Makefile 或者 IDEA 项目文件，并配置好编译选项；或者按照 YouCompleteMe 的文档指导，手动在配置文件中为每个文件类型设置编译器标志和头文件搜索路径等信息。这取决于具体的开发环境和工具链。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">是的，按照 YouCompleteMe 的要求，在当前项目根目录下创建名为 ycm_extra_conf.py 的文件，并根据实际需要进行配置。</span><br><span class="line"></span><br><span class="line">以 C++ 项目为例，可以在 ycm_extra_conf.py 文件中添加如下代码来提供编译器标志。这里假设编译器为 GCC 或 Clang，并且项目包含了多个源码文件和框架库：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line"># 编译器路径（可选）</span><br><span class="line"># 如果没有安装系统默认编译器，则需要手动指定路径</span><br><span class="line"># os.environ[&#x27;CC&#x27;] = &#x27;/usr/bin/clang&#x27;</span><br><span class="line"># os.environ[&#x27;CXX&#x27;] = &#x27;/usr/bin/clang++&#x27;</span><br><span class="line"></span><br><span class="line"># 全局通用编译器标志</span><br><span class="line">flags = [</span><br><span class="line">    &#x27;-Wall&#x27;,</span><br><span class="line">    &#x27;-Wextra&#x27;,</span><br><span class="line">    # 更多需要的标志</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 针对不同文件类型设置不同的编译器标志和头文件搜索路径</span><br><span class="line">def Settings(**kwargs):</span><br><span class="line">  if kwargs[&#x27;language&#x27;] == &#x27;cfamily&#x27;:</span><br><span class="line">    filename = kwargs[&#x27;filename&#x27;]</span><br><span class="line">    ext = os.path.splitext(filename)[1]</span><br><span class="line"></span><br><span class="line">    # 源码文件</span><br><span class="line">    if ext in [&#x27;.c&#x27;, &#x27;.cpp&#x27;, &#x27;.cxx&#x27;]:</span><br><span class="line">        return &#123;</span><br><span class="line">            &#x27;flags&#x27;: flags + [</span><br><span class="line">                &#x27;-std=c++17&#x27;,   # 或其它版本</span><br><span class="line">                # 可针对特定文件设置标志</span><br><span class="line">            ],</span><br><span class="line">            &#x27;include_paths_relative_to_dir&#x27;: &#x27;./&#x27;,</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    # 框架库头文件</span><br><span class="line">    elif ext in [&#x27;.h&#x27;, &#x27;.hpp&#x27;]:</span><br><span class="line">        return &#123;</span><br><span class="line">            &#x27;flags&#x27;: flags,</span><br><span class="line">            &#x27;include_paths_relative_to_dir&#x27;: &#x27;./&#x27;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  return &#123;&#125;</span><br><span class="line">在配置好 ycm_extra_conf.py 文件后，重新加载编辑器插件或重新打开文件即可。YouCompleteMe 将会根据该文件中的设置来提供适当的代码补全和提示等功能。需要注意的是不同插件有可能采用不同的标志格式和语法。上述代码仅为示例，并不代表全部情况。具体语法和参数请参看相应插件的文档。</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/" class="post-title-link" itemprop="url">深入理解计算机系统-第五章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-29 11:40:04" itemprop="dateCreated datePublished" datetime="2023-05-29T11:40:04+08:00">2023-05-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-06 14:36:01" itemprop="dateModified" datetime="2023-07-06T14:36:01+08:00">2023-07-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第五章优化程序性能"><a href="#第五章优化程序性能" class="headerlink" title="第五章优化程序性能"></a>第五章优化程序性能</h1><p>研究程序的汇编代码表示是理解编译器以及产生的代码会如何运行的最有效手段之一。仔细研究内循环的代码是一个很好的开端，识别出降低性能的属性，例如过多的内存引用和对寄存器使用不当。从汇编代码开始，我们还可以预测什么操作会并行执行，以及它们会如何使用处理器资源。正如我们会看到的，常常通过确认关键路径(critical path)来决定执行一个循环所需要的时间(或者说，至少是一个时间下界)。所谓<strong>关键路径</strong>是在循环的反复执行过程中形成的数据相关链。然后，我们会回过头来修改源代码，试着控制编译器使之产生更有效率的实现。</p>
<p>大多数编译器，包括GCC，一直都在更新和改进，特别是在优化能力方面。一个有用的策略是只重写程序到编译器由此就能产生有效代码所需要的程度就好了。这样，能尽量避免损害代码的可读性、模块性和可移植性，就好像我们使用的是具有最低能力的编译器。同样，通过测量值和检查生成的汇编代码，反复修改源代码和分析它的性能是很有帮助的。</p>
<p>对于新手程序员来说，不断修改源代码，试图欺骗编译器产生有效的代码，看起来很奇怪，但这确实是编写很多高性能程序的方式。比较于另一种方法—用汇编语言写代码，这种间接的方法具有的优点是:虽然性能不一定是最好的，但得到的代码仍然能够在其他机器上运行。</p>
<h2 id="优化编译器的能力和局限性"><a href="#优化编译器的能力和局限性" class="headerlink" title="优化编译器的能力和局限性"></a>优化编译器的能力和局限性</h2><p>现代编译器运用复杂精细的算法来确定一个程序中计算的是什么值，以及它们是被如何使用的。然后会利用一些机会来简化表达式，在几个不同的地方使用同一个计算，以及降低一个给定的计算必须被执行的次数。大多数编译器，包括GCC，向用户提供了一些对它们所使用的优化的控制。就像在第3章中讨论过的，最简单的控制就是指定优化级别。例如，以命令行选项“-Og”调用GCC是让GCC使用一组基本的优化。以选项“-O1”或更高(如“-O2”或“-O3”)调用GCC会让它使用更大量的优化。这样做可以进一步提高程序的性能，但是也可能增加程序的规模，也可能使标准的调试工具更难对程序进行调试。我们的表述，虽然对于大多数使用GCC的软件项目来说，优化级别-O2已经成为了被接受的标准，但是还是主要考虑以优化级别-O1编译出的代码。我们特意限制了优化级别，以展示写C语言函数的不同方法如何影响编译器产生代码的效率。我们会发现可以写出的C代码，即使用-O1选项编译得到的性能，也比用可能的最高的优化等级编译一个更原始的版本得到的性能好。</p>
<p>未经优化的代码是从C语言代码到机器代码的直接翻译，通常效率明显较低。简单地使用命令行选项“-O1”，就会进行一些基本的优化。正如可以看到的，程序员不需要做什么，就会显著地提高程序性能–—超过两个数量级。通常，养成至少使用这个级别优化的习惯是很好的。(使用-Og优化级别能得到相似的性能结果。)</p>
<h3 id="用内联函数替换优化函数调用"><a href="#用内联函数替换优化函数调用" class="headerlink" title="用内联函数替换优化函数调用"></a>用内联函数替换优化函数调用</h3><p>包含函数调用的代码可以用一个称为内联函数替换(inline substitution，或者简称“内联(inlining)”)的过程进行优化，此时，将函数调用替换为函数体。</p>
<p>GCC的最近版本会尝试进行这种形式的优化，要么是被用命令行选项“-finline”指示时，要么是使用优化等级-O1或者更高的等级时。遗憾的是，GCC只尝试在单个文件中定义的函数的内联。这就意味着它将无法应用于常见的情况，即一组库函数在一个文件中被定义，却被其他文件内的函数所调用。</p>
<p>在某些情况下，最好能阻止编译器执行内联替换。一种情况是用符号调试器来评估代码，比如GDB。如果一个函数调用已经用内联替换优化过了，那么任何对这个调用进行追踪或设置断点的尝试都会失败。还有一种情况是用代码剖析的方式来评估程序性能。用内联替换消除的函数调用是无法被正确剖析的。</p>
<h2 id="理解现代处理器"><a href="#理解现代处理器" class="headerlink" title="理解现代处理器"></a>理解现代处理器</h2><p>我们会发现两种下界描述了程序的最大性能。当一系列操作必须按照严格顺序执行时，就会遇到<strong>延迟界限</strong>(latencybound)，因为在下一条指令开始之前，这条指令必须结束。当代码中的数据相关限制了处理器利用指令级并行的能力时，延迟界限能够限制程序性能。<strong>吞吐量界限</strong>(throughpubound)刻画了处理器功能单元的原始计算能力。这个界限是程序性能的终极限制。</p>
<h3 id="整体操作"><a href="#整体操作" class="headerlink" title="整体操作"></a>整体操作</h3><p>ICU从指令高速缓存(instruction cache)中读取指令，指令高速缓存是一个特殊的高速存储器，它包含最近访问的指令。通常，ICU会在当前正在执行的指令很早之前取指，这样它才有足够的时间对指令译码，并把操作发送到EU。不过，一个问题是当程序遇到分支时，程序有两个可能的前进方向。一种可能会选择分支，控制被传递到分支目标。另一种可能是，不选择分支，控制被传递到指令序列的下一条指令。现代处理器采用了一种称为<strong>分支预测</strong>(branch prediction)的技术，处理器会猜测是否会选择分支，同时还预测分支的目标地址。使用<strong>投机执行</strong>(speculative execution)的技术，处理器会开始取出位于它预测的分支会跳到的地方的指令，并对指令译码，甚至在它确定分支预测是否正确之前就开始执行这些操作。如果过后确定分支预测错误，会将状态重新设置到分支点的状态，并开始取出和执行另一个方向上的指令。标记为取指控制的块包括分支预测，以完成确定取哪些指令的任务。</p>
<p>使用<strong>投机执行</strong>技术对操作求值，但是最终结果不会存放在程序寄存器或数据内存中，直到处理器能确定应该实际执行这些指令。分支操作被送到EU，不是确定分支该往哪里去，而是确定分支预测是否正确。如果预测错误，EU会丢弃分支点之后计算出来的结果。它还会发信号给分支单元，说预测是错误的，并指出正确的分支目的。在这种情况中，分支单元开始在新的位置取指。这样的预测错误会导致很大的性能开销。在可以取出新指令、译码和发送到执行单元之前，要花费一点时间。</p>
<p>控制操作数在执行单元间传送的最常见的机制称为<strong>寄存器重命名</strong>(register renaming)。当一条更新寄存器r的指令译码时，产生标记t，得到一个指向该操作结果的唯一的标识符。条目(r，t)被加入到一张表中，该表维护着每个程序寄存器r与会更新该寄存器的操作的标记t之间的关联。当随后以寄存器r作为操作数的指令译码时，发送到执行单元的操作会包含t作为操作数源的值。当某个执行单元完成第一个操作时，会生成-一个结果(v，t)，指明标记为t的操作产生值v。所有等待t作为源的操作都能使用v作为源值，这就是一种形式的数据转发。通过这种机制，值可以从一个操作直接转发到另一个操作，而不是写到寄存器文件再读出来，使得第二个操作能够在第一个操作完成后尽快开始。重命名表只包含关于有未进行写操作的寄存器条目。当一条被译码的指令需要寄存器r，而又没有标记与这个寄存器相关联，那么可以直接从寄存器文件中获取这个操作数。<strong>有了寄存器重命名，即使只有在处理器确定了分支结果之后才能更新寄存器，也可以预测着执行操作的整个序列。</strong></p>
<p>最小化一个计算中的操作数量不一定会提高它的性能。</p>
<p>CPE即是需要的时钟周期。</p>
<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230610161658961.png" alt="image-20230610161658961"></p>
<img src="/2023/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230610161658961.png" class title="This is an test image">

<p>延迟界限给出了任何必须按照严格顺序完成合并运算的函数所需要的最小CPE值。根据功能单元产生结果的最大速率，吞吐量界限给出了CPE的最小界限。例如，因为只有一个整数乘法器，它的发射时间为1个时钟周期，处理器不可能支持每个时钟周期大于1条乘法的速度。另-一方面，四个功能单元都可以执行整数加法，处理器就有可能持续每个周期执行4个操作的速率。不幸的是，因为需要从内存读数据，这造成了另一个吞吐量界限。两个加载单元限制了处理器每个时钟周期最多只能读取两个数据值，从而使得吞吐量界限为0.50。</p>
<h2 id="让编译器展开循环"><a href="#让编译器展开循环" class="headerlink" title="让编译器展开循环"></a>让编译器展开循环</h2><p>编译器可以很容易地执行循环展开。只要优化级别设置得足够高，许多编译器都能例行公事地做到这一点。用优化等级3或更高等级调用GCC，它就会执行循环展开。</p>
<p>循环展开，英文中称Loop unwinding或loop unrolling，是一种牺牲程序的尺寸来加快程序的执行速度的优化方法。可以由程序员完成，也可由编译器自动优化完成。循环展开最常用来降低循环开销，为具有多个功能单元的处理器提供指令级并行。也有利于指令流水线的调度。</p>
<h3 id="循环展开对程序性能的影响"><a href="#循环展开对程序性能的影响" class="headerlink" title="循环展开对程序性能的影响"></a>循环展开对程序性能的影响</h3><p>我们直接以实际代码向大家展示循环展开的作用，首先看未经过循环展开优化的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    auto start = std::chrono::system_clock::now();</span><br><span class="line">    int sum = 0;</span><br><span class="line">    int count = 10000;</span><br><span class="line">    //循环10000次累加</span><br><span class="line">    for(int i = 0;i &lt; count;i++)&#123;  </span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    auto end = std::chrono::system_clock::now();</span><br><span class="line">    std::chrono::duration&lt;double&gt; dura = end - start;</span><br><span class="line">    std::cout &lt;&lt;&quot;共耗时：&quot;&lt;&lt; dura.count() &lt;&lt; &quot;s&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们将循环展开一次，即把上述代码中的循环改为如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; count;i += <span class="number">2</span>)&#123;</span><br><span class="line">    sum += i;</span><br><span class="line">    sum += i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即每次循环将i和i+1一起累加到sum变量上，这样可以把循环次数从10000次降低到5000次，由于CPU的高度流水线化，连续两个加法指令增加耗时很低，所以此版本代码可以一定程度上提高程序运行速度</p>
<p>代码运行耗时0.0000159秒，相较于未优化代码速度快了将近一倍。</p>
<p>当然，我们可以继续增加循环展开次数以进一步提高程序运行速度，但是这个增加循环展开次数也是有限度的，<em>当达到了CPU的最高吞吐量之后，继续增加循环展开次数是没有意义的</em>。</p>
<p>上述循环展开后的代码依然有进一步优化的空间，那就是消除连续指令的相关性，以达到指令级并行，我们可以看到循环展开后的代码，循环体中有两条语句：sum +&#x3D; i 和 sum +&#x3D; i+1，第二条语句sum +&#x3D; i+1依赖于第一条命来sum +&#x3D; i的执行结果，所以这两条语句只能依次执行，限制了CPU进一步提高性能的可能。如果我们将循环体改为如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum1=<span class="number">0</span>,sum2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; count;i+=<span class="number">2</span>)&#123;</span><br><span class="line">    sum1 += i;</span><br><span class="line">    sum2 += i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">sum = sum1 + sum2;</span><br></pre></td></tr></table></figure>

<p>我们新建了两个变量sum1和sum2用于存储循环展开时两个累加语句的累加结果，最后在循环体外将两部分结果相加得到最终结果。该代码中两个累加语句之间是互不相关的，所以CPU可以并行执行这两条指令，以达到性能的进一步提高。相较于只进行循环展开的代码速度又快了将近一倍。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由上面三段代码的运行速度对比可以看出，循环展开对程序性能有着很重要的影响，可以减少分支预测错误次数，增加取消数据相关进一步利用并行执行提高速度的机会。但是，<strong>并不建议大家进行手动的循环展开</strong>，在代码中进行循环展开会导致程序的可读性下降，代码膨胀。为了直观感受循环展开对性能的影响，上述代码运行结果均是在不开编译器优化的情况下进行的测试，其实在我们<strong>开启了编译器优化</strong>的时候，编译器会自动对我们的循环代码进行循环展开，让我们可以在保持了代码可读性的同时，又能享受到循环展开对我们程序性能的提高。</p>
<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230613165045230.png" alt="image-20230613165045230"></p>
<img src="/2023/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230613165045230.png" class title="This is an test image">

<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230613165134725.png" alt="image-20230613165134725"></p>
<img src="/2023/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230613165134725.png" class title="This is an test image">



<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230613165149509.png" alt="image-20230613165149509"></p>
<img src="/2023/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230613165149509.png" class title="This is an test image">



<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230613165207581.png" alt="image-20230613165207581"></p>
<img src="/2023/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230613165207581.png" class title="This is an test image">

<h2 id="SIMD-用向量指令达到更高的并行度"><a href="#SIMD-用向量指令达到更高的并行度" class="headerlink" title="SIMD:用向量指令达到更高的并行度"></a>SIMD:用向量指令达到更高的并行度</h2><p><em>Single Instruction Multiple Data</em>，单指令多数据流，可以使用一条指令同时完成多个数据的运算操作。传统的指令架构是SISD就是单指令单数据流，每条指令只能对一个数据执行操作。</p>
<p>单纯使用SIMD指令并没有什么技术含量，一般程序员也不太会使用 Intrinsics 函数来优化 SIMD，基本上都是靠编译器帮我们进行自动矢量化。想要代码能尽量的自动矢量化，以下几点需要多注意：</p>
<ul>
<li>避免使用全局指针和全局变量以帮助编译器生成 SIMD 代码。</li>
<li>合理安排循环的嵌套，以便最内层的嵌套没有迭代间的依赖关系。尤其要避免在较早的迭代中存储数据，而在往后的迭代中加载该数据。</li>
<li>避免在循环内使用条件分支。</li>
<li>保持循环变量表达式简单。</li>
</ul>
<p>现代编译器已经能为我们自动做很多优化工作，不过这不代表我们学习手写SIMD代码就没有意义了。在向量、矩阵运算等基础库函数中，每个函数通常代码量不大，复杂度不高，但编译器并不能保证会给你优化好，手撸SIMD还是很有必要的。更重要的是，我们能在学习的过程中去接触更底层的一些东西（指令集，内存架构，汇编等），进而提升对整体的编程实力。</p>
<h2 id="一些限制因素"><a href="#一些限制因素" class="headerlink" title="一些限制因素"></a>一些限制因素</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (i = 0; i &lt; n; i++)&#123;</span><br><span class="line">    if (a[i] &gt; b[i]) &#123;</span><br><span class="line">    	long t = a[i];a[i] = b[i];b[i] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在随机数据上测试这个函数，得到的CPE大约为13.50，而对于可预测的数据，CPE为2.5～3.5，其预测错误惩罚约为20个周期。</p>
<p>用功能式的风格实现这个函数是计算每个位置i的最大值和最小值，然后将这些值分别赋给a[i]和 b[i]:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (i = 0; i &lt; n; i++)&#123;</span><br><span class="line">    long min = a[i] &lt; b[i] ? a[i] : b[i];</span><br><span class="line">    long max = a[i] &lt;b[i] ? b[i] : a[i];</span><br><span class="line">    a[i] = min;</span><br><span class="line">    b[i] = max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对这个函数的测试表明无论数据是任意的，还是可预测的，CPE都大约为4.0。(我们还检查了产生的汇编代码，确认它确实使用了条件传送。)</p>
<p>讨论过，不是所有的条件行为都能用条件数据传送来实现，所以无可避免地在某些情况中，程序员不能避免写出会导致条件分支的代码，而对于这些条件分支，处理器用分支预测可能会处理得很糟糕。但是，正如我们讲过的，程序员方面用一点点聪明，有时就能使代码更容易被翻译成条件数据传送。这需要一些试验，写出函数的不同版本，然后检查产生的汇编代码，并测试性能。</p>
<p>分支预测只对有规律的模式可行。程序中的许多测试是完全不可预测的，依赖于数据的任意特性，例如一个数是负数还是正数。对于这些测试，分支预测逻辑会处理得很糟糕。对于本质上无法预测的情况，如果编译器能够产生使用条件数据传送而不是使用条件控制转移的代码，可以极大地提高程序的性能。这不是C语言程序员可以直接控制的，但是有些表达条件行为的方法能够更直接地被翻译成条件传送，而不是其他操作。</p>
<h2 id="理解内存性能"><a href="#理解内存性能" class="headerlink" title="理解内存性能"></a>理解内存性能</h2><p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230705114807883.png" alt="image-20230705114807883"></p>
<img src="/2023/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230705114807883.png" class title="This is an test image">

<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230705114829177.png" alt="image-20230705114829177"></p>
<img src="/2023/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230705114829177.png" class title="This is an test image">

<p>原代码</p>
<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230705114934148.png" alt="image-20230705114934148"></p>
<p>后者vmovss有内存读取，即有了写读相关，导致数据相关。每次需要pi就得先写再读取，导致CPE高，如果是上面就没有。</p>
<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230705115802949.png" alt="image-20230705115802949"></p>
<img src="/2023/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230705115802949.png" class title="This is an test image">

<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230705115942271.png" alt="image-20230705115942271"></p>
<img src="/2023/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230705115942271.png" class title="This is an test image">

<h2 id="确认和消除性能瓶颈"><a href="#确认和消除性能瓶颈" class="headerlink" title="确认和消除性能瓶颈"></a>确认和消除性能瓶颈</h2><p>至此，我们只考虑了优化小的程序，在这样的小程序中有一些很明显限制性能的地方，因此应该是集中注意力对它们进行优化。在处理大程序时，连知道应该优化什么地方都是很难的。本节会描述如何使用代码剖析程序(code profiler)，这是在程序执行时收集性能数据的分析工具。我们还展示了一个系统优化的通用原则，称为Amdahl定律。</p>
<h3 id="程序剖析"><a href="#程序剖析" class="headerlink" title="程序剖析"></a>程序剖析</h3><p>程序剖析(profiling)运行程序的一个版本，其中插人了工具代码，以确定程序的各个部分需要多少时间。这对于确认程序中我们需要集中注意力优化的部分是很有用的。剖析的一个有力之处在于可以在现实的基准数据(benchmark data)上运行实际程序的同时，进行剖析。</p>
<p>Unix系统提供了一个剖析程序GPROF。这个程序产生两种形式的信息。首先，它确定程序中每个函数花费了多少CPU时间。其次，它计算每个函数被调用的次数，以执行调用的函数来分类。这两种形式的信息都非常有用。这些计时给出了不同函数在确定整体运行时间中的相对重要性。调用信息使得我们能理解程序的动态行为。</p>
<p>用GPROF进行剖析需要3个步骤，就像C程序prog.c所示，它运行时命令行参数为file.txt:</p>
<p>1）程序必须为剖析而编译和链接。使用GCC(以及其他C编译器)，就是在命令行上简单地包括运行时标志“-pg”。确保编译器不通过内联替换来尝试执行任何优化是很重要的，否则就可能无法正确刻画函数调用。我们使用优化标志-Og，以保证能正确跟踪函数调用<br><code>linux&gt; gcc -Og -pg prog.c -o prog</code></p>
<p>2）然后程序像往常一样执行:</p>
<p><code>linux&gt; ./prog file.txt</code><br>它运行得会比正常时稍微慢一点(大约慢2倍)，不过除此之外唯一的区别就是它产生了一个文件 gmon.out。<br>3）调用GPROF来分析gmon. out中的数据。</p>
<p><code>linux&gt; gprof prog</code></p>
<p>剖析报告的第一部分列出了执行各个函数花费的时间，按照降序排列。作为一个示例，下面列出了报告的一部分，是关于程序中最耗费时间的三个函数的:</p>
<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230706112821635.png" alt="image-20230706112821635"></p>
<img src="/2023/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230706112821635.png" class title="This is an test image">

<p>每一行代表对某个函数的所有调用所花费的时间。第一列表明花费在这个函数上的时间占整个时间的百分比。第二列显示的是直到这一行并包括这一行的函数所花费的累计时间。第三列显示的是花费在这个函数上的时间，而第四列显示的是它被调用的次数(递归调用不计算在内)。在例子中，函数sort_words只被调用了一次，但就是这一次调用需要203.66秒，而函数find ele_rec被调用了965 027次(递归调用不计算在内)，总共需要4.85秒。函数 strlen通过调用库函数strlen来计算字符串的长度。GPROF的结果中通常不显示库函数调用。库函数耗费的时间通常计算在调用它们的函数内。通过创建这个“包装函数( wrapper function)”strlen，我们可以可靠地跟踪对strlen的调用，表明它被调用了12511 031次，但是一共只需要0.30秒。</p>
<p>剖析报告的第二部分是函数的调用历史。下面是一个递归函数find ele rec的历史:</p>
<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230706113048681.png" alt="image-20230706113048681"></p>
<img src="/2023/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230706113048681.png" class title="This is an test image">

<p>这个历史既显示了调用find_ele_rec的函数，也显示了它调用的函数。头两行显示的是对这个函数的调用:被它自身递归地调用了158655725次，被函数insert_string调用了965 027次(它本身被调用了965027次)。函数find_ele_rec也调用了另外两个函数save_string和 new_ele，每个函数总共被调用了363039次。<br>根据这个调用信息，我们通常可以推断出关于程序行为的有用信息。例如，函数find_ele_rec是一个递归过程，它扫描一个哈希桶(hash bucket)的链表，查找一个特殊的字符串。对于这个函数，比较递归调用的数量和顶层调用的数量，提供了关于遍历这些链表的长度的统计信息。这里递归与顶层调用的比率是164.4，我们可以推断出程序每次平均大约扫描164个元素。</p>
<h2 id="使用剖析程序来指导优化"><a href="#使用剖析程序来指导优化" class="headerlink" title="使用剖析程序来指导优化"></a>使用剖析程序来指导优化</h2><p>迭代和递归是两种常见的函数调用方式，它们在实现方式和执行过程上有一些区别。</p>
<p>迭代（Iteration）是通过循环结构来重复执行一段代码，达到需要的结果。迭代通常使用循环变量作为计数器或条件判断，每次循环都更新循环变量，并基于该变量进行操作。迭代函数通常使用较少的系统资源，对于处理大规模数据集和性能要求较高的场景，迭代通常是更有效的选择。</p>
<p>递归（Recursion）是一种函数自身调用自身的方法。递归函数包含两部分：基准情况（Base Case）和递归调用（Recursive Call）。基准情况定义了递归结束的条件，当满足基准情况时，递归停止并开始回溯。递归调用是函数在自身调用期间的执行过程，每次递归调用会解决一个更小或更简单的子问题。递归函数通常比较简洁，但可能会占用较多的系统资源，并且在处理大规模数据集时可能导致堆栈溢出的问题。</p>
<p>总结区别：</p>
<ul>
<li>迭代是通过循环来完成重复执行，而递归是函数自身调用自身的方式。</li>
<li>迭代函数使用循环变量进行迭代和操作，而递归函数通过不断调用自身来解决子问题。</li>
<li>迭代通常使用较少的系统资源，适用于处理大规模数据集和性能要求较高的场景；递归通常较简洁但可能会占用较多系统资源，并且在处理大规模数据时有堆栈溢出的风险。</li>
</ul>
<p>在选择使用迭代还是递归时，需要考虑问题的特点、性能需求、代码可读性等因素。有些问题更适合使用迭代，而有些问题则可以利用递归的特性更好地表达和解决。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/21/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/21/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/" class="post-title-link" itemprop="url">Linux系统编程-文件IO</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-21 10:50:39" itemprop="dateCreated datePublished" datetime="2023-05-21T10:50:39+08:00">2023-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-07 15:22:17" itemprop="dateModified" datetime="2023-08-07T15:22:17+08:00">2023-08-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>系统调用 内核提供的函数 </p>
<p>库调用 程序库中的函数</p>
<h2 id="open-函数"><a href="#open-函数" class="headerlink" title="open 函数"></a>open 函数</h2><p>open 函数： <code>int open(char *pathname, int flags)  	#include  &lt;unistd.h&gt;</code> </p>
<p>参数： pathname: 欲打开的文件路径名 	flags：文件打开方式： <code>#include  &lt;unistd.h&gt; O_RDONLY|O_WRONLY|O_RDWR|O_CREAT|O_APPEND|O_TRUNC|O_EXCL|O_NONBLOCK ....</code> </p>
<p>返回值： 成功： 打开文件所得到对应的 文件描述符（整数） </p>
<p>失败： -1， 设置 errno </p>
<p><code>int open(char *pathname, int flags， mode_t mode) 	123 775</code> </p>
<p>参数： pathname: 欲打开的文件路径名 </p>
<p>flags：文件打开方式O_RDONLY|O_WRONLY|O_RDWR|O_CREAT|O_APPEND|O_TRUNC|O_EXCL|O_NONBLOCK …. </p>
<p>mode: 参数 3 使用的前提， 参 2 指定了 O_CREAT。 取值 8 进制数，用来描述文件的 访问权限。</p>
<p> rwx 0664 创建文件最终权限 &#x3D; mode &amp; ~umask (umask是系统默认0002取反775)</p>
<p>返回值： 成功： 打开文件所得到对应的 文件描述符（整数） </p>
<p>失败： -1， 设置 errno </p>
<p>close 函数： <code>int close(int fd);</code></p>
<h2 id="read和write实现cp"><a href="#read和write实现cp" class="headerlink" title="read和write实现cp"></a>read和write实现cp</h2><p>read函数：</p>
<p>  <code>ssize_t read(int fd, void *buf, size_t count);</code></p>
<p>  参数：</p>
<p>​    fd：文件描述符</p>
<p>​    buf：存数据的缓冲区</p>
<p>​    count：缓冲区大小</p>
<p>  返回值：</p>
<p>​    0：读到文件末尾。</p>
<p>​    成功； &gt; 0 读到的字节数。</p>
<p>​    失败： -1， 设置 errno</p>
<p>​    -1： 并且 errno &#x3D; EAGIN 或 EWOULDBLOCK, 说明不是read失败，而是read在以非阻塞方式读一个设备文件（网络文件），并且文件无数据。</p>
<p>write函数：</p>
<p>  <code>ssize_t write(int fd, const void *buf, size_t count);</code></p>
<p>  参数：</p>
<p>​    fd：文件描述符</p>
<p>​    buf：待写出数据的缓冲区</p>
<p>​    count：数据大小</p>
<p>  返回值：</p>
<p>​    成功； 写入的字节数。</p>
<p>​    失败： -1， 设置 errno</p>
<p><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230523223219656.png" alt="image-20230523223219656"></p>
<img src="/2023/05/21/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230523223219656.png" class title="This is an test image">

<p>可以在复制函数里加入错误检测：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(fd1 == -1)&#123;</span><br><span class="line"></span><br><span class="line">  perror(“open argv[1] error”);</span><br><span class="line"></span><br><span class="line">  exit(1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误处理函数：    与 errno 相关。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;xxx error: %d\n&quot;, errno);</span><br><span class="line"></span><br><span class="line">char *strerror(int errnum);</span><br><span class="line"></span><br><span class="line">printf(&quot;xxx error: %s\n&quot;, strerror(errno));</span><br><span class="line"></span><br><span class="line">void perror(const char *s);</span><br><span class="line"></span><br><span class="line">  perror(&quot;open error&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="系统调用和库函数比较—预读入缓输出"><a href="#系统调用和库函数比较—预读入缓输出" class="headerlink" title="系统调用和库函数比较—预读入缓输出"></a>系统调用和库函数比较—预读入缓输出</h2><p>所以系统函数并不是一定比库函数牛逼，能使用库函数的地方就使用库函数。 标准 IO 函数（如fputc&#x2F;fgetc）自带用户缓冲区（一般是4096，即4kb再向内核写入），系统调用（read&#x2F;write 这块，每次写一个字节，自己定义buf为1，会疯狂进行内核态和用户态的切换，所以非常耗时）无用户级缓冲。系统缓冲区是都有的。</p>
<p><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230525171335770.png" alt="image-20230525171335770"></p>
<img src="/2023/05/21/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230525171335770.png" class title="This is an test image">

<h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230525185325288.png" alt="image-20230525185325288"></p>
<img src="/2023/05/21/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230525185325288.png" class title="This is an test image">

<p>文件描述符是指向一个文件结构体的指针 </p>
<p>PCB 进程控制块：本质 结构体。</p>
<p> 成员：文件描述符表。 </p>
<p>文件描述符：0&#x2F;1&#x2F;2&#x2F;3&#x2F;4。。。。&#x2F;1023 表中可用的最小的。 </p>
<p>0 - STDIN_FILENO </p>
<p>1 - STDOUT_FILENO </p>
<p>2 - STDERR_FILENO</p>
<h2 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h2><p>阻塞、非阻塞： 是<strong>设备文件、网络文件</strong>的属性。普通创建的文件没有。</p>
<p>产生阻塞的场景。 读设备文件。读网络文件。（读常规文件无阻塞概念。） &#x2F;dev&#x2F;tty – 终端文件。 </p>
<p>open(“&#x2F;dev&#x2F;tty”, O_RDWR|O_NONBLOCK)	 — 设置 &#x2F;dev&#x2F;tty (当前终端)非阻塞状态。(默认为阻塞状态)</p>
<h2 id="fcntl-改文件属性"><a href="#fcntl-改文件属性" class="headerlink" title="fcntl 改文件属性"></a>fcntl 改文件属性</h2><p>fcntl 用来改变一个【已经打开】的文件的 访问控制属性 </p>
<p>重点掌握两个参数的使用， F_GETFL，F_SETFL </p>
<p>fcntl： </p>
<p>​	int (int fd, int cmd, …) </p>
<p>fd 文件描述符 cmd 命令，决定了后续参数个数 </p>
<p>int flgs &#x3D; fcntl(fd, F_GETFL);</p>
<p>flgs |&#x3D; O_NONBLOCK </p>
<p>fcntl(fd, F_SETFL, flgs); </p>
<p>获取文件状态： F_GETFL </p>
<p>设置文件状态： F_SETFL</p>
<p>终端文件默认是阻塞读的，这里用 fcntl 将其更改为非阻塞读</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;unistd.h&gt;</span><br><span class="line">2. #include &lt;fcntl.h&gt;</span><br><span class="line">3. #include &lt;errno.h&gt;</span><br><span class="line">4. #include &lt;stdio.h&gt;</span><br><span class="line">5. #include &lt;stdlib.h&gt;</span><br><span class="line">6. #include &lt;string.h&gt;</span><br><span class="line">7.</span><br><span class="line">8. #define MSG_TRY &quot;try again\n&quot;</span><br><span class="line">9.</span><br><span class="line">10. int main(void)</span><br><span class="line">11. &#123;</span><br><span class="line">12. char buf[10];</span><br><span class="line">13. int flags, n;</span><br><span class="line">14.</span><br><span class="line">15. flags = fcntl(STDIN_FILENO, F_GETFL); //获取 stdin 属性信息</span><br><span class="line">16. if(flags == -1)&#123;</span><br><span class="line">17. perror(&quot;fcntl error&quot;);</span><br><span class="line">18. exit(1);</span><br><span class="line">19. &#125;</span><br><span class="line">20. flags |= O_NONBLOCK;</span><br><span class="line">21. int ret = fcntl(STDIN_FILENO, F_SETFL, flags);</span><br><span class="line">22. if(ret == -1)&#123;</span><br><span class="line">23. perror(&quot;fcntl error&quot;);</span><br><span class="line">24. exit(1);</span><br><span class="line">25. &#125;</span><br><span class="line">26.</span><br><span class="line">27. tryagain:</span><br><span class="line">28. n = read(STDIN_FILENO, buf, 10);</span><br><span class="line">29. if(n &lt; 0)&#123;</span><br><span class="line">30. if(errno != EAGAIN)&#123;</span><br><span class="line">31. perror(&quot;read /dev/tty&quot;);</span><br><span class="line">32. exit(1);</span><br><span class="line">33. &#125;</span><br><span class="line">34. sleep(3);</span><br><span class="line">35. write(STDOUT_FILENO, MSG_TRY, strlen(MSG_TRY));</span><br><span class="line">36. goto tryagain;</span><br><span class="line">37. &#125;</span><br><span class="line">38. write(STDOUT_FILENO, buf, n);</span><br><span class="line">39.</span><br><span class="line">40. return 0;</span><br><span class="line">41. &#125;</span><br></pre></td></tr></table></figure>

<h2 id="lseek-函数"><a href="#lseek-函数" class="headerlink" title="lseek 函数"></a>lseek 函数</h2><p>lseek 函数： <code>off_t lseek(int fd, off_t offset, int whence);</code></p>
<p> 参数： fd：文件描述符 		offset： 偏移量，就是将读写指针从 whence 指定位置向后偏移 offset 个单位 		whence：起始偏移位置：开始，读到，结尾 SEEK_SET&#x2F;SEEK_CUR&#x2F;SEEK_END </p>
<p>返回值： 成功：较起始位置偏移量 失败：-1 errno </p>
<p>应用场景： </p>
<ol>
<li><p>文件的“读”、“写”使用同一偏移位置。 2. 使用 lseek 获取文件大小 3. 使用 lseek 拓展文件大小：要想使文件大小真正拓展，必须引起 IO 操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int lenth = lseek ( fd,101，SEEK_END);</span><br><span class="line">printf( &quot;file size: %d\n&quot; , lenth) ;</span><br><span class="line">write(fd,&quot;$&quot;，1);</span><br></pre></td></tr></table></figure>

<p>​			 使用 truncate 函数，直接拓展文件。 <code>int ret = truncate(&quot;dict.cp&quot;, 250);</code>&#x2F;&#x2F;dict.cp是必须存在的</p>
</li>
</ol>
<p>lseek 示例，写一个句子到空白文件，完事调整光标位置，读取刚才写那个文件。 这个示例中，如果不调整光标位置，是读取不到内容的，因为读写指针在内容的末尾 代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;unistd.h&gt;</span><br><span class="line">4. #include &lt;string.h&gt;</span><br><span class="line">5. #include &lt;fcntl.h&gt;</span><br><span class="line">6.</span><br><span class="line">7. int main(void)</span><br><span class="line">8. &#123;</span><br><span class="line">9. int fd, n;</span><br><span class="line">10. char msg[] = &quot;It&#x27;s a test for lseek\n&quot;;</span><br><span class="line">11. char ch;</span><br><span class="line">12.</span><br><span class="line">13. fd = open(&quot;lseek.txt&quot;, O_RDWR|O_CREAT, 0644);</span><br><span class="line">14. if(fd &lt; 0)&#123;</span><br><span class="line">15. perror(&quot;open lseek.txt error&quot;);</span><br><span class="line">16. exit(1);</span><br><span class="line">17. &#125;</span><br><span class="line">18.</span><br><span class="line">19. write(fd, msg, strlen(msg)); //使用 fd 对打开的文件进行写操作，问价读写位置位于文件结尾处。</span><br><span class="line">20.</span><br><span class="line">21. lseek(fd, 0, SEEK_SET); //修改文件读写指针位置，位于文件开头。 注释该行会怎样呢？</span><br><span class="line">22.</span><br><span class="line">23. while((n = read(fd, &amp;ch, 1)))&#123;</span><br><span class="line">24. if(n &lt; 0)&#123;</span><br><span class="line">25. perror(&quot;read error&quot;);</span><br><span class="line">26. exit(1);</span><br><span class="line">27. &#125;</span><br><span class="line">28. write(STDOUT_FILENO, &amp;ch, n); //将文件内容按字节读出，写出到屏幕</span><br><span class="line">29. &#125;</span><br><span class="line">30.</span><br><span class="line">31. close(fd);</span><br><span class="line">32.</span><br><span class="line">33. return 0;</span><br><span class="line">34. &#125;</span><br></pre></td></tr></table></figure>

<p>下面这个代码用 lseek 的偏移来读取文件大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int lenth = lseek(fd,0,SEEK_END);</span><br><span class="line">printf ( &quot;file size: %d\n&quot; , lenth) ;</span><br></pre></td></tr></table></figure>

<p>对于写文件再读取那个例子，由于文件写完之后未关闭，读写指针在文件末尾，所以不调节指针，直 接读取不到内容。</p>
<p> lseek 读取的文件大小总是相对文件头部而言。 </p>
<p>用 lseek 读取文件大小实际用的是读写指针初末位置的偏移差，一个新开文件，读写指针初位置都在 文件开头。如果用这个来扩展文件大小，必须引起 IO 才行，于是就至少要写入一个字符。上面代码 出现 lseek 返回 799，ls 查看为 800 的原因是，lseek 读取到偏移差的时候，还没有写入最后的‘$’ 符号. 末尾那一大堆^@，是文件空洞，如果自己写进去的也想保持队形，就写入“\0”。 </p>
<p>拓展文件直接使用 truncate，简单粗暴： 使用 truncate 函数，直接拓展文件。 int ret &#x3D; truncate(“dict.cp”, 250);</p>
<h2 id="传入传出参数"><a href="#传入传出参数" class="headerlink" title="传入传出参数"></a>传入传出参数</h2><p>传入参数： 1. 指针作为函数参数。 2. 同常有 const 关键字修饰。 3. 指针指向有效区域， 在函数内部做读操作。</p>
<p> 传出参数： 1. 指针作为函数参数。 2. 在函数调用之前，指针指向的空间可以无意义，但必须有效。 3. 在函数内部，做写操作。 4。函数调用结束后，充当函数返回值。 </p>
<p>传入传出参数： 1. 指针作为函数参数。 2. 在函数调用之前，指针指向的空间有实际意义。 3. 在函数内部，先做读操作，后做写操作。 4. 函数调用结束后，充当函数返回值</p>
<h2 id="目录项和-inode"><a href="#目录项和-inode" class="headerlink" title="目录项和 inode"></a>目录项和 inode</h2><p>一个文件主要由两部分组成，dentry(目录项)和 inode </p>
<p>inode 本质是结构体，存储文件的属性信息，如：权限、类型、大小、时间、用户、盘快位置… 也叫做文件属性管理结构，大多数的 inode 都存储在磁盘上。 </p>
<p>少量常用、近期使用的 inode 会被缓存到内存中。 </p>
<p>所谓的删除文件，就是删除 inode，但是数据其实还是在硬盘上，以后会覆盖掉。</p>
<h2 id="stat-函数"><a href="#stat-函数" class="headerlink" title="stat 函数"></a>stat 函数</h2><p>获取文件属性，（从 inode 结构体中获取） </p>
<p>stat&#x2F;lstat 函数： <code>int stat(const char *path, struct stat *buf);</code> </p>
<p>参数： </p>
<p>​	path： 文件路径 </p>
<p>​	buf：（传出参数） 存放文件属性，inode 结构体指针。 </p>
<p>返回值： </p>
<p>​	成功： 0 </p>
<p>​	失败： -1 errno </p>
<p>获取文件大小： buf.st_size </p>
<p>获取文件类型： buf.st_mode </p>
<p>获取文件权限： buf.st_mode </p>
<p>符号穿透：stat 会。lstat 不会。</p>
<p>下面这个例子是获取文件大小的正规军解法，用 stat：</p>
<p><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230526211019247.png" alt="image-20230526211019247"></p>
<img src="/2023/05/21/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230526211019247.png" class title="This is an test image">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">man 2 stat</span><br><span class="line">进入之后G</span><br><span class="line">一般比较大的函数或者是难度大的有example</span><br></pre></td></tr></table></figure>

<p>stat 会拿到符号链接指向那个文件或目录的属性。 不想穿透符号就用 lstat（两个除了穿透符号这个性质以外就一样）</p>
<p><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230526213815013.png" alt="image-20230526213815013"></p>
<img src="/2023/05/21/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230526213815013.png" class title="This is an test image">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">用sb.st_mode &amp; SIFMT前4位就是SIFMT与上文件得出的mode</span><br><span class="line">switch (sb.st_mode &amp; S_IFMT) &#123;</span><br><span class="line">           case S_IFBLK:  printf(&quot;block device\n&quot;);            br</span><br><span class="line">eak;</span><br><span class="line">           case S_IFCHR:  printf(&quot;character device\n&quot;);        br</span><br><span class="line">eak;</span><br><span class="line">           case S_IFDIR:  printf(&quot;directory\n&quot;);               br</span><br><span class="line">eak;</span><br><span class="line">           case S_IFIFO:  printf(&quot;FIFO/pipe\n&quot;);               br</span><br><span class="line">eak;</span><br><span class="line">           case S_IFLNK:  printf(&quot;symlink\n&quot;);                 br</span><br><span class="line">eak;</span><br><span class="line">           case S_IFREG:  printf(&quot;regular file\n&quot;);            br</span><br><span class="line">eak;</span><br><span class="line">           case S_IFSOCK: printf(&quot;socket\n&quot;);                  br</span><br><span class="line">eak;</span><br><span class="line">           default:       printf(&quot;unknown?\n&quot;);                br</span><br><span class="line">eak;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>

<h2 id="fstat"><a href="#fstat" class="headerlink" title="fstat"></a>fstat</h2><p>一样的用法，可以用来读取文件描述符</p>
<h2 id="link-和-Unlink-隐式回收"><a href="#link-和-Unlink-隐式回收" class="headerlink" title="link 和 Unlink 隐式回收"></a>link 和 Unlink 隐式回收</h2><p>硬链接数就是 dentry 数目 </p>
<p>link 就是用来创建硬链接的 （硬链接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬链接到重要文件,以防止“误删”的功能假设我们删除了原始的<code>foo.txt</code>文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="built_in">rm</span> -f foo.txt </span><br><span class="line">➜  <span class="built_in">cat</span> bar.txt </span><br><span class="line">LeetCode</span><br></pre></td></tr></table></figure>

<p>此时文件的内容依然存在，所以只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个链接被删除后，文件的数据块及目录的连接才会被释放，也就是说，文件才会被真正删除）</p>
<p>（软连接可以是任意文件或目录，可以链接不同文件系统的文件，在对符号文件进行读或写操作的时候，系统会自动把该操作转换为对源文件的操作，但删除链接文件时，系统仅仅删除链接文件，而不删除源文件本身，这一点类似于 Windows 操作系统下的快捷方式。）</p>
<p><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230619154914148.png" alt="image-20230619154914148"></p>
<img src="/2023/05/21/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230619154914148.png" class title="This is an test image">

<p>link 可以用来实现 mv 命令 </p>
<p>函数原型： <code>int link(const char *oldpath, const char *newpath)</code> 用这个来实现 mv，用 oldpath 来创建 newpath，完事儿删除 oldpath 就行。 </p>
<p>删除一个链接 <code>int unlink(const char *pathname)</code> </p>
<p>unlink 是删除一个文件的目录项 dentry，使硬链接数-1 </p>
<p>unlink 函数的特征：清除文件时，如果文件的硬链接数到 0 了，没有 dentry 对应，但该文件仍不会 马上被释放，要等到所有打开文件的进程关闭该文件，系统才会挑时间将该文件释放掉。</p>
<p>在程序中加入段错误成分，段错误在 unlink 之前，由于发生段错误，程序后续删除 temp.txt 的 dentry 部分就不会再执行，temp.txt 就保留了下来，这是不科学的。 </p>
<p>在编程中以下几类做法容易导致段错误,基本上是<strong>错误地使用指针引起的</strong>。 所谓的段错误就是指访问的内存超出了系统所给这个程序的内存空间，段错误应该就是访问了不可访问的内存，这个内存区要么是不存在的，要么是受到系统保护的。</p>
<p>解决办法是检测 fd 有效性后，立即释放 temp.txt，由于进程未结束，虽然 temp.txt 的硬链接数已 经为 0，但还不会立即释放，仍然存在，要等到程序执行完才会释放。这样就能避免程序出错导致临 时文件保留下来。</p>
<p>因为文件创建后，硬链接数立马减为 0，即使程序异常退出，这个文件也会被清理掉。这时候的内容 是写在内核空间的缓冲区。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. /*</span><br><span class="line">2. *unlink 函数是删除一个 dentry</span><br><span class="line">3. */</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;fcntl.h&gt;</span><br><span class="line">6. #include &lt;stdlib.h&gt;</span><br><span class="line">7. #include &lt;string.h&gt;</span><br><span class="line">8. #include &lt;stdio.h&gt;</span><br><span class="line">9.</span><br><span class="line">10.</span><br><span class="line">11. int main(void)</span><br><span class="line">12. &#123;</span><br><span class="line">13. int fd, ret;</span><br><span class="line">14. char *p = &quot;test of unlink\n&quot;;</span><br><span class="line">15. char *p2 = &quot;after write something.\n&quot;;</span><br><span class="line">16.</span><br><span class="line">17. fd = open(&quot;temp.txt&quot;, O_RDWR|O_CREAT|O_TRUNC, 0644);</span><br><span class="line">18. if(fd &lt; 0)&#123;</span><br><span class="line">19. perror(&quot;open temp error&quot;);</span><br><span class="line">20. exit(1);</span><br><span class="line">21. &#125;</span><br><span class="line">22.</span><br><span class="line">23. ret = unlink(&quot;temp.txt&quot;); //具备了被释放的条件</span><br><span class="line">24. if(ret &lt; 0)&#123;</span><br><span class="line">25. perror(&quot;unlink error&quot;);</span><br><span class="line">26. exit(1);</span><br><span class="line">27. &#125;</span><br><span class="line">28.</span><br><span class="line">29. ret = write(fd, p, strlen(p));</span><br><span class="line">30. if (ret == -1) &#123;</span><br><span class="line">31. perror(&quot;-----write error&quot;);</span><br><span class="line">32. &#125;</span><br><span class="line">33.</span><br><span class="line">34. printf(&quot;hi! I&#x27;m printf\n&quot;);</span><br><span class="line">35. ret = write(fd, p2, strlen(p2));</span><br><span class="line">36. if (ret == -1) &#123;</span><br><span class="line">37. perror(&quot;-----write error&quot;);</span><br><span class="line">38. &#125;</span><br><span class="line">39.</span><br><span class="line">40. printf(&quot;Enter anykey continue\n&quot;);</span><br><span class="line">41. getchar();//在调用getchar()函数时，编译器会依次读取用户键入缓存区的一个字符(注意这里只读取一个字符，如果缓存区有多个字符，那么将会读取上一次被读取字符的下一个字符),是阻塞状态，在这里可以方便查看文件</span><br><span class="line">42.</span><br><span class="line">43. close(fd);</span><br><span class="line">44.</span><br><span class="line">45. return 0;</span><br><span class="line">46. &#125;</span><br></pre></td></tr></table></figure>

<p><strong>隐式回收</strong>： </p>
<p>​		当进程结束运行时，所有进程打开的文件会被关闭，申请的内存空间会被释放。系统的这一特性 称之为隐式回收系统资源。 </p>
<p>​		比如上面那个程序，要是没有在程序中关闭文件描述符，没有隐式回收的话，这个文件描述符会保留， 多次出现这种情况会导致系统文件描述符耗尽。所以隐式回收会在程序结束时收回它打开的文件使用 的文件描述符。</p>
<p><strong>文件描述符</strong>（file descriptor）就是内核为了高效管理这些已经被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I&#x2F;O操作的系统调用都通过文件描述符来实现。同时还规定系统刚刚启动的时候，0是标准输入，1是标准输出，2是标准错误。这意味着如果此时去打开一个新的文件，它的文件描述符会是3，再打开一个文件文件描述符就是4……</p>
<h2 id="文件目录-rwx-权限差异"><a href="#文件目录-rwx-权限差异" class="headerlink" title="文件目录 rwx 权限差异"></a>文件目录 rwx 权限差异</h2><p>vi 目录 会得到目录项的列表</p>
<p><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230527200057726.png" alt="image-20230527200057726"></p>
<img src="/2023/05/21/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230527200057726.png" class title="This is an test image">

<h2 id="目录操作函数"><a href="#目录操作函数" class="headerlink" title="目录操作函数"></a>目录操作函数</h2><p>目录操作函数： <code>DIR * opendir(char *name);</code> </p>
<p><code>int closedir(DIR *dp);</code></p>
<p><code>struct dirent *readdir(DIR * dp);</code> </p>
<p><code>struct dirent &#123; </code></p>
<p><code>inode </code></p>
<p><code>char dname[256]; &#125;</code></p>
<p> 没有写目录操作，因为目录写操作就是创建文件。可以用 touch</p>
<p>下面用目录操作函数实现一个 ls 操作：</p>
<p><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230527200502344.png" alt="image-20230527200502344"></p>
<img src="/2023/05/21/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230527200502344.png" class title="This is an test image">

<p>要隐藏这个.和..的话，在输出文件名的时候判定一下，只输出不是.和..的就行了</p>
<h2 id="应用程序的系统调用过程"><a href="#应用程序的系统调用过程" class="headerlink" title="应用程序的系统调用过程"></a>应用程序的系统调用过程</h2><p>应用程序-&gt;标库函数-&gt;系统调用-&gt;驱动-&gt;硬件</p>
<h2 id="递归遍历目录实现"><a href="#递归遍历目录实现" class="headerlink" title="递归遍历目录实现"></a>递归遍历目录实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">先写个简易版的，可以判定文件，读取文件大小：</span><br><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;pthread.h&gt;</span><br><span class="line">6. #include &lt;sys/stat.h&gt;</span><br><span class="line">7.</span><br><span class="line">8. void isFile(char *name)&#123;</span><br><span class="line">9. int ret = 0;</span><br><span class="line">10. struct stat sb;</span><br><span class="line">11.</span><br><span class="line">12. ret = stat(name, &amp;sb);</span><br><span class="line">13. if(ret == -1)&#123;</span><br><span class="line">14. perror(&quot;stat error&quot;);</span><br><span class="line">15. return;</span><br><span class="line">16. &#125;</span><br><span class="line">17.</span><br><span class="line">18. if(S_ISDIR(sb.st_mode))&#123;</span><br><span class="line">19.</span><br><span class="line">20. &#125;</span><br><span class="line">21. printf(&quot;%s\t%ld\n&quot;, name, sb.st_size);</span><br><span class="line">22.</span><br><span class="line">23. return;</span><br><span class="line">24. &#125;</span><br><span class="line">25. int main(int argc, char *argv[])&#123;</span><br><span class="line">26. if(argc == 1) &#123;</span><br><span class="line">27. isFile(&quot;.&quot;);</span><br><span class="line">28. &#125;</span><br><span class="line">29. else &#123;</span><br><span class="line">30. isFile(argv[1]);</span><br><span class="line">31. &#125;</span><br><span class="line">32.</span><br><span class="line">33. return 0;</span><br><span class="line">34. &#125;</span><br></pre></td></tr></table></figure>

<p>下面完善功能，把对目录的递归处理补全，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;sys/stat.h&gt;</span><br><span class="line">6. #include &lt;dirent.h&gt;</span><br><span class="line">7. #include &lt;pthread.h&gt;</span><br><span class="line">8.</span><br><span class="line">9. void isFile(char *name);</span><br><span class="line">10.</span><br><span class="line">11. // 打开目录读取,处理目录</span><br><span class="line">12. void read_dir(char *dir, void (*func)(char *))</span><br><span class="line">13. &#123;</span><br><span class="line">14. char path[256];</span><br><span class="line">15. DIR *dp;</span><br><span class="line">16. struct dirent *sdp;</span><br><span class="line">17.</span><br><span class="line">18. dp = opendir(dir);</span><br><span class="line">19. if (dp == NULL) &#123;</span><br><span class="line">20. perror(&quot;opendir error&quot;);</span><br><span class="line">21. return;</span><br><span class="line">22. &#125;</span><br><span class="line">23. // 读取目录项</span><br><span class="line">24. while((sdp = readdir(dp)) != NULL) &#123;</span><br><span class="line">25. if (strcmp(sdp-&gt;d_name, &quot;.&quot;) == 0 || strcmp(sdp-&gt;d_name, &quot;..&quot;) == 0) &#123;</span><br><span class="line">26. continue;</span><br><span class="line">27. &#125;</span><br><span class="line">28. //fprintf();发送格式化输出到流 stream 中简单一点：把数据写入文件（但是文件流不只是文件，c++可以定义文件流,比如stderr)</span><br><span class="line">29. // 目录项本身不可访问, 拼接. 目录/目录项</span><br><span class="line">30. sprintf(path, &quot;%s/%s&quot;, dir, sdp-&gt;d_name);//sprintf的作用是将一个格式化的字符串输出到一个目的字符串中</span><br><span class="line">31.</span><br><span class="line">32. // 判断文件类型,目录递归进入,文件显示名字/大小</span><br><span class="line">33. //isFile(path);</span><br><span class="line">34. (*func)(path);</span><br><span class="line">35. &#125;</span><br><span class="line">36.</span><br><span class="line">37. closedir(dp);</span><br><span class="line">38.</span><br><span class="line">39. return ;</span><br><span class="line">40. &#125;</span><br><span class="line">41.</span><br><span class="line">42. void isFile(char *name)</span><br><span class="line">43. &#123;</span><br><span class="line">44. int ret = 0;</span><br><span class="line">45. struct stat sb;</span><br><span class="line">46.</span><br><span class="line">47. // 获取文件属性, 判断文件类型</span><br><span class="line">48. ret = stat(name, &amp;sb);</span><br><span class="line">49. if (ret == -1) &#123;</span><br><span class="line">50. perror(&quot;stat error&quot;);</span><br><span class="line">51. return ;</span><br><span class="line">52. &#125;</span><br><span class="line">53. // 是目录文件</span><br><span class="line">54. if (S_ISDIR(sb.st_mode)) &#123;</span><br><span class="line">55. read_dir(name, isFile);</span><br><span class="line">56. &#125;</span><br><span class="line">57. // 是普通文件, 显示名字/大小</span><br><span class="line">58. printf(&quot;%10s\t\t%ld\n&quot;, name, sb.st_size);</span><br><span class="line">59.</span><br><span class="line">60. return;</span><br><span class="line">61. &#125;</span><br><span class="line">62.</span><br><span class="line">63.</span><br><span class="line">64. int main(int argc, char *argv[])</span><br><span class="line">65. &#123;</span><br><span class="line">66. // 判断命令行参数</span><br><span class="line">67. if (argc == 1) &#123;</span><br><span class="line">68. isFile(&quot;.&quot;);</span><br><span class="line">69. &#125; else &#123;</span><br><span class="line">70. isFile(argv[1]);</span><br><span class="line">71. &#125;</span><br><span class="line">72.</span><br><span class="line">73. return 0;</span><br><span class="line">74. &#125;</span><br></pre></td></tr></table></figure>

<h2 id="dup-和-dup2"><a href="#dup-和-dup2" class="headerlink" title="dup 和 dup2"></a>dup 和 dup2</h2><p>用来做重定向，本质就是复制文件描述符：<br>dup 和 dup2：<br><code>int dup(int oldfd);</code> 文件描述符复制。<br>oldfd: 已有文件描述符<br>返回：新文件描述符，这个描述符和 oldfd 指向相同内容。<br><code>int dup2(int oldfd, int newfd);</code> 文件描述符复制，oldfd 拷贝给 newfd。返回 newfd</p>
<p>下面讲 dup2（dupto）： 下面这个例子，将一个已有文件描述符 fd1 复制给另一个文件描述符 fd2，<strong>然后用 fd2 修改 fd1</strong> 指向 的文件：</p>
<p><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230531192509565.png" alt="image-20230531192509565"></p>
<img src="/2023/05/21/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230531192509565.png" class title="This is an test image">

<p>上面那个例子，fd1 是打开 hello.c 的文件描述符，fd2 是打开 hello2.c 的文件描述符 用 dup2 将 fd1 复制给了 fd2，于是在对 fd2 指向的文件进行写操作时，实际上就是对 fd1 指向的 hello.c 进行写操作。 这里需要注意一个问题，由于 hello.c 和 hello2.c 都是空文件，所以直接写进去没关系。但如果 hello.c 是非空的，写进去的内容默认从文件头部开始写，会覆盖原有内容。</p>
<p>dup2 也可以用于标准输入输出的重定向。 下面这个例子，将输出到 STDOUT 的内容重定向到文件里：</p>
<p><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230531192739775.png" alt="image-20230531192739775"></p>
<img src="/2023/05/21/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230531192739775.png" class title="This is an test image">

<p>这个程序，将 fd1 的内容复制给了 fd2，使得原来指向 hello2.c 的 fd2 也指向了 hello.c 并通过 fd2 向 hello.c 里写入了…。完事儿将标准输出重定向至 fd1，就是将要显示在标准输出的内容，写入了 fd1 指向的文件，就是 hello.c 中 这里有一点和上面程序不同，就是 hello.c 是处于打开状态的，连续写入两段话，写入… 的时候，读写指针在这句话末尾，就不会覆盖前面这句话。 这里再强调一下，打开一个文件，读写指针默认在文件头，如果文件本身有内容，直接写入会覆盖有内容。</p>
<h2 id="fcntl-实现-dup-描述符"><a href="#fcntl-实现-dup-描述符" class="headerlink" title="fcntl 实现 dup 描述符"></a>fcntl 实现 dup 描述符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fcntl 函数实现 dup：</span><br><span class="line">	int fcntl(int fd, int cmd, ....)</span><br><span class="line">	cmd: F_DUPFD</span><br><span class="line">	参 3: 被占用的，返回最小可用的。</span><br><span class="line">			未被占用的， 返回=该值的文件描述符。</span><br></pre></td></tr></table></figure>

<p>对于 fcntl 中的参数 0，这个表示 0 被占用，fcntl 使用文件描述符表中的最小文件描述符返回 假设传入 0，传一个 7，且 7 未被占用，则会返回 7 所以这个参数可以这样理解，你传入一个文件描述符 k，如果 k 没被占用，则直接用 k 复制 fd1 的内 容。如果 k 被占用，则返回描述符表中最小可用描述符，也就是自己指定一个一志愿，如果行，就返 回这个。如果不行，国家给你分配一个最小的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/14/Linux%E4%B8%8Agcc%E7%BC%96%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/14/Linux%E4%B8%8Agcc%E7%BC%96%E8%AF%91/" class="post-title-link" itemprop="url">Linux上gcc编译</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-14 10:41:46" itemprop="dateCreated datePublished" datetime="2023-05-14T10:41:46+08:00">2023-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-21 10:34:55" itemprop="dateModified" datetime="2023-05-21T10:34:55+08:00">2023-05-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="gcc-编译-4-步骤"><a href="#gcc-编译-4-步骤" class="headerlink" title="gcc 编译 4 步骤"></a>gcc 编译 4 步骤</h1><p>GCC（GNU Compiler Collection）是由 GNU 开发的编程语言编译器。 GCC最初代表“GNU C Compiler”，当时只支持C语言。 后来又扩展能够支持更多编程语言，包括 C++、Fortran 和 Java 等。</p>
<p>GCC 编译工具链在编译一个C源文件时需要经过以下 4 步：</p>
<ul>
<li>预处理：为把头文件的代码、宏之类的内容转换成生成的.i文件，还是C代码。</li>
<li>编译：把预处理后的.i文件通过编译成.s文件，汇编语言。</li>
<li>汇编：将汇编语言文件生成目标文件.o文件，机器码。</li>
<li>链接：将每个源文件对应的.o文件链接起来，就生成一个可执行程序文件</li>
</ul>
<p><strong>（1）预处理阶段</strong></p>
<p>预处理过程中，对源代码文件中的文件包含 (include)、 预编译语句 (如宏定义define等)进行展开，生成 .i 文件。 可理解为把头文件的代码、宏之类的内容转换成更纯粹的C代码，不过生成的文件以.i为后缀。</p>
<p>使用GCC的参数 “-E”，可以让编译器生成 .i 文件，参数 “-o”，可以指定输出文件的名字。</p>
<p>具体命令如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 预处理，可理解为把头文件的代码汇总成C代码，把*.c转换得到*.i文件</span><br><span class="line">gcc –E hello.c –o hello.i</span><br></pre></td></tr></table></figure>

<p><strong>（2）编译阶段</strong>（消耗时间、系统资源最多）</p>
<p>把预处理后的.i文件通过编译成为汇编语言，生成.s文件，即把代码从C语言转换成汇编语言，这是GCC编译器完成的工作。在这个过程，GCC会检查各个源文件的语法，即使我们调用了一个没有定义的函数，也不会报错。</p>
<p>GCC可以使用-S选项，让编译程序生成汇编语言的代码文件（.s后缀）。</p>
<p>warning时如果有行号，说明是编译阶段出错。</p>
<p>具体命令如下:</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译，可理解为把C代码转换为汇编代码，把*.i转换得到*.s文件</span></span><br><span class="line">gcc –S hello.i –o hello.s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以直接以C文件作为输入进行编译，与上面的命令是等价的</span></span><br><span class="line">gcc –S hello.c –o hello.s</span><br></pre></td></tr></table></figure>

<p><strong>（3）汇编阶段</strong></p>
<p>将汇编语言文件经过汇编，生成目标文件.o文件，每一个源文件都对应一个目标文件。即把汇编语言的代码转换成机器码，这是as汇编器完成的工作。</p>
<p>GCC的参数“c”表示只编译(compile)源文件但不链接，会将源程序编译成目标文件（.o后缀）。计算机只认识0或者1，不懂得C语言，也不懂得汇编语言，经过编译汇编之后，生成的目标文件包含着机器代码，这部分代码就可以直接被计算机执行。一般情况下，可以直接使用参数“c”，跳过上述的两个过程，具体命令 如下：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 汇编，可理解为把汇编代码转换为机器码，把*.s转换得到*.o，即目标文件</span></span><br><span class="line">gcc –c hello.s –o hello.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以直接以C文件作为输入进行汇编，与上面的命令是等价的</span></span><br><span class="line">gcc –c hello.c –o hello.o</span><br></pre></td></tr></table></figure>

<p>Linux下生成的 <em>.o目标文件、</em>so动态库文件以及下一小节链接阶段生成最终的可执行文件都是elf格式的， 可以使用“readelf”工具来查看它们的内容。</p>
<p><strong>（4）链接阶段</strong></p>
<p>最后将每个源文件对应的目标.o文件链接起来，就生成一个可执行程序文件，这是链接器ld完成的工作。</p>
<p>例如一个工程里包含了A和B两个代码文件，在链接阶段， 链接过程需要把A和B之间的函数调用关系理顺，也就是说要告诉A在哪里能够调用到fun函数， 建立映射关系，所以称之为链接。若链接过程中找不到fun函数的具体定义，则会链接报错。</p>
<p>虽然本示例只有一个hello.c文件，但它调用了C标准代码库的printf函数， 所以链接器会把它和printf函数链接起来，生成最终的可执行文件。</p>
<p>链接分为两种：</p>
<ul>
<li>动态链接：GCC编译时的默认选项。动态是指在应用程序运行时才去加载外部的代码库，不同的程序可以共用代码库。 所以动态链接生成的程序比较小，占用较少的内存。</li>
<li>静态链接：链接时使用选项 “–static”，它在编译阶段就会把所有用到的库打包到自己的可执行程序中。 所以静态链接的优点是具有较好的兼容性，不依赖外部环境，但是生成的程序比较大。</li>
</ul>
<p>执行如下命令体验静态链接与动态链接的区别：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在hello.o所在的目录执行如下命令</span></span><br><span class="line"><span class="comment"># 动态链接，生成名为hello的可执行文件</span></span><br><span class="line">//<span class="literal">-o</span>是用来指定生成文件的名字</span><br><span class="line">gcc hello.o –o hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以直接使用C文件一步生成，与上面的命令等价</span></span><br><span class="line">gcc hello.c <span class="literal">-o</span> hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># 静态链接，使用--static参数，生成名为hello_static的可执行文件</span></span><br><span class="line">gcc hello.o –o hello_static <span class="literal">--static</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以直接使用C文件一步生成，与上面的命令等价</span></span><br><span class="line">gcc hello.c <span class="literal">-o</span> hello_static <span class="literal">--static</span></span><br></pre></td></tr></table></figure>

<h2 id="当头文件和源码不在一个目录下时，需要指定头文件"><a href="#当头文件和源码不在一个目录下时，需要指定头文件" class="headerlink" title="当头文件和源码不在一个目录下时，需要指定头文件"></a>当头文件和源码不在一个目录下时，需要指定头文件</h2><p>gcc -I .&#x2F;hellodir hello.c -o hello 其中-I 参数指定头文件所在位置，位置可以在编译文件前，也可以在后面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-I 指定头文件所在目录位置</span><br><span class="line">-c 只做预处理，编译，汇编。得到二进制文件</span><br><span class="line">-g 编译时添加调试文件，用于 gdb 调试</span><br><span class="line">-Wall 显示所有警告信息</span><br><span class="line">-D 向程序中“动态”注册宏定义，一般可以用在调试，制作一个开关，比如ifdef,发布的时候就可以不用删除调试信息</span><br><span class="line">-l 指定动态库库名</span><br><span class="line">-L 指定动态库路径</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="动态库和静态库理论对比"><a href="#动态库和静态库理论对比" class="headerlink" title="动态库和静态库理论对比"></a>动态库和静态库理论对比</h2><p>静态库在文件中静态展开，所以有多少文件就展开多少次，非常吃内存，100M 展开 100 次，就是 1G， 但是这样的好处就是静态加载的速度快 </p>
<p>使用动态库会将动态库加载到内存，10 个文件也只需要加载一次，然后这些文件用到库的时候临时去加载，速度慢一些，但是很省内存 </p>
<p>动态库和静态库各有优劣，根据实际情况合理选用即可。</p>
<ul>
<li>1.动态库是否加载到内存,取决于程序是否运行</li>
<li>2.动态库每次加载的位置不固定</li>
<li>3.动、静态库共存时,编译器默认使用动态库</li>
</ul>
<h3 id="静态库制作"><a href="#静态库制作" class="headerlink" title="静态库制作"></a>静态库制作</h3><p>静态库名字以 lib 开头，以.a 结尾 ，.a是ELF文件，可重定位目标文件。</p>
<p>例如：<code>libmylib.a</code> </p>
<p>静态库生成指令 <code>ar rcs libmylib.a file1.o</code></p>
<p>步骤一： 写好源代码</p>
<p>步骤二： 编译源代码生成.o 文件</p>
<p>步骤三： 制作静态库 ar rcs libname.a file1.o file2.o …</p>
<p>静态库的使用： gcc test.c lib 库名.a -o a.out</p>
<h3 id="动态库制作-生成与位置无关代码"><a href="#动态库制作-生成与位置无关代码" class="headerlink" title="动态库制作-生成与位置无关代码"></a>动态库制作-生成与位置无关代码</h3><p>写在源代码里的函数，相对 main 函数偏移是一定的，链接时，回填 main 函数地址之后，其他源代码里的函数也就得到了地址。 </p>
<p>动态库里的函数会用一个@plt 来标识，当动态库加载到内存时，再用加载进去的地址将@plt 替换掉。</p>
<p>制作动态库的步骤 </p>
<ol>
<li>生成位置无关的.o 文件 <code>gcc -c add.c -o add.o -fPIC</code> 使用这个参数过后，生成的函数就和位置无关，挂上@plt 标识，等待动态绑定 </li>
<li>使用 gcc -shared 制作动态库 <code>gcc -shared -o lib 库名.so add.o sub.o div.o</code> </li>
<li>编译可执行程序时指定所使用的动态库。-l:指定库名 -L:指定库路径 <code>gcc test.c -o a.out -l mymath -L ./lib</code> </li>
<li>运行可执行程序.&#x2F;a.out</li>
</ol>
<h4 id="动态库加载错误原因及解决方式"><a href="#动态库加载错误原因及解决方式" class="headerlink" title="动态库加载错误原因及解决方式"></a>动态库加载错误原因及解决方式</h4><p>出错原因分析： </p>
<p>连接器： 工作于链接阶段，工作时需要 -l 和 -L </p>
<p>动态链接器： 工作于程序运行阶段，工作时需要提供动态库所在目录位置 </p>
<p>指定动态库路径并使其生效，然后再执行文件 </p>
<p>通过环境变量指定动态库所在位置：<code>export LD_LIBRARY_PATH=动态库路径</code></p>
<p>当关闭终端，再次执行 a.out 时，又报错。 </p>
<p>这是因为，环境变量是进程的概念，关闭终端之后再打开，是两个进程，环境变量发生了变化。 </p>
<p>要想永久生效，需要修改 bash 的配置文件：<code>vi ~./bashrc</code> </p>
<p>修改后要使配置文件立即生效：<code>. .bashrc</code> 或者 <code>source .bashrc</code> 或者重开终端让其自己加载 这下再执行 a.out 就不会报错</p>
<h4 id="动态库加载错误原因及解决方式-2"><a href="#动态库加载错误原因及解决方式-2" class="headerlink" title="动态库加载错误原因及解决方式 2"></a>动态库加载错误原因及解决方式 2</h4><p>解决方式： </p>
<p>【1】 通过环境变量： <code>export LD_LIBRARY_PATH=动态库路径</code></p>
<p> .&#x2F;a.out 成功！！！ （临时生效， 终端重启环境变量失效） </p>
<p>【2】 永久生效： 写入 终端配置文件。 .bashrc 建议使用绝对路径。 </p>
<pre><code>1) vi ~/.bashrc
2) 写入 export LD_LIBRARY_PATH=动态库路径 保存 
3) ..bashrc/ source .bashrc / 重启 终端 (三种方法都可以)---&gt; 让修改后的.bashrc 生效 
4) ./a.out 成功！！！ 
</code></pre>
<p>【3】 拷贝自定义动态库 到 &#x2F;lib (标准 C 库所在目录位置) </p>
<p>【4】 配置文件法 </p>
<ul>
<li>sudo vi &#x2F;etc&#x2F;ld.so.conf</li>
<li>写入 动态库绝对路径 保存 </li>
<li>sudo ldconfig -v 使配置文件生效。 </li>
<li>.&#x2F;a.out 成功！！！— 使用 ldd a.out 查看</li>
</ul>
<h3 id="数据段合并"><a href="#数据段合并" class="headerlink" title="数据段合并"></a>数据段合并</h3><p>在链接阶段完成，节省空间，将同样工作（例如只读）的数据段合并。</p>
<h2 id="头文件守卫："><a href="#头文件守卫：" class="headerlink" title="头文件守卫："></a>头文件守卫：</h2><p>防止头文件被重复包含 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ifndef _HEAD_H_ </span><br><span class="line">#define _HEAD_H_ </span><br><span class="line">...... </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h2 id="gdb-调试基础指令"><a href="#gdb-调试基础指令" class="headerlink" title="gdb 调试基础指令"></a>gdb 调试基础指令</h2><p>使用 gdb 之前，要求对文件进行编译时增加-g 参数，加了这个参数过后生成的编译文件会大一些， 这是因为增加了 gdb 调试内容 </p>
<p>gdb 调试工具： 大前提：程序是你自己写的。 —逻辑错误 </p>
<p>基础指令： </p>
<p>​	-g：使用该参数编译可以执行文件，得到调试表。 </p>
<p>​	gdb .&#x2F;a.out </p>
<p>​	list： list 1 列出源码。根据源码指定 行号设置断点。 断点那一行不会执行</p>
<p>​	b： b 20 在 20 行位置设置断点。 </p>
<p>​	run&#x2F;r: 运行程序 </p>
<p>​	n&#x2F;next: 下一条指令（会越过函数） </p>
<p>​	next&#x2F;n :下一个，调用函数就跑 </p>
<p>​	step&#x2F;s :单步，会进入调用的函数 </p>
<p>​	要注意的是，如果是系统函数，按 s 就出不来了，这时用 until+行号直接执行到行号处</p>
<p>​	s&#x2F;step: 下一条指令（会进入函数） </p>
<p>​	p&#x2F;print：p i 查看变量的值。 </p>
<p>​	continue：继续执行断点后续指令。 </p>
<p>​	finish：结束当前函数调用。 </p>
<p>​	quit：退出 gdb 当前调试。 </p>
<p>其他指令： </p>
<p>​	run：使用 run 查找段错误出现位置。 </p>
<p>​	set args： 设置 main 函数命令行参数 （在 start、run 之前） </p>
<p>​	run 字串 1 字串 2 …: 设置 main 函数命令行参数 </p>
<p>​	info b: 查看断点信息表 </p>
<p>​	b 20 if i &#x3D; 5： 设置条件断点。 </p>
<p>​	ptype：查看变量类型。 </p>
<p>​	bt：列出当前程序正存活着的栈帧。 </p>
<p>​	frame： 根据栈帧编号，切换栈帧。 </p>
<p>​	display：设置跟踪变量 </p>
<p>​	undisplay：取消设置跟踪变量。 使用跟踪变量的编号。</p>
<p>没有符号被读取—编译时没加-g 参数 </p>
<p>file 后面加使用-g 编译的文件，可以不用退出，gdb 直接读取后进行调试。</p>
<h2 id="makefile-基础规则"><a href="#makefile-基础规则" class="headerlink" title="makefile 基础规则"></a>makefile 基础规则</h2><p>makefile： 管理项目。 </p>
<p>命名：makefile 	Makefile — make 命令 </p>
<p>1 个规则： </p>
<p>目标：依赖条件 </p>
<p>​	（一个 tab 缩进）命令 </p>
<ol>
<li>目标的时间必须晚于依赖条件的时间，否则，更新目标 </li>
<li>依赖条件如果不存在，找寻新的规则去产生依赖条件。</li>
</ol>
<p>ALL：指定 makefile 的终极目标（第一行）。</p>
<p>2 个函数：</p>
<p>​    src &#x3D; $(wildcard .&#x2F;*.c): 匹配当前工作目录下的所有.c 文件。将文件名组成列表，赋值给变量 src。 src &#x3D; add.c sub.c div1.c </p>
<p>​    obj &#x3D; $(patsubst %.c, %.o, $(src)): 将参数3中，包含参数1的部分，替换为参数2。 obj &#x3D; add.o sub.o div1.o</p>
<p>  clean: (没有依赖)</p>
<p>​    -rm -rf $(obj) a.out “-”：作用是，删除不存在文件时，不报错。顺序执行结束。</p>
<p>  3 个自动变量：</p>
<p>​    $@: 在规则的命令中，表示规则中的目标。</p>
<p>​    $^: 在规则的命令中，表示所有依赖条件。</p>
<p>​    $&lt;: 在规则的命令中，表示第一个依赖条件。如果将该变量应用在模式规则中，它可将依赖条件列表中的依赖依次取出，套用模式规则。</p>
<p>  模式规则：</p>
<p>​    %.o:%.c</p>
<p>​      gcc -c $&lt; -o %@</p>
<p>  静态模式规则：</p>
<p>​    $(obj):%.o:%.c</p>
<p>​      gcc -c $&lt; -o %@  </p>
<p>  伪目标：</p>
<p>​    .PHONY: clean ALL</p>
<p>  参数：</p>
<p>​    -n：模拟执行make、make clean 命令。</p>
<p>​    -f：指定文件执行 make 命令。       xxxx.mk</p>
<p> makefile检测原理：</p>
<p>修改文件后，文件的修改时间发生变化，会出现目标文件的时间早于作为依赖材料的时间，出现这种情况的文件会重新编译。</p>
<p>修改sub.c后，sub.o的时间就早于sub.c ，a.out的时间也早于sub.o的时间了，于是重新编译这俩文件了。</p>
<h2 id="makefile两个函数和clean"><a href="#makefile两个函数和clean" class="headerlink" title="makefile两个函数和clean"></a>makefile两个函数和clean</h2><p>src &#x3D; $(wildcard *.c)</p>
<p>找到当前目录下所有后缀为.c的文件，赋值给src</p>
<p>obj &#x3D; $(patsubset %.c,%.o, $(src))</p>
<p>把src变量里所有后缀为.c的文件替换成.o</p>
<p>rm前面的-，代表出错依然执行。比如，待删除文件集合是5个，已经手动删除了1个，就只剩下4个，然而删除命令里面还是5个的集合，就会有删除不存在文件的问题，不加这-，就会报错，告诉你有一个文件找不到。加了-就不会因为这个报错。</p>
<h2 id="makefile3个自动变量和模式规则"><a href="#makefile3个自动变量和模式规则" class="headerlink" title="makefile3个自动变量和模式规则"></a>makefile3个自动变量和模式规则</h2><p>3个自动变量</p>
<p>$@ ：在规则命令中，表示规则中的目标</p>
<p>$&lt; ：在规则命令中，表示规则中的第一个条件，如果将该变量用在模式规则中，它可以将依赖条件列表中的依赖依次取出，套用模式规则</p>
<p>$^ ：在规则命令中，表示规则中的所有条件，组成一个列表，以空格隔开，如果这个列表中有重复项，则去重</p>
<p>模式规则：</p>
<p>%.o:%.c</p>
<p>  gcc -c $&lt; -o $@</p>
<h2 id="静态模式规则"><a href="#静态模式规则" class="headerlink" title="静态模式规则"></a>静态模式规则</h2><p>继续优化makefile，使用静态模式规则，就是指定模式规则给谁用，这里指定模式规则给obj用，以后文件多了，文件集合会有很多个，就需要指定哪个文件集合用什么规则</p>
<p>$(obj):%.o:%.c</p>
<p>gcc -c $&lt; -o $@</p>
<p>再来一个扩展</p>
<p>当前文件夹下有ALL文件或者clean文件时，会导致makefile瘫痪，如下所示，make clean没有工作</p>
<p>用伪目标来解决，添加一行  .PHONY: clean ALL</p>
<p>还有一个扩展就是，编译时的参数，-g,-Wall这些，可以放在makefile里面</p>
<p>主要是注意%的匹配理解，只匹配文件名，目录位置要手动添加</p>
<p>如果makefile的名字变化一下，比如，叫m6</p>
<p>用m6执行makefile，   make -f m6</p>
<p>用m6执行clean      make -f m6 clean</p>
<p>源码 add.c,sub.c 这些在 src 目录下，.o 文件要放在 obj 目录下，头文件 head.h 在 inc 目录下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">src = $(wildcard ./src/*.c)	# ./src/add.c ./src/ sub.c...</span><br><span class="line">obj = $(patsubst ./src/%.c, ./obj/%.o，$(src))</span><br><span class="line">inc_path = ./inc</span><br><span class="line">myArgs = -Wall -g</span><br><span class="line">ALL:a.out</span><br><span class="line">$(obj):./obj/%.o:./src/%.c</span><br><span class="line">	gcc -c $&lt; -o $@ $(myArgs) -I $(inc_path)</span><br><span class="line">a.out: $(obj)</span><br><span class="line">	gcc $^ -o $@ $(myArgs)</span><br><span class="line">clean:</span><br><span class="line">	-rm -rf $(obj) a.out</span><br><span class="line">.PHONY: clean ALL</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/" class="post-title-link" itemprop="url">深入理解计算机系统 第三章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-13 11:28:04" itemprop="dateCreated datePublished" datetime="2023-05-13T11:28:04+08:00">2023-05-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-28 11:04:18" itemprop="dateModified" datetime="2023-05-28T11:04:18+08:00">2023-05-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第3章程序的机器级表示"><a href="#第3章程序的机器级表示" class="headerlink" title="第3章程序的机器级表示"></a>第3章程序的机器级表示</h1><h2 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h2><p>其中一些关于机器代码和它的反汇编表示的特性值得注意:</p>
<ul>
<li>x86-64的指令长度从1到15个字节不等。常用的指令以及操作数较少的指令所需的字节数少，而那些不太常用或操作数较多的指令所需字节数较多。</li>
<li>设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。例如，只有指令pushq %rbx是以字节值53开头的。</li>
<li>反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码。</li>
<li>反汇编器使用的指令命名规则与GCC生成的汇编代码使用的有些细微的差别。在我们的示例中，它省略了很多指令结尾的‘q’。这些后缀是大小指示符，在大多数情况中可以省略。相反，反汇编器给call和ret 指令添加了‘q’后缀，同样，省略这些后缀也没有问题。</li>
</ul>
<p>虽然C编译器在把程序中表达的计算转换到机器代码方面表现出色，但是仍然有一些机器特性是C程序访问不到的。例如，每次 x86-64处理器执行算术或逻辑运算时，如果得到的运算结果的低8位中有偶数个1，那么就会把一个名为PF的1位条件码(condition code)标志设置为1，否则就设置为0。这里的PF表示“parity flag(奇偶标志)”。在C语言中计算这个信息需要至少7次移位、掩码和异或运算。即使作为每次算术或逻辑运算的一部分，硬件都完成了这项计算，而C程序却无法知道PF条件码标志的值。在程序中插入几条汇编代码指令就能很容易地完成这项任务。</p>
<p>在C程序中插入汇编代码有两种方法。第一种是，我们可以编写完整的函数，放进一个独立的汇编代码文件中，让汇编器和链接器把它和用C语言书写的代码合并起来。第二种方法是，我们可以使用GCC的内联汇编(inline assembly)特性，用asm伪指令可以在C程序中包含简短的汇编代码。这种方法的好处是减少了与机器相关的代码量。</p>
<p>当然，在C程序中包含汇编代码使得这些代码与某类特殊的机器相关(例如x86-64)，所以只应该在想要的特性只能以此种方式才能访问到时才使用它。</p>
<h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><p>由于是从16位体系结构扩展成32位的，Intel用术语“字(word)”表示16位数据类型。因此，称32位数为“双字(double words)”，称64位数为“四字(quad words)”。C语言基本数据类型对应的x86-64表示。标准int值存储为双字(32位)。指针(在此用char *表示)存储为8字节的四字，64位机器本来就预期如此。</p>
<table>
<thead>
<tr>
<th>C声明</th>
<th>Intel数据类型</th>
<th>汇编代码后缀</th>
<th>大小(字节)</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>字节</td>
<td>b</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td>字</td>
<td>w</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>双字</td>
<td>l</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>四字</td>
<td>q</td>
<td>8</td>
</tr>
<tr>
<td>char*</td>
<td>四字</td>
<td>q</td>
<td>8</td>
</tr>
<tr>
<td>float</td>
<td>单精度</td>
<td>s</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>双精度</td>
<td>l</td>
<td>8</td>
</tr>
</tbody></table>
<h2 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h2><p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20230515185054534.jpg" alt="image-20230515185054534"></p>
<img src="/2023/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20230515185054534.jpg" class title="This is an test image">

<h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p>MOV指令源和目的类型的组合。记住，<strong>第一个是源操作数，第二个是目的操作数。</strong></p>
<p>源操作数指定的值是一个立即数，存储在寄存器中或者内存中。目的操作数指定一个位置，要么是一个寄存器或者，要么是一个内存地址。</p>
<p>寄存器部分的大小必须与指令最后一个字符(‘b’，‘w’，‘1’或‘q’)指定的大小匹配。大多数情况中，MOV指令只会更新目的操作数指定的那些寄存器字节或内存位置。唯一的例外是movl指令以寄存器作为目的时，它会把该寄存器的高位4字节设置为0。造成这个例外的原因是x86-64采用的惯例，即任何为寄存器生成32位值的指令都会把该寄存器的高位部分置成0。</p>
<p>常规的movq指令只能以表示为32位补码数字的立即数作为源操作数，然后把这个值符号扩展得到64位的值，放到目的位置。movabsq指令能够以任意64位立即数值作为源操作数，并且只能以寄存器作为目的。</p>
<p>所有这些指令都把数据从源(在寄存器或内存中)复制到目的寄存器。MOVZ类中的指令把目的中剩余的字节填充为0，而MOVS类中的指令通过符号扩展来填充，把源操作的最高位进行复制。可以观察到，每条指令名字的最后两个字符都是大小指示符:第一个字符指定源的大小，而第二个指明目的的大小。</p>
<p><strong>局部变量通常是保存在寄存器中</strong>，而不是内存中。访问寄存器比访问内存要快得多。</p>
<h2 id="算术和逻辑操作"><a href="#算术和逻辑操作" class="headerlink" title="算术和逻辑操作"></a>算术和逻辑操作</h2><h3 id="加载有效地址"><a href="#加载有效地址" class="headerlink" title="加载有效地址"></a>加载有效地址</h3><p>加载有效地址(load effective address)指令leaq实际上是movq指令的变形。它的指令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。它的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读人数据，而是将有效地址写入到目的操作数。</p>
<h3 id="二元操作"><a href="#二元操作" class="headerlink" title="二元操作"></a>二元操作</h3><p>二元操作，其中，第二个操作数既是源又是目的。这种语法让人想起C语言中的赋值运算符，例如x-&#x3D;y。不过，要注意，源操作数是第一-个，目的操作数是第二个,对于不可交换操作来说，这看上去很奇特。例如，指令<code>subq %rax,%rdx</code>使寄存器%rdx的值减去%rax中的值。(将指令解读成“从%rdx中减去%rax”会有所帮助。)第一个操作数可以是立即数、寄存器或是内存位置。第二个操作数可以是<strong>寄存器或是内存位置</strong>。注意,当第二个操作数为内存地址(如果是寄存器地址加操作数格式则表示内存位置)时，处理器必须从内存读出值，执行操作，再把结果写回内存。</p>
<p>通常，编译器产生的代码中，会用一个寄存器存放多个程序值，还会在寄存器之间传送程序值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xorq %rdx, %rdx</span><br></pre></td></tr></table></figure>

<p>但是在产生这段汇编代码的 C 代码中，并没有出现 EXCLUSIVE-OR 操作。</p>
<p>A. 解释这条特殊的 EXCLUSIVE-OR 指令的效果，它实现了什么有用的操作。</p>
<p>B. 更直接地表达这个操作的汇编代码是什么？</p>
<p>C. 比较同样一个操作的两种不同实现的编码字节长度。</p>
<blockquote>
<p>A. 这个指令用来将寄存器 % rdx 设置为 0，运用了对任意 x，x^x&#x3D;0 这一属性。它对应于 C 语句 x&#x3D;0 。</p>
<p>B. 将寄存器 % rdx 设置为 0 的更直接的方法是用指令 movq $0, % rdx 。</p>
<p>C. 汇编和反汇编这段代码，我们发现使用 xorq 的版本只需要 3 个字节，而使用 movq 的版本需要 7 个字节。其他将 % rdx 设置为 0 的方法都依赖于这样一个属性，即任何更新低位 4 字节的指令都会把高位字节设置为 0 。因此，我们可以使用 xorl % edx, % edx（2 字节）或 movl $0, % edx（5 字节）。</p>
</blockquote>
<h3 id="特殊的算术操作"><a href="#特殊的算术操作" class="headerlink" title="特殊的算术操作"></a>特殊的算术操作</h3><p>此外，x86-64 指令集还提供了两条不同的“单操作数”乘法指令，以计算两个64位值的全128位乘积——一个是无符号数乘法(mulq)，而另一个是补码乘法(imulq)。这两条指令都要求一个参数必须在寄存器%rax中，而另一个作为指令的源操作数给出。然后乘积存放在寄存器%rdx(高64位)和%rax(低64位)中。虽然imulq这个名字可以用于两个不同的乘法操作，但是汇编器能够通过计算操作数的数目，分辨出想用哪条指令。</p>
<p>有符号除法指令idivl将寄存器%rdx(高64位)和%rax(低64位)中的128位数作为被除数，而除数作为指令的操作数给出。指令将商存储在寄存器%rax中，将余数存储在寄存器%rdx中。</p>
<p>对于大多数64位除法应用来说，除数也常常是一个64位的值。这个值应该存放在%rax中，%rdx的位应该设置为全0(无符号运算)或者%rax的符号位(有符号运算)。后面这个操作可以用指令cqto来完成。这条指令不需要操作数—它隐含读出%rax的符号位，并将它复制到%rdx的所有位。即汇编代码中除法前一行就是cqto.</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>为了提高空间和时间效率，x86-64过程只分配自己所需要的栈帧部分。例如，许多过程有6个或者更少的参数，那么所有的参数都可以通过寄存器传递。因此，某些栈帧部分可以省略。实际上，许多函数甚至根本不需要栈帧。当所有的局部变量都可以保存在寄存器中，而且该函数不会调用任何其他函数(有时称之为叶子过程，此时把过程调用看做树结构)时，就可以这样处理。</p>
<p>x86-64 中，可以通过寄存器最多传递6个整型(例如整数和指针)参数。寄存器的使用是有特殊顺序的，寄存器使用的名字取决于要传递的数据类型的大小，如果一个函数有大于6个整型参数，超出6个的部分就要通过栈来传递。</p>
<p>T2（callq）是子程序调用指令，这条指令会：</p>
<ol>
<li>调整栈寄存器 (%rsp-8 -&gt; %rsp）</li>
<li>把下一条指令的地址放到栈里（0x40054e-&gt;*%rsp)</li>
<li>以上两步简单来说就是把下一条指令的地址入栈（push）</li>
<li>然后子程序的地址（0x400540）加载至rip</li>
</ol>
<p>然后子程序开始执行。子程序以retq结束会执行出栈（pop）操作：</p>
<ol>
<li>当前的栈内容放入%rip</li>
<li>调整栈寄存器（%rsp+8 -&gt; %rsp）</li>
</ol>
<p>程序从0x40054e继续执行（之前入栈的地址）<strong>栈区的地址分配是从内存的高地址开始向低地址分配；</strong></p>
<h3 id="栈上的局部存储"><a href="#栈上的局部存储" class="headerlink" title="栈上的局部存储"></a>栈上的局部存储</h3><p>到目前为止我们看到的大多数过程示例都不需要超出寄存器大小的本地存储区域。不过有些时候，局部数据必须存放在内存中，常见的情况包括:</p>
<ul>
<li>寄存器不足够存放所有的本地数据。</li>
<li>对一个局部变量使用地址运算符‘&amp;’，因此必须能够为它产生一个地址（用leaq指令生成到这些位置的指针）。</li>
<li>某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到。在描述数组和结构分配时，我们会讨论这个问题。</li>
</ul>
<p>一般来说，过程通过减小栈指针在栈上分配空间。分配的结果作为栈帧的一部分，标号为“局部变量”。</p>
<h3 id="寄存器的局部存储空间"><a href="#寄存器的局部存储空间" class="headerlink" title="寄存器的局部存储空间"></a>寄存器的局部存储空间</h3><p>根据惯例，寄存器rbx、%rbp和%r12～%r15被划分为被调用者保存寄存器。当过程P调用过程Q时，Q必须保存这些寄存器的值，保证它们的值在Q返回到P时与Q被调用时是一样的。过程Q保存一个寄存器的值不变，要么就是根本不去改变它，要么就是把原始值压入栈中，改变寄存器的值，然后在返回前从栈中弹出旧值。压人寄存器的值会在栈帧中创建标号为“保存的寄存器”的一部分。有了这条惯例，P的代码就能安全地把值存在被调用者保存寄存器中(当然，要先把之前的值保存到栈上)，调用Q,然后继续使用寄存器中的值,不用担心值被破坏。</p>
<h2 id="异数的数据结构"><a href="#异数的数据结构" class="headerlink" title="异数的数据结构"></a>异数的数据结构</h2><h3 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h3><p>还可以观察到，一个联合的总的大小等于它最大字段的大小。<br>在一些下上文中，联合十分有用。但是，它也能引起一些讨厌的错误，因为它们绕过了C语言类型系统提供的安全措施。一种应用情况是，我们事先知道对一个数据结构中的两个不同字段的使用是互斥的，那么将这两个字段声明为联合的一部分，而不是结构的一部分，会减小分配空间的总量。</p>
<p>开始的跳转表的汇编代码声明在第2行包含下面这样的命令:<br>.align 8<br>这就保证了它后面的数据(在此，是跳转表的开始)的起始地址是8的倍数。因为每个表项长8个字节，后面的元素都会遵守8字节对齐的限制。</p>
<h2 id="在机器级程序中将控制与数据结合起来"><a href="#在机器级程序中将控制与数据结合起来" class="headerlink" title="在机器级程序中将控制与数据结合起来"></a>在机器级程序中将控制与数据结合起来</h2><h3 id="理解指针"><a href="#理解指针" class="headerlink" title="理解指针"></a>理解指针</h3><p>leaq指令是设计用来计算内存引用的地址的，&amp;运算符的机器代码实现常常用这条指令来计算表达式的值。</p>
<h3 id="GDB命令"><a href="#GDB命令" class="headerlink" title="GDB命令"></a>GDB命令</h3><p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20230524151520753.png" alt="image-20230524151520753"></p>
<img src="/2023/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20230524151520753.png" class title="This is an test image">

<p>GDB的命令语法有点晦涩，但是在线帮助信息(用GDB的 help命令调用)能克服这些毛病。相对于使用命令行接口来访问GDB，许多程序员更愿意使用DDD，它是 GDB的一个扩展，提供了图形用户界面。</p>
<h3 id="内存越界引用和缓冲区溢出"><a href="#内存越界引用和缓冲区溢出" class="headerlink" title="内存越界引用和缓冲区溢出"></a>内存越界引用和缓冲区溢出</h3><p>更好一点的版本是使用fgets函数，它包括一个参数，限制<strong>待读入的最大字节数</strong>。通常，使用gets或其他任何能导致存储溢出的函数，都是不好的编程习惯。不幸的是，很多常用的库函数，包括strcpy、strcat和 sprintf都有一个属性——不需要告诉它们目标缓冲区的大小，就产生一个字节序列[97]。超过待读入最大字节数就可能发生错误，这样的情况就会导致缓冲区溢出漏洞。</p>
<p>如在栈上分配了24个字节，待读入最大字节为8</p>
<p>echo执行时栈的组织。该程序把栈指针减去了24，在栈上分配了24个字节。字符数组buf位于栈顶，可以看到,%rsp被复制到%rdi作为调用gets和puts 的参数。这个调用的参数和存储的返回指针之间的16字节是未被使用的。只要用户输人不超过7个字符，gets返回的字符串(包括结尾的null)就能够放进为buf分配的空间里。不过，长一些的字符串就会导致gets覆盖栈上存储的某些信息。随着字符串变长，下面的信息会被破坏:</p>
<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20230525102612348.png" alt="image-20230525102612348"></p>
<img src="/2023/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20230525102612348.png" class title="This is an test image">

<h2 id="浮点代码"><a href="#浮点代码" class="headerlink" title="浮点代码"></a>浮点代码</h2><p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20230527153556717.png" alt="image-20230527153556717"></p>
<img src="/2023/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20230527153556717.png" class title="This is an test image">

<p>在x86-64 中，XMM寄存器用来向函数传递浮点参数，以及从函数返回浮点值。如图3-45所示，可以看到如下规则:</p>
<ul>
<li>XMM寄存器%xmm0～%xmm7最多可以传递8个浮点参数。按照参数列出的顺序使用这些寄存器。可以通过栈传递额外的浮点参数。</li>
<li>函数使用寄存器%xmm0来返回浮点值。</li>
<li>所有的XMM寄存器都是调用者保存的。被调用者可以不用保存就覆盖这些寄存器中任意一个。</li>
</ul>
<p>当函数包含指针、整数和浮点数混合的参数时，指针和整数通过通用寄存器传递，而浮点值通过XMM寄存器传递。也就是说，参数到寄存器的映射取决于它们的类型和排列的顺序。下面是一些例子:<br><code>double f1(int x,double y, long z);</code><br>这个函数会把x存放在% edi中，y放在%xmm0中，而z放在%rsi中。<br><code>double f2(double y, int x，long z);</code><br>这个函数的寄存器分配与函数f1相同。<br><code>double f1(float x, double *y，long*z);</code><br>这个函数会将x放在%xmm0中，y放在%rdi中，而z放在%rsi中。</p>
<h3 id="定义和使用浮点常数"><a href="#定义和使用浮点常数" class="headerlink" title="定义和使用浮点常数"></a>定义和使用浮点常数</h3><p>和整数运算操作不同，AVX浮点操作不能以立即数值作为操作数。相反，编译器必须为所有的常量值分配和初始化存储空间。然后代码在把这些值从内存读人。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">深入理解计算机系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-05 16:12:22" itemprop="dateCreated datePublished" datetime="2023-05-05T16:12:22+08:00">2023-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-11 17:40:00" itemprop="dateModified" datetime="2023-05-11T17:40:00+08:00">2023-05-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第2章-信息的表示和处理"><a href="#第2章-信息的表示和处理" class="headerlink" title="第2章 信息的表示和处理"></a>第2章 信息的表示和处理</h1><h4 id="文字编码的Unicode标准"><a href="#文字编码的Unicode标准" class="headerlink" title="文字编码的Unicode标准"></a>文字编码的Unicode标准</h4><p>基本编码，称为Unicode的“统一字符集”，使用32位来表示字符。这好像要求文本串中每个字符要占用4个字节。不过，可以有一些替代编码，常见的字符只需要1个或2个字节，而不太常用的字符需要多一些的字节数。特别地，UTF-8表示将每个字符编码为一个字节序列，<strong>这样标准ASCII字符还是使用和它们在ASCII 中一样的单字节编码</strong>，这也就意味着所有的ASCII字节序列用ASCII码表示和用UTF-8表示是一样的。</p>
<p>Java编程语言使用Unicode来表示字符串。对于C语言也有支持 Unicode的程序库。</p>
<p>在使用ASCII码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关。因而，<strong>文本数据比二进制数据具有更强的平台独立性</strong>。</p>
<p>不同的机器类型使用不同的且不兼容的指令和编码方式。即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。</p>
<h2 id="c语言的移位运算"><a href="#c语言的移位运算" class="headerlink" title="c语言的移位运算"></a>c语言的移位运算</h2><p>C语言标准并没有明确定义对于有符号数应该使用哪种类型的右移–算术右移或者<strong>逻辑右移</strong>（不管符号均补0）都可以。不幸地，这就意味着任何假设一种或者另一种右移形式的代码都可能会遇到可移植性问题。然而，实际上，几乎所有的编译器&#x2F;机器组合都对有符号数使用<strong>算术右移</strong>（有符号时最高位是1补1），且许多程序员也都假设机器会使用这种右移。另一方面，对于无符号数，右移必须是逻辑的。<br>与C相比，Java对于如何进行右移有明确的定义。表达是x&gt;&gt;k会将x算术右移k个位置，而x&gt;&gt;&gt;k会对x做逻辑右移。</p>
<h3 id="移动k-位，这里k-很大"><a href="#移动k-位，这里k-很大" class="headerlink" title="移动k 位，这里k 很大"></a>移动k 位，这里k 很大</h3><p>对于一个由w位组成的数据类型，如果要移动k≥w位会得到什么结果呢?例如，计算下面的表达式会得到什么结果，假设数据类型int为w&#x3D;32:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">intlval =OxFEDCBA98&lt;&lt; 32;</span><br><span class="line">intaval =OxFEDCBA98&gt;&gt;36;</span><br><span class="line">unsigned uval =OxFEDCBA98u &gt;&gt;40;</span><br></pre></td></tr></table></figure>

<p>C语言标准很小心地规避了说明在这种情况下该如何做。在许多机器上，当移动一个w位的值时，移位指令只考虑位移量的低 log2 w位，因此实际上位移量就是通过计算k mod w得到的。例如，当w&#x3D;32时，上面三个移位运算分别是移动0、4和8位，得到结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lval 0xFEDCBA98</span><br><span class="line">aval 0xFFEDCBA9</span><br><span class="line">uval 0x00FEDCBA</span><br></pre></td></tr></table></figure>

<p>不过这种行为对于C程序来说是没有保证的，所以应该保持位移量小于待移位值的位数。另一方面，Java 特别要求位移数量应该按照我们前面所讲的求模的方法来计算。</p>
<h2 id="补码编码"><a href="#补码编码" class="headerlink" title="补码编码"></a>补码编码</h2><p>采用补码表示的32位大端法机器（符合习惯，先输出低地址的高位）上输出打印16进制时：是看补码来转换。</p>
<p>原理:补码编码的定义<br><img src="/2023/05/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Users\86191\AppData\Roaming\Typora\typora-user-images\image-20230507151108343.png" alt="image-20230507151108343"></p>
<p>例如1001（-1）的补码是1111可以根据上面计算-8+7&#x3D;-1</p>
<p><strong>负数的补码，是能够和其相反数相加通过溢出从而使计算机内计算结果变为0的二进制码</strong>。这是补码设计的初衷，具体目标就是让1+（-1）&#x3D;0，这利用原码是无法得到的</p>
<p>对于大多数C语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是:数值可能会改变，但是<strong>位模式不变</strong>。</p>
<p>无符号表示中的UMax竟有着和补码表示的-1相同的位模式。我们在这两个数之间也能看到这种关系<br>$$<br>:1+UMax_w&#x3D;2^w<br>$$<br>原理:补码转换为无符号数<br>对满足TMin_x≤x≤TMax_w的x有:<br>$$<br>T2U_w(x)&#x3D;\begin{cases} x+2^w,x&lt;0\ x,x&gt;&#x3D;0\end{cases}<br>$$<br>一个无符号数u和与之对应的有符号数U2T_w(u)之间的关系:</p>
<p>原理:无符号数转换为补码</p>
<p>对满足0≤u≤UMax _w的u有:<br>$$<br>U2T_w(u)&#x3D;\begin{cases} u-2^w,u&gt;TMax_w\ u,x&lt;&#x3D;TMax_w\end{cases}<br>$$<br>总结一下，我们考虑无符号与补码表示之间互相转换的结果。对于在范围0≤T&lt;TMax_w之内的值x而言，我们得到T2U_w(x)&#x3D;x和U2T_w(x)&#x3D;x。也就是说，在这个范围内的数字有相同的无符号和补码表示。对于这个范围以外的数值，转换需要加上或者减去2^w。例如，我们有<br>$$<br>T2U_w(-1)&#x3D;-1+2^w&#x3D;UMax_w<br>$$<br>—-最靠近0的负数映射为最大的无符号数</p>
<h2 id="c语言里面TMin不能写成-2147483648的原因"><a href="#c语言里面TMin不能写成-2147483648的原因" class="headerlink" title="c语言里面TMin不能写成-2147483648的原因"></a>c语言里面TMin不能写成-2147483648的原因</h2><p>C语言中，将TMin（32位有符号整数的最小值）写成 <strong>-2147483647-1</strong>，而不是简单地写成 -2147483648 或 0x80000000 。</p>
<p>可见如果不发生溢出，整型常量的值总是非负数。如果前面<strong>出现符号</strong>，则是对整型常量使用的一元运算符，而不是整型常量的一部分。</p>
<p>如果将TMin32写成-2147483648并且将代码在一个32位的机器上面编译，当编译器遇到**-X<strong>形式的数值，它首先会确定</strong>X<strong>的数据类型和值，然后取</strong>X**的。</p>
<p>由于-2147483648超过了int所能够表示的范围，编译器就会再次选择一种可以正确的表示此值的类型。然后它就会按照第一个表格（十进制）的顺序往下继续尝试类型，再假设编译器采用的标准是ISO C90，int-&gt;long-&gt;unsigned，然后就发现unsigned是第一个合适的数据类型。正如我们知道的，2147483648和-2147483648在32位数值上拥有同样的位表示，使得此常量的最终数据类型是unsigned且值为2147483648。这对于16进制的0x80000000也是相同的结果。</p>
<p>用一句话来解释C语言中TMin32的古怪写法的原因：虽然-2147483648 这个数值能够用int类型(4字节)来表示，但在C语言中却没法写出对应这个数值的int类型常量。</p>
<h2 id="补码的非"><a href="#补码的非" class="headerlink" title="补码的非"></a>补码的非</h2><p>原理:补码的非<br>对满足TMin_w≤x≤TMax_w 的x，其补码的非-^t_wx由下式给出<br>$$<br>-^t_wx&#x3D;\begin{cases}TMin_w,x&#x3D;TMin_w\-x,x&gt;TMin_w\end{cases}<br>$$<br>此处设w&#x3D;4，用补码可表示的范围就是[-8,7]，对于-8，它的“补码的非”还是-8,而[-7,7]补码的非就是原数的负数，比如说-4的“补码的非”是-4取负，即：4，而3的“补码的非”是3取负，即：-3。这是“补码的非”的定义；注意：“补码的非”并不是把“一个数的补码按位取非”</p>
<p>TMin_w&#x3D;-2^w-1</p>
<p>执行位级补码非的第一种方法是对每一位求反，再对结果加1。在C语言中，我们可以说，对于任意整数值x，计算表达式-x和~x+1得到的结果完全一样。</p>
<h2 id="对TMin-w-x3D-2-w-1的解释"><a href="#对TMin-w-x3D-2-w-1的解释" class="headerlink" title="对TMin_w&#x3D;-2^w-1的解释"></a>对TMin_w&#x3D;-2^w-1的解释</h2><p>如w&#x3D;4的-8&#x3D;1000，可以参考-2为例</p>
<p>[-2]原 &#x3D; 1 0010    [-2]补 &#x3D; 11110</p>
<p>如我所说，没有符号位，那么11110就是30，也就是说 -2的补码是30（%2^5）</p>
<h2 id="补码移位"><a href="#补码移位" class="headerlink" title="补码移位"></a>补码移位</h2><p>移位也是运算，需要将负数的原码变成补码移位</p>
<p>对无符号运算使用移位是非常简单的，部分原因是由于无符号数的右移一定是逻辑右移（不管最高位符号）。对于x大于等于0的有符号一样逻辑右移。</p>
<p>负数在执行算术右移之前加上一个适当的偏置量是可以导致结果正确舍入的。</p>
<p>补码除以2的幂(<strong>右移之前加上一个偏量</strong>，结果就向零舍入了).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int optarith(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    int t = x;</span><br><span class="line">    x &lt;&lt;= 5;</span><br><span class="line">    x -= t;</span><br><span class="line">    if (y &lt; 0)</span><br><span class="line">        y += 7;//加上一个适当的偏置量111,是为了正确右移3位，若右移4位，则加15（1111）</span><br><span class="line">    y &gt;&gt;= 3; /* Arithmetic shift */</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IEEE浮点标准"><a href="#IEEE浮点标准" class="headerlink" title="IEEE浮点标准"></a>IEEE浮点标准</h2><p>IEEE浮点标准用<br>$$<br>V&#x3D;（-1）^s<em>M</em>2^E<br>$$<br> 的形式来表示一个数，符号s，尾数M，阶码E</p>
<p>C语言中，单精度（float）的s为1b，E为8b，M为23b，双精度（double）的s为1b，E为11b，M为52b。</p>
<p>阶码的值<strong>E&#x3D;e-Bias</strong>，e是无符号数，Bias为偏置值，等于 2^(k-1)−1 (float为127，double为1023)</p>
<h3 id="计算-IEEE-754-标准浮点数的真值"><a href="#计算-IEEE-754-标准浮点数的真值" class="headerlink" title="计算 IEEE 754 标准浮点数的真值"></a>计算 IEEE 754 标准浮点数的真值</h3><p>在上述内容的分析之后，再通过观察分析以下这个 IEEE 754 单精度浮点数格式表示的数，系统性了解如何计算出 IEEE 754 标准浮点数的真值：</p>
<p>1 100 0000 1010 0000 0000 0000 0000 0000<br>上数分别对应图1-1的中 S（符号码，0 正，1 负），E (阶码) ，M (尾数数值)为：</p>
<p>S (红色部分) ：1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1，表示这个浮点数是个负数；</span><br></pre></td></tr></table></figure>

<p>E (蓝色部分) ：100 0000 1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100 0000 1，阶码，其真值为 ：移码 - 偏置值 =&gt; 1000 0001 - 0111 1111 = 0000 0010 = 2D；（对应下面的2^2D）</span><br></pre></td></tr></table></figure>

<p>M (黑色部分) ：010 0000 0000 0000 0000 0000</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">010 0000 0000 0000 0000 0000 表示这个浮点数的尾数部分，其真值为：被隐含的最高位1 + 0.尾数部分 =&gt; 1 + 0.01 = 1.01B;</span><br></pre></td></tr></table></figure>

<p>通过对 S，E，M 的分析，我们可以计算出该浮点数的真值，即：</p>
<p>-1.01B * 2^10B &#x3D; 1.25D （-1.01B）* 2^2D &#x3D; -5.0D</p>
<hr>
<p>十进制数12345具有二进制[0011 0000 0011 1001]（0x3039），通过将二进制小数点左移13位，得到这个数的一个规格化表示 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12345=1.1000000111001_2×2^13 </span><br></pre></td></tr></table></figure>

<p>，为了使用IEEE单精度（float）形式来编码，我们丢弃开头的1，并且在末尾增加10个0（单精度的尾数位23位，13+10&#x3D;23），来构造小数字段，得到二进制[1000000111001<em>0000000000</em>]，为了得到阶码字段，将13加上偏置量127，得到140，二进制表示为[10001100]，加上符号位0，得到12345.0的二进制浮点数[0100 0110 0100 0000 1110 0100 0000 0000]（0x4640E400），比较整数12345（0x3039）和浮点数12345.0（0x4640E400）的位级表示：</p>
<p>（0x00003039）0000000000000000001<em><strong>1000000111001</strong></em></p>
<p>（0x4640E400）010001100<em><strong>1000000111001</strong></em>0000000000</p>
<p>阶码的值E&#x3D;e-Bias,产生指数的取值范围，对于单精度是一126～＋127，而对于双精度是一1022~+1023。</p>
<h3 id="十进制数转为-IEEE-754-浮点数格式"><a href="#十进制数转为-IEEE-754-浮点数格式" class="headerlink" title="十进制数转为 IEEE 754 浮点数格式"></a>十进制数转为 IEEE 754 浮点数格式</h3><p>同样地再用一个例子 十进制数转为 IEEE 754 浮点数的例子，加深对 十进制数 与 IEEE 754 浮点数之间的转换的理解。</p>
<p> 例如：将十进制数 -0.75 转为 IEEE 754 的单精度浮点数格式表示，分析过程如下：</p>
<p>过程A： -0.75D &#x3D; -0.11B &#x3D; -1.1B * 2^(-1B)<br>S：1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-0.75 为负数，故 S 符号码为 1</span><br></pre></td></tr></table></figure>

<p>E：0111 1110</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由 过程A 得，阶码的真值为 -0000 0001(因为是2^(-1B)，与上面例子一致) ，其移码为：-0000 0001 + 0111 1111 = 0111 1110</span><br></pre></td></tr></table></figure>

<p>M：100 0000 0000 0000 0000 0000</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由 过程A 得，尾数码真值为：-1.1，隐含最高位 1 ，取小数部分，得100 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>

<p>最终结果为：</p>
<p>1 011 1111 0100 0000 0000 0000 0000 0000</p>
<h2 id="向偶数舍人在大多数现实情况中避免了这种统计偏差。"><a href="#向偶数舍人在大多数现实情况中避免了这种统计偏差。" class="headerlink" title="向偶数舍人在大多数现实情况中避免了这种统计偏差。"></a><strong>向偶数舍人在大多数现实情况中避免了这种统计偏差</strong>。</h2><p>在50%的时间里，它将向上舍人，而在50%的时间里，它将向下舍入。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/24/c-%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/24/c-%E7%B1%BB/" class="post-title-link" itemprop="url">c++类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-24 09:39:59 / 修改时间：15:12:34" itemprop="dateCreated datePublished" datetime="2023-04-24T09:39:59+08:00">2023-04-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>C++要求对一般的内置函数要用关键字inline声明，但对类内定义的成员函数，可以省略inline，因为<strong>这些成员函数已经被隐含地指定为内置函数了</strong>。</p>
<p>类的隐式内联和显式内联：</p>
<ul>
<li>类内部的内联函数：类内部只要定义在函数其实都是默认inline的（即通常我们说的尽量不要往.h中类定义的地方直接定义函数，最好只是做一个申明，这个说法其实不太好，因为这会破坏隐藏内联的功能）。</li>
<li>虽然说即便是隐藏的内联，也不一定是内联的，最后还是编译器决定，但是定义在.cpp中的内容，等于是放弃了内联功能，这种可能性降低的写法其实是不推荐的。</li>
<li>另外，也可以用inline放在开头，进行显式的内联，但是仍然需要注意：类内部成员函数的申明和最终的成员函数的定义（可以放在类定义的外部，但是还是要在同一个.h中，否则inline不会生效）。所以，从这个角度看，基本上可以引出一条规定：一些简单的函数、构造函数、析构函数，推荐在类内部进行直接定义，这样能够用到inline功能，对于性能来说更加有利的。至于可读性方面的考虑，完全可以加一些范围的注释、分类，将需要inline的定义在一撮，另外需要在cpp中实现的“复杂”函数，申明在另外一撮。</li>
</ul>
<h2 id="C-中常量成员函数"><a href="#C-中常量成员函数" class="headerlink" title="C++中常量成员函数"></a>C++中常量成员函数</h2><p>可以将C++中类的成员函数声明为常量，这种成员函数叫做常量成员函数（const member function）。</p>
<h3 id="1-声明"><a href="#1-声明" class="headerlink" title="1 声明"></a>1 声明</h3><p>将const关键字放在类成员函数的参数列表之后，表示该函数为常量成员函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class MyClass</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">int consFunc() const;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">int m_MyNum;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-定义"><a href="#2-定义" class="headerlink" title="2 定义"></a>2 定义</h3><p>可以在类内定义consFunc()函数，也可以在类外定义。不管是在类内还是类外定义该函数，都要使用关键字const。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int MyClass::consFunc() const</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">return this-&gt;m_MyNum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-含义"><a href="#3-含义" class="headerlink" title="3 含义"></a>3 含义</h3><p>在“2定义”中定义的consFunc()函数中，如果不添加const关键字，此时constFunc()是普通的成员函数，此时this的类型是MyClass* const，即this本身是常量，但是其指向的类型是非常量。这就意味着我们不能把this绑定到一个常量对象上。如果要把this绑定到一个常量对象上，必须要把this定义成const MyClass* const，即指向常量的常量。在类成员函数的参数列表之后添加const关键字，就相当于把this定义成const MyClass* const。</p>
<h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4 注意事项"></a>4 注意事项</h3><h4 id="4-1-常量对象必须调用常量成员函数"><a href="#4-1-常量对象必须调用常量成员函数" class="headerlink" title="4.1 常量对象必须调用常量成员函数"></a>4.1 常量对象必须调用常量成员函数</h4><p>正如“3 含义”中提到的，如果通过常量对象调用类的成员函数，该成员函数必须是常量成员函数。</p>
<h4 id="4-2-非常量对象可以调用常量成员函数"><a href="#4-2-非常量对象可以调用常量成员函数" class="headerlink" title="4.2 非常量对象可以调用常量成员函数"></a>4.2 非常量对象可以调用常量成员函数</h4><p>因为可以将一个非常量赋值给常量，所以非常量对象可以调用常量成员函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass myclass;</span><br><span class="line"></span><br><span class="line">myclass.consFunc();</span><br></pre></td></tr></table></figure>



<h4 id="4-3-常量成员函数中不能修改成员变量"><a href="#4-3-常量成员函数中不能修改成员变量" class="headerlink" title="4.3 常量成员函数中不能修改成员变量"></a>4.3 常量成员函数中不能修改成员变量</h4><p>因为常量成员函数中的this类型是const MyClass* const，所以不能通过this来修改成员变量。</p>
<p>如果consFunc()函数的定义改为如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int MyClass::consFunc() const</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">return this-&gt;m_MyNum++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则此时程序会报错，error C3490: 由于正在通过常量对象访问“m_MyNum”，因此无法对其进行修改。</p>
<hr>
<p>编译器分两步处理类:首先编译成员的声明，然后才轮到成员函数体（如果有的话)。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/23/linux%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/23/linux%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">linux基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-23 14:32:54" itemprop="dateCreated datePublished" datetime="2023-04-23T14:32:54+08:00">2023-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-03 16:31:18" itemprop="dateModified" datetime="2023-07-03T16:31:18+08:00">2023-07-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Linux的目录结构"><a href="#Linux的目录结构" class="headerlink" title="Linux的目录结构"></a>Linux的目录结构</h1><p>是一个树型结构<br>Windows系统可以拥有多个盘符,如C盘、D盘、E盘<br>Linux没有盘符这个概念,只有一个根目录&#x2F;，所有文件都在它下面</p>
<p>在Linux系统中，路径之间的层级关系，使用:&#x2F;来表示</p>
<p>在Windows系统中，路径之间的层级关系，使用:\来表示</p>
<p>D:\data\work\hello.txt<br>注意:<br>D:表示D盘 ,\表示层级关系</p>
<p>&#x2F;usr&#x2F;local&#x2F;hello.txt<br>注意:<br>开头的&#x2F;表示根目录,后面的&#x2F;表示层级关系</p>
<h2 id="ctrl-l清屏"><a href="#ctrl-l清屏" class="headerlink" title="ctrl+l清屏"></a>ctrl+l清屏</h2><h2 id="crtl-c中断"><a href="#crtl-c中断" class="headerlink" title="crtl+c中断"></a>crtl+c中断</h2><h2 id="crtl-d退出或登出"><a href="#crtl-d退出或登出" class="headerlink" title="crtl+d退出或登出"></a>crtl+d退出或登出</h2><ul>
<li>可以通过快捷键:ctrl + d,退出账户的登录</li>
<li>或者退出某些特定程序的专属页面，比如python</li>
</ul>
<h1 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h1><h2 id="Linux命令基础格式"><a href="#Linux命令基础格式" class="headerlink" title="Linux命令基础格式"></a>Linux命令基础格式</h2><p>无论是什么命令，用于什么用途，在Linux中，命令有其通用的格式:</p>
<p>command [-options] [parameter]</p>
<ul>
<li>command:命令本身</li>
<li>-options:[可选,非必填]命令的一些<strong>选项</strong>,可以通过选项控制命令的行为细节 </li>
<li>parameter: [可选，非必填]命令的<strong>参数</strong>，多数用于命令的指向目标等</li>
</ul>
<p>语法中的[]表示可选的意思</p>
<h3 id="ls命令的参数的作用"><a href="#ls命令的参数的作用" class="headerlink" title="ls命令的参数的作用"></a>ls命令的参数的作用</h3><ul>
<li>可以指定要查看的文件夹(目录)的内容,如果不给定参数,就查看当前工作目录的内容</li>
</ul>
<h4 id="ls命令的选项"><a href="#ls命令的选项" class="headerlink" title="ls命令的选项:"></a>ls命令的选项:</h4><ul>
<li>-a选项,可以展示出隐藏的内容</li>
<li>以.开头的文件或文件夹默认被隐藏，需要-a才能显示出来</li>
<li>-l选项,以列表的形式展示内容，并展示更多细节</li>
<li>-h选项,需要和-l选项搭配使用，以更加人性化的方式显示文件的大小单位</li>
</ul>
<h4 id="命令的选项组合使用"><a href="#命令的选项组合使用" class="headerlink" title="命令的选项组合使用"></a>命令的选项组合使用</h4><ul>
<li>命令的选项是可以组合使用的,比如: ls -lah,等同于ls -a -l -h</li>
</ul>
<h3 id="cd切换工作目录"><a href="#cd切换工作目录" class="headerlink" title="cd切换工作目录"></a>cd切换工作目录</h3><p>当Linux终端（命令行）打开的时候，会默认以用户的HOME目录作为当前的工作目录我们可以通过cd命令，更改当前所在的工作目录。<br>cd命令来自英文:Change Directory<br>语法: <code>cd [Linux路径]</code></p>
<ul>
<li>cd命令无需选项，只有参数，表示要切换到哪个目录下</li>
<li>cd命令直接执行，不写参数，表示回到用户的HOME目录</li>
</ul>
<h3 id="pwd查看当前工作目录"><a href="#pwd查看当前工作目录" class="headerlink" title="pwd查看当前工作目录"></a>pwd查看当前工作目录</h3><p>通过ls来验证当前的工作目录，其实是不恰当的。</p>
<p>我们可以通过pwd命令，来查看当前所在的工作目录。</p>
<p>pwd命令来自:Print Work Directory</p>
<p>语法:pwd</p>
<ul>
<li>pwd命令，无选项，无参数，直接输入pwd即可</li>
</ul>
<h3 id="特殊路径符"><a href="#特殊路径符" class="headerlink" title="特殊路径符:"></a>特殊路径符:</h3><ul>
<li>. 表示当前目录，比如cd .&#x2F;Desktop表示切换到当前目录下的Desktop目录内，和cd Desktop效果一致</li>
<li>.. 表示上一级目录，比如: cd .. 即可切换到上一级目录，cd ..&#x2F; ..切换到上二级的目录</li>
<li>~ 表示HOME目录，比如:cd~ 即可切换到HOME目录或cd ~&#x2F;Desktop,切换到HOME内的Desktop目录</li>
</ul>
<h3 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h3><p>通过mkdir命令可以创建新的目录（文件夹)</p>
<p>mkdir来自英文:Make Directory<br>语法:<code>mkdir [-p] Linux路径</code></p>
<ul>
<li>参数必填，表示Linux路径，即要创建的文件夹路径，相对路径或绝对路径均可</li>
<li>-p选项可选，表示自动创建不存在的父目录，适用于创建连续多层级的目录</li>
</ul>
<p>注意︰创建文件夹需要修改权限，请确保操作均在HOME目录内，不要在HOME外操作涉及到权限问题，HOME外无法成功</p>
<h3 id="touch创建文件"><a href="#touch创建文件" class="headerlink" title="touch创建文件"></a>touch创建文件</h3><p>可以通过touch命令创建文件</p>
<p>语法: <code>touch Linux路径</code></p>
<ul>
<li>touch命令无选项，参数必填，表示要创建的文件路径，相对、绝对、特殊路径符均可以使用</li>
</ul>
<h3 id="cat命令查看文件内容"><a href="#cat命令查看文件内容" class="headerlink" title="cat命令查看文件内容"></a>cat命令查看文件内容</h3><p>准备好文件内容后，可以通过cat查看内容。</p>
<p>语法:<code>cat Linux路径</code></p>
<ul>
<li><p>cat同样没有选项，只有必填参数，参数表示:被查看的文件路径，相对、绝对,</p>
<p>特殊路径符都可以使用</p>
</li>
</ul>
<h3 id="more命令查看文件内容"><a href="#more命令查看文件内容" class="headerlink" title="more命令查看文件内容"></a>more命令查看文件内容</h3><p>more命令同样可以查看文件内容，同cat不同的是:. </p>
<ul>
<li>cat是直接将内容全部显示出来</li>
<li>more支持翻页，如果文件内容过多，可以一页页的展示</li>
</ul>
<p>语法:<code>more Linux路径</code></p>
<ul>
<li>同样没有选项，只有必填参数，参数表示:被查看的文件路径，相对、绝对、特殊路径符都可以使用</li>
</ul>
<p>Linux系统内置有一个文件，路径为:&#x2F;etc&#x2F;services，可以使用more命令查看<br>more &#x2F;etc&#x2F;services</p>
<ul>
<li>在查看的过程中，通过空格翻页。</li>
<li>通过q退出查看</li>
</ul>
<h3 id="cp命令复制文件文件夹"><a href="#cp命令复制文件文件夹" class="headerlink" title="cp命令复制文件文件夹"></a>cp命令复制文件文件夹</h3><p>cp命令可以用于复制文件&#x2F;文件夹，cp命令来自英文单词: copy</p>
<p>语法: cp [-r] 参数1参数2</p>
<ul>
<li>-r选项，可选，用于复制文件夹使用，表示递归。</li>
<li>参数1,Linux路径，表示被复制的文件或文件夹。</li>
<li>参数2，Linux路径，表示要复制去的地方</li>
</ul>
<h3 id="mv移动文件或文件夹"><a href="#mv移动文件或文件夹" class="headerlink" title="mv移动文件或文件夹"></a>mv移动文件或文件夹</h3><p>mv命令可以用于移动文件\文件夹，mv命令来自英文单词:move</p>
<p>语法:<code>mv参数1参数2</code></p>
<ul>
<li>参数1,Linux路径，表示被移动的文件或文件夹</li>
<li>参数2，Linux路径，表示要移动去的地方，如果目标不存在，则进行改名，确保目标存在</li>
</ul>
<h3 id="rm删除文件、文件夹"><a href="#rm删除文件、文件夹" class="headerlink" title="rm删除文件、文件夹"></a>rm删除文件、文件夹</h3><p>rm命令可用于删除文件、文件夹</p>
<p>rm命令来自英文单词:remove</p>
<p>语法: <code>rm [-r -f] 参数1参数2 ......参数N</code></p>
<ul>
<li>同cp命令一样，-r选项用于删除文件夹</li>
<li>-f表示force，强制删除（不会弹出提示确认信息)<ul>
<li>普通用户删除内容不会弹出提示，只有root管理员用户删除内容会有提示</li>
<li>所以一般普通用户用不到-f选项</li>
</ul>
</li>
<li>参数1、参数2、…….、参数N表示要删除的文件或文件夹路径，按照空格隔开</li>
</ul>
<p>rm命令支持通配符 * ，用来做模糊匹配</p>
<ul>
<li><p>符号 * 表示通配符，即匹配任意内容（包含空)，示例:.</p>
</li>
<li><p>test*，表示匹配任何以test开头的内容</p>
</li>
<li><p>*test，表示匹配任何以test结尾的内容 </p>
</li>
<li><p>*test *，表示匹配任何包含test的内容</p>
</li>
<li><p>演示强制删除，-f选项</p>
</li>
<li><p>可以通过 su - root，并输入密码123456（和普通用户默认一样）临时切换到root用户体验</p>
</li>
<li><p>通过输入exit命令，退回普通用户,也可以回退到root用户。也可以使用ctrl+d</p>
</li>
</ul>
<h3 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h3><p>我们在前面学习的Linux命令，其实它们的本体就是一个个的二进制可执行程序。和Windows系统中的.exe文件，是一个意思。</p>
<p>我们可以通过which命令，查看所使用的一系列<strong>命令</strong>的程序文件存放在哪里</p>
<p>语法: <code>which 要查找的命令</code></p>
<h3 id="find命令–按文件名查找文件"><a href="#find命令–按文件名查找文件" class="headerlink" title="find命令–按文件名查找文件"></a>find命令–按文件名查找文件</h3><p>同样，在Linux系统中，我们可以通过find命令去搜索指定的文件。</p>
<p>语法:<code>find 起始路径 -name  &quot;被查找文件名&quot;</code></p>
<p>被查找文件名，支持使用通配符*来做模糊查询。</p>
<h3 id="find命令-按文件大小查找文件"><a href="#find命令-按文件大小查找文件" class="headerlink" title="find命令-按文件大小查找文件"></a>find命令-按文件大小查找文件</h3><p>语法: <code>find 起始路径 -size  +/-n[kMG]</code></p>
<ul>
<li>+、-表示大于和小于</li>
<li>n表示大小数字</li>
<li>kMG表示大小单位，k(小写字母)表示kb，M表示MB，G表示GB</li>
</ul>
<p>示例:</p>
<ul>
<li>查找小于10KB的文件: find  &#x2F; -size  -10k</li>
<li>查找大于100MB的文件: find &#x2F; -size +100M</li>
<li>查找大于1GB的文件: find &#x2F; -size +1G</li>
</ul>
<h3 id="grep命令-按文件大小查找文件内容"><a href="#grep命令-按文件大小查找文件内容" class="headerlink" title="grep命令-按文件大小查找文件内容"></a>grep命令-按文件大小查找文件内容</h3><p>可以通过grep命令，从文件中通过关键字过滤<strong>文件行</strong>。</p>
<p>ps aux | grep ‘cupsd’ – 检索进程结果集。 使用 grep 搜索进程，有一条结果是搜索进程本身</p>
<p><code>find … | xargs ls -l</code> 对 find 操作的结果集进行操作 </p>
<p>等价于 <code>find … -exec ls -l &#123;&#125; \；</code> 两者差别在于当结果集合很大的时候，xargs 会对结果进行分段处理，所以性能好些 </p>
<p>但 xargs 也有缺陷，xargs 默认用空格来分割结果集，当文件名有空格的时候，会因为文件名被切割 失效</p>
<p>-xargs：将 find 搜索的结果集执行某一指定命令。 当结果集数量过大时，可以分片映射。 <code>find /usr/ -name &#39;*tmp*&#39; | xargs ls -ld</code></p>
<p>解决 xargs 的缺陷，指定切分符号位 null </p>
<p>-print0： <code>find /usr/ -name &#39;*tmp*&#39; -print0 | xargs -print0 ls -l</code> 第一个 print0 指定结果集分隔为 null，第二个 print0 指定 xargs 分隔为 null</p>
<p>语法: <code>grep [-n] 关键字文件路径</code></p>
<ul>
<li>选项-n，可选，表示在结果中显示匹配的行的行号。</li>
<li>参数，关键字，必填，表示过滤的关键字，带有空格或其它特殊符号，建议使用” ”将关键字包围起来。</li>
<li>参数，文件路径，必填，表示要过滤内容的文件路径，可作为内容输入端口</li>
</ul>
<h3 id="wc命令做数量统计"><a href="#wc命令做数量统计" class="headerlink" title="wc命令做数量统计"></a>wc命令做数量统计</h3><p>可以通过wc命令统计文件的行数、单词数量等</p>
<p>语法: <code>wc [-c -m -l -w] 文件路径</code></p>
<ul>
<li>选项，-c，统计bytes数量。</li>
<li>选项，-m，统计字符数量</li>
<li>选项，-l，统计行数</li>
<li>选项，-w，统计单词数量</li>
<li>参数，文件路径，被统计的文件，可作为内容输入端口</li>
</ul>
<h3 id="管道符"><a href="#管道符" class="headerlink" title="管道符"></a>管道符</h3><p>管道符:l<br>管道符的含义是:将管道符左边命令的结果，作为右边命令的输入</p>
<ul>
<li>cat itheima.txt的输出结果（文件内容)。</li>
<li>作为右边grep命令的输入（被过滤文件)</li>
</ul>
<p><code>cat itheima.txt | grep itheima</code>还可以嵌套</p>
<h3 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h3><p>可以使用echo命令在命令行内输出指定内容</p>
<p>语法:<code>echo 输出的内容</code></p>
<ul>
<li><p>无需选项，只有一个参数，表示要输出的内容，复杂内容可以用” ”包围</p>
</li>
<li><p>带有空格或\等特殊符号，建议使用双引号包围</p>
</li>
<li><p>因为不包围的话，空格后很容易被识别为参数2，尽管echo不受影响，但是要养成习惯哦</p>
</li>
</ul>
<h3 id="反引号-96"><a href="#反引号-96" class="headerlink" title="反引号&#96;"></a>反引号&#96;</h3><p>本意是想，输出当前的工作路径，但是pwd被作为普通字符输出了。<br>我们可以通过将命令用反引号（通常也称之为飘号) &#96; 将其包围<br>被   飘号包围的内容，会被作为命令执行，而非普通字符</p>
<h3 id="重定向符"><a href="#重定向符" class="headerlink" title="重定向符"></a>重定向符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;,将左侧命令的结果，覆盖写入到符号右侧指定的文件中</span><br><span class="line">&gt;&gt;,将左侧命令的结果，追加写入到符号右侧指定的文件中</span><br></pre></td></tr></table></figure>

<h3 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h3><p>使用tail命令，可以查看文件尾部内容，跟踪文件的最新更改，</p>
<p>语法如下:<code>tail [-f -num ] Linux路径</code></p>
<ul>
<li>参数，Linux路径，表示被跟踪的文件路径。</li>
<li>选项，-f，表示持续跟踪</li>
<li>选项，-num，表示，查看尾部多少行，不填默认10行</li>
</ul>
<h3 id="vi-vim编辑器介绍"><a href="#vi-vim编辑器介绍" class="headerlink" title="vi\vim编辑器介绍"></a>vi\vim编辑器介绍</h3><p>vi\vim是visual interface的简称，是Linux中最经典的文本编辑器</p>
<p>同图形化界面中的文本编辑器一样，vi是命令行下对文本文件进行编辑的绝佳选择</p>
<p>vim是vi的加强版本，兼容vi的所有指令，不仅能编辑文本，而且还具有shell程序编辑的功能，可以不同颜色的字体来辨别语法的正确性，极大方便了程序的设计和编辑性。</p>
<h4 id="vi-vim编辑器的三种工作模式"><a href="#vi-vim编辑器的三种工作模式" class="headerlink" title="vi\vim编辑器的三种工作模式"></a>vi\vim编辑器的三种工作模式</h4><p>命令模式(Command mode)，最开始状态</p>
<ul>
<li>命令模式下，所敲的按键编辑器都理解为命令，以命令驱动执行不同的功能，此模型下，不能自由进行文本编辑。输入i o a进入输入模式，退出输入<strong>：wq</strong></li>
</ul>
<p>输入模式(lnsert mode)</p>
<ul>
<li>也就是所谓的编辑模式、插入模式。此模式下，可以对文件内容进行自由编辑。ESC键进入命令模式</li>
</ul>
<p>底线命令模式(Last line mode)</p>
<ul>
<li>以**:**开始，通常用于文件的保存、退出。命令以回车结束运行</li>
</ul>
<ol>
<li>如果文件路径表示的文件不存在，那么此命令会用于编辑新文件</li>
<li>如果文件路径表示的文件存在，那么此命令用于编辑已有文件</li>
</ol>
<table>
<thead>
<tr>
<th>模式</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>命令模式</td>
<td>i</td>
<td>在当前光标位置进入输入模式</td>
</tr>
<tr>
<td>命令模式</td>
<td>a</td>
<td>在当前光标位置之后进入输入模式</td>
</tr>
<tr>
<td>命令模式</td>
<td>I</td>
<td>在当前行的开头，进入输入模式</td>
</tr>
<tr>
<td>命令模式</td>
<td>A</td>
<td>在当前行的结尾，进入输入模式</td>
</tr>
<tr>
<td>命令模式</td>
<td>o</td>
<td>在当前光标下一行进入输入模式</td>
</tr>
<tr>
<td>命令模式</td>
<td>O</td>
<td>在当前光标上一行进入输入模式</td>
</tr>
<tr>
<td>输入模式</td>
<td>esc</td>
<td>任何情况下输入esc都能回到命令模式</td>
</tr>
<tr>
<td>命令模式</td>
<td>0</td>
<td>移动光标到当前行的开头</td>
</tr>
<tr>
<td>命令模式</td>
<td>$</td>
<td>移动光标到当前行的结尾</td>
</tr>
<tr>
<td>命令模式</td>
<td>pageup( Pgup)</td>
<td>向上翻页</td>
</tr>
<tr>
<td>命令模式</td>
<td>pangdown( PgDn)</td>
<td>向下翻页</td>
</tr>
<tr>
<td>命令模式</td>
<td>&#x2F;</td>
<td>进入搜索模式</td>
</tr>
<tr>
<td>命令模式</td>
<td>n</td>
<td>向下继续搜索</td>
</tr>
<tr>
<td>命令模式</td>
<td>N</td>
<td>向上继续搜索</td>
</tr>
<tr>
<td>命令模式</td>
<td>dd</td>
<td>删除光标所在行的内容</td>
</tr>
<tr>
<td>命令模式</td>
<td>ndd</td>
<td>n是数字，表示删除当前光标向下n行</td>
</tr>
<tr>
<td>命令模式</td>
<td>yy</td>
<td>复制当前行</td>
</tr>
<tr>
<td>命令模式</td>
<td>nyy</td>
<td>n是数字，复制当前行和下面的n行</td>
</tr>
<tr>
<td>命令模式</td>
<td>p</td>
<td>粘贴复制的内容</td>
</tr>
<tr>
<td>命令模式</td>
<td>u</td>
<td>撤销修改</td>
</tr>
<tr>
<td>命令模式</td>
<td>crtl+r</td>
<td>反向撤销修改</td>
</tr>
<tr>
<td>命令模式</td>
<td>gg</td>
<td>跳到首行</td>
</tr>
<tr>
<td>命令模式</td>
<td>G</td>
<td>跳到行尾</td>
</tr>
<tr>
<td>命令模式</td>
<td>dG</td>
<td>从当前行开始，向下全部删除</td>
</tr>
<tr>
<td>命令模式</td>
<td>dgg</td>
<td>从当前行开始，向上全部删除</td>
</tr>
<tr>
<td>命令模式</td>
<td>d$</td>
<td>从当前光标开始，删除到本行的结尾</td>
</tr>
<tr>
<td>命令模式</td>
<td>d0</td>
<td>从当前光标开始，删除到本行的开头</td>
</tr>
<tr>
<td>底线命令模式</td>
<td>:wq</td>
<td>保存并退出</td>
</tr>
<tr>
<td>底线命令模式</td>
<td>:q</td>
<td>仅退出</td>
</tr>
<tr>
<td>底线命令模式</td>
<td>:q!</td>
<td>强制退出</td>
</tr>
<tr>
<td>底线命令模式</td>
<td>:w</td>
<td>仅保存</td>
</tr>
<tr>
<td>底线命令模式</td>
<td>:set nu</td>
<td>显示行号</td>
</tr>
<tr>
<td>底线命令模式</td>
<td>:set paste</td>
<td>设置粘贴模式,主要是为了保证外部复制不会格式错乱</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>分屏，末行模式下 </p>
<ul>
<li>:sp 水平分屏</li>
<li>:vsp 竖直分屏 </li>
<li>分屏命令+filename，分屏并打开这个文件 </li>
<li>分屏后屏幕切换，Ctrl-w-w </li>
<li>使用:q 退出光标所在窗口 </li>
<li>使用:qall 退出所有窗口</li>
</ul>
<p>从 vim 中跳转 manpage，命令模式下 </p>
<p>将光标放在待查看单词上，按 K，默认看第一卷 n+K，查看第 n 卷 </p>
<p>查看宏定义：命令模式 </p>
<p>光标放在待查看词上，[+d 即可查看</p>
<p>vim 下使用 shell 命令：末行模式 :! + 命令 操作后，会切换至终端显示结果，按 Enter 后回到 vim 界面</p>
<h3 id="vim下自动排版命令"><a href="#vim下自动排版命令" class="headerlink" title="vim下自动排版命令"></a>vim下自动排版命令</h3><p>在命令行模式下：</p>
<p>1、使用“gg”将光标移动到文档开头</p>
<p>2、使用“v”切换到可视模式</p>
<p>3、再用“G”将光标移动到文档尾部（相当于全选）</p>
<p>4、最后使用“&#x3D;”，即可完成整个文档的自动排版。</p>
<h3 id="sudo命令"><a href="#sudo命令" class="headerlink" title="sudo命令"></a>sudo命令</h3><p>Su命令</p>
<ul>
<li>可以切换用户，语法:<code>su [-] [用户名]</code></li>
<li>-表示切换后加载环境变量,建议带上</li>
<li>用户可以省略,省略默认切换到root</li>
</ul>
<p>在我们得知root密码的时候，可以通过su命令切换到root得到最大权限。但是我们不建议长期使用root用户，避免带来系统损坏。</p>
<p>我们可以使用sudo命令，为普通的命令授权,临时以root身份执行。</p>
<p>语法:<code>sudo 其它命令</code></p>
<ul>
<li>在其它命令之前，带上sudo,即可为这一条命令临时赋予root授权</li>
<li>但是并不是所有的用户，都有权利使用sudo，我们需要为普通用户配置sudo认证</li>
</ul>
<h4 id="为普通用户配置sudo认证"><a href="#为普通用户配置sudo认证" class="headerlink" title="为普通用户配置sudo认证"></a>为普通用户配置sudo认证</h4><ul>
<li>切换到root用户,执行visudo命令，会自动通过vi编辑器打开:&#x2F;etc&#x2F;sudoers。</li>
<li>在文件的最后添加:<br><code>itheima ALL=(ALL)		NOPASSWD: ALL</code><br>其中最后的NOPASSWD:ALL表示使用sudo命令，无需输入密码，itheima是用户名</li>
<li>最后通过wq保存</li>
<li>切换回普通用户<br><code>[itheima@localhost ~]$ sudo ls /root</code></li>
<li><code>anaconda-ks.cfg	original-ks.cfg</code></li>
<li><code>[itheima@localhost ~]$ sudo mkdir /test</code></li>
<li><code>[itheima@localhost ~]$</code></li>
<li>执行的命令，均以root运行</li>
</ul>
<h2 id="用户、用户组"><a href="#用户、用户组" class="headerlink" title="用户、用户组"></a>用户、用户组</h2><p>Linux系统中可以:</p>
<ul>
<li>配置多个用户</li>
<li>配置多个用户组</li>
<li>用户可以加入多个用户组中</li>
</ul>
<h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>以下命令需root用户执行。</p>
<ul>
<li><p>创建用户</p>
<p>​	useradd [-g -d]用户名<br>​		选项: -g指定用户的组，不指定-g，会创建同名组并自动加入，指定-g需要组已经存在，如已存在同名组，必须使用-g</p>
<p>​		选项:-d指定用户HOME路径，不指定，HOME目录默认在:&#x2F;home&#x2F;用户名</p>
</li>
<li><p>删除用户</p>
<ul>
<li>​	userdel [-r]用户名<br>​		选项:-r，删除用户的HOME目录，不使用-r，删除用户时，HOME目录保留</li>
</ul>
</li>
<li><p>查看用户所属组</p>
<ul>
<li><p>id[用户名]</p>
<p>​	参数:用户名，被查看的用户，如果不提供则查看自身。</p>
</li>
</ul>
</li>
<li><p>修改用户所属组</p>
<ul>
<li>usermod -aG 用户组 用户名，将指定用户加入指定用户组，一个用户可以在多个用户组。</li>
</ul>
</li>
</ul>
<h3 id="getent"><a href="#getent" class="headerlink" title="getent"></a>getent</h3><p>使用getent命令，可以查看当前系统中有哪些用户</p>
<p>语法: getent passwd</p>
<p>共有7份信息，分别是:<br>用户名:密码(x):用户ID:组ID:描述信息(无用):HOME目录:执行终端(默认bash)</p>
<p>使用getent命令,同样可以查看当前系统中有哪些用户组</p>
<p>语法:getent group</p>
<p>包含3份信息,组名称:组认证(显示为x):组ID</p>
<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>ls -l后</p>
<p>drwxr-xr-x 2 xiaohuilin xiaohuilin 4096 9月  12  2021 公共的</p>
<p>举例: d rwx r-x r-x，表示:</p>
<ul>
<li>这是一个文件夹，首字母d表示( -表示文件 d表示文件夹 I表示软链接)</li>
<li>所属用户（第一个xiaohuilin）对d的权限是:有r有w有x, rwx</li>
<li>所属用户组（第二个xiaohuilin）的权限是:有r无w有x, r-x( -表示无此权限)</li>
<li>其它用户的权限是：有r无w有x,r-x</li>
</ul>
<p>rwx代表什么</p>
<p>r表示读权限</p>
<p>w表示写权限</p>
<p>x表示执行权限</p>
<p>针对文件、文件夹的不同，rwx的含义有细微差别</p>
<ul>
<li>r ,针对文件可以查看文件内容<ul>
<li>针对文件夹，可以查看文件夹内容，如ls命令</li>
</ul>
</li>
<li>w，针对文件表示可以修改此文件<ul>
<li>针对文件夹，可以在文件夹内:创建、删除、改名等操作</li>
</ul>
</li>
<li>x,针对文件表示可以将文件作为程序执行<ul>
<li>针对文件夹，表示可以更改工作目录到此文件夹，即cd进入</li>
</ul>
</li>
</ul>
<h2 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h2><p>我们可以使用chmod命令，修改文件、文件夹的权限信息。</p>
<p>注意，只有文件、文件夹的所属用户或root用户可以修改。</p>
<p>语法: <code>chmod [-R] 权限 文件或文件夹</code></p>
<ul>
<li>选项:-R，对文件夹内的全部内容应用同样的操作</li>
</ul>
<p>示例:</p>
<ul>
<li>chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;x hello.txt，将文件权限修改为:rwxr-x–x<ul>
<li>其中:u表示user所属用户权限, g表示group组权限,o表示other其它用户权限</li>
</ul>
</li>
<li>chmod -R u&#x3D;rwx,g&#x3D;rx,0&#x3D;x test,将文件夹test以及文件夹内全部内容权限设置为:rwxr-x–x</li>
</ul>
<p>除此之外，还有快捷写法: chmod 751 hello.txt<br>将hello.txt的权限修改为751,r记为4, w记为2,x记为1</p>
<h2 id="chown命令"><a href="#chown命令" class="headerlink" title="chown命令"></a>chown命令</h2><p>使用chown命令，可以修改文件、文件夹的所属用户和用户组<br>普通用户无法修改所属为其它用户或组，所以此命令只适用于root用户执行</p>
<p>语法: <code>chown[-R] [用户][:][用户组] 文件或文件夹</code></p>
<ul>
<li>选项，-R，同chmod,对文件夹内全部内容应用相同规则</li>
<li>选项，用户，修改所属用户</li>
<li>选项，用户组,修改所属用户组</li>
<li>:用于分隔用户和用户组</li>
</ul>
<p>示例:</p>
<ul>
<li>chown root hello.txt,将hello.txt所属用户修改为root</li>
<li>chown :root hello.txt,将hello.txt所属用户组修改为root</li>
<li>chown root:itheima hello.txt,将hello.txt所属用户修改为root,用户组修改为itheima</li>
<li>chown -R root test,将文件夹test的所属用户修改为root并对文件夹内全部内容应用同样规则</li>
</ul>
<h2 id="历史命令搜索"><a href="#历史命令搜索" class="headerlink" title="历史命令搜索"></a>历史命令搜索</h2><p><code>history</code></p>
<ul>
<li>可以通过:!命令前缀，自动执行上次匹配前缀的命令</li>
<li>可以通过快捷键:ctrl + r,输入内容去匹配历史命令</li>
</ul>
<p>如果搜索到的内容是你需要的，那么∶</p>
<ul>
<li>回车键可以直接执行</li>
<li>键盘左右键，可以得到此命令（不执行)</li>
</ul>
<h2 id="光标移动快捷键"><a href="#光标移动快捷键" class="headerlink" title="光标移动快捷键"></a>光标移动快捷键</h2><ul>
<li>ctrl+ a,跳到命令开头</li>
<li>ctrl+e,跳到命令结尾</li>
<li>ctrl＋键盘左键,向左跳一个单词</li>
<li>ctrl＋键盘右键,向右跳一个单词</li>
</ul>
<h2 id="清屏"><a href="#清屏" class="headerlink" title="清屏"></a>清屏</h2><ul>
<li><p>通过快捷键ctrl+l，可以清空终端内容</p>
</li>
<li><p>或通过命令clear得到同样效果</p>
</li>
</ul>
<h2 id="systemctl命令"><a href="#systemctl命令" class="headerlink" title="systemctl命令"></a>systemctl命令</h2><p>Linux系统很多软件(内置或第三方)均支持使用systemctl命令控制:启动、停止、开机自启</p>
<p>能够被systemctl管理的软件，一般也称之为:服务</p>
<p>语法: <code>systemctl start | stop | status | enable | disable 服务名</code></p>
<ul>
<li><p>start启动</p>
</li>
<li><p>stop关闭</p>
</li>
<li><p>status查看状态</p>
</li>
<li><p>enable开启开机自启</p>
</li>
<li><p>disable关闭开机自启</p>
</li>
</ul>
<p>系统内置的服务比较多，比如:</p>
<ul>
<li><p>NetworkManager,主网络服务</p>
</li>
<li><p>network,副网络服务</p>
</li>
<li><p>firewalld，防火墙服务</p>
</li>
<li><p>sshd, ssh服务(FinalShell远程登录Linux使用的就是这个服务)</p>
</li>
</ul>
<h2 id="ln命令创建软连接"><a href="#ln命令创建软连接" class="headerlink" title="ln命令创建软连接"></a>ln命令创建软连接</h2><p>在系统中创建软链接,可以将文件、文件夹链接到其它位置。</p>
<p>类似windows系统中的《快捷方式》</p>
<p>语法: <code>ln -s 参数1参数2</code></p>
<ul>
<li>-s选项,创建软连接</li>
<li>参数1:被链接的文件或文件夹</li>
<li>参数2:要链接去的目的地</li>
</ul>
<p>实例:</p>
<ul>
<li>ln -s &#x2F;etc&#x2F;yum.conf ~&#x2F;yum.conf</li>
<li>ln -s &#x2F;etc&#x2F;yum ~&#x2F;yum</li>
</ul>
<h2 id="date命令"><a href="#date命令" class="headerlink" title="date命令"></a>date命令</h2><p>通过date命令可以在命令行中查看系统的时间</p>
<p>语法: <code>date [-d][+格式化字符串]</code></p>
<ul>
<li><p>-d按照给定的字符串显示日期，一般用于日期计算</p>
</li>
<li><p>格式化字符串:通过特定的字符串标记,来控制显示的日期格式</p>
<ul>
<li><p>%Y	年</p>
</li>
<li><p>%y	年份后两位数字(00..99)</p>
</li>
<li><p>%m	月份(01..12)</p>
</li>
<li><p>%d	日(01..31)</p>
</li>
<li><p>%H	小时(00..23)</p>
</li>
<li><p>%M	分钟(00..59)</p>
</li>
<li><p>%S	秒(00..60)</p>
</li>
<li><p>%s	自1970-01-01	00::00::00 UTC到现在的秒数</p>
</li>
</ul>
</li>
</ul>
<h2 id="特殊IP地址"><a href="#特殊IP地址" class="headerlink" title="特殊IP地址"></a>特殊IP地址</h2><ul>
<li>127.0.0.1，这个IP地址用于指代本机</li>
<li>0.0.0.0,特殊lP地址<ul>
<li>可以用于指代本机</li>
<li>可以在端口绑定中用来确定绑定关系（后续讲解)</li>
<li>在一些IP地址限制中，表示所有IP的意思,如放行规则设置为0.0.0.0,表示允许任意IP访问</li>
</ul>
</li>
</ul>
<h2 id="在Linux中修改主机名"><a href="#在Linux中修改主机名" class="headerlink" title="在Linux中修改主机名"></a>在Linux中修改主机名</h2><ul>
<li>可以使用命令:hostname查看主机名</li>
<li>可以使用命令: hostnamectl set-hostname主机名,修改主机名（需root)</li>
</ul>
<p>什么是域名解析（主机名映射)</p>
<ul>
<li>可以通过主机名找到对应计算机的IP地址,这就是主机名映射（域名解析)</li>
<li>先通过系统本地的记录去查找，如果找不到就联网去公开DNS服务器去查找</li>
</ul>
<h2 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h2><p>可以通过ping命令,检查指定的网络服务器是否是可联通状态</p>
<p>语法: <code>ping [-c num] ip或主机名</code></p>
<ul>
<li>选项:-c，检查的次数，不使用-c选项,将无限次数持续检查</li>
<li>参数: ip或主机名，被检查的服务器的ip地址或主机名地址</li>
</ul>
<h2 id="wget命令"><a href="#wget命令" class="headerlink" title="wget命令"></a>wget命令</h2><p>wget是非交互式的文件下载器,可以在命令行内下载网络文件</p>
<p>语法: <code>wget [-b] url</code></p>
<ul>
<li>选项: -b，可选，后台下载,会将日志写入到当前工作目录的wget-log文件</li>
<li>参数: url，下载链接</li>
</ul>
<h2 id="curl命令"><a href="#curl命令" class="headerlink" title="curl命令"></a>curl命令</h2><p>curl可以发送http网络请求,可用于:下载文件、获取信息等</p>
<p>语法: <code>curl [-O] url</code></p>
<ul>
<li>选项:-O，用于下载文件，当url是下载链接时,可以使用此选项保存文件</li>
<li>参数: url，要发起请求的网络地址</li>
</ul>
<h2 id="使用top命令可以"><a href="#使用top命令可以" class="headerlink" title="使用top命令可以:"></a>使用top命令可以:</h2><p>类似Windows任务售理器·查看CPU、内存、进程的信息</p>
<h2 id="使用df命令可以"><a href="#使用df命令可以" class="headerlink" title="使用df命令可以:"></a>使用df命令可以:</h2><p>查看磁盘使用率</p>
<h2 id="使用iostat可以"><a href="#使用iostat可以" class="headerlink" title="使用iostat可以:"></a>使用iostat可以:</h2><p>查看磁盘速率等信息</p>
<h2 id="使用sar-n-DEV命令可以"><a href="#使用sar-n-DEV命令可以" class="headerlink" title="使用sar -n DEV命令可以:"></a>使用sar -n DEV命令可以:</h2><p>查看网络情况</p>
<h2 id="什么是环境变量"><a href="#什么是环境变量" class="headerlink" title="什么是环境变量"></a>什么是环境变量</h2><p>环境变量是一组信息记录,类型是KeyValue型(名称&#x3D;值)，用于操作系统运行的时候记录关键信息</p>
<h2 id="通过env命令可以查看当前系统配置的环境变量信息"><a href="#通过env命令可以查看当前系统配置的环境变量信息" class="headerlink" title="通过env命令可以查看当前系统配置的环境变量信息"></a>通过env命令可以查看当前系统配置的环境变量信息</h2><h2 id="通过-符号，可以取出环境变量的值"><a href="#通过-符号，可以取出环境变量的值" class="headerlink" title="通过$符号，可以取出环境变量的值"></a>通过$符号，可以取出环境变量的值</h2><h2 id="什么是PATH，作用是"><a href="#什么是PATH，作用是" class="headerlink" title="什么是PATH，作用是"></a>什么是PATH，作用是</h2><p>环境变量PATH会记录一组目录，目录之间用**:**隔开。这里记录的是命令的搜索路径，当执行命令会从记录中记录的目录中挨个搜索要执行的命令并执行。<br>可以通过修改这个项目的值,加入自定义的命令搜索路径<br>如<code>export PATH=$PATH:自定义路径</code></p>
<h2 id="如何修改环境变量"><a href="#如何修改环境变量" class="headerlink" title="如何修改环境变量"></a>如何修改环境变量</h2><ul>
<li>临时生效: export名称&#x3D;值</li>
<li>永久生效:<ul>
<li>针对用户:~&#x2F;bashrc文件中配置</li>
<li>针对全部用户:&#x2F;etc&#x2F;profile文件中配置。</li>
<li>配置完成，可以通过source命令立刻生效</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/16/c%E5%92%8Cc++/%E5%85%B3%E4%BA%8Evscode%E5%A6%82%E4%BD%95%E5%AF%B9%E5%A4%9A%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/16/c%E5%92%8Cc++/%E5%85%B3%E4%BA%8Evscode%E5%A6%82%E4%BD%95%E5%AF%B9%E5%A4%9A%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/" class="post-title-link" itemprop="url">关于vscode如何对多文件进行调试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-16 16:48:07" itemprop="dateCreated datePublished" datetime="2023-04-16T16:48:07+08:00">2023-04-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-08 15:24:15" itemprop="dateModified" datetime="2023-07-08T15:24:15+08:00">2023-07-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Vscode默认配置文件只能编译单cpp文件。若是需要多文件编译或者需要分别设置Include头文件夹、Source资源文件夹，则需要修改配置三个.json文件(tasks.json、launch.json、c_cpp_properties.json )</p>
<p>注：个人习惯将.h头文件放到Include目录、.c.cpp源文件放到Source文件夹下面，输出文件.exe文件放到out文件夹下面</p>
<ul>
<li>.vscode文件夹存放.json文件夹，实际使用中可以直接拷贝过来使用，而没必要每次都新建修改一遍</li>
<li>c_cpp_properties.json配置文件默认是不会产生的，快捷键ctrl+shift+p 再输入configuration便会出现</li>
<li>默认工作空间只有.vscode文件夹，.cpp文件直接放在工作空间根目录的。示例中include、source以及out文件夹可以利用Create C++ project创建工程模板才能在.json中修改配置</li>
</ul>
<h2 id="tasks-json文件"><a href="#tasks-json文件" class="headerlink" title="tasks.json文件"></a>tasks.json文件</h2><p>需要修改的地方主要有三处，可直接复制使用</p>
<ul>
<li>修改 -g后面的目录</li>
<li>修改-o后面的目录</li>
<li>添加 -I 及后面的目录</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;tasks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;,        //任务执行的是shell命令</span><br><span class="line">            &quot;label&quot;: &quot;C/C++: g++.exe build active file&quot;,   	//和launch.josn 中的 preLaunchTask 必须一样</span><br><span class="line">            &quot;command&quot;: &quot;C:\\c\\software\\mingw64\\bin\\g++.exe&quot;,  //命令是g++，也可以直接写g++</span><br><span class="line">            &quot;args&quot;: [  </span><br><span class="line">                &quot;-g&quot;,    //生成和调试有关的信息</span><br><span class="line">                &quot;-Wall&quot;, // 开启额外警告 </span><br><span class="line">				&quot;$&#123;workspaceFolder&#125;\\src\\*.cpp&quot;,  //当前工作空间下文件夹source目录名下的所有cpp文件。 source对应工程目录下的source文件夹名字，可自行修改   </span><br><span class="line">                &quot;-I&quot;,&quot;$&#123;workspaceFolder&#125;\\include&quot;,      // 参数-I 和工程路径 指明了项目中要引用的非标准头文件的位置。 include对应工程目录下的include文件夹名字，可自行修改                   </span><br><span class="line">                &quot;-o&quot;,                      </span><br><span class="line">                &quot;$&#123;workspaceFolder&#125;\\bulid\\$&#123;fileBasenameNoExtension&#125;.exe&quot;, //指定输出的文件名为out，默认a.exe。out对应工程目录下的out文件夹名字，可自行修改 </span><br><span class="line">                &quot;-std=c++17&quot;,                                      //使用c++17标准编译</span><br><span class="line">                &quot;-finput-charset=UTF-8&quot;,                           //输入编译器默认文本编码 默认为utf-8</span><br><span class="line">                &quot;-fexec-charset=GB18030&quot;,                          //输出exe文件编码 </span><br><span class="line">            ],</span><br><span class="line">            &quot;options&quot;: &#123;</span><br><span class="line">                &quot;cwd&quot;: &quot;C:\\c\\software\\mingw64\\bin&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;problemMatcher&quot;: [</span><br><span class="line">                &quot;$gcc&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;group&quot;: &#123;</span><br><span class="line">                &quot;kind&quot;: &quot;build&quot;,</span><br><span class="line">                &quot;isDefault&quot;: true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;version&quot;: &quot;2.0.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="launch-json文件"><a href="#launch-json文件" class="headerlink" title="launch.json文件"></a>launch.json文件</h2><p>需要修改的地方有以下：</p>
<ol>
<li>“program”目录</li>
<li>“cwd”</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;g++.exe &quot;,  // 该调试任务的名字，启动调试时会在待选列表中显示</span><br><span class="line">            &quot;type&quot;: &quot;cppdbg&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;\\build\\$&#123;fileBasenameNoExtension&#125;.exe&quot;,  //需要运行/调试的是当前打开文件的目录中，名字和当前文件相同，但扩展名为exe的程序。和tasks.json中-o后面的目录一样的</span><br><span class="line">            &quot;args&quot;: [],</span><br><span class="line">            &quot;stopAtEntry&quot;: false,  // 这一项控制是否在入口处暂停，默认false不暂停，改为true暂停</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;\\build&quot;, //调试程序时的工作目录 。out对应工程目录下的out文件夹</span><br><span class="line">            &quot;environment&quot;: [],</span><br><span class="line">            &quot;externalConsole&quot;: false,  // 这一项控制是否启动外部控制台（独立的黑框）运行程序，默认false表示在集成终端中运行</span><br><span class="line">            &quot;MIMode&quot;: &quot;gdb&quot;,</span><br><span class="line">            &quot;miDebuggerPath&quot;: &quot;C:\\c\\software\\mingw64\\bin\\gdb.exe&quot;,  // 调试器路径，必须与你自己的电脑相符</span><br><span class="line">            &quot;setupCommands&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;,</span><br><span class="line">                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,</span><br><span class="line">                    &quot;ignoreFailures&quot;: true</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;preLaunchTask&quot;: &quot;g++.exe build active file&quot;  // 调试会话开始前执行的任务，一般为编译程序，c++为g++, c为gcc 这个名字一定要跟tasks.json中的任务名字大小写一致</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="c-cpp-properties-json"><a href="#c-cpp-properties-json" class="headerlink" title="c_cpp_properties.json"></a>c_cpp_properties.json</h2><p>默认不会产生。快捷键ctrl+shift+p 再输入configuration便会出现。<br>修改的地方只有一处：</p>
<p>“includePath” 将include文件夹添加进去即可，注意格式！！<br>注：“compilerPath” 同launch.json。为编译器文件目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Win32&quot;,</span><br><span class="line">            &quot;includePath&quot;: [</span><br><span class="line">                &quot;$&#123;workspaceFolder&#125;/**&quot;,</span><br><span class="line">                &quot;$&#123;workspaceFolder&#125;\\include\\**&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;defines&quot;: [</span><br><span class="line">                &quot;_DEBUG&quot;,</span><br><span class="line">                &quot;UNICODE&quot;,</span><br><span class="line">                &quot;_UNICODE&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;cStandard&quot;: &quot;c17&quot;,</span><br><span class="line">            &quot;cppStandard&quot;: &quot;c++17&quot;,</span><br><span class="line">            &quot;compilerPath&quot;: &quot;C:\\c\\software\\mingw64\\bin\\gdb.exe&quot;,</span><br><span class="line">            &quot;intelliSenseMode&quot;: &quot;windows-gcc-x64&quot;,</span><br><span class="line">            &quot;configurationProvider&quot;: &quot;ms-vscode.makefile-tools&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;version&quot;: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结</p>
<ul>
<li>这三个配置文件可以各拷贝一份，新建工程时，直接放.vscode下面。软件在打开时会直接读取.json文件。</li>
<li>.vscode通常就是放配置文件的，除这三个常用的之外还有settings.json，用来配置编辑器等外观性质的东西。</li>
<li>VSCode下c++多文件夹项目编译调试还可以用makefile、cmake等工具实现，适用于大型项目文件时使用</li>
</ul>
<p><img src="/2023/04/16/c%E5%92%8Cc++/%E5%85%B3%E4%BA%8Evscode%E5%A6%82%E4%BD%95%E5%AF%B9%E5%A4%9A%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/Users\86191\OneDrive\图片\屏幕快照\2023-04-16.png" alt="2023-04-16"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">肖汇林</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">肖汇林</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
