<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="选择有时候比努力更重要">
<meta property="og:type" content="website">
<meta property="og:title" content="肖汇林的博客">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="肖汇林的博客">
<meta property="og:description" content="选择有时候比努力更重要">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="肖汇林">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>肖汇林的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖汇林的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/04/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%884%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/04/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%884%EF%BC%89/" class="post-title-link" itemprop="url">muduo-基础库（4）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-04 15:25:09" itemprop="dateCreated datePublished" datetime="2023-08-04T15:25:09+08:00">2023-08-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-07 16:37:16" itemprop="dateModified" datetime="2023-08-07T16:37:16+08:00">2023-08-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="日志类封装"><a href="#日志类封装" class="headerlink" title="日志类封装"></a>日志类封装</h1><h2 id="日志作用"><a href="#日志作用" class="headerlink" title="日志作用"></a>日志作用</h2><p>开发过程中:</p>
<ul>
<li>调试错误</li>
<li>更好的理解程序</li>
</ul>
<p>运行过程中:</p>
<ul>
<li><p>诊断系统故障并处理</p>
</li>
<li><p>记录系统运行状态</p>
</li>
</ul>
<h2 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h2><p>TRACE</p>
<ul>
<li>指出比DEBUG粒度更细的一些信息事件（开发过程中使用)</li>
</ul>
<p>DEBUG</p>
<ul>
<li>指出细粒度信息事件对调试应用程序是非常有帮助的。(开发过程中使用)</li>
</ul>
<p>INFO</p>
<ul>
<li>表明消息在粗粒度级别上突出强调应用程序的运行过程。</li>
</ul>
<p>WARN</p>
<ul>
<li>系统能正常运行，但可能会出现潜在错误的情形。</li>
</ul>
<p>ERROR</p>
<ul>
<li>指出虽然发生错误事件，但仍然不影响系统的继续运行。</li>
</ul>
<p>FATAL</p>
<ul>
<li>指出每个严重的错误事件将会导致应用程序的退出。</li>
</ul>
<h2 id="Logger使用时序图"><a href="#Logger使用时序图" class="headerlink" title="Logger使用时序图"></a>Logger使用时序图</h2><p>Logger &#x3D;&gt; lmpl &#x3D;&gt; LogStream &#x3D;&gt; operator&lt;&lt;FixedBuffer &#x3D;&gt; g_output &#x3D;&gt; g_flush</p>
<p>Logger：最外层的日志类</p>
<p>Impl:内部实际的实现，比如如何格式化日志</p>
<p> LogStream ：Impl类借助于它来输出日志，输出到FixedBuffer 缓冲区</p>
<p>g_output：标准输出或文件</p>
<p>g_flush：清空，写到文件里面,是将输出缓冲区中的数据立即刷新（写入）到相应的输出流（此处是标准输出流 <code>stdout</code>）</p>
<p><img src="/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%884%EF%BC%89/image-20230804163115384.png" alt="image-20230804163115384"></p>
<img src="/2023/08/04/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%884%EF%BC%89/image-20230804163115384.png" class title="This is an test image">

<p>使用的时候：比如<code>LOG_TRACE &lt;&lt; &quot;trace CST&quot;</code>;首先调用匿名对象构造，调用stream(),实际上是调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LogStream&amp; stream() &#123; return impl_.stream_; &#125;</span><br></pre></td></tr></table></figure>

<p>也就格式化了一些数据到缓冲区了，比如时间，<code>LOG_TRACE &lt;&lt; &quot;trace CST&quot;</code>;这句话执行完毕，无名对象就要被销毁，调用析构函数。</p>
<p>相关函数</p>
<h3 id="Logging-h"><a href="#Logging-h" class="headerlink" title="Logging.h"></a>Logging.h</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">class TimeZone;</span><br><span class="line"></span><br><span class="line">class Logger</span><br><span class="line">&#123;</span><br><span class="line">public</span><br><span class="line">	enum LogLevel//从上往下0开始，一共有NUM_LOG_LEVELS=6个级别</span><br><span class="line">	  &#123;</span><br><span class="line">	    TRACE,</span><br><span class="line">	    DEBUG,</span><br><span class="line">	    INFO,</span><br><span class="line">	    WARN,</span><br><span class="line">	    ERROR,</span><br><span class="line">	    FATAL,</span><br><span class="line">	    NUM_LOG_LEVELS,</span><br><span class="line">	  &#125;;</span><br><span class="line">	  </span><br><span class="line">	  </span><br><span class="line">	LogStream&amp; stream() &#123; return impl_.stream_; &#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	typedef void (*OutputFunc)(const char* msg, int len);</span><br><span class="line">	  typedef void (*FlushFunc)();</span><br><span class="line">	  static void setOutput(OutputFunc);</span><br><span class="line">	  static void setFlush(FlushFunc);</span><br><span class="line">	  static void setTimeZone(const TimeZone&amp; tz);</span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">	class Impl//实际是Logger类内部的嵌套类，还负责日志的格式化</span><br><span class="line">	&#123;</span><br><span class="line">	 public:</span><br><span class="line">	  typedef Logger::LogLevel LogLevel;</span><br><span class="line">	  Impl(LogLevel level, int old_errno, const SourceFile&amp; file, int line);</span><br><span class="line">	  void formatTime();</span><br><span class="line">	  void finish();</span><br><span class="line">	</span><br><span class="line">	  Timestamp time_;</span><br><span class="line">	  LogStream stream_;</span><br><span class="line">	  LogLevel level_;</span><br><span class="line">	  int line_;</span><br><span class="line">	  SourceFile basename_;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	  Impl impl_;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line">extern Logger::LogLevel g_logLevel;//设置级别</span><br><span class="line"></span><br><span class="line">inline Logger::LogLevel Logger::logLevel()//static inline muduo::Logger::LogLevel muduo::Logger::logLevel()</span><br><span class="line">&#123;</span><br><span class="line">  return g_logLevel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//因为logLevel()大于后面的，所以最高级别只输出INFO</span><br><span class="line">#define LOG_TRACE if (muduo::Logger::logLevel() &lt;= muduo::Logger::TRACE) \</span><br><span class="line">  muduo::Logger(__FILE__, __LINE__, muduo::Logger::TRACE, __func__).stream()//调用的是匿名对象，会调用析构</span><br><span class="line">#define LOG_DEBUG if (muduo::Logger::logLevel() &lt;= muduo::Logger::DEBUG) \</span><br><span class="line">  muduo::Logger(__FILE__, __LINE__, muduo::Logger::DEBUG, __func__).stream()</span><br><span class="line">#define LOG_INFO if (muduo::Logger::logLevel() &lt;= muduo::Logger::INFO) \</span><br><span class="line">  muduo::Logger(__FILE__, __LINE__).stream()</span><br><span class="line">#define LOG_WARN muduo::Logger(__FILE__, __LINE__, muduo::Logger::WARN).stream()</span><br><span class="line">#define LOG_ERROR muduo::Logger(__FILE__, __LINE__, muduo::Logger::ERROR).stream()</span><br><span class="line">#define LOG_FATAL muduo::Logger(__FILE__, __LINE__, muduo::Logger::FATAL).stream()</span><br><span class="line">#define LOG_SYSERR muduo::Logger(__FILE__, __LINE__, false).stream()//false表示不会退出程序</span><br><span class="line">#define LOG_SYSFATAL muduo::Logger(__FILE__, __LINE__, true).stream()//true表示FATAL级别会退出程序</span><br></pre></td></tr></table></figure>

<h3 id="Logging-cc"><a href="#Logging-cc" class="headerlink" title="Logging.cc"></a>Logging.cc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">Logger::LogLevel initLogLevel()//这里可以更改级别，比如直接return Logger::TRACE;</span><br><span class="line">&#123;</span><br><span class="line">  if (::getenv(&quot;MUDUO_LOG_TRACE&quot;))</span><br><span class="line">    return Logger::TRACE;</span><br><span class="line">  else if (::getenv(&quot;MUDUO_LOG_DEBUG&quot;))</span><br><span class="line">    return Logger::DEBUG;</span><br><span class="line">  else</span><br><span class="line">    return Logger::INFO;</span><br><span class="line">&#125;</span><br><span class="line">Logger::LogLevel g_logLevel = initLogLevel();//设置级别</span><br><span class="line">const char* LogLevelName[Logger::NUM_LOG_LEVELS] =</span><br><span class="line">&#123;</span><br><span class="line">  &quot;TRACE &quot;,</span><br><span class="line">  &quot;DEBUG &quot;,</span><br><span class="line">  &quot;INFO  &quot;,</span><br><span class="line">  &quot;WARN  &quot;,</span><br><span class="line">  &quot;ERROR &quot;,</span><br><span class="line">  &quot;FATAL &quot;,</span><br><span class="line">&#125;;</span><br><span class="line">// helper class for known string length at compile time</span><br><span class="line">class T</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  T(const char* str, unsigned len)</span><br><span class="line">    :str_(str),</span><br><span class="line">     len_(len)</span><br><span class="line">  &#123;</span><br><span class="line">    assert(strlen(str) == len_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const char* str_;</span><br><span class="line">  const unsigned len_;</span><br><span class="line">&#125;;</span><br><span class="line">void defaultOutput(const char* msg, int len)</span><br><span class="line">&#123;</span><br><span class="line">  size_t n = fwrite(msg, 1, len, stdout);</span><br><span class="line">  //FIXME check n</span><br><span class="line">  (void)n;</span><br><span class="line">  //在这段代码中，fwrite 函数用于将数据写入到标准输出流 stdout 中。fwrite 的返回值是写入成功的数据项个数，通常用 size_t 类型表示。在实际应用中，为了避免编译器的未使用变量警告，常常使用 (void)n; 这样的语句来“使用”变量 n，以便在代码中明确表达它是有意的、预期的未使用状态。</span><br><span class="line"></span><br><span class="line">  //在一些编译器中，未使用变量可能会导致警告，因为它可能表明代码逻辑有问题。通过使用 (void)n; 这样的语句，开发者可以明确表示这个变量是有意的未使用状态，从而避免编译器警告，同时保持代码的清晰和易读.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void defaultFlush()</span><br><span class="line">&#123;</span><br><span class="line">  fflush(stdout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Logger::OutputFunc g_output = defaultOutput;</span><br><span class="line">//typedef void (*OutputFunc)(const char* msg, int len);--&gt;&gt;void g_output(const char* msg, int len)</span><br><span class="line">Logger::FlushFunc g_flush = defaultFlush;</span><br><span class="line">TimeZone g_logTimeZone;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo这是一个 C++ 中的命名空间（namespace）定义示例，名为 muduo，可以通过 muduo:: 前缀来访问命名空间内的成员</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line"></span><br><span class="line">Logger::Impl::Impl(LogLevel level, int savedErrno, const SourceFile&amp; file, int line)</span><br><span class="line">  : time_(Timestamp::now()),</span><br><span class="line">    stream_(),</span><br><span class="line">    level_(level),</span><br><span class="line">    line_(line),</span><br><span class="line">    basename_(file)</span><br><span class="line">&#123;</span><br><span class="line">  formatTime();</span><br><span class="line">  CurrentThread::tid();//缓存一下当前线程的id</span><br><span class="line">  stream_ &lt;&lt; T(CurrentThread::tidString(), CurrentThread::tidStringLength());</span><br><span class="line">  stream_ &lt;&lt; T(LogLevelName[level], 6);</span><br><span class="line">  if (savedErrno != 0)</span><br><span class="line">  &#123;</span><br><span class="line">    stream_ &lt;&lt; strerror_tl(savedErrno) &lt;&lt; &quot; (errno=&quot; &lt;&lt; savedErrno &lt;&lt; &quot;) &quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Logger::Impl::formatTime()</span><br><span class="line">&#123;</span><br><span class="line">  int64_t microSecondsSinceEpoch = time_.microSecondsSinceEpoch();</span><br><span class="line">  time_t seconds = static_cast&lt;time_t&gt;(microSecondsSinceEpoch / Timestamp::kMicroSecondsPerSecond);</span><br><span class="line">  int microseconds = static_cast&lt;int&gt;(microSecondsSinceEpoch % Timestamp::kMicroSecondsPerSecond);</span><br><span class="line">  if (seconds != t_lastSecond)</span><br><span class="line">  &#123;</span><br><span class="line">    t_lastSecond = seconds;</span><br><span class="line">    struct DateTime dt;</span><br><span class="line">    if (g_logTimeZone.valid())</span><br><span class="line">    &#123;</span><br><span class="line">      dt = g_logTimeZone.toLocalTime(seconds);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      dt = TimeZone::toUtcTime(seconds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int len = snprintf(t_time, sizeof(t_time), &quot;%4d%02d%02d %02d:%02d:%02d&quot;,</span><br><span class="line">        dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second);</span><br><span class="line">    assert(len == 17); (void)len;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (g_logTimeZone.valid())</span><br><span class="line">  &#123;</span><br><span class="line">    Fmt us(&quot;.%06d &quot;, microseconds);</span><br><span class="line">    assert(us.length() == 8);</span><br><span class="line">    stream_ &lt;&lt; T(t_time, 17) &lt;&lt; T(us.data(), 8);//将时间和格式化的微秒输出到缓冲区</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    Fmt us(&quot;.%06dZ &quot;, microseconds);</span><br><span class="line">    assert(us.length() == 9);</span><br><span class="line">    stream_ &lt;&lt; T(t_time, 17) &lt;&lt; T(us.data(), 9);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Logger::Logger(SourceFile file, int line, LogLevel level)</span><br><span class="line">  : impl_(level, 0, file, line)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Logger::Logger(SourceFile file, int line, bool toAbort)</span><br><span class="line">  : impl_(toAbort?FATAL:ERROR, errno, file, line)//根据muduo::Logger(__FILE__, __LINE__, true)来判断级别是FATAL还是ERROR</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Logger::~Logger()</span><br><span class="line">&#123;</span><br><span class="line">  impl_.finish();</span><br><span class="line">  const LogStream::Buffer&amp; buf(stream().buffer());//引用的缓冲区，所以不需要拷贝</span><br><span class="line">  g_output(buf.data(), buf.length());//输出，调用defaultOutput</span><br><span class="line">  if (impl_.level_ == FATAL)</span><br><span class="line">  &#123;</span><br><span class="line">    g_flush();//defaultFlush</span><br><span class="line">    abort();//终止程序</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Logger::setLogLevel(Logger::LogLevel level)</span><br><span class="line">&#123;</span><br><span class="line">  g_logLevel = level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Logger::setOutput(OutputFunc out)</span><br><span class="line">&#123;</span><br><span class="line">  g_output = out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要输出到文件当中就可以在测试文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用文件描述符而不用stdout</span><br><span class="line">muduo::Logger::setOutput(outputFunc);</span><br><span class="line">muduo::Logger::setFlush(flushFunc);</span><br></pre></td></tr></table></figure>

<p>重新指定函数</p>
<hr>
<h3 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h3><p> C 标准库中的 <code>fwrite</code> 函数，它的作用是将数据写入到标准输出流 <code>stdout</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fwrite(msg, 1, len, stdout);</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>msg</code> 是一个指向要写入的数据的指针，通常是一个字符数组或者字节流的指针。</li>
<li><code>1</code> 是写入数据块的大小，表示每个数据项的大小为 1 字节。</li>
<li><code>len</code> 表示要写入的数据项的个数，通常用 <code>size_t</code> 类型表示。</li>
</ul>
<p>该函数将 <code>len</code> 个数据项（每个数据项大小为 1 字节）从 <code>msg</code> 指针所指向的内存地址写入到标准输出流 <code>stdout</code> 中。在写入成功时，它会返回成功写入的数据项个数，通常等于 <code>len</code>。失败时，返回值可能会小于 <code>len</code>，或者出现错误。所以，实际应用中一般会检查返回值来确保写入操作成功。</p>
<h3 id="fflush"><a href="#fflush" class="headerlink" title="fflush"></a>fflush</h3><p>C 标准库中的 <code>fflush</code> 函数，它的作用是将输出缓冲区中的数据立即刷新（写入）到相应的输出流（此处是标准输出流 <code>stdout</code>）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fflush(stdout);</span><br></pre></td></tr></table></figure>

<p>在 C&#x2F;C++ 程序中，标准输出流 <code>stdout</code> 是一个带有输出缓冲区的流。当使用输出函数（如 <code>printf</code> 或 <code>fwrite</code>）输出数据时，这些数据会先被放入输出缓冲区，而不是立即输出到终端或文件。输出缓冲区会在满时、程序结束时、或者调用 <code>fflush</code> 函数时进行刷新，将数据真正写入到目标输出设备。</p>
<p>调用 <code>fflush(stdout)</code> 可以强制将输出缓冲区中的数据立即刷新到终端，这在某些情况下是必要的，例如：</p>
<ol>
<li>当需要在输出内容后立即显示在屏幕上，而不等到输出缓冲区满或程序结束时。</li>
<li>在输出文件和控制台混合使用时，确保输出的顺序正确。</li>
<li>当程序需要在输出之后执行一些可能导致崩溃的操作，为了确保输出的数据已经被正确保存。</li>
</ol>
<p>需要注意的是，频繁地调用 <code>fflush</code> 可能会导致性能下降，因为刷新输出缓冲区通常比较耗时。在一般情况下，系统会自动地在合适的时机进行缓冲区刷新，而无需手动调用 <code>fflush</code>。但在某些特殊情况下，手动调用 <code>fflush</code> 是有必要的。</p>
<hr>
<h3 id="LogStream-h"><a href="#LogStream-h" class="headerlink" title="LogStream.h"></a>LogStream.h</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#ifndef MUDUO_BASE_LOGSTREAM_H</span><br><span class="line">#define MUDUO_BASE_LOGSTREAM_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/noncopyable.h&quot;</span><br><span class="line">#include &quot;muduo/base/StringPiece.h&quot;</span><br><span class="line">#include &quot;muduo/base/Types.h&quot;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;string.h&gt; // memcpy</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">namespace detail</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">const int kSmallBuffer = 4000;</span><br><span class="line">const int kLargeBuffer = 4000*1000;</span><br><span class="line"></span><br><span class="line">template&lt;int SIZE&gt;</span><br><span class="line">class FixedBuffer : noncopyable//缓冲区类</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  FixedBuffer()</span><br><span class="line">    : cur_(data_)</span><br><span class="line">  &#123;</span><br><span class="line">    setCookie(cookieStart);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~FixedBuffer()</span><br><span class="line">  &#123;</span><br><span class="line">    setCookie(cookieEnd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void append(const char* /*restrict*/ buf, size_t len)//添加数据</span><br><span class="line">  &#123;</span><br><span class="line">    // FIXME: append partially这里没有实现当空间不足以添加的情况</span><br><span class="line">    if (implicit_cast&lt;size_t&gt;(avail()) &gt; len)// implicit_cast 函数进行 size_t 隐式类型转换</span><br><span class="line">    &#123;</span><br><span class="line">      memcpy(cur_, buf, len);</span><br><span class="line">      //使用 memcpy 函数将源缓冲区 (buf) 中的数据复制到目标缓冲区中。cur_ 是一个指向当前位置的指针，表示数据将被添加到当前位置的后面</span><br><span class="line">      cur_ += len;//将当前指针 cur_ 向后移动 len 个位置，以确保下次添加数据时不会覆盖已经添加的部分</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const char* data() const &#123; return data_; &#125;</span><br><span class="line">  int length() const &#123; return static_cast&lt;int&gt;(cur_ - data_); &#125;//已经用了的空间长度</span><br><span class="line"></span><br><span class="line">  // write to data_ directly</span><br><span class="line">  char* current() &#123; return cur_; &#125;//返回当前添加数据位置的指针</span><br><span class="line">  int avail() const &#123; return static_cast&lt;int&gt;(end() - cur_); &#125;//当前可用空间</span><br><span class="line">  void add(size_t len) &#123; cur_ += len; &#125;</span><br><span class="line"></span><br><span class="line">  void reset() &#123; cur_ = data_; &#125;//重置，只需要移动指针，覆盖就行了</span><br><span class="line">  void bzero() &#123; memZero(data_, sizeof data_); &#125;//清零</span><br><span class="line"></span><br><span class="line">  // for used by GDB</span><br><span class="line">  const char* debugString();</span><br><span class="line">  void setCookie(void (*cookie)()) &#123; cookie_ = cookie; &#125;</span><br><span class="line">  // for used by unit test</span><br><span class="line">  string toString() const &#123; return string(data_, length()); &#125;</span><br><span class="line">  StringPiece toStringPiece() const &#123; return StringPiece(data_, length()); &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  const char* end() const &#123; return data_ + sizeof data_; &#125;//结尾位置，因为data是首地址</span><br><span class="line">  // Must be outline function for cookies.</span><br><span class="line">  static void cookieStart();</span><br><span class="line">  static void cookieEnd();</span><br><span class="line"></span><br><span class="line">  void (*cookie_)();//是一个函数指针</span><br><span class="line">  char data_[SIZE];</span><br><span class="line">  char* cur_;//指向用了空间的下一个位置</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace detail</span><br><span class="line"></span><br><span class="line">class LogStream : noncopyable</span><br><span class="line">&#123;</span><br><span class="line">  typedef LogStream self;</span><br><span class="line"> public:</span><br><span class="line">  typedef detail::FixedBuffer&lt;detail::kSmallBuffer&gt; Buffer;</span><br><span class="line"></span><br><span class="line">  self&amp; operator&lt;&lt;(bool v)</span><br><span class="line">  &#123;</span><br><span class="line">    buffer_.append(v ? &quot;1&quot; : &quot;0&quot;, 1);</span><br><span class="line">    return *this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self&amp; operator&lt;&lt;(short);</span><br><span class="line">  self&amp; operator&lt;&lt;(unsigned short);</span><br><span class="line">  self&amp; operator&lt;&lt;(int);</span><br><span class="line">  self&amp; operator&lt;&lt;(unsigned int);</span><br><span class="line">  self&amp; operator&lt;&lt;(long);</span><br><span class="line">  self&amp; operator&lt;&lt;(unsigned long);</span><br><span class="line">  self&amp; operator&lt;&lt;(long long);</span><br><span class="line">  self&amp; operator&lt;&lt;(unsigned long long);</span><br><span class="line"></span><br><span class="line">  self&amp; operator&lt;&lt;(const void*);</span><br><span class="line"></span><br><span class="line">  self&amp; operator&lt;&lt;(float v)</span><br><span class="line">  &#123;</span><br><span class="line">    *this &lt;&lt; static_cast&lt;double&gt;(v);</span><br><span class="line">    return *this;</span><br><span class="line">  &#125;</span><br><span class="line">  self&amp; operator&lt;&lt;(double);</span><br><span class="line">  // self&amp; operator&lt;&lt;(long double);</span><br><span class="line"></span><br><span class="line">  self&amp; operator&lt;&lt;(char v)</span><br><span class="line">  &#123;</span><br><span class="line">    buffer_.append(&amp;v, 1);</span><br><span class="line">    return *this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // self&amp; operator&lt;&lt;(signed char);</span><br><span class="line">  // self&amp; operator&lt;&lt;(unsigned char);</span><br><span class="line"></span><br><span class="line">  self&amp; operator&lt;&lt;(const char* str)</span><br><span class="line">  &#123;</span><br><span class="line">    if (str)</span><br><span class="line">    &#123;</span><br><span class="line">      buffer_.append(str, strlen(str));</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      buffer_.append(&quot;(null)&quot;, 6);</span><br><span class="line">    &#125;</span><br><span class="line">    return *this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self&amp; operator&lt;&lt;(const unsigned char* str)</span><br><span class="line">  &#123;</span><br><span class="line">    return operator&lt;&lt;(reinterpret_cast&lt;const char*&gt;(str));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self&amp; operator&lt;&lt;(const string&amp; v)</span><br><span class="line">  &#123;</span><br><span class="line">    buffer_.append(v.c_str(), v.size());</span><br><span class="line">    return *this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self&amp; operator&lt;&lt;(const StringPiece&amp; v)</span><br><span class="line">  &#123;</span><br><span class="line">    buffer_.append(v.data(), v.size());</span><br><span class="line">    return *this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self&amp; operator&lt;&lt;(const Buffer&amp; v)</span><br><span class="line">  &#123;</span><br><span class="line">    *this &lt;&lt; v.toStringPiece();</span><br><span class="line">    return *this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void append(const char* data, int len) &#123; buffer_.append(data, len); &#125;</span><br><span class="line">  const Buffer&amp; buffer() const &#123; return buffer_; &#125;</span><br><span class="line">  void resetBuffer() &#123; buffer_.reset(); &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  void staticCheck();</span><br><span class="line"></span><br><span class="line">  template&lt;typename T&gt;</span><br><span class="line">  void formatInteger(T);</span><br><span class="line"></span><br><span class="line">  Buffer buffer_;</span><br><span class="line"></span><br><span class="line">  static const int kMaxNumericSize = 48;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Fmt // : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  template&lt;typename T&gt;</span><br><span class="line">  Fmt(const char* fmt, T val);</span><br><span class="line"></span><br><span class="line">  const char* data() const &#123; return buf_; &#125;</span><br><span class="line">  int length() const &#123; return length_; &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  char buf_[32];</span><br><span class="line">  int length_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inline LogStream&amp; operator&lt;&lt;(LogStream&amp; s, const Fmt&amp; fmt)</span><br><span class="line">&#123;</span><br><span class="line">  s.append(fmt.data(), fmt.length());</span><br><span class="line">  return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Format quantity n in SI units (k, M, G, T, P, E).</span><br><span class="line">// The returned string is atmost 5 characters long.</span><br><span class="line">// Requires n &gt;= 0</span><br><span class="line">string formatSI(int64_t n);</span><br><span class="line"></span><br><span class="line">// Format quantity n in IEC (binary) units (Ki, Mi, Gi, Ti, Pi, Ei).</span><br><span class="line">// The returned string is atmost 6 characters long.</span><br><span class="line">// Requires n &gt;= 0</span><br><span class="line">string formatIEC(int64_t n);</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_BASE_LOGSTREAM_H</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="LogStream-cc"><a href="#LogStream-cc" class="headerlink" title="LogStream.cc"></a>LogStream.cc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/LogStream.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;limits&gt;</span><br><span class="line">#include &lt;type_traits&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#ifndef __STDC_FORMAT_MACROS</span><br><span class="line">#define __STDC_FORMAT_MACROS</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::detail;</span><br><span class="line"></span><br><span class="line">// TODO: better itoa.</span><br><span class="line">#if defined(__clang__)</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wtautological-compare&quot;</span><br><span class="line">#else</span><br><span class="line">#pragma GCC diagnostic ignored &quot;-Wtype-limits&quot; //代码中忽略检测到旧式的类型转换时发出警告</span><br><span class="line">#endif</span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace detail</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">const char digits[] = &quot;9876543210123456789&quot;;</span><br><span class="line">const char* zero = digits + 9;</span><br><span class="line">static_assert(sizeof(digits) == 20, &quot;wrong number of digits&quot;);</span><br><span class="line"></span><br><span class="line">const char digitsHex[] = &quot;0123456789ABCDEF&quot;;</span><br><span class="line">static_assert(sizeof digitsHex == 17, &quot;wrong number of digitsHex&quot;);</span><br><span class="line"></span><br><span class="line">// Efficient Integer to String Conversions, by Matthew Wilson.</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">size_t convert(char buf[], T value)</span><br><span class="line">&#123;</span><br><span class="line">  T i = value;</span><br><span class="line">  char* p = buf;</span><br><span class="line"></span><br><span class="line">  do</span><br><span class="line">  &#123;</span><br><span class="line">    int lsd = static_cast&lt;int&gt;(i % 10);//最后一个数字</span><br><span class="line">    i /= 10;//// 将 i 缩小为原来的十分之一，即去掉最后一位数字</span><br><span class="line">    *p++ = zero[lsd]; // 将最后一位数字对应的字符存储到 buf 中，然后移动指针 p 到下一个位置</span><br><span class="line">  &#125; while (i != 0);</span><br><span class="line"></span><br><span class="line">  if (value &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    *p++ = &#x27;-&#x27;;// 如果传入的 value 是负数，则在字符串最前面加上负号，并移动指针 p 到下一个位置</span><br><span class="line">  &#125;</span><br><span class="line">  *p = &#x27;\0&#x27;;</span><br><span class="line">  std::reverse(buf, p);// 反转整个字符串，以得到正确的顺序</span><br><span class="line"></span><br><span class="line">  return p - buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">size_t convertHex(char buf[], uintptr_t value)//16进制</span><br><span class="line">&#123;</span><br><span class="line">  uintptr_t i = value;</span><br><span class="line">  char* p = buf;</span><br><span class="line"></span><br><span class="line">  do</span><br><span class="line">  &#123;</span><br><span class="line">    int lsd = static_cast&lt;int&gt;(i % 16);</span><br><span class="line">    i /= 16;</span><br><span class="line">    *p++ = digitsHex[lsd];</span><br><span class="line">  &#125; while (i != 0);</span><br><span class="line"></span><br><span class="line">  *p = &#x27;\0&#x27;;</span><br><span class="line">  std::reverse(buf, p);</span><br><span class="line"></span><br><span class="line">  return p - buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template class FixedBuffer&lt;kSmallBuffer&gt;;</span><br><span class="line">template class FixedBuffer&lt;kLargeBuffer&gt;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace detail</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> Format a number with 5 characters, including SI units.</span><br><span class="line"> [0,     999]</span><br><span class="line"> [1.00k, 999k]</span><br><span class="line"> [1.00M, 999M]</span><br><span class="line"> [1.00G, 999G]</span><br><span class="line"> [1.00T, 999T]</span><br><span class="line"> [1.00P, 999P]</span><br><span class="line"> [1.00E, inf)</span><br><span class="line">*/</span><br><span class="line">std::string formatSI(int64_t s)</span><br><span class="line">&#123;</span><br><span class="line">  double n = static_cast&lt;double&gt;(s);</span><br><span class="line">  char buf[64];</span><br><span class="line">  if (s &lt; 1000)</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%&quot; PRId64, s);</span><br><span class="line">  else if (s &lt; 9995)</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%.2fk&quot;, n/1e3);</span><br><span class="line">  else if (s &lt; 99950)</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%.1fk&quot;, n/1e3);</span><br><span class="line">  else if (s &lt; 999500)</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%.0fk&quot;, n/1e3);</span><br><span class="line">  else if (s &lt; 9995000)</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%.2fM&quot;, n/1e6);</span><br><span class="line">  else if (s &lt; 99950000)</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%.1fM&quot;, n/1e6);</span><br><span class="line">  else if (s &lt; 999500000)</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%.0fM&quot;, n/1e6);</span><br><span class="line">  else if (s &lt; 9995000000)</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%.2fG&quot;, n/1e9);</span><br><span class="line">  else if (s &lt; 99950000000)</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%.1fG&quot;, n/1e9);</span><br><span class="line">  else if (s &lt; 999500000000)</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%.0fG&quot;, n/1e9);</span><br><span class="line">  else if (s &lt; 9995000000000)</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%.2fT&quot;, n/1e12);</span><br><span class="line">  else if (s &lt; 99950000000000)</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%.1fT&quot;, n/1e12);</span><br><span class="line">  else if (s &lt; 999500000000000)</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%.0fT&quot;, n/1e12);</span><br><span class="line">  else if (s &lt; 9995000000000000)</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%.2fP&quot;, n/1e15);</span><br><span class="line">  else if (s &lt; 99950000000000000)</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%.1fP&quot;, n/1e15);</span><br><span class="line">  else if (s &lt; 999500000000000000)</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%.0fP&quot;, n/1e15);</span><br><span class="line">  else</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%.2fE&quot;, n/1e18);</span><br><span class="line">  return buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> [0, 1023]</span><br><span class="line"> [1.00Ki, 9.99Ki]</span><br><span class="line"> [10.0Ki, 99.9Ki]</span><br><span class="line"> [ 100Ki, 1023Ki]</span><br><span class="line"> [1.00Mi, 9.99Mi]</span><br><span class="line">*/</span><br><span class="line">std::string formatIEC(int64_t s)//将给定的整数 s 格式化成带有国际单位符号的字符串表示</span><br><span class="line">&#123;</span><br><span class="line">  double n = static_cast&lt;double&gt;(s);</span><br><span class="line">  char buf[64];</span><br><span class="line">  const double Ki = 1024.0;</span><br><span class="line">  const double Mi = Ki * 1024.0;</span><br><span class="line">  const double Gi = Mi * 1024.0;</span><br><span class="line">  const double Ti = Gi * 1024.0;</span><br><span class="line">  const double Pi = Ti * 1024.0;</span><br><span class="line">  const double Ei = Pi * 1024.0;</span><br><span class="line"></span><br><span class="line">  if (n &lt; Ki)</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%&quot; PRId64, s);</span><br><span class="line">  else if (n &lt; Ki*9.995)</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%.2fKi&quot;, n / Ki);</span><br><span class="line">  else if (n &lt; Ki*99.95)</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%.1fKi&quot;, n / Ki);</span><br><span class="line">  else if (n &lt; Ki*1023.5)</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%.0fKi&quot;, n / Ki);</span><br><span class="line"></span><br><span class="line">  else if (n &lt; Mi*9.995)</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%.2fMi&quot;, n / Mi);</span><br><span class="line">  else if (n &lt; Mi*99.95)</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%.1fMi&quot;, n / Mi);</span><br><span class="line">  else if (n &lt; Mi*1023.5)</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%.0fMi&quot;, n / Mi);</span><br><span class="line"></span><br><span class="line">  else if (n &lt; Gi*9.995)</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%.2fGi&quot;, n / Gi);</span><br><span class="line">  else if (n &lt; Gi*99.95)</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%.1fGi&quot;, n / Gi);</span><br><span class="line">  else if (n &lt; Gi*1023.5)</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%.0fGi&quot;, n / Gi);</span><br><span class="line"></span><br><span class="line">  else if (n &lt; Ti*9.995)</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%.2fTi&quot;, n / Ti);</span><br><span class="line">  else if (n &lt; Ti*99.95)</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%.1fTi&quot;, n / Ti);</span><br><span class="line">  else if (n &lt; Ti*1023.5)</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%.0fTi&quot;, n / Ti);</span><br><span class="line"></span><br><span class="line">  else if (n &lt; Pi*9.995)</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%.2fPi&quot;, n / Pi);</span><br><span class="line">  else if (n &lt; Pi*99.95)</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%.1fPi&quot;, n / Pi);</span><br><span class="line">  else if (n &lt; Pi*1023.5)</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%.0fPi&quot;, n / Pi);</span><br><span class="line"></span><br><span class="line">  else if (n &lt; Ei*9.995)</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%.2fEi&quot;, n / Ei );</span><br><span class="line">  else</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%.1fEi&quot;, n / Ei );</span><br><span class="line">  return buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void LogStream::formatInteger(T v)</span><br><span class="line">&#123;</span><br><span class="line">  if (buffer_.avail() &gt;= kMaxNumericSize)</span><br><span class="line">  &#123;</span><br><span class="line">    size_t len = convert(buffer_.current(), v);//将int转化成string存入buffer当前位置缓冲区</span><br><span class="line">    buffer_.add(len);//调整current位置</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LogStream&amp; LogStream::operator&lt;&lt;(short v)</span><br><span class="line">&#123;</span><br><span class="line">  *this &lt;&lt; static_cast&lt;int&gt;(v);</span><br><span class="line">  //将一个 short 值转换为 int 值，然后调用 LogStream 对象的另一个 &lt;&lt; 操作符，将转换后的 int 值写入流中</span><br><span class="line">  return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">Fmt::Fmt(const char* fmt, T val)</span><br><span class="line">&#123;//断言T是算术类型</span><br><span class="line">  static_assert(std::is_arithmetic&lt;T&gt;::value == true, &quot;Must be arithmetic type&quot;);</span><br><span class="line"></span><br><span class="line">  length_ = snprintf(buf_, sizeof buf_, fmt, val);</span><br><span class="line">  assert(static_cast&lt;size_t&gt;(length_) &lt; sizeof buf_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Explicit instantiations</span><br><span class="line">//一些特化，除了这些其它类型都不能用，显示实例化了</span><br><span class="line">template Fmt::Fmt(const char* fmt, char);</span><br><span class="line"></span><br><span class="line">template Fmt::Fmt(const char* fmt, short);</span><br><span class="line">template Fmt::Fmt(const char* fmt, unsigned short);</span><br><span class="line">template Fmt::Fmt(const char* fmt, int);</span><br><span class="line">template Fmt::Fmt(const char* fmt, unsigned int);</span><br><span class="line">template Fmt::Fmt(const char* fmt, long);</span><br><span class="line">template Fmt::Fmt(const char* fmt, unsigned long);</span><br><span class="line">template Fmt::Fmt(const char* fmt, long long);</span><br><span class="line">template Fmt::Fmt(const char* fmt, unsigned long long);</span><br><span class="line"></span><br><span class="line">template Fmt::Fmt(const char* fmt, float);</span><br><span class="line">template Fmt::Fmt(const char* fmt, double);</span><br></pre></td></tr></table></figure>

<p>这两个函数 <code>formatSI</code> 和 <code>formatIEC</code> 的作用是将给定的整数 <code>s</code> 格式化成带有国际单位符号的字符串表示。</p>
<ol>
<li><code>formatSI</code> 函数:<ul>
<li>这个函数将一个整数 <code>s</code> 格式化成带有国际单位符号的字符串表示。国际单位符号包括 k（千）、M（百万）、G（十亿）、T（万亿）、P（千万亿）、E（百万亿亿）。</li>
<li>函数首先将整数 <code>s</code> 转换成 <code>double</code> 类型 <code>n</code>，然后根据整数的大小选择合适的单位并格式化成字符串。</li>
<li>例如，如果 <code>s</code> 小于 1000，则直接将整数转换成字符串；如果 <code>s</code> 在 1000 到 9995 之间，则将其除以 1000 并保留两位小数，后缀为 “k”；如果在其他范围内，则依次使用 “M”、”G”、”T”、”P”、”E” 作为后缀，并对数字进行适当的格式化。</li>
</ul>
</li>
<li><code>formatIEC</code> 函数:<ul>
<li>这个函数将一个整数 <code>s</code> 格式化成带有 IEC（国际电工委员会）单位符号的字符串表示。IEC 单位符号是用于计算机存储容量的单位，基于 2 的幂次方，包括 Ki（千字节）、Mi（兆字节）、Gi（吉字节）、Ti（太字节）、Pi（拍字节）、Ei（艾字节）。</li>
<li>函数首先将整数 <code>s</code> 转换成 <code>double</code> 类型 <code>n</code>，然后根据整数的大小选择合适的单位并格式化成字符串。</li>
<li>例如，如果 <code>s</code> 小于 1024，则直接将整数转换成字符串；如果 <code>s</code> 在 1024 到 9995 之间，则将其除以 1024 并保留两位小数，后缀为 “Ki”；如果在其他范围内，则依次使用 “Mi”、”Gi”、”Ti” 作为后缀，并对数字进行适当的格式化。</li>
</ul>
</li>
</ol>
<p>这两个函数使得对整数的单位转换和格式化变得简单和方便，适用于不同范围的整数值，并以易读的形式展示其大小。</p>
<h3 id="LogStream-test-cc"><a href="#LogStream-test-cc" class="headerlink" title="LogStream_test.cc"></a>LogStream_test.cc</h3><p><code>if(BOOSTTEST_LIBRARY)</code>：这个条件语句检查是否定义了宏 <code>BOOSTTEST_LIBRARY</code>。这通常是在 CMake 配置文件中定义的一个宏，用于指示是否包含了 Boost 库的测试框架。如果定义了这个宏，说明系统中包含了 Boost 测试库，可以执行下面的操作；否则，这段代码块会被忽略</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/LogStream.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;limits&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">//#define BOOST_TEST_MODULE LogStreamTest</span><br><span class="line">#define BOOST_TEST_MAIN</span><br><span class="line">#define BOOST_TEST_DYN_LINK</span><br><span class="line">#include &lt;boost/test/unit_test.hpp&gt;</span><br><span class="line"></span><br><span class="line">using muduo::string;</span><br><span class="line"></span><br><span class="line">BOOST_AUTO_TEST_CASE(testLogStreamBooleans)//都是一些测试用例，需要安装sudo apt-get install libboost-test-dev</span><br><span class="line">&#123;//bool的测试</span><br><span class="line">  muduo::LogStream os;</span><br><span class="line">  const muduo::LogStream::Buffer&amp; buf = os.buffer();</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;&quot;));</span><br><span class="line">  os &lt;&lt; true;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;1&quot;));</span><br><span class="line">  os &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;1\n&quot;));</span><br><span class="line">  os &lt;&lt; false;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;1\n0&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOST_AUTO_TEST_CASE(testLogStreamIntegers)//整形的测试</span><br><span class="line">&#123;</span><br><span class="line">  muduo::LogStream os;</span><br><span class="line">  const muduo::LogStream::Buffer&amp; buf = os.buffer();</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;&quot;));</span><br><span class="line">  os &lt;&lt; 1;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;1&quot;));</span><br><span class="line">  os &lt;&lt; 0;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;10&quot;));</span><br><span class="line">  os &lt;&lt; -1;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;10-1&quot;));</span><br><span class="line">  os.resetBuffer();//重复利用</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; 0 &lt;&lt; &quot; &quot; &lt;&lt; 123 &lt;&lt; &#x27;x&#x27; &lt;&lt; 0x64;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0 123x100&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOST_AUTO_TEST_CASE(testLogStreamIntegerLimits)</span><br><span class="line">&#123;</span><br><span class="line">  muduo::LogStream os;</span><br><span class="line">  const muduo::LogStream::Buffer&amp; buf = os.buffer();</span><br><span class="line">  os &lt;&lt; -2147483647;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;-2147483647&quot;));</span><br><span class="line">  os &lt;&lt; static_cast&lt;int&gt;(-2147483647 - 1);</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;-2147483647-2147483648&quot;));</span><br><span class="line">  os &lt;&lt; &#x27; &#x27;;</span><br><span class="line">  os &lt;&lt; 2147483647;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;-2147483647-2147483648 2147483647&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; std::numeric_limits&lt;int16_t&gt;::min();</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;-32768&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; std::numeric_limits&lt;int16_t&gt;::max();</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;32767&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; std::numeric_limits&lt;uint16_t&gt;::min();</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; std::numeric_limits&lt;uint16_t&gt;::max();</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;65535&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; std::numeric_limits&lt;int32_t&gt;::min();</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;-2147483648&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; std::numeric_limits&lt;int32_t&gt;::max();</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;2147483647&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; std::numeric_limits&lt;uint32_t&gt;::min();</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; std::numeric_limits&lt;uint32_t&gt;::max();</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;4294967295&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; std::numeric_limits&lt;int64_t&gt;::min();</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;-9223372036854775808&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; std::numeric_limits&lt;int64_t&gt;::max();</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;9223372036854775807&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; std::numeric_limits&lt;uint64_t&gt;::min();</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; std::numeric_limits&lt;uint64_t&gt;::max();</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;18446744073709551615&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  int16_t a = 0;</span><br><span class="line">  int32_t b = 0;</span><br><span class="line">  int64_t c = 0;</span><br><span class="line">  os &lt;&lt; a;</span><br><span class="line">  os &lt;&lt; b;</span><br><span class="line">  os &lt;&lt; c;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;000&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOST_AUTO_TEST_CASE(testLogStreamFloats)</span><br><span class="line">&#123;</span><br><span class="line">  muduo::LogStream os;</span><br><span class="line">  const muduo::LogStream::Buffer&amp; buf = os.buffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; 0.0;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; 1.0;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;1&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; 0.1;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0.1&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; 0.05;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0.05&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; 0.15;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0.15&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  double a = 0.1;</span><br><span class="line">  os &lt;&lt; a;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0.1&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  double b = 0.05;</span><br><span class="line">  os &lt;&lt; b;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0.05&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  double c = 0.15;</span><br><span class="line">  os &lt;&lt; c;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0.15&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; a+b;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0.15&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  BOOST_CHECK(a+b != c);</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; 1.23456789;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;1.23456789&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; 1.234567;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;1.234567&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; -123.456;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;-123.456&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOST_AUTO_TEST_CASE(testLogStreamVoid)</span><br><span class="line">&#123;</span><br><span class="line">  muduo::LogStream os;</span><br><span class="line">  const muduo::LogStream::Buffer&amp; buf = os.buffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; static_cast&lt;void*&gt;(0);</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0x0&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; reinterpret_cast&lt;void*&gt;(8888);</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0x22B8&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOST_AUTO_TEST_CASE(testLogStreamStrings)</span><br><span class="line">&#123;</span><br><span class="line">  muduo::LogStream os;</span><br><span class="line">  const muduo::LogStream::Buffer&amp; buf = os.buffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; &quot;Hello &quot;;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;Hello &quot;));</span><br><span class="line"></span><br><span class="line">  string chenshuo = &quot;Shuo Chen&quot;;</span><br><span class="line">  os &lt;&lt; chenshuo;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;Hello Shuo Chen&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOST_AUTO_TEST_CASE(testLogStreamFmts)</span><br><span class="line">&#123;</span><br><span class="line">  muduo::LogStream os;</span><br><span class="line">  const muduo::LogStream::Buffer&amp; buf = os.buffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; muduo::Fmt(&quot;%4d&quot;, 1);</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;   1&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; muduo::Fmt(&quot;%4.2f&quot;, 1.2);</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;1.20&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; muduo::Fmt(&quot;%4.2f&quot;, 1.2) &lt;&lt; muduo::Fmt(&quot;%4d&quot;, 43);</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;1.20  43&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOST_AUTO_TEST_CASE(testLogStreamLong)</span><br><span class="line">&#123;</span><br><span class="line">  muduo::LogStream os;</span><br><span class="line">  const muduo::LogStream::Buffer&amp; buf = os.buffer();</span><br><span class="line">  for (int i = 0; i &lt; 399; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    os &lt;&lt; &quot;123456789 &quot;;</span><br><span class="line">    BOOST_CHECK_EQUAL(buf.length(), 10*(i+1));</span><br><span class="line">    BOOST_CHECK_EQUAL(buf.avail(), 4000 - 10*(i+1));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; &quot;abcdefghi &quot;;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.length(), 3990);</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.avail(), 10);</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; &quot;abcdefghi&quot;;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.length(), 3999);</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.avail(), 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOST_AUTO_TEST_CASE(testFormatSI)</span><br><span class="line">&#123;</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(0), string(&quot;0&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(999), string(&quot;999&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(1000), string(&quot;1.00k&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(9990), string(&quot;9.99k&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(9994), string(&quot;9.99k&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(9995), string(&quot;10.0k&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(10000), string(&quot;10.0k&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(10049), string(&quot;10.0k&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(10050), string(&quot;10.1k&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(99900), string(&quot;99.9k&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(99949), string(&quot;99.9k&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(99950), string(&quot;100k&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(100499), string(&quot;100k&quot;));</span><br><span class="line">  // FIXME:</span><br><span class="line">  // BOOST_CHECK_EQUAL(muduo::formatSI(100500), string(&quot;101k&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(100501), string(&quot;101k&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(999499), string(&quot;999k&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(999500), string(&quot;1.00M&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(1004999), string(&quot;1.00M&quot;));</span><br><span class="line">  // BOOST_CHECK_EQUAL(muduo::formatSI(1005000), string(&quot;1.01M&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(1005001), string(&quot;1.01M&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(INT64_MAX), string(&quot;9.22E&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOST_AUTO_TEST_CASE(testFormatIEC)//测试 muduo::formatIEC 函数的行为是否正确</span><br><span class="line">&#123;</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(0), string(&quot;0&quot;));//测试用例 0：函数应该返回 &quot;0&quot;</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(1023), string(&quot;1023&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(1024), string(&quot;1.00Ki&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(10234), string(&quot;9.99Ki&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(10235), string(&quot;10.0Ki&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(10240), string(&quot;10.0Ki&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(10291), string(&quot;10.0Ki&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(10292), string(&quot;10.1Ki&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(102348), string(&quot;99.9Ki&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(102349), string(&quot;100Ki&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(102912), string(&quot;100Ki&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(102913), string(&quot;101Ki&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(1022976), string(&quot;999Ki&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(1047552), string(&quot;1023Ki&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(1047961), string(&quot;1023Ki&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(1048063), string(&quot;1023Ki&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(1048064), string(&quot;1.00Mi&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(1048576), string(&quot;1.00Mi&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(10480517), string(&quot;9.99Mi&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(10480518), string(&quot;10.0Mi&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(INT64_MAX), string(&quot;8.00Ei&quot;));</span><br><span class="line">&#125;//每个 BOOST_CHECK_EQUAL 语句都验证了函数的实际输出是否与预期输出相匹配。如果所有检查都通过，就表示 muduo::formatIEC 函数在提供的测试用例中表现正确</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>LogStream_bench.cc</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/LogStream.h&quot;</span><br><span class="line">#include &quot;muduo/base/Timestamp.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define __STDC_FORMAT_MACROS</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line"></span><br><span class="line">const size_t N = 1000000;</span><br><span class="line"></span><br><span class="line">#pragma GCC diagnostic ignored &quot;-Wold-style-cast&quot;</span><br><span class="line">//可以在代码中暂时禁用对 -Wold-style-cast 警告的处理，这意味着编译器会忽略与旧式类型转换相关的警告，不会在这些地方生成警告信息</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void benchPrintf(const char* fmt)//函数打印出性能测试的结果，即格式化字符串操作所花费的时间</span><br><span class="line">&#123;</span><br><span class="line">  char buf[32];</span><br><span class="line">  Timestamp start(Timestamp::now());</span><br><span class="line">  for (size_t i = 0; i &lt; N; ++i)</span><br><span class="line">    snprintf(buf, sizeof buf, fmt, (T)(i));//(T)(i)是c语言的旧式类型转换,snprintf 函数会重新写入到 buf 缓冲区的开头</span><br><span class="line">  Timestamp end(Timestamp::now());</span><br><span class="line"></span><br><span class="line">  printf(&quot;benchPrintf %f\n&quot;, timeDifference(end, start));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void benchStringStream()</span><br><span class="line">&#123;</span><br><span class="line">  Timestamp start(Timestamp::now());</span><br><span class="line">  std::ostringstream os;</span><br><span class="line"></span><br><span class="line">  for (size_t i = 0; i &lt; N; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    os &lt;&lt; (T)(i);</span><br><span class="line">    os.seekp(0, std::ios_base::beg);</span><br><span class="line">    //将流的写指针重置到起始位置，以便下一次循环中可以重新将数据插入到流中</span><br><span class="line">  &#125;</span><br><span class="line">  Timestamp end(Timestamp::now());</span><br><span class="line"></span><br><span class="line">  printf(&quot;benchStringStream %f\n&quot;, timeDifference(end, start));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void benchLogStream()</span><br><span class="line">&#123;</span><br><span class="line">  Timestamp start(Timestamp::now());</span><br><span class="line">  LogStream os;</span><br><span class="line">  for (size_t i = 0; i &lt; N; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    os &lt;&lt; (T)(i);</span><br><span class="line">    os.resetBuffer();//重置，只需要移动指针，覆盖就行了</span><br><span class="line">  &#125;</span><br><span class="line">  Timestamp end(Timestamp::now());</span><br><span class="line"></span><br><span class="line">  printf(&quot;benchLogStream %f\n&quot;, timeDifference(end, start));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  benchPrintf&lt;int&gt;(&quot;%d&quot;);</span><br><span class="line"></span><br><span class="line">  puts(&quot;int&quot;);//在控制台输出字符串 &quot;int&quot;，并在末尾自动添加换行符</span><br><span class="line">  benchPrintf&lt;int&gt;(&quot;%d&quot;);</span><br><span class="line">  benchStringStream&lt;int&gt;();</span><br><span class="line">  benchLogStream&lt;int&gt;();</span><br><span class="line"></span><br><span class="line">  puts(&quot;double&quot;);</span><br><span class="line">  benchPrintf&lt;double&gt;(&quot;%.12g&quot;);</span><br><span class="line">  benchStringStream&lt;double&gt;();</span><br><span class="line">  benchLogStream&lt;double&gt;();</span><br><span class="line"></span><br><span class="line">  puts(&quot;int64_t&quot;);</span><br><span class="line">  benchPrintf&lt;int64_t&gt;(&quot;%&quot; PRId64);</span><br><span class="line">  benchStringStream&lt;int64_t&gt;();</span><br><span class="line">  benchLogStream&lt;int64_t&gt;();</span><br><span class="line"></span><br><span class="line">  puts(&quot;void*&quot;);</span><br><span class="line">  benchPrintf&lt;void*&gt;(&quot;%p&quot;);</span><br><span class="line">  benchStringStream&lt;void*&gt;();</span><br><span class="line">  benchLogStream&lt;void*&gt;();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%884%EF%BC%89/image-20230805153659241.png" alt="image-20230805153659241"></p>
<img src="/2023/08/04/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%884%EF%BC%89/image-20230805153659241.png" class title="This is an test image">

<p>这段代码是一个性能测试程序，旨在比较不同方法（<code>printf</code>、<code>std::ostringstream</code> 和 <code>LogStream</code>）来进行格式化字符串操作时所花费的时间。以下是对代码的分析：</p>
<ol>
<li>引入头文件和命名空间：代码开始引入了 <code>muduo/base/LogStream.h</code> 和 <code>muduo/base/Timestamp.h</code> 头文件，以及 <code>std::ostringstream</code> 和其他标准库头文件。然后，通过 <code>using namespace muduo;</code> 使用了 <code>muduo</code> 命名空间。</li>
<li>定义常量和模板函数：代码定义了一个常量 <code>N</code>，表示迭代次数。接下来，定义了三个模板函数 <code>benchPrintf</code>、<code>benchStringStream</code> 和 <code>benchLogStream</code>，用于分别测试不同的格式化字符串操作方法。</li>
<li><code>benchPrintf</code> 函数：该函数使用 <code>snprintf</code> 函数以指定的格式将数据格式化到缓冲区。使用当前时间戳记录操作开始时间，然后进行循环迭代，每次迭代都进行一次格式化操作。迭代结束后再次获取时间戳，计算出格式化操作所花费的时间，并打印结果。</li>
<li><code>benchStringStream</code> 函数：该函数使用 <code>std::ostringstream</code> 对象进行格式化操作。与前一个函数类似，使用时间戳记录操作开始时间，然后进行循环迭代，每次迭代使用流将数据格式化。迭代结束后计算时间差，并打印结果。</li>
<li><code>benchLogStream</code> 函数：该函数使用 <code>LogStream</code> 对象进行格式化操作。同样，使用时间戳记录操作开始时间，然后进行循环迭代，每次迭代使用 <code>LogStream</code> 将数据格式化。迭代结束后计算时间差，并打印结果。</li>
<li><code>main</code> 函数：在主函数中，首先测试了 <code>benchPrintf</code> 函数的性能，对 <code>int</code> 类型使用 <code>%d</code> 格式。然后分别测试了 <code>int</code>、<code>double</code>、<code>int64_t</code> 和 <code>void*</code> 类型，调用相应的测试函数。</li>
</ol>
<p>总体来说，该程序旨在比较三种不同方法在进行格式化字符串操作时的性能。通过在循环中多次执行格式化操作，可以测量出每种方法的性能表现，并将结果打印出来以进行比较。这样可以帮助开发人员选择在特定情况下最适合的格式化字符串操作方法。</p>
<h1 id="StringPiece-h"><a href="#StringPiece-h" class="headerlink" title="StringPiece.h"></a>StringPiece.h</h1><p>用以实现高效的字符串传递</p>
<p>如果void foo(const StringPiece&amp; x);</p>
<p>这里既可以用const char*、也可以用std::string类型作为参数传递进去</p>
<p>并且不涉及内存拷贝</p>
<p>在STL中为了提供通用的操作而又不损失效率，我们用到了一种特殊的技巧，叫traits编程技巧。其体的来说，traits就是通过定义一些结构体或类，并利用模板特化和偏特化的能力，给类型赋予一些特性，这些特性根据类型的不同而异。<br>在程序设计中可以使用这些traits来判断一个类型的一些特性，引发C++的函数重载机制，实现同一种操作因类型不同而异的效果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#ifdef HAVE_TYPE_TRAITS</span><br><span class="line">//这里对_type_traits进行特化，给StringPiece一些特性</span><br><span class="line">// This makes vector&lt;StringPiece&gt; really fast for some STL implementations</span><br><span class="line">template&lt;&gt; struct __type_traits&lt;muduo::StringPiece&gt; &#123;</span><br><span class="line">  typedef __true_type    has_trivial_default_constructor;</span><br><span class="line">  typedef __true_type    has_trivial_copy_constructor;</span><br><span class="line">  typedef __true_type    has_trivial_assignment_operator;</span><br><span class="line">  typedef __true_type    has_trivial_destructor;</span><br><span class="line">  typedef __true_type    is_POD_type;</span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>这段代码是对 C++ 标准库中的 <code>type_traits</code> 进行特化，为 <code>muduo::StringPiece</code> 类型添加一些特性。</p>
<ol>
<li><code>#ifdef HAVE_TYPE_TRAITS</code>：这是一个预处理指令，用于判断是否定义了宏 <code>HAVE_TYPE_TRAITS</code>。如果定义了该宏，则执行下面的代码块，否则忽略这段代码。</li>
<li><code>template&lt;&gt; struct __type_traits&lt;muduo::StringPiece&gt;</code>：这是一个模板特化，为 <code>muduo::StringPiece</code> 类型添加特性。<code>__type_traits</code> 是一个模板结构体，用于提供类型特性信息。</li>
<li><code>typedef __true_type    has_trivial_default_constructor;</code>：给 <code>muduo::StringPiece</code> 添加了一个类型特性 <code>has_trivial_default_constructor</code>，该特性表示该类型拥有一个平凡的默认构造函数（trivial default constructor）。</li>
<li><code>typedef __true_type    has_trivial_copy_constructor;</code>：添加了类型特性 <code>has_trivial_copy_constructor</code>，表示 <code>muduo::StringPiece</code> 拥有一个平凡的拷贝构造函数（trivial copy constructor）。</li>
<li><code>typedef __true_type    has_trivial_assignment_operator;</code>：添加了类型特性 <code>has_trivial_assignment_operator</code>，表示 <code>muduo::StringPiece</code> 拥有一个平凡的赋值运算符（trivial assignment operator）。</li>
<li><code>typedef __true_type    has_trivial_destructor;</code>：添加了类型特性 <code>has_trivial_destructor</code>，表示 <code>muduo::StringPiece</code> 拥有一个平凡的析构函数（trivial destructor）。</li>
<li><code>typedef __true_type    is_POD_type;</code>：添加了类型特性 <code>is_POD_type</code>，表示 <code>muduo::StringPiece</code> 是一个平凡的数据类型（Plain Old Data type）。</li>
</ol>
<p>特化 <code>type_traits</code> 是为了告诉编译器有关于 <code>muduo::StringPiece</code> 类型的特性信息，这些信息可以用于优化代码，提高程序的性能。例如，在使用标准库容器 <code>vector&lt;StringPiece&gt;</code> 时，这些特性信息可以让一些 STL 实现对 <code>muduo::StringPiece</code> 进行更高效的操作，使得程序在处理该类型时更快速和高效。</p>
<hr>
<p>你可以在代码中使用 <code>muduo::StringPiece</code> 类，以及定义在这个头文件中的相关操作函数。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;muduo/base/StringPiece.h&quot;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    const char* data = &quot;Hello, World!&quot;;</span><br><span class="line">    muduo::StringPiece piece(data, 5); // 创建一个 StringPiece，引用前5个字符</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;StringPiece size: &quot; &lt;&lt; piece.size() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;StringPiece data: &quot; &lt;&lt; piece.data() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li><code>muduo::StringPiece</code> 只是一个视图，它不拥有字符串的内存。因此，在使用 <code>muduo::StringPiece</code> 时，需要确保被引用的字符串的生命周期长于 <code>StringPiece</code> 的使用。</li>
<li><code>muduo::StringPiece</code> 不负责管理字符串的内存，因此不应该对其进行修改（例如增删字符），它只是用来读取字符串数据的。</li>
</ul>
<h1 id="日志滚动"><a href="#日志滚动" class="headerlink" title="日志滚动"></a>日志滚动</h1><p>日志滚动条件</p>
<ul>
<li>文件大小（例如每写满1G换下一个文件)</li>
<li>时间(每天零点新建一个日志文件，不论前一个文件是否写满）</li>
</ul>
<p>一个典型的日志文件名</p>
<ul>
<li>logfile_test.20130411-115604.popo.7743.log</li>
</ul>
<h2 id="LogFile-h"><a href="#LogFile-h" class="headerlink" title="LogFile.h"></a>LogFile.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_BASE_LOGFILE_H</span><br><span class="line">#define MUDUO_BASE_LOGFILE_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Mutex.h&quot;</span><br><span class="line">#include &quot;muduo/base/Types.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">namespace FileUtil</span><br><span class="line">&#123;</span><br><span class="line">class AppendFile;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LogFile : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  LogFile(const string&amp; basename,</span><br><span class="line">          off_t rollSize,</span><br><span class="line">          bool threadSafe = true,</span><br><span class="line">          int flushInterval = 3,</span><br><span class="line">          int checkEveryN = 1024);</span><br><span class="line">  ~LogFile();</span><br><span class="line"></span><br><span class="line">  void append(const char* logline, int len);//添加到日志文件</span><br><span class="line">  void flush();//清空缓冲区</span><br><span class="line">  bool rollFile();//滚动日志</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  void append_unlocked(const char* logline, int len);//不加锁的方式添加</span><br><span class="line"></span><br><span class="line">  static string getLogFileName(const string&amp; basename, time_t* now);</span><br><span class="line"></span><br><span class="line">  const string basename_;//日志文件 basename</span><br><span class="line">  const off_t rollSize_;//日志文件达到rollSize换一个新文件</span><br><span class="line">  const int flushInterval_;//日志写入间隔时间</span><br><span class="line">  const int checkEveryN_;</span><br><span class="line"></span><br><span class="line">  int count_;</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;MutexLock&gt; mutex_;//unique_ptr智能指针对象，不需要调用delete</span><br><span class="line">  time_t startOfPeriod_;//开始记录日志时间（调整至零点的时间）</span><br><span class="line">  time_t lastRoll_;//上一次滚动日志文件时间</span><br><span class="line">  time_t lastFlush_;//上一次日志写入文件时间</span><br><span class="line">  std::unique_ptr&lt;FileUtil::AppendFile&gt; file_;//这行代码声明了一个名为file_的std::unique_ptr，它将用于管理一个指向FileUtil::AppendFile类型对象的指针</span><br><span class="line"></span><br><span class="line">  const static int kRollPerSeconds_ = 60*60*24;//一天</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line">#endif  // MUDUO_BASE_LOGFILE_H</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="LogFile-cc"><a href="#LogFile-cc" class="headerlink" title="LogFile.cc"></a>LogFile.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/LogFile.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/FileUtil.h&quot;</span><br><span class="line">#include &quot;muduo/base/ProcessInfo.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">//可以实现多线程对同一个文件进行写入</span><br><span class="line">LogFile::LogFile(const string&amp; basename,</span><br><span class="line">                 off_t rollSize,</span><br><span class="line">                 bool threadSafe,</span><br><span class="line">                 int flushInterval,</span><br><span class="line">                 int checkEveryN)</span><br><span class="line">  : basename_(basename),</span><br><span class="line">    rollSize_(rollSize),</span><br><span class="line">    flushInterval_(flushInterval),</span><br><span class="line">    checkEveryN_(checkEveryN),</span><br><span class="line">    count_(0),</span><br><span class="line">    mutex_(threadSafe ? new MutexLock : NULL),//根据是否线程安全来初始化mutex</span><br><span class="line">    startOfPeriod_(0),</span><br><span class="line">    lastRoll_(0),</span><br><span class="line">    lastFlush_(0)</span><br><span class="line">&#123;</span><br><span class="line">  assert(basename.find(&#x27;/&#x27;) == string::npos);//断言basename不包含/</span><br><span class="line">  rollFile();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LogFile::~LogFile() = default;</span><br><span class="line"></span><br><span class="line">void LogFile::append(const char* logline, int len)</span><br><span class="line">&#123;</span><br><span class="line">  if (mutex_)</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(*mutex_);</span><br><span class="line">    append_unlocked(logline, len);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    append_unlocked(logline, len);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LogFile::flush()</span><br><span class="line">&#123;</span><br><span class="line">  if (mutex_)</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(*mutex_);</span><br><span class="line">    file_-&gt;flush();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    file_-&gt;flush();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LogFile::append_unlocked(const char* logline, int len)</span><br><span class="line">&#123;</span><br><span class="line">  file_-&gt;append(logline, len);</span><br><span class="line"></span><br><span class="line">  if (file_-&gt;writtenBytes() &gt; rollSize_)</span><br><span class="line">  &#123;</span><br><span class="line">    rollFile();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    ++count_;</span><br><span class="line">    if (count_ &gt;= checkEveryN_)</span><br><span class="line">    &#123;</span><br><span class="line">      count_ = 0;</span><br><span class="line">      time_t now = ::time(NULL);</span><br><span class="line">      time_t thisPeriod_ = now / kRollPerSeconds_ * kRollPerSeconds_;</span><br><span class="line">      if (thisPeriod_ != startOfPeriod_)</span><br><span class="line">      &#123;</span><br><span class="line">        rollFile();</span><br><span class="line">      &#125;</span><br><span class="line">      else if (now - lastFlush_ &gt; flushInterval_)</span><br><span class="line">      &#123;</span><br><span class="line">        lastFlush_ = now;</span><br><span class="line">        file_-&gt;flush();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool LogFile::rollFile()</span><br><span class="line">&#123;</span><br><span class="line">  time_t now = 0;</span><br><span class="line">  string filename = getLogFileName(basename_, &amp;now);//把当前时间返回回来</span><br><span class="line">  //对齐至kRollPerSeconds_的整数倍，也就是时间调整到当天零点</span><br><span class="line">  time_t start = now / kRollPerSeconds_ * kRollPerSeconds_;</span><br><span class="line"></span><br><span class="line">  if (now &gt; lastRoll_)</span><br><span class="line">  &#123;</span><br><span class="line">    lastRoll_ = now;</span><br><span class="line">    lastFlush_ = now;</span><br><span class="line">    startOfPeriod_ = start;</span><br><span class="line">    file_.reset(new FileUtil::AppendFile(filename));</span><br><span class="line">    //通过分配内存来初始化std::unique_ptr，并传递filename参数给FileUtil::AppendFile的构造函数</span><br><span class="line">    //当调用reset函数时，它会释放智能指针当前所持有的对象，并将指针指向一个新的对象或者置为nullptr。如果未提供参数，即不传递新对象指针给reset，则智能指针会释放当前持有的对象，并将其指向空指针（nullptr），相当于释放了内存</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string LogFile::getLogFileName(const string&amp; basename, time_t* now)</span><br><span class="line">&#123;</span><br><span class="line">  string filename;</span><br><span class="line">  filename.reserve(basename.size() + 64);</span><br><span class="line">  filename = basename;</span><br><span class="line"></span><br><span class="line">  char timebuf[32];</span><br><span class="line">  struct tm tm;</span><br><span class="line">  *now = time(NULL);//保存一下当前时间，距离1970.1.1零点的秒数</span><br><span class="line">  gmtime_r(now, &amp;tm); // FIXME: localtime_r ?GMT的时间，_r说明它是线程安全的，因为它还有一个相同的保存在tm中，不会被别的线程访问，如果改成localtime_r就不需要在当前时间加8</span><br><span class="line">  strftime(timebuf, sizeof timebuf, &quot;.%Y%m%d-%H%M%S.&quot;, &amp;tm);</span><br><span class="line">  filename += timebuf;</span><br><span class="line"></span><br><span class="line">  filename += ProcessInfo::hostname();</span><br><span class="line"></span><br><span class="line">  char pidbuf[32];</span><br><span class="line">  snprintf(pidbuf, sizeof pidbuf, &quot;.%d&quot;, ProcessInfo::pid());</span><br><span class="line">  filename += pidbuf;</span><br><span class="line"></span><br><span class="line">  filename += &quot;.log&quot;;</span><br><span class="line"></span><br><span class="line">  return filename;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Logging-test-cc"><a href="#Logging-test-cc" class="headerlink" title="Logging_test.cc"></a>Logging_test.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line">#include &quot;muduo/base/LogFile.h&quot;</span><br><span class="line">#include &quot;muduo/base/ThreadPool.h&quot;</span><br><span class="line">#include &quot;muduo/base/TimeZone.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int g_total;</span><br><span class="line">FILE* g_file;</span><br><span class="line">std::unique_ptr&lt;muduo::LogFile&gt; g_logFile;</span><br><span class="line"></span><br><span class="line">void dummyOutput(const char* msg, int len)</span><br><span class="line">&#123;</span><br><span class="line">  g_total += len;</span><br><span class="line">  if (g_file)</span><br><span class="line">  &#123;</span><br><span class="line">    fwrite(msg, 1, len, g_file);</span><br><span class="line">  &#125;</span><br><span class="line">  else if (g_logFile)</span><br><span class="line">  &#123;</span><br><span class="line">    g_logFile-&gt;append(msg, len);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bench(const char* type)</span><br><span class="line">&#123;</span><br><span class="line">  muduo::Logger::setOutput(dummyOutput);</span><br><span class="line">  muduo::Timestamp start(muduo::Timestamp::now());</span><br><span class="line">  g_total = 0;</span><br><span class="line"></span><br><span class="line">  int n = 1000*1000;</span><br><span class="line">  const bool kLongLog = false;</span><br><span class="line">  muduo::string empty = &quot; &quot;;</span><br><span class="line">  muduo::string longStr(3000, &#x27;X&#x27;);</span><br><span class="line">  longStr += &quot; &quot;;</span><br><span class="line">  for (int i = 0; i &lt; n; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_INFO &lt;&lt; &quot;Hello 0123456789&quot; &lt;&lt; &quot; abcdefghijklmnopqrstuvwxyz&quot;</span><br><span class="line">    //nop没有输出到标准输出和文件，因为上面的dummyOutput的g_file,g_logFile都是0</span><br><span class="line">             &lt;&lt; (kLongLog ? longStr : empty)</span><br><span class="line">             &lt;&lt; i;</span><br><span class="line">  &#125;</span><br><span class="line">  muduo::Timestamp end(muduo::Timestamp::now());</span><br><span class="line">  double seconds = timeDifference(end, start);</span><br><span class="line">  printf(&quot;%12s: %f seconds, %d bytes, %10.2f msg/s, %.2f MiB/s\n&quot;,</span><br><span class="line">         type, seconds, g_total, n / seconds, g_total / seconds / (1024 * 1024));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void logInThread()</span><br><span class="line">&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;logInThread&quot;;//线程池在记日志</span><br><span class="line">  usleep(1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  getppid(); // for ltrace and strace</span><br><span class="line"></span><br><span class="line">  muduo::ThreadPool pool(&quot;pool&quot;);//线程池名称</span><br><span class="line">  pool.start(5);//启动5个线程</span><br><span class="line">  pool.run(logInThread);//下面5个都是在线程池当中运行的</span><br><span class="line">  pool.run(logInThread);</span><br><span class="line">  pool.run(logInThread);</span><br><span class="line">  pool.run(logInThread);</span><br><span class="line">  pool.run(logInThread);</span><br><span class="line"></span><br><span class="line">  LOG_TRACE &lt;&lt; &quot;trace&quot;;//主线程的输出</span><br><span class="line">  LOG_DEBUG &lt;&lt; &quot;debug&quot;;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;Hello&quot;;</span><br><span class="line">  LOG_WARN &lt;&lt; &quot;World&quot;;</span><br><span class="line">  LOG_ERROR &lt;&lt; &quot;Error&quot;;</span><br><span class="line">  LOG_INFO &lt;&lt; sizeof(muduo::Logger);</span><br><span class="line">  LOG_INFO &lt;&lt; sizeof(muduo::LogStream);</span><br><span class="line">  LOG_INFO &lt;&lt; sizeof(muduo::Fmt);</span><br><span class="line">  LOG_INFO &lt;&lt; sizeof(muduo::LogStream::Buffer);</span><br><span class="line">  //只要没有setOutput就是输出到标准输出</span><br><span class="line">  sleep(1);</span><br><span class="line">  bench(&quot;nop&quot;);//性能测试程序</span><br><span class="line"></span><br><span class="line">  char buffer[64*1024];</span><br><span class="line"></span><br><span class="line">  g_file = fopen(&quot;/dev/null&quot;, &quot;w&quot;);</span><br><span class="line">  setbuffer(g_file, buffer, sizeof buffer);</span><br><span class="line">  bench(&quot;/dev/null&quot;);//测试写入到/dev/null性能</span><br><span class="line">  fclose(g_file);</span><br><span class="line"></span><br><span class="line">  g_file = fopen(&quot;/tmp/log&quot;, &quot;w&quot;);</span><br><span class="line">  setbuffer(g_file, buffer, sizeof buffer);</span><br><span class="line">  bench(&quot;/tmp/log&quot;);</span><br><span class="line">  fclose(g_file);</span><br><span class="line"></span><br><span class="line">  g_file = NULL;</span><br><span class="line">  g_logFile.reset(new muduo::LogFile(&quot;test_log_st&quot;, 500*1000*1000, false));//false不是线程安全的</span><br><span class="line">  bench(&quot;test_log_st&quot;);</span><br><span class="line"></span><br><span class="line">  g_logFile.reset(new muduo::LogFile(&quot;test_log_mt&quot;, 500*1000*1000, true));</span><br><span class="line">  bench(&quot;test_log_mt&quot;);</span><br><span class="line">  g_logFile.reset();</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">  g_file = stdout;</span><br><span class="line">  sleep(1);</span><br><span class="line">  muduo::TimeZone beijing(8*3600, &quot;CST&quot;);</span><br><span class="line">  muduo::Logger::setTimeZone(beijing);</span><br><span class="line">  LOG_TRACE &lt;&lt; &quot;trace CST&quot;;//操作的是stream，重载了&lt;&lt;,按流的方式来操作日志</span><br><span class="line">  LOG_DEBUG &lt;&lt; &quot;debug CST&quot;;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;Hello CST&quot;;</span><br><span class="line">  LOG_WARN &lt;&lt; &quot;World CST&quot;;</span><br><span class="line">  LOG_ERROR &lt;&lt; &quot;Error CST&quot;;</span><br><span class="line"></span><br><span class="line">  sleep(1);</span><br><span class="line">  muduo::TimeZone newyork = muduo::TimeZone::loadZoneFile(&quot;/usr/share/zoneinfo/America/New_York&quot;);</span><br><span class="line">  muduo::Logger::setTimeZone(newyork);</span><br><span class="line">  LOG_TRACE &lt;&lt; &quot;trace NYT&quot;;</span><br><span class="line">  LOG_DEBUG &lt;&lt; &quot;debug NYT&quot;;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;Hello NYT&quot;;</span><br><span class="line">  LOG_WARN &lt;&lt; &quot;World NYT&quot;;</span><br><span class="line">  LOG_ERROR &lt;&lt; &quot;Error NYT&quot;;</span><br><span class="line">  g_file = NULL;</span><br><span class="line">  &#125;</span><br><span class="line">  bench(&quot;timezone nop&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%884%EF%BC%89/image-20230807161311439.png" alt="image-20230807161311439"></p>
<img src="/2023/08/04/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%884%EF%BC%89/image-20230807161311439.png" class title="This is an test image">

<h2 id="FileUtil类封装"><a href="#FileUtil类封装" class="headerlink" title="FileUtil类封装"></a>FileUtil类封装</h2><p>还有一个名为 <code>FileUtil</code> 的命名空间，它包含了两个类：<code>ReadSmallFile</code> 和 <code>AppendFile</code>，用于文件读取和文件追加写入操作。</p>
<ol>
<li><code>ReadSmallFile</code> 类：<ul>
<li>功能：用于读取小文件（小于 64KB）的内容。</li>
<li>成员变量：<ul>
<li><code>int fd_</code>：文件描述符，用于打开要读取的文件。</li>
<li><code>int err_</code>：存储错误码，表示读取过程中是否发生错误。</li>
<li><code>char buf_[kBufferSize]</code>：缓冲区，用于暂存读取的文件内容。</li>
</ul>
</li>
<li>成员函数：<ul>
<li>构造函数 <code>ReadSmallFile(StringArg filename)</code>：打开指定的文件，初始化文件描述符和错误码。</li>
<li>析构函数 <code>~ReadSmallFile()</code>：关闭文件。</li>
<li><code>int readToString(int maxSize, String* content, int64_t* fileSize, int64_t* modifyTime, int64_t* createTime)</code>：读取文件内容到指定的字符串对象中，并返回错误码。</li>
<li><code>int readToBuffer(int* size)</code>：将文件内容读取到缓冲区中，并返回错误码。</li>
</ul>
</li>
</ul>
</li>
<li><code>AppendFile</code> 类：<ul>
<li>功能：用于将内容追加写入文件。</li>
<li>成员变量：<ul>
<li><code>FILE* fp_</code>：文件指针，用于打开要写入的文件。</li>
<li><code>char buffer_[64*1024]</code>：缓冲区，用于暂存写入的内容。</li>
<li><code>off_t writtenBytes_</code>：记录已写入文件的字节数。</li>
</ul>
</li>
<li>成员函数：<ul>
<li>构造函数 <code>explicit AppendFile(StringArg filename)</code>：打开指定的文件，初始化文件指针和字节数。</li>
<li>析构函数 <code>~AppendFile()</code>：关闭文件。</li>
<li><code>void append(const char* logline, size_t len)</code>：将指定长度的内容追加写入文件。</li>
<li><code>void flush()</code>：将缓冲区内容写入文件，并清空缓冲区。</li>
<li><code>off_t writtenBytes() const</code>：返回已写入文件的字节数。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><code>FileUtil::readFile</code>函数模板：用于读取整个文件内容。它调用<code>FileUtil::ReadSmallFile</code>类中的<code>readToString</code>函数实现。</p>
<p>该文件操作类可用于进行文件读取和追加写入操作，并且对小文件进行了特别的处理以提高性能。需要注意的是，这些类在多线程环境下并不是线程安全的，因此在使用时需要注意并发访问的情况。但是但是logfile是线程安全的，所以在logfile用，也是安全的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/03/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%883%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/03/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%883%EF%BC%89/" class="post-title-link" itemprop="url">muduo-基础库（3）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-03 11:11:21" itemprop="dateCreated datePublished" datetime="2023-08-03T11:11:21+08:00">2023-08-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-07 10:34:02" itemprop="dateModified" datetime="2023-08-07T10:34:02+08:00">2023-08-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="线程安全Singleton类实现"><a href="#线程安全Singleton类实现" class="headerlink" title="线程安全Singleton类实现"></a>线程安全Singleton类实现</h1><ul>
<li><p>pthread_once </p>
</li>
<li><p>atexit</p>
</li>
<li><p>typedef char T_must_be_complete_type[sizeof(T)&#x3D;&#x3D;0? -1∶1];</p>
</li>
</ul>
<p>实现单例模式</p>
<h2 id="Singleton-h"><a href="#Singleton-h" class="headerlink" title="Singleton.h"></a>Singleton.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_BASE_SINGLETON_H</span><br><span class="line">#define MUDUO_BASE_SINGLETON_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/noncopyable.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt; // atexit</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">namespace detail</span><br><span class="line">&#123;</span><br><span class="line">// This doesn&#x27;t detect inherited member functions!</span><br><span class="line">// http://stackoverflow.com/questions/1966362/sfinae-to-check-for-inherited-member-functions</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct has_no_destroy</span><br><span class="line">&#123;</span><br><span class="line">  template &lt;typename C&gt; static char test(decltype(&amp;C::no_destroy));</span><br><span class="line">  template &lt;typename C&gt; static int32_t test(...);</span><br><span class="line">  const static bool value = sizeof(test&lt;T&gt;(0)) == 1;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  // namespace detail</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class Singleton : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  Singleton() = delete;</span><br><span class="line">  ~Singleton() = delete;</span><br><span class="line"></span><br><span class="line">  static T&amp; instance()</span><br><span class="line">  &#123;</span><br><span class="line">    pthread_once(&amp;ponce_, &amp;Singleton::init);//只创建一次value_ = new T();，同时保证线程安全</span><br><span class="line">    assert(value_ != NULL);</span><br><span class="line">    return *value_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  static void init()</span><br><span class="line">  &#123;</span><br><span class="line">    value_ = new T();</span><br><span class="line">    if (!detail::has_no_destroy&lt;T&gt;::value)</span><br><span class="line">    &#123;</span><br><span class="line">      ::atexit(destroy);//用于在程序退出时注册一个函数，该函数将在程序退出之前被调用</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static void destroy()</span><br><span class="line">  &#123;</span><br><span class="line">    typedef char T_must_be_complete_type[sizeof(T) == 0 ? -1 : 1];</span><br><span class="line">    //检查类型T是否完整。如果T是一个不完整的类型（比如只有前向声明而没有定义），那么这个typedef将会导致编译错误</span><br><span class="line">    //具体做法是，通过sizeof(T)来检查T的大小，如果T是一个不完整类型，则其大小为0，条件表达式结果为-1，否则为1。这样，如果T是不完整类型，就会尝试定义一个大小为-1的数组，从而导致编译错误</span><br><span class="line">    T_must_be_complete_type dummy; (void) dummy;</span><br><span class="line">    //这里使用了一个无操作的转换，目的是消除未使用变量的编译器警告。dummy是之前定义的T_must_be_complete_type数组，由于它不会被实际使用，为了避免编译器警告，使用(void)进行转换</span><br><span class="line">    delete value_;</span><br><span class="line">    value_ = NULL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  static pthread_once_t ponce_;</span><br><span class="line">  static T*             value_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">pthread_once_t Singleton&lt;T&gt;::ponce_ = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">T* Singleton&lt;T&gt;::value_ = NULL;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_BASE_SINGLETON_H</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Singleton-test-cc"><a href="#Singleton-test-cc" class="headerlink" title="Singleton_test.cc"></a>Singleton_test.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/Singleton.h&quot;</span><br><span class="line">#include &quot;muduo/base/CurrentThread.h&quot;</span><br><span class="line">#include &quot;muduo/base/Thread.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">class Test : muduo::noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  Test()</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;tid=%d, constructing %p\n&quot;, muduo::CurrentThread::tid(), this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~Test()</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;tid=%d, destructing %p %s\n&quot;, muduo::CurrentThread::tid(), this, name_.c_str());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const muduo::string&amp; name() const &#123; return name_; &#125;</span><br><span class="line">  void setName(const muduo::string&amp; n) &#123; name_ = n; &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  muduo::string name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class TestNoDestroy : muduo::noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  // Tag member for Singleton&lt;T&gt;</span><br><span class="line">  void no_destroy();//用于标记不调用析构函数</span><br><span class="line"></span><br><span class="line">  TestNoDestroy()</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;tid=%d, constructing TestNoDestroy %p\n&quot;, muduo::CurrentThread::tid(), this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~TestNoDestroy()</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;tid=%d, destructing TestNoDestroy %p\n&quot;, muduo::CurrentThread::tid(), this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void threadFunc()</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;tid=%d, %p name=%s\n&quot;,</span><br><span class="line">         muduo::CurrentThread::tid(),</span><br><span class="line">         &amp;muduo::Singleton&lt;Test&gt;::instance(),</span><br><span class="line">         muduo::Singleton&lt;Test&gt;::instance().name().c_str());</span><br><span class="line">  muduo::Singleton&lt;Test&gt;::instance().setName(&quot;only one, changed&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  muduo::Singleton&lt;Test&gt;::instance().setName(&quot;only one&quot;);</span><br><span class="line">  muduo::Thread t1(threadFunc);</span><br><span class="line">  t1.start();</span><br><span class="line">  t1.join();</span><br><span class="line">  printf(&quot;tid=%d, %p name=%s\n&quot;,</span><br><span class="line">         muduo::CurrentThread::tid(),</span><br><span class="line">         &amp;muduo::Singleton&lt;Test&gt;::instance(),</span><br><span class="line">         muduo::Singleton&lt;Test&gt;::instance().name().c_str());</span><br><span class="line">  muduo::Singleton&lt;TestNoDestroy&gt;::instance();//在首次调用 instance() 函数时，init() 函数会被调用，并且在 init() 函数内部使用了 new T() 进行对象的动态内存分配，从而调用了 TestNoDestroy 的构造函数来创建对象</span><br><span class="line">  printf(&quot;with valgrind, you should see %zd-byte memory leak.\n&quot;, sizeof(TestNoDestroy));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%883%EF%BC%89/image-20230803161712078.png" alt="image-20230803161712078"></p>
<img src="/2023/08/03/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%883%EF%BC%89/image-20230803161712078.png" class title="This is an test image">

<p>子线程和主线程共有一个<code>muduo::Singleton&lt;Test&gt;::instance().name().c_str()</code></p>
<h1 id="线程本地存储ThreadLocal-lt-T-gt-封装"><a href="#线程本地存储ThreadLocal-lt-T-gt-封装" class="headerlink" title="线程本地存储ThreadLocal&lt;T&gt;封装"></a>线程本地存储<code>ThreadLocal&lt;T&gt;</code>封装</h1><h2 id="ThreadLocal-h"><a href="#ThreadLocal-h" class="headerlink" title="ThreadLocal.h"></a>ThreadLocal.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#ifndef MUDUO_BASE_THREADLOCAL_H</span><br><span class="line">#define MUDUO_BASE_THREADLOCAL_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Mutex.h&quot;</span><br><span class="line">#include &quot;muduo/base/noncopyable.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class ThreadLocal : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  ThreadLocal()</span><br><span class="line">  &#123;</span><br><span class="line">    MCHECK(pthread_key_create(&amp;pkey_, &amp;ThreadLocal::destructor));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~ThreadLocal()</span><br><span class="line">  &#123;</span><br><span class="line">    MCHECK(pthread_key_delete(pkey_));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T&amp; value()//设置并返回perThreadValue</span><br><span class="line">  &#123;</span><br><span class="line">    T* perThreadValue = static_cast&lt;T*&gt;(pthread_getspecific(pkey_));</span><br><span class="line">    if (!perThreadValue)</span><br><span class="line">    &#123;</span><br><span class="line">      T* newObj = new T();</span><br><span class="line">      MCHECK(pthread_setspecific(pkey_, newObj));</span><br><span class="line">      perThreadValue = newObj;</span><br><span class="line">    &#125;</span><br><span class="line">    return *perThreadValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line"></span><br><span class="line">  static void destructor(void *x)</span><br><span class="line">  &#123;</span><br><span class="line">    T* obj = static_cast&lt;T*&gt;(x);</span><br><span class="line">    typedef char T_must_be_complete_type[sizeof(T) == 0 ? -1 : 1];</span><br><span class="line">    T_must_be_complete_type dummy; (void) dummy;</span><br><span class="line">    delete obj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  pthread_key_t pkey_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_BASE_THREADLOCAL_H</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="ThreadLocal-test-cc"><a href="#ThreadLocal-test-cc" class="headerlink" title="ThreadLocal_test.cc"></a>ThreadLocal_test.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/ThreadLocal.h&quot;</span><br><span class="line">#include &quot;muduo/base/CurrentThread.h&quot;</span><br><span class="line">#include &quot;muduo/base/Thread.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">class Test : muduo::noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  Test()</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;tid=%d, constructing %p\n&quot;, muduo::CurrentThread::tid(), this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~Test()</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;tid=%d, destructing %p %s\n&quot;, muduo::CurrentThread::tid(), this, name_.c_str());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const muduo::string&amp; name() const &#123; return name_; &#125;</span><br><span class="line">  void setName(const muduo::string&amp; n) &#123; name_ = n; &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  muduo::string name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">muduo::ThreadLocal&lt;Test&gt; testObj1;//每个线程都有，但是因为testObj1.value().setName(&quot;main one&quot;)，会使公有的变私有</span><br><span class="line">muduo::ThreadLocal&lt;Test&gt; testObj2;</span><br><span class="line"></span><br><span class="line">void print()</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;tid=%d, obj1 %p name=%s\n&quot;,</span><br><span class="line">         muduo::CurrentThread::tid(),</span><br><span class="line">         &amp;testObj1.value(),</span><br><span class="line">         testObj1.value().name().c_str());</span><br><span class="line">  printf(&quot;tid=%d, obj2 %p name=%s\n&quot;,</span><br><span class="line">         muduo::CurrentThread::tid(),</span><br><span class="line">         &amp;testObj2.value(),</span><br><span class="line">         testObj2.value().name().c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void threadFunc()//线程特定数据销毁，是利用static void destructor(void *x)</span><br><span class="line">&#123;</span><br><span class="line">  print();</span><br><span class="line">  testObj1.value().setName(&quot;changed 1&quot;);</span><br><span class="line">  testObj2.value().setName(&quot;changed 42&quot;);</span><br><span class="line">  print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  testObj1.value().setName(&quot;main one&quot;);//testObj1.value()返回的是muduo::ThreadLocal&lt;Test&gt; testObj1;创建时传入的Test对象</span><br><span class="line">  print();</span><br><span class="line">  muduo::Thread t1(threadFunc);</span><br><span class="line">  t1.start();</span><br><span class="line">  t1.join();</span><br><span class="line">  testObj2.value().setName(&quot;main two&quot;);</span><br><span class="line">  print();</span><br><span class="line"></span><br><span class="line">  pthread_exit(0);//退出当前线程，主线程</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%883%EF%BC%89/image-20230804111803394.png" alt="image-20230804111803394"></p>
<img src="/2023/08/03/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%883%EF%BC%89/image-20230804111803394.png" class title="This is an test image">

<h2 id="SingletonThreadLocal-test-cc"><a href="#SingletonThreadLocal-test-cc" class="headerlink" title="SingletonThreadLocal_test.cc"></a>SingletonThreadLocal_test.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/Singleton.h&quot;</span><br><span class="line">#include &quot;muduo/base/CurrentThread.h&quot;</span><br><span class="line">#include &quot;muduo/base/ThreadLocal.h&quot;</span><br><span class="line">#include &quot;muduo/base/Thread.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">class Test : muduo::noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  Test()</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;tid=%d, constructing %p\n&quot;, muduo::CurrentThread::tid(), this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~Test()</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;tid=%d, destructing %p %s\n&quot;, muduo::CurrentThread::tid(), this, name_.c_str());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const muduo::string&amp; name() const &#123; return name_; &#125;</span><br><span class="line">  void setName(const muduo::string&amp; n) &#123; name_ = n; &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  muduo::string name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define STL muduo::Singleton&lt;muduo::ThreadLocal&lt;Test&gt; &gt;::instance().value()</span><br><span class="line">//只是说muduo::ThreadLocal&lt;Test&gt;是单例的而不是Test，也就是每个value是不同的</span><br><span class="line">//即不同线程设置的value不同，读出的STL.name().c_str()是不一样的</span><br><span class="line">void print()</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;tid=%d, %p name=%s\n&quot;,</span><br><span class="line">         muduo::CurrentThread::tid(),</span><br><span class="line">         &amp;STL,</span><br><span class="line">         STL.name().c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void threadFunc(const char* changeTo)</span><br><span class="line">&#123;</span><br><span class="line">  print();</span><br><span class="line">  STL.setName(changeTo);</span><br><span class="line">  sleep(1);</span><br><span class="line">  print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  STL.setName(&quot;main one&quot;);</span><br><span class="line">  muduo::Thread t1(std::bind(threadFunc, &quot;thread1&quot;));</span><br><span class="line">  muduo::Thread t2(std::bind(threadFunc, &quot;thread2&quot;));</span><br><span class="line">  t1.start();</span><br><span class="line">  t2.start();</span><br><span class="line">  t1.join();</span><br><span class="line">  print();</span><br><span class="line">  t2.join();</span><br><span class="line">  pthread_exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%883%EF%BC%89/image-20230804111917446.png" alt="image-20230804111917446"></p>
<img src="/2023/08/03/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%883%EF%BC%89/image-20230804111917446.png" class title="This is an test image">

<p>这个例子只是说明<code>muduo::Singleton&lt;muduo::ThreadLocal&lt;Test&gt; &gt;::instance()</code>是单例对象，每个线程访问的都是同一个instance，通过单例模式可以把它当作全局变量，但是每个线程的value都不一样</p>
<h1 id="ThreadLocalSingleton-lt-T-gt-线程本地单例类封装"><a href="#ThreadLocalSingleton-lt-T-gt-线程本地单例类封装" class="headerlink" title="ThreadLocalSingleton&lt;T&gt;线程本地单例类封装"></a><code>ThreadLocalSingleton&lt;T&gt;</code>线程本地单例类封装</h1><p>线程本地存储机制：POD：__thread，TSD:定义的其它类</p>
<h2 id="ThreadLocalSingleton-h"><a href="#ThreadLocalSingleton-h" class="headerlink" title="ThreadLocalSingleton.h"></a>ThreadLocalSingleton.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#ifndef MUDUO_BASE_THREADLOCALSINGLETON_H</span><br><span class="line">#define MUDUO_BASE_THREADLOCALSINGLETON_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/noncopyable.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class ThreadLocalSingleton : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  ThreadLocalSingleton() = delete;</span><br><span class="line">  ~ThreadLocalSingleton() = delete;</span><br><span class="line"></span><br><span class="line">  static T&amp; instance()</span><br><span class="line">  &#123;</span><br><span class="line">    if (!t_value_)//因为都有，私有的所以不需要按照线程安全的方式来实现</span><br><span class="line">    &#123;</span><br><span class="line">      t_value_ = new T();</span><br><span class="line">      deleter_.set(t_value_);</span><br><span class="line">    &#125;</span><br><span class="line">    return *t_value_;//返回的是指针</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static T* pointer()</span><br><span class="line">  &#123;</span><br><span class="line">    return t_value_;//返回的是引用</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  static void destructor(void* obj)</span><br><span class="line">  &#123;</span><br><span class="line">    assert(obj == t_value_);</span><br><span class="line">    typedef char T_must_be_complete_type[sizeof(T) == 0 ? -1 : 1];</span><br><span class="line">    T_must_be_complete_type dummy; (void) dummy;</span><br><span class="line">    delete t_value_;</span><br><span class="line">    t_value_ = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Deleter//POSIX线程库的特定数据TSD实现的</span><br><span class="line">  &#123;</span><br><span class="line">   public:</span><br><span class="line">    Deleter()</span><br><span class="line">    &#123;</span><br><span class="line">      pthread_key_create(&amp;pkey_, &amp;ThreadLocalSingleton::destructor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Deleter()</span><br><span class="line">    &#123;</span><br><span class="line">      pthread_key_delete(pkey_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void set(T* newObj)</span><br><span class="line">    &#123;</span><br><span class="line">      assert(pthread_getspecific(pkey_) == NULL);</span><br><span class="line">      pthread_setspecific(pkey_, newObj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_key_t pkey_;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  static __thread T* t_value_;//表示每个线程都有,T*是POD类型</span><br><span class="line">  static Deleter deleter_;//是为了可以自动释放，和把指针设置进来</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">__thread T* ThreadLocalSingleton&lt;T&gt;::t_value_ = 0;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">typename ThreadLocalSingleton&lt;T&gt;::Deleter ThreadLocalSingleton&lt;T&gt;::deleter_;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line">#endif  // MUDUO_BASE_THREADLOCALSINGLETON_H</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="ThreadLocalSingleton-test-cc"><a href="#ThreadLocalSingleton-test-cc" class="headerlink" title="ThreadLocalSingleton_test.cc"></a>ThreadLocalSingleton_test.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/ThreadLocalSingleton.h&quot;</span><br><span class="line">#include &quot;muduo/base/CurrentThread.h&quot;</span><br><span class="line">#include &quot;muduo/base/Thread.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">class Test : muduo::noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  Test()</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;tid=%d, constructing %p\n&quot;, muduo::CurrentThread::tid(), this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~Test()</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;tid=%d, destructing %p %s\n&quot;, muduo::CurrentThread::tid(), this, name_.c_str());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const muduo::string&amp; name() const &#123; return name_; &#125;</span><br><span class="line">  void setName(const muduo::string&amp; n) &#123; name_ = n; &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  muduo::string name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void threadFunc(const char* changeTo)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;tid=%d, %p name=%s\n&quot;,</span><br><span class="line">         muduo::CurrentThread::tid(),</span><br><span class="line">         &amp;muduo::ThreadLocalSingleton&lt;Test&gt;::instance(),</span><br><span class="line">         muduo::ThreadLocalSingleton&lt;Test&gt;::instance().name().c_str());//间接调用了test构造函数</span><br><span class="line">  muduo::ThreadLocalSingleton&lt;Test&gt;::instance().setName(changeTo);</span><br><span class="line">  printf(&quot;tid=%d, %p name=%s\n&quot;,</span><br><span class="line">         muduo::CurrentThread::tid(),</span><br><span class="line">         &amp;muduo::ThreadLocalSingleton&lt;Test&gt;::instance(),</span><br><span class="line">         muduo::ThreadLocalSingleton&lt;Test&gt;::instance().name().c_str());</span><br><span class="line"></span><br><span class="line">  // no need to manually delete it</span><br><span class="line">  // muduo::ThreadLocalSingleton&lt;Test&gt;::destroy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  muduo::ThreadLocalSingleton&lt;Test&gt;::instance().setName(&quot;main one&quot;);</span><br><span class="line">  //因为有__thread，线程本地存储的原因，所以每个线程都有构造函数这一步骤</span><br><span class="line">  muduo::Thread t1(std::bind(threadFunc, &quot;thread1&quot;));</span><br><span class="line">  muduo::Thread t2(std::bind(threadFunc, &quot;thread2&quot;));</span><br><span class="line">  t1.start();</span><br><span class="line">  t2.start();</span><br><span class="line">  t1.join();</span><br><span class="line">  printf(&quot;tid=%d, %p name=%s\n&quot;,</span><br><span class="line">         muduo::CurrentThread::tid(),</span><br><span class="line">         &amp;muduo::ThreadLocalSingleton&lt;Test&gt;::instance(),</span><br><span class="line">         muduo::ThreadLocalSingleton&lt;Test&gt;::instance().name().c_str());</span><br><span class="line">  t2.join();</span><br><span class="line"></span><br><span class="line">  pthread_exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%883%EF%BC%89/image-20230804121019493.png" alt="image-20230804121019493"></p>
<img src="/2023/08/03/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%883%EF%BC%89/image-20230804121019493.png" class title="This is an test image">

<p><code>__thread</code> 关键字在 C++ 中用于声明线程局部变量。当你使用 <code>__thread</code> 来声明一个用户自定义类的变量时，意味着每个线程将有自己独立的该变量实例，并且在一个线程中对该变量所做的更改不会影响其他线程中该变量的值。</p>
<p>在提供的代码中，<code>__thread</code> 用于在 <code>ThreadLocalSingleton</code> 类中声明 <code>t_value_</code> 变量。这使得 <code>t_value_</code> 成为一个类型为 <code>T*</code> 的线程局部变量（指向用户定义的类 <code>T</code> 的指针）。当你调用 <code>muduo::ThreadLocalSingleton&lt;Test&gt;::instance()</code> 时，它返回与调用线程关联的 <code>Test</code> 类的线程局部实例的引用。</p>
<p>请注意，当使用 <code>__thread</code> 来声明线程局部变量时，必须在类声明之外的地方单独提供变量的定义（通常在源文件中）。这就是你看到以下定义的原因：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cpp复制代码template&lt;typename T&gt;</span><br><span class="line">__thread T* ThreadLocalSingleton&lt;T&gt;::t_value_ = 0;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">typename ThreadLocalSingleton&lt;T&gt;::Deleter ThreadLocalSingleton&lt;T&gt;::deleter_;</span><br></pre></td></tr></table></figure>

<p>这些定义确保每个线程拥有自己独立的 <code>t_value_</code> 和 <code>deleter_</code> 实例。<code>ThreadLocalSingleton</code> 类使用这些线程局部变量来在每个线程上管理用户定义类 <code>T</code> 的实例。这使得 <code>ThreadLocalSingleton</code> 类能够为每个线程提供一个独立的单例模式。</p>
<p>在 C++03 标准中，<code>__thread</code> 确实只能用于修饰 POD（Plain Old Data）类型，也就是简单的标量类型或者是包含简单标量类型的结构体，而不包含任何自定义构造函数、析构函数、虚函数、或者是含有虚函数的基类。</p>
<p>然而，在 C++11 标准中，<code>__thread</code> 被 <code>thread_local</code> 关键字所取代，并且 <code>thread_local</code> 关键字没有限制只能修饰 POD 类型，它可以用于修饰任何类型，包括用户自定义的类对象。</p>
<p>需要注意的是，在 C++11 之后，应尽量使用 <code>thread_local</code> 关键字来声明线程局部变量，以取代过时的 <code>__thread</code> 关键字，因为 <code>thread_local</code> 更加标准化和跨平台，同时还支持更多类型的线程局部存储。</p>
<p> <code>__thread</code> 关键字在很多编译器中与 <code>thread_local</code> 关键字具有相同的特性。虽然 <code>__thread</code> 关键字是过时的写法，但在很多编译器中仍然可以使用，并且通常与 <code>thread_local</code> 关键字功能相同。</p>
<p>这两个关键字的共同特性是都用于声明线程局部变量 (TLS)，使得每个线程都拥有自己独立的变量副本。每个线程都会维护一个独立的变量，而不会互相干扰。</p>
<p>然而，值得注意的是，虽然在很多情况下 <code>__thread</code> 和 <code>thread_local</code> 可以互换使用，但在某些编译器和特定的情况下可能会有细微的差异。为了确保最佳的可移植性和标准兼容性，推荐使用 <code>thread_local</code> 关键字，因为它是C++11标准中正式定义的线程局部存储方案，具有更好的支持和更广泛的应用。</p>
<hr>
<p>POSIX线程库中的线程特定数据（Thread-Specific Data，TSD）是一种机制，它允许程序员在多线程环境中为每个线程存储独立的数据。这样，每个线程都可以拥有自己的独立数据副本，而不会互相干扰。</p>
<p>在POSIX线程库中，TSD可以通过以下两个函数来实现：</p>
<ol>
<li><code>pthread_key_create</code>: 用于创建一个TSD键，该键在所有线程中具有唯一标识符。当一个线程创建一个TSD键后，其他线程可以通过该键来访问其独立的数据。</li>
<li><code>pthread_setspecific</code>: 用于将一个特定值与TSD键关联，这样当前线程就拥有了该键对应的独立数据。</li>
</ol>
<p>每个线程可以通过调用 <code>pthread_getspecific</code> 函数来获取与TSD键关联的数据，这样就可以实现线程局部存储 (TLS)。当线程退出时，与其相关联的TSD数据会被自动清理和释放，避免了内存泄漏。</p>
<p>POSIX线程库的TSD机制为多线程编程提供了一种简单且有效的方式来管理线程本地存储，从而在不同线程之间实现数据隔离。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/01/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%882%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/01/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%882%EF%BC%89/" class="post-title-link" itemprop="url">muduo-基础库（2）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-01 15:52:49" itemprop="dateCreated datePublished" datetime="2023-08-01T15:52:49+08:00">2023-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-29 11:14:54" itemprop="dateModified" datetime="2023-08-29T11:14:54+08:00">2023-08-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="线程封装Thread"><a href="#线程封装Thread" class="headerlink" title="线程封装Thread"></a>线程封装Thread</h1><p><code>__thread</code>，gcc内置的线程局部存储设施,定义之后表示每个线程都有的</p>
<ul>
<li><code>__thread</code>只能修饰POD类型</li>
<li>POD类型（plain old data），与C兼容的原始数据,例如，结构和整型等C语言中的类型是POD类型，但带有用户定义的构造函数或虚函数的类则不是.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void afterFork()//fork可能是在主线程中调用，也可能是在子线程中调用</span><br><span class="line">				//fork得到一个新进程，新进程只有一个执行序列，只有一个线程（调用fork的线程被继承下来)</span><br><span class="line">&#123;</span><br><span class="line">  muduo::CurrentThread::t_cachedTid = 0;</span><br><span class="line">  muduo::CurrentThread::t_threadName = &quot;main&quot;;</span><br><span class="line">  CurrentThread::tid();</span><br><span class="line">  // no need to call pthread_atfork(NULL, NULL, &amp;afterFork);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ThreadNameInitializer</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  ThreadNameInitializer()</span><br><span class="line">  &#123;</span><br><span class="line">    muduo::CurrentThread::t_threadName = &quot;main&quot;;</span><br><span class="line">    CurrentThread::tid();</span><br><span class="line">    pthread_atfork(NULL, NULL, &amp;afterFork);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ThreadNameInitializer init;//相当于全局变量，一开始就构造了</span><br></pre></td></tr></table></figure>

<p><code>pthread_atfork</code> 是一个 POSIX 线程库中的函数，用于注册在 <code>fork</code> 调用之前和之后执行的回调函数，以便在创建子进程时进行资源管理和同步操作。</p>
<p>该函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void));</span><br></pre></td></tr></table></figure>

<ul>
<li><code>prepare</code>: 当调用 <code>fork</code> 准备复制父进程之前，会调用此函数指定的回调函数。在此回调函数中，可以释放或重新初始化某些资源，以确保子进程继承了预期状态。该回调函数在父进程中执行。</li>
<li><code>parent</code>: 在成功创建子进程后，会在父进程中调用此函数指定的回调函数。在此回调函数中，可以恢复资源状态或重新初始化需要在父进程中使用的资源。</li>
<li><code>child</code>: 在成功创建子进程后，会在子进程中调用此函数指定的回调函数。在此回调函数中，可以重新初始化需要在子进程中使用的资源。</li>
</ul>
<p><code>pthread_atfork</code> 的使用场景通常涉及到多线程程序中调用 <code>fork</code> 创建新进程时，因为 <code>fork</code> 会复制当前进程的所有线程和资源，可能导致一些资源和同步问题。通过注册 <code>pthread_atfork</code> 提供的回调函数，我们可以在 <code>fork</code> 前后进行一些资源管理和同步操作，以确保子进程的创建过程是可控的。</p>
<p>需要注意的是，使用 <code>fork</code> 和 <code>pthread_atfork</code> 需要非常小心，因为它涉及到多线程和多进程的复杂情况。在使用之前，确保你充分理解了相关的潜在问题和风险，并进行必要的测试和验证。另外，如果可能，尽量避免在多线程程序中使用 <code>fork</code>，以减少潜在的问题和调试难度。</p>
<p>父进程在创建了一个线程，在doit并对mutex加锁,<br>父进程创建一个子进程，在子进程中调用doit，由于子进程会复制父进程的内存，这时候mutex处于锁的状态，父进程在复制子进程的时候，只会复制当前线程的执行状态,其它线程不会复制。因此子进程会处于死锁的状态。相当于在不知道加锁的情况下又加锁</p>
<p>CurrentThread</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// internal,__thread修饰的变量是线程局部存储的。也就是私有的线程内的全局变量。</span><br><span class="line"> extern __thread int t_cachedTid;//线程真实pid（tid）的缓存，是为了提高获取tid的效率，减少系统调用的次数::syscall(SYS_gettid)</span><br><span class="line"> extern __thread char t_tidString[32];//tid字符串的表现形式</span><br><span class="line"> extern __thread int t_tidStringLength;</span><br><span class="line"> extern __thread const char* t_threadName;//每个线程的名称</span><br></pre></td></tr></table></figure>

<h2 id="Thread-h"><a href="#Thread-h" class="headerlink" title="Thread.h"></a>Thread.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_BASE_THREAD_H</span><br><span class="line">#define MUDUO_BASE_THREAD_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Atomic.h&quot;</span><br><span class="line">#include &quot;muduo/base/CountDownLatch.h&quot;</span><br><span class="line">#include &quot;muduo/base/Types.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">class Thread : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  typedef std::function&lt;void ()&gt; ThreadFunc;</span><br><span class="line"></span><br><span class="line">  explicit Thread(ThreadFunc, const string&amp; name = string());</span><br><span class="line">  // FIXME: make it movable in C++11</span><br><span class="line">  ~Thread();</span><br><span class="line"></span><br><span class="line">  void start();</span><br><span class="line">  int join(); // return pthread_join()</span><br><span class="line"></span><br><span class="line">  bool started() const &#123; return started_; &#125;</span><br><span class="line">  // pthread_t pthreadId() const &#123; return pthreadId_; &#125;</span><br><span class="line">  pid_t tid() const &#123; return tid_; &#125;</span><br><span class="line">  const string&amp; name() const &#123; return name_; &#125;</span><br><span class="line"></span><br><span class="line">  static int numCreated() &#123; return numCreated_.get(); &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  void setDefaultName();</span><br><span class="line"></span><br><span class="line">  bool       started_;</span><br><span class="line">  bool       joined_;</span><br><span class="line">  pthread_t  pthreadId_;</span><br><span class="line">  pid_t      tid_;</span><br><span class="line">  ThreadFunc func_;</span><br><span class="line">  string     name_;</span><br><span class="line">  CountDownLatch latch_;</span><br><span class="line"></span><br><span class="line">  static AtomicInt32 numCreated_;//private 成员只能在类的成员函数（包括静态成员函数）内部访问，不能在类外部直接访问。</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line">#endif  // MUDUO_BASE_THREAD_H</span><br></pre></td></tr></table></figure>

<h2 id="Thread-cc"><a href="#Thread-cc" class="headerlink" title="Thread.cc"></a>Thread.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/Thread.h&quot;</span><br><span class="line">#include &quot;muduo/base/CurrentThread.h&quot;</span><br><span class="line">#include &quot;muduo/base/Exception.h&quot;</span><br><span class="line">//#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;type_traits&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/prctl.h&gt;</span><br><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;linux/unistd.h&gt;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace detail</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">pid_t gettid()</span><br><span class="line">&#123;</span><br><span class="line">  return static_cast&lt;pid_t&gt;(::syscall(SYS_gettid));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void afterFork()</span><br><span class="line">&#123;</span><br><span class="line">  muduo::CurrentThread::t_cachedTid = 0;</span><br><span class="line">  muduo::CurrentThread::t_threadName = &quot;main&quot;;</span><br><span class="line">  CurrentThread::tid();</span><br><span class="line">  // no need to call pthread_atfork(NULL, NULL, &amp;afterFork);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ThreadNameInitializer</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  ThreadNameInitializer()</span><br><span class="line">  &#123;</span><br><span class="line">    muduo::CurrentThread::t_threadName = &quot;main&quot;;</span><br><span class="line">    CurrentThread::tid();</span><br><span class="line">    pthread_atfork(NULL, NULL, &amp;afterFork);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ThreadNameInitializer init;</span><br><span class="line"></span><br><span class="line">struct ThreadData</span><br><span class="line">&#123;</span><br><span class="line">  typedef muduo::Thread::ThreadFunc ThreadFunc;</span><br><span class="line">  ThreadFunc func_;</span><br><span class="line">  string name_;</span><br><span class="line">  pid_t* tid_;</span><br><span class="line">  CountDownLatch* latch_;</span><br><span class="line"></span><br><span class="line">  ThreadData(ThreadFunc func,</span><br><span class="line">             const string&amp; name,</span><br><span class="line">             pid_t* tid,</span><br><span class="line">             CountDownLatch* latch)</span><br><span class="line">    : func_(std::move(func)),</span><br><span class="line">      name_(name),</span><br><span class="line">      tid_(tid),</span><br><span class="line">      latch_(latch)</span><br><span class="line">  &#123; &#125;</span><br><span class="line"></span><br><span class="line">  void runInThread()</span><br><span class="line">  &#123;</span><br><span class="line">    *tid_ = muduo::CurrentThread::tid();</span><br><span class="line">    tid_ = NULL;</span><br><span class="line">    latch_-&gt;countDown();</span><br><span class="line">    latch_ = NULL;</span><br><span class="line"></span><br><span class="line">    muduo::CurrentThread::t_threadName = name_.empty() ? &quot;muduoThread&quot; : name_.c_str();</span><br><span class="line">    ::prctl(PR_SET_NAME, muduo::CurrentThread::t_threadName);</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      func_();</span><br><span class="line">      muduo::CurrentThread::t_threadName = &quot;finished&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (const Exception&amp; ex)</span><br><span class="line">    &#123;</span><br><span class="line">      muduo::CurrentThread::t_threadName = &quot;crashed&quot;;</span><br><span class="line">      fprintf(stderr, &quot;exception caught in Thread %s\n&quot;, name_.c_str());</span><br><span class="line">      fprintf(stderr, &quot;reason: %s\n&quot;, ex.what());</span><br><span class="line">      fprintf(stderr, &quot;stack trace: %s\n&quot;, ex.stackTrace());</span><br><span class="line">      abort();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (const std::exception&amp; ex)</span><br><span class="line">    &#123;</span><br><span class="line">      muduo::CurrentThread::t_threadName = &quot;crashed&quot;;</span><br><span class="line">      fprintf(stderr, &quot;exception caught in Thread %s\n&quot;, name_.c_str());</span><br><span class="line">      fprintf(stderr, &quot;reason: %s\n&quot;, ex.what());</span><br><span class="line">      abort();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (...)</span><br><span class="line">    &#123;</span><br><span class="line">      muduo::CurrentThread::t_threadName = &quot;crashed&quot;;</span><br><span class="line">      fprintf(stderr, &quot;unknown exception caught in Thread %s\n&quot;, name_.c_str());</span><br><span class="line">      throw; // rethrow</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void* startThread(void* obj)</span><br><span class="line">&#123;</span><br><span class="line">  ThreadData* data = static_cast&lt;ThreadData*&gt;(obj);</span><br><span class="line">  data-&gt;runInThread();</span><br><span class="line">  delete data;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace detail</span><br><span class="line"></span><br><span class="line">void CurrentThread::cacheTid()</span><br><span class="line">&#123;</span><br><span class="line">  if (t_cachedTid == 0)</span><br><span class="line">  &#123;</span><br><span class="line">    t_cachedTid = detail::gettid();</span><br><span class="line">    t_tidStringLength = snprintf(t_tidString, sizeof t_tidString, &quot;%5d &quot;, t_cachedTid);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool CurrentThread::isMainThread()</span><br><span class="line">&#123;</span><br><span class="line">  return tid() == ::getpid();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CurrentThread::sleepUsec(int64_t usec)</span><br><span class="line">&#123;</span><br><span class="line">  struct timespec ts = &#123; 0, 0 &#125;;</span><br><span class="line">  ts.tv_sec = static_cast&lt;time_t&gt;(usec / Timestamp::kMicroSecondsPerSecond);</span><br><span class="line">  ts.tv_nsec = static_cast&lt;long&gt;(usec % Timestamp::kMicroSecondsPerSecond * 1000);</span><br><span class="line">  ::nanosleep(&amp;ts, NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AtomicInt32 Thread::numCreated_;</span><br><span class="line"></span><br><span class="line">Thread::Thread(ThreadFunc func, const string&amp; n)</span><br><span class="line">  : started_(false),</span><br><span class="line">    joined_(false),</span><br><span class="line">    pthreadId_(0),</span><br><span class="line">    tid_(0),</span><br><span class="line">    func_(std::move(func)),</span><br><span class="line">    name_(n),</span><br><span class="line">    latch_(1)</span><br><span class="line">&#123;</span><br><span class="line">  setDefaultName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread::~Thread()</span><br><span class="line">&#123;</span><br><span class="line">  if (started_ &amp;&amp; !joined_)</span><br><span class="line">  &#123;</span><br><span class="line">    pthread_detach(pthreadId_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Thread::setDefaultName()</span><br><span class="line">&#123;</span><br><span class="line">  int num = numCreated_.incrementAndGet();//使用原子类型确保了多线程环境下对 numCreated_ 的增加操作是安全的，不会出现竞态条件。因此，无论多少个线程同时创建 Thread 对象，都能保证 numCreated_ 的计数正确并且线程安全。</span><br><span class="line">  if (name_.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    char buf[32];</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;Thread%d&quot;, num);</span><br><span class="line">    name_ = buf;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Thread::start()</span><br><span class="line">&#123;</span><br><span class="line">  assert(!started_);</span><br><span class="line">  started_ = true;</span><br><span class="line">  // FIXME: move(func_)</span><br><span class="line">  detail::ThreadData* data = new detail::ThreadData(func_, name_, &amp;tid_, &amp;latch_);</span><br><span class="line">  if (pthread_create(&amp;pthreadId_, NULL, &amp;detail::startThread, data))</span><br><span class="line">  &#123;</span><br><span class="line">    started_ = false;</span><br><span class="line">    delete data; // or no delete?</span><br><span class="line">    LOG_SYSFATAL &lt;&lt; &quot;Failed in pthread_create&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    latch_.wait();</span><br><span class="line">    assert(tid_ &gt; 0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Thread::join()</span><br><span class="line">&#123;</span><br><span class="line">  assert(started_);</span><br><span class="line">  assert(!joined_);</span><br><span class="line">  joined_ = true;</span><br><span class="line">  return pthread_join(pthreadId_, NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br></pre></td></tr></table></figure>

<h2 id="CurrentThread-h"><a href="#CurrentThread-h" class="headerlink" title="CurrentThread.h"></a>CurrentThread.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_BASE_CURRENTTHREAD_H</span><br><span class="line">#define MUDUO_BASE_CURRENTTHREAD_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Types.h&quot;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace CurrentThread</span><br><span class="line">&#123;</span><br><span class="line">  // internal,__thread修饰的变量是线程局部存储的。也就是私有的线程内的全局变量。</span><br><span class="line">  extern __thread int t_cachedTid;//线程真实pid（tid）的缓存，是为了提高获取tid的效率，减少系统调用的次数::syscall(SYS_gettid)</span><br><span class="line">  extern __thread char t_tidString[32];//tid字符串的表现形式</span><br><span class="line">  extern __thread int t_tidStringLength;</span><br><span class="line">  extern __thread const char* t_threadName;//每个线程的名称</span><br><span class="line">  void cacheTid();</span><br><span class="line"></span><br><span class="line">  inline int tid()</span><br><span class="line">  &#123;</span><br><span class="line">    if (__builtin_expect(t_cachedTid == 0, 0))//__builtin_expect 是 GCC（GNU Compiler Collection）提供的编译器内置函数。它用于告诉编译器一个分支条件的预期，以便编译器优化代码执行路径</span><br><span class="line">    &#123;</span><br><span class="line">      cacheTid();</span><br><span class="line">    &#125;</span><br><span class="line">    return t_cachedTid;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  inline const char* tidString() // for logging</span><br><span class="line">  &#123;</span><br><span class="line">    return t_tidString;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  inline int tidStringLength() // for logging</span><br><span class="line">  &#123;</span><br><span class="line">    return t_tidStringLength;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  inline const char* name()</span><br><span class="line">  &#123;</span><br><span class="line">    return t_threadName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bool isMainThread();</span><br><span class="line"></span><br><span class="line">  void sleepUsec(int64_t usec);  // for testing</span><br><span class="line"></span><br><span class="line">  string stackTrace(bool demangle);</span><br><span class="line">&#125;  // namespace CurrentThread</span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_BASE_CURRENTTHREAD_H</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="CurrentThread-cc"><a href="#CurrentThread-cc" class="headerlink" title="CurrentThread.cc"></a>CurrentThread.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/CurrentThread.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;cxxabi.h&gt;</span><br><span class="line">#include &lt;execinfo.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace CurrentThread</span><br><span class="line">&#123;</span><br><span class="line">__thread int t_cachedTid = 0;</span><br><span class="line">__thread char t_tidString[32];</span><br><span class="line">__thread int t_tidStringLength = 6;</span><br><span class="line">__thread const char* t_threadName = &quot;unknown&quot;;</span><br><span class="line">static_assert(std::is_same&lt;int, pid_t&gt;::value, &quot;pid_t should be int&quot;);</span><br><span class="line"></span><br><span class="line">string stackTrace(bool demangle)</span><br><span class="line">&#123;</span><br><span class="line">  string stack;</span><br><span class="line">  const int max_frames = 200;</span><br><span class="line">  void* frame[max_frames];</span><br><span class="line">  int nptrs = ::backtrace(frame, max_frames);</span><br><span class="line">  char** strings = ::backtrace_symbols(frame, nptrs);</span><br><span class="line">  if (strings)</span><br><span class="line">  &#123;</span><br><span class="line">    size_t len = 256;</span><br><span class="line">    char* demangled = demangle ? static_cast&lt;char*&gt;(::malloc(len)) : nullptr;</span><br><span class="line">    for (int i = 1; i &lt; nptrs; ++i)  // skipping the 0-th, which is this function</span><br><span class="line">    &#123;</span><br><span class="line">      if (demangle)</span><br><span class="line">      &#123;</span><br><span class="line">        // https://panthema.net/2008/0901-stacktrace-demangled/</span><br><span class="line">        // bin/exception_test(_ZN3Bar4testEv+0x79) [0x401909]</span><br><span class="line">        char* left_par = nullptr;</span><br><span class="line">        char* plus = nullptr;</span><br><span class="line">        for (char* p = strings[i]; *p; ++p)</span><br><span class="line">        &#123;</span><br><span class="line">          if (*p == &#x27;(&#x27;)</span><br><span class="line">            left_par = p;</span><br><span class="line">          else if (*p == &#x27;+&#x27;)</span><br><span class="line">            plus = p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (left_par &amp;&amp; plus)</span><br><span class="line">        &#123;</span><br><span class="line">          *plus = &#x27;\0&#x27;;</span><br><span class="line">          int status = 0;</span><br><span class="line">          char* ret = abi::__cxa_demangle(left_par+1, demangled, &amp;len, &amp;status);</span><br><span class="line">          *plus = &#x27;+&#x27;;</span><br><span class="line">          if (status == 0)</span><br><span class="line">          &#123;</span><br><span class="line">            demangled = ret;  // ret could be realloc()</span><br><span class="line">            stack.append(strings[i], left_par+1);</span><br><span class="line">            stack.append(demangled);</span><br><span class="line">            stack.append(plus);</span><br><span class="line">            stack.push_back(&#x27;\n&#x27;);</span><br><span class="line">            continue;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // Fallback to mangled names</span><br><span class="line">      stack.append(strings[i]);</span><br><span class="line">      stack.push_back(&#x27;\n&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    free(demangled);</span><br><span class="line">    free(strings);</span><br><span class="line">  &#125;</span><br><span class="line">  return stack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace CurrentThread</span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Thread-test-cc"><a href="#Thread-test-cc" class="headerlink" title="Thread_test.cc"></a>Thread_test.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/Thread.h&quot;</span><br><span class="line">#include &quot;muduo/base/CurrentThread.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void mysleep(int seconds)</span><br><span class="line">&#123;</span><br><span class="line">  timespec t = &#123; seconds, 0 &#125;;//timespec 是 POSIX 中定义的用于表示时间的结构体，包含了秒数和纳秒数两个成员</span><br><span class="line">  nanosleep(&amp;t, NULL); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void threadFunc()</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;tid=%d\n&quot;, muduo::CurrentThread::tid());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void threadFunc2(int x)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;tid=%d, x=%d\n&quot;, muduo::CurrentThread::tid(), x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void threadFunc3()</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;tid=%d\n&quot;, muduo::CurrentThread::tid());</span><br><span class="line">  mysleep(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Foo</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  explicit Foo(double x)</span><br><span class="line">    : x_(x)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void memberFunc()</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;tid=%d, Foo::x_=%f\n&quot;, muduo::CurrentThread::tid(), x_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void memberFunc2(const std::string&amp; text)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;tid=%d, Foo::x_=%f, text=%s\n&quot;, muduo::CurrentThread::tid(), x_, text.c_str());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  double x_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;pid=%d, tid=%d\n&quot;, ::getpid(), muduo::CurrentThread::tid());</span><br><span class="line"></span><br><span class="line">  muduo::Thread t1(threadFunc);</span><br><span class="line">  t1.start();</span><br><span class="line">  printf(&quot;t1.tid=%d\n&quot;, t1.tid());</span><br><span class="line">  t1.join();</span><br><span class="line"></span><br><span class="line">  muduo::Thread t2(std::bind(threadFunc2, 42),</span><br><span class="line">                   &quot;thread for free function with argument&quot;);</span><br><span class="line">  t2.start();</span><br><span class="line">  printf(&quot;t2.tid=%d\n&quot;, t2.tid());</span><br><span class="line">  t2.join();</span><br><span class="line"></span><br><span class="line">  Foo foo(87.53);</span><br><span class="line">  muduo::Thread t3(std::bind(&amp;Foo::memberFunc, &amp;foo),</span><br><span class="line">                   &quot;thread for member function without argument&quot;);</span><br><span class="line">  t3.start();</span><br><span class="line">  t3.join();</span><br><span class="line"></span><br><span class="line">  muduo::Thread t4(std::bind(&amp;Foo::memberFunc2, std::ref(foo), std::string(&quot;Shuo Chen&quot;)));</span><br><span class="line">  t4.start();</span><br><span class="line">  t4.join();</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    muduo::Thread t5(threadFunc3);</span><br><span class="line">    t5.start();</span><br><span class="line">    // t5 may destruct eariler than thread creation.</span><br><span class="line">  &#125;</span><br><span class="line">  mysleep(2);</span><br><span class="line">  &#123;</span><br><span class="line">    muduo::Thread t6(threadFunc3);</span><br><span class="line">    t6.start();</span><br><span class="line">    mysleep(2);</span><br><span class="line">    // t6 destruct later than thread creation.</span><br><span class="line">  &#125;</span><br><span class="line">  sleep(2);</span><br><span class="line">  printf(&quot;number of created threads %d\n&quot;, muduo::Thread::numCreated());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从测试文件开始，主要是<strong>基于对象编程思想</strong>，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">muduo::Thread t2(std::bind(threadFunc2, 42),</span><br><span class="line">                   &quot;thread for free function with argument&quot;);</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>

<p>将threadFunc2利用函数适配器传入func_(std::move(func))</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Thread::Thread(ThreadFunc func, const string&amp; n)</span><br><span class="line">  : started_(false),</span><br><span class="line">    joined_(false),</span><br><span class="line">    pthreadId_(0),</span><br><span class="line">    tid_(0),</span><br><span class="line">    func_(std::move(func)),</span><br><span class="line">    name_(n),</span><br><span class="line">    latch_(1)</span><br><span class="line">&#123;</span><br><span class="line">  setDefaultName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void Thread::start()</span><br><span class="line">&#123;</span><br><span class="line">  assert(!started_);</span><br><span class="line">  started_ = true;</span><br><span class="line">  // FIXME: move(func_)</span><br><span class="line">  detail::ThreadData* data = new detail::ThreadData(func_, name_, &amp;tid_, &amp;latch_);</span><br><span class="line">  if (pthread_create(&amp;pthreadId_, NULL, &amp;detail::startThread, data))</span><br><span class="line">  &#123;</span><br><span class="line">    started_ = false;</span><br><span class="line">    delete data; // or no delete?</span><br><span class="line">    LOG_SYSFATAL &lt;&lt; &quot;Failed in pthread_create&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    latch_.wait();</span><br><span class="line">    assert(tid_ &gt; 0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再start函数初始化data，调用detail::ThreadData构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ThreadData(ThreadFunc func,</span><br><span class="line">             const string&amp; name,</span><br><span class="line">             pid_t* tid,</span><br><span class="line">             CountDownLatch* latch)</span><br><span class="line">    : func_(std::move(func)),</span><br><span class="line">      name_(name),</span><br><span class="line">      tid_(tid),</span><br><span class="line">      latch_(latch)</span><br><span class="line">  &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>将上面的适配函数threadFunc2传入<code>func_(std::move(func))</code>，然后<code>pthread_create(&amp;pthreadId_, NULL, &amp;detail::startThread, data)</code>，创建一个线程进入detail::startThread，并将data传入，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void* startThread(void* obj)</span><br><span class="line">&#123;</span><br><span class="line">  ThreadData* data = static_cast&lt;ThreadData*&gt;(obj);</span><br><span class="line">  data-&gt;runInThread();</span><br><span class="line">  delete data;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再调用runInThread，接着就是<code>func_();</code></p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>异常处理是编程中的重要概念，可以帮助我们更好地处理错误和异常情况，避免程序崩溃或数据不一致。在 C++ 中，异常处理通过 <code>try-catch</code> 块来实现。</p>
<p><code>try-catch</code> 块的处理规则如下：</p>
<ol>
<li><code>try</code> 块：在 <code>try</code> 后面的代码块中编写可能会抛出异常的代码。当程序执行到 <code>try</code> 块时，会尝试执行其中的代码。</li>
<li><code>catch</code> 块：如果在 <code>try</code> 块中的代码执行过程中抛出了异常，程序会跳过 <code>try</code> 块中剩余的代码，并进入与异常类型匹配的 <code>catch</code> 块（如果有的话）。<ul>
<li><code>catch</code> 后面跟着异常类型的参数，如 <code>catch (const std::exception&amp; ex)</code>，这表示该 <code>catch</code> 块用于捕获该类型的异常。可以根据需要捕获多种异常类型，每种类型用一个 <code>catch</code> 块来处理。</li>
</ul>
</li>
<li>匹配异常类型：当程序抛出异常时，它会在 <code>try</code> 块外部搜索与异常类型匹配的 <code>catch</code> 块。它会按照代码中 <code>catch</code> 块的顺序进行匹配，找到第一个匹配的 <code>catch</code> 块来处理异常。匹配规则是：异常类型必须与 <code>catch</code> 块中指定的类型相同，或者是该类型的派生类。</li>
<li>处理异常：一旦找到匹配的 <code>catch</code> 块，程序会执行该 <code>catch</code> 块中的代码，处理异常。在 <code>catch</code> 块中，通常会输出异常信息、记录日志、进行清理操作或者再次抛出异常。</li>
<li>多个 <code>catch</code> 块：可以在一个 <code>try</code> 块中使用多个 <code>catch</code> 块来处理不同类型的异常。它们按照出现的顺序依次匹配，找到匹配的 <code>catch</code> 块后，其它的 <code>catch</code> 块不会被执行。</li>
<li>嵌套 <code>try-catch</code>：可以在一个 <code>catch</code> 块中嵌套另一个 <code>try-catch</code> 块来处理更复杂的异常情况。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">try</span><br><span class="line">    &#123;</span><br><span class="line">      func_();</span><br><span class="line">      muduo::CurrentThread::t_threadName = &quot;finished&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (const Exception&amp; ex)</span><br><span class="line">    &#123;</span><br><span class="line">      muduo::CurrentThread::t_threadName = &quot;crashed&quot;;</span><br><span class="line">      fprintf(stderr, &quot;exception caught in Thread %s\n&quot;, name_.c_str());</span><br><span class="line">      fprintf(stderr, &quot;reason: %s\n&quot;, ex.what());</span><br><span class="line">      fprintf(stderr, &quot;stack trace: %s\n&quot;, ex.stackTrace());</span><br><span class="line">      abort();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (const std::exception&amp; ex)</span><br><span class="line">    &#123;</span><br><span class="line">      muduo::CurrentThread::t_threadName = &quot;crashed&quot;;</span><br><span class="line">      fprintf(stderr, &quot;exception caught in Thread %s\n&quot;, name_.c_str());</span><br><span class="line">      fprintf(stderr, &quot;reason: %s\n&quot;, ex.what());</span><br><span class="line">      abort();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (...)</span><br><span class="line">    &#123;</span><br><span class="line">      muduo::CurrentThread::t_threadName = &quot;crashed&quot;;</span><br><span class="line">      fprintf(stderr, &quot;unknown exception caught in Thread %s\n&quot;, name_.c_str());</span><br><span class="line">      throw; // rethrow</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是一个线程函数的异常处理代码块。它捕获可能抛出的异常并做出相应的处理。让我们逐个解释代码的含义：</p>
<ol>
<li><code>try</code>: 这是异常处理的起始点，表示接下来的代码可能会抛出异常。</li>
<li><code>func_()</code>: 这是一个函数调用，其中 <code>func_()</code> 可能会抛出异常。</li>
<li><code>catch (const Exception&amp; ex)</code>: 这是针对自定义的 <code>Exception</code> 类型的异常的捕获块。如果 <code>func_()</code> 抛出了 <code>Exception</code> 类型的异常，它会被这个 <code>catch</code> 块捕获。</li>
<li><code>catch (const std::exception&amp; ex)</code>: 这是针对标准库 <code>std::exception</code> 类型的异常的捕获块。如果 <code>func_()</code> 抛出了标准库的异常，它会被这个 <code>catch</code> 块捕获。</li>
<li><code>catch (...)</code>: 这是一个通配符的异常捕获块，可以捕获任何未被前面的 <code>catch</code> 块捕获的异常。通常用于处理未知类型的异常，或者为了在捕获后再次抛出异常。</li>
</ol>
<p>在处理不同类型的异常时，它们执行了类似的操作：</p>
<ul>
<li>设置当前线程的名称为 “crashed”，表示线程发生了异常。</li>
<li>输出异常信息到标准错误流 (stderr) ，包括线程名称、异常原因和堆栈跟踪。</li>
<li>如果是自定义的 <code>Exception</code> 或标准库的 <code>std::exception</code> 异常，则调用 <code>abort()</code> 终止程序执行。</li>
<li>对于其他未知类型的异常，它会重新抛出异常，使得异常继续传播到更高级别的异常处理代码。</li>
</ul>
<p>总结：就是测试文件传入一个适配函数，给Thread类，然后再start函数初始化data，调用detail::ThreadData构造函数，设置data的func_函数，再创建线程，传入子线程回调函数，进入startThread，调用data-&gt;runInThread();后面就是正常使用适配函数，打印例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void threadFunc2(int x)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;tid=%d, x=%d\n&quot;, muduo::CurrentThread::tid(), x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是<strong>基于对象编程</strong>思想编写的多线程封装</p>
<h1 id="互斥量Mutex"><a href="#互斥量Mutex" class="headerlink" title="互斥量Mutex"></a>互斥量Mutex</h1><h2 id="Mutex-h"><a href="#Mutex-h" class="headerlink" title="Mutex.h"></a>Mutex.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">class CAPABILITY(&quot;mutex&quot;) MutexLock : noncopyable//CAPABILITY(x): 表示被注释的对象x具有特定的能力，允许在特定线程上下文中使用</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  MutexLock()</span><br><span class="line">    : holder_(0)</span><br><span class="line">  &#123;</span><br><span class="line">    MCHECK(pthread_mutex_init(&amp;mutex_, NULL));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~MutexLock()</span><br><span class="line">  &#123;</span><br><span class="line">    assert(holder_ == 0);</span><br><span class="line">    MCHECK(pthread_mutex_destroy(&amp;mutex_));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // must be called when locked, i.e. for assertion</span><br><span class="line">  bool isLockedByThisThread() const</span><br><span class="line">  &#123;</span><br><span class="line">    return holder_ == CurrentThread::tid();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void assertLocked() const ASSERT_CAPABILITY(this)</span><br><span class="line">  &#123;</span><br><span class="line">    assert(isLockedByThisThread());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // internal usage</span><br><span class="line"></span><br><span class="line">  void lock() ACQUIRE()</span><br><span class="line">  &#123;</span><br><span class="line">    MCHECK(pthread_mutex_lock(&amp;mutex_));</span><br><span class="line">    assignHolder();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void unlock() RELEASE()</span><br><span class="line">  &#123;</span><br><span class="line">    unassignHolder();</span><br><span class="line">    MCHECK(pthread_mutex_unlock(&amp;mutex_));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pthread_mutex_t* getPthreadMutex() /* non-const */</span><br><span class="line">  &#123;</span><br><span class="line">    return &amp;mutex_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  friend class Condition;</span><br><span class="line"></span><br><span class="line">  class UnassignGuard : noncopyable</span><br><span class="line">  &#123;</span><br><span class="line">   public:</span><br><span class="line">    explicit UnassignGuard(MutexLock&amp; owner)</span><br><span class="line">      : owner_(owner)</span><br><span class="line">    &#123;</span><br><span class="line">      owner_.unassignHolder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~UnassignGuard()</span><br><span class="line">    &#123;</span><br><span class="line">      owner_.assignHolder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   private:</span><br><span class="line">    MutexLock&amp; owner_;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  void unassignHolder()</span><br><span class="line">  &#123;</span><br><span class="line">    holder_ = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void assignHolder()</span><br><span class="line">  &#123;</span><br><span class="line">    holder_ = CurrentThread::tid();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pthread_mutex_t mutex_;</span><br><span class="line">  pid_t holder_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Use as a stack variable, eg.</span><br><span class="line">// int Foo::size() const</span><br><span class="line">// &#123;</span><br><span class="line">//   MutexLockGuard lock(mutex_);</span><br><span class="line">//   return data_.size();</span><br><span class="line">// &#125;</span><br><span class="line">//SCOPED_CAPABILITY 注解有助于文档化并强制执行 MutexLockGuard 类的预期用法，清楚地表明它表示一个作用域内可加锁的能力，并且应该根据此用法在多线程代码中使用，以管理互斥锁</span><br><span class="line">class SCOPED_CAPABILITY MutexLockGuard : noncopyable//使用RAII技法封装，即资源获取和利用</span><br><span class="line">&#123;                                              //往往更加常用，移位1如果只加锁了，在生命周期结束后会自动调用析构函数解锁</span><br><span class="line"> public:</span><br><span class="line">  explicit MutexLockGuard(MutexLock&amp; mutex) ACQUIRE(mutex)// ACQUIRE指定被注释的函数获取指定的能力（锁）</span><br><span class="line">    : mutex_(mutex)</span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.lock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~MutexLockGuard() RELEASE()</span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.unlock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line"></span><br><span class="line">  MutexLock&amp; mutex_;//与MutexLockGuard只是关联关系</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">// Prevent misuse like:</span><br><span class="line">// MutexLockGuard(mutex_);</span><br><span class="line">// A tempory object doesn&#x27;t hold the lock for long!</span><br><span class="line">#define MutexLockGuard(x) error &quot;Missing guard object name&quot;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，有两个类：<code>MutexLock</code> 和 <code>MutexLockGuard</code>，以及一个宏定义。这些类用于实现互斥锁的功能，并通过 RAII 技术来确保在使用锁的过程中正确地获取和释放锁。</p>
<ol>
<li><code>MutexLock</code> 类：该类用于封装一个互斥锁，提供了锁的获取、释放和一些辅助方法。这个类具有被注释的特定能力 “mutex”，允许在特定线程上下文中使用。</li>
<li><code>MutexLockGuard</code> 类：这是一个 RAII 封装类，用于自动管理互斥锁的获取和释放。在构造函数中，它获取给定 <code>MutexLock</code> 对象的锁，并在析构函数中释放锁。通过这种方式，可以确保在生命周期结束时自动释放锁，避免了手动管理锁的问题。</li>
<li>宏定义：<code>MutexLockGuard(x) error &quot;Missing guard object name&quot;</code> 这个宏定义的作用是防止误用。当用户尝试创建一个没有给定名称的 <code>MutexLockGuard</code> 对象时，编译器会报错并显示 “Missing guard object name” 的错误消息，提醒用户在创建 <code>MutexLockGuard</code> 对象时必须为其指定一个名称。</li>
</ol>
<p>这样，通过 <code>MutexLock</code> 和 <code>MutexLockGuard</code> 类的组合使用，可以在代码中方便地实现互斥锁功能，并避免常见的锁使用错误。</p>
<h2 id="Mutex-test-cc"><a href="#Mutex-test-cc" class="headerlink" title="Mutex_test.cc"></a>Mutex_test.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/CountDownLatch.h&quot;</span><br><span class="line">#include &quot;muduo/base/Mutex.h&quot;</span><br><span class="line">#include &quot;muduo/base/Thread.h&quot;</span><br><span class="line">#include &quot;muduo/base/Timestamp.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">MutexLock g_mutex;</span><br><span class="line">vector&lt;int&gt; g_vec;</span><br><span class="line">const int kCount = 10*1000*1000;</span><br><span class="line"></span><br><span class="line">void threadFunc()</span><br><span class="line">&#123;</span><br><span class="line">  for (int i = 0; i &lt; kCount; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">  //此操作确保在循环体中对 g_vec 进行添加操作时，只有一个线程能够持有互斥锁，从而避免多个线程同时修改 g_vec 导致的数据竞争</span><br><span class="line">    MutexLockGuard lock(g_mutex);</span><br><span class="line">    g_vec.push_back(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int foo() __attribute__ ((noinline));//__attribute__((noinline)) 是 GCC 编译器提供的一个函数属性（function attribute），用于告诉编译器不要对特定函数进行内联优化。</span><br><span class="line"></span><br><span class="line">int g_count = 0;</span><br><span class="line">int foo()</span><br><span class="line">&#123;</span><br><span class="line">  MutexLockGuard lock(g_mutex);</span><br><span class="line">  if (!g_mutex.isLockedByThisThread())</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;FAIL\n&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ++g_count;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;sizeof pthread_mutex_t: %zd\n&quot;, sizeof(pthread_mutex_t));</span><br><span class="line">  printf(&quot;sizeof Mutex: %zd\n&quot;, sizeof(MutexLock));</span><br><span class="line">  printf(&quot;sizeof pthread_cond_t: %zd\n&quot;, sizeof(pthread_cond_t));</span><br><span class="line">  printf(&quot;sizeof Condition: %zd\n&quot;, sizeof(Condition));</span><br><span class="line">  MCHECK(foo());//MCHECK(foo()) 用于确保 foo() 函数执行正常，即成功获取锁并进行递增操作</span><br><span class="line">  if (g_count != 1)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;MCHECK calls twice.\n&quot;);</span><br><span class="line">    abort();//用于终止当前运行的程序</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const int kMaxThreads = 8;</span><br><span class="line">  g_vec.reserve(kMaxThreads * kCount);</span><br><span class="line"></span><br><span class="line">  Timestamp start(Timestamp::now());</span><br><span class="line">  for (int i = 0; i &lt; kCount; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    g_vec.push_back(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printf(&quot;single thread without lock %f\n&quot;, timeDifference(Timestamp::now(), start));</span><br><span class="line"></span><br><span class="line">  start = Timestamp::now();</span><br><span class="line">  threadFunc();</span><br><span class="line">  printf(&quot;single thread with lock %f\n&quot;, timeDifference(Timestamp::now(), start));</span><br><span class="line"></span><br><span class="line">  for (int nthreads = 1; nthreads &lt; kMaxThreads; ++nthreads)</span><br><span class="line">  &#123;</span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;Thread&gt;&gt; threads;//std::unique_ptr 是一个智能指针，用于管理动态分配的对象，并在其生命周期结束时自动释放内存</span><br><span class="line">    g_vec.clear();</span><br><span class="line">    start = Timestamp::now();</span><br><span class="line">    for (int i = 0; i &lt; nthreads; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      threads.emplace_back(new Thread(&amp;threadFunc));</span><br><span class="line">      //使用 emplace_back() 函数在 threads 容器的末尾插入一个新的 std::unique_ptr 对象，它包含了一个指向 Thread 对象的指针。new Thread(&amp;threadFunc) 动态分配一个新的 Thread 对象，并将其作为参数传递给 std::unique_ptr 的构造函数，从而把 Thread 对象交给智能指针管理</span><br><span class="line">      threads.back()-&gt;start();</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; nthreads; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      threads[i]-&gt;join();</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d thread(s) with lock %f\n&quot;, nthreads, timeDifference(Timestamp::now(), start));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%882%EF%BC%89/image-20230802150753684.png" alt="image-20230802150753684"></p>
<img src="/2023/08/01/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%882%EF%BC%89/image-20230802150753684.png" class title="This is an test image">

<p>这个测试的是在没锁和有锁的情况下向容器添加整数的时间差,后面就是创建不同个数线程然后跟前面一样传入一个函数，在每一个最后新加的Thread对象调用startt函数初始化data，调用detail::ThreadData构造函数，设置data的func_函数，再创建线程，传入子线程回调函数，进入startThread，调用data-&gt;runInThread();后面就是正常使用适配函数，跟前面一样。实际上就是创建不同个数线程在lock下的时间差</p>
<h2 id="条件变量Condition"><a href="#条件变量Condition" class="headerlink" title="条件变量Condition"></a>条件变量Condition</h2><h3 id="condition-h"><a href="#condition-h" class="headerlink" title="condition.h"></a>condition.h</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Condition : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  explicit Condition(MutexLock&amp; mutex)</span><br><span class="line">    : mutex_(mutex)</span><br><span class="line">  &#123;</span><br><span class="line">    MCHECK(pthread_cond_init(&amp;pcond_, NULL));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~Condition()</span><br><span class="line">  &#123;</span><br><span class="line">    MCHECK(pthread_cond_destroy(&amp;pcond_));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void wait()</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLock::UnassignGuard ug(mutex_);</span><br><span class="line">    MCHECK(pthread_cond_wait(&amp;pcond_, mutex_.getPthreadMutex()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // returns true if time out, false otherwise.</span><br><span class="line">  bool waitForSeconds(double seconds);</span><br><span class="line"></span><br><span class="line">  void notify()</span><br><span class="line">  &#123;</span><br><span class="line">    MCHECK(pthread_cond_signal(&amp;pcond_));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void notifyAll()</span><br><span class="line">  &#123;</span><br><span class="line">    MCHECK(pthread_cond_broadcast(&amp;pcond_));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  MutexLock&amp; mutex_;</span><br><span class="line">  pthread_cond_t pcond_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Condition-cc"><a href="#Condition-cc" class="headerlink" title="Condition.cc"></a>Condition.cc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// returns true if time out, false otherwise.</span><br><span class="line">//这个函数允许线程在指定的时间间隔内等待条件变量被唤醒。如果等待时间到期仍未被唤醒，则函数返回等待超时</span><br><span class="line">bool muduo::Condition::waitForSeconds(double seconds)</span><br><span class="line">&#123;</span><br><span class="line">  struct timespec abstime;</span><br><span class="line">  // FIXME: use CLOCK_MONOTONIC or CLOCK_MONOTONIC_RAW to prevent time rewind.</span><br><span class="line">  clock_gettime(CLOCK_REALTIME, &amp;abstime);</span><br><span class="line"></span><br><span class="line">  const int64_t kNanoSecondsPerSecond = 1000000000;</span><br><span class="line">  int64_t nanoseconds = static_cast&lt;int64_t&gt;(seconds * kNanoSecondsPerSecond);</span><br><span class="line"></span><br><span class="line">  abstime.tv_sec += static_cast&lt;time_t&gt;((abstime.tv_nsec + nanoseconds) / kNanoSecondsPerSecond);</span><br><span class="line">  abstime.tv_nsec = static_cast&lt;long&gt;((abstime.tv_nsec + nanoseconds) % kNanoSecondsPerSecond);</span><br><span class="line"></span><br><span class="line">  MutexLock::UnassignGuard ug(mutex_);</span><br><span class="line">  return ETIMEDOUT == pthread_cond_timedwait(&amp;pcond_, mutex_.getPthreadMutex(), &amp;abstime);</span><br><span class="line">&#125;</span><br><span class="line">这个函数 muduo::Condition::waitForSeconds(double seconds) 是用于等待一段特定时间来等待条件变量被唤醒。</span><br><span class="line"></span><br><span class="line">在函数内部，它进行了以下操作来等待条件变量的唤醒：</span><br><span class="line"></span><br><span class="line">获取当前时间，并将其保存在 abstime 结构体中。</span><br><span class="line">根据传入的 seconds 参数，计算出等待的绝对时间。</span><br><span class="line">更新 abstime 的秒数和纳秒数，以计算出等待结束的绝对时间点。</span><br><span class="line">在函数内部创建了一个 MutexLock::UnassignGuard 对象 ug，用于临时解除互斥锁的持有状态。</span><br><span class="line">调用 pthread_cond_timedwait 函数，传入条件变量 pcond_、互斥锁 mutex_.getPthreadMutex() 和等待的截止时间 &amp;abstime，来等待条件变量的唤醒。</span><br><span class="line">如果等待超时，则返回 ETIMEDOUT，表示等待时间已经到达并且条件变量未被唤醒；如果条件变量被唤醒，则返回其他值。</span><br><span class="line">因此，这个函数体现了在指定的时间内等待条件变量被唤醒的逻辑。它通过调用系统的 pthread_cond_timedwait 函数，在等待时间到达或者条件变量被唤醒时返回，从而实现等待操作。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>friend class Condition;</code> 声明了 <code>Condition</code> 类为 <code>MutexLock</code> 的友元类，使得 <code>Condition</code> 类的成员函数可以访问 <code>MutexLock</code> 类的私有成员。在 <code>MutexLock</code> 类的嵌套类 <code>UnassignGuard</code> 中，通过友元关系可以访问 <code>MutexLock</code> 类的私有成员函数，并在构造和析构过程中使用这些私有函数来实现解锁和重新上锁的操作</p>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>既可以用于所有子线程等待主线程发起“起跑’,用条件变量来通知<br>也可以用于主线程等待子线程初始化完毕才开始工作</p>
<p>配合condition使用，有多少个count_</p>
<h3 id="CountDownLatch-h"><a href="#CountDownLatch-h" class="headerlink" title="CountDownLatch.h"></a>CountDownLatch.h</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/Condition.h&quot;</span><br><span class="line">#include &quot;muduo/base/Mutex.h&quot;</span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">class CountDownLatch : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line"></span><br><span class="line">  explicit CountDownLatch(int count);</span><br><span class="line"></span><br><span class="line">  void wait();</span><br><span class="line"></span><br><span class="line">  void countDown();</span><br><span class="line"></span><br><span class="line">  int getCount() const;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  mutable MutexLock mutex_;//mutable表示可以改变的，在int getCount() const函数可以改变，即加锁</span><br><span class="line">  Condition condition_ GUARDED_BY(mutex_);</span><br><span class="line">  //通过添加 GUARDED_BY(mutex_) 注释，代码的作者表明只有当持有 mutex_ 锁时，才能安全地访问 condition_ 和 count_。这样可以帮助其他程序员理解在多线程环境中对这些成员变量进行操作时的线程安全性</span><br><span class="line">  int count_ GUARDED_BY(mutex_);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br></pre></td></tr></table></figure>

<h3 id="CountDownLatch-cc"><a href="#CountDownLatch-cc" class="headerlink" title="CountDownLatch.cc"></a>CountDownLatch.cc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">using namespace muduo;</span><br><span class="line"></span><br><span class="line">CountDownLatch::CountDownLatch(int count)</span><br><span class="line">  : mutex_(),</span><br><span class="line">    condition_(mutex_),</span><br><span class="line">    count_(count)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CountDownLatch::wait()</span><br><span class="line">&#123;</span><br><span class="line">  MutexLockGuard lock(mutex_);</span><br><span class="line">  while (count_ &gt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    condition_.wait();//阻塞等待条件变量，pthread_cond_wait(&amp;pcond_, mutex_.getPthreadMutex())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CountDownLatch::countDown()//解锁</span><br><span class="line">&#123;</span><br><span class="line">  MutexLockGuard lock(mutex_);</span><br><span class="line">  --count_;</span><br><span class="line">  if (count_ == 0)</span><br><span class="line">  &#123;</span><br><span class="line">    condition_.notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int CountDownLatch::getCount() const//获取当前count</span><br><span class="line">&#123;</span><br><span class="line">  MutexLockGuard lock(mutex_);</span><br><span class="line">  return count_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用于所有子线程等待主线程发起“起跑’,用条件变量来通知，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// 定义 CountDownLatch 对象</span><br><span class="line">CountDownLatch startSignal(1);</span><br><span class="line"></span><br><span class="line">// 子线程的任务函数</span><br><span class="line">void workerThread(int id)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Worker Thread &quot; &lt;&lt; id &lt;&lt; &quot; is waiting for the start signal.&quot; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    // 子线程等待主线程发起“起跑”信号</span><br><span class="line">    startSignal.wait();</span><br><span class="line"></span><br><span class="line">    // 执行子线程的工作任务</span><br><span class="line">    std::cout &lt;&lt; &quot;Worker Thread &quot; &lt;&lt; id &lt;&lt; &quot; starts working.&quot; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;Worker Thread &quot; &lt;&lt; id &lt;&lt; &quot; has finished its work.&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int numThreads = 5;</span><br><span class="line">    muduo::Thread threads[numThreads];</span><br><span class="line"></span><br><span class="line">    // 创建并启动子线程</span><br><span class="line">    for (int i = 0; i &lt; numThreads; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        threads[i] = muduo::Thread(workerThread, i + 1);</span><br><span class="line">        threads[i]-&gt;start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 主线程休眠一段时间，模拟一些准备工作</span><br><span class="line">    std::this_thread::sleep_for(std::chrono::seconds(2));</span><br><span class="line"></span><br><span class="line">    // 发起“起跑”信号</span><br><span class="line">    std::cout &lt;&lt; &quot;Starting all worker threads...&quot; &lt;&lt; std::endl;</span><br><span class="line">    startSignal.countDown(); // 解除阻塞，所有子线程同时开始工作</span><br><span class="line"></span><br><span class="line">    // 等待所有子线程执行完毕</span><br><span class="line">    for (int i = 0; i &lt; numThreads; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        threads[i].join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;All worker threads have finished their work. Main thread exits.&quot; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="BlockinngQueue-lt-T-gt-（无界缓冲区"><a href="#BlockinngQueue-lt-T-gt-（无界缓冲区" class="headerlink" title="BlockinngQueue&lt;T&gt;（无界缓冲区)"></a>BlockinngQueue<code>&lt;T&gt;</code>（无界缓冲区)</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_BASE_BLOCKINGQUEUE_H</span><br><span class="line">#define MUDUO_BASE_BLOCKINGQUEUE_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Condition.h&quot;</span><br><span class="line">#include &quot;muduo/base/Mutex.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class BlockingQueue : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  using queue_type = std::deque&lt;T&gt;;//表明队列使用 std::deque 作为底层容器，其中 T 是类型参数</span><br><span class="line"></span><br><span class="line">  BlockingQueue()</span><br><span class="line">    : mutex_(),</span><br><span class="line">      notEmpty_(mutex_),</span><br><span class="line">      queue_()</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void put(const T&amp; x)//用于将不可移动对象（常量左值）放入队列,这意味着在将对象添加到队列时，不会对传递给函数的对象进行移动或修改</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    queue_.push_back(x);</span><br><span class="line">    notEmpty_.notify(); // wait morphing saves us</span><br><span class="line">    // http://www.domaigne.com/blog/computing/condvars-signal-with-mutex-locked-or-not/</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void put(T&amp;&amp; x)//生产,用于将可移动对象（右值）放入队列</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    queue_.push_back(std::move(x));</span><br><span class="line">    notEmpty_.notify();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T take()//消费</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    // always use a while-loop, due to spurious wakeup</span><br><span class="line">    while (queue_.empty())</span><br><span class="line">    &#123;</span><br><span class="line">      notEmpty_.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    assert(!queue_.empty());</span><br><span class="line">    T front(std::move(queue_.front()));//构造了一个类型为 T 的对象 front</span><br><span class="line">    queue_.pop_front();</span><br><span class="line">    return front;</span><br><span class="line">  &#125;</span><br><span class="line">//drain() 函数将队列中的所有元素移除，并以一个新的 std::deque 对象的形式返回。注意，此操作会清空原队列，原队列中的数据将不再存在。在多线程环境下，使用互斥锁确保操作的原子性，避免与其他线程同时访问队列而导致的竞态条件</span><br><span class="line">  queue_type drain()</span><br><span class="line">  &#123;</span><br><span class="line">    std::deque&lt;T&gt; queue;</span><br><span class="line">    &#123;</span><br><span class="line">      MutexLockGuard lock(mutex_);</span><br><span class="line">      queue = std::move(queue_);</span><br><span class="line">      assert(queue_.empty());//确保在操作完成后，原队列确实为空</span><br><span class="line">    &#125;</span><br><span class="line">    return queue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  size_t size() const</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    return queue_.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  mutable MutexLock mutex_;</span><br><span class="line">  Condition         notEmpty_ GUARDED_BY(mutex_);</span><br><span class="line">  queue_type        queue_ GUARDED_BY(mutex_);</span><br><span class="line">&#125;;  // __attribute__ ((aligned (64)));</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br></pre></td></tr></table></figure>

<h2 id="BlockingQueue-test-cc"><a href="#BlockingQueue-test-cc" class="headerlink" title="BlockingQueue_test.cc"></a>BlockingQueue_test.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/BlockingQueue.h&quot;</span><br><span class="line">#include &quot;muduo/base/CountDownLatch.h&quot;</span><br><span class="line">#include &quot;muduo/base/Thread.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  Test(int numThreads)</span><br><span class="line">    : latch_(numThreads)//构造函数实现将消费者函数传递，跟前面的基于对象编程思想一样</span><br><span class="line">  &#123;</span><br><span class="line">    for (int i = 0; i &lt; numThreads; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      char name[32];</span><br><span class="line">      snprintf(name, sizeof name, &quot;work thread %d&quot;, i);</span><br><span class="line">      ////emplace_back 通常比 push_back 更高效。由于 emplace_back 直接在容器中构造元素，避免了额外的拷贝或移动操作，因此它在某些情况下可以更快</span><br><span class="line">      threads_.emplace_back(new muduo::Thread(</span><br><span class="line">            std::bind(&amp;Test::threadFunc, this), muduo::string(name)));</span><br><span class="line">    &#125;</span><br><span class="line">    for (auto&amp; thr : threads_)//遍历每个线程</span><br><span class="line">    &#123;</span><br><span class="line">      thr-&gt;start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void run(int times)//生产者函数</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;waiting for count down latch\n&quot;);</span><br><span class="line">    latch_.wait();//condition_.wait();阻塞等待唤醒</span><br><span class="line">    printf(&quot;all threads started\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; times; ++i)//生产100个</span><br><span class="line">    &#123;</span><br><span class="line">      char buf[32];</span><br><span class="line">      snprintf(buf, sizeof buf, &quot;hello %d&quot;, i);</span><br><span class="line">      queue_.put(buf);</span><br><span class="line">      printf(&quot;tid=%d, put data = %s, size = %zd\n&quot;, muduo::CurrentThread::tid(), buf, queue_.size());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void joinAll()</span><br><span class="line">  &#123;</span><br><span class="line">    for (size_t i = 0; i &lt; threads_.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      queue_.put(&quot;stop&quot;);//running = (d != &quot;stop&quot;);使其退出</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (auto&amp; thr : threads_)</span><br><span class="line">    &#123;</span><br><span class="line">      thr-&gt;join();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line"></span><br><span class="line">  void threadFunc()//消费者函数</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;tid=%d, %s started\n&quot;,</span><br><span class="line">           muduo::CurrentThread::tid(),</span><br><span class="line">           muduo::CurrentThread::name());</span><br><span class="line"></span><br><span class="line">    latch_.countDown();//--count_;</span><br><span class="line">    bool running = true;</span><br><span class="line">    while (running)</span><br><span class="line">    &#123;</span><br><span class="line">      std::string d(queue_.take());//消费，并将front返回添加到d</span><br><span class="line">      printf(&quot;tid=%d, get data = %s, size = %zd\n&quot;, muduo::CurrentThread::tid(), d.c_str(), queue_.size());</span><br><span class="line">      running = (d != &quot;stop&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;tid=%d, %s stopped\n&quot;,</span><br><span class="line">           muduo::CurrentThread::tid(),</span><br><span class="line">           muduo::CurrentThread::name());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  muduo::BlockingQueue&lt;std::string&gt; queue_;</span><br><span class="line">  muduo::CountDownLatch latch_;</span><br><span class="line">  std::vector&lt;std::unique_ptr&lt;muduo::Thread&gt;&gt; threads_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void testMove()</span><br><span class="line">&#123;</span><br><span class="line">  muduo::BlockingQueue&lt;std::unique_ptr&lt;int&gt;&gt; queue;</span><br><span class="line">  queue.put(std::unique_ptr&lt;int&gt;(new int(42)));</span><br><span class="line">  std::unique_ptr&lt;int&gt; x = queue.take();</span><br><span class="line">  printf(&quot;took %d\n&quot;, *x);</span><br><span class="line">  *x = 123;</span><br><span class="line">  queue.put(std::move(x));</span><br><span class="line">  std::unique_ptr&lt;int&gt; y = queue.take();</span><br><span class="line">  printf(&quot;took %d\n&quot;, *y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;pid=%d, tid=%d\n&quot;, ::getpid(), muduo::CurrentThread::tid());</span><br><span class="line">  Test t(5);//muduo::CountDownLatch latch_;实现5个子线程</span><br><span class="line">  t.run(100);</span><br><span class="line">  t.joinAll();</span><br><span class="line"></span><br><span class="line">  testMove();</span><br><span class="line"></span><br><span class="line">  printf(&quot;number of created threads %d\n&quot;, muduo::Thread::numCreated());</span><br><span class="line">  //muduo::Thread::numCreated(),就是访问static int numCreated() &#123; return numCreated_.get(); &#125;</span><br><span class="line">  //numCreated_ 是一个 AtomicInt32 类型的静态成员变量，这意味着它是一个类变量，属于整个 Thread 类而不是实例化对象。因此，每次创建新的 Thread 实例时，都会共享并更新 numCreated_，从而记录创建的线程数量</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>实现无边界的消费者生产者问题</strong></p>
<h1 id="BoundedBlockingQueue-lt-T-gt-有界缓冲区"><a href="#BoundedBlockingQueue-lt-T-gt-有界缓冲区" class="headerlink" title="BoundedBlockingQueue&lt;T&gt;(有界缓冲区)"></a>BoundedBlockingQueue<code>&lt;T&gt;</code>(有界缓冲区)</h1><h2 id="BoundedBlockingQueue-h"><a href="#BoundedBlockingQueue-h" class="headerlink" title="BoundedBlockingQueue.h"></a>BoundedBlockingQueue.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_BASE_BOUNDEDBLOCKINGQUEUE_H</span><br><span class="line">#define MUDUO_BASE_BOUNDEDBLOCKINGQUEUE_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Condition.h&quot;</span><br><span class="line">#include &quot;muduo/base/Mutex.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;boost/circular_buffer.hpp&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class BoundedBlockingQueue : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  explicit BoundedBlockingQueue(int maxSize)</span><br><span class="line">    : mutex_(),</span><br><span class="line">      notEmpty_(mutex_),</span><br><span class="line">      notFull_(mutex_),</span><br><span class="line">      queue_(maxSize)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void put(const T&amp; x)</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    while (queue_.full())</span><br><span class="line">    &#123;</span><br><span class="line">      notFull_.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    assert(!queue_.full());</span><br><span class="line">    queue_.push_back(x);</span><br><span class="line">    notEmpty_.notify();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void put(T&amp;&amp; x)</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    while (queue_.full())</span><br><span class="line">    &#123;</span><br><span class="line">      notFull_.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    assert(!queue_.full());</span><br><span class="line">    queue_.push_back(std::move(x));</span><br><span class="line">    notEmpty_.notify();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T take()</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    while (queue_.empty())</span><br><span class="line">    &#123;</span><br><span class="line">      notEmpty_.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    assert(!queue_.empty());</span><br><span class="line">    T front(std::move(queue_.front()));</span><br><span class="line">    queue_.pop_front();</span><br><span class="line">    notFull_.notify();</span><br><span class="line">    return front;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bool empty() const</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    return queue_.empty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bool full() const</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    return queue_.full();//用于判断循环缓冲区是否已满</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  size_t size() const</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    return queue_.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  size_t capacity() const</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    return queue_.capacity();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  mutable MutexLock          mutex_;</span><br><span class="line">  Condition                  notEmpty_ GUARDED_BY(mutex_);</span><br><span class="line">  Condition                  notFull_ GUARDED_BY(mutex_);</span><br><span class="line">  boost::circular_buffer&lt;T&gt;  queue_ GUARDED_BY(mutex_);//环形缓冲区</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_BASE_BOUNDEDBLOCKINGQUEUE_H</span><br></pre></td></tr></table></figure>

<p>跟上面相比就是需要判断是否满，并且这里实现的是环形缓冲区</p>
<h2 id="BoundedBlockingQueue-test-cc"><a href="#BoundedBlockingQueue-test-cc" class="headerlink" title="BoundedBlockingQueue_test.cc"></a>BoundedBlockingQueue_test.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/BoundedBlockingQueue.h&quot;</span><br><span class="line">#include &quot;muduo/base/CountDownLatch.h&quot;</span><br><span class="line">#include &quot;muduo/base/Thread.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  Test(int numThreads)</span><br><span class="line">    : queue_(20),</span><br><span class="line">      latch_(numThreads)</span><br><span class="line">  &#123;</span><br><span class="line">    threads_.reserve(numThreads);</span><br><span class="line">    for (int i = 0; i &lt; numThreads; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      char name[32];</span><br><span class="line">      snprintf(name, sizeof name, &quot;work thread %d&quot;, i);</span><br><span class="line">      threads_.emplace_back(new muduo::Thread(</span><br><span class="line">            std::bind(&amp;Test::threadFunc, this), muduo::string(name)));</span><br><span class="line">    &#125;</span><br><span class="line">    for (auto&amp; thr : threads_)</span><br><span class="line">    &#123;</span><br><span class="line">      thr-&gt;start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void run(int times)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;waiting for count down latch\n&quot;);</span><br><span class="line">    latch_.wait();</span><br><span class="line">    printf(&quot;all threads started\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; times; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      char buf[32];</span><br><span class="line">      snprintf(buf, sizeof buf, &quot;hello %d&quot;, i);</span><br><span class="line">      queue_.put(buf);</span><br><span class="line">      printf(&quot;tid=%d, put data = %s, size = %zd\n&quot;, muduo::CurrentThread::tid(), buf, queue_.size());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void joinAll()</span><br><span class="line">  &#123;</span><br><span class="line">    for (size_t i = 0; i &lt; threads_.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      queue_.put(&quot;stop&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (auto&amp; thr : threads_)</span><br><span class="line">    &#123;</span><br><span class="line">      thr-&gt;join();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line"></span><br><span class="line">  void threadFunc()</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;tid=%d, %s started\n&quot;,</span><br><span class="line">           muduo::CurrentThread::tid(),</span><br><span class="line">           muduo::CurrentThread::name());</span><br><span class="line"></span><br><span class="line">    latch_.countDown();</span><br><span class="line">    bool running = true;</span><br><span class="line">    while (running)</span><br><span class="line">    &#123;</span><br><span class="line">      std::string d(queue_.take());</span><br><span class="line">      printf(&quot;tid=%d, get data = %s, size = %zd\n&quot;, muduo::CurrentThread::tid(), d.c_str(), queue_.size());</span><br><span class="line">      running = (d != &quot;stop&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;tid=%d, %s stopped\n&quot;,</span><br><span class="line">           muduo::CurrentThread::tid(),</span><br><span class="line">           muduo::CurrentThread::name());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  muduo::BoundedBlockingQueue&lt;std::string&gt; queue_;</span><br><span class="line">  muduo::CountDownLatch latch_;</span><br><span class="line">  std::vector&lt;std::unique_ptr&lt;muduo::Thread&gt;&gt; threads_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void testMove()</span><br><span class="line">&#123;</span><br><span class="line">#if BOOST_VERSION &gt;= 105500L// Boost 库中的预定义宏，表示当前使用的 Boost 版本号。如果满足条件，则执行下面的代码块</span><br><span class="line">  muduo::BoundedBlockingQueue&lt;std::unique_ptr&lt;int&gt;&gt; queue(10);</span><br><span class="line">  queue.put(std::unique_ptr&lt;int&gt;(new int(42)));</span><br><span class="line">  std::unique_ptr&lt;int&gt; x = queue.take();</span><br><span class="line">  printf(&quot;took %d\n&quot;, *x);</span><br><span class="line">  *x = 123;</span><br><span class="line">  queue.put(std::move(x));</span><br><span class="line">  std::unique_ptr&lt;int&gt; y;</span><br><span class="line">  y = queue.take();</span><br><span class="line">  printf(&quot;took %d\n&quot;, *y);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;pid=%d, tid=%d\n&quot;, ::getpid(), muduo::CurrentThread::tid());</span><br><span class="line">  testMove();</span><br><span class="line">  Test t(5);</span><br><span class="line">  t.run(100);</span><br><span class="line">  t.joinAll();</span><br><span class="line"></span><br><span class="line">  printf(&quot;number of created threads %d\n&quot;, muduo::Thread::numCreated());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试代码和上面差不多，只是在源文件的put和take加入了多的判断界限。</p>
<h1 id="ThreadPool线程池封装"><a href="#ThreadPool线程池封装" class="headerlink" title="ThreadPool线程池封装"></a>ThreadPool线程池封装</h1><p>这个线程池的执行任务的过程如下：</p>
<ol>
<li><p>调用<code>ThreadPool::run()</code>函数添加一个任务到线程池中。如果线程池为空，直接执行任务。</p>
</li>
<li><p>如果线程池不为空，获取互斥锁，检查队列是否已满（达到最大容量）且线程池正在运行。</p>
<ul>
<li>如果队列已满且线程池正在运行，则等待条件变量<code>notFull_</code>，即等待队列不再满的时候再继续执行。</li>
<li>如果线程池不再运行，则直接返回，不再添加任务。</li>
</ul>
</li>
<li><p>释放互斥锁后，将任务添加到队列中，并通知条件变量<code>notEmpty_</code>，以便通知正在等待任务的线程。</p>
</li>
<li><p>在另外的线程中调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool::take()</span><br></pre></td></tr></table></figure>

<p>函数来获取任务并执行。获取任务前，先获取互斥锁。</p>
<ul>
<li>如果队列为空且线程池正在运行，则等待条件变量<code>notEmpty_</code>，即等待队列不再空的时候再继续执行。</li>
</ul>
</li>
<li><p>获取到任务后，从队列中取出并移除该任务，并检查是否需要唤醒等待在<code>notFull_</code>条件变量上的线程。</p>
</li>
<li><p>释放互斥锁后，执行任务函数。</p>
</li>
<li><p>当线程池停止时，通过调用<code>ThreadPool::stop()</code>函数设置<code>running_</code>为<code>false</code>，并通知等待在<code>notEmpty_</code>和<code>notFull_</code>条件变量上的线程。</p>
</li>
<li><p>线程池中的所有线程在执行完当前任务后退出。</p>
</li>
</ol>
<p>总结起来，线程池会不断从任务队列中获取任务并执行，同时提供了添加任务和停止线程池的功能。使用互斥锁和条件变量来实现对任务队列的线程安全操作，并通过多个工作线程实现并行执行任务的效果。</p>
<p>用于<em>计算线程池</em></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/01/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/01/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/" class="post-title-link" itemprop="url">muduo-基础库（1）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-01 12:04:15" itemprop="dateCreated datePublished" datetime="2023-08-01T12:04:15+08:00">2023-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-19 16:40:28" itemprop="dateModified" datetime="2023-08-19T16:40:28+08:00">2023-08-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p><img src="/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230730155255822.png" alt="image-20230730155255822"></p>
<img src="/2023/08/01/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230730155255822.png" class title="This is an test image">

<h2 id="基础库"><a href="#基础库" class="headerlink" title="基础库"></a>基础库</h2><p><img src="/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230730155339712.png" alt="image-20230730155339712"></p>
<img src="/2023/08/01/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230730155339712.png" class title="This is an test image">

<p><img src="/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230730155404611.png" alt="image-20230730155404611"></p>
<img src="/2023/08/01/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230730155404611.png" class title="This is an test image">

<h2 id="时间戳Timestamp类封装"><a href="#时间戳Timestamp类封装" class="headerlink" title="时间戳Timestamp类封装"></a>时间戳Timestamp类封装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;base/types.h&gt;</span><br></pre></td></tr></table></figure>

<p>less_than_comparable<br>    要求实现&lt;，可自动实现&gt;,&lt;&#x3D;,&gt;&#x3D;</p>
<p>BOOST_STATIC_ASSERT</p>
<p>使用PRId64</p>
<p>Timestamp实现及测试</p>
<p><strong>BOOST_STATIC_ASSERT</strong>编译时断言，现在是STATIC_ASSERT<br><strong>assert</strong>是运行时断言</p>
<p><code>static_assert</code> 是标准 C++ 的一部分，更为现代和推荐的用法，特别是在使用 C++11 及以上标准的项目中。而 <code>BOOST_STATIC_ASSERT</code> 则是为了兼容 C++03 标准而提供的 Boost 库中的宏，在旧的编译环境中可能会使用到。在使用时，根据项目的需求和所支持的 C++ 标准版本来选择使用哪种静态断言宏。</p>
<h3 id="使用PRld64"><a href="#使用PRld64" class="headerlink" title="使用PRld64"></a>使用PRld64</h3><p>int64_t用来表示64位整数，在32位系统中是long long int，在64位系统中是long int,所以打印int64_t的格式化方法是:<br><code>printf(&quot;%ld&quot;, value);// 64bit os</code></p>
<p><code>printf(&quot;%lld&quot;, value); // 32bit Os</code></p>
<p>跨平台的做法:<br><code>#define_STDC_FORMAT_MACROS</code>这是一个预处理指令，用于定义一个宏 <code>_STDC_FORMAT_MACROS</code>。在 <code>inttypes.h</code> 头文件中，如果检测到定义了这个宏，它将启用一系列与格式化整数类型相关的宏定义，包括 <code>PRId64</code>、<code>PRIu64</code> 等</p>
<p><code>#include &lt;inttypes.h&gt;</code>这是包含 C&#x2F;C++ 标准库中 <code>inttypes.h</code> 头文件的指令。<code>inttypes.h</code> 头文件提供了一系列用于处理整数类型的宏和格式说明符</p>
<p><code>#undef_STDC_FORMAT_MACROS</code>这是另一个预处理指令，用于取消之前定义的 <code>_STDC_FORMAT_MACROS</code> 宏。在包含完 <code>inttypes.h</code> 头文件之后，我们取消这个宏的定义，以防止它在后续代码中产生影响。</p>
<p><code>printf(&quot;%&quot;PRId64 &quot;\n&quot;, value);</code></p>
<p><img src="/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230730165438382.png" alt="image-20230730165438382"></p>
<img src="/2023/08/01/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230730165438382.png" class title="This is an test image">

<h3 id="Timestamp-h"><a href="#Timestamp-h" class="headerlink" title="Timestamp.h"></a>Timestamp.h</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#ifndef MUDUO_BASE_TIMESTAMP_H</span><br><span class="line">#define MUDUO_BASE_TIMESTAMP_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/copyable.h&quot;</span><br><span class="line">#include &quot;muduo/base/Types.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;boost/operators.hpp&gt;</span><br><span class="line"></span><br><span class="line">namespace muduo//namespace muduo 是一个命名空间（namespace），用于将一组相关的类、函数、变量等实体封装在一个逻辑上相互隔离的作用域中。这个命名空间在上述代码中包含了一个名为 Timestamp 的类以及与该类相关的一些函数和常量。</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">///</span><br><span class="line">/// Time stamp in UTC, in microseconds resolution.</span><br><span class="line">///</span><br><span class="line">/// This class is immutable.</span><br><span class="line">/// It&#x27;s recommended to pass it by value, since it&#x27;s passed in register on x64.</span><br><span class="line">///</span><br><span class="line">class Timestamp : public muduo::copyable,//是值语义，值语义是指对象的复制行为是复制其值而非引用。在 C++ 中，默认情况下，类的对象的复制行为是浅拷贝，即复制对象的成员变量的值，而不复制指向的资源</span><br><span class="line">                  public boost::equality_comparable&lt;Timestamp&gt;,</span><br><span class="line">                  public boost::less_than_comparable&lt;Timestamp&gt;</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  ///</span><br><span class="line">  /// Constucts an invalid Timestamp.</span><br><span class="line">  ///</span><br><span class="line">  Timestamp()</span><br><span class="line">    : microSecondsSinceEpoch_(0)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ///</span><br><span class="line">  /// Constucts a Timestamp at specific time</span><br><span class="line">  ///</span><br><span class="line">  /// @param microSecondsSinceEpoch</span><br><span class="line">  explicit Timestamp(int64_t microSecondsSinceEpochArg)</span><br><span class="line">    : microSecondsSinceEpoch_(microSecondsSinceEpochArg)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void swap(Timestamp&amp; that)</span><br><span class="line">  &#123;</span><br><span class="line">    std::swap(microSecondsSinceEpoch_, that.microSecondsSinceEpoch_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // default copy/assignment/dtor are Okay</span><br><span class="line"></span><br><span class="line">  string toString() const;</span><br><span class="line">  string toFormattedString(bool showMicroseconds = true) const;</span><br><span class="line"></span><br><span class="line">  bool valid() const &#123; return microSecondsSinceEpoch_ &gt; 0; &#125;</span><br><span class="line"></span><br><span class="line">  // for internal usage.</span><br><span class="line">  int64_t microSecondsSinceEpoch() const &#123; return microSecondsSinceEpoch_; &#125;</span><br><span class="line">  time_t secondsSinceEpoch() const</span><br><span class="line">  &#123; return static_cast&lt;time_t&gt;(microSecondsSinceEpoch_ / kMicroSecondsPerSecond); &#125;</span><br><span class="line"></span><br><span class="line">  ///</span><br><span class="line">  /// Get time of now.</span><br><span class="line">  ///</span><br><span class="line">  static Timestamp now();</span><br><span class="line">  static Timestamp invalid()</span><br><span class="line">  &#123;</span><br><span class="line">    return Timestamp();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static Timestamp fromUnixTime(time_t t)</span><br><span class="line">  &#123;</span><br><span class="line">    return fromUnixTime(t, 0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static Timestamp fromUnixTime(time_t t, int microseconds)</span><br><span class="line">  &#123;</span><br><span class="line">    return Timestamp(static_cast&lt;int64_t&gt;(t) * kMicroSecondsPerSecond + microseconds);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static const int kMicroSecondsPerSecond = 1000 * 1000;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  int64_t microSecondsSinceEpoch_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inline bool operator&lt;(Timestamp lhs, Timestamp rhs)//声明和定义都在.h文件</span><br><span class="line">&#123;</span><br><span class="line">  return lhs.microSecondsSinceEpoch() &lt; rhs.microSecondsSinceEpoch();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline bool operator==(Timestamp lhs, Timestamp rhs)//实现&lt;，可自动实现&gt;,&lt;=,&gt;=</span><br><span class="line">&#123;</span><br><span class="line">  return lhs.microSecondsSinceEpoch() == rhs.microSecondsSinceEpoch();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///</span><br><span class="line">/// Gets time difference of two timestamps, result in seconds.</span><br><span class="line">///</span><br><span class="line">/// @param high, low</span><br><span class="line">/// @return (high-low) in seconds</span><br><span class="line">/// @c double has 52-bit precision, enough for one-microsecond</span><br><span class="line">/// resolution for next 100 years.</span><br><span class="line">inline double timeDifference(Timestamp high, Timestamp low)</span><br><span class="line">&#123;</span><br><span class="line">  int64_t diff = high.microSecondsSinceEpoch() - low.microSecondsSinceEpoch();</span><br><span class="line">  return static_cast&lt;double&gt;(diff) / Timestamp::kMicroSecondsPerSecond;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///</span><br><span class="line">/// Add @c seconds to given timestamp.</span><br><span class="line">///</span><br><span class="line">/// @return timestamp+seconds as Timestamp</span><br><span class="line">///</span><br><span class="line">inline Timestamp addTime(Timestamp timestamp, double seconds)</span><br><span class="line">&#123;</span><br><span class="line">  int64_t delta = static_cast&lt;int64_t&gt;(seconds * Timestamp::kMicroSecondsPerSecond);</span><br><span class="line">  return Timestamp(timestamp.microSecondsSinceEpoch() + delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_BASE_TIMESTAMP_H</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Timestamp-cc"><a href="#Timestamp-cc" class="headerlink" title="Timestamp.cc"></a>Timestamp.cc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Timestamp.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#ifndef __STDC_FORMAT_MACROS</span><br><span class="line">#define __STDC_FORMAT_MACROS</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#include &lt;inttypes.h&gt;//如果 __STDC_FORMAT_MACROS 宏未定义，就会将其定义为非零值，然后再包含 &lt;inttypes.h&gt; 头文件，从而确保特殊的格式化宏在代码中可用</span><br><span class="line"></span><br><span class="line">using namespace muduo;//是一个命名空间的使用声明语句。它的作用是将命名空间 muduo 中的所有符号（变量、函数、类等）引入到当前的代码作用域中，使得在代码中可以直接使用这些符号而无需显式指定命名空间前缀。</span><br><span class="line"></span><br><span class="line">static_assert(sizeof(Timestamp) == sizeof(int64_t),</span><br><span class="line">              &quot;Timestamp should be same size as int64_t&quot;);</span><br><span class="line">string Timestamp::toString() const</span><br><span class="line">&#123;</span><br><span class="line">  char buf[32] = &#123;0&#125;;</span><br><span class="line">  int64_t seconds = microSecondsSinceEpoch_ / kMicroSecondsPerSecond;</span><br><span class="line">  int64_t microseconds = microSecondsSinceEpoch_ % kMicroSecondsPerSecond;</span><br><span class="line">  snprintf(buf, sizeof(buf), &quot;%&quot; PRId64 &quot;.%06&quot; PRId64 &quot;&quot;, seconds, microseconds);</span><br><span class="line">  return buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string Timestamp::toFormattedString(bool showMicroseconds) const</span><br><span class="line">&#123;</span><br><span class="line">  char buf[64] = &#123;0&#125;;</span><br><span class="line">  time_t seconds = static_cast&lt;time_t&gt;(microSecondsSinceEpoch_ / kMicroSecondsPerSecond);</span><br><span class="line">  struct tm tm_time;</span><br><span class="line">  gmtime_r(&amp;seconds, &amp;tm_time);//gmtime_r 是 C 语言和 C++ 中的一个函数，用于将 Unix 时间戳（自 1970 年 1 月 1 日以来的秒数）转换为 UTC（协调世界时）时间的结构体表示。该函数的功能与 gmtime 类似，但具有线程安全的特性。</span><br><span class="line"></span><br><span class="line">  if (showMicroseconds)</span><br><span class="line">  &#123;</span><br><span class="line">    int microseconds = static_cast&lt;int&gt;(microSecondsSinceEpoch_ % kMicroSecondsPerSecond);</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%4d%02d%02d %02d:%02d:%02d.%06d&quot;,</span><br><span class="line">             tm_time.tm_year + 1900, tm_time.tm_mon + 1, tm_time.tm_mday,</span><br><span class="line">             tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec,</span><br><span class="line">             microseconds);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%4d%02d%02d %02d:%02d:%02d&quot;,</span><br><span class="line">             tm_time.tm_year + 1900, tm_time.tm_mon + 1, tm_time.tm_mday,</span><br><span class="line">             tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec);</span><br><span class="line">  &#125;</span><br><span class="line">  return buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Timestamp Timestamp::now()</span><br><span class="line">&#123;</span><br><span class="line">  struct timeval tv;</span><br><span class="line">  gettimeofday(&amp;tv, NULL);</span><br><span class="line">  int64_t seconds = tv.tv_sec;</span><br><span class="line">  return Timestamp(seconds * kMicroSecondsPerSecond + tv.tv_usec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">seconds * kMicroSecondsPerSecond + tv.tv_usec</span><br><span class="line">这是计算时间戳的微秒数部分。首先，将 seconds 中的秒数部分转换成微秒，即乘以 kMicroSecondsPerSecond，这个值等于 1,000,000，表示一秒有多少微秒。然后，将这个值与 tv.tv_usec 的微秒数部分相加，得到完整的时间戳的微秒数。</span><br><span class="line">return Timestamp(seconds * kMicroSecondsPerSecond + tv.tv_usec);</span><br><span class="line">最后，通过上述计算得到的完整时间戳的微秒数，创建一个 Timestamp 类的对象，并将其作为函数的返回值。</span><br><span class="line">这行代码的作用是获取当前时间，计算得到完整的时间戳（以微秒为单位），然后返回这个时间戳作为 Timestamp 类的对象。</span><br><span class="line">这个时间戳将用于创建一个 Timestamp 类的对象，并作为函数 Timestamp::now() 的返回值。所以该表达式实际上是用于计算返回值</span><br></pre></td></tr></table></figure>

<h3 id="Timestamp-unittest-cc"><a href="#Timestamp-unittest-cc" class="headerlink" title="Timestamp_unittest.cc"></a>Timestamp_unittest.cc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/Timestamp.h&quot;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using muduo::Timestamp;//它的作用是将命名空间 muduo 中的 Timestamp 类引入到当前的代码作用域中，使得在代码中可以直接使用 Timestamp 类而无需显式指定命名空间前缀</span><br><span class="line"></span><br><span class="line">void passByConstReference(const Timestamp&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;%s\n&quot;, x.toString().c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void passByValue(Timestamp x)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;%s\n&quot;, x.toString().c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void benchmark()</span><br><span class="line">&#123;</span><br><span class="line">  const int kNumber = 1000*1000;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;Timestamp&gt; stamps;</span><br><span class="line">  stamps.reserve(kNumber);</span><br><span class="line">  for (int i = 0; i &lt; kNumber; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    stamps.push_back(Timestamp::now());</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;%s\n&quot;, stamps.front().toString().c_str());</span><br><span class="line">  printf(&quot;%s\n&quot;, stamps.back().toString().c_str());</span><br><span class="line">  printf(&quot;%f\n&quot;, timeDifference(stamps.back(), stamps.front()));</span><br><span class="line"></span><br><span class="line">  int increments[100] = &#123; 0 &#125;;</span><br><span class="line">  int64_t start = stamps.front().microSecondsSinceEpoch();</span><br><span class="line">  for (int i = 1; i &lt; kNumber; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    int64_t next = stamps[i].microSecondsSinceEpoch();</span><br><span class="line">    int64_t inc = next - start;</span><br><span class="line">    start = next;</span><br><span class="line">    if (inc &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;reverse!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (inc &lt; 100)</span><br><span class="line">    &#123;</span><br><span class="line">      ++increments[inc];</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;big gap %d\n&quot;, static_cast&lt;int&gt;(inc));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for (int i = 0; i &lt; 100; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;%2d: %d\n&quot;, i, increments[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  Timestamp now(Timestamp::now());//这是一个对象的定义和初始化语句，它使用上述调用 now() 的结果来初始化一个名为 now 的 Timestamp 类对象。这里使用的是直接初始化的方式，通过调用 now() 函数得到的时间戳对象来初始化 now 对象</span><br><span class="line">  //相当于Timestamp now=Timestamp::now();调用拷贝构造函数初始化对象</span><br><span class="line">  printf(&quot;%s\n&quot;, now.toString().c_str());</span><br><span class="line">  passByValue(now);</span><br><span class="line">  passByConstReference(now);</span><br><span class="line">  benchmark();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tests下的CMake"><a href="#tests下的CMake" class="headerlink" title="tests下的CMake"></a>tests下的CMake</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_executable(timestamp_unittest Timestamp_unittest.cc)</span><br><span class="line">target_link_libraries(timestamp_unittest muduo_base)//target_link_libraries 命令用于将库（静态库或动态库）链接到目标（可执行文件或其他库）</span><br><span class="line">add_test(NAME timestamp_unittest COMMAND timestamp_unittest)</span><br></pre></td></tr></table></figure>

<h2 id="Atomic-h-执行原子性操作"><a href="#Atomic-h-执行原子性操作" class="headerlink" title="Atomic.h 执行原子性操作"></a>Atomic.h 执行原子性操作</h2><p>因为多线程用锁的话，是性能杀手，而原子性操作可以有同样效果，但是没有性能问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#ifndef MUDUO_BASE_ATOMIC_H</span><br><span class="line">#define MUDUO_BASE_ATOMIC_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/noncopyable.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">namespace detail</span><br><span class="line">&#123;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class AtomicIntegerT : noncopyable// noncopyable表示这个类不可拷贝的</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  AtomicIntegerT()</span><br><span class="line">    : value_(0)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // uncomment if you need copying and assignment</span><br><span class="line">  //复制构造函数用于创建一个新对象并将其初始化为传入对象的值</span><br><span class="line">  // AtomicIntegerT(const AtomicIntegerT&amp; that)</span><br><span class="line">  //   : value_(that.get())</span><br><span class="line">  // &#123;&#125;</span><br><span class="line">  //</span><br><span class="line">  // AtomicIntegerT&amp; operator=(const AtomicIntegerT&amp; that)//把等号运算符做成私有的</span><br><span class="line">  // &#123;</span><br><span class="line">  //   getAndSet(that.get());</span><br><span class="line">  //   return *this;</span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line">  T get()//原子地比较指定变量的值和期望值，如果相等则将该变量的值设置为新的值，并返回操作之前的值</span><br><span class="line">  &#123;</span><br><span class="line">    // in gcc &gt;= 4.7: __atomic_load_n(&amp;value_, __ATOMIC_SEQ_CST)</span><br><span class="line">    return __sync_val_compare_and_swap(&amp;value_, 0, 0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T getAndAdd(T x)//原子地将指定变量的值加上一个增量，并返回变量加增量后的结果</span><br><span class="line">  &#123;</span><br><span class="line">    // in gcc &gt;= 4.7: __atomic_fetch_add(&amp;value_, x, __ATOMIC_SEQ_CST)</span><br><span class="line">    return __sync_fetch_and_add(&amp;value_, x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T addAndGet(T x)</span><br><span class="line">  &#123;</span><br><span class="line">    return getAndAdd(x) + x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T incrementAndGet()</span><br><span class="line">  &#123;</span><br><span class="line">    return addAndGet(1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T decrementAndGet()</span><br><span class="line">  &#123;</span><br><span class="line">    return addAndGet(-1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void add(T x)</span><br><span class="line">  &#123;</span><br><span class="line">    getAndAdd(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void increment()</span><br><span class="line">  &#123;</span><br><span class="line">    incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void decrement()</span><br><span class="line">  &#123;</span><br><span class="line">    decrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T getAndSet(T newValue)</span><br><span class="line">  &#123;</span><br><span class="line">    // in gcc &gt;= 4.7: __atomic_exchange_n(&amp;value_, newValue, __ATOMIC_SEQ_CST)</span><br><span class="line">    return __sync_lock_test_and_set(&amp;value_, newValue);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  volatile T value_;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  // namespace detail</span><br><span class="line"></span><br><span class="line">typedef detail::AtomicIntegerT&lt;int32_t&gt; AtomicInt32;</span><br><span class="line">typedef detail::AtomicIntegerT&lt;int64_t&gt; AtomicInt64;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_BASE_ATOMIC_H</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在c++11下有更新</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;atomic&gt;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class AtomicIntegerT : noncopyable</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    AtomicIntegerT()</span><br><span class="line">        : value_(0)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T get()</span><br><span class="line">    &#123;</span><br><span class="line">        return value_.load(std::memory_order_seq_cst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T getAndAdd(T x)</span><br><span class="line">    &#123;</span><br><span class="line">        return value_.fetch_add(x, std::memory_order_seq_cst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T addAndGet(T x)</span><br><span class="line">    &#123;</span><br><span class="line">        return getAndAdd(x) + x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T incrementAndGet()</span><br><span class="line">    &#123;</span><br><span class="line">        return addAndGet(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T decrementAndGet()</span><br><span class="line">    &#123;</span><br><span class="line">        return addAndGet(-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void add(T x)</span><br><span class="line">    &#123;</span><br><span class="line">        getAndAdd(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void increment()</span><br><span class="line">    &#123;</span><br><span class="line">        incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void decrement()</span><br><span class="line">    &#123;</span><br><span class="line">        decrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T getAndSet(T newValue)</span><br><span class="line">    &#123;</span><br><span class="line">        return value_.exchange(newValue, std::memory_order_seq_cst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::atomic&lt;T&gt; value_;//具有volatile特性</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="测试文件Atomic-test-cc"><a href="#测试文件Atomic-test-cc" class="headerlink" title="测试文件Atomic_test.cc"></a>测试文件Atomic_test.cc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/Atomic.h&quot;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  &#123;</span><br><span class="line">  muduo::AtomicInt64 a0;</span><br><span class="line">  assert(a0.get() == 0);</span><br><span class="line">  assert(a0.getAndAdd(1) == 0);</span><br><span class="line">  assert(a0.get() == 1);</span><br><span class="line">  assert(a0.addAndGet(2) == 3);</span><br><span class="line">  assert(a0.get() == 3);</span><br><span class="line">  assert(a0.incrementAndGet() == 4);</span><br><span class="line">  assert(a0.get() == 4);</span><br><span class="line">  a0.increment();</span><br><span class="line">  assert(a0.get() == 5);</span><br><span class="line">  assert(a0.addAndGet(-3) == 2);</span><br><span class="line">  assert(a0.getAndSet(100) == 2);</span><br><span class="line">  assert(a0.get() == 100);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">  muduo::AtomicInt32 a1;</span><br><span class="line">  assert(a1.get() == 0);</span><br><span class="line">  assert(a1.getAndAdd(1) == 0);</span><br><span class="line">  assert(a1.get() == 1);</span><br><span class="line">  assert(a1.addAndGet(2) == 3);</span><br><span class="line">  assert(a1.get() == 3);</span><br><span class="line">  assert(a1.incrementAndGet() == 4);</span><br><span class="line">  assert(a1.get() == 4);</span><br><span class="line">  a1.increment();</span><br><span class="line">  assert(a1.get() == 5);</span><br><span class="line">  assert(a1.addAndGet(-3) == 2);</span><br><span class="line">  assert(a1.getAndSet(100) == 2);</span><br><span class="line">  assert(a1.get() == 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在tests下的CMake里不需要target_link_libraries，因为它没有编译静态库</span><br></pre></td></tr></table></figure>

<h3 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h3><p><img src="/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230731161906596.png" alt="image-20230731161906596"></p>
<h3 id="Types-h"><a href="#Types-h" class="headerlink" title="Types.h"></a>Types.h</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename To, typename From&gt;</span><br><span class="line">inline To implicit_cast(From const &amp;f)//隐式转换</span><br><span class="line">&#123;</span><br><span class="line">  return f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>好处是可以在没有前面代码的基础下能看懂是隐式转换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename To, typename From&gt;     // use like this: down_cast&lt;T*&gt;(foo);</span><br><span class="line">inline To down_cast(From* f)                     // so we only accept pointers</span><br><span class="line">&#123;//向下转型的函数</span><br><span class="line">  // Ensures that To is a sub-type of From *.  This test is here only</span><br><span class="line">  // for compile-time type checking, and has no overhead in an</span><br><span class="line">  // optimized build at run-time, as it will be optimized away</span><br><span class="line">  // completely.</span><br><span class="line">  if (false)</span><br><span class="line">  &#123;</span><br><span class="line">    implicit_cast&lt;From*, To&gt;(0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">#if !defined(NDEBUG) &amp;&amp; !defined(GOOGLE_PROTOBUF_NO_RTTI)</span><br><span class="line">  assert(f == NULL || dynamic_cast&lt;To&gt;(f) != NULL);  // RTTI: debug mode only!</span><br><span class="line">#endif</span><br><span class="line">  return static_cast&lt;To&gt;(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异常Exception封装"><a href="#异常Exception封装" class="headerlink" title="异常Exception封装"></a>异常Exception封装</h2><p>Exception类实现</p>
<ul>
<li><p>backtrace，栈回溯，保存各个栈帧的地址</p>
</li>
<li><p>backtrace_symbols，根据地址，转成相应的函数符号</p>
</li>
<li><p>abi: :__cxa_demangle,我这里使用了将<code>demangle</code>参数设置为ture可以进行符号解析以得到更具可读性的堆栈信息</p>
</li>
</ul>
<h3 id="Exception-h"><a href="#Exception-h" class="headerlink" title="Exception.h"></a>Exception.h</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#ifndef MUDUO_BASE_EXCEPTION_H</span><br><span class="line">#define MUDUO_BASE_EXCEPTION_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Types.h&quot;</span><br><span class="line">#include &lt;exception&gt;  </span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">class Exception : public std::exception</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  Exception(string what);</span><br><span class="line">  ~Exception() noexcept override = default;</span><br><span class="line"></span><br><span class="line">  // default copy-ctor and operator= are okay.</span><br><span class="line"></span><br><span class="line">  const char* what() const noexcept override</span><br><span class="line">  &#123;</span><br><span class="line">    return message_.c_str();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const char* stackTrace() const noexcept</span><br><span class="line">  //const 关键字在函数名后面表示该函数是一个常量成员函数。而 noexcept 关键字则表示该函数不会抛出异常</span><br><span class="line">  &#123;</span><br><span class="line">    return stack_.c_str();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  string message_;</span><br><span class="line">  string stack_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_BASE_EXCEPTION_H</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Exception-cc"><a href="#Exception-cc" class="headerlink" title="Exception.cc"></a>Exception.cc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Exception.h&quot;</span><br><span class="line">#include &quot;muduo/base/CurrentThread.h&quot;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Exception::Exception(string msg)</span><br><span class="line">  : message_(std::move(msg)),//std::move用于实现右值引用（rvalue reference）。它将一个左值（lvalue）强制转换为右值引用，从而可以实现移动语义，减少不必要的拷贝，提高代码的性能</span><br><span class="line">    stack_(CurrentThread::stackTrace(/*demangle=*/false))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>stack_(CurrentThread::stackTrace(/*demangle=*/false))</code>这行代码是在构造<code>Exception</code>对象时调用<code>stackTrace</code>函数，并将返回的字符串作为参数传递给<code>stack_</code>成员变量。</p>
<p>具体调用过程如下：</p>
<ol>
<li>在<code>Exception</code>类的构造函数中，使用<code>std::move(msg)</code>将传入的<code>msg</code>字符串初始化<code>message_</code>成员变量。</li>
<li>接着，调用<code>CurrentThread::stackTrace(/*demangle=*/false)</code>函数，获取当前线程的堆栈信息，<code>demangle</code>参数设置为<code>false</code>表示不需要进行符号解析（mangling）。</li>
<li><code>stackTrace</code>函数首先声明了一个字符串<code>stack</code>，用于存储堆栈信息。</li>
<li>接下来，通过<code>::backtrace()</code>函数获取当前线程的调用堆栈帧，并将返回的帧指针数组存储在<code>frame</code>中。</li>
<li>使用<code>::backtrace_symbols()</code>函数将帧指针数组转换为可读的字符串数组<code>strings</code>，每个字符串表示一个堆栈帧的信息。</li>
<li>然后，函数进入一个循环，遍历堆栈帧，处理每个帧的信息。</li>
<li>如果<code>demangle</code>为<code>true</code>，则尝试对符号进行解析，以得到可读的函数名和地址信息。这里使用<code>abi::__cxa_demangle()</code>进行符号解析。</li>
<li>解析得到的字符串会与原始的堆栈帧信息拼接，然后添加到<code>stack</code>字符串中，并添加一个换行符。</li>
<li>如果<code>demangle</code>为<code>false</code>或解析失败，将使用原始的堆栈帧信息添加到<code>stack</code>字符串中，并添加一个换行符。</li>
<li>最后，返回拼接好的<code>stack</code>字符串作为函数的返回值。</li>
<li>这个返回的字符串将被用来初始化<code>Exception</code>对象的<code>stack_</code>成员变量。</li>
</ol>
<p>总结：<code>stack_(CurrentThread::stackTrace(/*demangle=*/false))</code>调用了<code>stackTrace</code>函数并将返回的字符串作为堆栈信息赋值给<code>stack_</code>成员变量。</p>
<h3 id="CurrentThread-cc"><a href="#CurrentThread-cc" class="headerlink" title="CurrentThread.cc"></a>CurrentThread.cc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">string stackTrace(bool demangle)</span><br><span class="line">&#123;</span><br><span class="line">  string stack;</span><br><span class="line">  const int max_frames = 200;</span><br><span class="line">  void* frame[max_frames];</span><br><span class="line">  int nptrs = ::backtrace(frame, max_frames);</span><br><span class="line">  char** strings = ::backtrace_symbols(frame, nptrs);</span><br><span class="line">  if (strings)</span><br><span class="line">  &#123;</span><br><span class="line">    size_t len = 256;</span><br><span class="line">    char* demangled = demangle ? static_cast&lt;char*&gt;(::malloc(len)) : nullptr;</span><br><span class="line">    for (int i = 1; i &lt; nptrs; ++i)  // skipping the 0-th, which is this function</span><br><span class="line">    &#123;</span><br><span class="line">      if (demangle)</span><br><span class="line">      &#123;</span><br><span class="line">        // https://panthema.net/2008/0901-stacktrace-demangled/</span><br><span class="line">        // bin/exception_test(_ZN3Bar4testEv+0x79) [0x401909]</span><br><span class="line">        char* left_par = nullptr;</span><br><span class="line">        char* plus = nullptr;</span><br><span class="line">        for (char* p = strings[i]; *p; ++p)</span><br><span class="line">        &#123;</span><br><span class="line">          if (*p == &#x27;(&#x27;)</span><br><span class="line">            left_par = p;</span><br><span class="line">          else if (*p == &#x27;+&#x27;)</span><br><span class="line">            plus = p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (left_par &amp;&amp; plus)</span><br><span class="line">        &#123;</span><br><span class="line">          *plus = &#x27;\0&#x27;;</span><br><span class="line">          int status = 0;</span><br><span class="line">          char* ret = abi::__cxa_demangle(left_par+1, demangled, &amp;len, &amp;status);</span><br><span class="line">          *plus = &#x27;+&#x27;;</span><br><span class="line">          if (status == 0)</span><br><span class="line">          &#123;</span><br><span class="line">            demangled = ret;  // ret could be realloc()</span><br><span class="line">            stack.append(strings[i], left_par+1);</span><br><span class="line">            stack.append(demangled);</span><br><span class="line">            stack.append(plus);</span><br><span class="line">            stack.push_back(&#x27;\n&#x27;);</span><br><span class="line">            continue;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // Fallback to mangled names</span><br><span class="line">      stack.append(strings[i]);</span><br><span class="line">      stack.push_back(&#x27;\n&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    free(demangled);</span><br><span class="line">    free(strings);</span><br><span class="line">  &#125;</span><br><span class="line">  return stack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在C++中，双冒号<code>::</code>被用于两个主要目的：</p>
<ol>
<li>表示全局命名空间：在全局作用域中，<code>::</code>表示全局命名空间，例如<code>::function_name()</code>表示调用全局命名空间中的函数<code>function_name</code>。</li>
<li>限定类的作用域：在类的作用域中，<code>::</code>可以用于限定类的作用域，例如<code>Class::member_function()</code>表示调用类<code>Class</code>的成员函数<code>member_function</code>。</li>
</ol>
<p>对于<code>::backtrace()</code>这个函数，它不属于任何特定的类，所以双冒号<code>::</code>表示全局命名空间，这样可以在全局范围内调用<code>backtrace</code>函数。</p>
<h3 id="Exception-test-cc"><a href="#Exception-test-cc" class="headerlink" title="Exception_test.cc"></a>Exception_test.cc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/CurrentThread.h&quot;</span><br><span class="line">#include &quot;muduo/base/Exception.h&quot;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">class Bar</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  void test(std::vector&lt;std::string&gt; names = &#123;&#125;)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Stack:\n%s\n&quot;, muduo::CurrentThread::stackTrace(true).c_str());</span><br><span class="line">    [] &#123;</span><br><span class="line">      printf(&quot;Stack inside lambda:\n%s\n&quot;, muduo::CurrentThread::stackTrace(true).c_str());</span><br><span class="line">    &#125;();</span><br><span class="line">    std::function&lt;void()&gt; func([] &#123;</span><br><span class="line">      printf(&quot;Stack inside std::function:\n%s\n&quot;, muduo::CurrentThread::stackTrace(true).c_str());</span><br><span class="line">    &#125;);</span><br><span class="line">    func();</span><br><span class="line"></span><br><span class="line">    func = std::bind(&amp;Bar::callback, this);</span><br><span class="line">    func();</span><br><span class="line"></span><br><span class="line">    throw muduo::Exception(&quot;oops&quot;);</span><br><span class="line">    //会创建一个 muduo::Exception 类型的异常对象，并将其抛出。然后程序会搜索调用栈，查找适合处理该异常的异常处理代码。如果找不到合适的处理代码，程序将终止并显示异常信息，跳转到下面catch</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">   void callback()</span><br><span class="line">   &#123;</span><br><span class="line">     printf(&quot;Stack inside std::bind:\n%s\n&quot;, muduo::CurrentThread::stackTrace(true).c_str());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void foo()</span><br><span class="line">&#123;</span><br><span class="line">  Bar b;</span><br><span class="line">  b.test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  try</span><br><span class="line">  &#123;</span><br><span class="line">    foo();</span><br><span class="line">  &#125;</span><br><span class="line">  catch (const muduo::Exception&amp; ex)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;reason: %s\n&quot;, ex.what());</span><br><span class="line">    printf(&quot;stack trace:\n%s\n&quot;, ex.stackTrace());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230801150628949.png" alt="image-20230801150628949"></p>
<img src="/2023/08/01/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230801150628949.png" class title="This is an test image">

<p>对throw muduo::Exception(“oops”);的理解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // 可能抛出异常的代码块</span><br><span class="line">    // ...</span><br><span class="line">    throw SomeException(&quot;Error message&quot;); // 抛出异常</span><br><span class="line">    // ...</span><br><span class="line">&#125; catch (const SomeException&amp; ex) &#123;</span><br><span class="line">    // 处理异常的代码块</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/27/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/27/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-1/" class="post-title-link" itemprop="url">muduo-1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-27 16:19:27" itemprop="dateCreated datePublished" datetime="2023-07-27T16:19:27+08:00">2023-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-08 15:15:42" itemprop="dateModified" datetime="2023-08-08T15:15:42+08:00">2023-08-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="高并发高性能服务器的一些思路"><a href="#高并发高性能服务器的一些思路" class="headerlink" title="高并发高性能服务器的一些思路"></a>高并发高性能服务器的一些思路</h1><p>队列+连接池<br>主要的业务逻辑挪到应用服务器处理，数据库只做辅助的业务处理</p>
<p>缓存<br>缓存更新(缓存同步)缓存time out<br>如果缓存失效重新去数据库查询，实时性比较差<br>一但数据库中数据更新，立即通知前端的缓存更新，实时性比较高。<br>缓存换页内存不够，将不活跃的数据换出内存。一些算法FIFO LRU(least recently used)(最近最少使用)LFU(least frequently used）最不频繁使用</p>
<p>nosql(反sql) key &#x2F; value非关系型数据库<br>分布式缓存<br>redis<br>mencached</p>
<p>数据库读写分离，可以避免锁竞争，提高访问速度</p>
<p>主从服务器</p>
<p>数据库的读操作&gt;写操作<br>对数据库进行负载均衡 replication机制，即写会同步更新到读库<br>比如数据分区(分库、分表)<br>分库 垂直分区     水平分区，更好用，每个类型的数据都有，更好扩展，需要增加一个数据访问层DAL</p>
<p>应用服务器的负载均衡<br>增加一个任务服务器来实现，任务服务器可以监视应用服务器的负载，CPU高、I0高、并发高、内存换页高查询到这些信息之后，选取负载最低的服务器分配任务。应用服务器被动接收任务，不公平，任务处理速度不同。</p>
<p>应用服务器主动到任务服务器接收任务进行处理，即空闲主动。</p>
<p><img src="/muduo-1/image-20230727162947044.png" alt="image-20230727162947044"></p>
<img src="/2023/07/27/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-1/image-20230727162947044.png" class title="This is an test image">

<p>服务器性能四大杀手</p>
<ul>
<li>数据拷贝		缓存</li>
<li>环境切换	（理性创建线程)该不该用多线程，单线程好还是多线程好，单核服务器（采用状态机编程，效率最佳，不能并行处理任务，相当于操作系统的进程切换，cpu时间分享给多个进程)，多线程能够充分发挥多核服务器的性能，大量的任务提交到服务器时多线程也不能保证并发，这时候线程间的切换开销大</li>
<li>内存分配		内存池</li>
<li>锁竞争</li>
</ul>
<h1 id="大型网站架构演变过程"><a href="#大型网站架构演变过程" class="headerlink" title="大型网站架构演变过程"></a>大型网站架构演变过程</h1><h2 id="第一步-web-server与数据库分离"><a href="#第一步-web-server与数据库分离" class="headerlink" title="第一步 web server与数据库分离"></a>第一步 web server与数据库分离</h2><p><img src="/muduo-1/image-20230727202043348.png" alt="image-20230727202043348"></p>
<img src="/2023/07/27/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-1/image-20230727202043348.png" class title="This is an test image">

<p><img src="/muduo-1/image-20230727202141040.png" alt="image-20230727202141040"></p>
<img src="/2023/07/27/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-1/image-20230727202141040.png" class title="This is an test image">

<h2 id="第二部-缓存处理"><a href="#第二部-缓存处理" class="headerlink" title="第二部 缓存处理"></a>第二部 缓存处理</h2><p><img src="/muduo-1/image-20230727202250355.png" alt="image-20230727202250355"></p>
<img src="/2023/07/27/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-1/image-20230727202250355.png" class title="This is an test image">

<p>front page cache静态页面</p>
<h2 id="第三步-web-server集群-读写分离"><a href="#第三步-web-server集群-读写分离" class="headerlink" title="第三步 web server集群+读写分离"></a>第三步 web server集群+读写分离</h2><p><img src="/muduo-1/image-20230727202523487.png" alt="image-20230727202523487"></p>
<img src="/2023/07/27/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-1/image-20230727202523487.png" class title="This is an test image">

<h2 id="第四步-CDN、分布式缓存、分库分表"><a href="#第四步-CDN、分布式缓存、分库分表" class="headerlink" title="第四步 CDN、分布式缓存、分库分表"></a>第四步 CDN、分布式缓存、分库分表</h2><p>CDN:内容分发网络</p>
<p>不同地区网络速度都得到提升</p>
<p>目前流行分布式缓存方案:memcached、membase、redis等,基本上当前的NoSQL方案都可以用来做分布式缓存方案</p>
<h2 id="第五步-多数据中心-分布式存储与计算"><a href="#第五步-多数据中心-分布式存储与计算" class="headerlink" title="第五步 多数据中心+分布式存储与计算"></a>第五步 多数据中心+分布式存储与计算</h2><p>对一致性要求不高的没必要保存在关系型数据库</p>
<p><img src="/muduo-1/image-20230727203310555.png" alt="image-20230727203310555"></p>
<img src="/2023/07/27/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-1/image-20230727203310555.png" class title="This is an test image">

<p>虽然这个本质是b&#x2F;s架构，但是核心本质还是c&#x2F;s，用到socket</p>
<p><img src="/muduo-1/image-20230727203423819.png" alt="image-20230727203423819"></p>
<img src="/2023/07/27/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-1/image-20230727203423819.png" class title="This is an test image">

<h1 id="cmake管理过程"><a href="#cmake管理过程" class="headerlink" title="cmake管理过程"></a>cmake管理过程</h1><p>用 <code>build.sh</code> 脚本来进行 CMake 构建。假设项目结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">muduo_test/</span><br><span class="line">	|-build/</span><br><span class="line">		|-bin</span><br><span class="line">	|- build.sh</span><br><span class="line">    |- CMakeLists.txt</span><br><span class="line">    |- src/</span><br><span class="line">         |- bf_test.cpp</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来，我们将依次执行以下步骤：</p>
<ol>
<li>创建 <code>bf_test.cpp</code> 文件并放入 <code>muduo_test/src/</code> 目录下。</li>
<li>编写 <code>CMakeLists.txt</code> 文件用于构建 <code>bf_test.cpp</code>。</li>
<li>创建 <code>build.sh</code> 脚本用于执行 CMake 构建，并将生成的可执行文件放入 <code>muduo_test/build/bin/</code> 目录下。</li>
</ol>
<p>首先，让我们创建 <code>bf_test.cpp</code> 文件。你可以使用编辑器（如 <code>nano</code>、<code>vim</code> 或其他文本编辑器）创建该文件，并将以下内容复制到 <code>bf_test.cpp</code> 中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// bf_test.cpp</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, muduo_test!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，创建 <code>CMakeLists.txt</code> 文件。在 <code>muduo_test/</code> 目录下创建一个名为 <code>CMakeLists.txt</code> 的文件，并将以下内容复制到其中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.10)  # 指定 CMake 最低版本要求</span><br><span class="line">#project() 命令用于定义一个项目。project() 命令的第一个参数是项目的名称，而第二个参数是可选的，用于指定所用的编程语言。</span><br><span class="line">project(muduo_test CXX)  # 设置项目名称，与你的项目名称相同</span><br><span class="line">set(CXX_FLAGS -g -Wall)# 设置编译选项</span><br><span class="line">set(CMAKE_CXX_COMPILER &quot;g++&quot;)# 设置C++编译器为g++</span><br><span class="line"></span><br><span class="line">set(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/bin)# 设置可执行文件输出路径</span><br><span class="line">add_executable(bf_test src/bf_test.cpp)# 添加可执行文件</span><br></pre></td></tr></table></figure>

<p>接下来，编写 <code>build.sh</code> 脚本。确保将脚本放在 <code>muduo_test/</code> 同级目录下，并给予执行权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">set -x</span><br><span class="line"></span><br><span class="line">SOURCE_DIR=$(pwd)</span><br><span class="line">BUILD_DIR=$&#123;SOURCE_DIR&#125;/build</span><br><span class="line"></span><br><span class="line">mkdir -p $BUILD_DIR \</span><br><span class="line">   &amp;&amp; cd $BUILD_DIR \</span><br><span class="line">   &amp;&amp; cmake $SOURCE_DIR \</span><br><span class="line">   &amp;&amp; make $*</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在我们已经准备好一切。并在终端中给予脚本执行权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x build.sh</span><br></pre></td></tr></table></figure>

<p>最后，运行 <code>./build.sh</code> 脚本来进行 CMake 构建：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build.sh</span><br></pre></td></tr></table></figure>

<p>脚本将在 <code>muduo_test/</code> 目录下创建一个名为 <code>build</code> 的目录，并在其中执行 CMake 和 Makefile 构建。然后，生成的可执行文件 <code>bf_test</code> 将被移动到 <code>muduo_test/build/bin/</code> 目录下。</p>
<p>运行 <code>./build/bin/bf_test</code> 即可看到输出</p>
<p>运行<code>./build.sh clean</code> 相当于<code>make clean</code></p>
<h1 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h1><h2 id="LT"><a href="#LT" class="headerlink" title="LT"></a>LT</h2><p>如果内核缓冲区不够了，将未发完的数据添加到应用缓冲区outbuffer,等到内核有空余时就会有connfd的EPOLLOUT事件，如果内核没有数据可以取，却在关注EPOLLOUT事件，就会出现忙等待。</p>
<p><img src="/muduo-1/image-20230728115359271.png" alt="image-20230728115359271"></p>
<img src="/2023/07/27/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-1/image-20230728115359271.png" class title="This is an test image">

<p>后面都采用LT模式</p>
<h2 id="ET"><a href="#ET" class="headerlink" title="ET"></a>ET</h2><p><img src="/muduo-1/image-20230728120915832.png" alt="image-20230728120915832"></p>
<img src="/2023/07/27/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-1/image-20230728120915832.png" class title="This is an test image">

<p>因为是电平触发，所有一开始就关注EPOLLOUT事件，EAGAIN如果数据未满，应用缓冲区发送给内核，相当于一直高电平，那么就一直不发送了，填满内核，变为低电平状态，如果被接受，就会变成高电平。</p>
<p>EMFILE状态，如果有connfd，返回失败，一直处于高电平，则后面的都接受不了，所以需要人为控制</p>
<h1 id="面向对象编程风格"><a href="#面向对象编程风格" class="headerlink" title="面向对象编程风格"></a>面向对象编程风格</h1><p>继承实现，将基类虚函数实现放到派生类函数来实现，这样调用基类虚函数，会自动调用派生类函数，比如下面的Run函数</p>
<p>Thread.h</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Thread&#123;</span><br><span class="line">public:</span><br><span class="line">	Thread():autoDelete_(false);</span><br><span class="line">	virtual ~Thread()=default;//因为多态的性质决定,是一个虚析构函数</span><br><span class="line">	void Start();</span><br><span class="line">	void Join();</span><br><span class="line">	void SetAutoDelate(bool autoDelete);</span><br><span class="line">	</span><br><span class="line">private:</span><br><span class="line">	static void* ThreadRoutine(void* arg);</span><br><span class="line">	virtual void Run()=0;	</span><br><span class="line">	pthread_t id_;</span><br><span class="line">	bool autoDelete_;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Thread.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Thread::Thread()&#123;</span><br><span class="line">	cout&lt;&lt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Thread::Start()&#123;</span><br><span class="line">	pthread_creat(&amp;id,NULL,ThreadRoutine,this);//this 指向正在创建的 Thread_test 对象。这样，在启动线程时，会在新线程中调用 Thread_test 对象的 Run() 函数</span><br><span class="line">&#125;</span><br><span class="line">void Thread::Join()&#123;</span><br><span class="line">	p_join(id,NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void*  Thread::ThreadRoutine(void* arg)&#123;//静态函数不能调用非静态函数，所以重新th,调用th的Run函数</span><br><span class="line">	thread* th=static_cast&lt;Thread*&gt;(arg);</span><br><span class="line">	th-&gt;Run;</span><br><span class="line">	if(th-&gt;autoDelete_)</span><br><span class="line">		delete th;</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Thread::SetAutoDelate(bool autoDelete)&#123;</span><br><span class="line">	autoDelete_=autoDelete;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Thread_test.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Thread_test: public Thread&#123;</span><br><span class="line">public:</span><br><span class="line">	thread(count):count_(count)&#123;</span><br><span class="line">		cout&lt;&lt;</span><br><span class="line">	&#125;</span><br><span class="line">		~thread()&#123;//派生类如果没有显式地定义析构函数，派生类会继承基类的虚析构函数</span><br><span class="line">		//通过继承基类的虚析构函数，派生类可以保证在销毁对象时正确调用基类和派生类的析构函数，实现正确的资源清理</span><br><span class="line">		cout</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	private:</span><br><span class="line">	void Run()&#123;//私有纯虚函数不能直接在派生类中调用，但是可以通过在派生类中重新声明并实现这些函数，并间接地通过公有函数或其他函数来调用。这样，派生类就能够满足基类的接口要求。</span><br><span class="line">	//派生类必须重新实现基类的纯虚函数，但是在基类中调用纯虚函数时，实际上会调用派生类的实现</span><br><span class="line">		while (count_--)&#123;</span><br><span class="line">			cout&lt;&lt;&quot;&quot;this is a test -..&quot;&lt;&lt;endl;</span><br><span class="line">			sleep(1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int count_ ;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	Thread_test t2 = new Thread_test(5);</span><br><span class="line">	t2-&gt;SetAutoDelate(true);</span><br><span class="line">	t2-&gt;Start();</span><br><span class="line">	t2-&gt;Join();</span><br><span class="line">	for (; ; )</span><br><span class="line">		pause();</span><br><span class="line">	return 8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果基类的run函数变为public，在main函数调用t2-&gt;Run(),则表示在主线程运行。</p>
<h1 id="基于对象编程风格"><a href="#基于对象编程风格" class="headerlink" title="基于对象编程风格"></a>基于对象编程风格</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;boost/function.hpp&gt;</span><br><span class="line">#include &lt;boost/bind.hpp&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Foo</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	void memberFunc(double d, int i, int j)&#123;</span><br><span class="line">		cout &lt;&lt;d&lt;&lt;endl;//打印0.5</span><br><span class="line">		cout &lt;&lt;i &lt;&lt;endl;//打印100</span><br><span class="line">		cout &lt;&lt;j &lt;&lt;endl;//打印10</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">	Foo foo;</span><br><span class="line">	boost::function&lt;void (int)&gt; fp = boost::bind(&amp;Foo::memberFunc,&amp;foo,0.5,_1,10);</span><br><span class="line">	//将Foo的memberFunc(double d, int i, int j)类的成员函数适配成void fp(int)，_1或_加数字表示占位，&amp;不能省略</span><br><span class="line">	fp(100);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>boost bind&#x2F;function库的出现，替代了stl中的mem fun,ptr fun,bind1 st,bin2nd等函数,相当于函数适配器</p>
<p>在 C++ 中，成员函数指针和普通函数指针有一些区别。在使用 <code>boost::bind</code> 绑定成员函数时，需要显式地使用 <code>&amp;</code> 来获得成员函数的地址，而普通函数则不需要。</p>
<p>这是因为在 C++ 中，成员函数有一个隐藏的额外参数，即指向调用成员函数的对象的指针（即 <code>this</code> 指针）。当你使用 <code>&amp;Foo::memberFunc</code> 时，它实际上获取了成员函数 <code>memberFunc</code> 的地址，包括了这个隐藏的 <code>this</code> 指针。所以，通过 <code>&amp;Foo::memberFunc</code> 可以正确地获得成员函数的指针。</p>
<p>然而，对于普通函数，不涉及到隐藏的 <code>this</code> 指针，因此在使用 <code>boost::bind</code> 绑定普通函数时，不需要显式使用 <code>&amp;</code> 来获取函数的地址。</p>
<p>综上所述：</p>
<ul>
<li>对于成员函数，使用 <code>&amp;</code> 是必需的，以获得成员函数的指针，包括隐藏的 <code>this</code> 指针。</li>
<li>对于普通函数，不需要使用 <code>&amp;</code>，因为它们没有隐藏的 <code>this</code> 指针。</li>
</ul>
<p>注意：在 C++11 及以后的标准中，可以使用更现代的方式来绑定函数和成员函数，例如使用 lambda 表达式或 <code>std::bind</code>。这些方法在使用语法上更加简洁和直观。</p>
<p>Thread.h</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Thread&#123;</span><br><span class="line">public:</span><br><span class="line">	typedef boost::function&lt;void ()&gt; ThreadFunc;</span><br><span class="line">	explicit Thread(const ThreadFunc&amp; func);	</span><br><span class="line">	void Start();</span><br><span class="line">	void Join();</span><br><span class="line">	void SetAutoDelate(bool autoDelete);</span><br><span class="line">	</span><br><span class="line">private:</span><br><span class="line">	static void* ThreadRoutine(void* arg);</span><br><span class="line">	void Run();</span><br><span class="line">    ThreadFunc func_;</span><br><span class="line">	pthread_t id_;</span><br><span class="line">	bool autoDelete_;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Thread.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Thread::Thread(const ThreadFunc&amp; func):func_(func),autoDelete_(false)&#123;</span><br><span class="line">	cout&lt;&lt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Thread::Start()&#123;</span><br><span class="line">	pthread_creat(&amp;id,NULL,ThreadRoutine,this);</span><br><span class="line">&#125;</span><br><span class="line">void Thread::Join()&#123;</span><br><span class="line">	p_join(id,NULL);</span><br><span class="line">&#125;</span><br><span class="line">void*  Thread::ThreadRoutine(void* arg)&#123;</span><br><span class="line">	thread* th=static_cast&lt;Thread*&gt;(arg);</span><br><span class="line">	th-&gt;Run;</span><br><span class="line">	if(th-&gt;autoDelete_)</span><br><span class="line">		delete th;</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Thread::Run()&#123;</span><br><span class="line">		func_();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Thread::SetAutoDelate(bool autoDelete)&#123;</span><br><span class="line">	autoDelete_=autoDelete;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Thread_test.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void func(int count)&#123;</span><br><span class="line">	while(--count)&#123;</span><br><span class="line">	cout&lt;&lt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br><span class="line">	</span><br><span class="line">int main()&#123;</span><br><span class="line">	Thread t2(boost::bind(func,3));//利用bind适配，</span><br><span class="line">	t2-&gt;SetAutoDelate(true);</span><br><span class="line">	t2-&gt;Start();</span><br><span class="line">	t2-&gt;Join();</span><br><span class="line">	</span><br><span class="line">	return 8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在C++中，<code>explicit</code>是一个关键字，通常用于修饰单参数的构造函数，用于防止隐式类型转换。当一个构造函数被标记为<code>explicit</code>时，在使用该构造函数进行对象初始化时，编译器不会自动执行隐式的类型转换。</p>
<p>考虑以下示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">public:</span><br><span class="line">    explicit MyClass(int x) &#123;</span><br><span class="line">        // Constructor code</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    MyClass obj1(10);  // 正确，直接调用构造函数</span><br><span class="line">    MyClass obj2 = 20; // 错误，因为构造函数被声明为explicit，禁止隐式类型转换</span><br><span class="line">    //MyClass obj2 = 20;语句试图将一个int类型的整数值20隐式转换为MyClass类型的对象。然而，由于MyClass的构造函数被声明为explicit，编译器不会自动执行这种类型转换</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>MyClass</code>拥有一个带有<code>int</code>参数的构造函数，并且该构造函数被标记为<code>explicit</code>。在<code>main()</code>函数中，创建<code>obj1</code>对象时直接调用了构造函数，这是正确的。然而，在尝试将整数值20赋值给<code>obj2</code>对象时，由于构造函数被声明为<code>explicit</code>，编译器会报错，不允许隐式类型转换。</p>
<p>通过使用<code>explicit</code>关键字，可以防止意外的类型转换，增加代码的清晰性和安全性。不让代码超出预期。</p>
<p><img src="/muduo-1/image-20230729212329032.png" alt="image-20230729212329032"></p>
<img src="/2023/07/27/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-1/image-20230729212329032.png" class title="This is an test image">

<h1 id="两种风格关系"><a href="#两种风格关系" class="headerlink" title="两种风格关系"></a>两种风格关系</h1><p>基于对象编程思想（OOP）和面向对象编程思想（OOAD）是紧密相关的概念，而不是互相对立的。下面将解释它们之间的关系以及各自的优势。</p>
<ul>
<li><strong>面向对象编程思想（Object-Oriented Programming Paradigm）</strong> 是一种编程方法论，其中的核心是将问题划分为各个对象，并通过对象之间的交互来解决问题。这种思想强调数据和操作的封装、继承、多态等概念，使得代码更具可重用性、可扩展性和可维护性。</li>
<li><strong>基于对象编程思想（Object-Based Programming Paradigm）</strong> 是指在某些编程语言中使用面向对象编程的部分特性，但不符合纯粹的面向对象编程的要求。它可能缺少某些面向对象编程的特征，如继承、多态等。</li>
</ul>
<p>因此，OOP是一种广义的编程思想，而OOAD则是针对软件系统设计与构建的一种方法。OOAD包括了面向对象编程范式，但它还超越了编程范畴，着重考虑软件开发的整体过程，包括需求分析、系统设计、模块化等方面。</p>
<p>总体而言，OOP和OOAD都有其独特的优势和应用场景：</p>
<ul>
<li>面向对象编程思想（OOP）是一种强大的编程范式，适合构建复杂、可重用和可扩展的软件系统。通过封装、继承和多态等特性，代码变得更易理解、模块化，减少了开发时间和维护成本。</li>
<li>基于对象编程思想（Object-Based Programming Paradigm）可能在某些简单场景下更加适用，特别是对那些不需要复杂继承和多态的问题。</li>
</ul>
<p>因此，选择使用OOP还是OOAD取决于具体的需求和项目要求。对于大型、复杂的软件系统，通常采用面向对象编程思想和面向对象分析设计方法是更好的选择。而在开发小型或简单的应用程序时，基于对象编程思想也可以提供足够的灵活性和效率。</p>
<h1 id="多线程与并发服务器设计"><a href="#多线程与并发服务器设计" class="headerlink" title="多线程与并发服务器设计"></a>多线程与并发服务器设计</h1><h2 id="常见并发服务器方案"><a href="#常见并发服务器方案" class="headerlink" title="常见并发服务器方案"></a>常见并发服务器方案</h2><p><img src="/muduo-1/image-20230807164014354.png" alt="image-20230807164014354"></p>
<img src="/2023/07/27/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-1/image-20230807164014354.png" class title="This is an test image">

<p><img src="/muduo-1/image-20230807212000990.png" alt="image-20230807212000990"></p>
<img src="/2023/07/27/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-1/image-20230807212000990.png" class title="This is an test image">

<p><img src="/muduo-1/image-20230808110610718.png" alt="image-20230808110610718"></p>
<img src="/2023/07/27/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-1/image-20230808110610718.png" class title="This is an test image">

<p><img src="/muduo-1/image-20230808110726418.png" alt="image-20230808110726418"></p>
<img src="/2023/07/27/muduo%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/muduo-1/image-20230808110726418.png" class title="This is an test image">

<p>9当中的多个reactor共享一个线程池，<strong>在Linux下更加推荐9</strong></p>
<p>惊群（Thundering Herd）现象是在多进程（prefork）或者多线程（pre-threaded）服务器模型中可能出现的一个性能问题。当一个监听套接字上的事件（如连接请求）到达时，所有等待处理此事件的进程或线程都会被唤醒，但只有其中一个能够成功地处理这个事件，而其他的进程或线程会在竞争中被阻塞。这会造成资源浪费和性能下降。</p>
<p>例如，假设有多个进程或线程都在等待处理连接请求，当一个连接到达时，多个进程或线程都会被唤醒，但只有一个进程或线程能够接受连接，而其他的进程或线程将会被阻塞在accept调用上。</p>
<p>为了解决惊群现象，可以考虑以下几种方法：</p>
<ol>
<li>使用互斥锁：在接受连接之前，使用互斥锁来保护临界区，确保只有一个进程或线程能够接受连接，其他的进程或线程会在锁上阻塞。这样可以避免多个进程或线程同时处理同一个事件。</li>
<li>使用信号量：类似于互斥锁，信号量也可以用来控制对临界资源的访问。在接受连接之前，可以使用信号量来控制只有一个进程或线程能够进入临界区。</li>
<li>延迟唤醒：让只有一个进程或线程来接受连接，其他进程或线程不进行accept调用，从而避免不必要的唤醒。当有新连接到达时，唤醒一个进程或线程来处理连接，其他进程或线程可以继续等待。</li>
<li>选用更先进的模型：使用更现代的多进程&#x2F;多线程服务器模型，如基于事件驱动的模型（如epoll、kqueue、IOCP等），可以更好地避免惊群现象，因为这些模型能够更精细地控制事件的分发。</li>
</ol>
<h2 id="多线程能提高并发度吗"><a href="#多线程能提高并发度吗" class="headerlink" title="多线程能提高并发度吗"></a>多线程能提高并发度吗</h2><p>如果指的是“并发连接数”，不能。<br>假如单纯采用thread per connection的模型，那么并发连接数大约300，这远远低于基于事件的单线程程序所能轻松达到的并发连接数（几千上万，甚至几万）。所谓“基于事件”，指的是用IO multiplexing event loop的编程模型，又称Reactor模式。</p>
<h2 id="多线程能提高吞吐量吗"><a href="#多线程能提高吞吐量吗" class="headerlink" title="多线程能提高吞吐量吗"></a>多线程能提高吞吐量吗</h2><p>对于计算密集型服务，不能。<br>如果要在一个8核的机器上压缩100个1G的文本文件，每个core的处理能力为200MB&#x2F;s，那么“每次起8个进程，一个进程压缩一个文件”与“只启动一个进程（8个线程并发压缩一个文件）”，这两种方式总耗时相当，但是第二种方式能<strong>较快</strong>的拿到第一个压缩完的文件。</p>
<p>从这个例子可以看出<strong>能提高响应时间</strong></p>
<h2 id="多线程如何让IO和计算重叠"><a href="#多线程如何让IO和计算重叠" class="headerlink" title="多线程如何让IO和计算重叠"></a>多线程如何让IO和计算重叠</h2><p>多线程程序如何让I&#x2F;O和计算重叠，降低latenc迟延)</p>
<ul>
<li>例:日志（logging) ，多个线程写日志，由于文件操作比较慢，服务线程会等在lO上，让CPU空闲，增加响应时间。</li>
<li>解决办法:单独用一个logging线程负责写磁盘文件通过BlockingQueue提供对外接口，别的线程要写日志的时候往队列一塞就行，这样服务线程的计算和logging线程的磁盘IO就可以重叠。</li>
<li>如果异步IO成熟的话，可以用protator模式。</li>
</ul>
<h2 id="线程池大小选择"><a href="#线程池大小选择" class="headerlink" title="线程池大小选择"></a>线程池大小选择</h2><p>如果池中执行任务时，密集计算所占时间比重为P(0&lt;p&lt;&#x3D;1)，而系统一共有C个CPU，为了让C个CPU跑满而不过载,线程池大小的经验公式T&#x3D;C&#x2F;P,即T*P&#x3D;C(让CPU刚好跑满)</p>
<ul>
<li>假设C&#x3D;8，P&#x3D;1.0，线程池的任务完全密集计算，只要8个活动线程就能让CPU饱和</li>
<li>假设C&#x3D;8，P&#x3D;0.5，线程池的任务有一半是计算，一半是lO，那么T&#x3D;16，也就是16个“50%繁忙的线程”能让8个CPU忙个不停。</li>
</ul>
<p><strong>I&#x2F;O操作不耗费CPU</strong>的原因是，当执行I&#x2F;O操作时，CPU可以将控制权交给其他任务或进程，而不需要持续地占用CPU资源。在进行I&#x2F;O操作期间，CPU可以继续执行其他指令，如处理其他进程的计算需求。</p>
<p>当一个程序发起一个I&#x2F;O请求时，它将传递给操作系统，然后操作系统将负责管理这个请求。操作系统可以将该请求放入一个队列中，等待设备准备就绪，并在合适的时候通知程序。这样一来，程序可以继续执行其他任务，而不必等待I&#x2F;O操作完成。</p>
<p>一旦设备准备好，并且I&#x2F;O操作已经完成，操作系统将通知程序，使程序能够继续执行。在这个过程中，CPU并没有被I&#x2F;O操作所阻塞，而是可以执行其他任务。因此，I&#x2F;O操作不会消耗大量的CPU时间。</p>
<p>值得注意的是，尽管I&#x2F;O操作本身可能不耗费CPU，但I&#x2F;O操作可能会导致CPU等待数据的返回。例如，当从硬盘读取文件时，CPU可能会暂停执行，直到数据被读取到内存中才能继续执行。这种情况下，虽然CPU可能会花费一些时间等待I&#x2F;O操作完成，但这并不是CPU主动参与I&#x2F;O操作的结果。</p>
<h2 id="线程分类"><a href="#线程分类" class="headerlink" title="线程分类"></a>线程分类</h2><p>I&#x2F;O线程（这里特指网络I&#x2F;O),reactor模式</p>
<p>计算线程，耗费cpu</p>
<p>第三方库所用线程，如logging,又比如database</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/26/c%E5%92%8Cc++/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/26/c%E5%92%8Cc++/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-26 10:19:17" itemprop="dateCreated datePublished" datetime="2023-07-26T10:19:17+08:00">2023-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-10 21:02:09" itemprop="dateModified" datetime="2023-09-10T21:02:09+08:00">2023-09-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h1><h2 id="UML中的关系"><a href="#UML中的关系" class="headerlink" title="UML中的关系"></a>UML中的关系</h2><p>UML中的关系主要包括4种:<br>关联关系(association)<br>依赖关系(dependency)<br>泛化关系(generalization)<br>实现关系(realization)</p>
<h2 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h2><p>(1)用例图(Use Case Diagram):也称为用户模型图，是从软件需求分析到最终实现的第一步，它是从客户的角度来描述系统功能.<br>(2）用例图包含3个基本组件:<br>参与者(Actor):与系统打交道的人或其他系统即使用该系统的人或事物.在UML中参与者用人形图标表示<br>用例(Use Case):代表系统的某项完整的功能.在UML中使用一个椭圆来表示<br>关系:定义用例之间的关系——泛化关系,扩展关系，包含关系</p>
<p>这是一个泛化关系</p>
<p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726103502809.png" alt="image-20230726103502809"></p>
<img src="/2023/07/26/c%E5%92%8Cc++/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726103502809.png" class title="This is an test image">

<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>类图是面向对象系统建模中最常用的图.是定义其他图的基础.<br>类图主要是用来显示系统中的类,接口以及它们之间的关系.<br>类图包含的主要元素有类，接口和关系.其中关系有泛化关系,关联关系，依赖关系和实现关系.在类图中也可以包含注释和约束.</p>
<h3 id="类的表示法"><a href="#类的表示法" class="headerlink" title="类的表示法"></a>类的表示法</h3><p>1.类是类图的主要组件，由3部分组成:类名，属性和方法.在UML中，类用矩形来表示，顶端部分存放类的名称，中间部分存放类的属性，属性的类型及值,底部部分存放类的方法,方法的参数和返回类型.<br>2.在UML中可以根据实际情况有选择的隐藏属性部分或方法部分或两者<br>都隐藏</p>
<p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726103808831.png" alt="image-20230726103808831"></p>
<img src="/2023/07/26/c%E5%92%8Cc++/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726103808831.png" class title="This is an test image">

<h3 id="类之间的关系-泛化关系"><a href="#类之间的关系-泛化关系" class="headerlink" title="类之间的关系-泛化关系"></a>类之间的关系-泛化关系</h3><p>1.在UML中，泛化关系用来表示类与类，接口与接口之间的继承关系.泛化关系有时也称为” is a kind of“关系.<br>2.在UML中泛化关系用一条实线空心箭头有子类指向父类.</p>
<h3 id="类之间的关系-实现关系"><a href="#类之间的关系-实现关系" class="headerlink" title="类之间的关系-实现关系"></a>类之间的关系-实现关系</h3><p>在UML中，实现关系用来表示类与接口之间的实现关系.</p>
<p>在UML中实现关系用一条虚线空心箭头由子类指向父类</p>
<h3 id="类之间的关系-依赖关系"><a href="#类之间的关系-依赖关系" class="headerlink" title="类之间的关系-依赖关系"></a>类之间的关系-依赖关系</h3><p>对于两个相对独立的系统，当一个系统负责构造另一个系统的实例，或者依赖另一个系统的服务时，这两个系统之间体现为依赖关系.</p>
<p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726104109089.png" alt="image-20230726104109089"></p>
<img src="/2023/07/26/c%E5%92%8Cc++/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726104109089.png" class title="This is an test image">

<h3 id="类之间的关系-关联关系"><a href="#类之间的关系-关联关系" class="headerlink" title="类之间的关系-关联关系"></a>类之间的关系-关联关系</h3><p>对于两个相对独立的系统，当一个系统的实例与另一个系统的一些特定实例存在固定的对应关系时，这两个系统之间为关联关系。</p>
<h3 id="常见的类图分为以下几个层级："><a href="#常见的类图分为以下几个层级：" class="headerlink" title="常见的类图分为以下几个层级："></a>常见的类图分为以下几个层级：</h3><ul>
<li>类名</li>
</ul>
<p>类名层不可省略，其他几层可以不存在；</p>
<p>类名是正体字，类是具体的；</p>
<p>类名是斜体字，类是抽象的，或者是接口；</p>
<ul>
<li>属性</li>
</ul>
<p>+代表public；</p>
<p>#代表protected；</p>
<p>-代表private ；</p>
<ul>
<li>方法</li>
</ul>
<p>+代表public；<br>#代表protected；<br>-代表private ；<br>如果方法下面有一道下划线，则表明该方法是静态方法；<br>方法后面带的是返回值类型；</p>
<h1 id="软件设计模式的种类"><a href="#软件设计模式的种类" class="headerlink" title="软件设计模式的种类"></a>软件设计模式的种类</h1><p>GoF提出的设计模式有23个包括︰<br>创建型(Creational)模式:如何创建对象﹔<br>结构型(Structural )模式:如何实现类或对象的组合﹔<br>行为型(Behavioral)模式︰类或对象怎样交互以及怎样分配职责。</p>
<p>有一个“简单工厂模式”不属于GoF 23种设计模式，但大部分的设计模式<br>书籍都会对它进行专门的介绍。</p>
<p>设计模式目前种类:GoF的23种+“简单工厂模式”&#x3D;24种。</p>
<p>设计模式的基础是<strong>多态</strong></p>
<h2 id="设计模式总览图"><a href="#设计模式总览图" class="headerlink" title="设计模式总览图"></a>设计模式总览图</h2><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726104823806.png" alt="image-20230726104823806"></p>
<img src="/2023/07/26/c%E5%92%8Cc++/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726104823806.png" class title="This is an test image">

<p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726104838478.png" alt="image-20230726104838478"></p>
<img src="/2023/07/26/c%E5%92%8Cc++/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726104838478.png" class title="This is an test image">

<p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726104917159.png" alt="image-20230726104917159"></p>
<img src="/2023/07/26/c%E5%92%8Cc++/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726104917159.png" class title="This is an test image">

<p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726104931305.png" alt="image-20230726104931305"></p>
<img src="/2023/07/26/c%E5%92%8Cc++/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726104931305.png" class title="This is an test image">

<p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726104944466.png" alt="image-20230726104944466"></p>
<img src="/2023/07/26/c%E5%92%8Cc++/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726104944466.png" class title="This is an test image">

<p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726104954560.png" alt="image-20230726104954560"></p>
<img src="/2023/07/26/c%E5%92%8Cc++/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726104954560.png" class title="This is an test image">

<h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><p>对于面向对象软件系统的设计而言，在支持可维护性的同时，提高系统的可复用性是一个至关重要的问题,如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。在面向对象设计中，可维护性的复用是以设计原则为基础的。每一个原则都蕴含一些面向对象设计的思想，可以从不同的角度提升一个软件结构的设计水平。</p>
<p>面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。面向对象设计原则也是我们用于评价一个设计模式的使用效果的重要指标之一。</p>
<p>原则的目的:高内聚，低耦合</p>
<p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726105230007.png" alt="image-20230726105230007"></p>
<img src="/2023/07/26/c%E5%92%8Cc++/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726105230007.png" class title="This is an test image">

<p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726105243049.png" alt="image-20230726105243049"></p>
<img src="/2023/07/26/c%E5%92%8Cc++/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726105243049.png" class title="This is an test image">

<p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726105255149.png" alt="image-20230726105255149"></p>
<img src="/2023/07/26/c%E5%92%8Cc++/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726105255149.png" class title="This is an test image">

<p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726105310548.png" alt="image-20230726105310548"></p>
<img src="/2023/07/26/c%E5%92%8Cc++/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726105310548.png" class title="This is an test image">

<p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726105326170.png" alt="image-20230726105326170"></p>
<img src="/2023/07/26/c%E5%92%8Cc++/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726105326170.png" class title="This is an test image">

<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Caculaor&#123;</span><br><span class="line">public:</span><br><span class="line">    Caculaor(int a，int b，string moperator)&#123;</span><br><span class="line">        this-&gt;m_a = a;</span><br><span class="line">        this-&gt;m_b = b;</span><br><span class="line">        this-&gt;m_operator = moperator;</span><br><span class="line">    &#125;</span><br><span class="line">int getResult() &#123;</span><br><span class="line">    if (m_operator.compare(&quot;+&quot;) == 0)&#123;</span><br><span class="line">        return m_a + m_b;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (m_operator.compare(&quot;-&quot;) == 0)&#123;</span><br><span class="line">    	return m_a - m_b;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (m_operator.compare(&quot;*&quot;&quot;) == 0)&#123;</span><br><span class="line">    	return m_a * m_b;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (m_operator.compare(&quot;/&quot;) =0)&#123;</span><br><span class="line">    	return m_a / m_b;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">	int m_a;</span><br><span class="line">	int m_b;</span><br><span class="line">	string m_operator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点:如果增加取模的运算需要修改getResult 成员方法，如果增加新功能的情况下要修改源代码，那么就会有修改出错的可能性。我们应该在增加新的功能时候，不能影响其他已经完成的功能。这就是对修改关闭，对扩展开放，叫做开闭原则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//开闭原则﹑对扩展开放，对修改关闭，增加功能是通过增加代码来实现，而不是去修改源代码</span><br><span class="line">//写一个抽象类</span><br><span class="line">class AbstractCaculator &#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void setOperatorNumber(int,int)=0;</span><br><span class="line">	virtual int getResult() =0;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">//加法计算器类</span><br><span class="line">class PlusCaculator :public AbstractCaculator&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void setOperatorNumber(int a,int b)&#123;</span><br><span class="line">		this-&gt;mA = a;</span><br><span class="line">		this-&gt;mB = b;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual int getResult()&#123;</span><br><span class="line">		return mA + mB;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	int mA;</span><br><span class="line">	int mB;</span><br><span class="line">&#125;;</span><br><span class="line">void test()&#123;</span><br><span class="line">	AbstractCaculator* pca=new PlusCaculator;</span><br><span class="line">	pca-&gt;setOperatorNumber(1,2);</span><br><span class="line">	int a=pca-&gt;getResult();</span><br><span class="line">	cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main ()&#123;</span><br><span class="line">	test();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用这个代码，扩展新功能就很方便，不用修改原有代码。</p>
<p>本质就是利用了多态，父类作为通用接口，扩展需要的子类。</p>
<h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//迪米特法则又叫最少知识原则</span><br><span class="line">c1ass AbstractBuilding &#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void sale() = 0;</span><br><span class="line">	virtual string getQuality() = 0;</span><br><span class="line">&#125;;</span><br><span class="line">//楼盘A</span><br><span class="line">class BuildingA : public AbstractBuilding&#123;</span><br><span class="line">public:</span><br><span class="line">	BuildingA() &#123;</span><br><span class="line">		mQulity =&quot;高品质&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void sale() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;楼盘A&quot;&lt;&lt; mQulity &lt;&lt;&quot;被售卖!&quot;&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	string mQulity;</span><br><span class="line">&#125; ;</span><br><span class="line">//楼盘B</span><br><span class="line">class BuildingB : public AbstractBuilding&#123;</span><br><span class="line">public:</span><br><span class="line">	BuildingB() &#123;</span><br><span class="line">		mQulity =&quot;低品质&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void sale() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;楼盘B&quot;&lt;&lt; mQulity &lt;&lt;&quot;被售卖!&quot;&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	string mQulity;</span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure>

<p>如上图，楼盘AB里应该再添加一个getQuality方法，截图费劲，没截进去了。这样是直接打交道的，客户端直接接触到了楼层类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//中介类</span><br><span class="line">class Mediator&#123;</span><br><span class="line">public:</span><br><span class="line">	Mediator()&#123;</span><br><span class="line">		AbstractBuilding* building = new BuildingA;</span><br><span class="line">		vBuilding. push_back(building) ;</span><br><span class="line">		building = new BuildingB;</span><br><span class="line">		vBuilding.push_back(building);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">//对外提供接口</span><br><span class="line">	AbstractBui1ding* findMyBuilding(string quality) &#123;</span><br><span class="line">		for (vector&lt;AbstractBuilding*&gt; : :iterator it = vBuilding.begin();it!=vBuilding.endl;it++)&#123;</span><br><span class="line">			if ((*it)-&gt;getQuality() == quality)&#123;</span><br><span class="line">				return *it;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	return NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	~Mediator() &#123;</span><br><span class="line">		for (vector&lt;AbstractBuilding*&gt; :: iterator it = vBuilding.begin();it!=vBuilding.endl;it++)</span><br><span class="line">			if (*it != NULL) &#123;</span><br><span class="line">				delete *it;//放指针指向的内存,析构函数的目的是确保释放 vBuilding 向量中的内存资源</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	vector&lt;AbstractBuilding*&gt; vBui1ding;</span><br><span class="line">&#125;</span><br><span class="line">//现在，客户只需要和中介打交道：</span><br><span class="line">//客户端</span><br><span class="line">void test02()&#123;</span><br><span class="line">	Mediator* mediator = new Mediator;</span><br><span class="line">	AbstractBuilding* building =mediator-&gt;findMyBuilding(&quot;高品质&quot;);</span><br><span class="line">	if (building !=NULL)&#123;</span><br><span class="line">		bui1ding-&gt;sale();</span><br><span class="line">	else &#123;</span><br><span class="line">		cout &lt;&lt;&quot;没有符合您条件的楼盘!&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p>就一句话，能用组合就别用继承</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//抽象车</span><br><span class="line">class AbstractCar &#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void run() = 0;</span><br><span class="line">&#125;</span><br><span class="line">//大众车</span><br><span class="line">class Dazhong :public AbstractCar&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void run() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;大众车启动...&quot;&lt;&lt; end1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; </span><br><span class="line">//拖拉机</span><br><span class="line">class Tuolaji :public AbstractCar&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void run() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;拖拉机启动...&quot;&lt;&lt;end1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//像上面这种写法，就非常不科学，如果有很多开不同类型车的人，就需要写很多类。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//可以使用组合</span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">	void setCar(AbstractCar* car)&#123;</span><br><span class="line">		this-&gt;car = car;</span><br><span class="line">	&#125;</span><br><span class="line">	void Doufeng ()&#123;</span><br><span class="line">		this-&gt;car-&gt;run() ;</span><br><span class="line">	&#125;</span><br><span class="line">	~person()&#123;</span><br><span class="line">		if(this-&gt;car!=NULL)</span><br><span class="line">			delete this-&gt;car;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	AbstractCar* car;</span><br><span class="line">&#125;;</span><br><span class="line">void test02()&#123;</span><br><span class="line">	Person* p = new Person;</span><br><span class="line">	p-&gt;setCar(new Dazhong);</span><br><span class="line">	p-&gt;Doufeng() ;</span><br><span class="line">	delete p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h2><p>传统的过程式设计倾向于使高层次的模块依赖于低层次的模块，抽象层依赖于具体的层次。</p>
<p>传统的设计过程，高层依赖于中层，中层依赖于底层</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//银行工作人员</span><br><span class="line">class BankWorker &#123;</span><br><span class="line">public:</span><br><span class="line">	void saveService() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;办理存款业务...&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	void payService()&#123;</span><br><span class="line">		cout &lt;&lt;&quot;办理支付业务..&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	void tranferService() &#123;</span><br><span class="line">		cout&lt;&lt;&quot;办理转账业务..&quot;&lt;&lt;endl;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//中层模块</span><br><span class="line">void doSaveBussiness (BankWorker* worker)&#123;</span><br><span class="line">	worker-&gt;saveService() ;</span><br><span class="line">&#125;</span><br><span class="line">void doPayBussiness(BankWorker* worker)&#123;</span><br><span class="line">	worker-&gt;payService();</span><br><span class="line">&#125;</span><br><span class="line">void doTransferBussiness(BankWorker* worker) &#123;</span><br><span class="line">	worker-&gt;tranferService();</span><br><span class="line"> &#125;</span><br><span class="line">void test01()&#123;</span><br><span class="line">	BankWorker* worker = new BankWorker ;</span><br><span class="line">	doSaveBussiness(worker);//办理存款业务</span><br><span class="line">	doPayBussiness(worker);//办理支付业务</span><br><span class="line">	doTransferBussiness(worker) ; //办理转账业务</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面用依赖倒转原则改写上面的业务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//银行工作人员</span><br><span class="line">class AbstractWorker&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void doBusfness() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//专门负责办理存款业务的工作人员</span><br><span class="line">class SaveBankWorer :public AbstractWorker&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void doBusiness() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;办理存款业务...”&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//专门办理支付业务的工作人员</span><br><span class="line">class PayBankWorker : public AbstractWorker&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void doBusiness() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;办理支付业务...&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">//专门办理转账业务的工作人员</span><br><span class="line">class TransferBankWorker : public AbstractWorker&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void doBusiness() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;办理转账业务...&quot; &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">//中层业务</span><br><span class="line">void doNewBusiness(AbstractWorker* worker)&#123;</span><br><span class="line">	worker-&gt;doBusiness() ;</span><br><span class="line">&#125;</span><br><span class="line">void tesat02()&#123;</span><br><span class="line">	AbstractWorker* transfer = new TransferBankWorker;</span><br><span class="line">	doNewBusiness(transfer) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是利用多态，将底层抽象出来，这样顶层就只依赖于抽象层，底层有改动时，也不会改变中层，就不会影响到上层。</p>
<h2 id="简单工厂模式-代码实现"><a href="#简单工厂模式-代码实现" class="headerlink" title="简单工厂模式-代码实现"></a>简单工厂模式-代码实现</h2><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726155959005.png" alt="image-20230726155959005"></p>
<img src="/2023/07/26/c%E5%92%8Cc++/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726155959005.png" class title="This is an test image">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">//抽象水果</span><br><span class="line">class AbstractFruit&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void ShowName () = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//苹果</span><br><span class="line">class Apple : public AbstractFruit&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void ShowName() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;我是苹果!&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//香蕉</span><br><span class="line">class Banana : public AbstractFruit&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void ShowName () &#123;</span><br><span class="line">		cout &lt;&lt;&quot;我是香蕉!&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//鸭梨</span><br><span class="line">class Pear : public AbstractFruit &#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void ShowName() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;我是鸭梨!&quot;&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//水果工厂</span><br><span class="line">class FruitFactory &#123;</span><br><span class="line">public:</span><br><span class="line">	static AbstractFruit* CreateFruit(string flag)&#123;</span><br><span class="line">		if (f1ag == &quot;apple&quot;)&#123;</span><br><span class="line">		return new Apple;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (flag == &quot;banana&quot;)&#123;</span><br><span class="line">			return new Banana;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (flag == &quot;pear&quot;) &#123;</span><br><span class="line">			return new Pear;</span><br><span class="line">		&#125; </span><br><span class="line">		else&#123;</span><br><span class="line">			return NULL;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()&#123;</span><br><span class="line">	FruitFactory* factory = new FruitFactory;</span><br><span class="line">	AbstractFruit* fruit = factory-&gt;CreateFruit(&quot;apple&quot;) ;</span><br><span class="line">	fruit-&gt;ShowName () ;</span><br><span class="line">	delete fruit;</span><br><span class="line">	fruit = factory-&gt;CreateFruit(&quot;banana&quot;);</span><br><span class="line">	fruit-&gt;ShowName() ;</span><br><span class="line">	delete fruit;</span><br><span class="line">	fruit = factory-&gt;CreateFruit(&quot;pear&quot;);</span><br><span class="line">	fruit-&gt;ShowName () ;</span><br><span class="line">	delele fruit;</span><br><span class="line">	delete factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>简单工厂中，工厂不符合开闭原则。这里，再将工厂抽象出来，让工厂也符合开闭原则。</p>
<p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726161204568.png" alt="image-20230726161204568"></p>
<img src="/2023/07/26/c%E5%92%8Cc++/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726161204568.png" class title="This is an test image">

<p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726161226477.png" alt="image-20230726161226477"></p>
<img src="/2023/07/26/c%E5%92%8Cc++/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726161226477.png" class title="This is an test image">

<p>优点:<br>(1)不需要记住具体类名，甚至连具体参数都不用记忆。<br>(2)实现了对象创建和使用的分离。<br>心<br>(3)系统的可扩展性也就变得非常好，无需修改接口和原类。<br>缺点:<br>(1)增加系统中类的个数，复杂度和理解度增加。<br>(2)增加了系统的抽象性和理解难度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//抽象水果</span><br><span class="line">class AbstractFruit&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void ShowName() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//苹果</span><br><span class="line">class Apple : public AbstractFruit&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void ShowName ()&#123;</span><br><span class="line">		cout &lt;&lt;”我是苹果!&quot;”&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//香蕉</span><br><span class="line">class Banana : public AbstractFruit&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void ShowName () &#123;</span><br><span class="line">		cout &lt;&lt;&quot;我是香蕉!”&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//抽象工厂</span><br><span class="line">class AbstractFruitFactory&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual AbstractFruit* CreateFruit()= 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//苹果工厂</span><br><span class="line">class AppleFactory : public AbstractFruitFactory&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual AbstractFruit* CreateFruit() &#123;</span><br><span class="line">		return new Apple();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01() &#123;</span><br><span class="line">	AbstractFruitFactory* factory = NULL;</span><br><span class="line">	AbstractFruit* fruit = NULL;</span><br><span class="line">	//创建一个苹果工厂</span><br><span class="line">	factory = new AppleFactory();</span><br><span class="line">	fruit = factory-&gt;CreateFruit() ;</span><br><span class="line">	fruit-&gt;ShowName() ;</span><br><span class="line">	delete fruit;</span><br><span class="line">	delete factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简单工厂和工厂方法模式适用场景"><a href="#简单工厂和工厂方法模式适用场景" class="headerlink" title="简单工厂和工厂方法模式适用场景"></a>简单工厂和工厂方法模式适用场景</h3><p>1.客户端不知道它所需要的对象的类。<br>2.抽象工厂类通过其子类来指定创建哪个对象。<br>3.工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。<br>4.客户端只知道传入工厂类的参数，对于如何创建对象并不关心。</p>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726162010494.png" alt="image-20230726162010494"></p>
<img src="/2023/07/26/c%E5%92%8Cc++/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726162010494.png" class title="This is an test image">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">//抽象苹果</span><br><span class="line">class AbstractApple&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void ShowName () = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//中国苹果</span><br><span class="line">class ChinaApple : public AbstractApple &#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void ShowName () &#123;</span><br><span class="line">		cout &lt;&lt;&quot;中国苹果!&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//美国苹果</span><br><span class="line">class USAApple : public AbstractApple &#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void ShowName() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;美国苹果!&quot;&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//抽象香蕉</span><br><span class="line">class AbsrtactBanana&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void ShowName() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//抽象鸭梨</span><br><span class="line">class AbstractPear &#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void ShowName () = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//抽象工厂针对产品族</span><br><span class="line">class AbstracFactory&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual AbstractApple* CreateApple() = 0;</span><br><span class="line">	virtual AbsrtactBanana* CreateBanana() = 0;</span><br><span class="line">	virtual AbstractPear* CreatePear() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//中国工厂</span><br><span class="line">class ChinaFactory : public AbstracFactory &#123;</span><br><span class="line">public:</span><br><span class="line">	virtual AbstractApple* CreateApple()&#123;</span><br><span class="line">		return new ChinaApple;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual AbsrtactBanana* CreateBanana() &#123;</span><br><span class="line">		return new ChinaBanana;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual AbstractPear* CreatePear ()&#123;</span><br><span class="line">		return new ChinaPear;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()&#123;</span><br><span class="line">	AbstracFactory* factory = NULL;</span><br><span class="line">	AbstractApple* apple = NULL;</span><br><span class="line">	AbsrtactBanana* banana = NULL;</span><br><span class="line">	AbstractPear* pear = NULL;</span><br><span class="line">	factory = new ChinaFactory;</span><br><span class="line">	apple = factory-&gt;CreateApple();</span><br><span class="line">	banana = factory-&gt;CreateBanana() ;</span><br><span class="line">	pear = factory-&gt;CreatePear();</span><br><span class="line">	apple-&gt;ShowName();</span><br><span class="line">	delete factory;</span><br><span class="line">	delete apple;</span><br><span class="line">	delete banana;</span><br><span class="line">	delete pear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单例模式-饿汉式和懒汉式创建"><a href="#单例模式-饿汉式和懒汉式创建" class="headerlink" title="单例模式_饿汉式和懒汉式创建"></a>单例模式_饿汉式和懒汉式创建</h2><p>单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">private:</span><br><span class="line">	A()&#123;</span><br><span class="line">		a=new A;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	static A* getInstace() &#123;//静态成员函数只能访问类的静态成员变量和其他静态成员函数，不能直接访问类的非静态成员变量和非静态成员函数，静态成员函数也没有访问权限限定符（public、private、protected）的限制。</span><br><span class="line">		return a;</span><br><span class="line">	&#125;</span><br><span class="line">	class CG &#123;</span><br><span class="line"> 	public:</span><br><span class="line"> 		~CG() &#123;</span><br><span class="line"> 			if (singlePattern::p != nullptr) &#123;</span><br><span class="line"> 			delete singlePattern::p;</span><br><span class="line"> 			singlePattern::p = nullptr;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	static A* a;</span><br><span class="line">&#125;;</span><br><span class="line">int main(void)&#123;</span><br><span class="line">	//A* a = new A;</span><br><span class="line">	A::getInstace();</span><br><span class="line">&#125;</span><br><span class="line">//实现单例步骤</span><br><span class="line">//1.构造函数私有化</span><br><span class="line">//2．增加静态私有的当前类的指针变量</span><br><span class="line">//3．提供静态对外接口，可以让用户获得单例对象</span><br></pre></td></tr></table></figure>

<p>懒汉式，调用getinstance的时候才会去new一个对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//单例分为懒汉式</span><br><span class="line">class Singleton_lazy&#123;</span><br><span class="line">private:</span><br><span class="line">	Singleton_lazy()&#123;&#125;</span><br><span class="line">public:</span><br><span class="line">	static sing1eton_1azy* getInstance() &#123;</span><br><span class="line">			if (pSingleton == NULL)&#123;</span><br><span class="line">				pSing1eton = new Singleton_1azy();</span><br><span class="line">			&#125;</span><br><span class="line">			return pSing1eton;</span><br><span class="line">		&#125;</span><br><span class="line">	class CG &#123;</span><br><span class="line"> 	public:</span><br><span class="line"> 		~CG() &#123;</span><br><span class="line"> 			if (Singleton_lazy::pSingleton != nullptr) &#123;</span><br><span class="line"> 			delete Singleton_lazy::pSingleton;</span><br><span class="line"> 			Singleton_lazy::pSingleton = nullptr;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	static Singleton_lazy* pSingleton;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//类外初始化</span><br><span class="line">Singleton_lazy* Singleton_lazy::pSingleton = NULL;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 饿汉式</span><br><span class="line">class Sing1eton_hungry &#123;</span><br><span class="line">private:</span><br><span class="line">	sing1eton_hungry () &#123;&#125;</span><br><span class="line">public:</span><br><span class="line">	static Singleton_hungry* getInstance()&#123;</span><br><span class="line">		return pSing1eton;</span><br><span class="line">	&#125;</span><br><span class="line">	class CG &#123;</span><br><span class="line"> 	public:</span><br><span class="line"> 		~CG() &#123;</span><br><span class="line"> 			if (Singleton_hungry::pSingleton != nullptr) &#123;</span><br><span class="line"> 			delete Singleton_hungry::pSingleton;</span><br><span class="line"> 			Singleton_hungry::pSingleton = nullptr;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	static Singleton_hungry* pSingleton;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton_hungry* Singleton_hungry::pSingleton = new Singleton_hungry();</span><br></pre></td></tr></table></figure>

<p>其实单例模式的核心就是构造函数私有化，让用户不能自己new一个对象。饿汉式是直接类内new一个对象，懒汉式是在需要访问对象时才实例化。完事儿通过static来保证大家访问的都是同一个实例</p>
<p>单例不需要考虑释放问题</p>
<p>单例模式不需要考虑释放问题的原因是，单例模式中的实例对象是在程序的整个生命周期中存在的，直到程序结束才会被销毁。因此，不需要手动释放单例对象。（如果需要，使用嵌套类的方式还能够起到一定的安全性保护作用。由于嵌套类 <code>CG</code> 是外部类 <code>singlePattern</code> 的友元类，它可以直接访问 <code>singlePattern</code> 类的私有成员变量，包括 <code>p</code>。因此，在 <code>CG</code> 类的析构函数中可以直接操作 <code>p</code> 对象，确保释放资源的正确性）</p>
<p>单例模式通过将构造函数私有化，并提供一个静态方法来获取唯一实例，确保了只有一个实例存在。实例一旦创建，就会一直存在于内存中，直到程序结束。因为单例对象是全局唯一的，可以在程序的任何地方访问，所以不需要手动释放实例。</p>
<p>如果强制要求释放单例对象，可能会导致程序在继续执行时无法再次获取该实例，从而违背了单例模式的初衷。</p>
<h3 id="单例碰到多线程"><a href="#单例碰到多线程" class="headerlink" title="单例碰到多线程"></a>单例碰到多线程</h3><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726165422048.png" alt="image-20230726165422048"></p>
<img src="/2023/07/26/c%E5%92%8Cc++/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230726165422048.png" class title="This is an test image">

<p>在单例模式的懒汉式实现中，实例对象在首次被请求时才会被创建。这种延迟加载的方式会在多线程环境下引发线程安全性问题。</p>
<p>当多个线程同时调用单例模式的懒汉式实现的获取实例的方法时，可能会导致多个线程同时判断实例为空，从而同时创建多个实例。这会破坏单例的唯一性。</p>
<p>在多线程的情况下，假设有两个线程 A 和 B 同时调用 <code>Singleton::getInstance()</code> 方法且此时 <code>instance</code> 为空。线程 A 执行到 <code>instance = new Singleton()</code> 时，它可能会被切换出去，而线程 B 此时也执行到了 <code>instance == nullptr</code> 的判断，于是线程 B 也会创建一个新的实例。这样就在多线程中产生了多个实例。</p>
<p>为了解决这个线程安全性问题，可以考虑使用加锁机制来保证只有一个线程可以同时访问创建实例的代码块。例如，可以使用互斥锁（<code>std::mutex</code>）来实现互斥访问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;mutex&gt;</span><br><span class="line"></span><br><span class="line">class Singleton &#123;</span><br><span class="line">private:</span><br><span class="line">    static Singleton* instance;</span><br><span class="line">    static std::mutex mtx;</span><br><span class="line">    </span><br><span class="line">    Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    static Singleton* getInstance() &#123;</span><br><span class="line">        if (instance == nullptr) &#123;</span><br><span class="line">            std::lock_guard&lt;std::mutex&gt; lock(mtx);  // 加锁</span><br><span class="line">            if (instance == nullptr) &#123;  // 再次判断是否为空</span><br><span class="line">                instance = new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">            //解锁</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = nullptr;</span><br><span class="line">std::mutex Singleton::mtx;</span><br></pre></td></tr></table></figure>

<h2 id="代理概念理解案例"><a href="#代理概念理解案例" class="headerlink" title="代理概念理解案例"></a>代理概念理解案例</h2><p>代理模式的定义∶为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//提供一种代理来控制对其他对象的访问</span><br><span class="line">c1ass AbstractCommonInterface&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void run() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//我已经写好的系统</span><br><span class="line">class MySystem : public AbstractCommonInterface&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void run() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;系统启动...&quot;&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//必须有要权限验证，不是所有人都能来启动我的启动，提供用户名和密码</span><br><span class="line">class MySystemProxy : public AbstractCommonInterface &#123;</span><br><span class="line">public:</span><br><span class="line">	MySystemProxy (string username,string password)&#123;</span><br><span class="line">		this-&gt;mUsername = username;</span><br><span class="line">		this-&gt;mPassword = password;</span><br><span class="line">		pSystem = new MySystem;</span><br><span class="line">	&#125;</span><br><span class="line">	bool checkUsernameAndPassoword() &#123;</span><br><span class="line">		if (mUsername == &quot; admin&quot; &amp;&amp; mPassword == &quot;admin&quot;)&#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;else</span><br><span class="line">			return false;</span><br><span class="line"></span><br><span class="line">	virtual void run () &#123;</span><br><span class="line">		if (checkUsernameAndPassoword ())</span><br><span class="line">			cout &lt;&lt;&quot;用户名和密码正确，验证通过...&lt;&lt;this-&gt;pSystem-&gt;run();</span><br><span class="line">		else&#123;</span><br><span class="line">			cout &lt;&lt;用户名或者密码错误,权限不足...&quot;&lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test()&#123;</span><br><span class="line">	MySystemProxy* mys=new MySystemProxy(&quot;admin&quot;,&quot;admin&quot;);</span><br><span class="line">	mys-&gt;run;</span><br><span class="line">	delete mys;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>web服务器在验证用户连接信息时，使用代理服务器，不然既要验证信息，又要数据传输，服务器压力会过大。</p>
<h2 id="外观模式-概念"><a href="#外观模式-概念" class="headerlink" title="外观模式_概念"></a>外观模式_概念</h2><p>根据迪米特法则，如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。<br>Facade模式也叫外观模式，是由GoF提出的23种设计模式中的一种。Facade模式为一组具有类似功能的类群，比如类库，子系统等等，提供一个一致的简单的界面。这个一致的简单的界面被称作facade。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">外观模式就是将复杂的子类系统抽象到同一个的接口进行管理</span><br><span class="line">，外界只需要通过此接口与子类系统进行交互，而不必要直接与复杂的子类系统进行交互</span><br><span class="line">*/</span><br><span class="line">//子系统1</span><br><span class="line">class SubSysteml &#123;</span><br><span class="line">public:</span><br><span class="line">	void run() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;子系统一运行...&quot; &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; ;</span><br><span class="line">//子系统2</span><br><span class="line">class SubSystem2&#123;</span><br><span class="line">public:</span><br><span class="line">	void run()&#123;</span><br><span class="line">		cout &lt;&lt;&quot;子系统二运行...&quot;&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//子系统3</span><br><span class="line">class SubSystem3&#123;</span><br><span class="line">public:</span><br><span class="line">	void run() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;子系统三运行...&quot;&lt;&lt; endl ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//子系统4</span><br><span class="line">class SubSystem4&#123;</span><br><span class="line">public:</span><br><span class="line">	void run() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;子系统四运行...&quot; &lt;&lt; endl ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//外观类</span><br><span class="line">class Facede&#123;</span><br><span class="line">public:</span><br><span class="line">	Facede() &#123;</span><br><span class="line">		pSysteml = new SubSysteml;</span><br><span class="line">		pSystem2 = new SubSystem2;</span><br><span class="line">		pSystem3 = new SubSystem3;</span><br><span class="line">		pSystem4 = new SubSystem4;</span><br><span class="line">	&#125;</span><br><span class="line">	~Facede() &#123;</span><br><span class="line">	//销毁</span><br><span class="line">	&#125;</span><br><span class="line">	void runSystem() &#123;</span><br><span class="line">		pSysteml-&gt;run();</span><br><span class="line">		pSystem2-&gt;run();</span><br><span class="line">		pSystem3-&gt;run();</span><br><span class="line">		pSystem4-&gt;run();</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	SubSysteml* pSysteml ;</span><br><span class="line">	SubSystem2* pSystem2;</span><br><span class="line">	SubSystem3* pSystem3;</span><br><span class="line">	SubSystem4* pSystem4;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()&#123;</span><br><span class="line">	Facede* facede = new Facede;</span><br><span class="line">	facede-&gt;runSystem() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在不同情况下，可能分不同模式的外观，即系统的不同状态需要重新定义外观类。</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//这函数我已经写好</span><br><span class="line">struct MyPrint &#123;</span><br><span class="line">	void operator() (int vl,int v2)&#123;</span><br><span class="line">		cout &lt;&lt; vl + v2 &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//定义目标接口我要是配偶适配成什么样的</span><br><span class="line">class Target&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void operator () (int v) = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//写适配器</span><br><span class="line">class Adapter : public Target &#123;</span><br><span class="line">public:</span><br><span class="line">	Adapter(int pram)&#123;</span><br><span class="line">		this-&gt;pram=pram;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void operator() (int v)&#123;</span><br><span class="line">		print(v,pram) ;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	MyPrint print;</span><br><span class="line">	int pram;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">	vector&lt;int&gt; v;</span><br><span class="line">	for (int i = 0; i &lt; 10;i++)</span><br><span class="line">		v.push_back(i) ;</span><br><span class="line">	for_each(v.begin(),v.end(),Adapter(10));//Adapter(10)是可以调用构造函数的</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//抽象模板</span><br><span class="line">class DrinkTemplate&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void BoilWater() = 0;//煮开水</span><br><span class="line">	virtual void Brew() = 0;//冲泡</span><br><span class="line">	virtual void PourInCup() = 0;//倒入杯中</span><br><span class="line">	virtual void AddSonmething() = 0;//加料</span><br><span class="line">&#125;;</span><br><span class="line">//模板方法</span><br><span class="line">void Make() &#123;</span><br><span class="line">	this-&gt;BoilWater();</span><br><span class="line">	this-&gt;Brew() ;</span><br><span class="line">	this-&gt;PourInCup() ;</span><br><span class="line">	this-&gt;AddSonmething();</span><br><span class="line">&#125;</span><br><span class="line">//制作茶水</span><br><span class="line">class Tea : public DrinkTemplate&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void BoilWater()&#123;</span><br><span class="line">		cout &lt;&lt;&quot;煮开水!&quot;&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void Brew()&#123;</span><br><span class="line">		cout &lt;&lt;&quot;冲泡茶叶!&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void PourInCup()&#123;</span><br><span class="line">		cout &lt;&lt;&quot;茶水倒入杯中!&quot;&lt;&lt; endl ;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void AddSonmething()&#123;</span><br><span class="line">		cout &lt;&lt;“加入柠檬!&quot;”&lt;&lt;endl ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">优点:</span><br><span class="line">(1)在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序。</span><br><span class="line">(2)模板方法模式是一种代码复用技术，它在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中,而通过其子类来实现不同的行为，它鼓励我们恰当使用继承来实现代码复用。</span><br><span class="line">(3)可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否要执行。</span><br><span class="line">(4)在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则。</span><br></pre></td></tr></table></figure>

<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式定义了一系列的算法，并将每一个算法封装起来而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//武器策略</span><br><span class="line">class WeaponStrategy&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void UseWeapon() =0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//匕首策略</span><br><span class="line">class KnifeStrategy : public WeaponStrategy&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void UseWeapon() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;使用匕首!&quot;&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Character &#123;</span><br><span class="line">public:</span><br><span class="line">	//设置武器策略</span><br><span class="line">	void setWeaponStrategy(WeaponStrategy* weaponStrategy) &#123;</span><br><span class="line">		pWeaponStrategy = weaponStrategy;</span><br><span class="line">	&#125;</span><br><span class="line">	void UseWeapon() &#123;</span><br><span class="line">		WeaponStrategy-&gt;UseWeapon() ;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	WeaponStrategy* pWeaponStrategy;</span><br><span class="line">&#125;;</span><br><span class="line">void test02()&#123;</span><br><span class="line">	Character* character = new Character;//创建角色</span><br><span class="line">	WeaponStrategy* strategy = NULL;//武器策略</span><br><span class="line">	cout &lt;&lt; &quot;---------------使用匕首策略--——-----------&quot; &lt;&lt; endl;</span><br><span class="line">	strategy = new KnifeStrategy;//创建匕首策略</span><br><span class="line">	character-&gt;setWeaponStrategy(strategy); //设置武器策略为匕首策略</span><br><span class="line">	character-&gt;UseWeapon() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化;对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。<br>命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">//协议处理类</span><br><span class="line">class HandleClientProtocol&#123;</span><br><span class="line">public:</span><br><span class="line">	//处理增加金币</span><br><span class="line">	void AddMoney() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;给玩家增加金币!&quot; &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	//处理增加钻石</span><br><span class="line">	void AddDiamond() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;给玩家增加钻石!&quot;&lt;&lt;end1;</span><br><span class="line">	&#125;</span><br><span class="line">	//处理玩家装备</span><br><span class="line">	void AddEquipment () &#123;</span><br><span class="line">		cout &lt;&lt;&quot;给玩家穿装备! &quot; &lt;&lt;end1;</span><br><span class="line">	&#125;</span><br><span class="line">	//处理玩家升级</span><br><span class="line">	void addLeve1() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;给玩家升级!&quot;&lt;&lt; end1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//命令接口</span><br><span class="line">class AbstractCommand&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void handle() = 0;//处理客户端请求的接口</span><br><span class="line">&#125;</span><br><span class="line">//处理增加金币请求</span><br><span class="line">c1ass AddMoneyCommand :public AbstractCommand &#123;</span><br><span class="line">public:</span><br><span class="line">	AddMoneyCommand(HandleClientProtocol* protocol)&#123;</span><br><span class="line">		this-&gt;pProtocol = protocol;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void handle() &#123;</span><br><span class="line">		this-&gt;pProtoco1-&gt;AddMoney() ;</span><br><span class="line">public:</span><br><span class="line">	HandleClientProtocol* pProtoco1;</span><br><span class="line">&#125;;</span><br><span class="line">//处理增加钻石的请求</span><br><span class="line">class AddDiamondCommand :public AbstractCommand &#123;</span><br><span class="line">public:</span><br><span class="line">	AddDiamondCommand(HandleClientProtocol* protoco1)&#123;</span><br><span class="line">		this-&gt;pProtocol = protocol;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void handle() &#123;</span><br><span class="line">		this-&gt;pProtoco1-&gt;AddDiamond () ;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	HandleClientProtocol* pProtocol;</span><br><span class="line">&#125;;</span><br><span class="line">//服务器程序</span><br><span class="line">class Serser&#123;</span><br><span class="line">public:</span><br><span class="line">	void addRequest(AbstractCommand* command)&#123;</span><br><span class="line">		mCommands. push(command) ;</span><br><span class="line">	&#125;</span><br><span class="line">	void startHandle() &#123;</span><br><span class="line">		while (!mCommands.empty())&#123;</span><br><span class="line">			AbstractCommand* command =mCommands.front() ;</span><br><span class="line">			command-&gt;handle();</span><br><span class="line">			mCommands.pop();</span><br><span class="line">		&#125;</span><br><span class="line">public:</span><br><span class="line">	queue&lt;AbstractCommand*&gt; mCommands;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()&#123;</span><br><span class="line">	HandleClientProtocol* protocol = new HandleClientProtocol;</span><br><span class="line">	//客户端增加金币的请求</span><br><span class="line">	AbstractCommand* addmoney = new AddMoneyCommand(protocol);</span><br><span class="line">	//客户端增加钻石的请求</span><br><span class="line">	AbstractCommand* adddiamond = new AddDiamondCommand(protocol);</span><br><span class="line">	addmoney-&gt;handle();</span><br><span class="line">	adddiamond-&gt;handle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>随着交通信号灯的变化，汽车的行为也将随之而变化，一盏交通信号灯可以指挥多辆汽车。<br>观察者模式是用于建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象,其他对象将相应作出反应。在观察者模式中，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">class AbstractHero&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void Update()= 0;</span><br><span class="line">&#125;;</span><br><span class="line">class HeroA : public AbstractHero&#123;</span><br><span class="line">public:</span><br><span class="line">	HeroA() &#123;</span><br><span class="line">		cout &lt;&lt;“英雄A正在措BOSs ...&quot;&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void Update() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;英雄A停止打,待机状态...&quot; &lt;&lt; end1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class HeroB :public AbstractHero&#123;</span><br><span class="line">public:</span><br><span class="line">	HeroB() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;英雄B正在打BOSs ...&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void Update() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;英雄B停止打,待机状态...&quot;&lt;&lt; end1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//观察目标抽象</span><br><span class="line">class AbstractBoss&#123;</span><br><span class="line">public:</span><br><span class="line">//添加观察者</span><br><span class="line">	virtual void addHero(AbstractHero* hero)= 0;//删除观察者</span><br><span class="line">	virtual void deleteHero(AbstractHero* hero) = 0;//通知所有观察者</span><br><span class="line">	virtual void notify() = 0;</span><br><span class="line">&#125;;</span><br><span class="line">//具体的观察者BOSSA</span><br><span class="line">class BOSSA : public AbstractBoss&#123; </span><br><span class="line">public:</span><br><span class="line">	virtual void addHero(AbstractHero* hero)&#123;</span><br><span class="line">		pHeroList.push_back(hero);</span><br><span class="line">	&#125;</span><br><span class="line">//删除观察者</span><br><span class="line">	virtual void deleteHero(AbstractHero* hero)&#123;</span><br><span class="line">		pHeroList.remove(hero) ;</span><br><span class="line">	&#125;</span><br><span class="line">//通知所有观察者</span><br><span class="line">	virtual void notify() &#123;</span><br><span class="line">		for (list&lt;AbstractHero*&gt; ::iterator it = pHeroList.begin(); it != pHeroList.end();it++)</span><br><span class="line">			(*it)-&gt;Update();</span><br><span class="line">public:</span><br><span class="line">	list&lt;AbstractHero*&gt; pHeroList;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()&#123;</span><br><span class="line">	//创建观察者</span><br><span class="line">	AbstractHero* heroA = new HeroA;</span><br><span class="line">	AbstractHero* heroB = new HeroB;</span><br><span class="line">	AbstractHero* heroC= new HeroC;</span><br><span class="line">	AbstractHero* heroD= new HeroD;</span><br><span class="line">	AbstractHero* heroE = new HeroE; </span><br><span class="line">	//创建观察目标</span><br><span class="line">	AbstractBoss* bossA = new BOSSA;</span><br><span class="line">	bossA-&gt;addHero(heroA);</span><br><span class="line">	bossA-&gt;addHero(heroB);</span><br><span class="line">	bossA-&gt;addHero(heroC);</span><br><span class="line">	bossA-&gt;addHero(heroD);</span><br><span class="line">	bossA-&gt;addHero(heroE);</span><br><span class="line">	cout &lt;&lt; &quot;heroC阵亡...&quot; &lt;&lt;endl;</span><br><span class="line">	bossA-&gt;deleteHero(heroC);</span><br><span class="line">	cout &lt;&lt; &quot;Boss死了...通知其他英雄停止攻击，抢装备...&quot;&lt;&lt; end1;</span><br><span class="line">	bossA-&gt;notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>装饰模式又叫包装模式，通过一种对客户端透明的方式来扩展对象功能，是继承关系的一种替代。<br>装饰模式就是把要附加的功能努别放在单独的类中，并让这个类包含它要装饰的对象，当需要执行时，客户端就可以有选择的、按顺序的使用装饰功能包装对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">//一般情况下用继承实现类的功能拓展/装饰模式可以动态给一个类增加功能</span><br><span class="line">//抽象英雄</span><br><span class="line">class AbstractHero&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void ShowStatus() = 0;</span><br><span class="line">public:</span><br><span class="line">	int mHp;</span><br><span class="line">	int mMp;</span><br><span class="line">	int mAt;</span><br><span class="line">	int mDf ;</span><br><span class="line">&#125;;</span><br><span class="line">//具体英雄</span><br><span class="line">class HeroA : public AbstractHero&#123;</span><br><span class="line">public:</span><br><span class="line">	HeroA()&#123;</span><br><span class="line">		mHp= 0 ;</span><br><span class="line">		mMp= 0 ;</span><br><span class="line">		mAt= 0 ;</span><br><span class="line">		mDf= 0 ;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	virtual void ShowStatus() &#123;</span><br><span class="line">		cout&lt;&quot;血量:&quot;&lt;&lt; mHp &lt;&lt; end1;</span><br><span class="line">		cout &lt;&lt;&quot;魔法:&quot;&lt;&lt; mMp &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt;&quot;攻击:&quot;&lt;&lt; mAt&lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt;&quot;防御:&quot;&lt;&lt; mDf&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//英雄穿上某个装饰物那么他还是个英雄</span><br><span class="line">class AbstractEquipment : public AbstractHero&#123;</span><br><span class="line">public:</span><br><span class="line">	AbstractEquipment(AbstractHero* hero)&#123;</span><br><span class="line">		this-&gt;pHero = hero;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void ShowStatus() &#123;&#125;</span><br><span class="line">public:</span><br><span class="line">	AbstractHero* pHero;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//狂徒</span><br><span class="line">class KuangtuEquipment : public AbstractEquipment &#123;</span><br><span class="line">public:</span><br><span class="line">	KuangtuEquipment(AbstractHero* hero) :AbstractEquipment(hero)&#123;&#125;//依赖基类的构造函数来完成部分数据成员的初始化</span><br><span class="line">	//增加额外功能</span><br><span class="line">	void AddKuangtu() &#123;</span><br><span class="line">		cout &lt;&lt;&quot;英雄穿上狂徒之后...&quot;&lt;&lt;endl;</span><br><span class="line">		this-&gt;mHp = this-&gt;pHero-&gt;mHp ;</span><br><span class="line">		this-&gt;mMpI= this-&gt;pHero-&gt;mMp ;</span><br><span class="line">		this-&gt;mAt = this-&gt;pHero-&gt;mAt ;</span><br><span class="line">		this-&gt;mDf = this-&gt;pHero-&gt;mDf + 30;</span><br><span class="line">		delete this-&gt;pHero;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void ShowStatus() &#123;</span><br><span class="line">		AddKuangtu();//额外增加功能</span><br><span class="line">		cout &lt;&lt;&quot;血量:&quot;&lt;&lt; mHp &lt;&lt; endl;</span><br><span class="line">		cout&lt;&lt;&quot;魔法:&quot;&lt;&lt; mMp &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt;&quot;攻击:&quot;&lt;&lt; mAt &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt;&quot;&quot;防御:&quot;&lt;&lt; mDf &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test01 ()&#123;</span><br><span class="line">	AbstractHero* hero = new HeroA;</span><br><span class="line">	hero-&gt;ShowStatus() ;</span><br><span class="line">	cout &lt;&lt; &quot;—------―----&quot; &lt;&lt; endl;</span><br><span class="line">	//给裸奔的英雄穿上衣服</span><br><span class="line">	hero = new KuangtuEquipment (hero);</span><br><span class="line">	hero-&gt;ShowStatus () ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/18/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/18/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/" class="post-title-link" itemprop="url">Linux网络编程-web大练习-B/S</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-18 15:10:55" itemprop="dateCreated datePublished" datetime="2023-07-18T15:10:55+08:00">2023-07-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-20 17:10:28" itemprop="dateModified" datetime="2023-07-20T17:10:28+08:00">2023-07-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="http协议请求、应答协议基础格式"><a href="#http协议请求、应答协议基础格式" class="headerlink" title="http协议请求、应答协议基础格式"></a>http协议请求、应答协议基础格式</h2><h3 id="HITP协议基础"><a href="#HITP协议基础" class="headerlink" title="HITP协议基础"></a>HITP协议基础</h3><p>HTTP，超文本传输协议（ HyperText Transfer Protocol )。互联网应用最为广泛的一种网络应用层协议。它可以减少网络传输，使浏览器更加高效。</p>
<p>通常HTTP消息包括客户机向服务器的请求消息和服务器向客户机的响应消息。</p>
<h3 id="请求消息-Request"><a href="#请求消息-Request" class="headerlink" title="请求消息(Request)"></a>请求消息(Request)</h3><p>浏览器—&gt;发给—&gt;服务器。主旨内容包含4部分: </p>
<ul>
<li>请求行:说明请求类型，要访问的资源，以及使用的http版本。                                                                                                                                         </li>
<li>请求头:说明服务器要使用的附加信息</li>
<li>空行:必须!，即使没有请求数据</li>
<li>请求数据:也叫主体，可以添加任意的其他数据</li>
</ul>
<p><img src="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230718151435496.png" alt="image-20230718151435496"></p>
<img src="/2023/07/18/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230718151435496.png" class title="This is an test image">

<h3 id="响应消息-Response"><a href="#响应消息-Response" class="headerlink" title="响应消息(Response)"></a>响应消息(Response)</h3><p>服务器―&gt;发给―&gt;浏览器。主旨内容包含4部分: </p>
<ul>
<li>状态行:包括http协议版本号，状态码，状态信息</li>
<li>消息报头:说明客户端要使用的一些附加信息</li>
<li>空行:必须!</li>
<li>响应正文:服务器返回给客户端的文本信息</li>
</ul>
<p><img src="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230718151614718.png" alt="image-20230718151614718"></p>
<img src="/2023/07/18/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230718151614718.png" class title="This is an test image">

<p><img src="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230718151728604.png" alt="image-20230718151728604"></p>
<img src="/2023/07/18/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230718151728604.png" class title="This is an test image">

<h2 id="服务器框架复习和getline函数"><a href="#服务器框架复习和getline函数" class="headerlink" title="服务器框架复习和getline函数"></a>服务器框架复习和getline函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;netinet/in.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">#include &lt;sys/wait.h&gt;  </span><br><span class="line">#include &lt;sys/types.h&gt;  </span><br><span class="line">#include &lt;sys/epoll.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;fcntl.h&gt;  </span><br><span class="line">  </span><br><span class="line">#define MAXSIZE 2048  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">int init_listen_fd(int port, int epfd)  </span><br><span class="line">&#123;  </span><br><span class="line">    //　创建监听的套接字 lfd  </span><br><span class="line">    int lfd = socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">    if (lfd == -1) &#123;      </span><br><span class="line">        perror(&quot;socket error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">    // 创建服务器地址结构 IP+port  </span><br><span class="line">    struct sockaddr_in srv_addr;  </span><br><span class="line">      </span><br><span class="line">    bzero(&amp;srv_addr, sizeof(srv_addr));  </span><br><span class="line">    srv_addr.sin_family = AF_INET;  </span><br><span class="line">    srv_addr.sin_port = htons(port);  </span><br><span class="line">    srv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">  </span><br><span class="line">    // 端口复用  </span><br><span class="line">    int opt = 1;  </span><br><span class="line">    setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt));  </span><br><span class="line">      </span><br><span class="line">    // 给 lfd 绑定地址结构  </span><br><span class="line">    int ret = bind(lfd, (struct sockaddr*)&amp;srv_addr, sizeof(srv_addr));  </span><br><span class="line">    if (ret == -1) &#123;     </span><br><span class="line">        perror(&quot;bind error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">    // 设置监听上限  </span><br><span class="line">    ret = listen(lfd, 128);  </span><br><span class="line">    if (ret == -1) &#123;   </span><br><span class="line">        perror(&quot;listen error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    // lfd 添加到 epoll 树上  </span><br><span class="line">    struct epoll_event ev;  </span><br><span class="line">    ev.events = EPOLLIN;  </span><br><span class="line">    ev.data.fd = lfd;  </span><br><span class="line">      </span><br><span class="line">    ret = epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;ev);  </span><br><span class="line">    if (ret == -1) &#123;   </span><br><span class="line">        perror(&quot;epoll_ctl add lfd error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return lfd;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void do_accept(int lfd, int epfd)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct sockaddr_in clt_addr;  </span><br><span class="line">    socklen_t clt_addr_len = sizeof(clt_addr);  </span><br><span class="line">      </span><br><span class="line">    int cfd = accept(lfd, (struct sockaddr*)&amp;clt_addr, &amp;clt_addr_len);  </span><br><span class="line">    if (cfd == -1) &#123;     </span><br><span class="line">        perror(&quot;accept error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // 打印客户端IP+port  </span><br><span class="line">    char client_ip[64] = &#123;0&#125;;  </span><br><span class="line">    printf(&quot;New Client IP: %s, Port: %d, cfd = %d\n&quot;,  </span><br><span class="line">           inet_ntop(AF_INET, &amp;clt_addr.sin_addr.s_addr, client_ip, sizeof(client_ip)),  </span><br><span class="line">           ntohs(clt_addr.sin_port), cfd);  </span><br><span class="line">  </span><br><span class="line">    // 设置 cfd 非阻塞  </span><br><span class="line">    int flag = fcntl(cfd, F_GETFL);  </span><br><span class="line">    flag |= O_NONBLOCK;  </span><br><span class="line">    fcntl(cfd, F_SETFL, flag);  </span><br><span class="line">  </span><br><span class="line">    // 将新节点cfd 挂到 epoll 监听树上  </span><br><span class="line">    struct epoll_event ev;  </span><br><span class="line">    ev.data.fd = cfd;  </span><br><span class="line">      </span><br><span class="line">    // 边沿非阻塞模式  </span><br><span class="line">    ev.events = EPOLLIN | EPOLLET;  </span><br><span class="line">      </span><br><span class="line">    int ret = epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;ev);  </span><br><span class="line">    if (ret == -1)  &#123;  </span><br><span class="line">        perror(&quot;epoll_ctl add cfd error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void do_read(int cfd, int epfd)  </span><br><span class="line">&#123;  </span><br><span class="line">    // read cfd 小 -- 大 write 回  </span><br><span class="line">    // 读取一行http协议， 拆分， 获取 get 文件名 协议号  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void epoll_run(int port)  </span><br><span class="line">&#123;  </span><br><span class="line">    int i = 0;  </span><br><span class="line">    struct epoll_event all_events[MAXSIZE];  </span><br><span class="line">  </span><br><span class="line">    // 创建一个epoll监听树根  </span><br><span class="line">    int epfd = epoll_create(MAXSIZE);  </span><br><span class="line">    if (epfd == -1) &#123;   </span><br><span class="line">        perror(&quot;epoll_create error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    // 创建lfd，并添加至监听树  </span><br><span class="line">    int lfd = init_listen_fd(port, epfd);  </span><br><span class="line">     </span><br><span class="line">    while (1) &#123;  </span><br><span class="line">        // 监听节点对应事件  </span><br><span class="line">        int ret = epoll_wait(epfd, all_events, MAXSIZE, -1);  </span><br><span class="line">        if (ret == -1) &#123;        </span><br><span class="line">            perror(&quot;epoll_wait error&quot;);  </span><br><span class="line">            exit(1);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        for (i=0; i&lt;ret; ++i) &#123;  </span><br><span class="line">                  </span><br><span class="line">            // 只处理读事件, 其他事件默认不处理  </span><br><span class="line">            struct epoll_event *pev = &amp;all_events[i];  </span><br><span class="line">              </span><br><span class="line">            // 不是读事件  </span><br><span class="line">            if (!(pev-&gt;events &amp; EPOLLIN)) &#123;                       </span><br><span class="line">                continue;  </span><br><span class="line">            &#125;  </span><br><span class="line">            if (pev-&gt;data.fd == lfd) &#123;       // 接受连接请求     </span><br><span class="line">                  </span><br><span class="line">                do_accept(lfd, epfd);  </span><br><span class="line">                  </span><br><span class="line">            &#125; else &#123;                        // 读数据  </span><br><span class="line">                  </span><br><span class="line">                do_read(pev-&gt;data.fd, epfd);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;   </span><br><span class="line">    // 命令行参数获取 端口 和 server提供的目录  </span><br><span class="line">    if (argc &lt; 3)   </span><br><span class="line">    &#123;  </span><br><span class="line">        printf(&quot;./server port path\n&quot;);   </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    // 获取用户输入的端口   </span><br><span class="line">    int port = atoi(argv[1]);  </span><br><span class="line">      </span><br><span class="line">    // 改变进程工作目录  </span><br><span class="line">    int ret = chdir(argv[2]);  </span><br><span class="line">    if (ret != 0) &#123;  </span><br><span class="line">        perror(&quot;chdir error&quot;);    </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // 启动 epoll监听  </span><br><span class="line">    epoll_run(port);  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="单文件通信流程分析"><a href="#单文件通信流程分析" class="headerlink" title="单文件通信流程分析"></a>单文件通信流程分析</h2><ol>
<li><p>getline() 获取 http协议的第一行。</p>
</li>
<li><p>从首行中拆分  GET、文件名、协议版本。 获取用户请求的文件名。</p>
</li>
<li><p>判断文件是否存在。 stat()</p>
</li>
<li><p>判断是文件还是目录。</p>
</li>
<li><p>是文件– open – read – 写回给浏览器</p>
</li>
<li><p>先写 http 应答协议头 ： 	http&#x2F;1.1 200 ok</p>
<pre><code>         Content-Type：text/plain; charset=iso-8859-1
</code></pre>
</li>
</ol>
<h3 id="正则表达式获取文件名"><a href="#正则表达式获取文件名" class="headerlink" title="正则表达式获取文件名"></a>正则表达式获取文件名</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void do_read(int cfd, int epfd)  </span><br><span class="line">&#123;  </span><br><span class="line">    // 读取一行http协议， 拆分， 获取 get 文件名 协议号     </span><br><span class="line">    char line[1024] = &#123;0&#125;;  </span><br><span class="line">    char method[16], path[256], protocol[16];   </span><br><span class="line">      </span><br><span class="line">    int len = get_line(cfd, line, sizeof(line)); //读 http请求协议首行 GET /hello.c HTTP/1.1  </span><br><span class="line">    if (len == 0) &#123;  </span><br><span class="line">        printf(&quot;服务器，检查到客户端关闭....\n&quot;);     </span><br><span class="line">        disconnect(cfd, epfd);  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">                  </span><br><span class="line">        sscanf(line, &quot;%[^ ] %[^ ] %[^ ]&quot;, method, path, protocol);    //%[^ ]取遇到空格为止的字符串</span><br><span class="line">        printf(&quot;method=%s, path=%s, protocol=%s\n&quot;, method, path, protocol);  </span><br><span class="line">          </span><br><span class="line">        while (1) &#123;  </span><br><span class="line">            char buf[1024] = &#123;0&#125;;  </span><br><span class="line">            len = get_line(cfd, buf, sizeof(buf));    </span><br><span class="line">            if (buf[0] == &#x27;\n&#x27;) &#123;  </span><br><span class="line">                break;    </span><br><span class="line">            &#125; else if (len == -1)  </span><br><span class="line">                break;  </span><br><span class="line">        &#125;     </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    if (strncasecmp(method, &quot;GET&quot;, 3) == 0)  </span><br><span class="line">    &#123;  </span><br><span class="line">        char *file = path+1;   // 取出 客户端要访问的文件名  </span><br><span class="line">          </span><br><span class="line">        http_request(cfd, file);  </span><br><span class="line">          </span><br><span class="line">        disconnect(cfd, epfd);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230719143817230.png" alt="image-20230719143817230"></p>
<img src="/2023/07/18/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230719143817230.png" class title="This is an test image">

<h3 id="判断文件是否存在"><a href="#判断文件是否存在" class="headerlink" title="判断文件是否存在"></a>判断文件是否存在</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 处理http请求， 判断文件是否存在， 回发  </span><br><span class="line">void http_request(int cfd, const char *file)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct stat sbuf;  </span><br><span class="line">      </span><br><span class="line">    // 判断文件是否存在  </span><br><span class="line">    int ret = stat(file, &amp;sbuf);  </span><br><span class="line">    if (ret != 0) &#123;  </span><br><span class="line">        // 回发浏览器 404 错误页面  </span><br><span class="line">        perror(&quot;stat&quot;);  </span><br><span class="line">        exit(1);      </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    if(S_ISREG(sbuf.st_mode)) &#123;     // 是一个普通文件  </span><br><span class="line">          </span><br><span class="line">        // 回发 http协议应答  </span><br><span class="line">        //send_respond(cfd, 200, &quot;OK&quot;, &quot; Content-Type: text/plain; charset=iso-8859-1&quot;, sbuf.st_size);     </span><br><span class="line">        send_respond(cfd, 200, &quot;OK&quot;, &quot;Content-Type:image/jpeg&quot;, -1);  </span><br><span class="line">        //send_respond(cfd, 200, &quot;OK&quot;, &quot;audio/mpeg&quot;, -1);  </span><br><span class="line">          </span><br><span class="line">        // 回发 给客户端请求数据内容。  </span><br><span class="line">        send_file(cfd, file);  </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="写出http应答协议头"><a href="#写出http应答协议头" class="headerlink" title="写出http应答协议头"></a>写出http应答协议头</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">	// 客户端端的fd, 错误号，错误描述，回发文件类型， 文件长度   </span><br><span class="line">void send_respond(int cfd, int no, char *disp, char *type, int len)  </span><br><span class="line">&#123;  </span><br><span class="line">    char buf[4096] = &#123;0&#125;;  </span><br><span class="line">      </span><br><span class="line">    sprintf(buf, &quot;HTTP/1.1 %d %s\r\n&quot;, no, disp);  </span><br><span class="line">    send(cfd, buf, strlen(buf), 0);  </span><br><span class="line">      </span><br><span class="line">    sprintf(buf, &quot;Content-Type: %s\r\n&quot;, type);  </span><br><span class="line">    sprintf(buf+strlen(buf), &quot;Content-Length:%d\r\n&quot;, len);  </span><br><span class="line">    send(cfd, buf, strlen(buf), 0);  </span><br><span class="line">      </span><br><span class="line">    send(cfd, &quot;\r\n&quot;, 2, 0);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="写数据给浏览器"><a href="#写数据给浏览器" class="headerlink" title="写数据给浏览器"></a>写数据给浏览器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 发送服务器本地文件 给浏览器  </span><br><span class="line">void send_file(int cfd, const char *file)  </span><br><span class="line">&#123;  </span><br><span class="line">    int n = 0, ret;  </span><br><span class="line">    char buf[4096] = &#123;0&#125;;  </span><br><span class="line">      </span><br><span class="line">    // 打开的服务器本地文件。  --- cfd 能访问客户端的 socket  </span><br><span class="line">    int fd = open(file, O_RDONLY);  </span><br><span class="line">    if (fd == -1) &#123;  </span><br><span class="line">        // 404 错误页面  </span><br><span class="line">        perror(&quot;open error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    while ((n = read(fd, buf, sizeof(buf))) &gt; 0) &#123;         </span><br><span class="line">        ret = send(cfd, buf, n, 0);  </span><br><span class="line">        if (ret == -1) &#123;  </span><br><span class="line">            perror(&quot;send error&quot;);     </span><br><span class="line">            exit(1);  </span><br><span class="line">        &#125;  </span><br><span class="line">        if (ret &lt; 4096)        </span><br><span class="line">            printf(&quot;-----send ret: %d\n&quot;, ret);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    close(fd);        </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="错误页面展示"><a href="#错误页面展示" class="headerlink" title="错误页面展示"></a>错误页面展示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void send_error(int cfd, int status, char *title, char *text)  </span><br><span class="line">&#123;  </span><br><span class="line">    char buf[4096] = &#123;0&#125;;  </span><br><span class="line">  </span><br><span class="line">    sprintf(buf, &quot;%s %d %s\r\n&quot;, &quot;HTTP/1.1&quot;, status, title);  </span><br><span class="line">    sprintf(buf+strlen(buf), &quot;Content-Type:%s\r\n&quot;, &quot;text/html&quot;);  </span><br><span class="line">    sprintf(buf+strlen(buf), &quot;Content-Length:%d\r\n&quot;, -1);  </span><br><span class="line">    sprintf(buf+strlen(buf), &quot;Connection: close\r\n&quot;);  </span><br><span class="line">    send(cfd, buf, strlen(buf), 0);  </span><br><span class="line">    send(cfd, &quot;\r\n&quot;, 2, 0);  </span><br><span class="line">  </span><br><span class="line">    memset(buf, 0, sizeof(buf));  </span><br><span class="line">  </span><br><span class="line">    sprintf(buf, &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;%d %s&lt;/title&gt;&lt;/head&gt;\n&quot;, status, title);  </span><br><span class="line">    sprintf(buf+strlen(buf), &quot;&lt;body bgcolor=\&quot;#cc99cc\&quot;&gt;&lt;h2 align=\&quot;center\&quot;&gt;%d %s&lt;/h4&gt;\n&quot;, status, title);  </span><br><span class="line">    sprintf(buf+strlen(buf), &quot;%s\n&quot;, text);  </span><br><span class="line">    sprintf(buf+strlen(buf), &quot;&lt;hr&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n&quot;);  </span><br><span class="line">    send(cfd, buf, strlen(buf), 0);  </span><br><span class="line">      </span><br><span class="line">    return ;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="浏览器请求目录"><a href="#浏览器请求目录" class="headerlink" title="浏览器请求目录"></a>浏览器请求目录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// http请求处理  </span><br><span class="line">void http_request(const char* request, int cfd)  </span><br><span class="line">&#123;  </span><br><span class="line">    // 拆分http请求行  </span><br><span class="line">    char method[12], path[1024], protocol[12];  </span><br><span class="line">    sscanf(request, &quot;%[^ ] %[^ ] %[^ ]&quot;, method, path, protocol);  </span><br><span class="line">    printf(&quot;method = %s, path = %s, protocol = %s\n&quot;, method, path, protocol);  </span><br><span class="line">  </span><br><span class="line">    // 转码 将不能识别的中文乱码 -&gt; 中文  </span><br><span class="line">    // 解码 %23 %34 %5f  </span><br><span class="line">    decode_str(path, path);  </span><br><span class="line">          </span><br><span class="line">    char* file = path+1; // 去掉path中的/ 获取访问文件名  </span><br><span class="line">      </span><br><span class="line">    // 如果没有指定访问的资源, 默认显示资源目录中的内容  </span><br><span class="line">    if(strcmp(path, &quot;/&quot;) == 0) &#123;      </span><br><span class="line">        // file的值, 资源目录的当前位置  </span><br><span class="line">        file = &quot;./&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // 获取文件属性  </span><br><span class="line">    struct stat st;  </span><br><span class="line">    int ret = stat(file, &amp;st);  </span><br><span class="line">    if(ret == -1) &#123;   </span><br><span class="line">        send_error(cfd, 404, &quot;Not Found&quot;, &quot;NO such file or direntry&quot;);       </span><br><span class="line">        return;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // 判断是目录还是文件  </span><br><span class="line">    if(S_ISDIR(st.st_mode)) &#123;       // 目录   S_ISDIR是stat的内置函数可以用来判断</span><br><span class="line">        // 发送头信息  </span><br><span class="line">        send_respond_head(cfd, 200, &quot;OK&quot;, get_file_type(&quot;.html&quot;), -1);  </span><br><span class="line">        // 发送目录信息  </span><br><span class="line">        send_dir(cfd, file);  </span><br><span class="line">    &#125; else if(S_ISREG(st.st_mode)) &#123; // 文件          </span><br><span class="line">        // 发送消息报头  </span><br><span class="line">        send_respond_head(cfd, 200, &quot;OK&quot;, get_file_type(file), st.st_size);  </span><br><span class="line">        // 发送文件内容  </span><br><span class="line">        send_file(cfd, file);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="判断文件类型"><a href="#判断文件类型" class="headerlink" title="判断文件类型"></a>判断文件类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 通过文件名获取文件的类型  </span><br><span class="line">const char *get_file_type(const char *name)  </span><br><span class="line">&#123;  </span><br><span class="line">    char* dot;  </span><br><span class="line">  </span><br><span class="line">    // 自右向左查找‘.’字符, 如不存在返回NULL  </span><br><span class="line">    dot = strrchr(name, &#x27;.&#x27;);     </span><br><span class="line">    if (dot == NULL)  </span><br><span class="line">        return &quot;text/plain; charset=utf-8&quot;;  </span><br><span class="line">    if (strcmp(dot, &quot;.html&quot;) == 0 || strcmp(dot, &quot;.htm&quot;) == 0)  </span><br><span class="line">        return &quot;text/html; charset=utf-8&quot;;  </span><br><span class="line">    if (strcmp(dot, &quot;.jpg&quot;) == 0 || strcmp(dot, &quot;.jpeg&quot;) == 0)  </span><br><span class="line">        return &quot;image/jpeg&quot;;  </span><br><span class="line">    if (strcmp(dot, &quot;.gif&quot;) == 0)  </span><br><span class="line">        return &quot;image/gif&quot;;  </span><br><span class="line">    if (strcmp(dot, &quot;.png&quot;) == 0)  </span><br><span class="line">        return &quot;image/png&quot;;  </span><br><span class="line">    if (strcmp(dot, &quot;.css&quot;) == 0)  </span><br><span class="line">        return &quot;text/css&quot;;  </span><br><span class="line">    if (strcmp(dot, &quot;.au&quot;) == 0)  </span><br><span class="line">        return &quot;audio/basic&quot;;  </span><br><span class="line">    if (strcmp( dot, &quot;.wav&quot; ) == 0)  </span><br><span class="line">        return &quot;audio/wav&quot;;  </span><br><span class="line">    if (strcmp(dot, &quot;.avi&quot;) == 0)  </span><br><span class="line">        return &quot;video/x-msvideo&quot;;  </span><br><span class="line">    if (strcmp(dot, &quot;.mov&quot;) == 0 || strcmp(dot, &quot;.qt&quot;) == 0)  </span><br><span class="line">        return &quot;video/quicktime&quot;;  </span><br><span class="line">    if (strcmp(dot, &quot;.mpeg&quot;) == 0 || strcmp(dot, &quot;.mpe&quot;) == 0)  </span><br><span class="line">        return &quot;video/mpeg&quot;;  </span><br><span class="line">    if (strcmp(dot, &quot;.vrml&quot;) == 0 || strcmp(dot, &quot;.wrl&quot;) == 0)  </span><br><span class="line">        return &quot;model/vrml&quot;;  </span><br><span class="line">    if (strcmp(dot, &quot;.midi&quot;) == 0 || strcmp(dot, &quot;.mid&quot;) == 0)  </span><br><span class="line">        return &quot;audio/midi&quot;;  </span><br><span class="line">    if (strcmp(dot, &quot;.mp3&quot;) == 0)  </span><br><span class="line">        return &quot;audio/mpeg&quot;;  </span><br><span class="line">    if (strcmp(dot, &quot;.ogg&quot;) == 0)  </span><br><span class="line">        return &quot;application/ogg&quot;;  </span><br><span class="line">    if (strcmp(dot, &quot;.pac&quot;) == 0)  </span><br><span class="line">        return &quot;application/x-ns-proxy-autoconfig&quot;;  </span><br><span class="line">  </span><br><span class="line">    return &quot;text/plain; charset=utf-8&quot;;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230720165731522.png" alt="image-20230720165731522"></p>
<img src="/2023/07/18/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230720165731522.png" class title="This is an test image">

<p><img src="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230720165803959.png" alt="image-20230720165803959"></p>
<img src="/2023/07/18/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230720165803959.png" class title="This is an test image">

<h3 id="汉字字符编码和解码"><a href="#汉字字符编码和解码" class="headerlink" title="汉字字符编码和解码"></a>汉字字符编码和解码</h3><p>URL中的汉字默认是存为Unicode码</p>
<p><img src="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230720165842142.png" alt="image-20230720165842142"></p>
<img src="/2023/07/18/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230720165842142.png" class title="This is an test image">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// 16进制数转化为10进制</span><br><span class="line">int hexit(char c)</span><br><span class="line">&#123;</span><br><span class="line">    if (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;)</span><br><span class="line">        return c - &#x27;0&#x27;;</span><br><span class="line">    if (c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;f&#x27;)</span><br><span class="line">        return c - &#x27;a&#x27; + 10;</span><br><span class="line">    if (c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;F&#x27;)</span><br><span class="line">        return c - &#x27;A&#x27; + 10;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> *  这里的内容是处理%20之类的东西！是&quot;解码&quot;过程。</span><br><span class="line"> *  %20 URL编码中的‘ ’(space)</span><br><span class="line"> *  %21 &#x27;!&#x27; %22 &#x27;&quot;&#x27; %23 &#x27;#&#x27; %24 &#x27;$&#x27;</span><br><span class="line"> *  %25 &#x27;%&#x27; %26 &#x27;&amp;&#x27; %27 &#x27;&#x27;&#x27; %28 &#x27;(&#x27;......</span><br><span class="line"> *  相关知识html中的‘ ’(space)是&amp;nbsp</span><br><span class="line"> */</span><br><span class="line">void encode_str(char* to, int tosize, const char* from)</span><br><span class="line">&#123;</span><br><span class="line">    int tolen;</span><br><span class="line"></span><br><span class="line">    for (tolen = 0; *from != &#x27;\0&#x27; &amp;&amp; tolen + 4 &lt; tosize; ++from) &#123;    </span><br><span class="line">        if (isalnum(*from) || strchr(&quot;/_.-~&quot;, *from) != (char*)0) &#123;      </span><br><span class="line">            *to = *from;</span><br><span class="line">            ++to;</span><br><span class="line">            ++tolen;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sprintf(to, &quot;%%%02x&quot;, (int) *from &amp; 0xff);</span><br><span class="line">            to += 3;</span><br><span class="line">            tolen += 3;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *to = &#x27;\0&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void decode_str(char *to, char *from)</span><br><span class="line">&#123;</span><br><span class="line">    for ( ; *from != &#x27;\0&#x27;; ++to, ++from  ) &#123;     </span><br><span class="line">        if (from[0] == &#x27;%&#x27; &amp;&amp; isxdigit(from[1]) &amp;&amp; isxdigit(from[2])) &#123;       </span><br><span class="line">            *to = hexit(from[1])*16 + hexit(from[2]);</span><br><span class="line">            from += 2;                      </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            *to = *from;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *to = &#x27;\0&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="浏览器请求ico"><a href="#浏览器请求ico" class="headerlink" title="浏览器请求ico"></a>浏览器请求ico</h2><p>准备一个favicon.ico文件放置到服务器提供访问的资源目录中。<br>浏览器在请求图片的同时，会请求一个ico图标，用于浏览器<code>&lt;title&gt;</code>标签文字部分前端的小图标显示。<br>这个ico的文件名固定——favicon.ico。因此自行准备一个ico文件,放置于服务器提供给浏览器访问的目标目录即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">favicon.ico 图标用于收藏夹图标和浏览器标签上的显示，如果不设置，浏览器会请求网站根目录的这个图标，如果网站根目录也没有这图标会产生 404。出于优化的考虑，要么就有这个图标，要么就禁止产生这个请求。</span><br><span class="line">在做 H5 混合应用的时候，不希望产生 favicon.ico 的请求。</span><br><span class="line">可以在页面的 &lt;head&gt; 区域，加上如下代码实现屏蔽：</span><br><span class="line">&lt;link rel=&quot;icon&quot; href=&quot;data:;base64,=&quot;&gt;，或者详细一点&lt;link rel=&quot;icon&quot; href=&quot;data:image/ico;base64,aWNv&quot;&gt;，当然，既然是 dataURL 方式，IE &lt; 8 等 old brower 就别想了</span><br></pre></td></tr></table></figure>

<h3 id="容错处理"><a href="#容错处理" class="headerlink" title="容错处理"></a>容错处理</h3><p>返回值一定要检查!!!.<br>尤其是 read、write、recv、send、recvfrom、sendto函数，返回的errno为 EINTR和EAGAIN时，不代表是一个错误，但会严重影响程序运行结果!通常使用continue来处理这种情况即可。</p>
<h2 id="快捷遍历目录scandir"><a href="#快捷遍历目录scandir" class="headerlink" title="快捷遍历目录scandir()"></a>快捷遍历目录scandir()</h2><p>服务器端，可以使用文件操作时”递归遍历目录的”源码，实现遍历目录内文件名，回显给浏览器。另外标准C库中,提供了scandir函数,可以便捷的实现该功能。函数原型如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int scandir(const char *dirp, struct dirent ***namelist,int (*filter)(const struct dirent *),int (*compar)(const struct dirent **, const struct dirent **));+</span><br><span class="line">scandir(待操作的目录，&amp;子目录项列表数组，过滤器(通常NULL)， alphasort) dirp:待访问的目录名称</span><br><span class="line">struct dirent类型:(参考readdir()函数)。</span><br></pre></td></tr></table></figure>

<p><img src="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230720155912787.png" alt="image-20230720155912787"></p>
<img src="/2023/07/18/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230720155912787.png" class title="This is an test image">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">compar:参数取如下函数即可:</span><br><span class="line">int alphasort(const void *a, const void *b);默认是由的排序算法。</span><br><span class="line">调用:struct dirent** namelist;</span><br><span class="line">int num = scandir(dirname,&amp;namlelist,NULL, alphasort);</span><br><span class="line">for (i = 0;i &lt; num;++i)</span><br><span class="line">	char* name = namelist[i]-&gt;d_name;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">// 发送目录内容</span><br><span class="line">void send_dir(int cfd, const char* dirname)</span><br><span class="line">&#123;</span><br><span class="line">    int i, ret;</span><br><span class="line"></span><br><span class="line">    // 拼一个html页面&lt;table&gt;&lt;/table&gt;</span><br><span class="line">    char buf[4094] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">    sprintf(buf, &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;目录名: %s&lt;/title&gt;&lt;/head&gt;&quot;, dirname);</span><br><span class="line">    sprintf(buf+strlen(buf), &quot;&lt;body&gt;&lt;h1&gt;当前目录: %s&lt;/h1&gt;&lt;table&gt;&quot;, dirname);</span><br><span class="line"></span><br><span class="line">    char enstr[1024] = &#123;0&#125;;</span><br><span class="line">    char path[1024] = &#123;0&#125;;</span><br><span class="line">    </span><br><span class="line">    // 目录项二级指针</span><br><span class="line">    struct dirent** ptr;</span><br><span class="line">    int num = scandir(dirname, &amp;ptr, NULL, alphasort);</span><br><span class="line">    </span><br><span class="line">    // 遍历</span><br><span class="line">    for(i = 0; i &lt; num; ++i) &#123;</span><br><span class="line">    </span><br><span class="line">        char* name = ptr[i]-&gt;d_name;</span><br><span class="line"></span><br><span class="line">        // 拼接文件的完整路径</span><br><span class="line">        sprintf(path, &quot;%s/%s&quot;, dirname, name);</span><br><span class="line">        printf(&quot;path = %s ===================\n&quot;, path);</span><br><span class="line">        struct stat st;</span><br><span class="line">        stat(path, &amp;st);</span><br><span class="line"></span><br><span class="line">		// 编码生成 %E5 %A7 之类的东西</span><br><span class="line">        encode_str(enstr, sizeof(enstr), name);</span><br><span class="line">        </span><br><span class="line">        // 如果是文件</span><br><span class="line">        if(S_ISREG(st.st_mode)) &#123;       </span><br><span class="line">            sprintf(buf+strlen(buf), </span><br><span class="line">                    &quot;&lt;tr&gt;&lt;td&gt;&lt;a href=\&quot;%s\&quot;&gt;%s&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;&quot;,</span><br><span class="line">                    enstr, name, (long)st.st_size);</span><br><span class="line">        &#125; else if(S_ISDIR(st.st_mode)) &#123;		// 如果是目录       </span><br><span class="line">            sprintf(buf+strlen(buf), </span><br><span class="line">                    &quot;&lt;tr&gt;&lt;td&gt;&lt;a href=\&quot;%s/\&quot;&gt;%s/&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;&quot;,</span><br><span class="line">                    enstr, name, (long)st.st_size);</span><br><span class="line">        &#125;</span><br><span class="line">        ret = send(cfd, buf, strlen(buf), 0);</span><br><span class="line">        if (ret == -1) &#123;</span><br><span class="line">            if (errno == EAGAIN) &#123;</span><br><span class="line">                perror(&quot;send error:&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125; else if (errno == EINTR) &#123;</span><br><span class="line">                perror(&quot;send error:&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                perror(&quot;send error:&quot;);</span><br><span class="line">                exit(1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memset(buf, 0, sizeof(buf));</span><br><span class="line">        // 字符串拼接</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sprintf(buf+strlen(buf), &quot;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;&quot;);</span><br><span class="line">    send(cfd, buf, strlen(buf), 0);</span><br><span class="line"></span><br><span class="line">    printf(&quot;dir message send OK!!!!\n&quot;);</span><br><span class="line">#if 0</span><br><span class="line">    // 打开目录</span><br><span class="line">    DIR* dir = opendir(dirname);</span><br><span class="line">    if(dir == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;opendir error&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 读目录</span><br><span class="line">    struct dirent* ptr = NULL;</span><br><span class="line">    while( (ptr = readdir(dir)) != NULL )</span><br><span class="line">    &#123;</span><br><span class="line">        char* name = ptr-&gt;d_name;</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dir);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="telnet调试"><a href="#telnet调试" class="headerlink" title="telnet调试"></a>telnet调试</h2><p><img src="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230720171014596.png" alt="image-20230720171014596"></p>
<img src="/2023/07/18/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-web%E5%A4%A7%E7%BB%83%E4%B9%A0-B-S/image-20230720171014596.png" class title="This is an test image">

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/15/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/15/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent/" class="post-title-link" itemprop="url">Linux网络编程-libevent</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-15 16:35:58" itemprop="dateCreated datePublished" datetime="2023-07-15T16:35:58+08:00">2023-07-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-11 17:09:27" itemprop="dateModified" datetime="2023-10-11T17:09:27+08:00">2023-10-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="static修饰的函数作用与意义"><a href="#static修饰的函数作用与意义" class="headerlink" title="static修饰的函数作用与意义"></a>static修饰的函数作用与意义</h2><p>static修饰的函数叫做静态函数，静态函数有两种，根据其出现的地方来分类：</p>
<p>如果这个静态函数出现在类里，那么它是一个静态成员函数；<br>        静态成员函数的作用在于：<strong>调用这个函数不会访问或者修改任何对象（非static）数据成员。</strong></p>
<p>​    其实很好理解，类的静态成员(变量和方法)属于类本身，在类加载的时候就会分配内存，可以通过类名直接去访问；非静态成员（变量和方法）属于类的对象，所以只有在类的对象产生（创建类的实例）时才会分配内存，然后通过类的对象（实例）去访问。</p>
<p>如果它不是出现在类中，那么它是一个普通的全局的静态函数。<br>        这样的static函数与普通函数的区别是：用static修饰的函数，限定在本源码文件中，不能被本源码文件以外的代码文件调用。而普通的函数，默认是extern的，也就是说它可以被其它代码文件调用。<br>　　在函数的返回类型前加上关键字static，函数就被定义成为静态函数。普通 函数的定义和声明默认情况下是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。因此定义静态函数有以下好处：<br>　　&lt;1&gt; 其他文件中可以定义相同名字的函数，不会发生冲突。<br>　　&lt;2&gt; 静态函数不能被其他文件所用。</p>
<p>在C++中，静态成员函数（static function）是与类关联的函数，而不是与类的实例对象关联的。它们可以直接通过类名调用，无需创建类的实例。</p>
<p>静态成员函数在以下几种情况下被调用：</p>
<ol>
<li>通过类名调用：静态成员函数可以通过类名直接调用，而不需要通过类的实例对象。这样调用时，它们与普通的全局函数类似，没有隐含的 this 指针。例如：<code>ClassName::staticFunction()</code>。</li>
<li>在类内部调用：静态成员函数可以在类的其他成员函数中被调用，包括其他静态成员函数和非静态成员函数。</li>
<li>在类的派生类中调用：派生类可以通过类名或派生类名直接调用继承的静态成员函数。</li>
</ol>
<p>需要注意的是，静态成员函数只能访问类的静态成员变量和其他静态成员函数，不能直接访问类的非静态成员变量和非静态成员函数。静态成员函数也没有访问权限限定符（public、private、protected）的限制。</p>
<p>静态成员函数的主要作用是为了某些与类相关的功能提供一个公共的接口，不依赖于类的实例化。常见的用途包括实现工具函数、访问类的静态成员变量等</p>
<hr>
<p>静态与非静态成员函数之间有一个主要的区别，那就是静态成员函数没有this指针。</p>
<p>虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，因为它是类的一个成员，并且vptr指向保存虚函数地址的vtable.对于静态成员函数，它没有this指针，所以无法访问vptr。</p>
<p>这就是为何static函数不能为virtual，虚函数的调用关系：this -&gt; vptr -&gt; vtable -&gt;virtual function。</p>
<h2 id="libevent简介"><a href="#libevent简介" class="headerlink" title="libevent简介"></a>libevent简介</h2><p>libevent库</p>
<p>  开源。精简。跨平台（Windows、Linux、maxos、unix）。专注于网络通信。</p>
<p>源码包安装： 参考 README、readme</p>
<p>  .&#x2F;configure    检查安装环境 生成 makefile</p>
<p>  make     生成 .o 和 可执行文件 </p>
<p>  sudo make install 将必要的资源cp置系统指定目录。</p>
<p>  进入 sample 目录，运行demo验证库安装使用情况。 </p>
<p>  编译使用库的 .c 时，需要加 -levent 选项。 </p>
<p>  库名 libevent.so –&gt; &#x2F;usr&#x2F;local&#x2F;lib  查看的到。</p>
<p>特性：</p>
<p>  基于“事件”异步通信模型。— 回调。</p>
<h2 id="libevent封装的框架思想"><a href="#libevent封装的框架思想" class="headerlink" title="libevent封装的框架思想"></a>libevent封装的框架思想</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">libevent框架：</span><br><span class="line"></span><br><span class="line">	1. 创建 event_base		(乐高底座)</span><br><span class="line">	2. 创建 事件evnet	</span><br><span class="line">	3. 将事件 添加到 base上	</span><br><span class="line">	4. 循环监听事件满足</span><br><span class="line">	5. 释放 event_base</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 创建 event_base		(乐高底座)</span><br><span class="line"></span><br><span class="line">		struct event_base *event_base_new(void);</span><br><span class="line"></span><br><span class="line">		struct event_base *base = event_base_new();</span><br><span class="line"></span><br><span class="line">2. 创建 事件evnet	</span><br><span class="line"></span><br><span class="line">		常规事件 event	--&gt; event_new(); </span><br><span class="line"></span><br><span class="line">		bufferevent --&gt; bufferevent_socket_new();</span><br><span class="line"></span><br><span class="line">3. 将事件 添加到 base上	</span><br><span class="line"></span><br><span class="line">		int event_add(struct event *ev, const struct timeval *tv)</span><br><span class="line"></span><br><span class="line">4. 循环监听事件满足</span><br><span class="line"></span><br><span class="line">		int event_base_dispatch(struct event_base *base);</span><br><span class="line"></span><br><span class="line">			event_base_dispatch(base);</span><br><span class="line"></span><br><span class="line">5. 释放 event_base</span><br><span class="line"></span><br><span class="line">		event_base_free(base);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="一些不常用相关函数了解"><a href="#一些不常用相关函数了解" class="headerlink" title="一些不常用相关函数了解"></a>一些不常用相关函数了解</h2><p>查看支持哪些多路IO<br><code>const char **event_get_supported_methods(void);</code></p>
<p>查看当前用的多路lO<br><code>const char * event_base_get_method(const struct event_base *base);</code></p>
<p>查看fork 后子进程使用的event_base<br><code>int event_reinit(struct event_base *base);</code><br>成功︰0，失败︰ -1<br>使用该函数后，父创建的base才能在子进程中生效。”</p>
<p><code>int event_base_loopexit(struct event_base *base, const struct timeval *tv);</code><br>在指定时间后停止循环。</p>
<p><code>int event_base_loopbreak(struct event_base *base);</code><br>立即停止循环。</p>
<h2 id="创建事件对象"><a href="#创建事件对象" class="headerlink" title="创建事件对象"></a>创建事件对象</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">创建事件event：</span><br><span class="line"></span><br><span class="line">	struct event *ev；</span><br><span class="line"></span><br><span class="line">	struct event *event_new(struct event_base *base，evutil_socket_t fd，short what，event_callback_fn cb;  void *arg);</span><br><span class="line"></span><br><span class="line">		base： event_base_new()返回值。</span><br><span class="line"></span><br><span class="line">		 fd： 绑定到 event 上的 文件描述符</span><br><span class="line"></span><br><span class="line">		what：对应的事件（r、w、e）</span><br><span class="line"></span><br><span class="line">			EV_READ		一次 读事件</span><br><span class="line"></span><br><span class="line">			EV_WRTIE	一次 写事件</span><br><span class="line"></span><br><span class="line">			EV_PERSIST	持续触发。 结合 event_base_dispatch 函数使用，生效。</span><br><span class="line"></span><br><span class="line">		cb：一旦事件满足监听条件，回调的函数。</span><br><span class="line"></span><br><span class="line">		typedef void (*event_callback_fn)(evutil_socket_t fd,  short,  void *)	</span><br><span class="line"></span><br><span class="line">		arg： 回调的函数的参数。</span><br><span class="line"></span><br><span class="line">		返回值：成功创建的 event</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="事件event操作"><a href="#事件event操作" class="headerlink" title="事件event操作"></a>事件event操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">添加事件到 event_base</span><br><span class="line"></span><br><span class="line">	int event_add(struct event *ev, const struct timeval *tv);</span><br><span class="line"></span><br><span class="line">		ev: event_new() 的返回值。</span><br><span class="line"></span><br><span class="line">		tv：NULL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">销毁事件</span><br><span class="line"></span><br><span class="line">	int event_free(struct event *ev);</span><br><span class="line"></span><br><span class="line">		ev: event_new() 的返回值。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用fifo的读写"><a href="#使用fifo的读写" class="headerlink" title="使用fifo的读写"></a>使用fifo的读写</h2><p>读端的代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;sys/types.h&gt;  </span><br><span class="line">#include &lt;sys/stat.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;fcntl.h&gt;  </span><br><span class="line">#include &lt;event2/event.h&gt;  </span><br><span class="line">  </span><br><span class="line">// 对操作处理函数  </span><br><span class="line">void read_cb(evutil_socket_t fd, short what, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    // 读管道  </span><br><span class="line">    char buf[1024] = &#123;0&#125;;  </span><br><span class="line">      </span><br><span class="line">    int len = read(fd, buf, sizeof(buf));  </span><br><span class="line">      </span><br><span class="line">    printf(&quot;read event: %s \n&quot;, what &amp; EV_READ ? &quot;Yes&quot; : &quot;No&quot;);  </span><br><span class="line">    printf(&quot;data len = %d, buf = %s\n&quot;, len, buf);  </span><br><span class="line">      </span><br><span class="line">    sleep(1);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">// 读管道  </span><br><span class="line">int main(int argc, const char* argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">    unlink(&quot;myfifo&quot;);  </span><br><span class="line">  </span><br><span class="line">    //创建有名管道  </span><br><span class="line">    mkfifo(&quot;myfifo&quot;, 0664);  </span><br><span class="line">  </span><br><span class="line">    // open file  </span><br><span class="line">    int fd = open(&quot;myfifo&quot;, O_RDONLY | O_NONBLOCK);//因为libevent是基于epoll反应堆实现的，所以是非阻塞的 </span><br><span class="line">    //int fd = open(&quot;myfifo&quot;, O_RDONLY);  </span><br><span class="line">    if(fd == -1)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(&quot;open error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // 创建个event_base  </span><br><span class="line">    struct event_base* base = NULL;  </span><br><span class="line">    base = event_base_new();  </span><br><span class="line">  </span><br><span class="line">    // 创建事件  </span><br><span class="line">    struct event* ev = NULL;  </span><br><span class="line">    ev = event_new(base, fd, EV_READ | EV_PERSIST, read_cb, NULL);  </span><br><span class="line">  </span><br><span class="line">    // 添加事件  </span><br><span class="line">    event_add(ev, NULL);  </span><br><span class="line">  </span><br><span class="line">    // 事件循环  </span><br><span class="line">    event_base_dispatch(base);  // while（1） &#123; epoll();&#125;  </span><br><span class="line">  </span><br><span class="line">    // 释放资源  </span><br><span class="line">    event_free(ev);  </span><br><span class="line">    event_base_free(base);  </span><br><span class="line">    close(fd);  </span><br><span class="line">      </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>写管道代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;sys/types.h&gt;  </span><br><span class="line">#include &lt;sys/stat.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;fcntl.h&gt;  </span><br><span class="line">#include &lt;event2/event.h&gt;  </span><br><span class="line">  </span><br><span class="line">// 对操作处理函数  </span><br><span class="line">void write_cb(evutil_socket_t fd, short what, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    // write管道  </span><br><span class="line">    char buf[1024] = &#123;0&#125;;  </span><br><span class="line">      </span><br><span class="line">    static int num = 0;  </span><br><span class="line">    sprintf(buf, &quot;hello,world-%d\n&quot;, num++);  </span><br><span class="line">    write(fd, buf, strlen(buf)+1);  </span><br><span class="line">      </span><br><span class="line">    sleep(1);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">// 写管道  </span><br><span class="line">int main(int argc, const char* argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">    // open file  </span><br><span class="line">    //int fd = open(&quot;myfifo&quot;, O_WRONLY | O_NONBLOCK);  </span><br><span class="line">    int fd = open(&quot;myfifo&quot;, O_WRONLY);  </span><br><span class="line">    if(fd == -1)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(&quot;open error&quot;);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // 写管道  </span><br><span class="line">    struct event_base* base = NULL;  </span><br><span class="line">    base = event_base_new();  </span><br><span class="line">  </span><br><span class="line">    // 创建事件  </span><br><span class="line">    struct event* ev = NULL;  </span><br><span class="line">    // 检测的写缓冲区是否有空间写  </span><br><span class="line">    //ev = event_new(base, fd, EV_WRITE , write_cb, NULL);  </span><br><span class="line">    ev = event_new(base, fd, EV_WRITE | EV_PERSIST, write_cb, NULL);  </span><br><span class="line">  </span><br><span class="line">    // 添加事件  </span><br><span class="line">    event_add(ev, NULL);  </span><br><span class="line">  </span><br><span class="line">    // 事件循环  </span><br><span class="line">    event_base_dispatch(base);  </span><br><span class="line">  </span><br><span class="line">    // 释放资源  </span><br><span class="line">    event_free(ev);  </span><br><span class="line">    event_base_free(base);  </span><br><span class="line">    close(fd);  </span><br><span class="line">      </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个也说明不一定只能在网络上才能用libevent库</p>
<h2 id="未决和非未决"><a href="#未决和非未决" class="headerlink" title="未决和非未决"></a>未决和非未决</h2><p>未决和非未决： </p>
<p>  非未决: 没有资格被处理</p>
<p>  未决： 有资格被处理，但尚未被处理</p>
<p>  event_new –&gt; event —&gt; 非未决 –&gt; event_add –&gt; 未决 –&gt; dispatch() &amp;&amp; 监听事件被触发 –&gt; 激活态 </p>
<p>  –&gt; 执行回调函数 –&gt; 处理态 –&gt; 非未决 event_add &amp;&amp; EV_PERSIST –&gt; 未决 –&gt; event_del –&gt; 非未决</p>
<p><img src="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent/image-20230716114206318.png" alt="image-20230716114206318"></p>
<img src="/2023/07/15/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent/image-20230716114206318.png" class title="This is an test image">

<h2 id="bufferevent特性"><a href="#bufferevent特性" class="headerlink" title="bufferevent特性"></a>bufferevent特性</h2><p><img src="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent/image-20230717161012885.png" alt="image-20230717161012885"></p>
<img src="/2023/07/15/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent/image-20230717161012885.png" class title="This is an test image">

<p>带缓冲区的事件 bufferevent</p>
<p>  <code>#include &lt;event2/bufferevent.h&gt;</code>  </p>
<p>  <code>read/write 两个缓冲. 借助 队列.</code></p>
<h3 id="bufferevent事件对象创建、销毁"><a href="#bufferevent事件对象创建、销毁" class="headerlink" title="bufferevent事件对象创建、销毁"></a>bufferevent事件对象创建、销毁</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">创建、销毁bufferevent：</span><br><span class="line"></span><br><span class="line">	struct bufferevent *ev；</span><br><span class="line"></span><br><span class="line">	struct bufferevent *bufferevent_socket_new(struct event_base *base, evutil_socket_t fd, enum bufferevent_options options);</span><br><span class="line"></span><br><span class="line">		base： event_base</span><br><span class="line"></span><br><span class="line">		fd:	封装到bufferevent内的 fd</span><br><span class="line"></span><br><span class="line">		options：BEV_OPT_CLOSE_ON_FREE（设置它在关闭的时候释放相应的这个套件对象）</span><br><span class="line"></span><br><span class="line">	返回： 成功创建的 bufferevent事件对象。</span><br><span class="line">void  bufferevent_socket_free(struct bufferevent *ev);</span><br></pre></td></tr></table></figure>

<h3 id="给bufferevent事件对象设置回调"><a href="#给bufferevent事件对象设置回调" class="headerlink" title="给bufferevent事件对象设置回调"></a>给bufferevent事件对象设置回调</h3><p><code>bufferevent_flush()</code> 函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cCopy Codeint bufferevent_flush(struct bufferevent *bufev, short iotype, enum bufferevent_flush_mode mode);</span><br></pre></td></tr></table></figure>

<p>该函数用于将缓冲区中的数据写入底层传输机制，以确保数据尽快发送出去。</p>
<p>参数说明：</p>
<ul>
<li><code>bufev</code>：指向 <code>struct bufferevent</code> 结构体的指针，表示要刷新的缓冲事件。</li>
<li><code>iotype</code>：表示刷新操作的类型，可以是 <code>EV_READ</code>、<code>EV_WRITE</code> 或它们的按位或运算结果。如果指定了 <code>EV_READ</code>，则刷新读缓冲区；如果指定了 <code>EV_WRITE</code>，则刷新写缓冲区。</li>
<li><code>mode</code>：表示刷新模式，可以是 <code>BEV_NORMAL</code>、<code>BEV_FLUSH</code> 或 <code>BEV_FINISHED</code>。<code>BEV_NORMAL</code> 表示正常模式，<code>BEV_FLUSH</code> 表示强制刷新缓冲区，<code>BEV_FINISHED</code> 表示刷新完毕。</li>
</ul>
<p>函数返回值为 0 表示成功，-1 表示失败。</p>
<p>通过调用 <code>bufferevent_flush()</code> 函数，可以显式地触发将缓冲区中的数据发送到底层传输机制。需要注意的是，该函数只是将数据写入底层传输机制，并不保证立即发送到对端，实际的发送可能受到底层传输机制和网络状况的影响。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">给bufferevent设置回调：</span><br><span class="line">	</span><br><span class="line">	对比event：	event_new( fd, callback );  					event_add() -- 挂到 event_base 上。</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">			bufferevent_socket_new（fd）  bufferevent_setcb（ callback ）</span><br><span class="line"></span><br><span class="line">	void bufferevent_setcb(struct bufferevent * bufev,</span><br><span class="line">				bufferevent_data_cb readcb,</span><br><span class="line">				bufferevent_data_cb writecb,</span><br><span class="line">				bufferevent_event_cb eventcb,</span><br><span class="line">				void *cbarg );</span><br><span class="line"></span><br><span class="line">	bufev： bufferevent_socket_new() 返回值</span><br><span class="line"></span><br><span class="line">	readcb： 设置 bufferevent 读缓冲，对应回调  read_cb&#123;  bufferevent_read() 读数据  &#125;</span><br><span class="line"></span><br><span class="line">	writecb： 设置 bufferevent 写缓冲，对应回调 write_cb &#123;  &#125; -- 给调用者，发送写成功通知。  可以 NULL,因为它是写成功才调用，很鸡肋</span><br><span class="line"></span><br><span class="line">	eventcb： 设置 事件回调。   也可传NULL</span><br><span class="line"></span><br><span class="line">		typedef void (*bufferevent_event_cb)(struct bufferevent *bev,  short events, void *ctx);</span><br><span class="line"></span><br><span class="line">		void event_cb(struct bufferevent *bev,  short events, void *ctx)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			。。。。。</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		events： BEV_EVENT_CONNECTED</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cbarg：	上述回调函数使用的 参数。</span><br><span class="line"></span><br><span class="line">	read 回调函数类型：</span><br><span class="line"></span><br><span class="line">		typedef void (*bufferevent_data_cb)(struct bufferevent *bev, void*ctx);</span><br><span class="line"></span><br><span class="line">		void read_cb(struct bufferevent *bev, void *cbarg )</span><br><span class="line">		&#123;</span><br><span class="line">			.....</span><br><span class="line">			bufferevent_read();   --- read();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	bufferevent_read()函数的原型：</span><br><span class="line"></span><br><span class="line">		size_t bufferevent_read(struct bufferevent *bev, void *buf, size_t bufsize);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	write 回调函数类型：</span><br><span class="line"></span><br><span class="line">		int bufferevent_write(struct bufferevent *bufev, const void *data,  size_t size);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="缓冲区开启和关闭"><a href="#缓冲区开启和关闭" class="headerlink" title="缓冲区开启和关闭"></a>缓冲区开启和关闭</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">启动、关闭 bufferevent的 缓冲区：</span><br><span class="line"></span><br><span class="line">	void bufferevent_enable(struct bufferevent *bufev, short events);   启动	</span><br><span class="line"></span><br><span class="line">		events： EV_READ、EV_WRITE、EV_READ|EV_WRITE</span><br><span class="line"></span><br><span class="line">		默认write 缓冲是 enable、read 缓冲是 disable</span><br><span class="line"></span><br><span class="line">			bufferevent_enable(evev, EV_READ);		-- 开启读缓冲。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="客户端和服务器连接和监听"><a href="#客户端和服务器连接和监听" class="headerlink" title="客户端和服务器连接和监听"></a>客户端和服务器连接和监听</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">连接客户端：</span><br><span class="line"></span><br><span class="line">	socket();connect();</span><br><span class="line"></span><br><span class="line">	int bufferevent_socket_connect(struct bufferevent *bev, struct sockaddr *address, int addrlen);</span><br><span class="line"></span><br><span class="line">		bev: bufferevent 事件对象（封装了fd）</span><br><span class="line"></span><br><span class="line">		address、len：等同于 connect() 参2/3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">创建监听服务器：</span><br><span class="line"></span><br><span class="line">	------ socket();bind();listen();accept();</span><br><span class="line"></span><br><span class="line">	struct evconnlistener * listner</span><br><span class="line"></span><br><span class="line">	struct evconnlistener *evconnlistener_new_bind (	</span><br><span class="line">		struct event_base *base,</span><br><span class="line">		evconnlistener_cb cb, </span><br><span class="line">		void *ptr, </span><br><span class="line">		unsigned flags,</span><br><span class="line">		int backlog,</span><br><span class="line">		const struct sockaddr *sa,</span><br><span class="line">		int socklen);</span><br><span class="line"></span><br><span class="line">	base： event_base</span><br><span class="line"></span><br><span class="line">	cb: 回调函数。 一旦被回调，说明在其内部应该与客户端完成， 数据读写操作，进行通信。</span><br><span class="line"></span><br><span class="line">	ptr： 回调函数的参数</span><br><span class="line"></span><br><span class="line">	flags： LEV_OPT_CLOSE_ON_FREE | LEV_OPT_REUSEABLE</span><br><span class="line"></span><br><span class="line">	backlog： listen() 2参。 -1 表最大值</span><br><span class="line"></span><br><span class="line">	sa：服务器自己的地址结构体</span><br><span class="line"></span><br><span class="line">	socklen：服务器自己的地址结构体大小。</span><br><span class="line"></span><br><span class="line">	返回值：成功创建的监听器。</span><br><span class="line">释放监听服务器:</span><br><span class="line"></span><br><span class="line">	void evconnlistener_free(struct evconnlistener *lev);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="libevent实现TCP服务器流程"><a href="#libevent实现TCP服务器流程" class="headerlink" title="libevent实现TCP服务器流程"></a>libevent实现TCP服务器流程</h2><p>服务器端 libevent 创建TCP连接：</p>
<ol>
<li>创建event_base</li>
<li>创建bufferevent事件对象。bufferevent_socket_new();</li>
<li>使用bufferevent_setcb() 函数给 bufferevent的 read、write、event 设置回调函数。</li>
<li>当监听的 事件满足时，read_cb会被调用， 在其内部 bufferevent_read();读</li>
<li>使用 evconnlistener_new_bind 创建监听服务器， 设置其回调函数，当有客户端成功连接时，这个回调函数会被调用。</li>
<li>封装 listner_cb() 在函数内部。完成与客户端通信。 </li>
<li>设置读缓冲、写缓冲的 使能状态 enable、disable</li>
<li>启动循环 event_base_dispath();</li>
<li>释放连接。</li>
</ol>
<p>服务器源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;sys/types.h&gt;  </span><br><span class="line">#include &lt;sys/stat.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;event2/event.h&gt;  </span><br><span class="line">#include &lt;event2/listener.h&gt;  </span><br><span class="line">#include &lt;event2/bufferevent.h&gt;  </span><br><span class="line">  </span><br><span class="line">// 读缓冲区回调  </span><br><span class="line">void read_cb(struct bufferevent *bev, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    char buf[1024] = &#123;0&#125;;     </span><br><span class="line">    bufferevent_read(bev, buf, sizeof(buf));  </span><br><span class="line">    printf(&quot;client say: %s\n&quot;, buf);  </span><br><span class="line">  </span><br><span class="line">    char *p = &quot;我是服务器, 已经成功收到你发送的数据!&quot;;  </span><br><span class="line">    // 发数据给客户端  </span><br><span class="line">    bufferevent_write(bev, p, strlen(p)+1);  </span><br><span class="line">    sleep(1);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// 写缓冲区回调  </span><br><span class="line">void write_cb(struct bufferevent *bev, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    printf(&quot;I&#x27;m服务器, 成功写数据给客户端,写缓冲区回调函数被回调...\n&quot;);   </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// 事件  </span><br><span class="line">void event_cb(struct bufferevent *bev, short events, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    if (events &amp; BEV_EVENT_EOF)  </span><br><span class="line">    &#123;  </span><br><span class="line">        printf(&quot;connection closed\n&quot;);    </span><br><span class="line">    &#125;  </span><br><span class="line">    else if(events &amp; BEV_EVENT_ERROR)     </span><br><span class="line">    &#123;  </span><br><span class="line">        printf(&quot;some other error\n&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    bufferevent_free(bev);      </span><br><span class="line">    printf(&quot;buffevent 资源已经被释放...\n&quot;);   </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"> // 被回调，说明有客户端成功连接， cfd已经传入该参数内部。 创建bufferevent事件对象 </span><br><span class="line"> // 与客户端完成读写操作。  </span><br><span class="line">void cb_listener(  </span><br><span class="line">        struct evconnlistener *listener,   </span><br><span class="line">        evutil_socket_t fd,   </span><br><span class="line">        struct sockaddr *addr,   </span><br><span class="line">        int len, void *ptr)  </span><br><span class="line">&#123;  </span><br><span class="line">   printf(&quot;connect new client\n&quot;);  </span><br><span class="line">  </span><br><span class="line">   struct event_base* base = (struct event_base*)ptr;  </span><br><span class="line">   // 通信操作  </span><br><span class="line">   // 添加新事件  </span><br><span class="line">   struct bufferevent *bev;  </span><br><span class="line">   bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);  //将fd封装进去bev</span><br><span class="line">  </span><br><span class="line">   // 给bufferevent缓冲区设置回调  </span><br><span class="line">   bufferevent_setcb(bev, read_cb, write_cb, event_cb, NULL);  //write_cb和event_cb甚至可以传NULL</span><br><span class="line">   // 启动 read 缓冲区的 使能状态</span><br><span class="line">   bufferevent_enable(bev, EV_READ);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">int main(int argc, const char* argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">  </span><br><span class="line">    // init server   </span><br><span class="line">    struct sockaddr_in serv;  </span><br><span class="line">  </span><br><span class="line">    memset(&amp;serv, 0, sizeof(serv));  </span><br><span class="line">    serv.sin_family = AF_INET;  </span><br><span class="line">    serv.sin_port = htons(9876);  </span><br><span class="line">    serv.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">  </span><br><span class="line">    struct event_base* base;  </span><br><span class="line">    base = event_base_new();  </span><br><span class="line">    // 创建套接字  </span><br><span class="line">    // 绑定  </span><br><span class="line">    // 接收连接请求  </span><br><span class="line">    struct evconnlistener* listener;  </span><br><span class="line">    listener = evconnlistener_new_bind(base, cb_listener, base,   </span><br><span class="line">                                  LEV_OPT_CLOSE_ON_FREE | LEV_OPT_REUSEABLE,   </span><br><span class="line">                                  36, (struct sockaddr*)&amp;serv, sizeof(serv));  </span><br><span class="line">  </span><br><span class="line">    event_base_dispatch(base);  </span><br><span class="line">  </span><br><span class="line">    evconnlistener_free(listener);  </span><br><span class="line">    event_base_free(base);  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="客户端流程简析和回顾"><a href="#客户端流程简析和回顾" class="headerlink" title="客户端流程简析和回顾"></a>客户端流程简析和回顾</h3><p><img src="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent/image-20230717162404576.png" alt="image-20230717162404576"></p>
<img src="/2023/07/15/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent/image-20230717162404576.png" class title="This is an test image">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;sys/types.h&gt;  </span><br><span class="line">#include &lt;sys/stat.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;event2/bufferevent.h&gt;  </span><br><span class="line">#include &lt;event2/event.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">  </span><br><span class="line">void read_cb(struct bufferevent *bev, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    char buf[1024] = &#123;0&#125;;   </span><br><span class="line">    bufferevent_read(bev, buf, sizeof(buf));  </span><br><span class="line">  </span><br><span class="line">    printf(&quot;fwq say:%s\n&quot;, buf);  </span><br><span class="line">  </span><br><span class="line">    bufferevent_write(bev, buf, strlen(buf)+1);  </span><br><span class="line">    sleep(1);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void write_cb(struct bufferevent *bev, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    printf(&quot;----------我是客户端的写回调函数,没卵用\n&quot;);   </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void event_cb(struct bufferevent *bev, short events, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    if (events &amp; BEV_EVENT_EOF)  </span><br><span class="line">    &#123;  </span><br><span class="line">        printf(&quot;connection closed\n&quot;);    </span><br><span class="line">    &#125;  </span><br><span class="line">    else if(events &amp; BEV_EVENT_ERROR)     </span><br><span class="line">    &#123;  </span><br><span class="line">        printf(&quot;some other error\n&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">    else if(events &amp; BEV_EVENT_CONNECTED)  </span><br><span class="line">    &#123;  </span><br><span class="line">        printf(&quot;已经连接服务器...\\(^o^)/...\n&quot;);  </span><br><span class="line">        return;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    // 释放资源  </span><br><span class="line">    bufferevent_free(bev);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// 客户端与用户交互，从终端读取数据写给服务器  </span><br><span class="line">void read_terminal(evutil_socket_t fd, short what, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    // 读数据  </span><br><span class="line">    char buf[1024] = &#123;0&#125;;  </span><br><span class="line">    int len = read(fd, buf, sizeof(buf));  </span><br><span class="line">  </span><br><span class="line">    struct bufferevent* bev = (struct bufferevent*)arg;  </span><br><span class="line">    // 发送数据  </span><br><span class="line">    bufferevent_write(bev, buf, len+1);  //将len增加1，确保缓冲区中包含字符串的终止符，这在处理字符串时非常重要。</span><br><span class="line"></span><br><span class="line">//如果不包括终止符，接收方可能会在读取数据时出现问题，因为它们可能没有办法确定何时停止读取字符串。因此，确保缓冲区的末尾有一个终止符可以提供字符串的正确性和完整性。</span><br><span class="line"></span><br><span class="line">//总之，使用len+1而不是简单的len确保了传输的字符串在缓冲区中正确终止，避免了潜在的错误和问题。</span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int main(int argc, const char* argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">    struct event_base* base = NULL;  </span><br><span class="line">    base = event_base_new();  </span><br><span class="line">  </span><br><span class="line">    int fd = socket(AF_INET, SOCK_STREAM, 0);  //没有服务器那边监听器，所以需要创建fd</span><br><span class="line">  </span><br><span class="line">    // 通信的fd放到bufferevent中  </span><br><span class="line">    struct bufferevent* bev = NULL;  </span><br><span class="line">    bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);  //将fd封装进bev</span><br><span class="line">  </span><br><span class="line">    // init server info  </span><br><span class="line">    struct sockaddr_in serv;  </span><br><span class="line">    memset(&amp;serv, 0, sizeof(serv));  </span><br><span class="line">    serv.sin_family = AF_INET;  </span><br><span class="line">    serv.sin_port = htons(9876);  </span><br><span class="line">    inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;serv.sin_addr.s_addr);  </span><br><span class="line">  </span><br><span class="line">    // 连接服务器  </span><br><span class="line">    bufferevent_socket_connect(bev, (struct sockaddr*)&amp;serv, sizeof(serv));  </span><br><span class="line">  </span><br><span class="line">    // 设置回调  </span><br><span class="line">    bufferevent_setcb(bev, read_cb, write_cb, event_cb, NULL);  </span><br><span class="line">  </span><br><span class="line">    // 设置读回调生效  </span><br><span class="line">    // bufferevent_enable(bev, EV_READ);  </span><br><span class="line">  </span><br><span class="line">    // 创建事件  </span><br><span class="line">    struct event* ev = event_new(base, STDIN_FILENO, EV_READ | EV_PERSIST,  </span><br><span class="line">                                 read_terminal, bev);  </span><br><span class="line">    // 添加事件                       </span><br><span class="line">    event_add(ev, NULL);  </span><br><span class="line">  </span><br><span class="line">    event_base_dispatch(base);  </span><br><span class="line">  </span><br><span class="line">    event_free(ev);  </span><br><span class="line">      </span><br><span class="line">    event_base_free(base);  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="还有一些函数"><a href="#还有一些函数" class="headerlink" title="还有一些函数"></a>还有一些函数</h2><h3 id="evsignal-new"><a href="#evsignal-new" class="headerlink" title="evsignal_new"></a>evsignal_new</h3><p><code>evsignal_new</code> 是一个函数，用于创建一个新的 libevent 信号事件对象。 libevent 是一个开源的高性能网络库，用于事件驱动的编程。</p>
<p><code>evsignal_new</code> 的声明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct event *evsignal_new(struct event_base *base, int signo,</span><br><span class="line">                           void (*cb)(evutil_socket_t, short, void *), void *arg);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>base</code>：指向事件基础结构体（<code>event_base</code>）的指针。</li>
<li><code>signo</code>：要监听的信号编号。</li>
<li><code>cb</code>：当信号触发时调用的回调函数。</li>
<li><code>arg</code>：传递给回调函数的参数。</li>
</ul>
<p>该函数成功创建并返回一个新的 <code>event</code> 结构体指针，或者返回 <code>NULL</code> 表示创建失败。</p>
<p>一般情况下，使用 <code>evsignal_new</code> 函数后，还需要调用 <code>event_add</code> 将事件添加到事件循环中，并调用 <code>event_base_dispatch</code> 开始事件循环。</p>
<h3 id="strcasecmp"><a href="#strcasecmp" class="headerlink" title="strcasecmp"></a>strcasecmp</h3><p><code>strcasecmp()</code> 是一个字符串比较函数，它忽略字符串的大小写差异进行比较。</p>
<p>语法形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cCopy Codeint strcasecmp(const char *str1, const char *str2);</span><br></pre></td></tr></table></figure>

<p>参数 <code>str1</code> 和 <code>str2</code> 分别是要比较的两个字符串。函数会将这两个字符串进行比较，并返回一个整数值，用于表示比较结果。</p>
<p>返回值的含义如下：</p>
<ul>
<li>如果 <code>str1</code> 等于 <code>str2</code>（不区分大小写），则返回值为 0。</li>
<li>如果 <code>str1</code> 大于 <code>str2</code>（忽略大小写），则返回值大于 0。</li>
<li>如果 <code>str1</code> 小于 <code>str2</code>（忽略大小写），则返回值小于 0。</li>
</ul>
<p>在给定的代码中，<code>strcasecmp(method, &quot;GET&quot;) == 0</code> 表达式用于判断字符串 <code>method</code> 是否等于 <code>&quot;GET&quot;</code>（不区分大小写）。如果相等，条件表达式的结果为真（非零），执行相应的代码块。否则，条件表达式的结果为假（零），代码块将被跳过。</p>
<p>因此，所给代码段用于检查 <code>method</code> 是否为 <code>&quot;GET&quot;</code>，并执行与之相关的处理逻辑。</p>
<h3 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h3><p><code>stat()</code> 函数被调用来获取指定文件的状态信息并存储在 <code>sb</code> 结构体中。<code>stat()</code> 函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cCopy Codeint stat(const char *path, struct stat *buf);</span><br></pre></td></tr></table></figure>

<p>参数 <code>path</code> 是要获取状态信息的文件路径，<code>buf</code> 是一个指向 <code>struct stat</code> 结构体的指针，用于存储获取到的状态信息。</p>
<p>函数返回值为 0 表示成功，-1 表示失败。</p>
<p>接下来，通过判断 <code>stat(pf, &amp;sb) &lt; 0</code> 来检查 <code>stat()</code> 函数是否执行失败。如果执行失败，说明无法获取文件的状态信息，这时会输出错误信息到标准错误流（使用 <code>perror()</code> 函数），发送错误响应（使用 <code>send_error()</code> 函数），并返回 -1，表示函数执行出错。</p>
<p>“状态”在这里指的是文件的状态信息，而不是文件的结尾。</p>
<p><code>stat()</code> 函数用于获取文件的状态信息，包括文件的权限、大小、修改时间等。通过 <code>struct stat</code> 结构体来存储这些信息。在给定的代码中，<code>stat()</code> 函数将获取到的文件状态信息存储在 <code>sb</code> 结构体中。</p>
<p>这些状态信息可以用于判断文件的类型（如普通文件、目录、符号链接等）、访问权限以及其他属性。通过检查这些状态信息，可以在程序中进行相应的逻辑处理，例如根据文件类型进行不同的操作或者判断文件是否存在等。</p>
<p>文件的结尾字符实际上是文件内容的一部分，而不是文件的状态信息。要读取文件的内容，可以使用文件操作函数如 <code>fread()</code> 或者相关的系统调用如 <code>read()</code> 来读取文件的字节流数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct stat sb;</span><br><span class="line">        if(stat(pf,&amp;sb) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;open file err:&quot;);</span><br><span class="line">            send_error(bev);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(S_ISDIR(sb.st_mode))//处理目录</span><br><span class="line">        &#123;</span><br><span class="line">            //应该显示目录列表</span><br><span class="line">            send_header(bev, 200, &quot;OK&quot;, get_file_type(&quot;.html&quot;), -1);</span><br><span class="line">            send_dir(bev, pf);</span><br><span class="line">        &#125;</span><br><span class="line">        else //处理文件</span><br><span class="line">        &#123;</span><br><span class="line">            send_header(bev, 200, &quot;OK&quot;, get_file_type(pf), sb.st_size);</span><br><span class="line">            send_file_to_http(pf, bev);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<h3 id="scandir"><a href="#scandir" class="headerlink" title="scandir"></a>scandir</h3><p><code>scandir()</code> 函数用于扫描指定目录中的文件，并将文件列表存储在一个目录项数组中。</p>
<p>具体解释如下：</p>
<ol>
<li><p><code>scandir()</code> 函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cCopy Codeint scandir(const char *dir, struct dirent ***namelist,</span><br><span class="line">            int (*filter)(const struct dirent *),</span><br><span class="line">            int (*compar)(const struct dirent **, const struct dirent **));</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数解析：</p>
<ul>
<li><code>dir</code>：要扫描的目录路径。</li>
<li><code>namelist</code>：指向一个结构体指针的指针，用于存储扫描结果的目录项数组。每个目录项都包含文件名等信息。</li>
<li><code>filter</code>：可选的过滤函数，用于过滤不满足特定条件的目录项。在给定的代码中，设置为 <code>NULL</code>，表示不进行过滤。</li>
<li><code>compar</code>：可选的比较函数，用于排序目录项数组。在给定的代码中，设置为 <code>alphasort</code>，表示按字母顺序排序。</li>
</ul>
</li>
<li><p>函数返回值：</p>
<ul>
<li>如果成功调用 <code>scandir()</code> 函数，则返回扫描到的目录项数量（包括隐藏文件和特殊文件）。</li>
<li>如果调用失败，则返回 -1，并设置相应的错误码。</li>
</ul>
</li>
</ol>
<p>在给定的代码中，通过 <code>int num = scandir(dirname, &amp;dirinfo, NULL, alphasort);</code>，将 <code>dirname</code> 目录中的文件列表扫描到 <code>dirinfo</code> 目录项数组中，并将扫描到的目录项数量存储在整型变量 <code>num</code> 中。这些目录项可以通过 <code>dirinfo</code> 数组进行访问和处理。</p>
<h3 id="strftime"><a href="#strftime" class="headerlink" title="strftime"></a>strftime</h3><p><code>strftime()</code> 函数用于将时间信息格式化为指定的字符串形式。</p>
<p>具体解释如下：</p>
<ol>
<li><p><code>strftime()</code> 函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cCopy Codesize_t strftime(char *s, size_t maxsize, const char *format, const struct tm *timeptr);</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数解析：</p>
<ul>
<li><code>s</code>：指向一个字符数组的指针，用于存储格式化后的时间字符串。</li>
<li><code>maxsize</code>：指定 <code>s</code> 数组的大小，用于避免溢出。</li>
<li><code>format</code>：指定输出时间字符串的格式。例如，在给定的代码中，格式化字符串为 <code>&quot;  %d  %b   %Y  %H:%M&quot;</code>，表示以两个空格开头，然后依次为日期（日），月份（缩写），年份，小时和分钟，之间用空格分隔。</li>
<li><code>timeptr</code>：指向一个 <code>struct tm</code> 结构体的指针，包含了要格式化的时间信息。在给定的代码中，使用 <code>localtime(&amp;sb.st_mtime)</code> 获取文件的最后修改时间，并将其转换为本地时间的 <code>struct tm</code> 结构体。</li>
</ul>
</li>
<li><p>函数返回值：</p>
<ul>
<li>返回生成的时间字符串的长度，不包括 null 终止符。</li>
<li>如果格式化失败或输出字符串超过了 <code>maxsize</code> 的限制，则返回 0。</li>
</ul>
</li>
</ol>
<p>在给定的代码中，通过 <code>strftime(timestr, sizeof(timestr), &quot;  %d  %b   %Y  %H:%M&quot;, localtime(&amp;sb.st_mtime));</code> 将 <code>sb.st_mtime</code> 所表示的最后修改时间格式化为 <code>&quot;  %d  %b   %Y  %H:%M&quot;</code> 的字符串形式，并将结果存储在 <code>timestr</code> 字符数组中。这样，<code>timestr</code> 就保存了文件的最后修改时间的格式化字符串。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/14/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux-%E7%BA%BF%E7%A8%8B%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/14/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux-%E7%BA%BF%E7%A8%8B%E6%B1%A0/" class="post-title-link" itemprop="url">Linux-线程池</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-14 22:06:00" itemprop="dateCreated datePublished" datetime="2023-07-14T22:06:00+08:00">2023-07-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-15 14:31:56" itemprop="dateModified" datetime="2023-07-15T14:31:56+08:00">2023-07-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ctags使用"><a href="#ctags使用" class="headerlink" title="ctags使用"></a>ctags使用</h1><p><img src="/Linux-%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230714220627268.png" alt="image-20230714220627268"></p>
<img src="/2023/07/14/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux-%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230714220627268.png" class title="This is an test image">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">在使用 ctags 时，它本身并没有提供直接在屏幕左侧列出文件列表的功能。但你可以使用其他工具结合 ctags 来实现类似的效果。</span><br><span class="line"></span><br><span class="line">一种常见的方法是使用类似于 NERDTree 插件的文件浏览器插件。NERDTree 是 Vim 编辑器中一个流行的插件，可以在 Vim 的侧边栏中显示和导航文件列表。你可以按照以下步骤在 Vim 中使用 NERDTree 插件：</span><br><span class="line"></span><br><span class="line">确保你已经安装了 pathogen 或者 vim-plug 这样的 Vim 插件管理器。</span><br><span class="line">根据你所选择的插件管理器，在你的 Vim 配置文件（通常是 ~/.vimrc）中添加相应的配置。</span><br><span class="line">安装 NERDTree 插件。对于 pathogen，可以将插件克隆到 ~/.vim/bundle/ 目录下。对于 vim-plug，可以在 ~/.vimrc 中添加插件的配置，并执行 :PlugInstall 命令进行安装。</span><br><span class="line">重启 Vim，并执行 :NERDTreeToggle 命令来打开或关闭 NERDTree 窗口。你可以将其映射为方便的快捷键。</span><br><span class="line">当你生成了 ctags 标签文件后，通过打开 NERDTree 窗口，你就可以在屏幕的左侧列出文件列表了。</span><br><span class="line"></span><br><span class="line">请注意，这只是一个示例插件，并且适用于 Vim 编辑器。对于其他编辑器或 IDE，你可能需要找到相应的文件浏览器插件或特定的功能来实现类似的效果。</span><br><span class="line"></span><br><span class="line">要在屏幕右边列出函数列表，你可以使用类似于 Tagbar 插件的工具。Tagbar 是一个常用的 Vim 插件，用于显示当前文件中定义的函数、类、变量等符号列表，并且可以将其放置在编辑窗口的侧边栏。</span><br><span class="line"></span><br><span class="line">以下是在 Vim 中使用 Tagbar 插件的简要步骤：</span><br><span class="line"></span><br><span class="line">确保你已经安装了 Vim 插件管理器，如 pathogen 或 vim-plug。</span><br><span class="line">根据你选择的插件管理器，在你的 Vim 配置文件（一般是 ~/.vimrc）中添加相应的配置。</span><br><span class="line">安装 Tagbar 插件。对于 pathogen，可以将插件克隆到 ~/.vim/bundle/ 目录下。对于 vim-plug，可以在 ~/.vimrc 中添加插件的配置，并执行 :PlugInstall 命令进行安装。</span><br><span class="line">重新启动 Vim，并执行 :TagbarToggle 命令来打开或关闭 Tagbar 窗口。你也可以将其映射为方便的快捷键。</span><br><span class="line">当你打开 Tagbar 窗口时，它将会在屏幕的右侧列出当前文件中的函数列表。</span><br><span class="line"></span><br><span class="line">请注意，这只是一个示例插件，适用于 Vim 编辑器。对于其他编辑器或 IDE，你可以搜索类似的插件或查看相关的功能来实现类似的效果。</span><br></pre></td></tr></table></figure>

<h1 id="线程池模型原理分析"><a href="#线程池模型原理分析" class="headerlink" title="线程池模型原理分析"></a>线程池模型原理分析</h1><p><img src="/Linux-%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230715143147311.png" alt="image-20230715143147311"></p>
<img src="/2023/07/14/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux-%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230715143147311.png" class title="This is an test image">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">struct threadpool_t &#123;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_t lock;               /* 用于锁住本结构体 */    </span><br><span class="line">    pthread_mutex_t thread_counter;     /* 记录忙状态线程个数de琐 -- busy_thr_num */</span><br><span class="line"></span><br><span class="line">    pthread_cond_t queue_not_full;      /* 当任务队列满时，添加任务的线程阻塞，等待此条件变量 */</span><br><span class="line">    pthread_cond_t queue_not_empty;     /* 任务队列里不为空时，通知等待任务的线程 */</span><br><span class="line"></span><br><span class="line">    pthread_t *threads;                 /* 存放线程池中每个线程的tid。数组 */</span><br><span class="line">    pthread_t adjust_tid;               /* 存管理线程tid */</span><br><span class="line">    threadpool_task_t *task_queue;      /* 任务队列(数组首地址) */</span><br><span class="line"></span><br><span class="line">    int min_thr_num;                    /* 线程池最小线程数 */</span><br><span class="line">    int max_thr_num;                    /* 线程池最大线程数 */</span><br><span class="line">    int live_thr_num;                   /* 当前存活线程个数 */</span><br><span class="line">    int busy_thr_num;                   /* 忙状态线程个数 */</span><br><span class="line">    int wait_exit_thr_num;              /* 要销毁的线程个数 */</span><br><span class="line"></span><br><span class="line">    int queue_front;                    /* task_queue队头下标 */</span><br><span class="line">    int queue_rear;                     /* task_queue队尾下标 */</span><br><span class="line">    int queue_size;                     /* task_queue队中实际任务数 */</span><br><span class="line">    int queue_max_size;                 /* task_queue队列可容纳任务数上限 */</span><br><span class="line"></span><br><span class="line">    int shutdown;                       /* 标志位，线程池使用状态，true或false */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line"></span><br><span class="line">    void *(*function)(void *);          /* 函数指针，回调函数 */</span><br><span class="line">	void *arg;                          /* 上面函数的参数 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="线程池main架构"><a href="#线程池main架构" class="headerlink" title="线程池main架构"></a>线程池main架构</h2><ol>
<li>main();</li>
</ol>
<p>​    创建线程池。</p>
<p>​    向线程池中添加任务。 借助回调处理任务。</p>
<p>​    销毁线程池。</p>
<h2 id="线程池-pthreadpool-create"><a href="#线程池-pthreadpool-create" class="headerlink" title="线程池-pthreadpool_create"></a>线程池-pthreadpool_create</h2><ol start="2">
<li>pthreadpool_create();</li>
</ol>
<p>​    创建线程池结构体 指针。</p>
<p>​    初始化线程池结构体 { N 个成员变量 }</p>
<p>​    创建 N 个任务线程。</p>
<p>​    创建 1 个管理者线程。</p>
<p>​    失败时，销毁开辟的所有空间。（释放）</p>
<h2 id="子线程回调函数"><a href="#子线程回调函数" class="headerlink" title="子线程回调函数"></a>子线程回调函数</h2><ol start="3">
<li>threadpool_thread（）</li>
</ol>
<p>​    进入子线程回调函数。</p>
<p>​    接收参数 void *arg –》 pool 结构体</p>
<p>​    加锁 –》lock –》 整个结构体锁</p>
<p>​    判断条件变量 –》 wait</p>
<h2 id="管理者线程"><a href="#管理者线程" class="headerlink" title="管理者线程"></a>管理者线程</h2><ol start="4">
<li>adjust_thread（）</li>
</ol>
<p>​    循环 10 s 执行一次。</p>
<p>​    进入管理者线程回调函数</p>
<p>​    接收参数 void *arg –》 pool 结构体</p>
<p>​    加锁 –》lock –》 整个结构体锁</p>
<p>​    获取管理线程池要用的到 变量。  task_num, live_num, busy_num</p>
<p>​    根据既定算法，使用上述3变量，判断是否应该 创建、销毁线程池中 指定步长的线程。</p>
<h2 id="threadpool-add函数"><a href="#threadpool-add函数" class="headerlink" title="threadpool_add函数"></a>threadpool_add函数</h2><ol start="5">
<li>threadpool_add ()</li>
</ol>
<p>​    总功能：</p>
<p>​      模拟产生任务。  num[20]</p>
<p>​      设置回调函数， 处理任务。 sleep（1） 代表处理完成。</p>
<p>​    内部实现：</p>
<p>​      加锁</p>
<p>​      初始化 任务队列结构体成员。  回调函数 function， arg</p>
<p>​      利用环形队列机制，实现添加任务。 借助队尾指针挪移 % 实现。</p>
<p>​      唤醒阻塞在 条件变量上的线程。</p>
<p>​      解锁</p>
<h2 id="条件满足，子线程wait被唤醒后处理任务"><a href="#条件满足，子线程wait被唤醒后处理任务" class="headerlink" title="条件满足，子线程wait被唤醒后处理任务"></a>条件满足，子线程wait被唤醒后处理任务</h2><ol start="6">
<li>从 3. 中的wait之后继续执行，处理任务。</li>
</ol>
<p>​    加锁</p>
<p>​    </p>
<p>​    获取 任务处理回调函数，及参数</p>
<p>​    利用环形队列机制，实现处理任务。 借助队头指针挪移 % 实现。</p>
<p>​    唤醒阻塞在 条件变量 上的 server。</p>
<p>​    解锁</p>
<p>​    加锁</p>
<p>​    改忙线程数++</p>
<p>​    解锁</p>
<p>​    执行处理任务的线程</p>
<p>​    加锁</p>
<p>​    改忙线程数——</p>
<p>​    解锁</p>
<h2 id="线程池扩容和销毁"><a href="#线程池扩容和销毁" class="headerlink" title="线程池扩容和销毁"></a>线程池扩容和销毁</h2><ol start="7">
<li>创建 销毁线程</li>
</ol>
<p>​    管理者线程根据 task_num, live_num, busy_num </p>
<p>​    根据既定算法，使用上述3变量，判断是否应该 创建、销毁线程池中 指定步长的线程。</p>
<p>​    如果满足 创建条件</p>
<p>​      pthread_create();  回调 任务线程函数。    live_num++</p>
<p>​    如果满足 销毁条件</p>
<p>​      wait_exit_thr_num &#x3D; 10; </p>
<p>​      signal 给 阻塞在条件变量上的线程 发送 假条件满足信号  </p>
<p>​      跳转至 –170 wait阻塞线程会被 假信号 唤醒。判断： wait_exit_thr_num &gt; 0 pthread_exit();</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/12/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux-%E5%A4%9A%E8%B7%AFI-O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/12/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux-%E5%A4%9A%E8%B7%AFI-O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/" class="post-title-link" itemprop="url">Linux-多路I/O转接服务器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-12 14:56:57" itemprop="dateCreated datePublished" datetime="2023-07-12T14:56:57+08:00">2023-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-28 12:09:04" itemprop="dateModified" datetime="2023-07-28T12:09:04+08:00">2023-07-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="多路IO转接服务器设计思路"><a href="#多路IO转接服务器设计思路" class="headerlink" title="多路IO转接服务器设计思路"></a>多路IO转接服务器设计思路</h2><p><img src="/Linux-%E5%A4%9A%E8%B7%AFI-O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230711110952097.png" alt="image-20230711110952097"></p>
<img src="/2023/07/12/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux-%E5%A4%9A%E8%B7%AFI-O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230711110952097.png" class title="This is an test image">

<h2 id="select函数参数简介"><a href="#select函数参数简介" class="headerlink" title="select函数参数简介"></a>select函数参数简介</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout);</span><br><span class="line"></span><br><span class="line">		nfds：监听的所有文件描述符中，最大文件描述符+1</span><br><span class="line"></span><br><span class="line">		readfds： 读 文件描述符监听集合。	传入、传出参数</span><br><span class="line"></span><br><span class="line">		writefds：写 文件描述符监听集合。	传入、传出参数		NULL</span><br><span class="line"></span><br><span class="line">		exceptfds：异常 文件描述符监听集合	传入、传出参数		NULL</span><br><span class="line"></span><br><span class="line">		timeout： 	&gt; 0: 	设置监听超时时长。</span><br><span class="line"></span><br><span class="line">				NULL:	阻塞监听</span><br><span class="line"></span><br><span class="line">				0：	非阻塞监听，轮询</span><br><span class="line">		返回值：</span><br><span class="line"></span><br><span class="line">			&gt; 0:	所有监听集合（3个）中， 满足对应事件的总数。</span><br><span class="line"></span><br><span class="line">			0：	没有满足监听条件的文件描述符</span><br><span class="line"></span><br><span class="line">			-1： 	errno</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="select相关函数参数分析"><a href="#select相关函数参数分析" class="headerlink" title="select相关函数参数分析"></a>select相关函数参数分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void FD_CLR(int fd, fd_set *set)		把某一个fd清除出去</span><br><span class="line">int FD_ISSET(int fd, fd_set *set)		判定某个fd是否在位图中</span><br><span class="line">void FD_SET(int fd, fd_set *set)		把某一个fd添加到位图</span><br><span class="line">void FD_ZERO(fd_set *set)				位图所有二进制位置零</span><br><span class="line"></span><br><span class="line">select多路IO转接：</span><br><span class="line"></span><br><span class="line">	原理：  借助内核， select 来监听， 客户端连接、数据通信事件。</span><br><span class="line"></span><br><span class="line">	void FD_ZERO(fd_set *set);	--- 清空一个文件描述符集合。</span><br><span class="line"></span><br><span class="line">		fd_set rset;</span><br><span class="line"></span><br><span class="line">		FD_ZERO(&amp;rset);</span><br><span class="line"></span><br><span class="line">	void FD_SET(int fd, fd_set *set);	--- 将待监听的文件描述符，添加到监听集合中</span><br><span class="line"></span><br><span class="line">		FD_SET(3, &amp;rset);	FD_SET(5, &amp;rset);	FD_SET(6, &amp;rset);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	void FD_CLR(int fd, fd_set *set);	--- 将一个文件描述符从监听集合中 移除。</span><br><span class="line"></span><br><span class="line">		FD_CLR（4， &amp;rset）;</span><br><span class="line"></span><br><span class="line">	int  FD_ISSET(int fd, fd_set *set);	--- 判断一个文件描述符是否在监听集合中。</span><br><span class="line"></span><br><span class="line">		返回值： 在：1；不在：0；</span><br><span class="line"></span><br><span class="line">		FD_ISSET（4， &amp;rset）;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="select实现多路IO转接设计思路"><a href="#select实现多路IO转接设计思路" class="headerlink" title="select实现多路IO转接设计思路"></a>select实现多路IO转接设计思路</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">思路分析：</span><br><span class="line"></span><br><span class="line">	int maxfd = 0；</span><br><span class="line"></span><br><span class="line">	lfd = socket() ;			创建套接字</span><br><span class="line"></span><br><span class="line">	maxfd = lfd；</span><br><span class="line"></span><br><span class="line">	bind();					绑定地址结构</span><br><span class="line"></span><br><span class="line">	listen();				设置监听上限</span><br><span class="line"></span><br><span class="line">	fd_set rset， allset;			创建r监听集合</span><br><span class="line"></span><br><span class="line">	FD_ZERO(&amp;allset);				将r监听集合清空</span><br><span class="line"></span><br><span class="line">	FD_SET(lfd, &amp;allset);			将 lfd 添加至读集合中。</span><br><span class="line"></span><br><span class="line">	while（1） &#123;</span><br><span class="line"></span><br><span class="line">		rset = allset；			保存监听集合</span><br><span class="line">	</span><br><span class="line">		ret  = select(lfd+1， &amp;rset， NULL， NULL， NULL);		监听文件描述符集合对应事件。</span><br><span class="line"></span><br><span class="line">		if（ret &gt; 0） &#123;							有监听的描述符满足对应事件</span><br><span class="line">		</span><br><span class="line">			if (FD_ISSET(lfd, &amp;rset)) &#123;				// 1 在。 0不在。</span><br><span class="line"></span><br><span class="line">				cfd = accept（）；				建立连接，返回用于通信的文件描述符</span><br><span class="line"></span><br><span class="line">				maxfd = cfd；</span><br><span class="line"></span><br><span class="line">				FD_SET(cfd, &amp;allset);				添加到监听通信描述符集合中。</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			for （i = lfd+1； i &lt;= 最大文件描述符; i++）&#123;</span><br><span class="line"></span><br><span class="line">				FD_ISSET(i, &amp;rset)				有read、write事件</span><br><span class="line"></span><br><span class="line">				read（）</span><br><span class="line"></span><br><span class="line">				小 -- 大</span><br><span class="line"></span><br><span class="line">				write();</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="select实现多路IO转接-代码review"><a href="#select实现多路IO转接-代码review" class="headerlink" title="select实现多路IO转接-代码review"></a>select实现多路IO转接-代码review</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">#include &lt;ctype.h&gt;  </span><br><span class="line"></span><br><span class="line">#include &quot;wrap.h&quot;  </span><br><span class="line"></span><br><span class="line">#define SERV_PORT 6666  </span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">    int i, j, n, nready;  </span><br><span class="line"></span><br><span class="line">    int maxfd = 0;  </span><br><span class="line"></span><br><span class="line">    int listenfd, connfd;  </span><br><span class="line"></span><br><span class="line">    char buf[BUFSIZ];         /* #define INET_ADDRSTRLEN 16 */  </span><br><span class="line"></span><br><span class="line">    struct sockaddr_in clie_addr, serv_addr;  </span><br><span class="line">    socklen_t clie_addr_len;  </span><br><span class="line"></span><br><span class="line">    listenfd = Socket(AF_INET, SOCK_STREAM, 0);    </span><br><span class="line">    int opt = 1;  </span><br><span class="line">    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, (void *)&amp;opt, sizeof(opt));  </span><br><span class="line">    </span><br><span class="line">    bzero(&amp;serv_addr, sizeof(serv_addr));  </span><br><span class="line">    serv_addr.sin_family= AF_INET;  </span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">    serv_addr.sin_port= htons(SERV_PORT);  </span><br><span class="line">    Bind(listenfd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr));  </span><br><span class="line">    Listen(listenfd, 128);  </span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">    fd_set rset, allset;                            /* rset 读事件文件描述符集合 allset用来暂存 */  </span><br><span class="line">  </span><br><span class="line">    maxfd = listenfd;  </span><br><span class="line">  </span><br><span class="line">    FD_ZERO(&amp;allset);  </span><br><span class="line">    FD_SET(listenfd, &amp;allset);                                  /* 构造select监控文件描述符集 */  </span><br><span class="line">  </span><br><span class="line">    while (1) &#123;     </span><br><span class="line">        rset = allset;                                          /* 每次循环时都从新设置select监控信号集 */  </span><br><span class="line">        nready = select(maxfd+1, &amp;rset, NULL, NULL, NULL);  </span><br><span class="line">        if (nready &lt; 0)  </span><br><span class="line">            perr_exit(&quot;select error&quot;);  </span><br><span class="line">  </span><br><span class="line">        if (FD_ISSET(listenfd, &amp;rset)) &#123;                        /* 说明有新的客户端链接请求 */  </span><br><span class="line">  </span><br><span class="line">            clie_addr_len = sizeof(clie_addr);  </span><br><span class="line">            connfd = Accept(listenfd, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);       /* Accept 不会阻塞 */  </span><br><span class="line">  </span><br><span class="line">            FD_SET(connfd, &amp;allset);                            /* 向监控文件描述符集合allset添加新的文件描述符connfd */  </span><br><span class="line">  </span><br><span class="line">            if (maxfd &lt; connfd)  </span><br><span class="line">                maxfd = connfd;  </span><br><span class="line">  </span><br><span class="line">            if (0 == --nready)                                  /* 只有listenfd有事件, 后续的 for 不需执行 */  </span><br><span class="line">                continue;  </span><br><span class="line">        &#125;   </span><br><span class="line">  </span><br><span class="line">        for (i = listenfd+1; i &lt;= maxfd; i++) &#123;                 /* 检测哪个clients 有数据就绪 */  </span><br><span class="line">  </span><br><span class="line">            if (FD_ISSET(i, &amp;rset)) &#123;  </span><br><span class="line">  </span><br><span class="line">                if ((n = Read(i, buf, sizeof(buf))) == 0) &#123;    /* 当client关闭链接时,服务器端也关闭对应链接 */  </span><br><span class="line">                    Close(i);  </span><br><span class="line">                    FD_CLR(i, &amp;allset);                        /* 解除select对此文件描述符的监控 */  </span><br><span class="line">                    &#125; else if (n &gt; 0) &#123;  </span><br><span class="line">	  </span><br><span class="line">	                    for (j = 0; j &lt; n; j++)  </span><br><span class="line">	                        buf[j] = toupper(buf[j]);  </span><br><span class="line">	                    Write(i, buf, n);  </span><br><span class="line">	                &#125;  </span><br><span class="line">	            &#125;  </span><br><span class="line">	        &#125;  </span><br><span class="line">	    &#125;  </span><br><span class="line">	  </span><br><span class="line">	    Close(listenfd);  </span><br><span class="line">	  </span><br><span class="line">	    return 0;  </span><br><span class="line">	&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用 Ctrl+Z 组合键是一种在命令行界面下停止（暂停）进程的方法，而不是正确关闭连接或套接字。</p>
<p>在大多数操作系统中，Ctrl+Z 组合键用于发送一个 SIGTSTP 信号给当前运行的进程，以暂停其执行。这通常是在后台运行的进程或任务中使用的，如在 Linux 或 UNIX 系统中运行的程序。通过按下 Ctrl+Z，您可以使进程进入后台挂起状态，并返回到命令行提示符，从而可以执行其他操作。</p>
<p>然而，Ctrl+Z 并不会主动关闭连接或套接字，它只是将进程暂停，但连接可能仍然处于活动状态。如果您希望正确关闭连接或套接字，应该在适当的时间调用相应的方法或函数来明确地关闭它们。具体取决于所使用的编程语言和网络库。</p>
<p>对于大多数命令行界面，使用 <strong>Ctrl+C</strong> 组合键是一种常用的方法来停止正在运行的进程或程序，包括网络连接和套接字。</p>
<p>按下 Ctrl+C 组合键会发送一个 SIGINT 信号给当前运行的进程，这通常会中断进程的执行并终止它。在网络编程中，当您想要停止正在进行的连接时，可以按下 Ctrl+C 组合键来关闭连接并终止与该连接相关的进程。</p>
<p>需要注意的是，按下 Ctrl+C 组合键将会立即终止进程，可能导致一些未完成的操作无法正确处理。因此，在关闭连接或套接字之前，建议在适当的时机进行必要的清理和处理操作，以确保数据的完整性和资源的正确释放。</p>
<p>总而言之，Ctrl+C 是一种常见且有效的方式来停止正在运行的进程，包括关闭网络连接和套接字。但请谨慎使用，确保在终止进程之前进行必要的清理和处理操作，以避免可能的问题。</p>
<h3 id="select优缺点"><a href="#select优缺点" class="headerlink" title="select优缺点"></a>select优缺点</h3><p>select优缺点：</p>
<p>  缺点： 监听上限受文件描述符限制。 最大 1024.</p>
<p>​    检测满足条件的fd， 自己添加业务逻辑提高小。 提高了编码难度。</p>
<p>  优点： 跨平台。win、linux、macOS、Unix、类Unix、mips</p>
<ol>
<li><p>select能监听的文件描述符个数受限于FD_SETSIZE,一般为1024，单纯改变进程打开的文件描述符个数并不能改变select监听文件个数</p>
</li>
<li><p>解决1024以下客户端时使用select是很合适的，但如果链接客户端过多，select采用的是轮询模型，会大大降低服务器响应效率，不应在select上投入更多精力</p>
</li>
</ol>
<p>select代码里有个可以优化的地方，用数组存下文件描述符，这样就不需要每次扫描一大堆无关文件描述符了</p>
<h2 id="添加一个自定义数组提高效率"><a href="#添加一个自定义数组提高效率" class="headerlink" title="添加一个自定义数组提高效率"></a>添加一个自定义数组提高效率</h2><p>这里就是改进之前代码的问题，之前的代码，如果最大fd是1023，每次确定有事件发生的fd时，就要扫描3-1023的所有文件描述符，这看起来很蠢。于是定义一个数组，把要监听的文件描述符存下来，每次扫描这个数组就行了。看起来科学得多。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">1.	#include &lt;stdio.h&gt;  </span><br><span class="line">2.	#include &lt;stdlib.h&gt;  </span><br><span class="line">3.	#include &lt;unistd.h&gt;  </span><br><span class="line">4.	#include &lt;string.h&gt;  </span><br><span class="line">5.	#include &lt;arpa/inet.h&gt;  </span><br><span class="line">6.	#include &lt;ctype.h&gt;  </span><br><span class="line">7.	  </span><br><span class="line">8.	#include &quot;wrap.h&quot;  </span><br><span class="line">9.	  </span><br><span class="line">10.	#define SERV_PORT 6666  </span><br><span class="line">11.	  </span><br><span class="line">12.	int main(int argc, char *argv[])  </span><br><span class="line">13.	&#123;  </span><br><span class="line">14.	    int i, j, n, maxi;  </span><br><span class="line">15.	  </span><br><span class="line">16.	    int nready, client[FD_SETSIZE];                 /* 自定义数组client, 防止遍历1024个文件描述符  FD_SETSIZE默认为1024 */  </span><br><span class="line">17.	    int maxfd, listenfd, connfd, sockfd;  </span><br><span class="line">18.	    char buf[BUFSIZ], str[INET_ADDRSTRLEN];         /* #define INET_ADDRSTRLEN 16 */  </span><br><span class="line">19.	  </span><br><span class="line">20.	    struct sockaddr_in clie_addr, serv_addr;  </span><br><span class="line">21.	    socklen_t clie_addr_len;  </span><br><span class="line">22.	    fd_set rset, allset;                            /* rset 读事件文件描述符集合 allset用来暂存 */  </span><br><span class="line">23.	  </span><br><span class="line">24.	    listenfd = Socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">25.	  </span><br><span class="line">26.	    int opt = 1;  </span><br><span class="line">27.	    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt));  </span><br><span class="line">28.	  </span><br><span class="line">29.	    bzero(&amp;serv_addr, sizeof(serv_addr));  </span><br><span class="line">30.	    serv_addr.sin_family= AF_INET;  </span><br><span class="line">31.	    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">32.	    serv_addr.sin_port= htons(SERV_PORT);  </span><br><span class="line">33.	  </span><br><span class="line">34.	    Bind(listenfd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr));  </span><br><span class="line">35.	    Listen(listenfd, 128);  </span><br><span class="line">36.	  </span><br><span class="line">37.	    maxfd = listenfd;                                           /* 起初 listenfd 即为最大文件描述符 */  </span><br><span class="line">38.	  </span><br><span class="line">39.	    maxi = -1;                                                  /* 将来用作client[]的下标, 初始值指向0个元素之前下标位置 */  </span><br><span class="line">40.	    for (i = 0; i &lt; FD_SETSIZE; i++)  </span><br><span class="line">41.	        client[i] = -1;                                         /* 用-1初始化client[] */  </span><br><span class="line">42.	  </span><br><span class="line">43.	    FD_ZERO(&amp;allset);  </span><br><span class="line">44.	    FD_SET(listenfd, &amp;allset);                                  /* 构造select监控文件描述符集 */  </span><br><span class="line">45.	  </span><br><span class="line">46.	    while (1) &#123;     </span><br><span class="line">47.	        rset = allset;                                          /* 每次循环时都重新设置select监控信号集 */  </span><br><span class="line">48.	  </span><br><span class="line">49.	        nready = select(maxfd+1, &amp;rset, NULL, NULL, NULL);  //2  1--lfd  1--connfd  </span><br><span class="line">50.	        if (nready &lt; 0)  </span><br><span class="line">51.	            perr_exit(&quot;select error&quot;);  </span><br><span class="line">52.	  </span><br><span class="line">53.	        if (FD_ISSET(listenfd, &amp;rset)) &#123;                        /* 说明有新的客户端链接请求 */  </span><br><span class="line">54.	  </span><br><span class="line">55.	            clie_addr_len = sizeof(clie_addr);  </span><br><span class="line">56.	            connfd = Accept(listenfd, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);       /* Accept 不会阻塞 */  </span><br><span class="line">57.	            printf(&quot;received from %s at PORT %d\n&quot;,  </span><br><span class="line">58.	                    inet_ntop(AF_INET, &amp;clie_addr.sin_addr, str, sizeof(str)),  </span><br><span class="line">59.	                    ntohs(clie_addr.sin_port));  </span><br><span class="line">60.	  </span><br><span class="line">61.	            for (i = 0; i &lt; FD_SETSIZE; i++)  </span><br><span class="line">62.	                if (client[i] &lt; 0) &#123;                            /* 找client[]中没有使用的位置 */  </span><br><span class="line">63.	                    client[i] = connfd;                         /* 保存accept返回的文件描述符到client[]里 */  </span><br><span class="line">64.	                    break;  </span><br><span class="line">65.	                &#125;  </span><br><span class="line">66.	  </span><br><span class="line">67.	            if (i == FD_SETSIZE) &#123;                              /* 达到select能监控的文件个数上限 1024 */  </span><br><span class="line">68.	                fputs(&quot;too many clients\n&quot;, stderr);  </span><br><span class="line">69.	                exit(1);  </span><br><span class="line">70.	            &#125;  </span><br><span class="line">71.	  </span><br><span class="line">72.	            FD_SET(connfd, &amp;allset);                            /* 向监控文件描述符集合allset添加新的文件描述符connfd */  </span><br><span class="line">73.	  </span><br><span class="line">74.	            if (connfd &gt; maxfd)  </span><br><span class="line">75.	                maxfd = connfd;                                 /* select第一个参数需要 */  </span><br><span class="line">76.	  </span><br><span class="line">77.	            if (i &gt; maxi)  </span><br><span class="line">78.	                maxi = i;                                       /* 保证maxi存的总是client[]最后一个元素下标 */  </span><br><span class="line">79.	  </span><br><span class="line">80.	            if (--nready == 0)  //在后面的原因，如果有请求，lfd有FD_ISSET(listenfd, &amp;rset)，再进行accept，无阻塞</span><br><span class="line">81.	                continue;  </span><br><span class="line">82.	        &#125;   </span><br><span class="line">83.	  </span><br><span class="line">84.	        for (i = 0; i &lt;= maxi; i++) &#123;                               /* 检测哪个clients 有数据就绪 */  </span><br><span class="line">85.	  </span><br><span class="line">86.	            if ((sockfd = client[i]) &lt; 0)  </span><br><span class="line">87.	                continue;  </span><br><span class="line">88.	            if (FD_ISSET(sockfd, &amp;rset)) &#123;  </span><br><span class="line">89.	  </span><br><span class="line">90.	                if ((n = Read(sockfd, buf, sizeof(buf))) == 0) &#123;    /* 当client关闭链接时,服务器端也关闭对应链接 */  </span><br><span class="line">91.	                    Close(sockfd);  </span><br><span class="line">92.	                    FD_CLR(sockfd, &amp;allset);                        /* 解除select对此文件描述符的监控 */  </span><br><span class="line">93.	                    client[i] = -1;  </span><br><span class="line">94.	                &#125; else if (n &gt; 0) &#123;  </span><br><span class="line">95.	                    for (j = 0; j &lt; n; j++)  </span><br><span class="line">96.	                        buf[j] = toupper(buf[j]);  </span><br><span class="line">97.	                    Write(sockfd, buf, n);  </span><br><span class="line">98.	                    Write(STDOUT_FILENO, buf, n);  </span><br><span class="line">99.	                &#125;  </span><br><span class="line">100.	                if (--nready == 0)  </span><br><span class="line">101.	                    break;                                          /* 跳出for, 但还在while中 */  </span><br><span class="line">102.	            &#125;  </span><br><span class="line">103.	        &#125;  </span><br><span class="line">104.	    &#125;  </span><br><span class="line">105.	    Close(listenfd);  </span><br><span class="line">106.	    return 0;  </span><br><span class="line">107.	&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="poll函数原型分析"><a href="#poll函数原型分析" class="headerlink" title="poll函数原型分析"></a>poll函数原型分析</h2><p>poll是对select的改进，但是它是个半成品，相对select提升不大。最终版本是epoll，所以poll了解一下就完事儿，重点掌握epoll。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">poll：</span><br><span class="line">	int poll(struct pollfd *fds, nfds_t nfds, int timeout);</span><br><span class="line"></span><br><span class="line">		fds：监听的文件描述符【数组】</span><br><span class="line"></span><br><span class="line">			struct pollfd &#123;</span><br><span class="line">				</span><br><span class="line">				int fd：	待监听的文件描述符</span><br><span class="line">				</span><br><span class="line">				short events：	待监听的文件描述符对应的监听事件</span><br><span class="line"></span><br><span class="line">						取值：POLLIN、POLLOUT、POLLERR</span><br><span class="line"></span><br><span class="line">				short revnets：	传入时， 给0。如果满足对应事件的话， 返回 非0 --&gt; POLLIN、POLLOUT、POLLERR</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		nfds: 监听数组的，实际有效监听个数。</span><br><span class="line"></span><br><span class="line">		timeout:  &gt; 0:  超时时长。单位：毫秒。</span><br><span class="line"></span><br><span class="line">			  -1:	阻塞等待</span><br><span class="line"></span><br><span class="line">			  0：  不阻塞</span><br><span class="line"></span><br><span class="line">		返回值：返回满足对应监听事件的文件描述符 总个数。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  优点：</p>
<p>​    自带数组结构。 可以将 监听事件集合 和 返回事件集合 分离。</p>
<p>​    拓展 监听上限。 超出 1024限制。</p>
<p>  缺点：</p>
<p>​    不能跨平台。 Linux</p>
<p>​    无法直接定位满足监听事件的文件描述符， 编码难度较大。</p>
<h3 id="poll函数实现服务器"><a href="#poll函数实现服务器" class="headerlink" title="poll函数实现服务器"></a>poll函数实现服务器</h3><p>这个东西用得少，基本都用epoll</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">1.	/* server.c */  </span><br><span class="line">2.	#include &lt;stdio.h&gt;  </span><br><span class="line">3.	#include &lt;stdlib.h&gt;  </span><br><span class="line">4.	#include &lt;string.h&gt;  </span><br><span class="line">5.	#include &lt;netinet/in.h&gt;  </span><br><span class="line">6.	#include &lt;arpa/inet.h&gt;  </span><br><span class="line">7.	#include &lt;poll.h&gt;  </span><br><span class="line">8.	#include &lt;errno.h&gt;  </span><br><span class="line">9.	#include &quot;wrap.h&quot;  </span><br><span class="line">10.	  </span><br><span class="line">11.	#define MAXLINE 80  </span><br><span class="line">12.	#define SERV_PORT 6666  </span><br><span class="line">13.	#define OPEN_MAX 1024  </span><br><span class="line">14.	  </span><br><span class="line">15.	int main(int argc, char *argv[])  </span><br><span class="line">16.	&#123;  </span><br><span class="line">17.	    int i, j, maxi, listenfd, connfd, sockfd;  </span><br><span class="line">18.	    int nready;  </span><br><span class="line">19.	    ssize_t n;  </span><br><span class="line">20.	    char buf[MAXLINE], str[INET_ADDRSTRLEN];  </span><br><span class="line">21.	    socklen_t clilen;  </span><br><span class="line">22.	    struct pollfd client[OPEN_MAX];  </span><br><span class="line">23.	    struct sockaddr_in cliaddr, servaddr;  </span><br><span class="line">24.	  </span><br><span class="line">25.	    listenfd = Socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">26.	  </span><br><span class="line">27.	    bzero(&amp;servaddr, sizeof(servaddr));  </span><br><span class="line">28.	    servaddr.sin_family = AF_INET;  </span><br><span class="line">29.	    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">30.	    servaddr.sin_port = htons(SERV_PORT);  </span><br><span class="line">31.	  </span><br><span class="line">32.	    Bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));  </span><br><span class="line">33.	  </span><br><span class="line">34.	    Listen(listenfd, 20);  </span><br><span class="line">35.	  </span><br><span class="line">36.	    client[0].fd = listenfd;  </span><br><span class="line">37.	    client[0].events = POLLRDNORM;                  /* listenfd监听普通读事件 */  </span><br><span class="line">38.	  </span><br><span class="line">39.	    for (i = 1; i &lt; OPEN_MAX; i++)  </span><br><span class="line">40.	        client[i].fd = -1;                          /* 用-1初始化client[]里剩下元素 */  </span><br><span class="line">41.	    maxi = 0;                                       /* client[]数组有效元素中最大元素下标 */  </span><br><span class="line">42.	  </span><br><span class="line">43.	    for ( ; ; ) &#123;  </span><br><span class="line">44.	        nready = poll(client, maxi+1, -1);          /* 阻塞 */  </span><br><span class="line">45.	        if (client[0].revents &amp; POLLRDNORM) &#123;       /* 有客户端链接请求 */  </span><br><span class="line">46.	            clilen = sizeof(cliaddr);  </span><br><span class="line">47.	            connfd = Accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;clilen);  </span><br><span class="line">48.	            printf(&quot;received from %s at PORT %d\n&quot;,  </span><br><span class="line">49.	                    inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, sizeof(str)),  </span><br><span class="line">50.	                    ntohs(cliaddr.sin_port));  </span><br><span class="line">51.	            for (i = 1; i &lt; OPEN_MAX; i++) &#123;  </span><br><span class="line">52.	                if (client[i].fd &lt; 0) &#123;  </span><br><span class="line">53.	                    client[i].fd = connfd;  /* 找到client[]中空闲的位置，存放accept返回的connfd */  </span><br><span class="line">54.	                    break;  </span><br><span class="line">55.	                &#125;  </span><br><span class="line">56.	            &#125;  </span><br><span class="line">57.	  </span><br><span class="line">58.	            if (i == OPEN_MAX)  </span><br><span class="line">59.	                perr_exit(&quot;too many clients&quot;);  </span><br><span class="line">60.	  </span><br><span class="line">61.	            client[i].events = POLLRDNORM;      /* 设置刚刚返回的connfd，监控读事件 */  </span><br><span class="line">62.	            if (i &gt; maxi)  </span><br><span class="line">63.	                maxi = i;                       /* 更新client[]中最大元素下标 */  </span><br><span class="line">64.	            if (--nready &lt;= 0)  </span><br><span class="line">65.	                continue;                       /* 没有更多就绪事件时,继续回到poll阻塞 */  </span><br><span class="line">66.	        &#125;  </span><br><span class="line">67.	        for (i = 1; i &lt;= maxi; i++) &#123;            /* 检测client[] */  </span><br><span class="line">68.	            if ((sockfd = client[i].fd) &lt; 0)  </span><br><span class="line">69.	                continue;  </span><br><span class="line">70.	            if (client[i].revents &amp; (POLLRDNORM | POLLERR)) &#123;  </span><br><span class="line">71.	                if ((n = Read(sockfd, buf, MAXLINE)) &lt; 0) &#123;  </span><br><span class="line">72.	                    if (errno == ECONNRESET) &#123; /* 当收到 RST标志时 */  </span><br><span class="line">73.	                        /* connection reset by client */  </span><br><span class="line">74.	                        printf(&quot;client[%d] aborted connection\n&quot;, i);  </span><br><span class="line">75.	                        Close(sockfd);  </span><br><span class="line">76.	                        client[i].fd = -1;  </span><br><span class="line">77.	                    &#125; else &#123;  </span><br><span class="line">78.	                        perr_exit(&quot;read error&quot;);  </span><br><span class="line">79.	                    &#125;  </span><br><span class="line">80.	                &#125; else if (n == 0) &#123;  </span><br><span class="line">81.	                    /* connection closed by client */  </span><br><span class="line">82.	                    printf(&quot;client[%d] closed connection\n&quot;, i);  </span><br><span class="line">83.	                    Close(sockfd);  </span><br><span class="line">84.	                    client[i].fd = -1;  </span><br><span class="line">85.	                &#125; else &#123;  </span><br><span class="line">86.	                    for (j = 0; j &lt; n; j++)  </span><br><span class="line">87.	                        buf[j] = toupper(buf[j]);  </span><br><span class="line">88.	                        Writen(sockfd, buf, n);  </span><br><span class="line">89.	                &#125;  </span><br><span class="line">90.	                if (--nready &lt;= 0)  </span><br><span class="line">91.	                    break;              /* no more readable descriptors */  </span><br><span class="line">92.	            &#125;  </span><br><span class="line">93.	        &#125;  </span><br><span class="line">94.	    &#125;  </span><br><span class="line">95.	    return 0;  </span><br><span class="line">96.	&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="epoll函数实现的多路IO转接"><a href="#epoll函数实现的多路IO转接" class="headerlink" title="epoll函数实现的多路IO转接"></a>epoll函数实现的多路IO转接</h2><h3 id="突破1024文件描述符设置"><a href="#突破1024文件描述符设置" class="headerlink" title="突破1024文件描述符设置"></a>突破1024文件描述符设置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">突破 1024 文件描述符限制：</span><br><span class="line"></span><br><span class="line">	cat /proc/sys/fs/file-max  --&gt; 当前计算机所能打开的最大文件个数。 受硬件影响。</span><br><span class="line"></span><br><span class="line">	ulimit -a 	——&gt; 当前用户下的进程，默认打开文件描述符个数。  缺省为 1024</span><br><span class="line"></span><br><span class="line">	修改：</span><br><span class="line">		打开 sudo vi /etc/security/limits.conf， 写入：</span><br><span class="line"></span><br><span class="line">		* soft nofile 65536			--&gt; 设置默认值， 可以直接借助命令修改。 【注销用户，使其生效】</span><br><span class="line"></span><br><span class="line">		* hard nofile 100000			--&gt; 命令修改上限。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cat /proc/sys/fs/file-max		查看最大文件描述符上限</span><br><span class="line">ulimit -a 	来查看open files</span><br><span class="line">sudo vi /etc/security/limits.conf  修改上限，修改之后，注销用户重新登录，查看文件描述符上限</span><br><span class="line">如果使用ulimit -n  来修改，会受到之前设置的hard的限制</span><br><span class="line">用ulimit -n设置之后，往下调可以，往上调需要注销用户再登录。</span><br></pre></td></tr></table></figure>

<h3 id="epoll-create和epoll-ctl"><a href="#epoll-create和epoll-ctl" class="headerlink" title="epoll_create和epoll_ctl"></a>epoll_create和epoll_ctl</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">epoll：</span><br><span class="line">	int epoll_create(int size);						创建一棵监听红黑树</span><br><span class="line"></span><br><span class="line">		size：创建的红黑树的监听节点数量。（仅供内核参考。）</span><br><span class="line"></span><br><span class="line">		返回值：指向新创建的红黑树的根节点的 fd。 </span><br><span class="line"></span><br><span class="line">			失败： -1 errno</span><br><span class="line"></span><br><span class="line">	int epoll_create1(int flags);</span><br><span class="line">		If  flags  is 0, then, other than the fact that the obsolete size argument is dropped, epoll_create1() is the same</span><br><span class="line">       as epoll_create().  The following value can be included in flags to obtain different behavior:</span><br><span class="line"></span><br><span class="line">       EPOLL_CLOEXEC</span><br><span class="line">              Set the close-on-exec (FD_CLOEXEC) flag on the new file descriptor.  See the description of  the  O_CLOEXEC</span><br><span class="line">              flag in open(2) for reasons why this may be useful.</span><br><span class="line">              相当于上面的多调用了一次f_cntl函数指定为O_CLOEXEC，节点数量依赖于系统的资源</span><br><span class="line">              </span><br><span class="line">	int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);	操作监听红黑树</span><br><span class="line"></span><br><span class="line">		epfd：epoll_create 函数的返回值。 epfd</span><br><span class="line"></span><br><span class="line">		op：对该监听红黑数所做的操作。</span><br><span class="line"></span><br><span class="line">			EPOLL_CTL_ADD 添加fd到 监听红黑树</span><br><span class="line"></span><br><span class="line">			EPOLL_CTL_MOD 修改fd在 监听红黑树上的监听事件。</span><br><span class="line"></span><br><span class="line">			EPOLL_CTL_DEL 将一个fd 从监听红黑树上摘下（取消监听）</span><br><span class="line"></span><br><span class="line">		fd：</span><br><span class="line">			待监听的fd</span><br><span class="line"></span><br><span class="line">		event：	本质 struct epoll_event 结构体 地址</span><br><span class="line"></span><br><span class="line">			成员 events：</span><br><span class="line">	</span><br><span class="line">				EPOLLIN / EPOLLOUT / EPOLLERR</span><br><span class="line"></span><br><span class="line">			成员 data： 联合体（共用体）：</span><br><span class="line"></span><br><span class="line">				int fd;	  对应监听事件的 fd</span><br><span class="line"></span><br><span class="line">				void *ptr； </span><br><span class="line"></span><br><span class="line">				uint32_t u32;</span><br><span class="line"></span><br><span class="line">				uint64_t u64;		</span><br><span class="line"></span><br><span class="line">		返回值：成功 0； 失败： -1 errno</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="epoll-wait函数"><a href="#epoll-wait函数" class="headerlink" title="epoll_wait函数"></a>epoll_wait函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); 	 阻塞监听。</span><br><span class="line"></span><br><span class="line">		epfd：epoll_create 函数的返回值。 epfd</span><br><span class="line"></span><br><span class="line">		events：传出参数，【数组】， 满足监听条件的 那些 fd 结构体。</span><br><span class="line"></span><br><span class="line">		maxevents：数组 元素的总个数。 1024</span><br><span class="line">				</span><br><span class="line">			struct epoll_event events[1024]</span><br><span class="line">		timeout：</span><br><span class="line"></span><br><span class="line">			-1: 阻塞</span><br><span class="line"></span><br><span class="line">			0： 不阻塞</span><br><span class="line"></span><br><span class="line">			&gt;0: 超时时间 （毫秒）</span><br><span class="line"></span><br><span class="line">		返回值：</span><br><span class="line"></span><br><span class="line">			&gt; 0: 满足监听的 总个数。 可以用作循环上限。</span><br><span class="line"></span><br><span class="line">			0： 没有fd满足监听事件</span><br><span class="line"></span><br><span class="line">			-1：失败。 errno</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &quot;wrap.h&quot;</span><br><span class="line"></span><br><span class="line">#define MAXLINE 80</span><br><span class="line">#define SERV_PORT 6666</span><br><span class="line">#define OPEN_MAX 1024</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int i, j, listenfd, connfd, sockfd;</span><br><span class="line">	int nready, efd, res;</span><br><span class="line">	ssize_t n;</span><br><span class="line">	char buf[MAXLINE], str[INET_ADDRSTRLEN];</span><br><span class="line">	socklen_t clilen;</span><br><span class="line">	</span><br><span class="line">	struct sockaddr_in cliaddr, servaddr;</span><br><span class="line">	struct epoll_event tep, ep[OPEN_MAX];//tep: epoll_ctl参数  ep[] : epoll_wait参数</span><br><span class="line"></span><br><span class="line">	listenfd = Socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">	int opt = 1;  </span><br><span class="line">	setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt));      //端口复用</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, sizeof(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">	Bind(listenfd, (struct sockaddr *) &amp;servaddr, sizeof(servaddr));</span><br><span class="line"></span><br><span class="line">	Listen(listenfd, 20);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	efd = epoll_create(OPEN_MAX);//创建epoll模型, efd指向红黑树根节点 </span><br><span class="line">	if (efd == -1)</span><br><span class="line">		perr_exit(&quot;epoll_create&quot;);</span><br><span class="line"></span><br><span class="line">	tep.events = EPOLLIN; </span><br><span class="line">	tep.data.fd = listenfd; //指定lfd的监听时间为&quot;读&quot;</span><br><span class="line"></span><br><span class="line">	res = epoll_ctl(efd, EPOLL_CTL_ADD, listenfd, &amp;tep);//将lfd及对应的结构体设置到树上,efd可找到该树  </span><br><span class="line">	if (res == -1)</span><br><span class="line">		perr_exit(&quot;epoll_ctl&quot;);</span><br><span class="line"></span><br><span class="line">	while (1) &#123;/*epoll为server阻塞监听事件, ep为struct epoll_event类型数组, OPEN_MAX为数组容量, -1表永久阻塞*/  </span><br><span class="line">		nready = epoll_wait(efd, ep, OPEN_MAX, -1);			 /* 阻塞监听 */</span><br><span class="line">		if (nready == -1)</span><br><span class="line">			perr_exit(&quot;epoll_wait&quot;);</span><br><span class="line"></span><br><span class="line">		for (i = 0; i &lt; nready; i++) &#123;</span><br><span class="line">			if (!(ep[i].events &amp; EPOLLIN))//如果不是&quot;读&quot;事件, 继续循环 </span><br><span class="line">				continue;</span><br><span class="line">			if (ep[i].data.fd == listenfd) &#123;//判断满足事件的fd是不是lfd    </span><br><span class="line">				clilen = sizeof(cliaddr);</span><br><span class="line">				connfd = Accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;clilen);//接受链接 </span><br><span class="line">				printf(&quot;received from %s at PORT %d\n&quot;, </span><br><span class="line">						inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, sizeof(str)), </span><br><span class="line">						ntohs(cliaddr.sin_port));</span><br><span class="line">				</span><br><span class="line">				</span><br><span class="line"></span><br><span class="line">				tep.events = EPOLLIN; </span><br><span class="line">				tep.data.fd = connfd;</span><br><span class="line">				res = epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &amp;tep);//加入红黑树</span><br><span class="line">				if (res == -1)</span><br><span class="line">					perr_exit(&quot;epoll_ctl&quot;);</span><br><span class="line">			&#125; else &#123;  															//不是lfd</span><br><span class="line">				sockfd = ep[i].data.fd;</span><br><span class="line">				n = Read(sockfd, buf, MAXLINE);</span><br><span class="line">				if (n == 0) &#123;										//读到0,说明客户端关闭链接</span><br><span class="line">					</span><br><span class="line">					res = epoll_ctl(efd, EPOLL_CTL_DEL, sockfd, NULL);  //将该文件描述符从红黑树摘</span><br><span class="line">					if (res == -1)</span><br><span class="line">						perr_exit(&quot;epoll_ctl&quot;);</span><br><span class="line"></span><br><span class="line">					Close(sockfd);									 //关闭与该客户端的链接 </span><br><span class="line">					printf(&quot;client[%d] closed connection\n&quot;, j);</span><br><span class="line">				&#125; else &#123;	//实际读到了字节数</span><br><span class="line">					for (j = 0; j &lt; n; j++)	</span><br><span class="line">						buf[j] = toupper(buf[j]);</span><br><span class="line">					Writen(sockfd, buf, n);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	close(listenfd);</span><br><span class="line">	close(efd);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="read函数返回值"><a href="#read函数返回值" class="headerlink" title="read函数返回值:"></a>read函数返回值:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; 0:实际读到的字节数</span><br><span class="line">=0:</span><br><span class="line">	socket中，表示对端关闭。close ()</span><br><span class="line">-1:</span><br><span class="line">    如果errno == EINTR被异常终端。 需要重启。</span><br><span class="line">    如果errno = EAGIN或EYOULDBLOCK以非阻塞方式读数据，但是没有数据。需要， 再次读。</span><br><span class="line">    如果errno == ECONNRESET说明连接被 重置。需要close ()，移除监听队列。</span><br><span class="line">    错误。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">while( (len = read(fd, buf, sizeof(buf))) &gt; 0 ) &#123;   </span><br><span class="line">        // 发送读出的数据</span><br><span class="line">        ret = send(cfd, buf, len, 0);</span><br><span class="line">        if (ret == -1) &#123;</span><br><span class="line">            if (errno == EAGAIN) &#123;</span><br><span class="line">                perror(&quot;send error:&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125; else if (errno == EINTR) &#123;</span><br><span class="line">                perror(&quot;send error:&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                perror(&quot;send error:&quot;);</span><br><span class="line">                exit(1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="ET和LT模式"><a href="#ET和LT模式" class="headerlink" title="ET和LT模式"></a>ET和LT模式</h2><p>epoll是Linux下多路复用IO接口select&#x2F;poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率，因为它会复用文件描述符集合来传递结果而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合，另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。</p>
<p><img src="/Linux-%E5%A4%9A%E8%B7%AFI-O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230713145435478.png" alt="image-20230713145435478"></p>
<img src="/2023/07/12/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux-%E5%A4%9A%E8%B7%AFI-O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230713145435478.png" class title="This is an test image">

<p>EPOLL事件有两种模型：</p>
<p>​	Edge Triggered (ET) 边缘触发只有数据到来才触发，不管缓存区中是否还有数据。</p>
<p>​	Level Triggered (LT) 水平触发只要有数据都会触发。</p>
<p>用一个子进程来写内容，用ET和LT模式来读取，结果很能说明问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;sys/epoll.h&gt;  </span><br><span class="line">#include &lt;errno.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">  </span><br><span class="line">#define MAXLINE 10  </span><br><span class="line">  </span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">    int efd, i;  </span><br><span class="line">    int pfd[2];  </span><br><span class="line">    pid_t pid;  </span><br><span class="line">    char buf[MAXLINE], ch = &#x27;a&#x27;;  </span><br><span class="line">  </span><br><span class="line">    pipe(pfd);  //管道</span><br><span class="line">    pid = fork();  </span><br><span class="line">  </span><br><span class="line">    if (pid == 0) &#123;             //子 写  </span><br><span class="line">        close(pfd[0]);  </span><br><span class="line">        while (1) &#123;  </span><br><span class="line">            //aaaa\n  </span><br><span class="line">            for (i = 0; i &lt; MAXLINE/2; i++)  </span><br><span class="line">                buf[i] = ch;  </span><br><span class="line">            buf[i-1] = &#x27;\n&#x27;;  </span><br><span class="line">            ch++;  </span><br><span class="line">            //bbbb\n  </span><br><span class="line">            for (; i &lt; MAXLINE; i++)  </span><br><span class="line">                buf[i] = ch;  </span><br><span class="line">            buf[i-1] = &#x27;\n&#x27;;  </span><br><span class="line">            ch++;  </span><br><span class="line">            //aaaa\nbbbb\n  </span><br><span class="line">            write(pfd[1], buf, sizeof(buf));  </span><br><span class="line">            sleep(5);  </span><br><span class="line">        &#125;  </span><br><span class="line">        close(pfd[1]);  </span><br><span class="line">  </span><br><span class="line">    &#125; else if (pid &gt; 0) &#123;       //父 读  </span><br><span class="line">        struct epoll_event event;  </span><br><span class="line">        struct epoll_event resevent[10];        //epoll_wait就绪返回event  </span><br><span class="line">        int res, len;  </span><br><span class="line">  </span><br><span class="line">        close(pfd[1]);  </span><br><span class="line">        efd = epoll_create(10);  </span><br><span class="line">  </span><br><span class="line">        event.events = EPOLLIN | EPOLLET;     // ET 边沿触发  </span><br><span class="line">       // event.events = EPOLLIN;                 // LT 水平触发 (默认)  </span><br><span class="line">        event.data.fd = pfd[0];  </span><br><span class="line">        epoll_ctl(efd, EPOLL_CTL_ADD, pfd[0], &amp;event);  </span><br><span class="line">  </span><br><span class="line">        while (1) &#123;  </span><br><span class="line">            res = epoll_wait(efd, resevent, 10, -1);  </span><br><span class="line">            printf(&quot;res %d\n&quot;, res);  </span><br><span class="line">            if (resevent[0].data.fd == pfd[0]) &#123;  </span><br><span class="line">                len = read(pfd[0], buf, MAXLINE/2);  </span><br><span class="line">                write(STDOUT_FILENO, buf, len);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        close(pfd[0]);  </span><br><span class="line">        close(efd);  </span><br><span class="line">  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        perror(&quot;fork&quot;);  </span><br><span class="line">        exit(-1);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>简单理解就是，水平触发就是有数据就触发，边沿触发是有新数据进来才触发。</p>
<h2 id="网络中ET和LT模式"><a href="#网络中ET和LT模式" class="headerlink" title="网络中ET和LT模式"></a>网络中ET和LT模式</h2><p>server代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;netinet/in.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">#include &lt;signal.h&gt;  </span><br><span class="line">#include &lt;sys/wait.h&gt;  </span><br><span class="line">#include &lt;sys/types.h&gt;  </span><br><span class="line">#include &lt;sys/epoll.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">  </span><br><span class="line">#define MAXLINE 10  </span><br><span class="line">#define SERV_PORT 9000  </span><br><span class="line">  </span><br><span class="line">int main(void)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct sockaddr_in servaddr, cliaddr;  </span><br><span class="line">    socklen_t cliaddr_len;  </span><br><span class="line">    int listenfd, connfd;  </span><br><span class="line">    char buf[MAXLINE];  </span><br><span class="line">    char str[INET_ADDRSTRLEN];  </span><br><span class="line">    int efd;  </span><br><span class="line">  </span><br><span class="line">    listenfd = socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">  </span><br><span class="line">    bzero(&amp;servaddr, sizeof(servaddr));  </span><br><span class="line">    servaddr.sin_family = AF_INET;  </span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);  </span><br><span class="line">  </span><br><span class="line">    bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));  </span><br><span class="line">  </span><br><span class="line">    listen(listenfd, 20);  </span><br><span class="line">  </span><br><span class="line">    struct epoll_event event;  </span><br><span class="line">    struct epoll_event resevent[10];  </span><br><span class="line">    int res, len;  </span><br><span class="line">  </span><br><span class="line">    efd = epoll_create(10);  </span><br><span class="line">    event.events = EPOLLIN | EPOLLET;     /* ET 边沿触发 */  </span><br><span class="line">    //event.events = EPOLLIN;                 /* 默认 LT 水平触发 */  </span><br><span class="line">  </span><br><span class="line">    printf(&quot;Accepting connections ...\n&quot;);  </span><br><span class="line">  </span><br><span class="line">    cliaddr_len = sizeof(cliaddr);  </span><br><span class="line">    connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);  </span><br><span class="line">    printf(&quot;received from %s at PORT %d\n&quot;,  </span><br><span class="line">            inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, sizeof(str)),  </span><br><span class="line">            ntohs(cliaddr.sin_port));  </span><br><span class="line">  </span><br><span class="line">    event.data.fd = connfd;  </span><br><span class="line">    epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &amp;event);  </span><br><span class="line">  </span><br><span class="line">    while (1) &#123;  </span><br><span class="line">        res = epoll_wait(efd, resevent, 10, -1);  </span><br><span class="line">  </span><br><span class="line">        printf(&quot;res %d\n&quot;, res);  </span><br><span class="line">        if (resevent[0].data.fd == connfd) &#123;  </span><br><span class="line">            len = read(connfd, buf, MAXLINE/2);         //readn(500)     </span><br><span class="line">            write(STDOUT_FILENO, buf, len);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>client代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">#include &lt;netinet/in.h&gt;  </span><br><span class="line">  </span><br><span class="line">#define MAXLINE 10  </span><br><span class="line">#define SERV_PORT 9000  </span><br><span class="line">  </span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">    struct sockaddr_in servaddr;  </span><br><span class="line">    char buf[MAXLINE];  </span><br><span class="line">    int sockfd, i;  </span><br><span class="line">    char ch = &#x27;a&#x27;;  </span><br><span class="line">  </span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">  </span><br><span class="line">    bzero(&amp;servaddr, sizeof(servaddr));  </span><br><span class="line">    servaddr.sin_family = AF_INET;  </span><br><span class="line">    inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;servaddr.sin_addr);  </span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);  </span><br><span class="line">  </span><br><span class="line">    connect(sockfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));  </span><br><span class="line">  </span><br><span class="line">    while (1) &#123;  </span><br><span class="line">        //aaaa\n  </span><br><span class="line">        for (i = 0; i &lt; MAXLINE/2; i++)  </span><br><span class="line">            buf[i] = ch;  </span><br><span class="line">        buf[i-1] = &#x27;\n&#x27;;  </span><br><span class="line">        ch++;  </span><br><span class="line">        //bbbb\n  </span><br><span class="line">        for (; i &lt; MAXLINE; i++)  </span><br><span class="line">            buf[i] = ch;  </span><br><span class="line">        buf[i-1] = &#x27;\n&#x27;;  </span><br><span class="line">        ch++;  </span><br><span class="line">        //aaaa\nbbbb\n  </span><br><span class="line">        write(sockfd, buf, sizeof(buf));  </span><br><span class="line">        sleep(5);  </span><br><span class="line">    &#125;  </span><br><span class="line">    close(sockfd);  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行后，每过5秒钟服务器才输出一组字符，这是就是边沿触发的效果</p>
<p>更改服务器为水平触发模式，运行程序，运行后，每5秒输出两组字符串，这是因为只写入了两组，这个模式的服务器，缓冲区有多少读多少。</p>
<h3 id="epoll的ET非阻塞模式"><a href="#epoll的ET非阻塞模式" class="headerlink" title="epoll的ET非阻塞模式"></a>epoll的ET非阻塞模式</h3><p>readn调用的阻塞，比如设定读500个字符，但是只读到498，完事儿阻塞了，等另剩下的2个字符，然而在server代码里，一旦read变为readn阻塞了，它就不会被唤醒了，因为epoll_wait因为readn的阻塞不会循环执行，读不到新数据。有点死锁的意思，差俩字符所以阻塞，因为阻塞，读不到新字符。</p>
<p>LT(level triggered)：LT是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的select&#x2F;poll都是这种模型的代表。</p>
<p>ET(edge-triggered)：ET是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知。请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once).</p>
<p>用fcntl设置阻塞</p>
<p>非阻塞epoll的服务器代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;netinet/in.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">#include &lt;sys/wait.h&gt;  </span><br><span class="line">#include &lt;sys/types.h&gt;  </span><br><span class="line">#include &lt;sys/epoll.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;fcntl.h&gt;  </span><br><span class="line">  </span><br><span class="line">#define MAXLINE 10  </span><br><span class="line">#define SERV_PORT 8000  </span><br><span class="line">  </span><br><span class="line">int main(void)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct sockaddr_in servaddr, cliaddr;  </span><br><span class="line">    socklen_t cliaddr_len;  </span><br><span class="line">    int listenfd, connfd;  </span><br><span class="line">    char buf[MAXLINE];  </span><br><span class="line">    char str[INET_ADDRSTRLEN];  </span><br><span class="line">    int efd, flag;  </span><br><span class="line">  </span><br><span class="line">    listenfd = socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">  </span><br><span class="line">    bzero(&amp;servaddr, sizeof(servaddr));  </span><br><span class="line">    servaddr.sin_family = AF_INET;  </span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);  </span><br><span class="line">  </span><br><span class="line">    bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));  </span><br><span class="line">  </span><br><span class="line">    listen(listenfd, 20);  </span><br><span class="line">  </span><br><span class="line">    ///////////////////////////////////////////////////////////////////////  </span><br><span class="line">    struct epoll_event event;  </span><br><span class="line">    struct epoll_event res_event[10];  </span><br><span class="line">    int res, len;  </span><br><span class="line">  </span><br><span class="line">    efd = epoll_create(10);  </span><br><span class="line">  </span><br><span class="line">    event.events = EPOLLIN | EPOLLET;     /* ET 边沿触发，默认是水平触发 */  </span><br><span class="line">  </span><br><span class="line">    //event.events = EPOLLIN;  </span><br><span class="line">    printf(&quot;Accepting connections ...\n&quot;);  </span><br><span class="line">    cliaddr_len = sizeof(cliaddr);  </span><br><span class="line">    connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);  </span><br><span class="line">    printf(&quot;received from %s at PORT %d\n&quot;,  </span><br><span class="line">            inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, sizeof(str)),  </span><br><span class="line">            ntohs(cliaddr.sin_port));  </span><br><span class="line">  </span><br><span class="line">    flag = fcntl(connfd, F_GETFL);          /* 修改connfd为非阻塞读 */  </span><br><span class="line">    flag |= O_NONBLOCK;  </span><br><span class="line">    fcntl(connfd, F_SETFL, flag);  </span><br><span class="line">  </span><br><span class="line">    event.data.fd = connfd;  </span><br><span class="line">    epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &amp;event);      //将connfd加入监听红黑树  </span><br><span class="line">    while (1) &#123;  </span><br><span class="line">        printf(&quot;epoll_wait begin\n&quot;);  </span><br><span class="line">        res = epoll_wait(efd, res_event, 10, -1);        //最多10个, 阻塞监听  </span><br><span class="line">        printf(&quot;epoll_wait end res %d\n&quot;, res);  </span><br><span class="line">  </span><br><span class="line">        if (res_event[0].data.fd == connfd) &#123;  </span><br><span class="line">            while ((len = read(connfd, buf, MAXLINE/2)) &gt;0 )    //非阻塞读, 轮询  </span><br><span class="line">                write(STDOUT_FILENO, buf, len);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其实就是多了这几行：</p>
<pre><code>flag = fcntl(connfd, F_GETFL);          /* 修改connfd为非阻塞读 */  
flag |= O_NONBLOCK;  
fcntl(connfd, F_SETFL, flag);  
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">结论：</span><br><span class="line">		epoll 的 ET模式， 高效模式，但是只支持 非阻塞模式。 --- 忙轮询。</span><br><span class="line"></span><br><span class="line">		struct epoll_event event;</span><br><span class="line"></span><br><span class="line">		event.events = EPOLLIN | EPOLLET;</span><br><span class="line">		event.data.fd = connfd;</span><br><span class="line"></span><br><span class="line">		epoll_ctl(epfd, EPOLL_CTL_ADD, connfd， &amp;event);	</span><br><span class="line"></span><br><span class="line">		int flg = fcntl(cfd, F_GETFL);	</span><br><span class="line"></span><br><span class="line">		flg |= O_NONBLOCK;</span><br><span class="line"></span><br><span class="line">		fcntl(cfd, F_SETFL, flg);</span><br><span class="line"></span><br><span class="line">	优点：</span><br><span class="line"></span><br><span class="line">		高效。突破1024文件描述符。</span><br><span class="line"></span><br><span class="line">	缺点：</span><br><span class="line">		不能跨平台。 Linux。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">后面使用epoll就用这种非阻塞的</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="epoll反应堆模型总述"><a href="#epoll反应堆模型总述" class="headerlink" title="epoll反应堆模型总述"></a>epoll反应堆模型总述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">epoll 反应堆模型：</span><br><span class="line"></span><br><span class="line">	epoll ET模式 + 非阻塞、轮询 + void *ptr。</span><br><span class="line"></span><br><span class="line">	原来：	socket、bind、listen -- epoll_create 创建监听 红黑树 --  返回 epfd -- epoll_ctl() 向树上添加一个监听fd -- while（1）--</span><br><span class="line"></span><br><span class="line">		-- epoll_wait 监听 -- 对应监听fd有事件产生 -- 返回 监听满足数组。 -- 判断返回数组元素 -- lfd满足 -- Accept -- cfd 满足 </span><br><span class="line"></span><br><span class="line">		-- read() --- 小-&gt;大 -- write回去。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">反应堆：不但要监听 cfd 的读事件、还要监听cfd的写事件。</span><br><span class="line"></span><br><span class="line">		socket、bind、listen -- epoll_create 创建监听 红黑树 --  返回 epfd -- epoll_ctl() 向树上添加一个监听fd -- while（1）--</span><br><span class="line"></span><br><span class="line">		-- epoll_wait 监听 -- 对应监听fd有事件产生 -- 返回 监听满足数组。 -- 判断返回数组元素 -- lfd满足 -- Accept -- cfd 满足 </span><br><span class="line"></span><br><span class="line">		-- read() --- 小-&gt;大 -- cfd从监听红黑树上摘下 -- EPOLLOUT -- 回调函数 -- epoll_ctl() -- EPOLL_CTL_ADD 重新放到红黑上监听写事件</span><br><span class="line"></span><br><span class="line">		-- 等待 epoll_wait 返回 -- 说明 cfd 可写 -- write回去 -- cfd从监听红黑树上摘下 -- EPOLLIN </span><br><span class="line"></span><br><span class="line">		-- epoll_ctl() -- EPOLL_CTL_ADD 重新放到红黑上监听读事件 -- epoll_wait 监听</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">反应堆的理解：加入IO转接之后，有了事件，server才去处理，这里反应堆也是这样，由于网络环境复杂，服务器处理数据之后，可能并不能直接写回去，比如遇到网络繁忙或者对方缓冲区已经满了这种情况，就不能直接写回给客户端。反应堆就是在处理数据之后，监听写事件，能写会客户端了，才去做写回操作。写回之后，再改为监听读事件。如此循环。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="epoll反应堆main逻辑"><a href="#epoll反应堆main逻辑" class="headerlink" title="epoll反应堆main逻辑"></a>epoll反应堆main逻辑</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> *epoll基于非阻塞I/O事件驱动 </span><br><span class="line"> */  </span><br><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;sys/socket.h&gt;  </span><br><span class="line">#include &lt;sys/epoll.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">#include &lt;fcntl.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;errno.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;time.h&gt;  </span><br><span class="line">  </span><br><span class="line">#define MAX_EVENTS  1024                                    //监听上限数  </span><br><span class="line">#define BUFLEN 4096  </span><br><span class="line">#define SERV_PORT   8080  </span><br><span class="line">  </span><br><span class="line">void recvdata(int fd, int events, void *arg);  </span><br><span class="line">void senddata(int fd, int events, void *arg);  </span><br><span class="line">  </span><br><span class="line">/* 描述就绪文件描述符相关信息 */  </span><br><span class="line">  </span><br><span class="line">struct myevent_s &#123;  </span><br><span class="line">    int fd;                                                 //要监听的文件描述符  </span><br><span class="line">    int events;                                             //对应的监听事件  </span><br><span class="line">    void *arg;                                              //泛型参数  </span><br><span class="line">    void (*call_back)(int fd, int events, void *arg);       //回调函数  </span><br><span class="line">    int status;                                             //是否在监听:1-&gt;在红黑树上(监听), 0-&gt;不在(不监听)  </span><br><span class="line">    char buf[BUFLEN];  </span><br><span class="line">    int len;  </span><br><span class="line">    long last_active;                                       //记录每次加入红黑树 g_efd 的时间值  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">int g_efd;                                                  //全局变量, 保存epoll_create返回的文件描述符  </span><br><span class="line">struct myevent_s g_events[MAX_EVENTS+1];                    //自定义结构体类型数组. +1--&gt;listen fd  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">/*将结构体 myevent_s 成员变量 初始化*/  </span><br><span class="line">  </span><br><span class="line">void eventset(struct myevent_s *ev, int fd, void (*call_back)(int, int, void *), void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    ev-&gt;fd = fd;  </span><br><span class="line">    ev-&gt;call_back = call_back;  </span><br><span class="line">    ev-&gt;events = 0;  </span><br><span class="line">    ev-&gt;arg = arg;  </span><br><span class="line">    ev-&gt;status = 0;  </span><br><span class="line">    memset(ev-&gt;buf, 0, sizeof(ev-&gt;buf));  </span><br><span class="line">    ev-&gt;len = 0;  </span><br><span class="line">    ev-&gt;last_active = time(NULL);                       //调用eventset函数的时间  </span><br><span class="line">  </span><br><span class="line">    return;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">/* 向 epoll监听的红黑树 添加一个 文件描述符 */  </span><br><span class="line">  </span><br><span class="line">//eventadd(efd, EPOLLIN, &amp;g_events[MAX_EVENTS]);  </span><br><span class="line">void eventadd(int efd, int events, struct myevent_s *ev)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct epoll_event epv = &#123;0, &#123;0&#125;&#125;;  </span><br><span class="line">    int op;  </span><br><span class="line">    epv.data.ptr = ev;  </span><br><span class="line">    epv.events = ev-&gt;events = events;       //EPOLLIN 或 EPOLLOUT  </span><br><span class="line">  </span><br><span class="line">    if (ev-&gt;status == 0) &#123;                                          //已经在红黑树 g_efd 里  </span><br><span class="line">        op = EPOLL_CTL_ADD;                 //将其加入红黑树 g_efd, 并将status置1  </span><br><span class="line">        ev-&gt;status = 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    if (epoll_ctl(efd, op, ev-&gt;fd, &amp;epv) &lt; 0)                       //实际添加/修改  </span><br><span class="line">        printf(&quot;event add failed [fd=%d], events[%d]\n&quot;, ev-&gt;fd, events);  </span><br><span class="line">    else  </span><br><span class="line">        printf(&quot;event add OK [fd=%d], op=%d, events[%0X]\n&quot;, ev-&gt;fd, op, events);  </span><br><span class="line">  </span><br><span class="line">    return ;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">/* 从epoll 监听的 红黑树中删除一个 文件描述符*/  </span><br><span class="line">  </span><br><span class="line">void eventdel(int efd, struct myevent_s *ev)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct epoll_event epv = &#123;0, &#123;0&#125;&#125;;  </span><br><span class="line">  </span><br><span class="line">    if (ev-&gt;status != 1)                                        //不在红黑树上  </span><br><span class="line">        return ;  </span><br><span class="line">  </span><br><span class="line">    //epv.data.ptr = ev;  </span><br><span class="line">    epv.data.ptr = NULL;  </span><br><span class="line">    ev-&gt;status = 0;                                             //修改状态  </span><br><span class="line">    epoll_ctl(efd, EPOLL_CTL_DEL, ev-&gt;fd, &amp;epv);                //从红黑树 efd 上将 ev-&gt;fd 摘除  </span><br><span class="line">  </span><br><span class="line">    return ;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">/*  当有文件描述符就绪, epoll返回, 调用该函数 与客户端建立链接 */  </span><br><span class="line">  </span><br><span class="line">void acceptconn(int lfd, int events, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct sockaddr_in cin;  </span><br><span class="line">    socklen_t len = sizeof(cin);  </span><br><span class="line">    int cfd, i;  </span><br><span class="line">  </span><br><span class="line">    if ((cfd = accept(lfd, (struct sockaddr *)&amp;cin, &amp;len)) == -1) &#123;  </span><br><span class="line">        if (errno != EAGAIN &amp;&amp; errno != EINTR) &#123;  </span><br><span class="line">            /* 暂时不做出错处理 */  </span><br><span class="line">        &#125;  </span><br><span class="line">        printf(&quot;%s: accept, %s\n&quot;, __func__, strerror(errno));  </span><br><span class="line">        return ;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    do &#123;  </span><br><span class="line">        for (i = 0; i &lt; MAX_EVENTS; i++)                                //从全局数组g_events中找一个空闲元素  </span><br><span class="line">            if (g_events[i].status == 0)                                //类似于select中找值为-1的元素  </span><br><span class="line">                break;                                                  //跳出 for  </span><br><span class="line">  </span><br><span class="line">        if (i == MAX_EVENTS) &#123;  </span><br><span class="line">            printf(&quot;%s: max connect limit[%d]\n&quot;, __func__, MAX_EVENTS);  </span><br><span class="line">            break;                                                      //跳出do while(0) 不执行后续代码  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        int flag = 0;  </span><br><span class="line">        if ((flag = fcntl(cfd, F_SETFL, O_NONBLOCK)) &lt; 0) &#123;             //将cfd也设置为非阻塞  </span><br><span class="line">            printf(&quot;%s: fcntl nonblocking failed, %s\n&quot;, __func__, strerror(errno));  </span><br><span class="line">            break;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        /* 给cfd设置一个 myevent_s 结构体, 回调函数 设置为 recvdata */  </span><br><span class="line">        eventset(&amp;g_events[i], cfd, recvdata, &amp;g_events[i]);     </span><br><span class="line">        eventadd(g_efd, EPOLLIN, &amp;g_events[i]);                         //将cfd添加到红黑树g_efd中,监听读事件  </span><br><span class="line">  </span><br><span class="line">    &#125; while(0);  </span><br><span class="line">  </span><br><span class="line">    printf(&quot;new connect [%s:%d][time:%ld], pos[%d]\n&quot;,   </span><br><span class="line">            inet_ntoa(cin.sin_addr), ntohs(cin.sin_port), g_events[i].last_active, i);  </span><br><span class="line">    return ;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void recvdata(int fd, int events, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct myevent_s *ev = (struct myevent_s *)arg;  </span><br><span class="line">    int len;  </span><br><span class="line">  </span><br><span class="line">    len = recv(fd, ev-&gt;buf, sizeof(ev-&gt;buf), 0);            //读文件描述符, 数据存入myevent_s成员buf中  </span><br><span class="line">  </span><br><span class="line">    eventdel(g_efd, ev);        //将该节点从红黑树上摘除  </span><br><span class="line">  </span><br><span class="line">    if (len &gt; 0) &#123;  </span><br><span class="line">  </span><br><span class="line">        ev-&gt;len = len;  </span><br><span class="line">        ev-&gt;buf[len] = &#x27;\0&#x27;;                                //手动添加字符串结束标记  </span><br><span class="line">        printf(&quot;C[%d]:%s\n&quot;, fd, ev-&gt;buf);  </span><br><span class="line">  </span><br><span class="line">        eventset(ev, fd, senddata, ev);                     //设置该 fd 对应的回调函数为 senddata  </span><br><span class="line">        eventadd(g_efd, EPOLLOUT, ev);                      //将fd加入红黑树g_efd中,监听其写事件  </span><br><span class="line">  </span><br><span class="line">    &#125; else if (len == 0) &#123;  </span><br><span class="line">        close(ev-&gt;fd);  </span><br><span class="line">        /* ev-g_events 地址相减得到偏移元素位置 */  </span><br><span class="line">        printf(&quot;[fd=%d] pos[%ld], closed\n&quot;, fd, ev-g_events);  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        close(ev-&gt;fd);  </span><br><span class="line">        printf(&quot;recv[fd=%d] error[%d]:%s\n&quot;, fd, errno, strerror(errno));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void senddata(int fd, int events, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct myevent_s *ev = (struct myevent_s *)arg;  </span><br><span class="line">    int len;  </span><br><span class="line">  </span><br><span class="line">    len = send(fd, ev-&gt;buf, ev-&gt;len, 0);                    //直接将数据 回写给客户端。未作处理  </span><br><span class="line">  </span><br><span class="line">    eventdel(g_efd, ev);                                //从红黑树g_efd中移除  </span><br><span class="line">  </span><br><span class="line">    if (len &gt; 0) &#123;  </span><br><span class="line">  </span><br><span class="line">        printf(&quot;send[fd=%d], [%d]%s\n&quot;, fd, len, ev-&gt;buf);  </span><br><span class="line">        eventset(ev, fd, recvdata, ev);                     //将该fd的 回调函数改为 recvdata  </span><br><span class="line">        eventadd(g_efd, EPOLLIN, ev);                       //从新添加到红黑树上， 设为监听读事件  </span><br><span class="line">  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        close(ev-&gt;fd);                                      //关闭链接  </span><br><span class="line">        printf(&quot;send[fd=%d] error %s\n&quot;, fd, strerror(errno));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return ;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">/*创建 socket, 初始化lfd */  </span><br><span class="line">  </span><br><span class="line">void initlistensocket(int efd, short port)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct sockaddr_in sin;  </span><br><span class="line">  </span><br><span class="line">    int lfd = socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">    fcntl(lfd, F_SETFL, O_NONBLOCK);                                            //将socket设为非阻塞  </span><br><span class="line">  </span><br><span class="line">    memset(&amp;sin, 0, sizeof(sin));                                               //bzero(&amp;sin, sizeof(sin))  </span><br><span class="line">    sin.sin_family = AF_INET;  </span><br><span class="line">    sin.sin_addr.s_addr = INADDR_ANY;  </span><br><span class="line">    sin.sin_port = htons(port);  </span><br><span class="line">  </span><br><span class="line">    bind(lfd, (struct sockaddr *)&amp;sin, sizeof(sin));  </span><br><span class="line">  </span><br><span class="line">    listen(lfd, 20);  </span><br><span class="line">  </span><br><span class="line">    /* void eventset(struct myevent_s *ev, int fd, void (*call_back)(int, int, void *), void *arg);  */  </span><br><span class="line">    eventset(&amp;g_events[MAX_EVENTS], lfd, acceptconn, &amp;g_events[MAX_EVENTS]);  </span><br><span class="line">  </span><br><span class="line">    /* void eventadd(int efd, int events, struct myevent_s *ev) */  </span><br><span class="line">    eventadd(efd, EPOLLIN, &amp;g_events[MAX_EVENTS]);  </span><br><span class="line">  </span><br><span class="line">    return ;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned short port = SERV_PORT;  </span><br><span class="line">  </span><br><span class="line">    if (argc == 2)  </span><br><span class="line">        port = atoi(argv[1]);                           //使用用户指定端口.如未指定,用默认端口,把参数 str 所指向的字符串转换为一个整数（类型为 int 型）  </span><br><span class="line">  </span><br><span class="line">    g_efd = epoll_create(MAX_EVENTS+1);                 //创建红黑树,返回给全局 g_efd   </span><br><span class="line">    if (g_efd &lt;= 0)  </span><br><span class="line">        printf(&quot;create efd in %s err %s\n&quot;, __func__, strerror(errno));  </span><br><span class="line">  </span><br><span class="line">    initlistensocket(g_efd, port);                      //初始化监听socket  </span><br><span class="line">  </span><br><span class="line">    struct epoll_event events[MAX_EVENTS+1];            //保存已经满足就绪事件的文件描述符数组   </span><br><span class="line">    printf(&quot;server running:port[%d]\n&quot;, port);  </span><br><span class="line">  </span><br><span class="line">    int checkpos = 0, i;  </span><br><span class="line">    while (1) &#123;  </span><br><span class="line">        /* 超时验证，每次测试100个链接，不测试listenfd 当客户端60秒内没有和服务器通信，则关闭此客户端链接 */  </span><br><span class="line">  </span><br><span class="line">        long now = time(NULL);                          //当前时间  </span><br><span class="line">        for (i = 0; i &lt; 100; i++, checkpos++) &#123;         //一次循环检测100个。 使用checkpos控制检测对象  </span><br><span class="line">            if (checkpos == MAX_EVENTS)  </span><br><span class="line">                checkpos = 0;  </span><br><span class="line">            if (g_events[checkpos].status != 1)         //不在红黑树 g_efd 上  </span><br><span class="line">                continue;  </span><br><span class="line">  </span><br><span class="line">            long duration = now - g_events[checkpos].last_active;       //客户端不活跃的世间  </span><br><span class="line">  //用一个last_active存储上次活跃时间，完事儿用当前时间和上次活跃时间来计算不活跃时间长度，不活跃时间超过一定阈值，就踢掉这个客户端。</span><br><span class="line">            if (duration &gt;= 60) &#123;  </span><br><span class="line">                close(g_events[checkpos].fd);                           //关闭与该客户端链接  </span><br><span class="line">                printf(&quot;[fd=%d] timeout\n&quot;, g_events[checkpos].fd);  </span><br><span class="line">                eventdel(g_efd, &amp;g_events[checkpos]);                   //将该客户端 从红黑树 g_efd移除  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        /*监听红黑树g_efd, 将满足的事件的文件描述符加至events数组中, 1秒没有事件满足, 返回 0*/  </span><br><span class="line">        int nfd = epoll_wait(g_efd, events, MAX_EVENTS+1, 1000);  </span><br><span class="line">        if (nfd &lt; 0) &#123;  </span><br><span class="line">            printf(&quot;epoll_wait error, exit\n&quot;);  </span><br><span class="line">            break;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        for (i = 0; i &lt; nfd; i++) &#123;  </span><br><span class="line">            /*使用自定义结构体myevent_s类型指针, 接收 联合体data的void *ptr成员*/  </span><br><span class="line">            struct myevent_s *ev = (struct myevent_s *)events[i].data.ptr;    </span><br><span class="line">  </span><br><span class="line">            if ((events[i].events &amp; EPOLLIN) &amp;&amp; (ev-&gt;events &amp; EPOLLIN)) &#123;           //读就绪事件  </span><br><span class="line">                ev-&gt;call_back(ev-&gt;fd, events[i].events, ev-&gt;arg);  </span><br><span class="line">                //lfd  EPOLLIN    </span><br><span class="line">            &#125;  </span><br><span class="line">            if ((events[i].events &amp; EPOLLOUT) &amp;&amp; (ev-&gt;events &amp; EPOLLOUT)) &#123;         //写就绪事件  </span><br><span class="line">                ev-&gt;call_back(ev-&gt;fd, events[i].events, ev-&gt;arg);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /* 退出前释放所有资源 */  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>main逻辑：创建套接字—》初始化连接—》超时验证—》监听—》处理读事件和写事件</p>
<p>eventset函数指定了不同事件对应的回调函数，所以虽然读写事件都用的call_back来回调，但实际上调用的是不同的函数。</p>
<p>eventset函数：</p>
<p>​    设置回调函数。  lfd –》 acceptconn()</p>
<p>​       cfd –&gt; recvdata();</p>
<p>​      cfd –&gt; senddata();</p>
<p>eventadd函数： </p>
<p>​    将一个fd， 添加到 监听红黑树。 设置监听 read事件，还是监听写事件。</p>
<p>网络编程中：   read — recv()</p>
<p>​      write — send();</p>
<hr>
<h2 id="accept返回EMFILE的处理"><a href="#accept返回EMFILE的处理" class="headerlink" title="accept返回EMFILE的处理"></a>accept返回EMFILE的处理</h2><p><img src="/Linux-%E5%A4%9A%E8%B7%AFI-O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230727221452876.png" alt="image-20230727221452876"></p>
<img src="/2023/07/12/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/Linux-%E5%A4%9A%E8%B7%AFI-O%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20230727221452876.png" class title="This is an test image">

<p>如果文件描述符不够用了</p>
<p>准备一个空闲的文件描述符。遇到这种情况，先关闭这个空闲文件，获得一个文件描述符名额;再accept (2)拿到socket连接的文件描述符;随后立刻close(2)，这样就优雅地断开了与客户端的连接;最后重新打开空闲文件，把“坑”填上，以备再次出现这种情况时使用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">肖汇林</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">82</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">肖汇林</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
