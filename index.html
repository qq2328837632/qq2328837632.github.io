<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="选择有时候比努力更重要">
<meta property="og:type" content="website">
<meta property="og:title" content="肖汇林的博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="肖汇林的博客">
<meta property="og:description" content="选择有时候比努力更重要">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="肖汇林">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>肖汇林的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖汇林的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/27/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/27/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-6/" class="post-title-link" itemprop="url">muduo库使用示例_6</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-27 19:51:30 / 修改时间：22:15:16" itemprop="dateCreated datePublished" datetime="2023-08-27T19:51:30+08:00">2023-08-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="限制服务器最大并发连接数"><a href="#限制服务器最大并发连接数" class="headerlink" title="限制服务器最大并发连接数"></a>限制服务器最大并发连接数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  int numConnected_; // should be atomic_int 当前连接数</span><br><span class="line">  const int kMaxConnections_;//允许连接的最大数目</span><br><span class="line">  </span><br><span class="line">  void EchoServer::onConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">  &#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;EchoServer - &quot; &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;</span><br><span class="line">           &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; is &quot;</span><br><span class="line">           &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);</span><br><span class="line"></span><br><span class="line">  if (conn-&gt;connected())</span><br><span class="line">  &#123;</span><br><span class="line">    ++numConnected_;//当前连接数加一</span><br><span class="line">    if (numConnected_ &gt; kMaxConnections_)</span><br><span class="line">    &#123;</span><br><span class="line">      conn-&gt;shutdown();//断开连接</span><br><span class="line">      conn-&gt;forceCloseWithDelay(3.0);  // &gt; round trip of the whole Internet.</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    --numConnected_;//当前连接数减一</span><br><span class="line">  &#125;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;numConnected = &quot; &lt;&lt; numConnected_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="用Timing-wheel（时间轮）踢掉空闲连接"><a href="#用Timing-wheel（时间轮）踢掉空闲连接" class="headerlink" title="用Timing wheel（时间轮）踢掉空闲连接"></a>用Timing wheel（时间轮）踢掉空闲连接</h1><h2 id="main-cc"><a href="#main-cc" class="headerlink" title="main.cc"></a>main.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;examples/idleconnection/echo.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line">#include &quot;muduo/net/EventLoop.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">  // testHash();</span><br><span class="line">  EventLoop loop;</span><br><span class="line">  InetAddress listenAddr(2007);</span><br><span class="line">  int idleSeconds = 10;//环形缓冲区个数分成了10</span><br><span class="line">  if (argc &gt; 1)</span><br><span class="line">  &#123;</span><br><span class="line">    idleSeconds = atoi(argv[1]);</span><br><span class="line">  &#125;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;pid = &quot; &lt;&lt; getpid() &lt;&lt; &quot;, idle seconds = &quot; &lt;&lt; idleSeconds;</span><br><span class="line">  EchoServer server(&amp;loop, listenAddr, idleSeconds);</span><br><span class="line">  server.start();</span><br><span class="line">  loop.loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="echo-h"><a href="#echo-h" class="headerlink" title="echo.h"></a>echo.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_EXAMPLES_IDLECONNECTION_ECHO_H</span><br><span class="line">#define MUDUO_EXAMPLES_IDLECONNECTION_ECHO_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/net/TcpServer.h&quot;</span><br><span class="line">//#include &lt;muduo/base/Types.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;boost/circular_buffer.hpp&gt;</span><br><span class="line"></span><br><span class="line">// RFC 862</span><br><span class="line">class EchoServer</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  EchoServer(muduo::net::EventLoop* loop,</span><br><span class="line">             const muduo::net::InetAddress&amp; listenAddr,</span><br><span class="line">             int idleSeconds);</span><br><span class="line"></span><br><span class="line">  void start();</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  void onConnection(const muduo::net::TcpConnectionPtr&amp; conn);</span><br><span class="line"></span><br><span class="line">  void onMessage(const muduo::net::TcpConnectionPtr&amp; conn,</span><br><span class="line">                 muduo::net::Buffer* buf,</span><br><span class="line">                 muduo::Timestamp time);</span><br><span class="line"></span><br><span class="line">  void onTimer();</span><br><span class="line"></span><br><span class="line">  void dumpConnectionBuckets() const;</span><br><span class="line">  //连接的弱引用</span><br><span class="line">  typedef std::weak_ptr&lt;muduo::net::TcpConnection&gt; WeakTcpConnectionPtr;</span><br><span class="line"></span><br><span class="line">  struct Entry : public muduo::copyable</span><br><span class="line">  &#123;</span><br><span class="line">    explicit Entry(const WeakTcpConnectionPtr&amp; weakConn)</span><br><span class="line">      : weakConn_(weakConn)//构造一个Entry对象的时候因为是弱引用，所以计数不会加1</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Entry()</span><br><span class="line">    &#123;</span><br><span class="line">      muduo::net::TcpConnectionPtr conn = weakConn_.lock();</span><br><span class="line">      if (conn)</span><br><span class="line">      &#123;</span><br><span class="line">        conn-&gt;shutdown();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WeakTcpConnectionPtr weakConn_;</span><br><span class="line">  &#125;;</span><br><span class="line">  typedef std::shared_ptr&lt;Entry&gt; EntryPtr;//set中的元素是一个EntryPtr</span><br><span class="line">  typedef std::weak_ptr&lt;Entry&gt; WeakEntryPtr;</span><br><span class="line">  typedef std::unordered_set&lt;EntryPtr&gt; Bucket;//环形缓冲区每个格子存放的是一个hash_set，不会自动排序，提高效率</span><br><span class="line">  typedef boost::circular_buffer&lt;Bucket&gt; WeakConnectionList;//环形缓冲区</span><br><span class="line"> </span><br><span class="line">  muduo::net::TcpServer server_;</span><br><span class="line">  WeakConnectionList connectionBuckets_;//连接队列环形缓冲区</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_EXAMPLES_IDLECONNECTION_ECHO_H</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="echo-cc"><a href="#echo-cc" class="headerlink" title="echo.cc"></a>echo.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;examples/idleconnection/echo.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line">#include &quot;muduo/net/EventLoop.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EchoServer::EchoServer(EventLoop* loop,</span><br><span class="line">                       const InetAddress&amp; listenAddr,</span><br><span class="line">                       int idleSeconds)</span><br><span class="line">  : server_(loop, listenAddr, &quot;EchoServer&quot;),</span><br><span class="line">    connectionBuckets_(idleSeconds)</span><br><span class="line">&#123;</span><br><span class="line">  server_.setConnectionCallback(</span><br><span class="line">      std::bind(&amp;EchoServer::onConnection, this, _1));</span><br><span class="line">  server_.setMessageCallback(</span><br><span class="line">      std::bind(&amp;EchoServer::onMessage, this, _1, _2, _3));</span><br><span class="line">  loop-&gt;runEvery(1.0, std::bind(&amp;EchoServer::onTimer, this));//注册一个1s的定时器</span><br><span class="line">  connectionBuckets_.resize(idleSeconds);</span><br><span class="line">  dumpConnectionBuckets();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void EchoServer::start()</span><br><span class="line">&#123;</span><br><span class="line">  server_.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void EchoServer::onConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;EchoServer - &quot; &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;</span><br><span class="line">           &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; is &quot;</span><br><span class="line">           &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);</span><br><span class="line"></span><br><span class="line">  if (conn-&gt;connected())</span><br><span class="line">  &#123;</span><br><span class="line">    EntryPtr entry(new Entry(conn));</span><br><span class="line">    //connectionBuckets_.back()返回连接队列中的最后一个Bucket</span><br><span class="line">    connectionBuckets_.back().insert(entry);//插入到队尾，这时候引用计数为2</span><br><span class="line">    dumpConnectionBuckets();//将环形缓冲区连接数打印出来</span><br><span class="line">    WeakEntryPtr weakEntry(entry);</span><br><span class="line">    conn-&gt;setContext(weakEntry);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    assert(!conn-&gt;getContext().empty());</span><br><span class="line">    WeakEntryPtr weakEntry(boost::any_cast&lt;WeakEntryPtr&gt;(conn-&gt;getContext()));</span><br><span class="line">    LOG_DEBUG &lt;&lt; &quot;Entry use_count = &quot; &lt;&lt; weakEntry.use_count();//打印一下引用计数</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void EchoServer::onMessage(const TcpConnectionPtr&amp; conn,</span><br><span class="line">                           Buffer* buf,</span><br><span class="line">                           Timestamp time)</span><br><span class="line">&#123;</span><br><span class="line">  string msg(buf-&gt;retrieveAllAsString());</span><br><span class="line">  LOG_INFO &lt;&lt; conn-&gt;name() &lt;&lt; &quot; echo &quot; &lt;&lt; msg.size()</span><br><span class="line">           &lt;&lt; &quot; bytes at &quot; &lt;&lt; time.toString();</span><br><span class="line">  conn-&gt;send(msg);</span><br><span class="line"></span><br><span class="line">  assert(!conn-&gt;getContext().empty());</span><br><span class="line">  WeakEntryPtr weakEntry(boost::any_cast&lt;WeakEntryPtr&gt;(conn-&gt;getContext()));</span><br><span class="line">  EntryPtr entry(weakEntry.lock());//lock()方法将返回一个指向该资源的有效EntryPtr</span><br><span class="line">  //如果资源已经被销毁或者WeakEntryPtr为空，则lock()方法将返回一个空的EntryPtr</span><br><span class="line">  if (entry)</span><br><span class="line">  &#123;</span><br><span class="line">    connectionBuckets_.back().insert(entry);//引用计数加1</span><br><span class="line">    dumpConnectionBuckets();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void EchoServer::onTimer()</span><br><span class="line">&#123;</span><br><span class="line">  //相当于将tail位置原有的Bucket删除了，然后增加了一个空的Bucket</span><br><span class="line">  //如果有entry对象，那引用计数可能会减为0，然后调用析构函数</span><br><span class="line">  connectionBuckets_.push_back(Bucket());</span><br><span class="line">  dumpConnectionBuckets();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void EchoServer::dumpConnectionBuckets() const</span><br><span class="line">&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;size = &quot; &lt;&lt; connectionBuckets_.size();</span><br><span class="line">  int idx = 0;</span><br><span class="line">  for (WeakConnectionList::const_iterator bucketI = connectionBuckets_.begin();</span><br><span class="line">      bucketI != connectionBuckets_.end();</span><br><span class="line">      ++bucketI, ++idx)</span><br><span class="line">  &#123;</span><br><span class="line">    const Bucket&amp; bucket = *bucketI;</span><br><span class="line">    printf(&quot;[%d] len = %zd : &quot;, idx, bucket.size());</span><br><span class="line">    for (const auto&amp; it : bucket)</span><br><span class="line">    &#123;</span><br><span class="line">      bool connectionDead = it-&gt;weakConn_.expired();</span><br><span class="line">      printf(&quot;%p(%ld)%s, &quot;, get_pointer(it), it.use_count(),</span><br><span class="line">          connectionDead ? &quot; DEAD&quot; : &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;&quot;);//在标准输出中打印一个换行符</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>connectionBuckets_</code>是一个环形缓冲区（<code>WeakConnectionList</code>），存储了多个<code>Bucket</code>对象。每个<code>Bucket</code>对象是一个无序集合（<code>unordered_set&lt;EntryPtr&gt;</code>），用于存放一组<code>EntryPtr</code>对象。</p>
<p><code>connectionBuckets_.back()</code>用于获取环形缓冲区中最后一个<code>Bucket</code>对象，即最新的一个存放连接的桶。然后，通过调用<code>insert(entry)</code>将指定的<code>entry</code>插入到这个最新的<code>Bucket</code>中。</p>
<p>这样做的目的是将一个新的连接（即<code>entry</code>）添加到连接队列的环形缓冲区中，以便后续对这些连接进行管理和处理。通过将连接分散到多个桶中，可以提高效率，因为每个桶相当于一个子集，遍历查找特定连接的时间复杂度会相对较低。</p>
<hr>
<p><code>WeakEntryPtr weakEntry(entry)</code>的作用是创建一个<code>weakEntry</code>变量，将<code>entry</code>存储在其中。<code>weakEntry</code> 是一个弱引用，它不增加指向对象的引用计数。在这里，它被用作<code>TcpConnection</code>对象的上下文（context），以便在连接关闭时访问它。</p>
<p>在<code>onConnection</code>函数中，如果新建立了一个连接（<code>conn-&gt;connected()</code>为真），那么将创建一个<code>Entry</code>对象，并将其插入到<code>connectionBuckets_</code>环形缓冲区的最后一个桶中。然后，将<code>weakEntry</code>存储在连接的上下文中，以便在连接关闭时访问它。</p>
<p>在<code>onMessage</code>函数中，通过<code>boost::any_cast</code>从连接的上下文中获取<code>weakEntry</code>对象，然后使用<code>lock()</code>方法获取一个有效的<code>EntryPtr</code>对象。如果获取成功（即<code>entry</code>不为空），则将其重新插入到<code>connectionBuckets_</code>环形缓冲区的最后一个桶中，以延长它的生命周期。这样做是为了确保在每次有活动的消息时，该连接在<code>connectionBuckets_</code>中所在的桶不会被回收。</p>
<hr>
<p>在<code>Entry</code>的析构函数中，会通过<code>weakConn_.lock()</code>方法尝试将弱引用转换为强引用，即获取一个有效的<code>TcpConnectionPtr</code>(称为<code>conn</code>)。如果<code>TcpConnection</code>对象仍然存在，则通过<code>conn-&gt;shutdown()</code>方法关闭连接。</p>
<p>这样设计的目的是，在连接关闭时自动释放与之关联的<code>Entry</code>对象，避免内存泄漏。由于<code>weakConn_</code>是一个弱引用，它不会使<code>TcpConnection</code>的引用计数增加，因此在关闭连接后，如果没有其他强引用指向该连接，<code>conn</code>将为空，<code>Entry</code>对象因此可以安全地被销毁。</p>
<hr>
<p><code>Entry</code>的析构函数会在以下情况下被调用：</p>
<ol>
<li><p>当与 <code>Entry</code> 对象关联的 <code>TcpConnection</code> 连接关闭时，析构函数会被调用。这是因为在 <code>onConnection</code> 函数中，当一个新的连接建立时，会创建一个 <code>Entry</code> 对象，并将其插入到 <code>connectionBuckets_</code> 环形缓冲区的最后一个桶中。当该连接关闭时，<code>TcpConnection</code> 对象的引用计数减为零，<code>TcpConnection</code> 的析构函数被调用，进而引发 <code>Entry</code> 对象的析构函数的调用。</p>
</li>
<li><p>当 <code>EchoServer</code> 对象销毁时，其中所有的 <code>Entry</code> 对象也会随之被销毁，其析构函数会被调用。这是因为 <code>EchoServer</code> 在内部存储了一组 <code>EntryPtr</code>，当 <code>EchoServer</code> 对象被销毁时，它管理的所有 <code>Entry</code> 对象也会被销毁。或者是 <code>EntryPtr entry</code>引用计数为0，调用析构函数。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//相当于将tail位置原有的Bucket删除了，然后增加了一个空的Bucket</span><br><span class="line">//如果有entry对象，那引用计数可能会减为0，然后调用析构函数</span><br><span class="line">connectionBuckets_.push_back(Bucket());</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/27/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-%E4%BA%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/27/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-%E4%BA%94/" class="post-title-link" itemprop="url">muduo库使用示例_五</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-27 16:03:30 / 修改时间：16:39:40" itemprop="dateCreated datePublished" datetime="2023-08-27T16:03:30+08:00">2023-08-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="测量两台机器网络延迟–RTT"><a href="#测量两台机器网络延迟–RTT" class="headerlink" title="测量两台机器网络延迟–RTT"></a>测量两台机器网络延迟–RTT</h1><p>往返时间&#x2F; round trip time&#x2F; RTT</p>
<p><strong>NTP</strong>是网络时间同步协议<br>用来同步客户端与服务端的时钟</p>
<p><img src="/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-%E4%BA%94/image-20230827160856414.png" alt="image-20230827160856414"></p>
<img src="/2023/08/27/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-%E4%BA%94/image-20230827160856414.png" class title="This is an test image">

<p>RTT&#x3D;(T4-T1)-(T3-T2)</p>
<p>T1 + RTT&#x2F;2 &#x3D; T2 + offset (offset是指客户端与服务器端的时间差)，如果客户端的时钟快了，则offset为正。offset &#x3D; T1 - T2 + RTT&#x2F;2 &#x3D; T1 - T2 +((T4-T1)-(T3-T2))&#x2F;2 &#x3D; ((T4+T1)-(T2+T3))&#x2F;2</p>
<p>设计的<strong>roundtrip</strong>示例程序中，协议有所简化：</p>
<p><img src="/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-%E4%BA%94/image-20230827161556177.png" alt="image-20230827161556177"></p>
<img src="/2023/08/27/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-%E4%BA%94/image-20230827161556177.png" class title="This is an test image">

<p>offset是指服务器端与客户端的时间差</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line">#include &quot;muduo/net/EventLoop.h&quot;</span><br><span class="line">#include &quot;muduo/net/TcpClient.h&quot;</span><br><span class="line">#include &quot;muduo/net/TcpServer.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">const size_t frameLen = 2*sizeof(int64_t);</span><br><span class="line"></span><br><span class="line">void serverConnectionCallback(const TcpConnectionPtr&amp; conn)</span><br><span class="line">&#123;</span><br><span class="line">  LOG_TRACE &lt;&lt; conn-&gt;name() &lt;&lt; &quot; &quot; &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;</span><br><span class="line">        &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; is &quot;</span><br><span class="line">        &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);</span><br><span class="line">  if (conn-&gt;connected())</span><br><span class="line">  &#123;</span><br><span class="line">    conn-&gt;setTcpNoDelay(true);//因为协议是消息一到立刻发送</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void serverMessageCallback(const TcpConnectionPtr&amp; conn,</span><br><span class="line">                           Buffer* buffer,</span><br><span class="line">                           muduo::Timestamp receiveTime)</span><br><span class="line">&#123;</span><br><span class="line">  int64_t message[2];</span><br><span class="line">  while (buffer-&gt;readableBytes() &gt;= frameLen)</span><br><span class="line">  &#123;</span><br><span class="line">    memcpy(message, buffer-&gt;peek(), frameLen);</span><br><span class="line">    buffer-&gt;retrieve(frameLen);</span><br><span class="line">    message[1] = receiveTime.microSecondsSinceEpoch();</span><br><span class="line">    conn-&gt;send(message, sizeof message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void runServer(uint16_t port)</span><br><span class="line">&#123;</span><br><span class="line">  EventLoop loop;</span><br><span class="line">  TcpServer server(&amp;loop, InetAddress(port), &quot;ClockServer&quot;);</span><br><span class="line">  server.setConnectionCallback(serverConnectionCallback);</span><br><span class="line">  server.setMessageCallback(serverMessageCallback);</span><br><span class="line">  server.start();</span><br><span class="line">  loop.loop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpConnectionPtr clientConnection;</span><br><span class="line"></span><br><span class="line">void clientConnectionCallback(const TcpConnectionPtr&amp; conn)</span><br><span class="line">&#123;</span><br><span class="line">  LOG_TRACE &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;</span><br><span class="line">        &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; is &quot;</span><br><span class="line">        &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);</span><br><span class="line">  if (conn-&gt;connected())</span><br><span class="line">  &#123;</span><br><span class="line">    clientConnection = conn;</span><br><span class="line">    conn-&gt;setTcpNoDelay(true);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    clientConnection.reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void clientMessageCallback(const TcpConnectionPtr&amp;,</span><br><span class="line">                           Buffer* buffer,</span><br><span class="line">                           muduo::Timestamp receiveTime)</span><br><span class="line">&#123;</span><br><span class="line">  int64_t message[2];</span><br><span class="line">  while (buffer-&gt;readableBytes() &gt;= frameLen)</span><br><span class="line">  &#123;</span><br><span class="line">    memcpy(message, buffer-&gt;peek(), frameLen);</span><br><span class="line">    buffer-&gt;retrieve(frameLen);</span><br><span class="line">    int64_t send = message[0];//T1</span><br><span class="line">    int64_t their = message[1];//T2</span><br><span class="line">    int64_t back = receiveTime.microSecondsSinceEpoch();//T3</span><br><span class="line">    int64_t mine = (back+send)/2;</span><br><span class="line">    LOG_INFO &lt;&lt; &quot;round trip &quot; &lt;&lt; back - send</span><br><span class="line">             &lt;&lt; &quot; clock error &quot; &lt;&lt; their - mine;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sendMyTime()</span><br><span class="line">&#123;</span><br><span class="line">  if (clientConnection)</span><br><span class="line">  &#123;</span><br><span class="line">    int64_t message[2] = &#123; 0, 0 &#125;;</span><br><span class="line">    message[0] = Timestamp::now().microSecondsSinceEpoch();</span><br><span class="line">    clientConnection-&gt;send(message, sizeof message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void runClient(const char* ip, uint16_t port)</span><br><span class="line">&#123;</span><br><span class="line">  EventLoop loop;</span><br><span class="line">  TcpClient client(&amp;loop, InetAddress(ip, port), &quot;ClockClient&quot;);</span><br><span class="line">  client.enableRetry();</span><br><span class="line">  client.setConnectionCallback(clientConnectionCallback);</span><br><span class="line">  client.setMessageCallback(clientMessageCallback);</span><br><span class="line">  client.connect();</span><br><span class="line">  loop.runEvery(0.2, sendMyTime);</span><br><span class="line">  loop.loop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">  if (argc &gt; 2)</span><br><span class="line">  &#123;</span><br><span class="line">    uint16_t port = static_cast&lt;uint16_t&gt;(atoi(argv[2]));</span><br><span class="line">    if (strcmp(argv[1], &quot;-s&quot;) == 0)</span><br><span class="line">    &#123;</span><br><span class="line">      runServer(port);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      runClient(argv[1], port);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Usage:\n%s -s port\n%s ip port\n&quot;, argv[0], argv[0]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/24/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/24/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-3/" class="post-title-link" itemprop="url">muduo库使用示例-3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-24 19:01:01" itemprop="dateCreated datePublished" datetime="2023-08-24T19:01:01+08:00">2023-08-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-27 16:02:29" itemprop="dateModified" datetime="2023-08-27T16:02:29+08:00">2023-08-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="聊天服务器"><a href="#聊天服务器" class="headerlink" title="聊天服务器"></a>聊天服务器</h1><h2 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h2><p>消息分为包头与包体，每条消息有一个4字节的头部，以网络序存放字符串的长度。包体是一个字符串，字符串也不一定以’\0’结尾。比方说有两条消息”hello”和”chenshuo”，那么打包后的字节流是:0x00,0x00,0x00,0x05,’h’,’e’,’,’l’,’l’,’o’,0x00,0x00,0x00,0x08,’c’,’h’,’e’,’n’,’s’,’h’,’u’,’o’<br>共21字节。</p>
<p>字符串不一定以’\0’结尾是因为在消息传输中，字符串的长度已经通过包头中的4字节进行了明确的指定，所以没有必要使用’\0’来表示字符串的结束。</p>
<p>在网络通信中，消息传输往往使用二进制格式，而不是以C语言风格的以’\0’结尾的字符串。通过包头中的长度信息，接收方可以准确地知道要读取的字节数，从而正确解析出字符串。</p>
<p>由于字符串的长度信息已经被明确传递并解析，没有必要依赖于’\0’作为字符串的结束标志。事实上，在一些特定的应用场景中，字符串内容本身可能会包含’\0’字符，如果字符串以’\0’结尾，则会导致字符串截断，丢失部分数据。</p>
<p>因此，在消息传输中，字符串可以是任意字节的数据序列，并不依赖于’\0’来标识结束。接收方可以根据包头中指定的长度来正确处理和解析字符串</p>
<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p><img src="/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-3/image-20230824193437339.png" alt="image-20230824193437339"></p>
<img src="/2023/08/24/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-3/image-20230824193437339.png" class title="This is an test image">

<p>LengthHeaderCodec是间接层，对消息进行编解码</p>
<h2 id="codec-h"><a href="#codec-h" class="headerlink" title="codec.h"></a>codec.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_EXAMPLES_ASIO_CHAT_CODEC_H</span><br><span class="line">#define MUDUO_EXAMPLES_ASIO_CHAT_CODEC_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line">#include &quot;muduo/net/Buffer.h&quot;</span><br><span class="line">#include &quot;muduo/net/Endian.h&quot;</span><br><span class="line">#include &quot;muduo/net/TcpConnection.h&quot;</span><br><span class="line"></span><br><span class="line">class LengthHeaderCodec : muduo::noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  typedef std::function&lt;void (const muduo::net::TcpConnectionPtr&amp;,</span><br><span class="line">                                const muduo::string&amp; message,</span><br><span class="line">                                muduo::Timestamp)&gt; StringMessageCallback;</span><br><span class="line"></span><br><span class="line">  explicit LengthHeaderCodec(const StringMessageCallback&amp; cb)</span><br><span class="line">    : messageCallback_(cb)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void onMessage(const muduo::net::TcpConnectionPtr&amp; conn,</span><br><span class="line">                 muduo::net::Buffer* buf,</span><br><span class="line">                 muduo::Timestamp receiveTime)</span><br><span class="line">  &#123;</span><br><span class="line">    //用while而不用if，因为不止一条消息</span><br><span class="line">    //粘包问题的处理，TCP是字节流，是无边界的，传输层不处理边界，所以需要在应用层处理</span><br><span class="line">    while (buf-&gt;readableBytes() &gt;= kHeaderLen) // kHeaderLen == 4</span><br><span class="line">    &#123;</span><br><span class="line">      // FIXME: use Buffer::peekInt32()</span><br><span class="line">      const void* data = buf-&gt;peek();</span><br><span class="line">      int32_t be32 = *static_cast&lt;const int32_t*&gt;(data); // SIGBUS</span><br><span class="line">      const int32_t len = muduo::net::sockets::networkToHost32(be32);</span><br><span class="line">      if (len &gt; 65536 || len &lt; 0)//64k</span><br><span class="line">      &#123;</span><br><span class="line">        LOG_ERROR &lt;&lt; &quot;Invalid length &quot; &lt;&lt; len;</span><br><span class="line">        conn-&gt;shutdown();  // FIXME: disable reading</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      else if (buf-&gt;readableBytes() &gt;= len + kHeaderLen)//达到一条完整的消息</span><br><span class="line">      &#123;</span><br><span class="line">        buf-&gt;retrieve(kHeaderLen);</span><br><span class="line">        muduo::string message(buf-&gt;peek(), len);</span><br><span class="line">        messageCallback_(conn, message, receiveTime);</span><br><span class="line">        buf-&gt;retrieve(len);</span><br><span class="line">      &#125;</span><br><span class="line">      else//未达到一条完整的消息</span><br><span class="line">      &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // FIXME: TcpConnectionPtr</span><br><span class="line">  void send(muduo::net::TcpConnection* conn,</span><br><span class="line">            const muduo::StringPiece&amp; message)</span><br><span class="line">  &#123;</span><br><span class="line">    muduo::net::Buffer buf;</span><br><span class="line">    buf.append(message.data(), message.size());</span><br><span class="line">    int32_t len = static_cast&lt;int32_t&gt;(message.size());</span><br><span class="line">    int32_t be32 = muduo::net::sockets::hostToNetwork32(len);</span><br><span class="line">    buf.prepend(&amp;be32, sizeof be32);</span><br><span class="line">    conn-&gt;send(&amp;buf);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  StringMessageCallback messageCallback_;</span><br><span class="line">  const static size_t kHeaderLen = sizeof(int32_t);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_EXAMPLES_ASIO_CHAT_CODEC_H</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="server-cc"><a href="#server-cc" class="headerlink" title="server.cc"></a>server.cc</h2><p>单线程</p>
<p>错误的消息。<br>服务端如何处理这个错误的消息呢。<br>还会带上一个应用层的校验信息的。比如说CRC32校验。<br>校验错误，这条消息就是错误的消息。</p>
<p>第二种方式:<br>服务器端应该有空闲断开功能。在一定时间没有收到客户端的消息，就断开它。</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;examples/asio/chat/codec.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line">#include &quot;muduo/base/Mutex.h&quot;</span><br><span class="line">#include &quot;muduo/net/EventLoop.h&quot;</span><br><span class="line">#include &quot;muduo/net/TcpServer.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">class ChatServer : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  ChatServer(EventLoop* loop,</span><br><span class="line">             const InetAddress&amp; listenAddr)</span><br><span class="line">  : server_(loop, listenAddr, &quot;ChatServer&quot;),</span><br><span class="line">    codec_(std::bind(&amp;ChatServer::onStringMessage, this, _1, _2, _3))</span><br><span class="line">  &#123;</span><br><span class="line">    server_.setConnectionCallback(</span><br><span class="line">        std::bind(&amp;ChatServer::onConnection, this, _1));</span><br><span class="line">    server_.setMessageCallback(</span><br><span class="line">        std::bind(&amp;LengthHeaderCodec::onMessage, &amp;codec_, _1, _2, _3));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void start()</span><br><span class="line">  &#123;</span><br><span class="line">    server_.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  void onConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_INFO &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;</span><br><span class="line">             &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; is &quot;</span><br><span class="line">             &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);</span><br><span class="line"></span><br><span class="line">    if (conn-&gt;connected())</span><br><span class="line">    &#123;</span><br><span class="line">      connections_.insert(conn);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      connections_.erase(conn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void onStringMessage(const TcpConnectionPtr&amp;,</span><br><span class="line">                       const string&amp; message,</span><br><span class="line">                       Timestamp)</span><br><span class="line">  &#123;</span><br><span class="line">    //只有一个IO线程，因而这里的connections_不需要用mutex保护</span><br><span class="line">    //转发消息给所有客户端</span><br><span class="line">    for (ConnectionList::iterator it = connections_.begin();</span><br><span class="line">        it != connections_.end();</span><br><span class="line">        ++it)</span><br><span class="line">    &#123;</span><br><span class="line">      codec_.send(get_pointer(*it), message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  typedef std::set&lt;TcpConnectionPtr&gt; ConnectionList;</span><br><span class="line">  TcpServer server_;</span><br><span class="line">  LengthHeaderCodec codec_;//消息编解码</span><br><span class="line">  ConnectionList connections_;//连接列表，遍历连接列表来转发消息</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;pid = &quot; &lt;&lt; getpid();</span><br><span class="line">  if (argc &gt; 1)</span><br><span class="line">  &#123;</span><br><span class="line">    EventLoop loop;</span><br><span class="line">    uint16_t port = static_cast&lt;uint16_t&gt;(atoi(argv[1]));</span><br><span class="line">    InetAddress serverAddr(port);</span><br><span class="line">    ChatServer server(&amp;loop, serverAddr);</span><br><span class="line">    server.start();</span><br><span class="line">    loop.loop();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Usage: %s port\n&quot;, argv[0]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="client-cc"><a href="#client-cc" class="headerlink" title="client.cc"></a>client.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;examples/asio/chat/codec.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line">#include &quot;muduo/base/Mutex.h&quot;</span><br><span class="line">#include &quot;muduo/net/EventLoopThread.h&quot;</span><br><span class="line">#include &quot;muduo/net/TcpClient.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">class ChatClient : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  ChatClient(EventLoop* loop, const InetAddress&amp; serverAddr)</span><br><span class="line">    : client_(loop, serverAddr, &quot;ChatClient&quot;),</span><br><span class="line">      codec_(std::bind(&amp;ChatClient::onStringMessage, this, _1, _2, _3))</span><br><span class="line">  &#123;</span><br><span class="line">    client_.setConnectionCallback(</span><br><span class="line">        std::bind(&amp;ChatClient::onConnection, this, _1));</span><br><span class="line">    client_.setMessageCallback(</span><br><span class="line">        std::bind(&amp;LengthHeaderCodec::onMessage, &amp;codec_, _1, _2, _3));</span><br><span class="line">    client_.enableRetry();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void connect()</span><br><span class="line">  &#123;</span><br><span class="line">    client_.connect();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void disconnect()</span><br><span class="line">  &#123;</span><br><span class="line">    client_.disconnect();</span><br><span class="line">  &#125;</span><br><span class="line">  //该函数在主线程中执行,因为connection_主线程和IO线程都要访问，所以onConnection中需要保护</span><br><span class="line">  void write(const StringPiece&amp; message)</span><br><span class="line">  &#123;</span><br><span class="line">    //nutex用来保护connection_这个shared_ptr</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    if (connection_)</span><br><span class="line">    &#123;</span><br><span class="line">      codec_.send(get_pointer(connection_), message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line"> //该函数在IO线程中执行，IO线程与主线程不在同一个线程</span><br><span class="line">  void onConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_INFO &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;</span><br><span class="line">             &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; is &quot;</span><br><span class="line">             &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);</span><br><span class="line"></span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    if (conn-&gt;connected())</span><br><span class="line">    &#123;</span><br><span class="line">      connection_ = conn;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      connection_.reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void onStringMessage(const TcpConnectionPtr&amp;,</span><br><span class="line">                       const string&amp; message,</span><br><span class="line">                       Timestamp)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;&lt;&lt;&lt; %s\n&quot;, message.c_str());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  TcpClient client_;</span><br><span class="line">  LengthHeaderCodec codec_;</span><br><span class="line">  MutexLock mutex_;</span><br><span class="line">  TcpConnectionPtr connection_ GUARDED_BY(mutex_);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;pid = &quot; &lt;&lt; getpid();</span><br><span class="line">  if (argc &gt; 2)</span><br><span class="line">  &#123;</span><br><span class="line">    EventLoopThread loopThread;</span><br><span class="line">    uint16_t port = static_cast&lt;uint16_t&gt;(atoi(argv[2]));</span><br><span class="line">    InetAddress serverAddr(argv[1], port);</span><br><span class="line"></span><br><span class="line">    ChatClient client(loopThread.startLoop(), serverAddr);</span><br><span class="line">    client.connect();</span><br><span class="line">    std::string line;</span><br><span class="line">    while (std::getline(std::cin, line))</span><br><span class="line">    &#123;</span><br><span class="line">      client.write(line);</span><br><span class="line">    &#125;</span><br><span class="line">    client.disconnect();</span><br><span class="line">    CurrentThread::sleepUsec(1000*1000);  // wait for disconnect, see ace/logging/client.cc</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Usage: %s host_ip port\n&quot;, argv[0]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="server-threaded-cc"><a href="#server-threaded-cc" class="headerlink" title="server_threaded.cc"></a>server_threaded.cc</h2><p>多线程TcpServer，并用mutex来保护共享数据mutex</p>
<p>由于mutex的存在，多线程并不能并发执行，而是串行的。</p>
<p>因而存在较高的锁竞争。效率比较低。<br>C1向服务器端发送一条消息hello,服务器通过一个IO线程转发给所有客户端，与此同时C2向服务器端发送—条消息hello2，服务器端通过另一个IO线程<br>转发给所有客户端，由于锁的在存在，这两个线程并不能并发执行，而是串行的。这个时候，客户端数目比较大，第二条消息hello2到达各个客户端的延迟也比较大。</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;examples/asio/chat/codec.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line">#include &quot;muduo/base/Mutex.h&quot;</span><br><span class="line">#include &quot;muduo/net/EventLoop.h&quot;</span><br><span class="line">#include &quot;muduo/net/TcpServer.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">class ChatServer : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  ChatServer(EventLoop* loop,</span><br><span class="line">             const InetAddress&amp; listenAddr)</span><br><span class="line">  : server_(loop, listenAddr, &quot;ChatServer&quot;),</span><br><span class="line">    codec_(std::bind(&amp;ChatServer::onStringMessage, this, _1, _2, _3))</span><br><span class="line">  &#123;</span><br><span class="line">    server_.setConnectionCallback(</span><br><span class="line">        std::bind(&amp;ChatServer::onConnection, this, _1));</span><br><span class="line">    server_.setMessageCallback(</span><br><span class="line">        std::bind(&amp;LengthHeaderCodec::onMessage, &amp;codec_, _1, _2, _3));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void setThreadNum(int numThreads)</span><br><span class="line">  &#123;</span><br><span class="line">    server_.setThreadNum(numThreads);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void start()</span><br><span class="line">  &#123;</span><br><span class="line">    server_.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  void onConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_INFO &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;</span><br><span class="line">        &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; is &quot;</span><br><span class="line">        &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);</span><br><span class="line">    //有多个IO线程，因而这里的connections_需要用mutex保护</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    if (conn-&gt;connected())</span><br><span class="line">    &#123;</span><br><span class="line">      connections_.insert(conn);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      connections_.erase(conn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void onStringMessage(const TcpConnectionPtr&amp;,</span><br><span class="line">                       const string&amp; message,</span><br><span class="line">                       Timestamp)</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    for (ConnectionList::iterator it = connections_.begin();</span><br><span class="line">        it != connections_.end();</span><br><span class="line">        ++it)</span><br><span class="line">    &#123;</span><br><span class="line">      codec_.send(get_pointer(*it), message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  typedef std::set&lt;TcpConnectionPtr&gt; ConnectionList;</span><br><span class="line">  TcpServer server_;</span><br><span class="line">  LengthHeaderCodec codec_;</span><br><span class="line">  MutexLock mutex_;</span><br><span class="line">  ConnectionList connections_ GUARDED_BY(mutex_);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;pid = &quot; &lt;&lt; getpid();</span><br><span class="line">  if (argc &gt; 1)</span><br><span class="line">  &#123;</span><br><span class="line">    EventLoop loop;</span><br><span class="line">    uint16_t port = static_cast&lt;uint16_t&gt;(atoi(argv[1]));</span><br><span class="line">    InetAddress serverAddr(port);</span><br><span class="line">    ChatServer server(&amp;loop, serverAddr);</span><br><span class="line">    if (argc &gt; 2)</span><br><span class="line">    &#123;</span><br><span class="line">      server.setThreadNum(atoi(argv[2]));</span><br><span class="line">    &#125;</span><br><span class="line">    server.start();</span><br><span class="line">    loop.loop();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Usage: %s port [thread_num]\n&quot;, argv[0]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="server-threaded-efficient-cc"><a href="#server-threaded-efficient-cc" class="headerlink" title="server_threaded_efficient.cc"></a>server_threaded_efficient.cc</h2><p>借shared_ptr实现copy-on-write的手法来降低锁竞争</p>
<ul>
<li>shared_ptr是引用计数智能指针，如果当前只有一个观察者，那么引用计数为1,可以用shared_ptr::unique()来判断</li>
<li>对于write端，如果发现引用计数为1，这时可以安全地修改对象,不必担心有人在读它。</li>
<li>对于read端，在读之前把引用计数加1，读完之后减1，这样可以保证在读的期间其引用计数大于1，可以阻止并发写。</li>
<li>比较难的是，对于write端，如果发现引用计数大于1，该如何处理，既然要更新数据，肯定要加锁，如果这时候其他线程正在读，那么不能在原来的数据上修改，得创建一个副本，在副本上修改，修改完了再替换。如果没有用户在读，那么可以直接修改。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;examples/asio/chat/codec.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line">#include &quot;muduo/base/Mutex.h&quot;</span><br><span class="line">#include &quot;muduo/net/EventLoop.h&quot;</span><br><span class="line">#include &quot;muduo/net/TcpServer.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">class ChatServer : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  ChatServer(EventLoop* loop,</span><br><span class="line">             const InetAddress&amp; listenAddr)</span><br><span class="line">  : server_(loop, listenAddr, &quot;ChatServer&quot;),</span><br><span class="line">    codec_(std::bind(&amp;ChatServer::onStringMessage, this, _1, _2, _3)),</span><br><span class="line">    connections_(new ConnectionList)</span><br><span class="line">  &#123;</span><br><span class="line">    server_.setConnectionCallback(</span><br><span class="line">        std::bind(&amp;ChatServer::onConnection, this, _1));</span><br><span class="line">    server_.setMessageCallback(</span><br><span class="line">        std::bind(&amp;LengthHeaderCodec::onMessage, &amp;codec_, _1, _2, _3));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void setThreadNum(int numThreads)</span><br><span class="line">  &#123;</span><br><span class="line">    server_.setThreadNum(numThreads);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void start()</span><br><span class="line">  &#123;</span><br><span class="line">    server_.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  void onConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_INFO &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;</span><br><span class="line">        &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; is &quot;</span><br><span class="line">        &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);</span><br><span class="line"></span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    if (!connections_.unique())//说明引用计数大于1</span><br><span class="line">    &#123;</span><br><span class="line">      //reset()函数的作用是用新的对象替换原来的对象，并更新智能指针的引用计数</span><br><span class="line">      //使用一个新的ConnectionList对象的副本替换原来的连接列表对象，并更新智能指针connections_的引用计数为1</span><br><span class="line">      connections_.reset(new ConnectionList(*connections_));</span><br><span class="line">    &#125;</span><br><span class="line">    assert(connections_.unique());</span><br><span class="line">    //在复本上修改，不会影响读者，所以读者在遍历列表的时候，不需要用mutex保护</span><br><span class="line">    if (conn-&gt;connected())</span><br><span class="line">    &#123;</span><br><span class="line">      connections_-&gt;insert(conn);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      connections_-&gt;erase(conn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  typedef std::set&lt;TcpConnectionPtr&gt; ConnectionList;</span><br><span class="line">  typedef std::shared_ptr&lt;ConnectionList&gt; ConnectionListPtr;</span><br><span class="line"></span><br><span class="line">  void onStringMessage(const TcpConnectionPtr&amp;,</span><br><span class="line">                       const string&amp; message,</span><br><span class="line">                       Timestamp)</span><br><span class="line">  &#123;</span><br><span class="line">    //引用计数加1，mutex保护的临界区大大缩短</span><br><span class="line">    //锁竞争大大减小，提高了并发</span><br><span class="line">    ConnectionListPtr connections = getConnectionList();</span><br><span class="line">    for (ConnectionList::iterator it = connections-&gt;begin();</span><br><span class="line">        it != connections-&gt;end();</span><br><span class="line">        ++it)</span><br><span class="line">    &#123;</span><br><span class="line">      //读端指的是在onStringMessage函数中遍历connections_集合中的每个连接，将消息发送给对应的连接</span><br><span class="line">      //写端指的是在不同的地方通过codec_.send函数向连接写入消息</span><br><span class="line">      codec_.send(get_pointer(*it), message);</span><br><span class="line">    &#125;</span><br><span class="line">    //这个断言不一定成立</span><br><span class="line">    //assert(!connections_.unique());</span><br><span class="line">    //当connections这个栈上的变量销毁的时候，引用计数减1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ConnectionListPtr getConnectionList()</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    return connections_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  TcpServer server_;</span><br><span class="line">  LengthHeaderCodec codec_;</span><br><span class="line">  MutexLock mutex_;</span><br><span class="line">  ConnectionListPtr connections_ GUARDED_BY(mutex_);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;pid = &quot; &lt;&lt; getpid();</span><br><span class="line">  if (argc &gt; 1)</span><br><span class="line">  &#123;</span><br><span class="line">    EventLoop loop;</span><br><span class="line">    uint16_t port = static_cast&lt;uint16_t&gt;(atoi(argv[1]));</span><br><span class="line">    InetAddress serverAddr(port);</span><br><span class="line">    ChatServer server(&amp;loop, serverAddr);</span><br><span class="line">    if (argc &gt; 2)</span><br><span class="line">    &#123;</span><br><span class="line">      server.setThreadNum(atoi(argv[2]));</span><br><span class="line">    &#125;</span><br><span class="line">    server.start();</span><br><span class="line">    loop.loop();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Usage: %s port [thread_num]\n&quot;, argv[0]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于读端（即在<code>onStringMessage</code>函数中遍历连接并发送消息），在读之前会先将引用计数加1，表示有其他线程正在访问这个对象。这样做的目的是为了在读取期间阻止其他线程对该对象进行并发写操作，保证数据的一致性和安全性。</p>
<p>而对于写端（即修改对象），只有在发现引用计数为1时，才可以安全地修改该对象。如果引用计数为1，意味着当前线程是唯一一个访问该对象的，不存在其他并发的读操作，因此可以安全地对对象进行修改，不需要担心其他线程正在读取它。</p>
<p>通过对引用计数的控制和判断，可以实现对读写操作的同步和互斥，确保在读操作期间不会发生并发写操作，避免了数据的竞争和冲突。这种方式可以提高并发性能，并保证数据的正确性。</p>
<p>在发现引用计数大于1时：</p>
<ol>
<li>使用<code>MutexLockGuard</code>对临界区进行加锁，以确保并发访问的安全性。</li>
<li>检查<code>connections_</code>的引用计数是否大于1，即通过<code>!connections_.unique()</code>判断。</li>
<li>如果引用计数大于1，说明有其他线程正在读取数据，此时需要创建一个副本，并在副本上进行修改。</li>
<li>使用<code>connections_.reset(new ConnectionList(*connections_))</code>将原始的连接列表对象替换为副本，同时更新智能指针<code>connections_</code>的引用计数为1。</li>
<li>在副本上进行修改操作，确保不会影响到正在读取数据的其他线程。</li>
<li>修改完成后，在<code>onConnection</code>函数中，根据连接的状态（连接建立或断开），更新副本并触发其他操作。</li>
</ol>
<p>这样做可以避免在读取期间对原始对象进行修改，确保数据的一致性和安全性，同时减小了锁的粒度，提高了并发性能。</p>
<p>通过<code>connections_.reset(new ConnectionList(*connections_))</code>操作，实际上是将原始的连接列表对象进行了一次拷贝，并用拷贝后的对象替换了原始对象。这样做的目的是在修改连接列表时操作副本，而保持原始对象不变，以防止其他线程正在读取该对象时的并发冲突。</p>
<h2 id="server-threaded-highperformance-cc"><a href="#server-threaded-highperformance-cc" class="headerlink" title="server_threaded_highperformance.cc"></a>server_threaded_highperformance.cc</h2><p>采用thread local变量实现多线程高效转发</p>
<p>调用 <code>LocalConnections::instance()</code> 函数获取当前线程的线程局部单例对象时，并没有特定的接收者。这个调用的目的是为了在当前线程中创建和获取一个独立的连接列表对象。</p>
<p>线程局部单例模式允许每个线程都有自己独立的实例，这个实例可以在当前线程的任何地方使用，而不需要传递给其他对象或函数。因此，<code>LocalConnections::instance()</code> 的返回值可以直接在当前线程的代码中使用并进行操作，而不需要显式地给一个特定的接收者。</p>
<p>在使用线程局部单例对象时，它的实例可以在当前线程的任何地方使用，主要通过以下两种方式来体现：</p>
<ol>
<li>在当前线程的任意位置直接调用静态成员函数或成员方法：由于线程局部单例对象是针对每个线程独立存在的，因此在当前线程的任意位置都可以直接调用该线程局部单例对象的静态成员函数或成员方法，而无需传递对象的引用或指针。</li>
<li>通过操纵符号 <code>::</code> 访问静态成员：如果线程局部单例对象的静态成员是公有的，可以使用 <code>::</code> 操纵符号直接访问静态成员。这样，在当前线程的任何位置都可以通过线程局部单例类名称和静态成员名称来访问对应的静态成员函数或变量。</li>
</ol>
<p>这种设计模式的好处是，每个线程都有自己独立的实例，不需要显式地传递对象引用或指针给其他对象或函数。这样可以避免多线程环境下的同步和互斥问题，以及减少参数传递的复杂性。线程局部单例对象在当前线程的任何地方都可以使用，并提供了一种方便的方式来共享和访问线程相关的资源或状态。</p>
<p>如果线程局部单例对象的静态成员和静态成员函数是私有的，则无法直接使用 <code>::</code> 操纵符号来访问这些私有成员。<code>::</code> 操纵符号只能用于访问公有的静态成员。</p>
<p>对于私有的静态成员和静态成员函数，只能在线程局部单例类的内部或友元类中进行访问。如果需要在当前线程的任何地方使用这些私有成员，可以考虑提供公有的接口函数或方法来间接访问这些成员，这样其他代码就可以通过调用接口来间接操作线程局部单例对象中的私有静态成员</p>
<p>代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;examples/asio/chat/codec.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line">#include &quot;muduo/base/Mutex.h&quot;</span><br><span class="line">#include &quot;muduo/base/ThreadLocalSingleton.h&quot;</span><br><span class="line">#include &quot;muduo/net/EventLoop.h&quot;</span><br><span class="line">#include &quot;muduo/net/TcpServer.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">class ChatServer : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  ChatServer(EventLoop* loop,</span><br><span class="line">             const InetAddress&amp; listenAddr)</span><br><span class="line">  : server_(loop, listenAddr, &quot;ChatServer&quot;),</span><br><span class="line">    codec_(std::bind(&amp;ChatServer::onStringMessage, this, _1, _2, _3))</span><br><span class="line">  &#123;</span><br><span class="line">    server_.setConnectionCallback(</span><br><span class="line">        std::bind(&amp;ChatServer::onConnection, this, _1));</span><br><span class="line">    server_.setMessageCallback(</span><br><span class="line">        std::bind(&amp;LengthHeaderCodec::onMessage, &amp;codec_, _1, _2, _3));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void setThreadNum(int numThreads)</span><br><span class="line">  &#123;</span><br><span class="line">    server_.setThreadNum(numThreads);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void start()</span><br><span class="line">  &#123;</span><br><span class="line">    server_.setThreadInitCallback(std::bind(&amp;ChatServer::threadInit, this, _1));</span><br><span class="line">    server_.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  void onConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_INFO &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;</span><br><span class="line">             &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; is &quot;</span><br><span class="line">             &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);</span><br><span class="line">    //由于每一个线程都有一个LocalConnections实例，所以不需要锁</span><br><span class="line">    if (conn-&gt;connected())</span><br><span class="line">    &#123;</span><br><span class="line">      LocalConnections::instance().insert(conn);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      LocalConnections::instance().erase(conn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void onStringMessage(const TcpConnectionPtr&amp;,</span><br><span class="line">                       const string&amp; message,</span><br><span class="line">                       Timestamp)</span><br><span class="line">  &#123;</span><br><span class="line">    EventLoop::Functor f = std::bind(&amp;ChatServer::distributeMessage, this, message);</span><br><span class="line">    LOG_DEBUG;</span><br><span class="line"></span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    //转发消息给所有客户端，高效转发(多线程来转发)</span><br><span class="line">    for (std::set&lt;EventLoop*&gt;::iterator it = loops_.begin();</span><br><span class="line">        it != loops_.end();</span><br><span class="line">        ++it)</span><br><span class="line">    &#123;</span><br><span class="line">      //让对应的IO线程来执行distributeMessage</span><br><span class="line">      //distributeMessage放到IO线程队列中执行，因此，这里的mutex_锁竞争大大减小</span><br><span class="line">      //distributeMessage不受mutex_保护</span><br><span class="line">      (*it)-&gt;queueInLoop(f);</span><br><span class="line">    &#125;</span><br><span class="line">    LOG_DEBUG;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  typedef std::set&lt;TcpConnectionPtr&gt; ConnectionList;</span><br><span class="line"></span><br><span class="line">  void distributeMessage(const string&amp; message)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_DEBUG &lt;&lt; &quot;begin&quot;;</span><br><span class="line">    //connections_是thread local变量，所以不需要保护</span><br><span class="line">    for (ConnectionList::iterator it = LocalConnections::instance().begin();</span><br><span class="line">        it != LocalConnections::instance().end();</span><br><span class="line">        ++it)</span><br><span class="line">    &#123;</span><br><span class="line">      codec_.send(get_pointer(*it), message);</span><br><span class="line">    &#125;</span><br><span class="line">    LOG_DEBUG &lt;&lt; &quot;end&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void threadInit(EventLoop* loop)</span><br><span class="line">  &#123;</span><br><span class="line">    assert(LocalConnections::pointer() == NULL);</span><br><span class="line">    //线程局部单例模式允许每个线程都有自己独立的实例，这个实例可以在当前线程的任何地方使用，而不需要传递给其他对象或函数</span><br><span class="line">    LocalConnections::instance();</span><br><span class="line">    assert(LocalConnections::pointer() != NULL);</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    loops_.insert(loop);//将IO线程所对应的EventLoop插入进去</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  TcpServer server_;</span><br><span class="line">  LengthHeaderCodec codec_;</span><br><span class="line">  //线程局部单例变量，每个线程都有一个connections_实例</span><br><span class="line">  typedef ThreadLocalSingleton&lt;ConnectionList&gt; LocalConnections;</span><br><span class="line"></span><br><span class="line">  MutexLock mutex_;</span><br><span class="line">  std::set&lt;EventLoop*&gt; loops_ GUARDED_BY(mutex_);//EventLoop列表</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;pid = &quot; &lt;&lt; getpid();</span><br><span class="line">  if (argc &gt; 1)</span><br><span class="line">  &#123;</span><br><span class="line">    EventLoop loop;</span><br><span class="line">    uint16_t port = static_cast&lt;uint16_t&gt;(atoi(argv[1]));</span><br><span class="line">    InetAddress serverAddr(port);</span><br><span class="line">    ChatServer server(&amp;loop, serverAddr);</span><br><span class="line">    if (argc &gt; 2)</span><br><span class="line">    &#123;</span><br><span class="line">      server.setThreadNum(atoi(argv[2]));</span><br><span class="line">    &#125;</span><br><span class="line">    server.start();</span><br><span class="line">    loop.loop();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Usage: %s port [thread_num]\n&quot;, argv[0]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/24/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/24/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-2/" class="post-title-link" itemprop="url">muduo库使用示例_2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-24 10:32:34 / 修改时间：15:10:29" itemprop="dateCreated datePublished" datetime="2023-08-24T10:32:34+08:00">2023-08-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h1><h2 id="download-cc"><a href="#download-cc" class="headerlink" title="download.cc"></a>download.cc</h2><p>一次性把文件读入内存，一次性调用send(const string&amp;)发送完毕，这个版本满足<strong>除了</strong>“内存消耗只能并发连接数有关，跟文件大小无关”之外的健壮性要求。也就是说跟文件大小有关。</p>
<p>send函数是非阻塞的，立刻返回。不用担心数据什么时候给对等端。这个由网络库muduo负责到底。</p>
<p>fileContent比较大的时候，是没有办法一次性将数据拷到内核缓冲区的,这时候，会将剩余的数据拷贝到应用层的OutputBuffer中。<br>当内核缓冲区中的数据发送出去之后，可写事件产生，muduo就会从OutputBuffer中取出数据发送。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conn-&gt;send(fileContent);</span><br><span class="line">conn-&gt;shutdown();</span><br></pre></td></tr></table></figure>

<p>没有问题<br>shutdown，内部的实现仅仅只是关闭写入这一半。<br>shutdown -&gt;shutdownInLoop();<br>当前不处于发送数据的状态，才会调用socket_-&gt;shutdownwrite() ;</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line">#include &quot;muduo/net/EventLoop.h&quot;</span><br><span class="line">#include &quot;muduo/net/TcpServer.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">const char* g_file = NULL;</span><br><span class="line"></span><br><span class="line">// FIXME: use FileUtil::readFile()</span><br><span class="line">string readFile(const char* filename)</span><br><span class="line">&#123;</span><br><span class="line">  string content;</span><br><span class="line">  FILE* fp = ::fopen(filename, &quot;rb&quot;);</span><br><span class="line">  if (fp)</span><br><span class="line">  &#123;</span><br><span class="line">    // inefficient!!!</span><br><span class="line">    const int kBufSize = 1024*1024;</span><br><span class="line">    char iobuf[kBufSize];</span><br><span class="line">    ::setbuffer(fp, iobuf, sizeof iobuf);//用于将文件fp与名为iobuf的缓冲区相关联，并指定缓冲区的大小为kBufSize字节。</span><br><span class="line">    //通过关联缓冲区，文件读取和写入操作将会先将数据读取到缓冲区中或者从缓冲区中写出数据，而不是直接与磁盘进行交互。这样可以减少频繁的磁盘访问带来的性能损耗，提高读写效率</span><br><span class="line">    char buf[kBufSize];</span><br><span class="line">    size_t nread = 0;</span><br><span class="line">    while ( (nread = ::fread(buf, 1, sizeof buf, fp)) &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      content.append(buf, nread);</span><br><span class="line">    &#125;</span><br><span class="line">    ::fclose(fp);</span><br><span class="line">  &#125;</span><br><span class="line">  return content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void onHighWaterMark(const TcpConnectionPtr&amp; conn, size_t len)</span><br><span class="line">&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;HighWaterMark &quot; &lt;&lt; len;//打印输出当前应用缓冲区的大小是多大</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void onConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;FileServer - &quot; &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;</span><br><span class="line">           &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; is &quot;</span><br><span class="line">           &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);</span><br><span class="line">  if (conn-&gt;connected())</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_INFO &lt;&lt; &quot;FileServer - Sending file &quot; &lt;&lt; g_file</span><br><span class="line">             &lt;&lt; &quot; to &quot; &lt;&lt; conn-&gt;peerAddress().toIpPort();</span><br><span class="line">    //当应用缓冲区的outputbuffer，发送缓冲区超过了64K就回调onHighWaterMark</span><br><span class="line">    conn-&gt;setHighWaterMarkCallback(onHighWaterMark, 64*1024);</span><br><span class="line">    string fileContent = readFile(g_file);</span><br><span class="line">    conn-&gt;send(fileContent);</span><br><span class="line">    conn-&gt;shutdown();</span><br><span class="line">    LOG_INFO &lt;&lt; &quot;FileServer - done&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;pid = &quot; &lt;&lt; getpid();</span><br><span class="line">  if (argc &gt; 1)</span><br><span class="line">  &#123;</span><br><span class="line">    g_file = argv[1];//要下载的文件名称</span><br><span class="line"></span><br><span class="line">    EventLoop loop;</span><br><span class="line">    InetAddress listenAddr(2021);</span><br><span class="line">    TcpServer server(&amp;loop, listenAddr, &quot;FileServer&quot;);</span><br><span class="line">    server.setConnectionCallback(onConnection);</span><br><span class="line">    server.start();</span><br><span class="line">    loop.loop();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    fprintf(stderr, &quot;Usage: %s file_for_downloading\n&quot;, argv[0]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="download2-cc"><a href="#download2-cc" class="headerlink" title="download2.cc"></a>download2.cc</h2><p>一块一块地发送文件，减少内存使用，用到了WriteCompleteCallback，这个版本满足了上述全部健壮性要求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line">#include &quot;muduo/net/EventLoop.h&quot;</span><br><span class="line">#include &quot;muduo/net/TcpServer.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">void onHighWaterMark(const TcpConnectionPtr&amp; conn, size_t len)</span><br><span class="line">&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;HighWaterMark &quot; &lt;&lt; len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const int kBufSize = 64*1024;</span><br><span class="line">const char* g_file = NULL;</span><br><span class="line"></span><br><span class="line">void onConnection(const TcpConnectionPtr&amp; conn)//连接建立或断开时被自动调用</span><br><span class="line">&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;FileServer - &quot; &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;</span><br><span class="line">           &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; is &quot;</span><br><span class="line">           &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);</span><br><span class="line">  if (conn-&gt;connected())</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_INFO &lt;&lt; &quot;FileServer - Sending file &quot; &lt;&lt; g_file</span><br><span class="line">             &lt;&lt; &quot; to &quot; &lt;&lt; conn-&gt;peerAddress().toIpPort();</span><br><span class="line">    conn-&gt;setHighWaterMarkCallback(onHighWaterMark, kBufSize+1);</span><br><span class="line"></span><br><span class="line">    FILE* fp = ::fopen(g_file, &quot;rb&quot;);</span><br><span class="line">    if (fp)</span><br><span class="line">    &#123;</span><br><span class="line">      //将TcpConnection对象与fp绑定</span><br><span class="line">      //通过这种方法，我们就不需要额外再用一个map容器来管理对应关系.</span><br><span class="line">      conn-&gt;setContext(fp);</span><br><span class="line">      char buf[kBufSize];</span><br><span class="line">      size_t nread = ::fread(buf, 1, sizeof buf, fp);//读取一块64K的内容</span><br><span class="line">      conn-&gt;send(buf, static_cast&lt;int&gt;(nread));</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      conn-&gt;shutdown();</span><br><span class="line">      LOG_INFO &lt;&lt; &quot;FileServer - no such file&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    if (!conn-&gt;getContext().empty())</span><br><span class="line">    &#123;</span><br><span class="line">      FILE* fp = boost::any_cast&lt;FILE*&gt;(conn-&gt;getContext());</span><br><span class="line">      if (fp)</span><br><span class="line">      &#123;</span><br><span class="line">        ::fclose(fp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void onWriteComplete(const TcpConnectionPtr&amp; conn)</span><br><span class="line">&#123;</span><br><span class="line">  FILE* fp = boost::any_cast&lt;FILE*&gt;(conn-&gt;getContext());</span><br><span class="line">  char buf[kBufSize];</span><br><span class="line">  size_t nread = ::fread(buf, 1, sizeof buf, fp);</span><br><span class="line">  if (nread &gt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    conn-&gt;send(buf, static_cast&lt;int&gt;(nread));</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    ::fclose(fp);</span><br><span class="line">    fp = NULL;</span><br><span class="line">    conn-&gt;setContext(fp);</span><br><span class="line">    conn-&gt;shutdown();</span><br><span class="line">    LOG_INFO &lt;&lt; &quot;FileServer - done&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;pid = &quot; &lt;&lt; getpid();</span><br><span class="line">  if (argc &gt; 1)</span><br><span class="line">  &#123;</span><br><span class="line">    g_file = argv[1];</span><br><span class="line"></span><br><span class="line">    EventLoop loop;</span><br><span class="line">    InetAddress listenAddr(2021);</span><br><span class="line">    TcpServer server(&amp;loop, listenAddr, &quot;FileServer&quot;);</span><br><span class="line">    server.setConnectionCallback(onConnection);</span><br><span class="line">    server.setWriteCompleteCallback(onWriteComplete);</span><br><span class="line">    server.start();</span><br><span class="line">    loop.loop();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    fprintf(stderr, &quot;Usage: %s file_for_downloading\n&quot;, argv[0]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="download3-cc"><a href="#download3-cc" class="headerlink" title="download3.cc"></a>download3.cc</h2><p>同2，但是采用shared_ptr来管理FILE*，避免手动调用::fclose(3)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">const int kBufSize = 64*1024;</span><br><span class="line">const char* g_file = NULL;</span><br><span class="line">typedef std::shared_ptr&lt;FILE&gt; FilePtr;</span><br><span class="line"></span><br><span class="line">void onConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;FileServer - &quot; &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;</span><br><span class="line">           &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; is &quot;</span><br><span class="line">           &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);</span><br><span class="line">  if (conn-&gt;connected())</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_INFO &lt;&lt; &quot;FileServer - Sending file &quot; &lt;&lt; g_file</span><br><span class="line">             &lt;&lt; &quot; to &quot; &lt;&lt; conn-&gt;peerAddress().toIpPort();</span><br><span class="line">    conn-&gt;setHighWaterMarkCallback(onHighWaterMark, kBufSize+1);</span><br><span class="line"></span><br><span class="line">    FILE* fp = ::fopen(g_file, &quot;rb&quot;);</span><br><span class="line">    if (fp)</span><br><span class="line">    &#123;</span><br><span class="line">      FilePtr ctx(fp, ::fclose);//表示ctx引用计数减为0时候，要销毁fp是通过fclose()来销毁的.</span><br><span class="line">      conn-&gt;setContext(ctx);//那么生存期是一致的</span><br><span class="line">      char buf[kBufSize];</span><br><span class="line">      size_t nread = ::fread(buf, 1, sizeof buf, fp);</span><br><span class="line">      conn-&gt;send(buf, static_cast&lt;int&gt;(nread));</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      conn-&gt;shutdown();</span><br><span class="line">      LOG_INFO &lt;&lt; &quot;FileServer - no such file&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void onWriteComplete(const TcpConnectionPtr&amp; conn)</span><br><span class="line">&#123;</span><br><span class="line">  const FilePtr&amp; fp = boost::any_cast&lt;const FilePtr&amp;&gt;(conn-&gt;getContext());</span><br><span class="line">  char buf[kBufSize];</span><br><span class="line">  //get_pointer 是一个函数模板，它用于返回指向智能指针内部所管理对象的原始指针。</span><br><span class="line">  //在这里，get_pointer 函数被用来获取 FilePtr 智能指针对象 fp 内部所管理的原始 FILE* 指针</span><br><span class="line">  //这样就可以将 buf 作为参数传递给 ::fread 函数进行文件读取操作</span><br><span class="line">  size_t nread = ::fread(buf, 1, sizeof buf, get_pointer(fp));</span><br><span class="line">  if (nread &gt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    conn-&gt;send(buf, static_cast&lt;int&gt;(nread));</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    conn-&gt;shutdown();</span><br><span class="line">    LOG_INFO &lt;&lt; &quot;FileServer - done&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里销毁fp是通过销毁TcpConnection对象，这样引用计数才会减为0</p>
<h2 id="tests-x2F-Filetransfer-test-cc"><a href="#tests-x2F-Filetransfer-test-cc" class="headerlink" title="tests&#x2F;Filetransfer_test.cc"></a>tests&#x2F;Filetransfer_test.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">AtomicInt32 g_disaliveConnections;//原子操作</span><br><span class="line">int g_connections =8;//发起了8个连接</span><br><span class="line">EventLoop* g_loop;//全局变量</span><br><span class="line">class RecvFileClient : boost::noncopyable&#123;</span><br><span class="line">public:</span><br><span class="line">	RecvFileClient(EventLoop* loop, const InetAddress&amp; serverAddr, const string&amp; id)</span><br><span class="line">		:loop_(loop) ,</span><br><span class="line">		client_(loop, serverAddr,&quot;RecvFileClient&quot;)</span><br><span class="line">	&#123;</span><br><span class="line">		client_.setConnectionCallback(</span><br><span class="line">			boost::bind(&amp;RecvFileClient::onConnection,this，_1));</span><br><span class="line">		client_ .setMessageCallback(</span><br><span class="line">			boost::bind(RecvFileClient::onMessage,this,_1._2,_3));</span><br><span class="line">		string filename= &quot;RecvFileClient&quot;+id;</span><br><span class="line">		fp_=::fopen(filename.c_str(),&quot;we&quot;);</span><br><span class="line">		//&quot;we&quot; 指定了以写入模式打开一个新的空文本文件，并允许对文件进行读取和写入操作。如果文件已经存在，则会清空文件内容</span><br><span class="line">		assert(fp_);</span><br><span class="line">	&#125;</span><br><span class="line">	~RecvFileClient()</span><br><span class="line">	&#123;</span><br><span class="line">		::fclose(fp_);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	void connect()</span><br><span class="line">	&#123;</span><br><span class="line">		client_.connect();</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">void onConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_TRACE &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;</span><br><span class="line">        &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; is &quot;</span><br><span class="line">        &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);</span><br><span class="line">    if(conn-&gt;connected())&#123;</span><br><span class="line">    	connection_=conn;</span><br><span class="line">    	if(g_aliveConnections.incrementAndGet()== g_connections)</span><br><span class="line">    		LOG_INFO&lt;&lt;&quot;all connected&quot;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">    	connection_.reset();</span><br><span class="line">		if ((g_aliveConnections.incrementAndGet()==g_connections)</span><br><span class="line">		&#123;</span><br><span class="line">			LOG INFO &lt;&lt;&quot;all disconnected&quot;;</span><br><span class="line">			//g_loop-&gt;quit();有线程安全问题，可能loop循环退出了，但另外两个loopPool.setThreadNum(2);还没退出</span><br><span class="line">			exit(0);//整个进程结束</span><br><span class="line">		&#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void onMessage(const TcpConnectionPtr&amp; conn, Buffer* buf, Timestamp)</span><br><span class="line">  &#123;</span><br><span class="line">    fwrite(buf-&gt;peek(),1,buf-&gt;readableBytes(),fP_);//消息到达时，写入这个文件当中</span><br><span class="line">    buf-&gt;retrieveAll();</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">EventLoop* loop_;</span><br><span class="line">Tcpclient client_;</span><br><span class="line">TcpConnectionPtr connection_;</span><br><span class="line">FILE* fp_;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc,char* argv[])&#123;</span><br><span class="line">	LOG_INFO &lt;&lt; &quot;pid = &quot; &lt;&lt; getpid();</span><br><span class="line">	EventLoop loop;</span><br><span class="line">	g_loop =&amp;loop;</span><br><span class="line">	//用两个I0线程来发起大量的连接</span><br><span class="line">	EventLoopThreadPool loopPool(&amp;loop);</span><br><span class="line">	loopPool.setThreadNum(2);</span><br><span class="line">	loopPool.start();</span><br><span class="line">	boost::ptr_vector&lt;RecvFileClient&gt; clients(g_connections);</span><br><span class="line">	InetAddress serverAddr(&quot;127.0.0.1&quot;，2021);</span><br><span class="line">	for(int i =0; i &lt; g_connections;++i)&#123;</span><br><span class="line">		char buf[32];</span><br><span class="line">		snprintf( buf, sizeof buf,%d&quot;,i+1);</span><br><span class="line">		//选择了一个EventLoopThreadPool对象也就是IO线程来处理客户端相关业务</span><br><span class="line">		clients.push_back(new RecvFileClient(loopPool.getNextLoop(),serverAddr,buf));</span><br><span class="line">		clients[i].connect();</span><br><span class="line">		usleep(200);</span><br><span class="line">	&#125;</span><br><span class="line">	loop.loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个线程发起8个连接，有了8个文件</p>
<p>可以用来进行压力测试</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/22/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/22/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-1/" class="post-title-link" itemprop="url">muduo库使用示例-1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-22 20:40:33" itemprop="dateCreated datePublished" datetime="2023-08-22T20:40:33+08:00">2023-08-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-24 21:16:57" itemprop="dateModified" datetime="2023-08-24T21:16:57+08:00">2023-08-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="五个简单TCP协议"><a href="#五个简单TCP协议" class="headerlink" title="五个简单TCP协议"></a>五个简单TCP协议</h1><h2 id="discard"><a href="#discard" class="headerlink" title="discard"></a>discard</h2><ul>
<li><p>discard -丢弃所有收到的数据;</p>
<ul>
<li><p>相比echo少了回显</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void DiscardServer::onMessage(const TcpConnectionPtr&amp; conn,</span><br><span class="line">                              Buffer* buf,</span><br><span class="line">                              Timestamp time)</span><br><span class="line">&#123;</span><br><span class="line">  string msg(buf-&gt;retrieveAllAsString());</span><br><span class="line">  LOG_INFO &lt;&lt; conn-&gt;name() &lt;&lt; &quot; discards &quot; &lt;&lt; msg.size()</span><br><span class="line">           &lt;&lt; &quot; bytes received at &quot; &lt;&lt; time.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="daytime"><a href="#daytime" class="headerlink" title="daytime"></a>daytime</h2><ul>
<li><p>daytime -服务端accept连接之后，以字符串形式发送当前时间，然后主动断开连接;</p>
<ul>
<li>&#96;&#96;&#96;<br>void DaytimeServer::onConnection(const TcpConnectionPtr&amp; conn)<br>{<br>  LOG_INFO &lt;&lt; “DaytimeServer - “ &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; “ -&gt; “<br>       &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; “ is “<br>       &lt;&lt; (conn-&gt;connected() ? “UP” : “DOWN”);<br>  if (conn-&gt;connected())<br>  {<br>conn-&gt;send(Timestamp::now().toFormattedString() + “\n”);<br>conn-&gt;shutdown();&#x2F;&#x2F;发送完毕，只关闭写入这一半，主动断开连接<br>  }<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## time </span><br><span class="line"></span><br><span class="line">- time -服务端accept连接之后，以二进制形式发送当前时间(从Epoch到现在的秒数)，然后主动断开连接;我们需要一个客户程序来把收到的时间转换为字符串。</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    void TimeServer::onConnection(const muduo::net::TcpConnectionPtr&amp; conn)</span><br><span class="line">    &#123;</span><br><span class="line">      LOG_INFO &lt;&lt; &quot;TimeServer - &quot; &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;</span><br><span class="line">               &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; is &quot;</span><br><span class="line">               &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);</span><br><span class="line">      if (conn-&gt;connected())</span><br><span class="line">      &#123;</span><br><span class="line">        time_t now = ::time(NULL);</span><br><span class="line">        int32_t be32 = sockets::hostToNetwork32(static_cast&lt;int32_t&gt;(now));</span><br><span class="line">        conn-&gt;send(&amp;be32, sizeof be32);</span><br><span class="line">        conn-&gt;shutdown();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    客户程序timeclient</span><br><span class="line">    #include &quot;muduo/base/Logging.h&quot;</span><br><span class="line">    #include &quot;muduo/net/Endian.h&quot;</span><br><span class="line">    #include &quot;muduo/net/EventLoop.h&quot;</span><br><span class="line">    #include &quot;muduo/net/InetAddress.h&quot;</span><br><span class="line">    #include &quot;muduo/net/TcpClient.h&quot;</span><br><span class="line">    </span><br><span class="line">    #include &lt;utility&gt;</span><br><span class="line">    </span><br><span class="line">    #include &lt;stdio.h&gt;</span><br><span class="line">    #include &lt;unistd.h&gt;</span><br><span class="line">    </span><br><span class="line">    using namespace muduo;</span><br><span class="line">    using namespace muduo::net;</span><br><span class="line">    </span><br><span class="line">    class TimeClient : noncopyable</span><br><span class="line">    &#123;</span><br><span class="line">     public:</span><br><span class="line">      TimeClient(EventLoop* loop, const InetAddress&amp; serverAddr)</span><br><span class="line">        : loop_(loop),</span><br><span class="line">          client_(loop, serverAddr, &quot;TimeClient&quot;)</span><br><span class="line">      &#123;</span><br><span class="line">        client_.setConnectionCallback(</span><br><span class="line">            std::bind(&amp;TimeClient::onConnection, this, _1));</span><br><span class="line">        client_.setMessageCallback(</span><br><span class="line">            std::bind(&amp;TimeClient::onMessage, this, _1, _2, _3));</span><br><span class="line">        // client_.enableRetry();</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      void connect()</span><br><span class="line">      &#123;</span><br><span class="line">        client_.connect();</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">     private:</span><br><span class="line">    </span><br><span class="line">      EventLoop* loop_;</span><br><span class="line">      TcpClient client_;</span><br><span class="line">    </span><br><span class="line">      void onConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">      &#123;</span><br><span class="line">        LOG_INFO &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;</span><br><span class="line">                 &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; is &quot;</span><br><span class="line">                 &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);</span><br><span class="line">    </span><br><span class="line">        if (!conn-&gt;connected())</span><br><span class="line">        &#123;</span><br><span class="line">          loop_-&gt;quit();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      void onMessage(const TcpConnectionPtr&amp; conn, Buffer* buf, Timestamp receiveTime)</span><br><span class="line">      &#123;</span><br><span class="line">        if (buf-&gt;readableBytes() &gt;= sizeof(int32_t))</span><br><span class="line">        &#123;</span><br><span class="line">          const void* data = buf-&gt;peek();</span><br><span class="line">          //使用 *static_cast&lt;const int32_t*&gt;(data) 主要是为了将 void* 类型的指针转换为 int32_t 类型。</span><br><span class="line">          //由于 data 是一个指向 void 类型的指针，不能直接进行解引用操作。</span><br><span class="line">          //因此，我们需要先通过 static_cast 进行类型转换，将 data 转换为 int32_t* 类型的指针，</span><br><span class="line">          //然后再使用 * 运算符进行解引用操作，获取指针所指向的具体数值</span><br><span class="line">          int32_t be32 = *static_cast&lt;const int32_t*&gt;(data);</span><br><span class="line">          buf-&gt;retrieve(sizeof(int32_t));</span><br><span class="line">          time_t time = sockets::networkToHost32(be32);</span><br><span class="line">          Timestamp ts(implicit_cast&lt;uint64_t&gt;(time) * Timestamp::kMicroSecondsPerSecond);</span><br><span class="line">          LOG_INFO &lt;&lt; &quot;Server time = &quot; &lt;&lt; time &lt;&lt; &quot;, &quot; &lt;&lt; ts.toFormattedString();</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">          LOG_INFO &lt;&lt; conn-&gt;name() &lt;&lt; &quot; no enough data &quot; &lt;&lt; buf-&gt;readableBytes()</span><br><span class="line">                   &lt;&lt; &quot; at &quot; &lt;&lt; receiveTime.toFormattedString();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    int main(int argc, char* argv[])</span><br><span class="line">    &#123;</span><br><span class="line">      LOG_INFO &lt;&lt; &quot;pid = &quot; &lt;&lt; getpid();</span><br><span class="line">      if (argc &gt; 1)</span><br><span class="line">      &#123;</span><br><span class="line">        EventLoop loop;</span><br><span class="line">        InetAddress serverAddr(argv[1], 2037);</span><br><span class="line">    </span><br><span class="line">        TimeClient timeClient(&amp;loop, serverAddr);</span><br><span class="line">        timeClient.connect();</span><br><span class="line">        loop.loop();</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        printf(&quot;Usage: %s host_ip\n&quot;, argv[0]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><ul>
<li><p>echo-回显服务，把收到的数据发回客户端;</p>
<ul>
<li><p>&#96;&#96;&#96;<br>echo.h<br>#ifndef MUDUO_EXAMPLES_SIMPLE_ECHO_ECHO_H<br>#define MUDUO_EXAMPLES_SIMPLE_ECHO_ECHO_H</p>
<p>#include “muduo&#x2F;net&#x2F;TcpServer.h”</p>
<p>&#x2F;&#x2F; RFC 862<br>class EchoServer<br>{<br> public:<br>  EchoServer(muduo::net::EventLoop* loop,<br>         const muduo::net::InetAddress&amp; listenAddr);<br>  void start();  &#x2F;&#x2F; calls server_.start();</p>
<p> private:<br>  void onConnection(const muduo::net::TcpConnectionPtr&amp; conn);</p>
<p>  void onMessage(const muduo::net::TcpConnectionPtr&amp; conn,<br>             muduo::net::Buffer* buf,<br>             muduo::Timestamp time);<br>  muduo::net::TcpServer server_;<br>};</p>
<p>#endif  &#x2F;&#x2F; MUDUO_EXAMPLES_SIMPLE_ECHO_ECHO_H</p>
<p>echo.cc<br>#include “examples&#x2F;simple&#x2F;echo&#x2F;echo.h”</p>
<p>#include “muduo&#x2F;base&#x2F;Logging.h”</p>
<p>using std::placeholders::_1;<br>using std::placeholders::_2;<br>using std::placeholders::_3;</p>
<p>&#x2F;&#x2F; using namespace muduo;<br>&#x2F;&#x2F; using namespace muduo::net;</p>
<p>EchoServer::EchoServer(muduo::net::EventLoop* loop,<br>                   const muduo::net::InetAddress&amp; listenAddr)<br>  : server_(loop, listenAddr, “EchoServer”)<br>{<br>  server_.setConnectionCallback(<br>  std::bind(&amp;EchoServer::onConnection, this, <em>1));<br>  server</em>.setMessageCallback(<br>  std::bind(&amp;EchoServer::onMessage, this, _1, _2, _3));<br>}</p>
<p>void EchoServer::start()<br>{<br>  server_.start();<br>}</p>
<p>void EchoServer::onConnection(const muduo::net::TcpConnectionPtr&amp; conn)<br>{<br>  LOG_INFO &lt;&lt; “EchoServer - “ &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; “ -&gt; “<br>       &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; “ is “<br>       &lt;&lt; (conn-&gt;connected() ? “UP” : “DOWN”);<br>}</p>
<p>void EchoServer::onMessage(const muduo::net::TcpConnectionPtr&amp; conn,<br>                       muduo::net::Buffer* buf,<br>                       muduo::Timestamp time)<br>{<br>  muduo::string msg(buf-&gt;retrieveAllAsString());<br>  LOG_INFO &lt;&lt; conn-&gt;name() &lt;&lt; “ echo “ &lt;&lt; msg.size() &lt;&lt; “ bytes, “<br>       &lt;&lt; “data received at “ &lt;&lt; time.toString();<br>  conn-&gt;send(msg);&#x2F;&#x2F;回显<br>}</p>
<p>main.cc<br>#include “examples&#x2F;simple&#x2F;echo&#x2F;echo.h”</p>
<p>#include “muduo&#x2F;base&#x2F;Logging.h”<br>#include “muduo&#x2F;net&#x2F;EventLoop.h”</p>
<p>#include &lt;unistd.h&gt;</p>
<p>&#x2F;&#x2F; using namespace muduo;<br>&#x2F;&#x2F; using namespace muduo::net;</p>
<p>int main()<br>{<br>  LOG_INFO &lt;&lt; “pid &#x3D; “ &lt;&lt; getpid();<br>  muduo::net::EventLoop loop;<br>  muduo::net::InetAddress listenAddr(2007);<br>  EchoServer server(&amp;loop, listenAddr);<br>  server.start();<br>  loop.loop();<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## chargen</span><br><span class="line"></span><br><span class="line">- chargen-服务端accept连接之后，不停地发送测试数据。测试服务器吞吐量</span><br><span class="line"></span><br><span class="line">  - TCP流量调节的功能    即使服务端生成数据很快但是客户端接收或处理数据慢，所以可以自己创建客户端使接受到的数据不打印到输出</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ChargenServer::ChargenServer(EventLoop* loop,<br>                         const InetAddress&amp; listenAddr,<br>                         bool print)<br>  : server_(loop, listenAddr, “ChargenServer”),<br>transferred_(0),<br>startTime_(Timestamp::now())<br>{<br>  server_.setConnectionCallback(<br>  std::bind(&amp;ChargenServer::onConnection, this, <em>1));<br>  server</em>.setMessageCallback(<br>  std::bind(&amp;ChargenServer::onMessage, this, _1, _2, <em>3));<br>  server</em>.setWriteCompleteCallback(<br>  std::bind(&amp;ChargenServer::onWriteComplete, this, _1));<br>  if (print)<br>  {<br>&#x2F;&#x2F;每隔3秒打印一下吞吐量<br>loop-&gt;runEvery(3.0, std::bind(&amp;ChargenServer::printThroughput, this));<br>  }</p>
<p>  string line;<br>  for (int i &#x3D; 33; i &lt; 127; ++i)<br>  {<br>line.push_back(char(i));<br>  }<br>  line +&#x3D; line;</p>
<p>  for (size_t i &#x3D; 0; i &lt; 127-33; ++i)<br>  {<br>message_ +&#x3D; line.substr(i, 72) + ‘\n’;<br>  }<br>}</p>
<p>void ChargenServer::start()<br>{<br>  server_.start();<br>}</p>
<p>void ChargenServer::onConnection(const TcpConnectionPtr&amp; conn)<br>{<br>  LOG_INFO &lt;&lt; “ChargenServer - “ &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; “ -&gt; “<br>       &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; “ is “<br>       &lt;&lt; (conn-&gt;connected() ? “UP” : “DOWN”);<br>  if (conn-&gt;connected())<br>  {<br>conn-&gt;setTcpNoDelay(true);&#x2F;&#x2F;有数据立刻发送，不需要等待<br>conn-&gt;send(message_);<br>  }<br>}</p>
<p>void ChargenServer::onMessage(const TcpConnectionPtr&amp; conn,<br>                          Buffer* buf,<br>                          Timestamp time)<br>{<br>  string msg(buf-&gt;retrieveAllAsString());<br>  LOG_INFO &lt;&lt; conn-&gt;name() &lt;&lt; “ discards “ &lt;&lt; msg.size()<br>       &lt;&lt; “ bytes received at “ &lt;&lt; time.toString();<br>}</p>
<p>void ChargenServer::onWriteComplete(const TcpConnectionPtr&amp; conn)<br>{<br>  transferred_ +&#x3D; message_.size();&#x2F;&#x2F; transferred_已经发送的数据<br>  conn-&gt;send(message_);&#x2F;&#x2F;发送完又会调用onWriteComplete，相当于循环<br>}</p>
<p>void ChargenServer::printThroughput()<br>{<br>  Timestamp endTime &#x3D; Timestamp::now();<br>  double time &#x3D; timeDifference(endTime, startTime_);<br>  printf(“%4.3f MiB&#x2F;s\n”, static_cast<double>(transferred_)&#x2F;time&#x2F;1024&#x2F;1024);&#x2F;&#x2F;每秒多少兆<br>  transferred_ &#x3D; 0;<br>  startTime_ &#x3D; endTime;<br>}</double></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">网络编程关注三个半事件:</span><br><span class="line"></span><br><span class="line">- 连接建立</span><br><span class="line">- 连接断开</span><br><span class="line">- 消息到达</span><br><span class="line">- 消息发送完毕（对于低流量的服务来说，通常不需要关注该事件)</span><br><span class="line"></span><br><span class="line">提供一个XXXServer类</span><br><span class="line">在该类中包含一个Tcpserver对象,和三个半事件，就说明该类是一个TCP服务器了。</span><br><span class="line"></span><br><span class="line"># muduo库网络模型使用示例(sudoku求解服务器)</span><br><span class="line"></span><br><span class="line">## 	reactor (一个IO线程)</span><br><span class="line"></span><br><span class="line">这个IO线程既负责listenfd也负责connfd</span><br><span class="line"></span><br><span class="line">server_basic.cc</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p> void onMessage(const TcpConnectionPtr&amp; conn, Buffer* buf, Timestamp)<br>  {<br>    LOG_DEBUG &lt;&lt; conn-&gt;name();<br>    size_t len &#x3D; buf-&gt;readableBytes();<br>    while (len &gt;&#x3D; kCells + 2)&#x2F;&#x2F;9<em>9&#x3D;81+\r\n,id可能没有<br>    {<br>      const char</em> crlf &#x3D; buf-&gt;findCRLF();&#x2F;&#x2F;返回匹配的第一个位置<br>      if (crlf)<br>      {<br>        string request(buf-&gt;peek(), crlf);&#x2F;&#x2F;不包括\r\n<br>        buf-&gt;retrieveUntil(crlf + 2);&#x2F;&#x2F;将数据从buf中取回，包括\r\n<br>        len &#x3D; buf-&gt;readableBytes();<br>        if (!processRequest(conn, request))<br>        {<br>          conn-&gt;send(“Bad Request!\r\n”);<br>          conn-&gt;shutdown();<br>          break;<br>        }<br>      }<br>      else if (len &gt; 100) &#x2F;&#x2F; id + “:” + kCells + “\r\n”<br>      {<br>        conn-&gt;send(“Id too long!\r\n”);<br>        conn-&gt;shutdown();<br>        break;<br>      }<br>      else<br>      {<br>        break;<br>      }<br>    }<br>  }</p>
<p>  bool processRequest(const TcpConnectionPtr&amp; conn, const string&amp; request)<br>  {<br>    string id;<br>    string puzzle;&#x2F;&#x2F;求解的数字<br>    bool goodRequest &#x3D; true;</p>
<pre><code>string::const_iterator colon = find(request.begin(), request.end(), &#39;:&#39;);
if (colon != request.end())
&#123;
  id.assign(request.begin(), colon);
  puzzle.assign(colon+1, request.end());
&#125;
else
&#123;
  puzzle = request;
&#125;

if (puzzle.size() == implicit_cast&lt;size_t&gt;(kCells))
&#123;
  LOG_DEBUG &lt;&lt; conn-&gt;name();
  string result = solveSudoku(puzzle);//求解的函数
  if (id.empty())
  &#123;
    conn-&gt;send(result+&quot;\r\n&quot;);
  &#125;
  else
  &#123;
    conn-&gt;send(id+&quot;:&quot;+result+&quot;\r\n&quot;);
  &#125;
&#125;
else
&#123;
  goodRequest = false;
&#125;
return goodRequest;
</code></pre>
<p>  }</p>
<p>  int main(int argc, char* argv[])<br>{<br>  LOG_INFO &lt;&lt; “pid &#x3D; “ &lt;&lt; getpid() &lt;&lt; “, tid &#x3D; “ &lt;&lt; CurrentThread::tid();<br>  EventLoop loop;<br>  InetAddress listenAddr(9981);<br>  SudokuServer server(&amp;loop, listenAddr);</p>
<p>  server.start();</p>
<p>  loop.loop();<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 	multiple reactor（多个IO线程)</span><br><span class="line"></span><br><span class="line">main reactor		负责listenfdaccept</span><br><span class="line">sub reactor			负责connfd</span><br><span class="line"></span><br><span class="line">roundbin轮叫</span><br><span class="line">来一个连接，就选择下一个EventLoop，对应一个IO线程</span><br><span class="line">这样就让多个连接分配给若干个EventLoop来处理，而每个EventLoop属于一个IO线程也就意味着,多个连接分配给若干个IO线程来处理。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在构造函数添加<br>server_.setThreadNum(numThreads);&#x2F;&#x2F;IO线程池EventLoopThreadPool::setThreadNum的调用<br>&#x2F;&#x2F;调用ThreadPool::run()函数添加一个任务到线程池中</p>
<p>int main(int argc, char* argv[])<br>{<br>  LOG_INFO &lt;&lt; “pid &#x3D; “ &lt;&lt; getpid() &lt;&lt; “, tid &#x3D; “ &lt;&lt; CurrentThread::tid();<br>  int numThreads &#x3D; 0;<br>  if (argc &gt; 1)<br>  {<br>    numThreads &#x3D; atoi(argv[1]);&#x2F;&#x2F;多少个IO线程<br>  }<br>  EventLoop loop;<br>  InetAddress listenAddr(9981);<br>  SudokuServer server(&amp;loop, listenAddr, numThreads);</p>
<p>  server.start();</p>
<p>  loop.loop();<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 	one loop per thread + thread pool（多个IO线程＋计算线程池）</span><br><span class="line"></span><br><span class="line">多个IO线程处理并发的连接，因为计算时间比较久，容易使IO线程阻塞，IO线程很快就用完了，就不能处理大量的并发连接了。</span><br><span class="line"></span><br><span class="line">这个程序目前是一个线程加计算线程池，如果需要加多个IO线程，只需要添加</span><br><span class="line"></span><br><span class="line">`server_.setThreadNum(numThreads);//IO线程池EventLoopThreadPool::setThreadNum的调用`</span><br><span class="line"></span><br><span class="line">计算线程池的添加主要是</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>threadPool_.start(numThreads_);&#x2F;&#x2F;启动计算线程池<br>threadPool_.run(std::bind(&amp;solve, conn, puzzle, id));&#x2F;&#x2F;没有直接调用，而是通过线程池来运行<br>ThreadPool threadPool_;&#x2F;&#x2F;计算线程池</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">完整代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#include “examples&#x2F;sudoku&#x2F;sudoku.h”</p>
<p>#include “muduo&#x2F;base&#x2F;Atomic.h”<br>#include “muduo&#x2F;base&#x2F;Logging.h”<br>#include “muduo&#x2F;base&#x2F;Thread.h”<br>#include “muduo&#x2F;base&#x2F;ThreadPool.h”<br>#include “muduo&#x2F;net&#x2F;EventLoop.h”<br>#include “muduo&#x2F;net&#x2F;InetAddress.h”<br>#include “muduo&#x2F;net&#x2F;TcpServer.h”</p>
<p>#include <utility></utility></p>
<p>#include &lt;stdio.h&gt;<br>#include &lt;unistd.h&gt;</p>
<p>using namespace muduo;<br>using namespace muduo::net;</p>
<p>class SudokuServer<br>{<br> public:<br>  SudokuServer(EventLoop* loop, const InetAddress&amp; listenAddr, int numThreads)<br>    : server_(loop, listenAddr, “SudokuServer”),<br>      numThreads_(numThreads),<br>      startTime_(Timestamp::now())<br>  {<br>    server_.setConnectionCallback(<br>        std::bind(&amp;SudokuServer::onConnection, this, <em>1));<br>    server</em>.setMessageCallback(<br>        std::bind(&amp;SudokuServer::onMessage, this, _1, _2, _3));<br>  }</p>
<p>  void start()<br>  {<br>    LOG_INFO &lt;&lt; “starting “ &lt;&lt; numThreads_ &lt;&lt; “ threads.”;<br>    threadPool_.start(numThreads_);&#x2F;&#x2F;启动计算线程池<br>    server_.start();<br>  }</p>
<p> private:<br>  void onConnection(const TcpConnectionPtr&amp; conn)<br>  {<br>    LOG_TRACE &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; “ -&gt; “<br>        &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; “ is “<br>        &lt;&lt; (conn-&gt;connected() ? “UP” : “DOWN”);<br>  }</p>
<p>  void onMessage(const TcpConnectionPtr&amp; conn, Buffer* buf, Timestamp)<br>  {<br>    LOG_DEBUG &lt;&lt; conn-&gt;name();<br>    size_t len &#x3D; buf-&gt;readableBytes();<br>    while (len &gt;&#x3D; kCells + 2)<br>    {<br>      const char* crlf &#x3D; buf-&gt;findCRLF();<br>      if (crlf)<br>      {<br>        string request(buf-&gt;peek(), crlf);<br>        buf-&gt;retrieveUntil(crlf + 2);<br>        len &#x3D; buf-&gt;readableBytes();<br>        if (!processRequest(conn, request))<br>        {<br>          conn-&gt;send(“Bad Request!\r\n”);<br>          conn-&gt;shutdown();<br>          break;<br>        }<br>      }<br>      else if (len &gt; 100) &#x2F;&#x2F; id + “:” + kCells + “\r\n”<br>      {<br>        conn-&gt;send(“Id too long!\r\n”);<br>        conn-&gt;shutdown();<br>        break;<br>      }<br>      else<br>      {<br>        break;<br>      }<br>    }<br>  }</p>
<p>  bool processRequest(const TcpConnectionPtr&amp; conn, const string&amp; request)<br>  {<br>    string id;<br>    string puzzle;<br>    bool goodRequest &#x3D; true;</p>
<pre><code>string::const_iterator colon = find(request.begin(), request.end(), &#39;:&#39;);
if (colon != request.end())
&#123;
  id.assign(request.begin(), colon);
  puzzle.assign(colon+1, request.end());
&#125;
else
&#123;
  puzzle = request;
&#125;

if (puzzle.size() == implicit_cast&lt;size_t&gt;(kCells))
&#123;
  threadPool_.run(std::bind(&amp;solve, conn, puzzle, id));//没有直接调用，而是通过线程池来运行，将计算添加到队列
&#125;
else
&#123;
  goodRequest = false;
&#125;
return goodRequest;
</code></pre>
<p>  }</p>
<p>  static void solve(const TcpConnectionPtr&amp; conn,<br>                    const string&amp; puzzle,<br>                    const string&amp; id)<br>  {<br>    LOG_DEBUG &lt;&lt; conn-&gt;name();<br>    string result &#x3D; solveSudoku(puzzle);<br>    if (id.empty())<br>    {<br>      conn-&gt;send(result+”\r\n”);&#x2F;&#x2F;IO线程发送<br>    }<br>    else<br>    {<br>      conn-&gt;send(id+”:”+result+”\r\n”);<br>    }<br>  }</p>
<p>  TcpServer server_;<br>  ThreadPool threadPool_;&#x2F;&#x2F;计算线程池<br>  int numThreads_;<br>  Timestamp startTime_;<br>};</p>
<p>int main(int argc, char* argv[])<br>{<br>  LOG_INFO &lt;&lt; “pid &#x3D; “ &lt;&lt; getpid() &lt;&lt; “, tid &#x3D; “ &lt;&lt; CurrentThread::tid();<br>  int numThreads &#x3D; 0;<br>  if (argc &gt; 1)<br>  {<br>    numThreads &#x3D; atoi(argv[1]);&#x2F;&#x2F;计算线程池的个数<br>  }<br>  EventLoop loop;&#x2F;&#x2F;一个IO线程<br>  InetAddress listenAddr(9981);<br>  SudokuServer server(&amp;loop, listenAddr, numThreads);</p>
<p>  server.start();</p>
<p>  loop.loop();<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 包含inspect库</span><br><span class="line"></span><br><span class="line">含有通过HTTP方式为服务器提供监控接口</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#include “examples&#x2F;sudoku&#x2F;sudoku.h”</p>
<p>#include “muduo&#x2F;base&#x2F;Atomic.h”<br>#include “muduo&#x2F;base&#x2F;Logging.h”<br>#include “muduo&#x2F;base&#x2F;Thread.h”<br>#include “muduo&#x2F;base&#x2F;ThreadPool.h”<br>#include “muduo&#x2F;net&#x2F;EventLoop.h”<br>#include “muduo&#x2F;net&#x2F;EventLoopThread.h”<br>#include “muduo&#x2F;net&#x2F;InetAddress.h”<br>#include “muduo&#x2F;net&#x2F;TcpServer.h”<br>#include “muduo&#x2F;net&#x2F;inspect&#x2F;Inspector.h”</p>
<p>#include &lt;boost&#x2F;circular_buffer.hpp&gt;</p>
<p>&#x2F;&#x2F;#include &lt;stdio.h&gt;<br>&#x2F;&#x2F;#include &lt;unistd.h&gt;</p>
<p>using namespace muduo;<br>using namespace muduo::net;</p>
<p>#include “examples&#x2F;sudoku&#x2F;stat.h”</p>
<p>class SudokuServer : noncopyable<br>{<br> public:<br>  SudokuServer(EventLoop* loop,<br>               const InetAddress&amp; listenAddr,<br>               int numEventLoops,<br>               int numThreads,<br>               bool nodelay)<br>    : server_(loop, listenAddr, “SudokuServer”),<br>      threadPool_(),<br>      numThreads_(numThreads),<br>      tcpNoDelay_(nodelay),<br>      startTime_(Timestamp::now()),<br>      stat_(threadPool_),<br>      inspectThread_(),<br>      inspector_(inspectThread_.startLoop(), InetAddress(9982), “sudoku-solver”)<br>  {<br>    LOG_INFO &lt;&lt; “Use “ &lt;&lt; numEventLoops &lt;&lt; “ IO threads.”;<br>    LOG_INFO &lt;&lt; “TCP no delay “ &lt;&lt; nodelay;</p>
<pre><code>server_.setConnectionCallback(
    std::bind(&amp;SudokuServer::onConnection, this, _1));
server_.setMessageCallback(
    std::bind(&amp;SudokuServer::onMessage, this, _1, _2, _3));
server_.setThreadNum(numEventLoops);

inspector_.add(&quot;sudoku&quot;, &quot;stats&quot;, std::bind(&amp;SudokuStat::report, &amp;stat_),
               &quot;statistics of sudoku solver&quot;);
inspector_.add(&quot;sudoku&quot;, &quot;reset&quot;, std::bind(&amp;SudokuStat::reset, &amp;stat_),
               &quot;reset statistics of sudoku solver&quot;);
</code></pre>
<p>  }</p>
<p>  void start()<br>  {<br>    LOG_INFO &lt;&lt; “Starting “ &lt;&lt; numThreads_ &lt;&lt; “ computing threads.”;<br>    threadPool_.start(numThreads_);<br>    server_.start();<br>  }</p>
<p> private:<br>  void onConnection(const TcpConnectionPtr&amp; conn)<br>  {<br>    LOG_TRACE &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; “ -&gt; “<br>        &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; “ is “<br>        &lt;&lt; (conn-&gt;connected() ? “UP” : “DOWN”);<br>    if (conn-&gt;connected())<br>    {<br>      if (tcpNoDelay_)<br>        conn-&gt;setTcpNoDelay(true);<br>      conn-&gt;setHighWaterMarkCallback(<br>          std::bind(&amp;SudokuServer::highWaterMark, this, _1, _2), 5 * 1024 * 1024);<br>      bool throttle &#x3D; false;<br>      conn-&gt;setContext(throttle);<br>    }<br>  }</p>
<p>  void highWaterMark(const TcpConnectionPtr&amp; conn, size_t tosend)<br>  {<br>    LOG_WARN &lt;&lt; conn-&gt;name() &lt;&lt; “ high water mark “ &lt;&lt; tosend;<br>    if (tosend &lt; 10 * 1024 * 1024)<br>    {<br>      conn-&gt;setHighWaterMarkCallback(<br>          std::bind(&amp;SudokuServer::highWaterMark, this, _1, _2), 10 * 1024 * 1024);<br>      conn-&gt;setWriteCompleteCallback(std::bind(&amp;SudokuServer::writeComplete, this, <em>1));<br>      bool throttle &#x3D; true;<br>      conn-&gt;setContext(throttle);<br>    }<br>    else<br>    {<br>      conn-&gt;send(“Bad Request!\r\n”);<br>      conn-&gt;shutdown();  &#x2F;&#x2F; FIXME: forceClose() ?<br>      stat</em>.recordBadRequest();<br>    }<br>  }</p>
<p>  void writeComplete(const TcpConnectionPtr&amp; conn)<br>  {<br>    LOG_INFO &lt;&lt; conn-&gt;name() &lt;&lt; “ write complete”;<br>    conn-&gt;setHighWaterMarkCallback(<br>        std::bind(&amp;SudokuServer::highWaterMark, this, _1, _2), 5 * 1024 * 1024);<br>    conn-&gt;setWriteCompleteCallback(WriteCompleteCallback());<br>    bool throttle &#x3D; false;<br>    conn-&gt;setContext(throttle);<br>  }</p>
<p>  void onMessage(const TcpConnectionPtr&amp; conn, Buffer* buf, Timestamp receiveTime)<br>  {<br>    size_t len &#x3D; buf-&gt;readableBytes();<br>    while (len &gt;&#x3D; kCells + 2)<br>    {<br>      const char* crlf &#x3D; buf-&gt;findCRLF();<br>      if (crlf)<br>      {<br>        string request(buf-&gt;peek(), crlf);<br>        buf-&gt;retrieveUntil(crlf + 2);<br>        len &#x3D; buf-&gt;readableBytes();<br>        stat_.recordRequest();<br>        if (!processRequest(conn, request, receiveTime))<br>        {<br>          conn-&gt;send(“Bad Request!\r\n”);<br>          conn-&gt;shutdown();<br>          stat_.recordBadRequest();<br>          break;<br>        }<br>      }<br>      else if (len &gt; 100) &#x2F;&#x2F; id + “:” + kCells + “\r\n”<br>      {<br>        conn-&gt;send(“Id too long!\r\n”);<br>        conn-&gt;shutdown();<br>        stat_.recordBadRequest();<br>        break;<br>      }<br>      else<br>      {<br>        break;<br>      }<br>    }<br>  }</p>
<p>  struct Request<br>  {<br>    string id;<br>    string puzzle;<br>    Timestamp receiveTime;<br>  };</p>
<p>  bool processRequest(const TcpConnectionPtr&amp; conn, const string&amp; request, Timestamp receiveTime)<br>  {<br>    Request req;<br>    req.receiveTime &#x3D; receiveTime;</p>
<pre><code>string::const_iterator colon = find(request.begin(), request.end(), &#39;:&#39;);
if (colon != request.end())
&#123;
  req.id.assign(request.begin(), colon);
  req.puzzle.assign(colon+1, request.end());
&#125;
else
&#123;
  // when using thread pool, an id must be provided in the request.
  if (numThreads_ &gt; 1)
    return false;
  req.puzzle = request;
&#125;

if (req.puzzle.size() == implicit_cast&lt;size_t&gt;(kCells))
&#123;
  bool throttle = boost::any_cast&lt;bool&gt;(conn-&gt;getContext());
  if (threadPool_.queueSize() &lt; 1000 * 1000 &amp;&amp; !throttle)
  &#123;
    threadPool_.run(std::bind(&amp;SudokuServer::solve, this, conn, req));
  &#125;
  else
  &#123;
    if (req.id.empty())
    &#123;
      conn-&gt;send(&quot;ServerTooBusy\r\n&quot;);
    &#125;
    else
    &#123;
      conn-&gt;send(req.id + &quot;:ServerTooBusy\r\n&quot;);
    &#125;
    stat_.recordDroppedRequest();
  &#125;
  return true;
&#125;
return false;
</code></pre>
<p>  }</p>
<p>  void solve(const TcpConnectionPtr&amp; conn, const Request&amp; req)<br>  {<br>    LOG_DEBUG &lt;&lt; conn-&gt;name();<br>    string result &#x3D; solveSudoku(req.puzzle);<br>    if (req.id.empty())<br>    {<br>      conn-&gt;send(result + “\r\n”);<br>    }<br>    else<br>    {<br>      conn-&gt;send(req.id + “:” + result + “\r\n”);<br>    }<br>    stat_.recordResponse(Timestamp::now(), req.receiveTime, result !&#x3D; kNoSolution);<br>  }</p>
<p>  TcpServer server_;<br>  ThreadPool threadPool_;<br>  const int numThreads_;<br>  const bool tcpNoDelay_;<br>  const Timestamp startTime_;</p>
<p>  SudokuStat stat_;<br>  EventLoopThread inspectThread_;<br>  Inspector inspector_;<br>};</p>
<p>int main(int argc, char* argv[])<br>{<br>  LOG_INFO &lt;&lt; argv[0] &lt;&lt; “ [number of IO threads] [number of worker threads] [-n]”;<br>  LOG_INFO &lt;&lt; “pid &#x3D; “ &lt;&lt; getpid() &lt;&lt; “, tid &#x3D; “ &lt;&lt; CurrentThread::tid();<br>  int numEventLoops &#x3D; 0;<br>  int numThreads &#x3D; 0;<br>  bool nodelay &#x3D; false;<br>  if (argc &gt; 1)<br>  {<br>    numEventLoops &#x3D; atoi(argv[1]);<br>  }<br>  if (argc &gt; 2)<br>  {<br>    numThreads &#x3D; atoi(argv[2]);<br>  }<br>  if (argc &gt; 3 &amp;&amp; string(argv[3]) &#x3D;&#x3D; “-n”)<br>  {<br>    nodelay &#x3D; true;<br>  }</p>
<p>  EventLoop loop;<br>  InetAddress listenAddr(9981);<br>  SudokuServer server(&amp;loop, listenAddr, numEventLoops, numThreads, nodelay);</p>
<p>  server.start();</p>
<p>  loop.loop();<br>}</p>
<pre><code>
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/22/muduo-inspect%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/22/muduo-inspect%E5%BA%93/" class="post-title-link" itemprop="url">muduo_inspect库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-22 14:59:49" itemprop="dateCreated datePublished" datetime="2023-08-22T14:59:49+08:00">2023-08-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-23 17:33:22" itemprop="dateModified" datetime="2023-08-23T17:33:22+08:00">2023-08-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="muduo-inspect库"><a href="#muduo-inspect库" class="headerlink" title="muduo_inspect库"></a>muduo_inspect库</h1><h2 id="通过HTTP方式为服务器提供监控接口"><a href="#通过HTTP方式为服务器提供监控接口" class="headerlink" title="通过HTTP方式为服务器提供监控接口"></a>通过HTTP方式为服务器提供监控接口</h2><p>接受了多少个TCP连接<br>当前有多少个活动连接</p>
<p>一共响应了多少次请求<br>每次请求的平均响应时间多少毫秒</p>
<p>。。。</p>
<p>要实现这些可以模仿ProcessInspector设置回调函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class ProcessInspector : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  void registerCommands(Inspector* ins);//注册命令接口</span><br><span class="line"></span><br><span class="line">  static string overview(HttpRequest::Method, const Inspector::ArgList&amp;);</span><br><span class="line">  static string pid(HttpRequest::Method, const Inspector::ArgList&amp;);</span><br><span class="line">  static string procStatus(HttpRequest::Method, const Inspector::ArgList&amp;);</span><br><span class="line">  static string openedFiles(HttpRequest::Method, const Inspector::ArgList&amp;);</span><br><span class="line">  static string threads(HttpRequest::Method, const Inspector::ArgList&amp;);</span><br><span class="line"></span><br><span class="line">  static string username_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void ProcessInspector::registerCommands(Inspector* ins)</span><br><span class="line">&#123;</span><br><span class="line">  ins-&gt;add(&quot;proc&quot;, &quot;overview&quot;, ProcessInspector::overview, &quot;print basic overview&quot;);</span><br><span class="line">  ins-&gt;add(&quot;proc&quot;, &quot;pid&quot;, ProcessInspector::pid, &quot;print pid&quot;);</span><br><span class="line">  ins-&gt;add(&quot;proc&quot;, &quot;status&quot;, ProcessInspector::procStatus, &quot;print /proc/self/status&quot;);</span><br><span class="line">  // ins-&gt;add(&quot;proc&quot;, &quot;opened_files&quot;, ProcessInspector::openedFiles, &quot;count /proc/self/fd&quot;);</span><br><span class="line">  ins-&gt;add(&quot;proc&quot;, &quot;threads&quot;, ProcessInspector::threads, &quot;list /proc/self/task&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Inspector"><a href="#Inspector" class="headerlink" title="Inspector"></a>Inspector</h2><p>包含了一个HttpServer对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//如add(&quot;proc&quot;,&quot;pid&quot;，ProcessInspector::pid,&quot;print pid&quot;);</span><br><span class="line">  //http://192.168.48.128:12345/proc/pid这个http请求就会相应的调用ProcessInspector::pid来处理</span><br><span class="line">  /// Add a Callback for handling the special uri : /mudule/command</span><br><span class="line">  void add(const string&amp; module,//模块，命令，回调函数，帮助文本</span><br><span class="line">           const string&amp; command,</span><br><span class="line">           const Callback&amp; cb,</span><br><span class="line">           const string&amp; help);</span><br><span class="line">           private:</span><br><span class="line">  typedef std::map&lt;string, Callback&gt; CommandList;</span><br><span class="line">  typedef std::map&lt;string, string&gt; HelpList;</span><br><span class="line"></span><br><span class="line">  void start();</span><br><span class="line">  void onRequest(const HttpRequest&amp; req, HttpResponse* resp);</span><br><span class="line"></span><br><span class="line">  HttpServer server_;//因为它是一个http服务器</span><br><span class="line">  std::unique_ptr&lt;ProcessInspector&gt; processInspector_;</span><br><span class="line">  std::unique_ptr&lt;PerformanceInspector&gt; performanceInspector_;</span><br><span class="line">  std::unique_ptr&lt;SystemInspector&gt; systemInspector_;</span><br><span class="line">  MutexLock mutex_;</span><br><span class="line">  std::map&lt;string, CommandList&gt; modules_ GUARDED_BY(mutex_);//module,command,Callback</span><br><span class="line">  std::map&lt;string, HelpList&gt; helps_ GUARDED_BY(mutex_);//module,conenand,hellp</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">namespace</span><br><span class="line">&#123;</span><br><span class="line">Inspector* g_globalInspector = 0;</span><br><span class="line"></span><br><span class="line">// Looks buggy</span><br><span class="line">std::vector&lt;string&gt; split(const string&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">  std::vector&lt;string&gt; result;</span><br><span class="line">  size_t start = 0;</span><br><span class="line">  size_t pos = str.find(&#x27;/&#x27;);</span><br><span class="line">  //在使用find()函数查找子字符串时，如果未找到匹配的子字符串，find()函数将返回string::npos作为索引位置，以指示没有找到匹配</span><br><span class="line">  while (pos != string::npos)</span><br><span class="line">  &#123;</span><br><span class="line">    if (pos &gt; start)</span><br><span class="line">    &#123;</span><br><span class="line">      result.push_back(str.substr(start, pos-start));</span><br><span class="line">    &#125;</span><br><span class="line">    start = pos+1;</span><br><span class="line">    pos = str.find(&#x27;/&#x27;, start);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (start &lt; str.length())//说明最后一个字符不是&#x27;/&#x27;</span><br><span class="line">  &#123;</span><br><span class="line">    result.push_back(str.substr(start));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace</span><br><span class="line"></span><br><span class="line">Inspector::Inspector(EventLoop* loop,</span><br><span class="line">                     const InetAddress&amp; httpAddr,</span><br><span class="line">                     const string&amp; name)</span><br><span class="line">    : server_(loop, httpAddr, &quot;Inspector:&quot;+name),</span><br><span class="line">      processInspector_(new ProcessInspector),</span><br><span class="line">      systemInspector_(new SystemInspector)</span><br><span class="line">&#123;</span><br><span class="line">  assert(CurrentThread::isMainThread());</span><br><span class="line">  assert(g_globalInspector == 0);</span><br><span class="line">  g_globalInspector = this;</span><br><span class="line">  server_.setHttpCallback(std::bind(&amp;Inspector::onRequest, this, _1, _2));</span><br><span class="line">  processInspector_-&gt;registerCommands(this);</span><br><span class="line"></span><br><span class="line">  systemInspector_-&gt;registerCommands(this);</span><br><span class="line">#ifdef HAVE_TCMALLOC</span><br><span class="line">  performanceInspector_.reset(new PerformanceInspector);</span><br><span class="line">  performanceInspector_-&gt;registerCommands(this);</span><br><span class="line">#endif</span><br><span class="line">  //这样子做法是为了防止竞态问题</span><br><span class="line">  //如果直接调用start,(当前线程不是IO线程，是主线程）那么有可能，当前构造函数还没返回，</span><br><span class="line">  //httpServer所在的IO线程可能已经收到了http客户端的请求了(因为这时候HttpServer已启动)，那么就会回调</span><br><span class="line">  //Inspector::onRequest，而这时候构造函数还没返回，也就是说对象还没完全构造好</span><br><span class="line">  loop-&gt;runAfter(0, std::bind(&amp;Inspector::start, this)); // little race condition，仍然有点问题，可以将时间改长一点</span><br><span class="line">&#125;</span><br><span class="line">void Inspector::add(const string&amp; module,</span><br><span class="line">                    const string&amp; command,</span><br><span class="line">                    const Callback&amp; cb,</span><br><span class="line">                    const string&amp; help)</span><br><span class="line">&#123;</span><br><span class="line">  MutexLockGuard lock(mutex_);</span><br><span class="line">  modules_[module][command] = cb;</span><br><span class="line">  helps_[module][command] = help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Inspector::start()</span><br><span class="line">&#123;</span><br><span class="line">  server_.start();</span><br><span class="line">&#125;</span><br><span class="line">//一旦http请求就会回调这个函数</span><br><span class="line">void Inspector::onRequest(const HttpRequest&amp; req, HttpResponse* resp)</span><br><span class="line">&#123;</span><br><span class="line">  if (req.path() == &quot;/&quot;)</span><br><span class="line">  &#123;</span><br><span class="line">    string result;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    //遍历helps</span><br><span class="line">    for (std::map&lt;string, HelpList&gt;::const_iterator helpListI = helps_.begin();</span><br><span class="line">         helpListI != helps_.end();</span><br><span class="line">         ++helpListI)</span><br><span class="line">    &#123;</span><br><span class="line">      const HelpList&amp; list = helpListI-&gt;second;</span><br><span class="line">      for (const auto&amp; it : list)</span><br><span class="line">      &#123;</span><br><span class="line">        //其中一条/proc/pid                  print pid</span><br><span class="line">        result += &quot;/&quot;;</span><br><span class="line">        result += helpListI-&gt;first;//module  eg:proc</span><br><span class="line">        result += &quot;/&quot;;</span><br><span class="line">        result += it.first;//command  eg:pid</span><br><span class="line">        size_t len = helpListI-&gt;first.size() + it.first.size();</span><br><span class="line">        result += string(len &gt;= 25 ? 1 : 25 - len, &#x27; &#x27;);</span><br><span class="line">        result += it.second;//help  eg: print pid</span><br><span class="line">        result += &quot;\n&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resp-&gt;setStatusCode(HttpResponse::k200Ok);</span><br><span class="line">    resp-&gt;setStatusMessage(&quot;OK&quot;);</span><br><span class="line">    resp-&gt;setContentType(&quot;text/plain&quot;);</span><br><span class="line">    resp-&gt;setBody(result);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    //以&quot;/&quot;进行分割，将得到的字符串保存在result中</span><br><span class="line">    std::vector&lt;string&gt; result = split(req.path());</span><br><span class="line">    // boost::split(result, req.path(), boost::is_any_of(&quot;/&quot;));</span><br><span class="line">    //std::copy(result.begin(), result.end(), std::ostream_iterator&lt;string&gt;(std::cout, &quot;, &quot;));</span><br><span class="line">    //std::cout &lt;&lt; &quot;\n&quot;;</span><br><span class="line">    bool ok = false;</span><br><span class="line">    if (result.size() == 0)</span><br><span class="line">    &#123;</span><br><span class="line">      //这种情况是错误的，因此OK仍未false</span><br><span class="line">      LOG_DEBUG &lt;&lt; req.path();</span><br><span class="line">    &#125;</span><br><span class="line">    else if (result.size() == 1)</span><br><span class="line">    &#123;</span><br><span class="line">      //只有module，没有connand也是错的，因此ok仍为false,除了下面这种情况</span><br><span class="line">      string module = result[0];</span><br><span class="line">      if (module == &quot;favicon.ico&quot;)</span><br><span class="line">      &#123;</span><br><span class="line">        resp-&gt;setStatusCode(HttpResponse::k200Ok);</span><br><span class="line">        resp-&gt;setStatusMessage(&quot;OK&quot;);</span><br><span class="line">        resp-&gt;setContentType(&quot;image/png&quot;);</span><br><span class="line">        resp-&gt;setBody(string(favicon, sizeof favicon));</span><br><span class="line"></span><br><span class="line">        ok = true;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        LOG_ERROR &lt;&lt; &quot;Unimplemented &quot; &lt;&lt; module;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      string module = result[0];</span><br><span class="line">      MutexLockGuard lock(mutex_);</span><br><span class="line">      //查找module所对应的命令列表</span><br><span class="line">      std::map&lt;string, CommandList&gt;::const_iterator commListI = modules_.find(module);</span><br><span class="line">      if (commListI != modules_.end())</span><br><span class="line">      &#123;</span><br><span class="line">        string command = result[1];</span><br><span class="line">        const CommandList&amp; commList = commListI-&gt;second;</span><br><span class="line">        //查找command对应的命令</span><br><span class="line">        CommandList::const_iterator it = commList.find(command);</span><br><span class="line">        if (it != commList.end())</span><br><span class="line">        &#123;</span><br><span class="line">          ArgList args(result.begin()+2, result.end());//传递给回调函数的参数表</span><br><span class="line">          if (it-&gt;second)//callback</span><br><span class="line">          &#123;</span><br><span class="line">            resp-&gt;setStatusCode(HttpResponse::k200Ok);</span><br><span class="line">            resp-&gt;setStatusMessage(&quot;OK&quot;);</span><br><span class="line">            resp-&gt;setContentType(&quot;text/plain&quot;);</span><br><span class="line">            const Callback&amp; cb = it-&gt;second;</span><br><span class="line">            resp-&gt;setBody(cb(req.method(), args));//调用cb将返回的字符串传给setBody</span><br><span class="line">            ok = true;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!ok)</span><br><span class="line">    &#123;</span><br><span class="line">      resp-&gt;setStatusCode(HttpResponse::k404NotFound);</span><br><span class="line">      resp-&gt;setStatusMessage(&quot;Not Found&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //resp-&gt;setCloseConnection(true);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="ProcessInspector"><a href="#ProcessInspector" class="headerlink" title="ProcessInspector"></a>ProcessInspector</h2><p>通过Processlnfo返回进程信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class ProcessInspector : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  void registerCommands(Inspector* ins);//注册命令接口</span><br><span class="line"></span><br><span class="line">  static string overview(HttpRequest::Method, const Inspector::ArgList&amp;);</span><br><span class="line">  static string pid(HttpRequest::Method, const Inspector::ArgList&amp;);</span><br><span class="line">  static string procStatus(HttpRequest::Method, const Inspector::ArgList&amp;);</span><br><span class="line">  static string openedFiles(HttpRequest::Method, const Inspector::ArgList&amp;);</span><br><span class="line">  static string threads(HttpRequest::Method, const Inspector::ArgList&amp;);</span><br><span class="line"></span><br><span class="line">  static string username_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void ProcessInspector::registerCommands(Inspector* ins)</span><br><span class="line">&#123;</span><br><span class="line">  ins-&gt;add(&quot;proc&quot;, &quot;overview&quot;, ProcessInspector::overview, &quot;print basic overview&quot;);</span><br><span class="line">  ins-&gt;add(&quot;proc&quot;, &quot;pid&quot;, ProcessInspector::pid, &quot;print pid&quot;);</span><br><span class="line">  ins-&gt;add(&quot;proc&quot;, &quot;status&quot;, ProcessInspector::procStatus, &quot;print /proc/self/status&quot;);</span><br><span class="line">  // ins-&gt;add(&quot;proc&quot;, &quot;opened_files&quot;, ProcessInspector::openedFiles, &quot;count /proc/self/fd&quot;);</span><br><span class="line">  ins-&gt;add(&quot;proc&quot;, &quot;threads&quot;, ProcessInspector::threads, &quot;list /proc/self/task&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string ProcessInspector::pid(HttpRequest::Method, const Inspector::ArgList&amp;)</span><br><span class="line">&#123;</span><br><span class="line">  char buf[32];</span><br><span class="line">  snprintf(buf, sizeof buf, &quot;%d&quot;, ProcessInfo::pid());</span><br><span class="line">  return buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Processlnfo"><a href="#Processlnfo" class="headerlink" title="Processlnfo"></a>Processlnfo</h2><p>获取进程相关信息</p>
<h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/net/inspect/Inspector.h&quot;</span><br><span class="line">#include &quot;muduo/net/EventLoop.h&quot;</span><br><span class="line">#include &quot;muduo/net/EventLoopThread.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  EventLoop loop;//两个线程，一个主线程，一个监控线程，构造函数在主线程调用</span><br><span class="line">  EventLoopThread t;//监控线程</span><br><span class="line">  Inspector ins(t.startLoop(), InetAddress(12345), &quot;test&quot;);</span><br><span class="line">  loop.loop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.48.128:12345/</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/proc/overview             print basic overview</span><br><span class="line">/proc/pid                  print pid</span><br><span class="line">/proc/status               print /proc/self/status</span><br><span class="line">/proc/threads              list /proc/self/task</span><br><span class="line">/sys/cpuinfo               print /proc/cpuinfo</span><br><span class="line">/sys/loadavg               print /proc/loadavg</span><br><span class="line">/sys/meminfo               print /proc/meminfo</span><br><span class="line">/sys/overview              print system overview</span><br><span class="line">/sys/stat                  print /proc/stat</span><br><span class="line">/sys/version               print /proc/version</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/21/muduo-http%E5%BA%93-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/21/muduo-http%E5%BA%93-1/" class="post-title-link" itemprop="url">muduo-http库(1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-21 16:46:26" itemprop="dateCreated datePublished" datetime="2023-08-21T16:46:26+08:00">2023-08-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-22 12:10:24" itemprop="dateModified" datetime="2023-08-22T12:10:24+08:00">2023-08-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="http-request"><a href="#http-request" class="headerlink" title="http request"></a>http request</h1><p>request line + header + body ( header分为普通报头，请求报头与实体报头)</p>
<p>header与body之间有一空行（CRLF：\r\n)</p>
<p>请求方法有:<br>Get, Post, Head, Put,Delete等</p>
<p>协议版本1.0、1.1</p>
<p>常用请求头</p>
<ul>
<li>Accept:浏览器可接受的媒体（MIME）类型;</li>
<li>Accept-Language:浏览器所希望的语言种类</li>
<li>Accept-Encoding:浏览器能够解码的编码方法，如gzip，deflate等</li>
<li>User-Agent:告诉HTTP服务器，客户端使用的操作系统和浏览器的名称和版本</li>
<li>Connection:表示是否需要持久连接，Keep-Alive表示长连接，close表示短连接</li>
</ul>
<h2 id="一个典型的http请求"><a href="#一个典型的http请求" class="headerlink" title="一个典型的http请求"></a>一个典型的http请求</h2><p><img src="/muduo-http%E5%BA%93-1/image-20230821175548800.png" alt="image-20230821175548800"></p>
<img src="/2023/08/21/muduo-http%E5%BA%93-1/image-20230821175548800.png" class title="This is an test image">

<h1 id="http-response"><a href="#http-response" class="headerlink" title="http response"></a>http response</h1><p>status line + header + body ( header分为普通报头，响应报头与实体报头)</p>
<p>header与body之间有一空行（CRLF)</p>
<p>状态响应码</p>
<ul>
<li>1XX提示信息-表示请求已被成功接收，继续处理</li>
<li>2XX成功-表示请求已被成功接收，理解，接受</li>
<li>3XX重定向-要完成请求必须进行更进一步的处理</li>
<li>4XX客户端错误–请求有语法错误或请求无法实现</li>
<li>5XX服务器端错误–服务器执行一个有效请求失败</li>
</ul>
<h2 id="一个典型的http应答"><a href="#一个典型的http应答" class="headerlink" title="一个典型的http应答"></a>一个典型的http应答</h2><p><img src="/muduo-http%E5%BA%93-1/image-20230821175626176.png" alt="image-20230821175626176"></p>
<img src="/2023/08/21/muduo-http%E5%BA%93-1/image-20230821175626176.png" class title="This is an test image">

<h1 id="muduo-http库涉及到的类"><a href="#muduo-http库涉及到的类" class="headerlink" title="muduo_http库涉及到的类"></a>muduo_http库涉及到的类</h1><h2 id="HttpRequest-http请求类封装"><a href="#HttpRequest-http请求类封装" class="headerlink" title="HttpRequest: http请求类封装"></a>HttpRequest: http请求类封装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_NET_HTTP_HTTPREQUEST_H</span><br><span class="line">#define MUDUO_NET_HTTP_HTTPREQUEST_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/copyable.h&quot;</span><br><span class="line">#include &quot;muduo/base/Timestamp.h&quot;</span><br><span class="line">#include &quot;muduo/base/Types.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">class HttpRequest : public muduo::copyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  enum Method//http支持的方法，不止这些方法</span><br><span class="line">  &#123;</span><br><span class="line">    kInvalid, kGet, kPost, kHead, kPut, kDelete</span><br><span class="line">  &#125;;</span><br><span class="line">  enum Version//http协议版本</span><br><span class="line">  &#123;</span><br><span class="line">    kUnknown, kHttp10, kHttp11</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  HttpRequest()</span><br><span class="line">    : method_(kInvalid),</span><br><span class="line">      version_(kUnknown)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void setVersion(Version v)</span><br><span class="line">  &#123;</span><br><span class="line">    version_ = v;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Version getVersion() const</span><br><span class="line">  &#123; return version_; &#125;</span><br><span class="line"></span><br><span class="line">  bool setMethod(const char* start, const char* end)</span><br><span class="line">  &#123;</span><br><span class="line">    assert(method_ == kInvalid);</span><br><span class="line">    string m(start, end);//迭代器的用法，获取start到end的字符串，不包括end</span><br><span class="line">    if (m == &quot;GET&quot;)</span><br><span class="line">    &#123;</span><br><span class="line">      method_ = kGet;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (m == &quot;POST&quot;)</span><br><span class="line">    &#123;</span><br><span class="line">      method_ = kPost;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (m == &quot;HEAD&quot;)</span><br><span class="line">    &#123;</span><br><span class="line">      method_ = kHead;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (m == &quot;PUT&quot;)</span><br><span class="line">    &#123;</span><br><span class="line">      method_ = kPut;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (m == &quot;DELETE&quot;)</span><br><span class="line">    &#123;</span><br><span class="line">      method_ = kDelete;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      method_ = kInvalid;</span><br><span class="line">    &#125;</span><br><span class="line">    return method_ != kInvalid;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Method method() const</span><br><span class="line">  &#123; return method_; &#125;</span><br><span class="line">  //请求方法转换成字符串</span><br><span class="line">  const char* methodString() const</span><br><span class="line">  &#123;</span><br><span class="line">    const char* result = &quot;UNKNOWN&quot;;</span><br><span class="line">    switch(method_)</span><br><span class="line">    &#123;</span><br><span class="line">      case kGet:</span><br><span class="line">        result = &quot;GET&quot;;</span><br><span class="line">        break;</span><br><span class="line">      case kPost:</span><br><span class="line">        result = &quot;POST&quot;;</span><br><span class="line">        break;</span><br><span class="line">      case kHead:</span><br><span class="line">        result = &quot;HEAD&quot;;</span><br><span class="line">        break;</span><br><span class="line">      case kPut:</span><br><span class="line">        result = &quot;PUT&quot;;</span><br><span class="line">        break;</span><br><span class="line">      case kDelete:</span><br><span class="line">        result = &quot;DELETE&quot;;</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void setPath(const char* start, const char* end)</span><br><span class="line">  &#123;</span><br><span class="line">    path_.assign(start, end);//字符串赋值操作，将从指针 start 指向的位置开始，到指针 end 指向的位置结束的字符序列赋值给 path_</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const string&amp; path() const</span><br><span class="line">  &#123; return path_; &#125;</span><br><span class="line"></span><br><span class="line">  void setQuery(const char* start, const char* end)</span><br><span class="line">  &#123;</span><br><span class="line">    query_.assign(start, end);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const string&amp; query() const</span><br><span class="line">  &#123; return query_; &#125;</span><br><span class="line"></span><br><span class="line">  void setReceiveTime(Timestamp t)</span><br><span class="line">  &#123; receiveTime_ = t; &#125;</span><br><span class="line"></span><br><span class="line">  Timestamp receiveTime() const</span><br><span class="line">  &#123; return receiveTime_; &#125;</span><br><span class="line"></span><br><span class="line">  void addHeader(const char* start, const char* colon, const char* end)//colon冒号</span><br><span class="line">  &#123;</span><br><span class="line">    string field(start, colon);//header域</span><br><span class="line">    ++colon;</span><br><span class="line">    //去除左空格</span><br><span class="line">    while (colon &lt; end &amp;&amp; isspace(*colon))</span><br><span class="line">    &#123;</span><br><span class="line">      ++colon;</span><br><span class="line">    &#125;</span><br><span class="line">    string value(colon, end);//header值</span><br><span class="line">    //去除右空格</span><br><span class="line">    while (!value.empty() &amp;&amp; isspace(value[value.size()-1]))</span><br><span class="line">    &#123;</span><br><span class="line">      value.resize(value.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line">    headers_[field] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  //根据头域返回它的值</span><br><span class="line">  string getHeader(const string&amp; field) const</span><br><span class="line">  &#123;</span><br><span class="line">    string result;</span><br><span class="line">    std::map&lt;string, string&gt;::const_iterator it = headers_.find(field);</span><br><span class="line">    if (it != headers_.end())</span><br><span class="line">    &#123;</span><br><span class="line">      result = it-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const std::map&lt;string, string&gt;&amp; headers() const</span><br><span class="line">  &#123; return headers_; &#125;</span><br><span class="line"></span><br><span class="line">  void swap(HttpRequest&amp; that)</span><br><span class="line">  &#123;</span><br><span class="line">    std::swap(method_, that.method_);</span><br><span class="line">    std::swap(version_, that.version_);</span><br><span class="line">    path_.swap(that.path_);</span><br><span class="line">    query_.swap(that.query_);</span><br><span class="line">    receiveTime_.swap(that.receiveTime_);</span><br><span class="line">    headers_.swap(that.headers_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  Method method_;//请求方法</span><br><span class="line">  Version version_;//协议版本1.0 1.1</span><br><span class="line">  string path_;//请求路径</span><br><span class="line">  string query_;</span><br><span class="line">  Timestamp receiveTime_;//请求时间</span><br><span class="line">  std::map&lt;string, string&gt; headers_;//header列表</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_NET_HTTP_HTTPREQUEST_H</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void addHeader(const char* start, const char* colon, const char* end)//colon冒号</span><br><span class="line">&#123;</span><br><span class="line">  string field(start, colon);//header域</span><br><span class="line">  ++colon;</span><br><span class="line">  //去除左空格</span><br><span class="line">  while (colon &lt; end &amp;&amp; isspace(*colon))</span><br><span class="line">  &#123;</span><br><span class="line">    ++colon;</span><br><span class="line">  &#125;</span><br><span class="line">  string value(colon, end);//header值</span><br><span class="line">  //去除右空格</span><br><span class="line">  while (!value.empty() &amp;&amp; isspace(value[value.size()-1]))</span><br><span class="line">  &#123;</span><br><span class="line">    value.resize(value.size()-1);</span><br><span class="line">  &#125;</span><br><span class="line">  headers_[field] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的作用是将从HTTP请求中解析出来的头部信息（header）添加到一个名为<code>headers_</code>的容器中。</p>
<p>具体而言，该函数接受三个指针参数：<code>start</code>指向头部字段（field）的起始位置，<code>colon</code>指向冒号的位置，<code>end</code>指向头部值（value）的结束位置。</p>
<p>首先，该函数通过将<code>start</code>和<code>colon</code>之间的字符创建一个<code>string</code>对象，即头部字段名。然后，它递增<code>colon</code>指针以跳过冒号，并在循环中去除<code>colon</code>及其后面的所有空格字符。</p>
<p>接下来，函数通过将<code>colon</code>和<code>end</code>之间的字符创建一个<code>string</code>对象，即头部值。再次使用循环，它去除头部值的末尾空格字符，使得头部值不包含任何额外的空白。</p>
<p>最后，函数将头部字段名和头部值作为键值对存储在<code>headers_</code>容器中，以便稍后使用。</p>
<p>总而言之，该函数解析并提取了HTTP请求中的单个头部字段和值，并将它们存储在<code>headers_</code>容器中，方便后续对头部信息的访问和处理。</p>
<h2 id="HttpResponse-http响应类封装"><a href="#HttpResponse-http响应类封装" class="headerlink" title="HttpResponse: http响应类封装"></a>HttpResponse: http响应类封装</h2><h3 id="HttpResponse-h"><a href="#HttpResponse-h" class="headerlink" title="HttpResponse.h"></a>HttpResponse.h</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class HttpResponse : public muduo::copyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  enum HttpStatusCode//响应的状态码枚举类型，不全</span><br><span class="line">  &#123;</span><br><span class="line">    kUnknown,</span><br><span class="line">    k200Ok = 200,//成功</span><br><span class="line">    k301MovedPermanently = 301,//301重定向，请求的页面永久性地转移到另一个地址</span><br><span class="line">    k400BadRequest = 400,//错误的请求，语法格式有误，服务器无法处理此请求</span><br><span class="line">    k404NotFound = 404,//请求的网页不存在</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  explicit HttpResponse(bool close)</span><br><span class="line">    : statusCode_(kUnknown),</span><br><span class="line">      closeConnection_(close)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void setStatusCode(HttpStatusCode code)</span><br><span class="line">  &#123; statusCode_ = code; &#125;</span><br><span class="line"></span><br><span class="line">  void setStatusMessage(const string&amp; message)</span><br><span class="line">  &#123; statusMessage_ = message; &#125;</span><br><span class="line"></span><br><span class="line">  void setCloseConnection(bool on)</span><br><span class="line">  &#123; closeConnection_ = on; &#125;</span><br><span class="line"></span><br><span class="line">  bool closeConnection() const</span><br><span class="line">  &#123; return closeConnection_; &#125;</span><br><span class="line">  //设置文档媒体类型(MIME)</span><br><span class="line">  void setContentType(const string&amp; contentType)</span><br><span class="line">  &#123; addHeader(&quot;Content-Type&quot;, contentType); &#125;</span><br><span class="line"></span><br><span class="line">  // FIXME: replace string with StringPiece</span><br><span class="line">  void addHeader(const string&amp; key, const string&amp; value)</span><br><span class="line">  &#123; headers_[key] = value; &#125;</span><br><span class="line"></span><br><span class="line">  void setBody(const string&amp; body)</span><br><span class="line">  &#123; body_ = body; &#125;</span><br><span class="line"></span><br><span class="line">  void appendToBuffer(Buffer* output) const;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  std::map&lt;string, string&gt; headers_;//header列表</span><br><span class="line">  HttpStatusCode statusCode_;//状态响应码</span><br><span class="line">  // FIXME: add http version</span><br><span class="line">  string statusMessage_;//状态响应码对应的文本信息</span><br><span class="line">  bool closeConnection_;//是否关闭连接</span><br><span class="line">  string body_;         //实体</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="HttpResponse-cc"><a href="#HttpResponse-cc" class="headerlink" title="HttpResponse.cc"></a>HttpResponse.cc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void HttpResponse::appendToBuffer(Buffer* output) const</span><br><span class="line">&#123;</span><br><span class="line">  char buf[32];</span><br><span class="line">  //添加响应头</span><br><span class="line">  snprintf(buf, sizeof buf, &quot;HTTP/1.1 %d &quot;, statusCode_);</span><br><span class="line">  output-&gt;append(buf);</span><br><span class="line">  output-&gt;append(statusMessage_);</span><br><span class="line">  output-&gt;append(&quot;\r\n&quot;);</span><br><span class="line"></span><br><span class="line">  if (closeConnection_)</span><br><span class="line">  &#123;</span><br><span class="line">    //如果是短连接，不存在粘包问题，不需要告诉浏览器Content-Length，浏览器也能正确处理</span><br><span class="line">    output-&gt;append(&quot;Connection: close\r\n&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    //长连接</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;Content-Length: %zd\r\n&quot;, body_.size());//实体长度</span><br><span class="line">    output-&gt;append(buf);</span><br><span class="line">    output-&gt;append(&quot;Connection: Keep-Alive\r\n&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  //header列表</span><br><span class="line">  for (const auto&amp; header : headers_)</span><br><span class="line">  &#123;</span><br><span class="line">    output-&gt;append(header.first);</span><br><span class="line">    output-&gt;append(&quot;: &quot;);</span><br><span class="line">    output-&gt;append(header.second);</span><br><span class="line">    output-&gt;append(&quot;\r\n&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  output-&gt;append(&quot;\r\n&quot;);//header与body之间的空行</span><br><span class="line">  output-&gt;append(body_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="HttpContext-http协议解析类"><a href="#HttpContext-http协议解析类" class="headerlink" title="HttpContext: http协议解析类"></a>HttpContext: http协议解析类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">  enum HttpRequestParseState</span><br><span class="line">  &#123;</span><br><span class="line">    kExpectRequestLine,</span><br><span class="line">    kExpectHeaders,</span><br><span class="line">    kExpectBody,</span><br><span class="line">    kGotAll,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  bool gotAll() const</span><br><span class="line">  &#123; return state_ == kGotAll; &#125;</span><br><span class="line">  //重置HttpContext状态</span><br><span class="line">  HttpRequestParseState state_;//请求解析状态</span><br><span class="line">  HttpRequest request_;//http请求</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  //解析请求行</span><br><span class="line">  bool HttpContext::processRequestLine(const char* begin, const char* end)</span><br><span class="line">&#123;</span><br><span class="line">  bool succeed = false;</span><br><span class="line">  const char* start = begin;</span><br><span class="line">  const char* space = std::find(start, end, &#x27; &#x27;);</span><br><span class="line">  if (space != end &amp;&amp; request_.setMethod(start, space))//解析请求方法</span><br><span class="line">  &#123;</span><br><span class="line">    start = space+1;</span><br><span class="line">    space = std::find(start, end, &#x27; &#x27;);</span><br><span class="line">    if (space != end)</span><br><span class="line">    &#123;</span><br><span class="line">      const char* question = std::find(start, space, &#x27;?&#x27;);</span><br><span class="line">      if (question != space)</span><br><span class="line">      &#123;</span><br><span class="line">        request_.setPath(start, question);</span><br><span class="line">        request_.setQuery(question, space);</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        request_.setPath(start, space);//解析PATH</span><br><span class="line">      &#125;</span><br><span class="line">      start = space+1;</span><br><span class="line">      succeed = end-start == 8 &amp;&amp; std::equal(start, end-1, &quot;HTTP/1.&quot;);</span><br><span class="line">      if (succeed)</span><br><span class="line">      &#123;</span><br><span class="line">        if (*(end-1) == &#x27;1&#x27;)//HTTP/1.1</span><br><span class="line">        &#123;</span><br><span class="line">          request_.setVersion(HttpRequest::kHttp11);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (*(end-1) == &#x27;0&#x27;)//HTTP/1.0</span><br><span class="line">        &#123;</span><br><span class="line">          request_.setVersion(HttpRequest::kHttp10);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">          succeed = false;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return succeed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// return false if any error</span><br><span class="line">bool HttpContext::parseRequest(Buffer* buf, Timestamp receiveTime)</span><br><span class="line">&#123;</span><br><span class="line">  bool ok = true;</span><br><span class="line">  bool hasMore = true;</span><br><span class="line">  while (hasMore)//相当于一个状态机</span><br><span class="line">  &#123;</span><br><span class="line">    if (state_ == kExpectRequestLine)//处于解析请求行的状态</span><br><span class="line">    &#123;</span><br><span class="line">      const char* crlf = buf-&gt;findCRLF();</span><br><span class="line">      if (crlf)</span><br><span class="line">      &#123;</span><br><span class="line">        ok = processRequestLine(buf-&gt;peek(), crlf);//解析请求行</span><br><span class="line">        if (ok)</span><br><span class="line">        &#123;</span><br><span class="line">          request_.setReceiveTime(receiveTime);//设置请求时间</span><br><span class="line">          buf-&gt;retrieveUntil(crlf + 2);//将请求行从buf中取回，包括\r\n</span><br><span class="line">          state_ = kExpectHeaders;//HttpContext将状态改为kExpectHeaders</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">          hasMore = false;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        hasMore = false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (state_ == kExpectHeaders)//解析header</span><br><span class="line">    &#123;</span><br><span class="line">      const char* crlf = buf-&gt;findCRLF();</span><br><span class="line">      if (crlf)</span><br><span class="line">      &#123;</span><br><span class="line">        const char* colon = std::find(buf-&gt;peek(), crlf, &#x27;:&#x27;);//冒号所在位置</span><br><span class="line">        if (colon != crlf)</span><br><span class="line">        &#123;</span><br><span class="line">          request_.addHeader(buf-&gt;peek(), colon, crlf);//函数将头部字段名和头部值作为键值对存储在headers_容器中</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">          // empty line, end of header</span><br><span class="line">          // FIXME:</span><br><span class="line">          state_ = kGotAll;//HttpContext将状态改为 kGotAll</span><br><span class="line">          hasMore = false;</span><br><span class="line">        &#125;</span><br><span class="line">        buf-&gt;retrieveUntil(crlf + 2);//将header从buf中取回，包括\r\n</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        hasMore = false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (state_ == kExpectBody)//当前还不支持请求中带body</span><br><span class="line">    &#123;</span><br><span class="line">      // FIXME:</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是一个基于muduo网络库的HTTP请求解析器，用于解析HTTP请求报文。</p>
<p><code>HttpContext::processRequestLine</code> 函数用于解析请求行，该函数接受两个指针参数 <code>begin</code> 和 <code>end</code>，表示请求行的起始位置和结束位置。函数首先在请求行中寻找空格字符，将请求方法解析出来，并设置到 <code>request_</code> 对象中。然后再次寻找空格字符，解析出路径和查询字符串，并设置到 <code>request_</code> 对象中。最后判断请求的HTTP版本号，并设置到 <code>request_</code> 对象中。</p>
<p><code>HttpContext::parseRequest</code> 函数用于解析完整的HTTP请求报文。该函数接受一个 <code>Buffer</code> 对象和一个时间戳参数。函数通过一个 while 循环来不断解析请求报文的各个部分。</p>
<ul>
<li>当 <code>state_</code> 的值为 <code>kExpectRequestLine</code> 时，表示正在解析请求行。函数调用 <code>buf-&gt;findCRLF()</code> 来查找请求行的结束位置，如果找到了 CRLF（回车换行）字符，则调用 <code>processRequestLine</code> 进行解析。解析成功后，设置请求时间并从 <code>buf</code> 中移除已解析的请求行，然后将 <code>state_</code> 设置为 <code>kExpectHeaders</code>，进入下一个状态。</li>
<li>当 <code>state_</code> 的值为 <code>kExpectHeaders</code> 时，表示正在解析请求头部。函数调用 <code>buf-&gt;findCRLF()</code> 来查找头部的结束位置，如果找到了 CRLF 字符，则调用 <code>request_.addHeader</code> 函数将头部字段名和值存储到 <code>request_</code> 对象中。如果找不到 CRLF 字符，说明还没有解析完所有的头部字段，函数退出循环。</li>
<li>当 <code>state_</code> 的值为 <code>kExpectBody</code> 时，表示请求中带有请求体部分。当前代码中并未实现对请求体的解析。</li>
</ul>
<p>这段代码主要是通过状态机的方式逐步解析HTTP请求报文的各个部分，并将解析结果存储在 <code>request_</code> 对象中。</p>
<h2 id="HttpServer-http服务器类封装"><a href="#HttpServer-http服务器类封装" class="headerlink" title="HttpServer:http服务器类封装"></a>HttpServer:http服务器类封装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">//也是一个Tcp服务器</span><br><span class="line">class HttpServer : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  typedef std::function&lt;void (const HttpRequest&amp;,</span><br><span class="line">                              HttpResponse*)&gt; HttpCallback;</span><br><span class="line"></span><br><span class="line">  HttpServer(EventLoop* loop,</span><br><span class="line">             const InetAddress&amp; listenAddr,</span><br><span class="line">             const string&amp; name,</span><br><span class="line">             TcpServer::Option option = TcpServer::kNoReusePort);</span><br><span class="line"></span><br><span class="line">  EventLoop* getLoop() const &#123; return server_.getLoop(); &#125;</span><br><span class="line"></span><br><span class="line">  /// Not thread safe, callback be registered before calling start().</span><br><span class="line">  void setHttpCallback(const HttpCallback&amp; cb)</span><br><span class="line">  &#123;</span><br><span class="line">    httpCallback_ = cb;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void setThreadNum(int numThreads)</span><br><span class="line">  &#123;</span><br><span class="line">    server_.setThreadNum(numThreads);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void start();</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  void onConnection(const TcpConnectionPtr&amp; conn);</span><br><span class="line">  void onMessage(const TcpConnectionPtr&amp; conn,</span><br><span class="line">                 Buffer* buf,</span><br><span class="line">                 Timestamp receiveTime);</span><br><span class="line">  void onRequest(const TcpConnectionPtr&amp;, const HttpRequest&amp;);</span><br><span class="line"></span><br><span class="line">  TcpServer server_;</span><br><span class="line">  HttpCallback httpCallback_;//在处理http请求(即调用onRequest)的过程中回调此函数，对请求进行具体的处理，boost::any context_;将这个绑定</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line">namespace detail</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">void defaultHttpCallback(const HttpRequest&amp;, HttpResponse* resp)</span><br><span class="line">&#123;</span><br><span class="line">  resp-&gt;setStatusCode(HttpResponse::k404NotFound);</span><br><span class="line">  resp-&gt;setStatusMessage(&quot;Not Found&quot;);</span><br><span class="line">  resp-&gt;setCloseConnection(true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace detail</span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">HttpServer::HttpServer(EventLoop* loop,</span><br><span class="line">                       const InetAddress&amp; listenAddr,</span><br><span class="line">                       const string&amp; name,</span><br><span class="line">                       TcpServer::Option option)</span><br><span class="line">  : server_(loop, listenAddr, name, option),</span><br><span class="line">    httpCallback_(detail::defaultHttpCallback)</span><br><span class="line">&#123;</span><br><span class="line">  server_.setConnectionCallback(</span><br><span class="line">      std::bind(&amp;HttpServer::onConnection, this, _1));</span><br><span class="line">  server_.setMessageCallback(</span><br><span class="line">      std::bind(&amp;HttpServer::onMessage, this, _1, _2, _3));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HttpServer::start()</span><br><span class="line">&#123;</span><br><span class="line">  LOG_WARN &lt;&lt; &quot;HttpServer[&quot; &lt;&lt; server_.name()</span><br><span class="line">    &lt;&lt; &quot;] starts listening on &quot; &lt;&lt; server_.ipPort();</span><br><span class="line">  server_.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HttpServer::onConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">&#123;</span><br><span class="line">  if (conn-&gt;connected())</span><br><span class="line">  &#123;</span><br><span class="line">    conn-&gt;setContext(HttpContext());//TcpConnection与一个HttpContext绑定</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HttpServer::onMessage(const TcpConnectionPtr&amp; conn,</span><br><span class="line">                           Buffer* buf,</span><br><span class="line">                           Timestamp receiveTime)</span><br><span class="line">&#123;</span><br><span class="line">  HttpContext* context = boost::any_cast&lt;HttpContext&gt;(conn-&gt;getMutableContext());</span><br><span class="line">  //解析请求包</span><br><span class="line">  if (!context-&gt;parseRequest(buf, receiveTime))</span><br><span class="line">  &#123;</span><br><span class="line">    conn-&gt;send(&quot;HTTP/1.1 400 Bad Request\r\n\r\n&quot;);</span><br><span class="line">    conn-&gt;shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">  //请求解析完毕</span><br><span class="line">  if (context-&gt;gotAll())</span><br><span class="line">  &#123;</span><br><span class="line">    onRequest(conn, context-&gt;request());</span><br><span class="line">    context-&gt;reset();//本次请求处理完毕，重置Httpcontext，适用于长连接</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HttpServer::onRequest(const TcpConnectionPtr&amp; conn, const HttpRequest&amp; req)</span><br><span class="line">&#123;</span><br><span class="line">  const string&amp; connection = req.getHeader(&quot;Connection&quot;);//根据头域返回它的值</span><br><span class="line">  bool close = connection == &quot;close&quot; ||</span><br><span class="line">    (req.getVersion() == HttpRequest::kHttp10 &amp;&amp; connection != &quot;Keep-Alive&quot;);//1.0版本只支持短连接</span><br><span class="line">  HttpResponse response(close);//处理完请求是否要关闭连接</span><br><span class="line">  httpCallback_(req, &amp;response);//回调用户的函数对HTTP进行相应的处理，处理完，会返回一个response对象</span><br><span class="line">  Buffer buf;</span><br><span class="line">  response.appendToBuffer(&amp;buf);</span><br><span class="line">  conn-&gt;send(&amp;buf);</span><br><span class="line">  if (response.closeConnection())</span><br><span class="line">  &#123;</span><br><span class="line">    conn-&gt;shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">extern char favicon[555];</span><br><span class="line">bool benchmark = false;</span><br><span class="line">//实际的请求处理，返回一个http应答</span><br><span class="line">void onRequest(const HttpRequest&amp; req, HttpResponse* resp)</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; &quot;Headers &quot; &lt;&lt; req.methodString() &lt;&lt; &quot; &quot; &lt;&lt; req.path() &lt;&lt; std::endl;</span><br><span class="line">  if (!benchmark)</span><br><span class="line">  &#123;</span><br><span class="line">    const std::map&lt;string, string&gt;&amp; headers = req.headers();</span><br><span class="line">    for (const auto&amp; header : headers)</span><br><span class="line">    &#123;</span><br><span class="line">      std::cout &lt;&lt; header.first &lt;&lt; &quot;: &quot; &lt;&lt; header.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (req.path() == &quot;/&quot;)</span><br><span class="line">  &#123;</span><br><span class="line">    resp-&gt;setStatusCode(HttpResponse::k200Ok);</span><br><span class="line">    resp-&gt;setStatusMessage(&quot;OK&quot;);</span><br><span class="line">    resp-&gt;setContentType(&quot;text/html&quot;);</span><br><span class="line">    resp-&gt;addHeader(&quot;Server&quot;, &quot;Muduo&quot;);</span><br><span class="line">    string now = Timestamp::now().toFormattedString();</span><br><span class="line">    resp-&gt;setBody(&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;This is title&lt;/title&gt;&lt;/head&gt;&quot;</span><br><span class="line">        &quot;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;Now is &quot; + now +</span><br><span class="line">        &quot;&lt;/body&gt;&lt;/html&gt;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  else if (req.path() == &quot;/favicon.ico&quot;)</span><br><span class="line">  &#123;</span><br><span class="line">    resp-&gt;setStatusCode(HttpResponse::k200Ok);</span><br><span class="line">    resp-&gt;setStatusMessage(&quot;OK&quot;);</span><br><span class="line">    resp-&gt;setContentType(&quot;image/png&quot;);</span><br><span class="line">    resp-&gt;setBody(string(favicon, sizeof favicon));</span><br><span class="line">  &#125;</span><br><span class="line">  else if (req.path() == &quot;/hello&quot;)</span><br><span class="line">  &#123;</span><br><span class="line">    resp-&gt;setStatusCode(HttpResponse::k200Ok);</span><br><span class="line">    resp-&gt;setStatusMessage(&quot;OK&quot;);</span><br><span class="line">    resp-&gt;setContentType(&quot;text/plain&quot;);</span><br><span class="line">    resp-&gt;addHeader(&quot;Server&quot;, &quot;Muduo&quot;);</span><br><span class="line">    resp-&gt;setBody(&quot;hello, world!\n&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    resp-&gt;setStatusCode(HttpResponse::k404NotFound);</span><br><span class="line">    resp-&gt;setStatusMessage(&quot;Not Found&quot;);</span><br><span class="line">    resp-&gt;setCloseConnection(true);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">  int numThreads = 0;</span><br><span class="line">  if (argc &gt; 1)</span><br><span class="line">  &#123;</span><br><span class="line">    benchmark = true;</span><br><span class="line">    Logger::setLogLevel(Logger::WARN);</span><br><span class="line">    numThreads = atoi(argv[1]);</span><br><span class="line">  &#125;</span><br><span class="line">  EventLoop loop;</span><br><span class="line">  HttpServer server(&amp;loop, InetAddress(8000), &quot;dummy&quot;);</span><br><span class="line">  server.setHttpCallback(onRequest);</span><br><span class="line">  server.setThreadNum(numThreads);</span><br><span class="line">  server.start();</span><br><span class="line">  loop.loop();</span><br><span class="line">&#125;</span><br><span class="line">//这是一个图片数据</span><br><span class="line">char favicon[555] = &#123;</span><br><span class="line">  &#x27;\x89&#x27;, &#x27;P&#x27;, &#x27;N&#x27;, &#x27;G&#x27;, &#x27;\xD&#x27;, &#x27;\xA&#x27;, &#x27;\x1A&#x27;, &#x27;\xA&#x27;,</span><br><span class="line">  &#x27;\x0&#x27;, &#x27;\x0&#x27;, &#x27;\x0&#x27;, &#x27;\xD&#x27;, &#x27;I&#x27;, &#x27;H&#x27;, &#x27;D&#x27;, &#x27;R&#x27;,</span><br><span class="line">  &#x27;\x0&#x27;, &#x27;\x0&#x27;, &#x27;\x0&#x27;, &#x27;\x10&#x27;, &#x27;\x0&#x27;, &#x27;\x0&#x27;, &#x27;\x0&#x27;, &#x27;\x10&#x27;,</span><br><span class="line">  &#x27;\x8&#x27;, &#x27;\x6&#x27;, &#x27;\x0&#x27;, &#x27;\x0&#x27;, &#x27;\x0&#x27;, &#x27;\x1F&#x27;, &#x27;\xF3&#x27;, &#x27;\xFF&#x27;,</span><br><span class="line">  &#x27;a&#x27;, &#x27;\x0&#x27;, &#x27;\x0&#x27;, &#x27;\x0&#x27;, &#x27;\x19&#x27;, &#x27;t&#x27;, &#x27;E&#x27;, &#x27;X&#x27;,</span><br><span class="line">  &#x27;t&#x27;, &#x27;S&#x27;, &#x27;o&#x27;, &#x27;f&#x27;, &#x27;t&#x27;, &#x27;w&#x27;, &#x27;a&#x27;, &#x27;r&#x27;,</span><br><span class="line">  &#x27;e&#x27;, &#x27;\x0&#x27;, &#x27;A&#x27;, &#x27;d&#x27;, &#x27;o&#x27;, &#x27;b&#x27;, &#x27;e&#x27;, &#x27;\x20&#x27;,</span><br><span class="line">  &#x27;I&#x27;, &#x27;m&#x27;, &#x27;a&#x27;, &#x27;g&#x27;, &#x27;e&#x27;, &#x27;R&#x27;, &#x27;e&#x27;, &#x27;a&#x27;,</span><br><span class="line">  &#x27;d&#x27;, &#x27;y&#x27;, &#x27;q&#x27;, &#x27;\xC9&#x27;, &#x27;e&#x27;, &#x27;\x3C&#x27;, &#x27;\x0&#x27;, &#x27;\x0&#x27;,</span><br><span class="line">  &#x27;\x1&#x27;, &#x27;\xCD&#x27;, &#x27;I&#x27;, &#x27;D&#x27;, &#x27;A&#x27;, &#x27;T&#x27;, &#x27;x&#x27;, &#x27;\xDA&#x27;,</span><br><span class="line">  &#x27;\x94&#x27;, &#x27;\x93&#x27;, &#x27;9&#x27;, &#x27;H&#x27;, &#x27;\x3&#x27;, &#x27;A&#x27;, &#x27;\x14&#x27;, &#x27;\x86&#x27;,</span><br><span class="line">  &#x27;\xFF&#x27;, &#x27;\x5D&#x27;, &#x27;b&#x27;, &#x27;\xA7&#x27;, &#x27;\x4&#x27;, &#x27;R&#x27;, &#x27;\xC4&#x27;, &#x27;m&#x27;,</span><br><span class="line">  &#x27;\x22&#x27;, &#x27;\x1E&#x27;, &#x27;\xA0&#x27;, &#x27;F&#x27;, &#x27;\x24&#x27;, &#x27;\x8&#x27;, &#x27;\x16&#x27;, &#x27;\x16&#x27;,</span><br><span class="line">  &#x27;v&#x27;, &#x27;\xA&#x27;, &#x27;6&#x27;, &#x27;\xBA&#x27;, &#x27;J&#x27;, &#x27;\x9A&#x27;, &#x27;\x80&#x27;, &#x27;\x8&#x27;,</span><br><span class="line">  &#x27;A&#x27;, &#x27;\xB4&#x27;, &#x27;q&#x27;, &#x27;\x85&#x27;, &#x27;X&#x27;, &#x27;\x89&#x27;, &#x27;G&#x27;, &#x27;\xB0&#x27;,</span><br><span class="line">  &#x27;I&#x27;, &#x27;\xA9&#x27;, &#x27;Q&#x27;, &#x27;\x24&#x27;, &#x27;\xCD&#x27;, &#x27;\xA6&#x27;, &#x27;\x8&#x27;, &#x27;\xA4&#x27;,</span><br><span class="line">  &#x27;H&#x27;, &#x27;c&#x27;, &#x27;\x91&#x27;, &#x27;B&#x27;, &#x27;\xB&#x27;, &#x27;\xAF&#x27;, &#x27;V&#x27;, &#x27;\xC1&#x27;,</span><br><span class="line">  &#x27;F&#x27;, &#x27;\xB4&#x27;, &#x27;\x15&#x27;, &#x27;\xCF&#x27;, &#x27;\x22&#x27;, &#x27;X&#x27;, &#x27;\x98&#x27;, &#x27;\xB&#x27;,</span><br><span class="line">  &#x27;T&#x27;, &#x27;H&#x27;, &#x27;\x8A&#x27;, &#x27;d&#x27;, &#x27;\x93&#x27;, &#x27;\x8D&#x27;, &#x27;\xFB&#x27;, &#x27;F&#x27;,</span><br><span class="line">  &#x27;g&#x27;, &#x27;\xC9&#x27;, &#x27;\x1A&#x27;, &#x27;\x14&#x27;, &#x27;\x7D&#x27;, &#x27;\xF0&#x27;, &#x27;f&#x27;, &#x27;v&#x27;,</span><br><span class="line">  &#x27;f&#x27;, &#x27;\xDF&#x27;, &#x27;\x7C&#x27;, &#x27;\xEF&#x27;, &#x27;\xE7&#x27;, &#x27;g&#x27;, &#x27;F&#x27;, &#x27;\xA8&#x27;,</span><br><span class="line">  &#x27;\xD5&#x27;, &#x27;j&#x27;, &#x27;H&#x27;, &#x27;\x24&#x27;, &#x27;\x12&#x27;, &#x27;\x2A&#x27;, &#x27;\x0&#x27;, &#x27;\x5&#x27;,</span><br><span class="line">  &#x27;\xBF&#x27;, &#x27;G&#x27;, &#x27;\xD4&#x27;, &#x27;\xEF&#x27;, &#x27;\xF7&#x27;, &#x27;\x2F&#x27;, &#x27;6&#x27;, &#x27;\xEC&#x27;,</span><br><span class="line">  &#x27;\x12&#x27;, &#x27;\x20&#x27;, &#x27;\x1E&#x27;, &#x27;\x8F&#x27;, &#x27;\xD7&#x27;, &#x27;\xAA&#x27;, &#x27;\xD5&#x27;, &#x27;\xEA&#x27;,</span><br><span class="line">  &#x27;\xAF&#x27;, &#x27;I&#x27;, &#x27;5&#x27;, &#x27;F&#x27;, &#x27;\xAA&#x27;, &#x27;T&#x27;, &#x27;\x5F&#x27;, &#x27;\x9F&#x27;,</span><br><span class="line">  &#x27;\x22&#x27;, &#x27;A&#x27;, &#x27;\x2A&#x27;, &#x27;\x95&#x27;, &#x27;\xA&#x27;, &#x27;\x83&#x27;, &#x27;\xE5&#x27;, &#x27;r&#x27;,</span><br><span class="line">  &#x27;9&#x27;, &#x27;d&#x27;, &#x27;\xB3&#x27;, &#x27;Y&#x27;, &#x27;\x96&#x27;, &#x27;\x99&#x27;, &#x27;L&#x27;, &#x27;\x6&#x27;,</span><br><span class="line">  &#x27;\xE9&#x27;, &#x27;t&#x27;, &#x27;\x9A&#x27;, &#x27;\x25&#x27;, &#x27;\x85&#x27;, &#x27;\x2C&#x27;, &#x27;\xCB&#x27;, &#x27;T&#x27;,</span><br><span class="line">  &#x27;\xA7&#x27;, &#x27;\xC4&#x27;, &#x27;b&#x27;, &#x27;1&#x27;, &#x27;\xB5&#x27;, &#x27;\x5E&#x27;, &#x27;\x0&#x27;, &#x27;\x3&#x27;,</span><br><span class="line">  &#x27;h&#x27;, &#x27;\x9A&#x27;, &#x27;\xC6&#x27;, &#x27;\x16&#x27;, &#x27;\x82&#x27;, &#x27;\x20&#x27;, &#x27;X&#x27;, &#x27;R&#x27;,</span><br><span class="line">  &#x27;\x14&#x27;, &#x27;E&#x27;, &#x27;6&#x27;, &#x27;S&#x27;, &#x27;\x94&#x27;, &#x27;\xCB&#x27;, &#x27;e&#x27;, &#x27;x&#x27;,</span><br><span class="line">  &#x27;\xBD&#x27;, &#x27;\x5E&#x27;, &#x27;\xAA&#x27;, &#x27;U&#x27;, &#x27;T&#x27;, &#x27;\x23&#x27;, &#x27;L&#x27;, &#x27;\xC0&#x27;,</span><br><span class="line">  &#x27;\xE0&#x27;, &#x27;\xE2&#x27;, &#x27;\xC1&#x27;, &#x27;\x8F&#x27;, &#x27;\x0&#x27;, &#x27;\x9E&#x27;, &#x27;\xBC&#x27;, &#x27;\x9&#x27;,</span><br><span class="line">  &#x27;A&#x27;, &#x27;\x7C&#x27;, &#x27;\x3E&#x27;, &#x27;\x1F&#x27;, &#x27;\x83&#x27;, &#x27;D&#x27;, &#x27;\x22&#x27;, &#x27;\x11&#x27;,</span><br><span class="line">  &#x27;\xD5&#x27;, &#x27;T&#x27;, &#x27;\x40&#x27;, &#x27;\x3F&#x27;, &#x27;8&#x27;, &#x27;\x80&#x27;, &#x27;w&#x27;, &#x27;\xE5&#x27;,</span><br><span class="line">  &#x27;3&#x27;, &#x27;\x7&#x27;, &#x27;\xB8&#x27;, &#x27;\x5C&#x27;, &#x27;\x2E&#x27;, &#x27;H&#x27;, &#x27;\x92&#x27;, &#x27;\x4&#x27;,</span><br><span class="line">  &#x27;\x87&#x27;, &#x27;\xC3&#x27;, &#x27;\x81&#x27;, &#x27;\x40&#x27;, &#x27;\x20&#x27;, &#x27;\x40&#x27;, &#x27;g&#x27;, &#x27;\x98&#x27;,</span><br><span class="line">  &#x27;\xE9&#x27;, &#x27;6&#x27;, &#x27;\x1A&#x27;, &#x27;\xA6&#x27;, &#x27;g&#x27;, &#x27;\x15&#x27;, &#x27;\x4&#x27;, &#x27;\xE3&#x27;,</span><br><span class="line">  &#x27;\xD7&#x27;, &#x27;\xC8&#x27;, &#x27;\xBD&#x27;, &#x27;\x15&#x27;, &#x27;\xE1&#x27;, &#x27;i&#x27;, &#x27;\xB7&#x27;, &#x27;C&#x27;,</span><br><span class="line">  &#x27;\xAB&#x27;, &#x27;\xEA&#x27;, &#x27;x&#x27;, &#x27;\x2F&#x27;, &#x27;j&#x27;, &#x27;X&#x27;, &#x27;\x92&#x27;, &#x27;\xBB&#x27;,</span><br><span class="line">  &#x27;\x18&#x27;, &#x27;\x20&#x27;, &#x27;\x9F&#x27;, &#x27;\xCF&#x27;, &#x27;3&#x27;, &#x27;\xC3&#x27;, &#x27;\xB8&#x27;, &#x27;\xE9&#x27;,</span><br><span class="line">  &#x27;N&#x27;, &#x27;\xA7&#x27;, &#x27;\xD3&#x27;, &#x27;l&#x27;, &#x27;J&#x27;, &#x27;\x0&#x27;, &#x27;i&#x27;, &#x27;6&#x27;,</span><br><span class="line">  &#x27;\x7C&#x27;, &#x27;\x8E&#x27;, &#x27;\xE1&#x27;, &#x27;\xFE&#x27;, &#x27;V&#x27;, &#x27;\x84&#x27;, &#x27;\xE7&#x27;, &#x27;\x3C&#x27;,</span><br><span class="line">  &#x27;\x9F&#x27;, &#x27;r&#x27;, &#x27;\x2B&#x27;, &#x27;\x3A&#x27;, &#x27;B&#x27;, &#x27;\x7B&#x27;, &#x27;7&#x27;, &#x27;f&#x27;,</span><br><span class="line">  &#x27;w&#x27;, &#x27;\xAE&#x27;, &#x27;\x8E&#x27;, &#x27;\xE&#x27;, &#x27;\xF3&#x27;, &#x27;\xBD&#x27;, &#x27;R&#x27;, &#x27;\xA9&#x27;,</span><br><span class="line">  &#x27;d&#x27;, &#x27;\x2&#x27;, &#x27;B&#x27;, &#x27;\xAF&#x27;, &#x27;\x85&#x27;, &#x27;2&#x27;, &#x27;f&#x27;, &#x27;F&#x27;,</span><br><span class="line">  &#x27;\xBA&#x27;, &#x27;\xC&#x27;, &#x27;\xD9&#x27;, &#x27;\x9F&#x27;, &#x27;\x1D&#x27;, &#x27;\x9A&#x27;, &#x27;l&#x27;, &#x27;\x22&#x27;,</span><br><span class="line">  &#x27;\xE6&#x27;, &#x27;\xC7&#x27;, &#x27;\x3A&#x27;, &#x27;\x2C&#x27;, &#x27;\x80&#x27;, &#x27;\xEF&#x27;, &#x27;\xC1&#x27;, &#x27;\x15&#x27;,</span><br><span class="line">  &#x27;\x90&#x27;, &#x27;\x7&#x27;, &#x27;\x93&#x27;, &#x27;\xA2&#x27;, &#x27;\x28&#x27;, &#x27;\xA0&#x27;, &#x27;S&#x27;, &#x27;j&#x27;,</span><br><span class="line">  &#x27;\xB1&#x27;, &#x27;\xB8&#x27;, &#x27;\xDF&#x27;, &#x27;\x29&#x27;, &#x27;5&#x27;, &#x27;C&#x27;, &#x27;\xE&#x27;, &#x27;\x3F&#x27;,</span><br><span class="line">  &#x27;X&#x27;, &#x27;\xFC&#x27;, &#x27;\x98&#x27;, &#x27;\xDA&#x27;, &#x27;y&#x27;, &#x27;j&#x27;, &#x27;P&#x27;, &#x27;\x40&#x27;,</span><br><span class="line">  &#x27;\x0&#x27;, &#x27;\x87&#x27;, &#x27;\xAE&#x27;, &#x27;\x1B&#x27;, &#x27;\x17&#x27;, &#x27;B&#x27;, &#x27;\xB4&#x27;, &#x27;\x3A&#x27;,</span><br><span class="line">  &#x27;\x3F&#x27;, &#x27;\xBE&#x27;, &#x27;y&#x27;, &#x27;\xC7&#x27;, &#x27;\xA&#x27;, &#x27;\x26&#x27;, &#x27;\xB6&#x27;, &#x27;\xEE&#x27;,</span><br><span class="line">  &#x27;\xD9&#x27;, &#x27;\x9A&#x27;, &#x27;\x60&#x27;, &#x27;\x14&#x27;, &#x27;\x93&#x27;, &#x27;\xDB&#x27;, &#x27;\x8F&#x27;, &#x27;\xD&#x27;,</span><br><span class="line">  &#x27;\xA&#x27;, &#x27;\x2E&#x27;, &#x27;\xE9&#x27;, &#x27;\x23&#x27;, &#x27;\x95&#x27;, &#x27;\x29&#x27;, &#x27;X&#x27;, &#x27;\x0&#x27;,</span><br><span class="line">  &#x27;\x27&#x27;, &#x27;\xEB&#x27;, &#x27;n&#x27;, &#x27;V&#x27;, &#x27;p&#x27;, &#x27;\xBC&#x27;, &#x27;\xD6&#x27;, &#x27;\xCB&#x27;,</span><br><span class="line">  &#x27;\xD6&#x27;, &#x27;G&#x27;, &#x27;\xAB&#x27;, &#x27;\x3D&#x27;, &#x27;l&#x27;, &#x27;\x7D&#x27;, &#x27;\xB8&#x27;, &#x27;\xD2&#x27;,</span><br><span class="line">  &#x27;\xDD&#x27;, &#x27;\xA0&#x27;, &#x27;\x60&#x27;, &#x27;\x83&#x27;, &#x27;\xBA&#x27;, &#x27;\xEF&#x27;, &#x27;\x5F&#x27;, &#x27;\xA4&#x27;,</span><br><span class="line">  &#x27;\xEA&#x27;, &#x27;\xCC&#x27;, &#x27;\x2&#x27;, &#x27;N&#x27;, &#x27;\xAE&#x27;, &#x27;\x5E&#x27;, &#x27;p&#x27;, &#x27;\x1A&#x27;,</span><br><span class="line">  &#x27;\xEC&#x27;, &#x27;\xB3&#x27;, &#x27;\x40&#x27;, &#x27;9&#x27;, &#x27;\xAC&#x27;, &#x27;\xFE&#x27;, &#x27;\xF2&#x27;, &#x27;\x91&#x27;,</span><br><span class="line">  &#x27;\x89&#x27;, &#x27;g&#x27;, &#x27;\x91&#x27;, &#x27;\x85&#x27;, &#x27;\x21&#x27;, &#x27;\xA8&#x27;, &#x27;\x87&#x27;, &#x27;\xB7&#x27;,</span><br><span class="line">  &#x27;X&#x27;, &#x27;\x7E&#x27;, &#x27;\x7E&#x27;, &#x27;\x85&#x27;, &#x27;\xBB&#x27;, &#x27;\xCD&#x27;, &#x27;N&#x27;, &#x27;N&#x27;,</span><br><span class="line">  &#x27;b&#x27;, &#x27;t&#x27;, &#x27;\x40&#x27;, &#x27;\xFA&#x27;, &#x27;\x93&#x27;, &#x27;\x89&#x27;, &#x27;\xEC&#x27;, &#x27;\x1E&#x27;,</span><br><span class="line">  &#x27;\xEC&#x27;, &#x27;\x86&#x27;, &#x27;\x2&#x27;, &#x27;H&#x27;, &#x27;\x26&#x27;, &#x27;\x93&#x27;, &#x27;\xD0&#x27;, &#x27;u&#x27;,</span><br><span class="line">  &#x27;\x1D&#x27;, &#x27;\x7F&#x27;, &#x27;\x9&#x27;, &#x27;2&#x27;, &#x27;\x95&#x27;, &#x27;\xBF&#x27;, &#x27;\x1F&#x27;, &#x27;\xDB&#x27;,</span><br><span class="line">  &#x27;\xD7&#x27;, &#x27;c&#x27;, &#x27;\x8A&#x27;, &#x27;\x1A&#x27;, &#x27;\xF7&#x27;, &#x27;\x5C&#x27;, &#x27;\xC1&#x27;, &#x27;\xFF&#x27;,</span><br><span class="line">  &#x27;\x22&#x27;, &#x27;J&#x27;, &#x27;\xC3&#x27;, &#x27;\x87&#x27;, &#x27;\x0&#x27;, &#x27;\x3&#x27;, &#x27;\x0&#x27;, &#x27;K&#x27;,</span><br><span class="line">  &#x27;\xBB&#x27;, &#x27;\xF8&#x27;, &#x27;\xD6&#x27;, &#x27;\x2A&#x27;, &#x27;v&#x27;, &#x27;\x98&#x27;, &#x27;I&#x27;, &#x27;\x0&#x27;,</span><br><span class="line">  &#x27;\x0&#x27;, &#x27;\x0&#x27;, &#x27;\x0&#x27;, &#x27;I&#x27;, &#x27;E&#x27;, &#x27;N&#x27;, &#x27;D&#x27;, &#x27;\xAE&#x27;,</span><br><span class="line">  &#x27;B&#x27;, &#x27;\x60&#x27;, &#x27;\x82&#x27;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/20/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%886%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/20/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%886%EF%BC%89/" class="post-title-link" itemprop="url">muduo-网络库（6）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-20 10:44:58" itemprop="dateCreated datePublished" datetime="2023-08-20T10:44:58+08:00">2023-08-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-24 14:43:49" itemprop="dateModified" datetime="2023-08-24T14:43:49+08:00">2023-08-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="完善TcpConnection"><a href="#完善TcpConnection" class="headerlink" title="完善TcpConnection"></a>完善TcpConnection</h1><h2 id="WriteCompleteCallback含义"><a href="#WriteCompleteCallback含义" class="headerlink" title="WriteCompleteCallback含义"></a>WriteCompleteCallback含义</h2><p><strong>对于大流量的数据</strong><br>不断生成数据,然后发送conn.&gt;send2.<br>如果对等方接受不及时，受到通告窗口的控制，内核发送缓冲不足，这个时候，就会将用户数据添加到应用层发送缓冲区(output buffer);可能会撑爆output buffer.<br>解决方法就是,调整发送频率。<br>关注WriteCompleteCallback<br>当所有的用户数据都拷贝到内核缓冲区，WriteCompleteCallback回调，然后继续发送。output buffer被清空也会回调该函数，可以理解为低水位标回调函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WriteCompleteCallback writeCompleteCallback_;//当所有的用户数据都拷贝到内核缓冲区，WriteCompleteCallback回调，然后继续发送。</span><br><span class="line">                                              //output buffer被清空也会回调该函数（也就是所有的用户数据都拷贝到内核缓冲区），可以理解为低水位标回调函数。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">void TcpConnection::sendInLoop(const void* data, size_t len)</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  ssize_t nwrote = 0;</span><br><span class="line">  size_t remaining = len;</span><br><span class="line">  bool faultError = false;</span><br><span class="line">  if (state_ == kDisconnected)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_WARN &lt;&lt; &quot;disconnected, give up writing&quot;;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  // if no thing in output queue, try writing directly</span><br><span class="line">  //通道没有关注可写事件并且发送缓冲区没有数据，直接write</span><br><span class="line">  if (!channel_-&gt;isWriting() &amp;&amp; outputBuffer_.readableBytes() == 0)</span><br><span class="line">  &#123;</span><br><span class="line">    nwrote = sockets::write(channel_-&gt;fd(), data, len);</span><br><span class="line">    if (nwrote &gt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">      remaining = len - nwrote;</span><br><span class="line">      //写完了，回调writeCompleteCallback_</span><br><span class="line">      if (remaining == 0 &amp;&amp; writeCompleteCallback_)</span><br><span class="line">      &#123;</span><br><span class="line">        loop_-&gt;queueInLoop(std::bind(writeCompleteCallback_, shared_from_this()));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else // nwrote &lt; 0</span><br><span class="line">    &#123;</span><br><span class="line">      nwrote = 0;</span><br><span class="line">      if (errno != EWOULDBLOCK)</span><br><span class="line">      &#123;</span><br><span class="line">        LOG_SYSERR &lt;&lt; &quot;TcpConnection::sendInLoop&quot;;</span><br><span class="line">        if (errno == EPIPE || errno == ECONNRESET) // FIXME: any others?</span><br><span class="line">        &#123;</span><br><span class="line">          faultError = true;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert(remaining &lt;= len);</span><br><span class="line">  //没有错误，并且还有未写完的数据（说明内核发送缓冲区满，要将未写完的数据添加到output buffer中)</span><br><span class="line">  if (!faultError &amp;&amp; remaining &gt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    size_t oldLen = outputBuffer_.readableBytes();</span><br><span class="line">    //如果超过highwaterMark_(高水位标)，回调highwaterMarkCallback_</span><br><span class="line">    if (oldLen + remaining &gt;= highWaterMark_</span><br><span class="line">        &amp;&amp; oldLen &lt; highWaterMark_</span><br><span class="line">        &amp;&amp; highWaterMarkCallback_)</span><br><span class="line">    &#123;</span><br><span class="line">      loop_-&gt;queueInLoop(std::bind(highWaterMarkCallback_, shared_from_this(), oldLen + remaining));</span><br><span class="line">    &#125;</span><br><span class="line">    outputBuffer_.append(static_cast&lt;const char*&gt;(data)+nwrote, remaining);</span><br><span class="line">    if (!channel_-&gt;isWriting())</span><br><span class="line">    &#123;</span><br><span class="line">      channel_-&gt;enableWriting();//关注pollout事件 </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//当内核发送缓冲区有空间了，pollout事件触发就会回调该函数</span><br><span class="line">  //通道可写事件到来的时候，回调TcpConnection::handleWrite</span><br><span class="line">  channel_-&gt;setWriteCallback(</span><br><span class="line">      std::bind(&amp;TcpConnection::handleWrite, this));</span><br><span class="line"></span><br><span class="line">void TcpConnection::handleWrite()</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  if (channel_-&gt;isWriting())</span><br><span class="line">  &#123;</span><br><span class="line">    ssize_t n = sockets::write(channel_-&gt;fd(),</span><br><span class="line">                               outputBuffer_.peek(),</span><br><span class="line">                               outputBuffer_.readableBytes());</span><br><span class="line">    if (n &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      outputBuffer_.retrieve(n);</span><br><span class="line">      if (outputBuffer_.readableBytes() == 0)//发送缓冲区已清空</span><br><span class="line">      &#123;</span><br><span class="line">        channel_-&gt;disableWriting();//停止关注pollout事件，以免出现busyloop</span><br><span class="line">        if (writeCompleteCallback_)//回调writeCompleteCallback_</span><br><span class="line">        &#123;</span><br><span class="line">          //应用层发送缓冲区已被清空，就回调用writeCompleteCallback_</span><br><span class="line">          loop_-&gt;queueInLoop(std::bind(writeCompleteCallback_, shared_from_this()));</span><br><span class="line">        &#125;</span><br><span class="line">        if (state_ == kDisconnecting)//发送缓冲区已被清空并且连接状态是kDisconnecting，要关闭连接</span><br><span class="line">        &#123;</span><br><span class="line">          shutdownInLoop();//关闭连接</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      LOG_SYSERR &lt;&lt; &quot;TcpConnection::handleWrite&quot;;</span><br><span class="line">      // if (state_ == kDisconnecting)</span><br><span class="line">      // &#123;</span><br><span class="line">      //   shutdownInLoop();</span><br><span class="line">      // &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_TRACE &lt;&lt; &quot;Connection fd = &quot; &lt;&lt; channel_-&gt;fd()</span><br><span class="line">              &lt;&lt; &quot; is down, no more writing&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="HighWaterMarkCallback含义"><a href="#HighWaterMarkCallback含义" class="headerlink" title="HighWaterMarkCallback含义"></a>HighWaterMarkCallback含义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HighWaterMarkCallback highWaterMarkCallback_;//高水位标回调函数，也就是output buffer撑到一定程度回调该函数</span><br></pre></td></tr></table></figure>

<h2 id="boost-any-context"><a href="#boost-any-context" class="headerlink" title="boost::any context_"></a>boost::any context_</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void setContext(const boost::any&amp; context)</span><br><span class="line">  &#123; context_ = context; &#125;</span><br><span class="line"></span><br><span class="line">  const boost::any&amp; getContext() const//外部不可以更改</span><br><span class="line">  &#123; return context_; &#125;</span><br><span class="line"></span><br><span class="line">  boost::any* getMutableContext()//可以更改</span><br><span class="line">  &#123; return &amp;context_; &#125;</span><br><span class="line">  boost::any context_;//你可以使用C++17中引入的std::any来替代boost::any，绑定一个未知类型的上下文对象</span><br></pre></td></tr></table></figure>

<h2 id="std-any"><a href="#std-any" class="headerlink" title="std::any"></a>std::any</h2><p>可以使用C++17中引入的std::any来替代boost::any，绑定一个未知类型的上下文对象</p>
<p><code>std::any context_;</code>的目的是创建一个可以存储任意类型对象的变量。</p>
<p>使用<code>std::any</code>可以在不事先知道对象类型的情况下，将其存储在一个统一的容器中。</p>
<p><code>std::any</code>提供了以下功能：</p>
<ol>
<li>存储任意类型的对象：你可以将任何类型的对象赋值给<code>context_</code>，无论是内置类型（例如int、float）还是自定义类型。</li>
<li>类型安全的访问：你可以使用<code>std::any_cast</code>函数来安全地将对象从<code>std::any</code>中检索出来，并进行类型转换。如果尝试将<code>std::any</code>中存储的对象转换为与实际类型不匹配的类型，将会抛出<code>std::bad_any_cast</code>异常。</li>
<li>空状态检查：你可以使用<code>std::any</code>的<code>has_value</code>函数来检查它是否包含了一个有效的对象。</li>
</ol>
<p><code>std::any</code>的灵活性使得它可以用于各种情况，特别适用于需要在运行时处理不同类型对象的场景，例如实现插件系统、通用数据结构等</p>
<h2 id="signal-SIGPIPE-SIG-IGN"><a href="#signal-SIGPIPE-SIG-IGN" class="headerlink" title="signal(SIGPIPE, SIG_IGN)"></a>signal(SIGPIPE, SIG_IGN)</h2><p>EvenLoop.cc中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#pragma GCC diagnostic ignored &quot;-Wold-style-cast&quot;</span><br><span class="line">//编译器不会发出或记录与这种旧式的类型转换相关的警告信息。</span><br><span class="line">//这是因为这段代码中可能使用了旧式的C风格类型转换，而该警告可以帮助开发者避免一些潜在的问题</span><br><span class="line">//封装了系统调用</span><br><span class="line">class IgnoreSigPipe</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  IgnoreSigPipe()</span><br><span class="line">  &#123;</span><br><span class="line">    ::signal(SIGPIPE, SIG_IGN);</span><br><span class="line">    // LOG_TRACE &lt;&lt; &quot;Ignore SIGPIPE&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">#pragma GCC diagnostic error &quot;-Wold-style-cast&quot;</span><br><span class="line">//如果后面的代码中出现了旧式的类型转换，编译器将会将其作为错误处理，终止编译过程</span><br><span class="line">IgnoreSigPipe initObj;</span><br><span class="line">&#125;// namespace 代码被放置在了匿名的 namespace 中。这意味着其中的内容只对当前文件中的代码可见，不会对其他文件中的代码造成影响。这在一定程度上隐藏了实现细节，限制了作用域，并且通过将 IgnoreSigPipe 类声明为 private，限制了类在文件之外的可见性。这样可以帮助控制代码的组织和维护，并减少了潜在的命名冲突。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="可变类型解决方案"><a href="#可变类型解决方案" class="headerlink" title="可变类型解决方案"></a>可变类型解决方案</h2><ul>
<li>void*.这种方法不是类型安全的</li>
<li>boost:any<ul>
<li>任意类型的类型安全存储以及安全的取回</li>
<li>在标准库容器中存放不同类型的方法，比如说<code>vector&lt;boost::any&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">class TestServer&#123;</span><br><span class="line">public:</span><br><span class="line">TestServer(EventLoop*loop,const InetAddress&amp; listenAddr)</span><br><span class="line">			:loop_(loop),</span><br><span class="line">			server(loop,1istenAddr,&quot;TestServer&quot;)</span><br><span class="line">	&#123;</span><br><span class="line">		server_.setconnectionCa11back(</span><br><span class="line">			boost::bind(&amp;Testserver::onConnection,this，_1));</span><br><span class="line">		server_.setMessageCa11back(</span><br><span class="line">			boost::bind(&amp;TestServer::onMessage, this，_1,_2,_3));</span><br><span class="line">		server_.setWriteCompleteCallback(</span><br><span class="line">			boost::bind(&amp;TestServer::onWriteComplete, this，_1));</span><br><span class="line">		//生成数据</span><br><span class="line">		string line;</span><br><span class="line">		for (int i = 33; i &lt; 127;++i)&#123;</span><br><span class="line">			line.push_back(char(i));</span><br><span class="line">		&#125;</span><br><span class="line">		line += line;</span><br><span class="line">		for (size_t i =0 ; i &lt; 127-33; ++i)&#123;</span><br><span class="line">			message_ += line.substr(i,72)+ &#x27;\n&#x27;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	void start()&#123;</span><br><span class="line">		server_.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	void:onConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">	&#123;</span><br><span class="line">		if( conn-&gt;connected())&#123;</span><br><span class="line">			printf(&quot;onconnection(): new connettion [%s]from %s\n&quot;,</span><br><span class="line">				conn-&gt;name()-&gt;c_str(),</span><br><span class="line">				conn-&gt;peerAddress().toIpPort().c_str());</span><br><span class="line">			conn-&gt;setTcpNoDelay(true);</span><br><span class="line">			conn-&gt;send(message_);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			printf(&quot;onconnection():connettion [%s] is down\n&quot;,</span><br><span class="line">				conn-&gt;name()-&gt;c_str());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	void onMessage(const TcpConnectionPtr&amp; conn,</span><br><span class="line">					Buffer* buf,</span><br><span class="line">					Timestamp receiveTime)</span><br><span class="line">	&#123;</span><br><span class="line">		muduo::string msg(buf-&gt;retrieveAllAsString());</span><br><span class="line">		printf(&quot;onMessage(): received %zd bytes from connection [%s] at %s\n&quot;,</span><br><span class="line">				msg.size(),</span><br><span class="line">				conn-&gt;name().c_str(),</span><br><span class="line">				receiveTime.toFormattedString().c_str());</span><br><span class="line">		conn-&gt;send(msg);</span><br><span class="line">	&#125;</span><br><span class="line">	void onWriteComplete(const TcpConnectionPtr&amp; conn)</span><br><span class="line">	&#123;</span><br><span class="line">		conn-&gt;send(message_);</span><br><span class="line">	&#125;</span><br><span class="line">	EventLoop* loop_;</span><br><span class="line">	TcpServer server_;</span><br><span class="line">	muduo::string message_;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">	printf( &quot;main(): pid = %d\n&quot;,getpid());</span><br><span class="line">	InetAddress listenAddr(8888);</span><br><span class="line">	EventLoop loop;</span><br><span class="line">	TestServer server(&amp;loop,listenAddr);</span><br><span class="line">	server.start();</span><br><span class="line">	loop.loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段示例代码可以实现chargen服务程序</p>
<p>“chargen” 是指字符发生器（Character Generator）服务程序。它是一种网络服务，最初用于测试和诊断网络连接。</p>
<p>chargen 服务程序会向连接到它的客户端发送一系列 ASCII 字符。这些字符通常是可打印字符的连续序列，如字母、数字和标点符号等。服务程序以循环的方式生成字符，并不停地发送给客户端，直到连接关闭为止。</p>
<p>chargen 服务通常用于测试网络传输的稳定性和性能。通过向客户端发送大量的字符数据，可以模拟网络流量的负载情况。这对于查找网络传输问题、测量网络带宽的上限以及评估系统的抗压能力等方面非常有用。</p>
<p>然而，由于 chargen 服务产生大量的网络流量，可能会导致网络拥塞和安全问题。因此，在实际应用中，chargen 服务通常不会被广泛使用，并且在许多系统中默认关闭或禁用。可以用于进行DoS攻击。</p>
<h1 id="muduo库对编写tcp客户端程序的支持"><a href="#muduo库对编写tcp客户端程序的支持" class="headerlink" title="muduo库对编写tcp客户端程序的支持"></a>muduo库对编写tcp客户端程序的支持</h1><h2 id="Connector-h"><a href="#Connector-h" class="headerlink" title="Connector.h"></a>Connector.h</h2><p>主动发起连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_NET_CONNECTOR_H</span><br><span class="line">#define MUDUO_NET_CONNECTOR_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/noncopyable.h&quot;</span><br><span class="line">#include &quot;muduo/net/InetAddress.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">class Channel;</span><br><span class="line">class EventLoop;</span><br><span class="line"></span><br><span class="line">//主动发起连接，带有自动重连功能</span><br><span class="line">class Connector : noncopyable,</span><br><span class="line">                  public std::enable_shared_from_this&lt;Connector&gt;</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  typedef std::function&lt;void (int sockfd)&gt; NewConnectionCallback;</span><br><span class="line"></span><br><span class="line">  Connector(EventLoop* loop, const InetAddress&amp; serverAddr);</span><br><span class="line">  ~Connector();</span><br><span class="line"></span><br><span class="line">  void setNewConnectionCallback(const NewConnectionCallback&amp; cb)</span><br><span class="line">  &#123; newConnectionCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line">  void start();  // can be called in any thread</span><br><span class="line">  void restart();  // must be called in loop thread</span><br><span class="line">  void stop();  // can be called in any thread</span><br><span class="line"></span><br><span class="line">  const InetAddress&amp; serverAddress() const &#123; return serverAddr_; &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  enum States &#123; kDisconnected, kConnecting, kConnected &#125;;</span><br><span class="line">  static const int kMaxRetryDelayMs = 30*1000;//38秒，最大重连延迟时间</span><br><span class="line">  static const int kInitRetryDelayMs = 500;  //0.5秒，初始状态，连接不上，0.5秒后重连</span><br><span class="line"></span><br><span class="line">  void setState(States s) &#123; state_ = s; &#125;</span><br><span class="line">  void startInLoop();</span><br><span class="line">  void stopInLoop();</span><br><span class="line">  void connect();</span><br><span class="line">  void connecting(int sockfd);</span><br><span class="line">  void handleWrite();</span><br><span class="line">  void handleError();</span><br><span class="line">  void retry(int sockfd);</span><br><span class="line">  int removeAndResetChannel();</span><br><span class="line">  void resetChannel();</span><br><span class="line"></span><br><span class="line">  EventLoop* loop_;//所属EventLoop</span><br><span class="line">  InetAddress serverAddr_;//服务器端地址</span><br><span class="line">  bool connect_; // atomic</span><br><span class="line">  States state_;  // FIXME: use atomic variable</span><br><span class="line">  std::unique_ptr&lt;Channel&gt; channel_;//connector所对应的Channel</span><br><span class="line">  NewConnectionCallback newConnectionCallback_;//连接成功回调函数</span><br><span class="line">  int retryDelayMs_;//重连延迟时间（单位：毫秒）</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_NET_CONNECTOR_H</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Connector-cc"><a href="#Connector-cc" class="headerlink" title="Connector.cc"></a>Connector.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line">//可以跨线程调用</span><br><span class="line">void Connector::start()</span><br><span class="line">&#123;</span><br><span class="line">  connect_ = true;</span><br><span class="line">  loop_-&gt;runInLoop(std::bind(&amp;Connector::startInLoop, this)); // FIXME: unsafe</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Connector::startInLoop()</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  assert(state_ == kDisconnected);</span><br><span class="line">  if (connect_)</span><br><span class="line">  &#123;</span><br><span class="line">    connect();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_DEBUG &lt;&lt; &quot;do not connect&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Connector::stop()</span><br><span class="line">&#123;</span><br><span class="line">  connect_ = false;</span><br><span class="line">  loop_-&gt;queueInLoop(std::bind(&amp;Connector::stopInLoop, this)); // FIXME: unsafe</span><br><span class="line">  // FIXME: cancel timer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Connector::stopInLoop()</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  if (state_ == kConnecting)</span><br><span class="line">  &#123;</span><br><span class="line">    setState(kDisconnected);</span><br><span class="line">    int sockfd = removeAndResetChannel();//将通道从poller中移除关注，并将channel置空</span><br><span class="line">    retry(sockfd);//这里并非要重连，只是调用sockets::close(sockfd);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Connector::connect()</span><br><span class="line">&#123;</span><br><span class="line">  int sockfd = sockets::createNonblockingOrDie(serverAddr_.family());//创建非阻塞套接字</span><br><span class="line">  int ret = sockets::connect(sockfd, serverAddr_.getSockAddr());</span><br><span class="line">  int savedErrno = (ret == 0) ? 0 : errno;</span><br><span class="line">  switch (savedErrno)</span><br><span class="line">  &#123;</span><br><span class="line">    case 0:</span><br><span class="line">    case EINPROGRESS://非阻塞套接字，未连接成功返回码是EINPROGRESs表示正在连接</span><br><span class="line">    case EINTR:</span><br><span class="line">    case EISCONN:   //连接成功</span><br><span class="line">      connecting(sockfd);</span><br><span class="line">      break;</span><br><span class="line"></span><br><span class="line">    case EAGAIN:</span><br><span class="line">    case EADDRINUSE:</span><br><span class="line">    case EADDRNOTAVAIL:</span><br><span class="line">    case ECONNREFUSED:</span><br><span class="line">    case ENETUNREACH:</span><br><span class="line">      retry(sockfd);//重连</span><br><span class="line">      break;</span><br><span class="line"></span><br><span class="line">    case EACCES:</span><br><span class="line">    case EPERM:</span><br><span class="line">    case EAFNOSUPPORT:</span><br><span class="line">    case EALREADY:</span><br><span class="line">    case EBADF:</span><br><span class="line">    case EFAULT:</span><br><span class="line">    case ENOTSOCK:</span><br><span class="line">      LOG_SYSERR &lt;&lt; &quot;connect error in Connector::startInLoop &quot; &lt;&lt; savedErrno;</span><br><span class="line">      sockets::close(sockfd);//不能重连，关闭sockfd</span><br><span class="line">      break;</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">      LOG_SYSERR &lt;&lt; &quot;Unexpected error in Connector::startInLoop &quot; &lt;&lt; savedErrno;</span><br><span class="line">      sockets::close(sockfd);</span><br><span class="line">      // connectErrorCallback_();</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Connector::restart()</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  setState(kDisconnected);</span><br><span class="line">  retryDelayMs_ = kInitRetryDelayMs;</span><br><span class="line">  connect_ = true;</span><br><span class="line">  startInLoop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Connector::connecting(int sockfd)</span><br><span class="line">&#123;</span><br><span class="line">  setState(kConnecting);</span><br><span class="line">  assert(!channel_);</span><br><span class="line">  //channel与sockfd关联</span><br><span class="line">  channel_.reset(new Channel(loop_, sockfd));</span><br><span class="line">  //设置可写回调函数，这时候如果socket没有错误，sockfd就处于可写状态</span><br><span class="line">  channel_-&gt;setWriteCallback(</span><br><span class="line">      std::bind(&amp;Connector::handleWrite, this)); // FIXME: unsafe</span><br><span class="line">  channel_-&gt;setErrorCallback(</span><br><span class="line">      std::bind(&amp;Connector::handleError, this)); // FIXME: unsafe</span><br><span class="line"></span><br><span class="line">  // channel_-&gt;tie(shared_from_this()); is not working,</span><br><span class="line">  // as channel_ is not managed by shared_ptr</span><br><span class="line">  channel_-&gt;enableWriting();//让poller关注可写事件</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Connector::removeAndResetChannel()</span><br><span class="line">&#123;</span><br><span class="line">  channel_-&gt;disableAll();</span><br><span class="line">  channel_-&gt;remove();</span><br><span class="line">  int sockfd = channel_-&gt;fd();</span><br><span class="line">  // Can&#x27;t reset channel_ here, because we are inside Channel::handleEvent</span><br><span class="line">  //不能在这里重置channel_，因为正在调用Channel::handleEvent</span><br><span class="line">  loop_-&gt;queueInLoop(std::bind(&amp;Connector::resetChannel, this)); // FIXME: unsafe</span><br><span class="line">  return sockfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Connector::resetChannel()</span><br><span class="line">&#123;</span><br><span class="line">  channel_.reset();//channle_置空</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Connector::handleWrite()</span><br><span class="line">&#123;</span><br><span class="line">  LOG_TRACE &lt;&lt; &quot;Connector::handleWrite &quot; &lt;&lt; state_;</span><br><span class="line"></span><br><span class="line">  if (state_ == kConnecting)</span><br><span class="line">  &#123;</span><br><span class="line">    int sockfd = removeAndResetChannel();//从poller中移除关注，并将channel置空</span><br><span class="line">    //socket可写并不意味着连接一定建立成功</span><br><span class="line">    //还需要用getsockopt(sockfd, SOL_SOCKET，SO_ERROR，.….)再次确认一下.</span><br><span class="line">    int err = sockets::getSocketError(sockfd);</span><br><span class="line">    if (err)</span><br><span class="line">    &#123;</span><br><span class="line">      LOG_WARN &lt;&lt; &quot;Connector::handleWrite - SO_ERROR = &quot;</span><br><span class="line">               &lt;&lt; err &lt;&lt; &quot; &quot; &lt;&lt; strerror_tl(err);</span><br><span class="line">      retry(sockfd);//重连</span><br><span class="line">    &#125;</span><br><span class="line">    //sockets::isSelfConnect函数的作用是通过比较本地地址和对端地址的端口号和IP地址，判断一个连接是否为自连接</span><br><span class="line">    //在网络编程中，自连接指的是本地主机与自身之间建立的连接。这种情况通常发生在客户端和服务器运行在同一台主机上，且使用相同的地址和端口进行通信的情况下</span><br><span class="line">    else if (sockets::isSelfConnect(sockfd))//自连接</span><br><span class="line">    &#123;</span><br><span class="line">      LOG_WARN &lt;&lt; &quot;Connector::handleWrite - Self connect&quot;;</span><br><span class="line">      retry(sockfd);//重连</span><br><span class="line">    &#125;</span><br><span class="line">    else//连接成功</span><br><span class="line">    &#123;</span><br><span class="line">      setState(kConnected);</span><br><span class="line">      if (connect_)</span><br><span class="line">      &#123;</span><br><span class="line">        newConnectionCallback_(sockfd);//回调</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        sockets::close(sockfd);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    // what happened?</span><br><span class="line">    assert(state_ == kDisconnected);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Connector::handleError()</span><br><span class="line">&#123;</span><br><span class="line">  LOG_ERROR &lt;&lt; &quot;Connector::handleError state=&quot; &lt;&lt; state_;</span><br><span class="line">  if (state_ == kConnecting)</span><br><span class="line">  &#123;</span><br><span class="line">    int sockfd = removeAndResetChannel();//从poller中移除关注，并将channel置空</span><br><span class="line">    //需要移除对可写事件的关注的原因是已经建立了与服务器的连接。在连接成功后，我们不再需要关注套接字是否可写，因为我们已经知道它是可写的。移除对可写事件的关注可以减少不必要的事件通知和资源消耗</span><br><span class="line">    int err = sockets::getSocketError(sockfd);</span><br><span class="line">    LOG_TRACE &lt;&lt; &quot;SO_ERROR = &quot; &lt;&lt; err &lt;&lt; &quot; &quot; &lt;&lt; strerror_tl(err);</span><br><span class="line">    retry(sockfd);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//采用back-off策略重连，即重连时间逐渐延长，0.5s，1s，2s，...直至30s</span><br><span class="line">void Connector::retry(int sockfd)</span><br><span class="line">&#123;</span><br><span class="line">  sockets::close(sockfd);</span><br><span class="line">  setState(kDisconnected);</span><br><span class="line">  if (connect_)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_INFO &lt;&lt; &quot;Connector::retry - Retry connecting to &quot; &lt;&lt; serverAddr_.toIpPort()</span><br><span class="line">             &lt;&lt; &quot; in &quot; &lt;&lt; retryDelayMs_ &lt;&lt; &quot; milliseconds. &quot;;</span><br><span class="line">    //注册一个定时操作，重连</span><br><span class="line">    loop_-&gt;runAfter(retryDelayMs_/1000.0,</span><br><span class="line">                    std::bind(&amp;Connector::startInLoop, shared_from_this()));</span><br><span class="line">    retryDelayMs_ = std::min(retryDelayMs_ * 2, kMaxRetryDelayMs);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_DEBUG &lt;&lt; &quot;do not connect&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="TcpClient-h"><a href="#TcpClient-h" class="headerlink" title="TcpClient.h"></a>TcpClient.h</h2><p>包含了一个Connector对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_NET_TCPCLIENT_H</span><br><span class="line">#define MUDUO_NET_TCPCLIENT_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Mutex.h&quot;</span><br><span class="line">#include &quot;muduo/net/TcpConnection.h&quot;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">class Connector;</span><br><span class="line">typedef std::shared_ptr&lt;Connector&gt; ConnectorPtr;</span><br><span class="line"></span><br><span class="line">class TcpClient : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  // TcpClient(EventLoop* loop);</span><br><span class="line">  // TcpClient(EventLoop* loop, const string&amp; host, uint16_t port);</span><br><span class="line">  TcpClient(EventLoop* loop,</span><br><span class="line">            const InetAddress&amp; serverAddr,</span><br><span class="line">            const string&amp; nameArg);</span><br><span class="line">  ~TcpClient();  // force out-line dtor, for std::unique_ptr members.</span><br><span class="line"></span><br><span class="line">  void connect();</span><br><span class="line">  void disconnect();</span><br><span class="line">  void stop();</span><br><span class="line"></span><br><span class="line">  TcpConnectionPtr connection() const</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    return connection_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  EventLoop* getLoop() const &#123; return loop_; &#125;</span><br><span class="line">  bool retry() const &#123; return retry_; &#125;</span><br><span class="line">  void enableRetry() &#123; retry_ = true; &#125;</span><br><span class="line"></span><br><span class="line">  const string&amp; name() const</span><br><span class="line">  &#123; return name_; &#125;</span><br><span class="line"></span><br><span class="line">  /// Set connection callback.</span><br><span class="line">  /// Not thread safe.</span><br><span class="line">  void setConnectionCallback(ConnectionCallback cb)</span><br><span class="line">  &#123; connectionCallback_ = std::move(cb); &#125;</span><br><span class="line"></span><br><span class="line">  /// Set message callback.</span><br><span class="line">  /// Not thread safe.</span><br><span class="line">  void setMessageCallback(MessageCallback cb)</span><br><span class="line">  &#123; messageCallback_ = std::move(cb); &#125;</span><br><span class="line"></span><br><span class="line">  /// Set write complete callback.</span><br><span class="line">  /// Not thread safe.</span><br><span class="line">  void setWriteCompleteCallback(WriteCompleteCallback cb)</span><br><span class="line">  &#123; writeCompleteCallback_ = std::move(cb); &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  /// Not thread safe, but in loop</span><br><span class="line">  void newConnection(int sockfd);</span><br><span class="line">  /// Not thread safe, but in loop</span><br><span class="line">  void removeConnection(const TcpConnectionPtr&amp; conn);</span><br><span class="line"></span><br><span class="line">  EventLoop* loop_;</span><br><span class="line">  ConnectorPtr connector_; // avoid revealing Connector,用于主动发起连接</span><br><span class="line">  const string name_;//名称</span><br><span class="line">  ConnectionCallback connectionCallback_;//连接建立回调函数</span><br><span class="line">  MessageCallback messageCallback_;//消息到来回调函数</span><br><span class="line">  WriteCompleteCallback writeCompleteCallback_;//数据发送完毕回调函数</span><br><span class="line">  bool retry_;   // atomic，重连，是指连接建立之后又断开的时候是否重连</span><br><span class="line">  bool connect_; // atomic</span><br><span class="line">  // always in loop thread</span><br><span class="line">  int nextConnId_;//name_+nextConnId_用于标识一个连接</span><br><span class="line">  mutable MutexLock mutex_;</span><br><span class="line">  TcpConnectionPtr connection_ GUARDED_BY(mutex_);//Connector连接成功之后，得到一个TcpConnection</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_NET_TCPCLIENT_H</span><br></pre></td></tr></table></figure>

<h2 id="TcpClient-cc"><a href="#TcpClient-cc" class="headerlink" title="TcpClient.cc"></a>TcpClient.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (unique)</span><br><span class="line">&#123;</span><br><span class="line">    conn-&gt;forceClose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>connection_</code> 是唯一引用时，说明当前的 <code>TcpConnection</code> 实例没有其他智能指针指向它，也就意味着没有其他地方在使用这个连接对象。</p>
<p>在正常情况下，当需要关闭连接时，应该先发送TCP终止连接的相关消息（如FIN包），等待对方响应并进行优雅关闭的握手过程。这样可以确保数据的完整性和可靠性。</p>
<p>但是，在某些情况下，可能需要立即关闭连接，而不进行优雅关闭的握手过程。这些情况可能包括：</p>
<ol>
<li>程序逻辑需要：根据具体的业务需求，在某些特定的场景下，需要立即终止连接，而不等待握手过程完成。例如，发生了错误或异常情况，需要立即中断连接以防止进一步的数据传输。</li>
<li>资源回收：当 <code>TcpConnection</code> 对象没有其他引用时，为了及时释放与连接相关的资源，可以选择立即强制关闭连接，而不等待未来可能的操作。</li>
</ol>
<p>因此，当 <code>connection_</code> 是唯一引用时，调用 <code>forceClose()</code> 函数可以立即关闭连接，无需等待握手过程完成，以满足上述需求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line">namespace detail</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">void removeConnection(EventLoop* loop, const TcpConnectionPtr&amp; conn)</span><br><span class="line">&#123;</span><br><span class="line">  loop-&gt;queueInLoop(std::bind(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void removeConnector(const ConnectorPtr&amp; connector)</span><br><span class="line">&#123;</span><br><span class="line">  //connector-&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace detail</span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">TcpClient::TcpClient(EventLoop* loop,</span><br><span class="line">                     const InetAddress&amp; serverAddr,</span><br><span class="line">                     const string&amp; nameArg)</span><br><span class="line">  : loop_(CHECK_NOTNULL(loop)),</span><br><span class="line">    connector_(new Connector(loop, serverAddr)),</span><br><span class="line">    name_(nameArg),</span><br><span class="line">    connectionCallback_(defaultConnectionCallback),</span><br><span class="line">    messageCallback_(defaultMessageCallback),</span><br><span class="line">    retry_(false),</span><br><span class="line">    connect_(true),</span><br><span class="line">    nextConnId_(1)</span><br><span class="line">&#123;</span><br><span class="line">  connector_-&gt;setNewConnectionCallback(</span><br><span class="line">      std::bind(&amp;TcpClient::newConnection, this, _1));</span><br><span class="line">  // FIXME setConnectFailedCallback</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;TcpClient::TcpClient[&quot; &lt;&lt; name_</span><br><span class="line">           &lt;&lt; &quot;] - connector &quot; &lt;&lt; get_pointer(connector_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpClient::~TcpClient()</span><br><span class="line">&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;TcpClient::~TcpClient[&quot; &lt;&lt; name_</span><br><span class="line">           &lt;&lt; &quot;] - connector &quot; &lt;&lt; get_pointer(connector_);</span><br><span class="line">  TcpConnectionPtr conn;</span><br><span class="line">  bool unique = false;</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    unique = connection_.unique();//shared_ptr类的成员函数，用于判断该智能指针是否是唯一引用（即没有其他指针指向相同对象）</span><br><span class="line">    //如果当前智能指针是唯一引用，则返回true；否则，返回false</span><br><span class="line">    conn = connection_;</span><br><span class="line">  &#125;</span><br><span class="line">  if (conn)</span><br><span class="line">  &#123;</span><br><span class="line">    assert(loop_ == conn-&gt;getLoop());</span><br><span class="line">    // FIXME: not 100% safe, if we are in different thread</span><br><span class="line">    //重新设置TcpConnection中的closeCallback_为detail::removeConnection</span><br><span class="line">    CloseCallback cb = std::bind(&amp;detail::removeConnection, loop_, _1);</span><br><span class="line">    //不能调用TcpClient::removeConnection，因为它有重连功能</span><br><span class="line">    loop_-&gt;runInLoop(</span><br><span class="line">        std::bind(&amp;TcpConnection::setCloseCallback, conn, cb));</span><br><span class="line">    if (unique)</span><br><span class="line">    &#123;</span><br><span class="line">      conn-&gt;forceClose();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    //这种情况，说明connector处于未连接状态，将connector_停止</span><br><span class="line">    connector_-&gt;stop();</span><br><span class="line">    // FIXME: HACK</span><br><span class="line">    loop_-&gt;runAfter(1, std::bind(&amp;detail::removeConnector, connector_));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpClient::connect()</span><br><span class="line">&#123;</span><br><span class="line">  // FIXME: check state</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;TcpClient::connect[&quot; &lt;&lt; name_ &lt;&lt; &quot;] - connecting to &quot;</span><br><span class="line">           &lt;&lt; connector_-&gt;serverAddress().toIpPort();</span><br><span class="line">  connect_ = true;</span><br><span class="line">  connector_-&gt;start();</span><br><span class="line">&#125;</span><br><span class="line">//用于连接已建立的情况下，关闭连接</span><br><span class="line">void TcpClient::disconnect()</span><br><span class="line">&#123;</span><br><span class="line">  connect_ = false;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    if (connection_)</span><br><span class="line">    &#123;</span><br><span class="line">      connection_-&gt;shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//停止connector_,可能是连接尚未建立成功</span><br><span class="line">void TcpClient::stop()</span><br><span class="line">&#123;</span><br><span class="line">  connect_ = false;</span><br><span class="line">  connector_-&gt;stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpClient::newConnection(int sockfd)</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  InetAddress peerAddr(sockets::getPeerAddr(sockfd));</span><br><span class="line">  char buf[32];</span><br><span class="line">  snprintf(buf, sizeof buf, &quot;:%s#%d&quot;, peerAddr.toIpPort().c_str(), nextConnId_);</span><br><span class="line">  ++nextConnId_;</span><br><span class="line">  string connName = name_ + buf;</span><br><span class="line"></span><br><span class="line">  InetAddress localAddr(sockets::getLocalAddr(sockfd));</span><br><span class="line">  // FIXME poll with zero timeout to double confirm the new connection</span><br><span class="line">  // FIXME use make_shared if necessary</span><br><span class="line">  TcpConnectionPtr conn(new TcpConnection(loop_,</span><br><span class="line">                                          connName,</span><br><span class="line">                                          sockfd,</span><br><span class="line">                                          localAddr,</span><br><span class="line">                                          peerAddr));</span><br><span class="line"></span><br><span class="line">  conn-&gt;setConnectionCallback(connectionCallback_);</span><br><span class="line">  conn-&gt;setMessageCallback(messageCallback_);</span><br><span class="line">  conn-&gt;setWriteCompleteCallback(writeCompleteCallback_);</span><br><span class="line">  conn-&gt;setCloseCallback(</span><br><span class="line">      std::bind(&amp;TcpClient::removeConnection, this, _1)); // FIXME: unsafe</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    connection_ = conn;//保存TcpConnection</span><br><span class="line">  &#125;</span><br><span class="line">  conn-&gt;connectEstablished();//这里回调connectionCallback_</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpClient::removeConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  assert(loop_ == conn-&gt;getLoop());</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    //GUARDED_BY(mutex_)体现在每次对connection_对象使用的时候都需要保护</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    assert(connection_ == conn);</span><br><span class="line">    connection_.reset();//重置</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  loop_-&gt;queueInLoop(std::bind(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class="line">  if (retry_ &amp;&amp; connect_)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_INFO &lt;&lt; &quot;TcpClient::connect[&quot; &lt;&lt; name_ &lt;&lt; &quot;] - Reconnecting to &quot;</span><br><span class="line">             &lt;&lt; connector_-&gt;serverAddress().toIpPort();</span><br><span class="line">    connector_-&gt;restart();//这里的重连是指连接建立成功之后被断开的重连</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="测试程序-1"><a href="#测试程序-1" class="headerlink" title="测试程序"></a>测试程序</h2><h3 id="TcpClient-test-cc-x2F-x2F-echo-client"><a href="#TcpClient-test-cc-x2F-x2F-echo-client" class="headerlink" title="TcpClient_test.cc &#x2F;&#x2F; echo client"></a>TcpClient_test.cc &#x2F;&#x2F; echo client</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">class TestClient&#123;</span><br><span class="line">public:</span><br><span class="line">	TestClient(EventLoop* loop，const InetAddress&amp; listenaddr)</span><br><span class="line">		:loop_(loop),</span><br><span class="line">		client_(loop.listenAddr,&quot;Testclient&quot;),</span><br><span class="line">		stdinchanne1_(loop，0)</span><br><span class="line">	&#123;</span><br><span class="line">		client_.setConnectionCallback(</span><br><span class="line">			boost::bind(&amp;TestClient::onConnection,this,_1));</span><br><span class="line">		//有消息到来回调函数</span><br><span class="line">		client_.setMessageCa11back(</span><br><span class="line">			boost::bind(&amp;TestClient::onMessage,this,_1,_2,_3));</span><br><span class="line">		//client_.enableRetry();客户端已经建立连接成功，因为某种意外断开，是否能够重连的标志</span><br><span class="line">		//标准输入缓冲区中有数据的时候，回调Testclient::handleRead</span><br><span class="line">		stdinChannel_.setReadCallback(boost::bind(&amp;TestClient::handleRead, this));</span><br><span class="line">		stdinChanne1_.enableReading();</span><br><span class="line">	&#125;</span><br><span class="line">	void connect()&#123;</span><br><span class="line">		client_.connect();</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	void:onConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">	&#123;</span><br><span class="line">		if( conn-&gt;connected())&#123;</span><br><span class="line">			printf(&quot;onconnection(): new connettion [%s]from %s\n&quot;,</span><br><span class="line">				conn-&gt;name()-&gt;c_str(),</span><br><span class="line">				conn-&gt;peerAddress().toIpPort().c_str());</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			printf(&quot;onconnection():connettion [%s] is down\n&quot;,</span><br><span class="line">				conn-&gt;name()-&gt;c_str());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	void onMessage(const TcpConnectionPtr&amp; conn,</span><br><span class="line">					Buffer* buf,</span><br><span class="line">					Timestamp receiveTime)</span><br><span class="line">	&#123;</span><br><span class="line">		muduo::string msg(buf-&gt;retrieveAllAsString());</span><br><span class="line">		printf(&quot;onMessage(): received %zd bytes from connection [%s] at %s\n&quot;,</span><br><span class="line">				msg.size(),</span><br><span class="line">				conn-&gt;name().c_str(),</span><br><span class="line">				receiveTime.toFormattedString().c_str());</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	//标准输入缓冲区中有数据的时候,回调该函数</span><br><span class="line">	void handleRead()&#123;</span><br><span class="line">		char buf[1024]=&#123;0&#125;;</span><br><span class="line">		fgets(buf,1024,stdin);</span><br><span class="line">		buf[str1en(buf)-1]=&#x27;\0&#x27;;//去除\n</span><br><span class="line">		client_.connection()-&gt;send(buf);</span><br><span class="line">	&#125;</span><br><span class="line">	EventLoop* loop_;</span><br><span class="line">	TcpClient client_;//具有自动重连功能，是指还没建立成功的时候</span><br><span class="line">	Channel stdinChannel;//标准输入chaanel</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">	printf( &quot;main(): pid = %d\n&quot;,getpid());</span><br><span class="line">	InetAddress serverAddr(&quot;127.0.0.1&quot;,8888);</span><br><span class="line">	EventLoop loop;</span><br><span class="line">	TestClient client(&amp;loop,serverAddr);</span><br><span class="line">	client.connect();</span><br><span class="line">	loop.loop();</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/16/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%885%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/16/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%885%EF%BC%89/" class="post-title-link" itemprop="url">muduo-网络库（5）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-16 19:21:54" itemprop="dateCreated datePublished" datetime="2023-08-16T19:21:54+08:00">2023-08-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-24 14:42:41" itemprop="dateModified" datetime="2023-08-24T14:42:41+08:00">2023-08-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="muduo库如何支持多线程"><a href="#muduo库如何支持多线程" class="headerlink" title="muduo库如何支持多线程"></a>muduo库如何支持多线程</h1><ul>
<li>EventLoopThread (IO线程类)</li>
<li>EventLoopThreadPool(IO线程池类)<ul>
<li>IO线程池的功能是开启若干个IO线程，并让这些IO线程处于事件循环的状态</li>
</ul>
</li>
</ul>
<p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%885%EF%BC%89/image-20230816193049699.png" alt="image-20230816193049699"></p>
<img src="/2023/08/16/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%885%EF%BC%89/image-20230816193049699.png" class title="This is an test image">

<h2 id="TcpServer-cc关于EventLoopThreadPool部分"><a href="#TcpServer-cc关于EventLoopThreadPool部分" class="headerlink" title="TcpServer.cc关于EventLoopThreadPool部分"></a>TcpServer.cc关于EventLoopThreadPool部分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">std::shared_ptr&lt;EventLoopThreadPool&gt; threadPool_;</span><br><span class="line">void setThreadInitCallback(const ThreadInitCallback&amp; cb)</span><br><span class="line">  &#123; threadInitCallback_ = cb; &#125;</span><br><span class="line">构造函数</span><br><span class="line">threadPool_(new EventLoopThreadPool(loop, name_))</span><br><span class="line"></span><br><span class="line">void TcpServer::setThreadNum(int numThreads)</span><br><span class="line">&#123;</span><br><span class="line">  assert(0 &lt;= numThreads);</span><br><span class="line">  threadPool_-&gt;setThreadNum(numThreads);//不包含主线程</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpServer::start()</span><br><span class="line">&#123;</span><br><span class="line">  if (started_.getAndSet(1) == 0)</span><br><span class="line">  &#123;</span><br><span class="line">    threadPool_-&gt;start(threadInitCallback_);//启动线程池</span><br><span class="line"></span><br><span class="line">    assert(!acceptor_-&gt;listening());</span><br><span class="line">    //get_pointer返回原生指针</span><br><span class="line">    loop_-&gt;runInLoop(</span><br><span class="line">        std::bind(&amp;Acceptor::listen, get_pointer(acceptor_)));//ptr.get();裸指针是为了将对象指针传递给 std::bind，从而在可调用对象中使用</span><br><span class="line">  &#125;//acceptor_.get() 是 std::unique_ptr 类提供的成员函数 get() 的调用，它用于获取被智能指针管理的对象的原始裸指针</span><br><span class="line">  //智能指针不能直接传递对象，是因为智能指针对对象进行了所有权管理</span><br><span class="line">&#125;</span><br><span class="line">void TcpServer::newConnection(int sockfd, const InetAddress&amp; peerAddr)&#123;</span><br><span class="line"> //按照轮叫的方式选择一个EventLoop</span><br><span class="line">  EventLoop* ioLoop = threadPool_-&gt;getNextLoop();</span><br><span class="line">  TcpConnectionPtr conn(new TcpConnection(ioLoop,</span><br><span class="line">                                          connName,</span><br><span class="line">                                          sockfd,</span><br><span class="line">                                          localAddr,</span><br><span class="line">                                          peerAddr));</span><br><span class="line"> ioLoop-&gt;runInLoop(std::bind(&amp;TcpConnection::connectEstablished, conn));//再ioLoop所属线程调用connectEstablished</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>EventLoopThreadPool::start</code> 方法中，线程池会根据指定的线程数量创建并启动多个 <code>EventLoopThread</code> 线程，然后每个线程会创建一个 <code>EventLoop</code> 实例。通过调用 <code>threadInitCallback_</code> 回调函数，你可以在每个线程开始事件循环之前执行一些初始化操作，以确保线程处于正确的状态。</p>
<p>因此，<code>threadPool_-&gt;start(threadInitCallback_)</code> 是用于启动整个线程池，其中每个线程会拥有自己的事件循环，并在事件循环开始之前调用 <code>threadInitCallback_</code> 进行初始化。这样就为每个线程提供了一个适当的上下文，以便它们可以正常地处理连接和事件。</p>
<h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%885%EF%BC%89/image-20230817192430816.png" alt="image-20230817192430816"></p>
<img src="/2023/08/16/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%885%EF%BC%89/image-20230817192430816.png" class title="This is an test image">

<p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%885%EF%BC%89/image-20230817192738143.png" alt="image-20230817192738143"></p>
<img src="/2023/08/16/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%885%EF%BC%89/image-20230817192738143.png" class title="This is an test image">

<p>主线程的文件描述符创建先后，3：pollerfd，4：timerfd，5：wakeupfd，6：listenfd，7：idlefd，再创建其它子线程（线程池）依此类推,子线程没有listenfd和idlefd,处理读事件的都是wakeupfd</p>
<h2 id="EventLoopThreadPool-h"><a href="#EventLoopThreadPool-h" class="headerlink" title="EventLoopThreadPool.h"></a>EventLoopThreadPool.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_NET_EVENTLOOPTHREADPOOL_H</span><br><span class="line">#define MUDUO_NET_EVENTLOOPTHREADPOOL_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/noncopyable.h&quot;</span><br><span class="line">#include &quot;muduo/base/Types.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">class EventLoop;</span><br><span class="line">class EventLoopThread;</span><br><span class="line"></span><br><span class="line">class EventLoopThreadPool : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  typedef std::function&lt;void(EventLoop*)&gt; ThreadInitCallback;</span><br><span class="line"></span><br><span class="line">  EventLoopThreadPool(EventLoop* baseLoop, const string&amp; nameArg);</span><br><span class="line">  ~EventLoopThreadPool();</span><br><span class="line">  void setThreadNum(int numThreads) &#123; numThreads_ = numThreads; &#125;</span><br><span class="line">  void start(const ThreadInitCallback&amp; cb = ThreadInitCallback());</span><br><span class="line"></span><br><span class="line">  // valid after calling start()</span><br><span class="line">  /// round-robin</span><br><span class="line">  EventLoop* getNextLoop();</span><br><span class="line"></span><br><span class="line">  /// with the same hash code, it will always return the same EventLoop</span><br><span class="line">  EventLoop* getLoopForHash(size_t hashCode);</span><br><span class="line"></span><br><span class="line">  std::vector&lt;EventLoop*&gt; getAllLoops();</span><br><span class="line"></span><br><span class="line">  bool started() const</span><br><span class="line">  &#123; return started_; &#125;</span><br><span class="line"></span><br><span class="line">  const string&amp; name() const</span><br><span class="line">  &#123; return name_; &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line"></span><br><span class="line">  EventLoop* baseLoop_;//与Acceptor所属EventLoop相同</span><br><span class="line">  string name_;</span><br><span class="line">  bool started_;</span><br><span class="line">  int numThreads_;//线程数</span><br><span class="line">  int next_;//新连接到来，所选择EventLoop对象下标</span><br><span class="line">  std::vector&lt;std::unique_ptr&lt;EventLoopThread&gt;&gt; threads_;//IO线程列表</span><br><span class="line">  std::vector&lt;EventLoop*&gt; loops_;//EventLoop列表，EventLoop 对象的生命周期由其他IO线程负责</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_NET_EVENTLOOPTHREADPOOL_H</span><br></pre></td></tr></table></figure>

<h2 id="EventLoopThreadPool-cc"><a href="#EventLoopThreadPool-cc" class="headerlink" title="EventLoopThreadPool.cc"></a>EventLoopThreadPool.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/net/EventLoopThreadPool.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/net/EventLoop.h&quot;</span><br><span class="line">#include &quot;muduo/net/EventLoopThread.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">EventLoopThreadPool::EventLoopThreadPool(EventLoop* baseLoop, const string&amp; nameArg)</span><br><span class="line">  : baseLoop_(baseLoop),</span><br><span class="line">    name_(nameArg),</span><br><span class="line">    started_(false),</span><br><span class="line">    numThreads_(0),</span><br><span class="line">    next_(0)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventLoopThreadPool::~EventLoopThreadPool()</span><br><span class="line">&#123;</span><br><span class="line">  // Don&#x27;t delete loop, it&#x27;s stack variable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void EventLoopThreadPool::start(const ThreadInitCallback&amp; cb)</span><br><span class="line">&#123;</span><br><span class="line">  assert(!started_);</span><br><span class="line">  baseLoop_-&gt;assertInLoopThread();</span><br><span class="line"></span><br><span class="line">  started_ = true;</span><br><span class="line"></span><br><span class="line">  for (int i = 0; i &lt; numThreads_; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    char buf[name_.size() + 32];</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%s%d&quot;, name_.c_str(), i);</span><br><span class="line">    EventLoopThread* t = new EventLoopThread(cb, buf);</span><br><span class="line">    threads_.push_back(std::unique_ptr&lt;EventLoopThread&gt;(t));</span><br><span class="line">    loops_.push_back(t-&gt;startLoop());//启动EventLoopThread线程，将返回的loop压入容器，在进入事件循环之前，会调用cb即启动调用EventLoopThread::threadFunc</span><br><span class="line">  &#125;</span><br><span class="line">  if (numThreads_ == 0 &amp;&amp; cb)</span><br><span class="line">  &#123;</span><br><span class="line">    //只有一个EventLoop，在这个EventLoop进入事件循环之前，调用cb,baseLoop_ 表示了一个已经存在的 EventLoop 实例，通常是主线程的事件循环</span><br><span class="line">    cb(baseLoop_);//在每个 EventLoopThread 启动之前，让用户有机会在新线程的事件循环开始之前执行自定义的初始化操作</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventLoop* EventLoopThreadPool::getNextLoop()</span><br><span class="line">&#123;</span><br><span class="line">  baseLoop_-&gt;assertInLoopThread();</span><br><span class="line">  assert(started_);</span><br><span class="line">  EventLoop* loop = baseLoop_;</span><br><span class="line">  //如果loops_为空，则loop指向baseLoop</span><br><span class="line">  //如果不为空，按照round-robin (RR，轮叫）的调度方式选择一个EventLoop</span><br><span class="line">  if (!loops_.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    // round-robin</span><br><span class="line">    loop = loops_[next_];</span><br><span class="line">    ++next_;</span><br><span class="line">    if (implicit_cast&lt;size_t&gt;(next_) &gt;= loops_.size())</span><br><span class="line">    &#123;</span><br><span class="line">      next_ = 0;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventLoop* EventLoopThreadPool::getLoopForHash(size_t hashCode)</span><br><span class="line">&#123;</span><br><span class="line">  baseLoop_-&gt;assertInLoopThread();</span><br><span class="line">  EventLoop* loop = baseLoop_;</span><br><span class="line"></span><br><span class="line">  if (!loops_.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    loop = loops_[hashCode % loops_.size()];</span><br><span class="line">  &#125;</span><br><span class="line">  return loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;EventLoop*&gt; EventLoopThreadPool::getAllLoops()</span><br><span class="line">&#123;</span><br><span class="line">  baseLoop_-&gt;assertInLoopThread();</span><br><span class="line">  assert(started_);</span><br><span class="line">  if (loops_.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    return std::vector&lt;EventLoop*&gt;(1, baseLoop_);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    return loops_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**<code>EventLoop\* EventLoopThreadPool::getLoopForHash(size_t hashCode)</code>**：</p>
<p>此函数根据提供的哈希码从线程池中获取一个事件循环。哈希码用于确定应该为特定任务分配哪个事件循环。此函数的主要目的是确保不同的任务以一致的方式分配给不同的事件循环。这有助于在各个事件循环之间分布负载。</p>
<p><code>getLoopForHash</code> 函数的步骤如下：</p>
<ul>
<li>它断言调用线程与与基本事件循环关联的线程相同。</li>
<li>如果事件循环向量（<code>loops_</code>）不为空，则根据提供的哈希码从向量中选择一个事件循环。</li>
<li>哈希码用于计算在 <code>loops_</code> 向量中的索引，从而在可用的事件循环之间分配任务。</li>
<li>如果向量为空，则函数返回基本事件循环（<code>baseLoop_</code>）。</li>
</ul>
<h1 id="应用层缓冲区Buffer设计"><a href="#应用层缓冲区Buffer设计" class="headerlink" title="应用层缓冲区Buffer设计"></a>应用层缓冲区Buffer设计</h1><h2 id="Buffer-h"><a href="#Buffer-h" class="headerlink" title="Buffer.h"></a>Buffer.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_NET_BUFFER_H</span><br><span class="line">#define MUDUO_NET_BUFFER_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/copyable.h&quot;</span><br><span class="line">#include &quot;muduo/base/StringPiece.h&quot;</span><br><span class="line">#include &quot;muduo/base/Types.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/net/Endian.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">//#include &lt;unistd.h&gt;  // ssize_t</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">/// A buffer class modeled after org.jboss.netty.buffer.ChannelBuffer</span><br><span class="line">///</span><br><span class="line">/// @code</span><br><span class="line">/// +-------------------+------------------+------------------+</span><br><span class="line">/// | prependable bytes |  readable bytes  |  writable bytes  |</span><br><span class="line">/// |                   |     (CONTENT)    |                  |</span><br><span class="line">/// +-------------------+------------------+------------------+</span><br><span class="line">/// |                   |                  |                  |</span><br><span class="line">/// 0      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=     size</span><br><span class="line">/// @endcode</span><br><span class="line">class Buffer : public muduo::copyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  static const size_t kCheapPrepend = 8;</span><br><span class="line">  static const size_t kInitialSize = 1024;</span><br><span class="line"></span><br><span class="line">  explicit Buffer(size_t initialSize = kInitialSize)</span><br><span class="line">    : buffer_(kCheapPrepend + initialSize),//预先分配了1032字节</span><br><span class="line">      readerIndex_(kCheapPrepend),</span><br><span class="line">      writerIndex_(kCheapPrepend)</span><br><span class="line">  &#123;</span><br><span class="line">    assert(readableBytes() == 0);</span><br><span class="line">    assert(writableBytes() == initialSize);</span><br><span class="line">    assert(prependableBytes() == kCheapPrepend);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // implicit copy-ctor, move-ctor, dtor and assignment are fine</span><br><span class="line">  // NOTE: implicit move-ctor is added in g++ 4.6</span><br><span class="line"></span><br><span class="line">  void swap(Buffer&amp; rhs)</span><br><span class="line">  &#123;</span><br><span class="line">    buffer_.swap(rhs.buffer_);</span><br><span class="line">    std::swap(readerIndex_, rhs.readerIndex_);</span><br><span class="line">    std::swap(writerIndex_, rhs.writerIndex_);</span><br><span class="line">  &#125;</span><br><span class="line">  size_t readableBytes() const</span><br><span class="line">  &#123; return writerIndex_ - readerIndex_; &#125;</span><br><span class="line"></span><br><span class="line">  size_t writableBytes() const</span><br><span class="line">  &#123; return buffer_.size() - writerIndex_; &#125;</span><br><span class="line"></span><br><span class="line">  size_t prependableBytes() const</span><br><span class="line">  &#123; return readerIndex_; &#125;</span><br><span class="line"></span><br><span class="line">  const char* peek() const//返回读的指针</span><br><span class="line">  &#123; return begin() + readerIndex_; &#125;</span><br><span class="line"></span><br><span class="line">  const char* findCRLF() const</span><br><span class="line">  &#123;</span><br><span class="line">    // FIXME: replace with memmem()?</span><br><span class="line">    const char* crlf = std::search(peek(), beginWrite(), kCRLF, kCRLF+2);</span><br><span class="line">    //从peek()到beginWrite()的范围内搜索回车换行字符序列 (&quot;\r\n&quot;) 是否存在，并返回匹配的第一个位置的迭代器或指针</span><br><span class="line">    return crlf == beginWrite() ? NULL : crlf;</span><br><span class="line">  &#125;</span><br><span class="line">   void retrieve(size_t len)//取数据</span><br><span class="line">  &#123;</span><br><span class="line">    assert(len &lt;= readableBytes());</span><br><span class="line">    if (len &lt; readableBytes())</span><br><span class="line">    &#123;</span><br><span class="line">      readerIndex_ += len;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      retrieveAll();//取所有</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  void retrieveAll()</span><br><span class="line">  &#123;</span><br><span class="line">    readerIndex_ = kCheapPrepend;</span><br><span class="line">    writerIndex_ = kCheapPrepend;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  string retrieveAllAsString()</span><br><span class="line">  &#123;</span><br><span class="line">    return retrieveAsString(readableBytes());</span><br><span class="line">  &#125;</span><br><span class="line">  //用于从数据源中读取指定长度的数据，将其存储为字符串，并将数据源中已读取的数据删除</span><br><span class="line">  string retrieveAsString(size_t len)</span><br><span class="line">  &#123;</span><br><span class="line">    assert(len &lt;= readableBytes());</span><br><span class="line">    string result(peek(), len);</span><br><span class="line">    retrieve(len);</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">  //确保缓冲区可写空间&gt;=len，如果不足则扩充</span><br><span class="line">  void ensureWritableBytes(size_t len)</span><br><span class="line">  &#123;</span><br><span class="line">    if (writableBytes() &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">      makeSpace(len);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(writableBytes() &gt;= len);</span><br><span class="line">  &#125;</span><br><span class="line">  //从缓冲区中读取一个32位大端字节序的整数，然后将其转换为主机字节序，并返回转换后的整数值</span><br><span class="line">  int32_t peekInt32() const</span><br><span class="line">  &#123;</span><br><span class="line">    assert(readableBytes() &gt;= sizeof(int32_t));</span><br><span class="line">    int32_t be32 = 0;</span><br><span class="line">    ::memcpy(&amp;be32, peek(), sizeof be32);</span><br><span class="line">    return sockets::networkToHost32(be32);</span><br><span class="line">  &#125;</span><br><span class="line">//在缓冲区的头部插入给定长度的数据。它会通过将已读索引向前移动，并将新数据复制到头部位置来实现</span><br><span class="line">  void prepend(const void* /*restrict*/ data, size_t len)</span><br><span class="line">  &#123;</span><br><span class="line">    assert(len &lt;= prependableBytes());</span><br><span class="line">    readerIndex_ -= len;</span><br><span class="line">    const char* d = static_cast&lt;const char*&gt;(data);</span><br><span class="line">    std::copy(d, d+len, begin()+readerIndex_);</span><br><span class="line">  &#125;</span><br><span class="line">  //伸缩空间，保留reserve个字节</span><br><span class="line">  //这个函数的作用是缩小当前缓冲区的容量，以释放不必要的内存。</span><br><span class="line">  //它通过创建一个临时的 other 缓冲区，将当前缓冲区中的数据追加到其中，然后交换它们的内容，实现缓冲区的内存收缩</span><br><span class="line">  void shrink(size_t reserve)</span><br><span class="line">  &#123;</span><br><span class="line">    // FIXME: use vector::shrink_to_fit() in C++ 11 if possible.</span><br><span class="line">    Buffer other;</span><br><span class="line">    other.ensureWritableBytes(readableBytes()+reserve);</span><br><span class="line">    other.append(toStringPiece());</span><br><span class="line">    swap(other);</span><br><span class="line">  &#125;</span><br><span class="line">private:</span><br><span class="line">	 void makeSpace(size_t len)</span><br><span class="line">  &#123;</span><br><span class="line">    if (writableBytes() + prependableBytes() &lt; len + kCheapPrepend)</span><br><span class="line">    &#123;</span><br><span class="line">      // FIXME: move readable data</span><br><span class="line">      buffer_.resize(writerIndex_+len);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      // move readable data to the front, make space inside buffer</span><br><span class="line">      assert(kCheapPrepend &lt; readerIndex_);</span><br><span class="line">      size_t readable = readableBytes();</span><br><span class="line">      //将位于 buffer_ 中 readerIndex_ 到 writerIndex_ 范围内的数据复制到 buffer_ 中的另一个位置，从 kCheapPrepend 开始</span><br><span class="line">      std::copy(begin()+readerIndex_,</span><br><span class="line">                begin()+writerIndex_,</span><br><span class="line">                begin()+kCheapPrepend);</span><br><span class="line">      readerIndex_ = kCheapPrepend;</span><br><span class="line">      writerIndex_ = readerIndex_ + readable;</span><br><span class="line">      assert(readable == readableBytes());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  private:</span><br><span class="line">  std::vector&lt;char&gt; buffer_;</span><br><span class="line">  size_t readerIndex_;</span><br><span class="line">  size_t writerIndex_;</span><br><span class="line"></span><br><span class="line">  static const char kCRLF[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_NET_BUFFER_H</span><br></pre></td></tr></table></figure>

<h2 id="Buffer-cc"><a href="#Buffer-cc" class="headerlink" title="Buffer.cc"></a>Buffer.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/net/Buffer.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/net/SocketsOps.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;sys/uio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">const char Buffer::kCRLF[] = &quot;\r\n&quot;;</span><br><span class="line"></span><br><span class="line">const size_t Buffer::kCheapPrepend;</span><br><span class="line">const size_t Buffer::kInitialSize;</span><br><span class="line">//结合栈上的空间，避免内存使用过大,提高内存使用率</span><br><span class="line">//如果有5k个连接，每个连接就分配64K+64k的缓冲区的话，将占用640M内存，而大多数时候，这些缓冲区的使用率很低</span><br><span class="line">ssize_t Buffer::readFd(int fd, int* savedErrno)</span><br><span class="line">&#123;</span><br><span class="line">  // saved an ioctl()/FIONREAD call to tell how much to read</span><br><span class="line">  char extrabuf[65536];//栈上的空间足够大，节省一次ioctl系统调用（获取有多少可读数据）</span><br><span class="line">  struct iovec vec[2];</span><br><span class="line">  const size_t writable = writableBytes();</span><br><span class="line">  //第一块缓冲区</span><br><span class="line">  vec[0].iov_base = begin()+writerIndex_;</span><br><span class="line">  vec[0].iov_len = writable;</span><br><span class="line">  //第二块缓冲区</span><br><span class="line">  vec[1].iov_base = extrabuf;</span><br><span class="line">  vec[1].iov_len = sizeof extrabuf;</span><br><span class="line">  // when there is enough space in this buffer, don&#x27;t read into extrabuf.</span><br><span class="line">  // when extrabuf is used, we read 128k-1 bytes at most.</span><br><span class="line">  const int iovcnt = (writable &lt; sizeof extrabuf) ? 2 : 1;//根据当前缓冲区的可写入大小与 extrabuf 的大小，确定要传递给 readv 函数的 iovec 结构体数量</span><br><span class="line">  const ssize_t n = sockets::readv(fd, vec, iovcnt);</span><br><span class="line">  if (n &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    *savedErrno = errno;</span><br><span class="line">  &#125;</span><br><span class="line">  else if (implicit_cast&lt;size_t&gt;(n) &lt;= writable)//第一块缓冲区足够容纳</span><br><span class="line">  &#123;</span><br><span class="line">    writerIndex_ += n;</span><br><span class="line">  &#125;</span><br><span class="line">  else       //当前缓冲区，不够容纳，因而数据放不到第一块的故接收到了第二块缓冲区extrabuf，将其append至buffer,</span><br><span class="line">  &#123;</span><br><span class="line">    writerIndex_ = buffer_.size();</span><br><span class="line">    append(extrabuf, n - writable);</span><br><span class="line">  &#125;</span><br><span class="line">  // if (n == writable + sizeof extrabuf)</span><br><span class="line">  // &#123;</span><br><span class="line">  //   goto line_30;</span><br><span class="line">  // &#125;</span><br><span class="line">  return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="为什么需要有应用层缓冲区"><a href="#为什么需要有应用层缓冲区" class="headerlink" title="为什么需要有应用层缓冲区"></a>为什么需要有应用层缓冲区</h2><p>Non-blocking IO的核心思想是避免阻塞在read()或write()或其他IO系统调用上，这样可以最大限度地复用thread-of-control，让一个线程能服务于多个socket连接。IO线程只能阻塞在IO-multiplexing函数上，如 select()&#x2F;poll()&#x2F;epoll_wait()。这样一来，应用层的缓冲是必须的，每个TCP socket都要有stateful的 input buffer和 output buffer。</p>
<p>TcpConnection必须要有output buffer考虑一个常见场景:程序想通过TCP连接发送100k字节的数据，但是在write()调用中，操作系统只接受了80k字节(受TCPadvertised window的控制，细节见TCPv1)，你肯定不想在原地等待，因为不知道会等多久(取决于对方什么时候接受数据，然后滑动TCP窗口)。程序应该尽快交出控制权，返回event loop。在这种情况下，剩余的20k字节数据怎么办?</p>
<p>对于应用程序而言，它只管生成数据，它不应该关心到底数据是一次性发送还是分成几次发送，这些应该由网络库来操心，程序只要调用TcpConnection:send()就行了，网络库会负责到底。网络库应该接管这剩余的20k字节数据，把它保存在该TCP connection 的output buffer 里，然后注册POLLOUT事件，一旦socket变得可写就立刻发送数据。当然，这第二次write()也不一定能完全写入20k字节，如果还有剩余，网络库应该继续关注POLLOUT事件;如果写完了20k字节，网络库应该停止关注 POLLOUT，以免造成busy loop。(Muduo EventLoop采用的是epoll level trigger）</p>
<p>如果程序又写入了50k字节，而这时候output buffer里还有待发送的20k数据，那么网络库不应该直接调用write()，而应该把这50k数据append在那20k数据之后，等socket变得可写的时候再一并写入。</p>
<p>如果 output buffer里还有待发送的数据，而程序又想关闭连接（对程序而言，调用TcpConnection:send()之后他就认为数据迟早会发出去)，那么这时候网络库不能立刻关闭连接，而要等数据发送完毕。</p>
<p>综上，要让程序在write操作上不阻塞，网络库必须要给每个tcp connection配置output buffer .</p>
<h3 id="TcpConnection必须要有input-buffer"><a href="#TcpConnection必须要有input-buffer" class="headerlink" title="TcpConnection必须要有input buffer"></a>TcpConnection必须要有input buffer</h3><p>TCP是一个无边界的字节流协议，接收方必须要处理“收到的数据尚不构成一条完整的消息”和“一次收到两条消息的数据”等等情况。</p>
<p>网络库在处理“socket可读”事件的时候，必须一次性把socket里的数据读完（从操作系统buffer搬到应用层buffer)，否则会反复触发POLLIN事件，造成busy-loop。</p>
<p>那么网络库必然要应对“数据不完整”的情况，收到的数据先放到input buffer里，等构成一条完整的消息再通知程序的业务逻辑。这通常是codec的职责。</p>
<p>最好一次性把内核缓冲区中的数据读完，当然分多次读也没有关系<br>接收到数据，存至input buffer,通知上层的应用程序,OnMessage(Buffer* buff)回调，根据应用层协议是否是一个完整的包，codec,如果不是一条完整的消息，不会取走数据，也不会进行相应的处理，如果是一条完整的消息，将取走这条消息，并进行相应的处理。 </p>
<p>所以，在 tcp 网络编程中，网络库必须要给每个tcp connection配置inputbuffer。</p>
<p>所有muduo中的IO都是带缓冲的IO (buffered IO)，你不会自己去read()或write()某个socket，只会操作TcpConnection 的 input buffer和 output buffer。更确切的说，是在onMessage()回调里读取 input buffer;调用TcpConnection:send()来间接操作output buffer，一般不会直接操作 output buffer。</p>
<h2 id="Buffer结构"><a href="#Buffer结构" class="headerlink" title="Buffer结构"></a>Buffer结构</h2><p>Muduo Buffer的设计要点:</p>
<ul>
<li>对外表现为一块连续的内存(char*, len)，以方便客户代码的编写。</li>
<li>其size()可以自动增长，以适应不同大小的消息。它不是一个fixed size array(即char buf[8192])。</li>
<li>内部以vector of char来保存数据，并提供相应的访问函数。</li>
</ul>
<p>Buffer其实像是一个queue，从末尾写入数据，从头部读出数据。</p>
<p>谁会用Buffer?谁写谁读?根据前文分析，TcpConnection会有两个 Buffer成员，input buffer 与output buffer。</p>
<ul>
<li>input buffer，TcpConnection会从 socket读取数据，然后写入input buffer(其实这一步是用 BufferreadFd()完成的);客户代码从input buffer读取数据。</li>
<li>output buffer，客户代码会把数据写入 output buffer(其实这一步是用Tcp-Connection:send()完成的);TcpConnection 从 output buffer 读取数据并写入socket。</li>
</ul>
<p>其实，input和 output是针对客户代码而言，客户代码从input读，往output写。TcpConnection的读写正好相反。</p>
<h3 id="Muduo-Buffer的数据结构"><a href="#Muduo-Buffer的数据结构" class="headerlink" title="Muduo Buffer的数据结构"></a>Muduo Buffer的数据结构</h3><p>Muduo中的<code>Buffer</code>类设计得很巧妙。它的实现主要基于一个<code>std::vector&lt;char&gt;</code>，但不同于一般的缓冲区，Muduo的<code>Buffer</code>具有前置空间(prependable space)、可读数据(readable data)和可写空间(writable space)三部分。</p>
<p>以下是其核心的数据结构的概述：</p>
<ol>
<li><strong>std::vector<char> buffer_</char></strong>:<ul>
<li>它是存储数据的核心结构。<code>buffer_</code>的大小通常大于实际数据量，以支持高效的数据插入和删除。</li>
</ul>
</li>
<li><strong>size_t readerIndex_</strong>:<ul>
<li>这是一个索引，指向<code>buffer_</code>中的第一个可读字节。所有在<code>readerIndex_</code>之前的字节都是前置空间，可用于某些特殊的前置操作。</li>
</ul>
</li>
<li><strong>size_t writerIndex_</strong>:<ul>
<li>这是一个索引，指向<code>buffer_</code>中的第一个可写字节。所有在<code>writerIndex_</code>之后的字节都是可写空间。</li>
</ul>
</li>
</ol>
<p>基于这些索引，<code>Buffer</code>的数据布局如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+------------------+------------------+</span><br><span class="line">| prependable bytes |  readable bytes  |  writable bytes  |</span><br><span class="line">+-------------------+------------------+------------------+</span><br><span class="line">|                   |                  |                  |</span><br><span class="line">0      &lt;=      readerIndex_   &lt;=   writerIndex_   &lt;=   size()</span><br></pre></td></tr></table></figure>

<p>以下是一些<code>Buffer</code>的基本操作及其对应的实现逻辑：</p>
<ul>
<li><strong>空闲空间</strong>: 使用<code>buffer_.capacity()</code>与<code>buffer_.size()</code>之间的差值来获取。</li>
<li><strong>确保空间</strong>: 如果可写空间不足以容纳新的数据，<code>Buffer</code>可能需要重新分配空间。</li>
<li><strong>读操作</strong>: 通常会移动<code>readerIndex_</code>。</li>
<li><strong>写操作</strong>: 会移动<code>writerIndex_</code>，并在需要时重新分配空间。</li>
<li><strong>prepend操作</strong>: 使用前置空间，在<code>readerIndex_</code>之前添加数据。</li>
<li><strong>清空或重置</strong>: 通过重置<code>readerIndex_</code>和<code>writerIndex_</code>来实现。</li>
</ul>
<hr>
<p>为什么我们不需要调用reserve()来预先分配空间?因为Buffer在构造函数里把初始size()设为1k，这样当size()超过1k的时候vector 会把 capacity()加倍，等于说resize()替我们做了reserve()的事。用一段简单的代码验证一下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;char&gt; vec;</span><br><span class="line">printf(”%zd %zd\n”, vec.size(), vec.capacity());</span><br><span class="line">vec.resize(1024);</span><br><span class="line">printf(”%zd %zd\n”, vec.size(), vec.capacity());</span><br><span class="line">vec.resize( 1300);</span><br><span class="line">printf(”%zd %zd\n”，vec.size(), vec.capacity());</span><br></pre></td></tr></table></figure>

<ul>
<li>初始时，空的vector <code>vec</code> 没有元素，因此大小和容量都为0。</li>
<li>在调用 <code>vec.resize(1024)</code> 后，vector会分配至少1024个字节的内存空间，使其大小变为1024，而容量与大小相等，都为1024。</li>
<li>接着调用 <code>vec.resize(1300)</code> 后，由于容量不足以容纳1300个元素，vector会重新分配内存空间，并将原来的1024个元素复制到新的内存空间中。此时，大小变为1300，而容量增长到2048。</li>
</ul>
<p>请注意，在这个过程中，vector的容量在需要时会自动增长，并且可能会超过当前元素的数量。</p>
<h1 id="epoll使用LT模式的原因"><a href="#epoll使用LT模式的原因" class="headerlink" title="epoll使用LT模式的原因"></a>epoll使用LT模式的原因</h1><p>与poll兼容</p>
<p>LT模式不会发生漏掉事件的BUG，但POLLOUT事件不能一开始就关注，否则会出现busy loop，而应该在write无法写入内核缓冲区的时候才关注，将未写入内核缓冲区的数据添加到应用层output buffer，直到应用层output buffer写完，停止关注POLLOUT事件。</p>
<p>读写的时候不必等候EAGAIN，可以节省系统调用次效，降低迟。（注:如果用ET模式，读的时候读到EAGAIN,写的时候直到output buffer写完或者EAGAIN)</p>
<h1 id="其他缓冲区设计方案"><a href="#其他缓冲区设计方案" class="headerlink" title="其他缓冲区设计方案"></a>其他缓冲区设计方案</h1><p>谈谈其他可能的应用层 buffer设计方案</p>
<h2 id="不用vector-lt-char-gt"><a href="#不用vector-lt-char-gt" class="headerlink" title="不用vector&lt;char&gt;"></a>不用<code>vector&lt;char&gt;</code></h2><p>如果放弃“连续性”要求，可以用circular buffer，这样可以减少一点内存拷贝（没有“内部腾挪”)</p>
<p>使用连续性要求（元素在内存中连续存储）的容器，如 <code>std::vector</code>，在许多情况下提供了高效的随机访问和尾部操作，但在某些情况下，可能会涉及内存的重新分配和数据复制，这可能会带来性能开销。</p>
<p>C++ 标准库中没有直接支持的循环缓冲区（circular buffer）容器，但循环缓冲区在一些特定的应用场景中非常有用，特别是在需要在不断写入数据的同时，高效地读取最早写入的数据的情况下。</p>
<p>循环缓冲区的主要特点包括：</p>
<ol>
<li><strong>环形结构</strong>: 循环缓冲区的内部数据结构是环形的，数据从队列的尾部写入，从队列的头部读取。当队列尾部到达缓冲区末尾时，写入操作会回到缓冲区的开头，实现循环的效果。</li>
<li><strong>无需内存重分配</strong>: 循环缓冲区不需要频繁地进行内存重分配，因为其大小是固定的，当写入数据时，只需移动尾指针。这减少了内存分配和复制的开销。</li>
<li><strong>减少内存拷贝</strong>: 由于数据在循环缓冲区中是连续存储的，而且没有内存重分配，读取最早写入的数据时，不需要进行大量的内存拷贝操作。读取操作只需调整头指针即可。</li>
<li><strong>适用于实时流式数据</strong>: 循环缓冲区适用于需要实时处理流式数据的场景，如音频处理、网络数据包的缓冲等。通过不断写入新数据，同时高效读取最早写入的数据，可以实现数据的缓冲和流式处理。</li>
</ol>
<p>总之，循环缓冲区适用于需要高效地循环读取和写入数据的场景，它通过维护一个固定大小的环形结构，避免了内存重分配和大量的内存拷贝，从而在某些情况下提供了更好的性能和内存利用率。</p>
<h2 id="Zero-copy"><a href="#Zero-copy" class="headerlink" title="Zero copy"></a>Zero copy</h2><p>实际上也不是真正意义上的零拷贝，因为数据从内核到用户空间，总是有一次拷贝的。除非把应用程序放到内核中才能实现真正的零拷贝。</p>
<p><code>libevent</code> 2.0.x 提供了以下设计方案来实现分段连续的零拷贝缓冲区和散收 I&#x2F;O：</p>
<ol>
<li><strong>evbuffer 的分段连续缓冲区设计</strong>：<ul>
<li><code>evbuffer</code> 是 <code>libevent</code> 中用于管理缓冲区的数据结构。它可以容纳多个内存块，这些内存块可以是连续的，也可以是分散的。这种设计允许在不进行数据拷贝的情况下管理和操作多个数据段。</li>
<li>您可以使用 <code>evbuffer_add()</code> 函数将数据添加到 <code>evbuffer</code> 中。如果数据不连续，<code>evbuffer</code> 会自动将它们合并成连续的数据段。</li>
<li>使用 <code>evbuffer_remove()</code> 函数可以从 <code>evbuffer</code> 中读取数据。这个函数允许您在一次操作中读取并删除数据，而不需要额外的拷贝。</li>
</ul>
</li>
<li><strong>散收 I&#x2F;O 的应用</strong>：<ul>
<li>散收 I&#x2F;O 是一种优化技术，用于将数据分散存储到多个缓冲区中或从多个缓冲区中进行聚集写入。这避免了将数据从用户空间到内核空间的拷贝，提高了性能。</li>
<li>在 <code>libevent</code> 中，当数据从套接字读取到 <code>evbuffer</code> 时，<code>libevent</code> 可以使用散收 I&#x2F;O 将数据分散存储到多个数据段中，而不需要在用户空间进行拷贝。</li>
<li>类似地，在写入数据到套接字时，<code>libevent</code> 可以使用聚集写入的方式，从 <code>evbuffer</code> 中聚集多个数据段，然后一次性进行写入。</li>
</ul>
</li>
</ol>
<h1 id="TcpConnection中增加send"><a href="#TcpConnection中增加send" class="headerlink" title="TcpConnection中增加send"></a>TcpConnection中增加send</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"> // void send(string&amp;&amp; message); // C++11</span><br><span class="line">  void send(const void* message, int len);</span><br><span class="line">  void send(const StringPiece&amp; message);</span><br><span class="line">  // void send(Buffer&amp;&amp; message); // C++11</span><br><span class="line">  void send(Buffer* message);  // this one will swap data</span><br><span class="line">  void shutdown(); // NOT thread safe, no simultaneous calling</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Buffer inputBuffer_;//应用层接受缓冲区</span><br><span class="line">Buffer outputBuffer_;//应用层发送缓冲区</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void TcpConnection::send(const void* data, int len)</span><br><span class="line">&#123;</span><br><span class="line">  send(StringPiece(static_cast&lt;const char*&gt;(data), len));</span><br><span class="line">&#125;</span><br><span class="line">//线程安全，可以跨线程调用</span><br><span class="line">void TcpConnection::send(const StringPiece&amp; message)</span><br><span class="line">&#123;</span><br><span class="line">  if (state_ == kConnected)</span><br><span class="line">  &#123;</span><br><span class="line">    if (loop_-&gt;isInLoopThread())</span><br><span class="line">    &#123;</span><br><span class="line">      sendInLoop(message);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      void (TcpConnection::*fp)(const StringPiece&amp; message) = &amp;TcpConnection::sendInLoop;</span><br><span class="line">      loop_-&gt;runInLoop(</span><br><span class="line">          std::bind(fp,</span><br><span class="line">                    this,     // FIXME</span><br><span class="line">                    message.as_string()));</span><br><span class="line">                    //std::forward&lt;string&gt;(message)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// FIXME efficiency!!!</span><br><span class="line">void TcpConnection::send(Buffer* buf)</span><br><span class="line">&#123;</span><br><span class="line">  if (state_ == kConnected)</span><br><span class="line">  &#123;</span><br><span class="line">    if (loop_-&gt;isInLoopThread())</span><br><span class="line">    &#123;</span><br><span class="line">      sendInLoop(buf-&gt;peek(), buf-&gt;readableBytes());</span><br><span class="line">      buf-&gt;retrieveAll();</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      void (TcpConnection::*fp)(const StringPiece&amp; message) = &amp;TcpConnection::sendInLoop;</span><br><span class="line">      loop_-&gt;runInLoop(</span><br><span class="line">          std::bind(fp,</span><br><span class="line">                    this,     // FIXME</span><br><span class="line">                    buf-&gt;retrieveAllAsString()));</span><br><span class="line">                    //std::forward&lt;string&gt;(message)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpConnection::sendInLoop(const StringPiece&amp; message)</span><br><span class="line">&#123;</span><br><span class="line">  sendInLoop(message.data(), message.size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpConnection::sendInLoop(const void* data, size_t len)</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  sockets::write(channe1_-&gt;fd(),data,len);</span><br><span class="line">&#125;</span><br><span class="line">//通道可读事件到来的时候，回调TcpConnection::handleRead，_1是事件发生时间</span><br><span class="line">/*channel_-&gt;setReadCallback(</span><br><span class="line">      std::bind(&amp;TcpConnection::handleRead, this, _1));*/</span><br><span class="line">void TcpConnection::handleRead(Timestamp receiveTime)</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  int savedErrno = 0;</span><br><span class="line">  /*typedef std::function&lt;void (const TcpConnectionPtr&amp;,</span><br><span class="line">                            Buffer*,</span><br><span class="line">                            Timestamp)&gt; MessageCallback;*/</span><br><span class="line">  ssize_t n = inputBuffer_.readFd(channel_-&gt;fd(), &amp;savedErrno);</span><br><span class="line">  if (n &gt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    messageCallback_(shared_from_this(), &amp;inputBuffer_, receiveTime);//shared_from_this()将当前对象转换成shared_ptr，而不是裸指针</span><br><span class="line">  &#125;</span><br><span class="line">  else if (n == 0)</span><br><span class="line">  &#123;</span><br><span class="line">    handleClose();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    errno = savedErrno;</span><br><span class="line">    LOG_SYSERR &lt;&lt; &quot;TcpConnection::handleRead&quot;;</span><br><span class="line">    handleError();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释掉的C++11用法是使用右值引用（rvalue reference）和移动语义（move semantics）。在这段代码中，定义了两个使用右值引用的发送函数。</p>
<p>首先是<code>void send(string&amp;&amp; message)</code>函数，它接受一个右值引用参数 <code>message</code>。右值引用通过使用 <code>&amp;&amp;</code> 修饰类型来标识，表示该参数可以接受临时对象或将要被移动的对象。这种方式可以避免不必要的复制操作，并通过移动语义将资源（如内存）从一个对象转移到另一个对象，提高性能。</p>
<p>其次是<code>void send(Buffer&amp;&amp; message)</code>函数。它也接受一个右值引用参数 <code>message</code>，但这里的类型是 <code>Buffer</code>，而不是普通的 <code>string</code> 类型。通过右值引用和移动语义，可以高效地将 <code>Buffer</code> 对象的数据从原始对象转移到接收方，而不需要进行深拷贝。</p>
<h1 id="TcpConnection中shutdown的处理方法"><a href="#TcpConnection中shutdown的处理方法" class="headerlink" title="TcpConnection中shutdown的处理方法"></a>TcpConnection中shutdown的处理方法</h1><p>连接状态更改为kDisconnecting,并没有关闭连接<br>服务器端主动断开与客户端的连接<br>这意味着客户端read返回为0,close(conn) ;</p>
<p><code>conn-&gt;shutdown()</code> 会关闭服务器与客户端之间的连接，而不是关闭客户端。客户端可以通过相应的关闭操作来结束自己的连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">void TcpConnection::shutdown()</span><br><span class="line">&#123;</span><br><span class="line">  // FIXME: use compare and swap</span><br><span class="line">  //可以使用原子操作来比较当前状态是否为 kConnected，如果是，则使用原子操作修改状态为 kDisconnecting。</span><br><span class="line">  //这可以避免在多线程环境中多个线程同时检查并修改状态，从而避免竞态条件</span><br><span class="line">  /*AtomicIntegerT(const AtomicIntegerT&amp; that)</span><br><span class="line">     : value_(that.get())</span><br><span class="line">  &#123;&#125;*/</span><br><span class="line">  if (state_ == kConnected)</span><br><span class="line">  &#123;</span><br><span class="line">    setState(kDisconnecting);</span><br><span class="line">    // FIXME: shared_from_this()?</span><br><span class="line">    loop_-&gt;runInLoop(std::bind(&amp;TcpConnection::shutdownInLoop, this));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpConnection::shutdownInLoop()</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  if (!channel_-&gt;isWriting())//不再关注pollout事件</span><br><span class="line">  &#123;</span><br><span class="line">    // we are not writing</span><br><span class="line">    socket_-&gt;shutdownWrite();//关闭写的这一半</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//只关闭写的这一半</span><br><span class="line">void sockets::shutdownWrite(int sockfd)</span><br><span class="line">&#123;</span><br><span class="line">  if (::shutdown(sockfd, SHUT_WR) &lt; 0)//关闭套接字 sockfd 的写入端</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSERR &lt;&lt; &quot;sockets::shutdownWrite&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">class TestServer&#123;</span><br><span class="line">public:</span><br><span class="line">TestServer(EventLoop*loop,const InetAddress&amp; listenAddr)</span><br><span class="line">			:loop_(loop),</span><br><span class="line">			server(loop,1istenAddr,&quot;TestServer&quot;)</span><br><span class="line">	&#123;</span><br><span class="line">	server_.setconnectionCa11back(</span><br><span class="line">		boost::bind(&amp;Testserver::onConnection,this，_1));</span><br><span class="line">	server_.setMessageCa11back(</span><br><span class="line">		boost::bind(&amp;TestServer::onMessage, this，_1,_2,_3));</span><br><span class="line">	message1_.resize(100);</span><br><span class="line">	message2_.resize(200);</span><br><span class="line">	std::fill(message1_.begin(),message1_.end(),&#x27;A&#x27;);</span><br><span class="line">	std::fill(message2_.begin(),message2_.end(),&#x27;B&#x27;);</span><br><span class="line">	&#125;</span><br><span class="line">	void start()&#123;</span><br><span class="line">		server_.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	void:onConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">	&#123;</span><br><span class="line">		if( conn-&gt;connected())&#123;</span><br><span class="line">			printf(&quot;onconnection(): new connettion [%s]from %s\n&quot;,</span><br><span class="line">				conn-&gt;name()-&gt;c_str(),</span><br><span class="line">				conn-&gt;peerAddress().toIpPort().c_str());</span><br><span class="line">			conn-&gt;send(message1_);</span><br><span class="line">			conn-&gt;send(message2_);</span><br><span class="line">			conn-&gt;shutdown();//关闭服务器与客户端之间的连接，而不是关闭客户端。</span><br><span class="line">			//这将导致服务端无法再向客户端发送数据，但服务端仍然可以接收来自客户端的数据</span><br><span class="line">			//这将关闭服务端连接的写入端，这在服务器端会导致客户端的read操作返回0,close(conn)和POLLHUP | POLLIN事件</span><br><span class="line">			//POLLHUP事件表示连接被挂起，即连接的一方关闭了连接或异常断开</span><br><span class="line">			//POLLIN事件表示连接上有数据可读</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			printf(&quot;onconnection():connettion [%s] is down\n&quot;,</span><br><span class="line">				conn-&gt;name()-&gt;c_str());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	void onMessage(const TcpConnectionPtr&amp; conn,</span><br><span class="line">					Buffer* buf,</span><br><span class="line">					Timestamp receiveTime)</span><br><span class="line">	&#123;</span><br><span class="line">		muduo::string msg(buf-&gt;retrieveAllAsString());</span><br><span class="line">		printf(&quot;onMessage(): received %zd bytes from connection [%s] at %s\n&quot;,</span><br><span class="line">				msg.size(),</span><br><span class="line">				conn-&gt;name().c_str(),</span><br><span class="line">				receiveTime.toFormattedString().c_str());</span><br><span class="line">		conn-&gt;send(msg);</span><br><span class="line">	&#125;</span><br><span class="line">	EventLoop* l_;</span><br><span class="line">	TcpServer server_;</span><br><span class="line">	muduo::string message1_;</span><br><span class="line">	muduo::string message2_;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">	printf( &quot;main(): pid = %d\n&quot;,getpid());</span><br><span class="line">	InetAddress listenAddr(8888);</span><br><span class="line">	EventLoop loop;</span><br><span class="line">	TestServer server(&amp;loop,listenAddr);</span><br><span class="line">	server.start();</span><br><span class="line">	loop.loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常情况下，服务端使用 <code>::shutdown(sockfd, SHUT_WR)</code> 来实现优雅的连接关闭，就像之前讨论的一样。这样，服务端会通知客户端它已经完成了数据的发送，并且客户端应该停止发送数据，但仍然可以接收来自客户端的数据。然后，服务端可以在需要的时候关闭整个连接。这种关闭方式可以确保连接的正常结束，而不会丢失任何数据或造成不必要的中断。</p>
<p>当服务器关闭写入端时，会产生POLLHUP事件，用于通知客户端连接已关闭；同时，由于连接未完全关闭，客户端仍然可以从连接中读取数据，所以也会产生POLLIN事件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/15/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%884%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/15/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%884%EF%BC%89/" class="post-title-link" itemprop="url">muduo-网络库（4）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-15 11:25:01" itemprop="dateCreated datePublished" datetime="2023-08-15T11:25:01+08:00">2023-08-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-16 16:31:41" itemprop="dateModified" datetime="2023-08-16T16:31:41+08:00">2023-08-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="TcpServer-x2F-TcpConnection"><a href="#TcpServer-x2F-TcpConnection" class="headerlink" title="TcpServer&#x2F;TcpConnection"></a>TcpServer&#x2F;TcpConnection</h1><ul>
<li>Acceptor类的主要功能是socket、bind、listen</li>
<li>一般来说，在上层应用程序中，我们不直接使用Acceptor，而是把它作为TcpServer的成员</li>
<li>TcpServer还包含了一个TcpConnection列表</li>
<li>TcpConnection与Acceptor类似，有两个重要的数据成员，Socket与Channel,Channel关注Socket的可读可写事件</li>
</ul>
<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%884%EF%BC%89/image-20230815112907646.png" alt="image-20230815112907646"></p>
<img src="/2023/08/15/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%884%EF%BC%89/image-20230815112907646.png" class title="This is an test image">

<h2 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h2><p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%884%EF%BC%89/image-20230815155937436.png" alt="image-20230815155937436"></p>
<img src="/2023/08/15/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%884%EF%BC%89/image-20230815155937436.png" class title="This is an test image">

<p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%884%EF%BC%89/image-20230815155828886.png" alt="image-20230815155828886"></p>
<img src="/2023/08/15/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%884%EF%BC%89/image-20230815155828886.png" class title="This is an test image">

<p>在TcpServer.cc中，TcpServer类通过监听指定的IP地址和端口号，接受客户端的连接，并管理多个TcpConnection对象。下面是对TcpServer类对连接客户端的一步步操作的总结：</p>
<ol>
<li><p>在构造函数中创建一个Acceptor对象，并设置新连接回调函数<code>newConnectionCallback</code>。Acceptor负责监听并接受新的客户端连接。</p>
</li>
<li><p>在<code>start()</code>函数中启动服务器，包括启动EventLoop线程池、绑定地址、开始监听等操作。</p>
</li>
<li><p>当Acceptor接受到新的客户端连接时，在<code>TcpServer</code>类中的私有成员函数<code>newConnection()</code>被回调。在<code>newConnection()</code>函数中，会创建一个新的TcpConnection对象，并将其添加到连接管理字典<code>connections_</code>中。</p>
</li>
<li><p>在创建TcpConnection对象时，会设置相应的回调函数，包括连接建立回调函数、消息到达回调函数、写操作完成回调函数以及连接关闭回调函数。</p>
</li>
<li><p>创建TcpConnection后，通过调用<code>connectEstablished()</code>函数通知TcpConnection所属的EventLoop连接已经建立完毕，并触发用户设置的连接建立回调函数。（<code>connectEstablished()</code>函数会在TcpConnection对象所属的EventLoop线程中被回调，具体发生的时机是在新的客户端连接建立完成后。</p>
<p>当TcpServer监听到新的连接请求并接受连接时，会在<code>TcpServer::newConnection()</code>函数中创建一个新的TcpConnection对象，并通过<code>ioLoop-&gt;runInLoop()</code>将<code>TcpConnection::connectEstablished()</code>函数添加到所属的EventLoop线程的任务队列中。</p>
<p>随后，在EventLoop线程的下一个事件循环周期中，会从任务队列中取出<code>TcpConnection::connectEstablished()</code>函数并执行。这时，会触发用户设置的连接建立回调函数，并通知用户连接已经建立完毕。</p>
<p>因此，<code>connectEstablished()</code>函数的回调时机是在新的客户端连接建立完成后，即连接建立时机已经稳定，可以进行后续数据收发操作。）</p>
</li>
<li><p>在TcpConnection中，会监听连接的读事件，当有数据到达时，会调用用户设置的消息到达回调函数。</p>
</li>
<li><p>用户可以通过TcpConnection对象发送消息给客户端，TcpConnection内部会处理发送缓冲区，并通过调用底层的Socket API发送数据。</p>
</li>
<li><p>当连接关闭时，会触发连接关闭回调函数，并将TcpConnection从连接管理字典<code>connections_</code>中移除。</p>
</li>
</ol>
<p>这样，TcpServer实现了对连接客户端的一步步操作，包括接受连接、创建TcpConnection对象、监听事件、处理数据收发等过程。</p>
<p>以下是一个简单的例子来说明TcpServer的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;TcpServer.h&quot;</span><br><span class="line"></span><br><span class="line">void onConnection(const TcpConnectionPtr&amp; conn) &#123;</span><br><span class="line">    if (conn-&gt;connected()) &#123;</span><br><span class="line">        printf(&quot;New connection from %s\n&quot;, conn-&gt;peerAddress().toIpPort().c_str());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        printf(&quot;Connection %s is closed\n&quot;, conn-&gt;peerAddress().toIpPort().c_str());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void onMessage(const TcpConnectionPtr&amp; conn, Buffer* buffer) &#123;</span><br><span class="line">    std::string message = buffer-&gt;retrieveAllAsString();</span><br><span class="line">    printf(&quot;Received message from %s: %s\n&quot;, conn-&gt;peerAddress().toIpPort().c_str(), message.c_str());</span><br><span class="line">    conn-&gt;send(message); // Echo back the received message to the client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    EventLoop loop;</span><br><span class="line">    TcpServer server(&amp;loop, InetAddress(1234), &quot;TestServer&quot;);</span><br><span class="line">    server.setConnectionCallback(onConnection);</span><br><span class="line">    server.setMessageCallback(onMessage);</span><br><span class="line"></span><br><span class="line">    server.start();</span><br><span class="line"></span><br><span class="line">    loop.loop();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们首先创建一个EventLoop对象和一个TcpServer对象。然后，我们设置了连接建立回调函数<code>onConnection</code>和消息到达回调函数<code>onMessage</code>。最后，我们启动服务器并运行事件循环。</p>
<p>当有新的客户端连接时，会调用<code>onConnection</code>函数进行处理，输出连接建立信息。当有消息到达时，会调用<code>onMessage</code>函数进行处理，输出接收到的消息，并将该消息回传给客户端。</p>
<h2 id="TcpServer-h"><a href="#TcpServer-h" class="headerlink" title="TcpServer.h"></a>TcpServer.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">class TcpServer : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  typedef std::function&lt;void(EventLoop*)&gt; ThreadInitCallback;</span><br><span class="line">  enum Option</span><br><span class="line">  &#123;</span><br><span class="line">    kNoReusePort,</span><br><span class="line">    kReusePort,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  //TcpServer(EventLoop* loop, const InetAddress&amp; listenAddr);</span><br><span class="line">  TcpServer(EventLoop* loop,</span><br><span class="line">            const InetAddress&amp; listenAddr,</span><br><span class="line">            const string&amp; nameArg,</span><br><span class="line">            Option option = kNoReusePort);</span><br><span class="line">  ~TcpServer();  // force out-line dtor, for std::unique_ptr members.</span><br><span class="line"></span><br><span class="line">  const string&amp; ipPort() const &#123; return ipPort_; &#125;</span><br><span class="line">  const string&amp; name() const &#123; return name_; &#125;</span><br><span class="line">  EventLoop* getLoop() const &#123; return loop_; &#125;</span><br><span class="line"></span><br><span class="line">  void setThreadNum(int numThreads);</span><br><span class="line">  void setThreadInitCallback(const ThreadInitCallback&amp; cb)</span><br><span class="line">  &#123; threadInitCallback_ = cb; &#125;</span><br><span class="line">  /// valid after calling start()</span><br><span class="line">  std::shared_ptr&lt;EventLoopThreadPool&gt; threadPool()</span><br><span class="line">  &#123; return threadPool_; &#125;</span><br><span class="line"></span><br><span class="line">  /// Starts the server if it&#x27;s not listening.</span><br><span class="line">  ///</span><br><span class="line">  /// It&#x27;s harmless to call it multiple times.</span><br><span class="line">  /// Thread safe.</span><br><span class="line">  void start();</span><br><span class="line"></span><br><span class="line">  /// Set connection callback.</span><br><span class="line">  /// Not thread safe.</span><br><span class="line">  //设置连接到来或者连接关闭回调函数</span><br><span class="line">  void setConnectionCallback(const ConnectionCallback&amp; cb)</span><br><span class="line">  &#123; connectionCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line">  /// Set message callback.</span><br><span class="line">  /// Not thread safe.</span><br><span class="line">  //设置消息到来回调函数</span><br><span class="line">  void setMessageCallback(const MessageCallback&amp; cb)</span><br><span class="line">  &#123; messageCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line">  /// Set write complete callback.</span><br><span class="line">  /// Not thread safe.</span><br><span class="line">  void setWriteCompleteCallback(const WriteCompleteCallback&amp; cb)</span><br><span class="line">  &#123; writeCompleteCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  /// Not thread safe, but in loop</span><br><span class="line">  void newConnection(int sockfd, const InetAddress&amp; peerAddr);</span><br><span class="line">  /// Thread safe.</span><br><span class="line">  void removeConnection(const TcpConnectionPtr&amp; conn);</span><br><span class="line">  /// Not thread safe, but in loop</span><br><span class="line">  void removeConnectionInLoop(const TcpConnectionPtr&amp; conn);</span><br><span class="line"></span><br><span class="line">  typedef std::map&lt;string, TcpConnectionPtr&gt; ConnectionMap;//typedef std::shared_ptr&lt;TcpConnection&gt; TcpConnectionPtr;</span><br><span class="line"></span><br><span class="line">  EventLoop* loop_;  // the acceptor loop</span><br><span class="line">  const string ipPort_;//服务端口</span><br><span class="line">  const string name_;//服务名</span><br><span class="line">  std::unique_ptr&lt;Acceptor&gt; acceptor_; // avoid revealing Acceptor</span><br><span class="line">  std::shared_ptr&lt;EventLoopThreadPool&gt; threadPool_;</span><br><span class="line">  ConnectionCallback connectionCallback_;</span><br><span class="line">  MessageCallback messageCallback_;</span><br><span class="line">  WriteCompleteCallback writeCompleteCallback_;</span><br><span class="line">  ThreadInitCallback threadInitCallback_;</span><br><span class="line">  AtomicInt32 started_;</span><br><span class="line">  </span><br><span class="line">  ConnectionMap connections_;//连接列表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="TcpServer-cc"><a href="#TcpServer-cc" class="headerlink" title="TcpServer.cc"></a>TcpServer.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/net/TcpServer.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line">#include &quot;muduo/net/Acceptor.h&quot;</span><br><span class="line">#include &quot;muduo/net/EventLoop.h&quot;</span><br><span class="line">#include &quot;muduo/net/EventLoopThreadPool.h&quot;</span><br><span class="line">#include &quot;muduo/net/SocketsOps.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;  // snprintf</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">TcpServer::TcpServer(EventLoop* loop,</span><br><span class="line">                     const InetAddress&amp; listenAddr,</span><br><span class="line">                     const string&amp; nameArg,</span><br><span class="line">                     Option option)</span><br><span class="line">  : loop_(CHECK_NOTNULL(loop)),//是Logging.h定义的CHECK_NOTNULL</span><br><span class="line">    ipPort_(listenAddr.toIpPort()),</span><br><span class="line">    name_(nameArg),</span><br><span class="line">    acceptor_(new Acceptor(loop, listenAddr, option == kReusePort)),</span><br><span class="line">    threadPool_(new EventLoopThreadPool(loop, name_)),</span><br><span class="line">    connectionCallback_(defaultConnectionCallback),</span><br><span class="line">    messageCallback_(defaultMessageCallback),</span><br><span class="line">    nextConnId_(1)</span><br><span class="line">&#123;</span><br><span class="line">  //Acceptor: :handleRead函数中会回调用TcpSeruer::newConnection</span><br><span class="line">  //_1对应的是socket文件描述符，2对应的是对等方的地址( InetAddress)</span><br><span class="line">  acceptor_-&gt;setNewConnectionCallback(</span><br><span class="line">      std::bind(&amp;TcpServer::newConnection, this, _1, _2));</span><br><span class="line">&#125;</span><br><span class="line">//该函数多次调用是无害的</span><br><span class="line">//该函数可改跨线程调用</span><br><span class="line">void TcpServer::start()</span><br><span class="line">&#123;</span><br><span class="line">  if (started_.getAndSet(1) == 0)</span><br><span class="line">  &#123;</span><br><span class="line">    threadPool_-&gt;start(threadInitCallback_);</span><br><span class="line"></span><br><span class="line">    assert(!acceptor_-&gt;listening());</span><br><span class="line">    //get_pointer返回原生指针</span><br><span class="line">    loop_-&gt;runInLoop(</span><br><span class="line">        std::bind(&amp;Acceptor::listen, get_pointer(acceptor_)));//ptr.get();裸指针是为了将对象指针传递给 std::bind，从而在可调用对象中使用</span><br><span class="line">  &#125;//acceptor_.get() 是 std::unique_ptr 类提供的成员函数 get() 的调用，它用于获取被智能指针管理的对象的原始裸指针</span><br><span class="line">  //智能指针不能直接传递对象，是因为智能指针对对象进行了所有权管理</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpServer::newConnection(int sockfd, const InetAddress&amp; peerAddr)</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  EventLoop* ioLoop = threadPool_-&gt;getNextLoop();</span><br><span class="line">  char buf[64];</span><br><span class="line">  snprintf(buf, sizeof buf, &quot;-%s#%d&quot;, ipPort_.c_str(), nextConnId_);</span><br><span class="line">  ++nextConnId_;</span><br><span class="line">  string connName = name_ + buf;</span><br><span class="line"></span><br><span class="line">  LOG_INFO &lt;&lt; &quot;TcpServer::newConnection [&quot; &lt;&lt; name_</span><br><span class="line">           &lt;&lt; &quot;] - new connection [&quot; &lt;&lt; connName</span><br><span class="line">           &lt;&lt; &quot;] from &quot; &lt;&lt; peerAddr.toIpPort();</span><br><span class="line">  InetAddress localAddr(sockets::getLocalAddr(sockfd));</span><br><span class="line">  // FIXME poll with zero timeout to double confirm the new connection</span><br><span class="line">  // FIXME use make_shared if necessary</span><br><span class="line">  TcpConnectionPtr conn(new TcpConnection(ioLoop,</span><br><span class="line">                                          connName,</span><br><span class="line">                                          sockfd,</span><br><span class="line">                                          localAddr,</span><br><span class="line">                                          peerAddr));</span><br><span class="line">  connections_[connName] = conn;</span><br><span class="line">  conn-&gt;setConnectionCallback(connectionCallback_);</span><br><span class="line">  conn-&gt;setMessageCallback(messageCallback_);</span><br><span class="line">  conn-&gt;setWriteCompleteCallback(writeCompleteCallback_);</span><br><span class="line">  conn-&gt;setCloseCallback(</span><br><span class="line">      std::bind(&amp;TcpServer::removeConnection, this, _1)); // FIXME: unsafe</span><br><span class="line">  ioLoop-&gt;runInLoop(std::bind(&amp;TcpConnection::connectEstablished, conn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当服务器监听到新的客户端连接请求时，Acceptor类会调用<code>handleRead</code>函数，在<code>handleRead</code>函数中会回调<code>TcpServer</code>类的<code>newConnection</code>函数来处理新的连接。</p>
<p>无论是第一个连接还是后续的连接，都会通过调用<code>newConnection</code>函数来创建相应的TcpConnection对象，并进行必要的初始化和设置。</p>
<h2 id="TcpConnection-h"><a href="#TcpConnection-h" class="headerlink" title="TcpConnection.h"></a>TcpConnection.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void setConnectionCallback(const ConnectionCallback&amp; cb)</span><br><span class="line">  &#123; connectionCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line">  void setMessageCallback(const MessageCallback&amp; cb)</span><br><span class="line">  &#123; messageCallback_ = cb; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="TcpConnection-cc"><a href="#TcpConnection-cc" class="headerlink" title="TcpConnection.cc"></a>TcpConnection.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">TcpConnection::TcpConnection(EventLoop* loop,</span><br><span class="line">                             const string&amp; nameArg,</span><br><span class="line">                             int sockfd,</span><br><span class="line">                             const InetAddress&amp; localAddr,</span><br><span class="line">                             const InetAddress&amp; peerAddr)</span><br><span class="line">  : loop_(CHECK_NOTNULL(loop)),</span><br><span class="line">    name_(nameArg),</span><br><span class="line">    state_(kConnecting),</span><br><span class="line">    reading_(true),</span><br><span class="line">    socket_(new Socket(sockfd)),</span><br><span class="line">    channel_(new Channel(loop, sockfd)),</span><br><span class="line">    localAddr_(localAddr),</span><br><span class="line">    peerAddr_(peerAddr),</span><br><span class="line">    highWaterMark_(64*1024*1024)</span><br><span class="line">&#123;</span><br><span class="line">  //通道可读事件到来的时候，回调TcpConnection::handleRead，_1是事件发生时间</span><br><span class="line">  channel_-&gt;setReadCallback(</span><br><span class="line">      std::bind(&amp;TcpConnection::handleRead, this, _1));</span><br><span class="line">  channel_-&gt;setWriteCallback(</span><br><span class="line">      std::bind(&amp;TcpConnection::handleWrite, this));</span><br><span class="line">  channel_-&gt;setCloseCallback(</span><br><span class="line">      std::bind(&amp;TcpConnection::handleClose, this));</span><br><span class="line">  channel_-&gt;setErrorCallback(</span><br><span class="line">      std::bind(&amp;TcpConnection::handleError, this));</span><br><span class="line">  LOG_DEBUG &lt;&lt; &quot;TcpConnection::ctor[&quot; &lt;&lt;  name_ &lt;&lt; &quot;] at &quot; &lt;&lt; this</span><br><span class="line">            &lt;&lt; &quot; fd=&quot; &lt;&lt; sockfd;</span><br><span class="line">  socket_-&gt;setKeepAlive(true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpConnection::connectEstablished()</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  assert(state_ == kConnecting);</span><br><span class="line">  setState(kConnected);</span><br><span class="line">  channel_-&gt;tie(shared_from_this());</span><br><span class="line">  channel_-&gt;enableReading();//Tcpconnection所对应的通道加入到Poller关注</span><br><span class="line"></span><br><span class="line">  connectionCallback_(shared_from_this());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpConnection::handleRead(Timestamp receiveTime)</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  int savedErrno = 0;</span><br><span class="line">  ssize_t n = inputBuffer_.readFd(channel_-&gt;fd(), &amp;savedErrno);</span><br><span class="line">  if (n &gt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    messageCallback_(shared_from_this(), &amp;inputBuffer_, receiveTime);//shared_from_this()将当前对象转换成shared_ptr，而不是裸指针</span><br><span class="line">  &#125;</span><br><span class="line">  else if (n == 0)</span><br><span class="line">  &#123;</span><br><span class="line">    handleClose();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    errno = savedErrno;</span><br><span class="line">    LOG_SYSERR &lt;&lt; &quot;TcpConnection::handleRead&quot;;</span><br><span class="line">    handleError();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TcpConnection::connectEstablished()</code>函数是TcpConnection类的成员函数，用于在连接成功建立后进行相应的处理。</p>
<p>首先，使用<code>loop_-&gt;assertInLoopThread()</code>断言当前函数被调用的线程是所属的EventLoop线程，以确保函数只能在正确的线程中被调用。</p>
<p>然后，通过<code>assert(state_ == kConnecting)</code>断言当前连接状态<code>state_</code>为正在连接状态，以确保该函数只能在连接状态为正在连接时被调用。</p>
<p>接下来，通过调用<code>setState(kConnected)</code>将连接状态更新为已连接状态。</p>
<p>然后，将TcpConnection所对应的通道<code>channel_</code>与TcpConnection对象自身进行绑定，即调用<code>channel_-&gt;tie(shared_from_this())</code>。这个操作是为了在通道回调函数中可以安全地使用TcpConnection对象。</p>
<p>接着，调用<code>channel_-&gt;enableReading()</code>，将TcpConnection所对应的通道加入到Poller中进行读事件的监听。</p>
<p>最后，调用<code>connectionCallback_(shared_from_this())</code>，即用户设置的连接回调函数，通知用户连接已经建立成功，并将TcpConnection对象作为参数传递给回调函数。</p>
<p>总之，<code>connectEstablished</code>函数在连接成功建立后，会进行一系列的操作，包括更新连接状态、关联通道并进行事件监听，并触发连接回调函数以通知用户连接建立成功。</p>
<h2 id="TcpConnection生存期管理"><a href="#TcpConnection生存期管理" class="headerlink" title="TcpConnection生存期管理"></a>TcpConnection生存期管理</h2><p>当连接到来，创建一个TcpConnection对象，立刻用shared_ptr来管理，引用计数为1<br>在Channel中维护一个<code>weak_ptr(tie_)</code>，将这个<code>shared_ptr</code>对象赋值给<code>tie_</code>引用计数仍为1</p>
<p>当连接关闭，在handleEvent，将<code>tie_</code>提升，得到一个<code>shared_ptr</code>对象，引用计数就变成了2</p>
<p><code>shared_ptr</code> 是 C++ 标准库中的一个智能指针（Smart Pointer）类模板，用于管理动态分配的对象的生命周期。它允许多个 <code>shared_ptr</code> 实例共享同一个堆上的对象，当没有引用指向对象时，对象会自动被销毁，从而避免了内存泄漏。</p>
<p><code>shared_ptr</code> 提供了一种自动引用计数机制，它会跟踪有多少个 <code>shared_ptr</code> 实例指向相同的对象。每当创建一个新的 <code>shared_ptr</code> 指向对象，引用计数会增加；当 <code>shared_ptr</code> 被销毁或重置时，引用计数会减少。当引用计数减少到零时，表示没有 <code>shared_ptr</code> 实例再指向该对象，对象将会被自动删除。</p>
<p>以下是 <code>shared_ptr</code> 的一些重要特性和用法：</p>
<ol>
<li><strong>共享所有权：</strong> 多个 <code>shared_ptr</code> 实例可以共享相同的对象所有权，从而避免了手动管理内存释放。</li>
<li><strong>循环引用问题：</strong> 尽管 <code>shared_ptr</code> 可以有效地管理内存，但如果存在循环引用（两个或多个对象相互引用），可能会导致内存泄漏。为了解决这个问题，可以使用 <code>weak_ptr</code> 来解除循环引用。</li>
<li><strong>自定义删除器：</strong> 可以使用自定义的删除器函数或函数对象来控制对象的销毁过程。</li>
<li><strong>线程安全：</strong> <code>shared_ptr</code> 本身不提供线程安全的保证。多个线程同时修改引用计数可能导致竞态条件。在多线程环境中，需要额外的同步机制来确保安全使用。</li>
<li><strong>使用方便：</strong> <code>shared_ptr</code> 的使用方式类似于常规指针，可以通过 <code>-&gt;</code> 和 <code>*</code> 运算符访问对象的成员。</li>
</ol>
<h3 id="连接关闭时序图"><a href="#连接关闭时序图" class="headerlink" title="连接关闭时序图"></a>连接关闭时序图</h3><p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%884%EF%BC%89/image-20230816112443369.png" alt="image-20230816112443369"></p>
<img src="/2023/08/15/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%884%EF%BC%89/image-20230816112443369.png" class title="This is an test image">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> &#123; /// Internal use only.</span><br><span class="line">  void setCloseCallback(const CloseCallback&amp; cb)</span><br><span class="line">  &#123; closeCallback_ = cb; &#125;</span><br><span class="line">private:</span><br><span class="line">  void connectDestroyed();  // should be called only once</span><br><span class="line">  CloseCallback closeCallback_;//用户内部的连接关闭回调函数</span><br><span class="line">  void handleError();</span><br><span class="line">  void handleClose();</span><br><span class="line"> &#125;; </span><br><span class="line">  typedef std::shared_ptr&lt;TcpConnection&gt; TcpConnectionPtr;</span><br><span class="line">  </span><br><span class="line">  构造函数：</span><br><span class="line">  channel_-&gt;setCloseCallback(</span><br><span class="line">      std::bind(&amp;TcpConnection::handleClose, this));</span><br><span class="line">  channel_-&gt;setErrorCallback(</span><br><span class="line">      std::bind(&amp;TcpConnection::handleError, this));</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">void TcpConnection::handleRead(Timestamp receiveTime)</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  int savedErrno = 0;</span><br><span class="line">  ssize_t n = inputBuffer_.readFd(channel_-&gt;fd(), &amp;savedErrno);</span><br><span class="line">  if (n &gt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    messageCallback_(shared_from_this(), &amp;inputBuffer_, receiveTime);//shared_from_this()将当前对象转换成shared_ptr，而不是裸指针</span><br><span class="line">  &#125;</span><br><span class="line">  else if (n == 0)</span><br><span class="line">  &#123;</span><br><span class="line">    handleClose();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    errno = savedErrno;</span><br><span class="line">    LOG_SYSERR &lt;&lt; &quot;TcpConnection::handleRead&quot;;</span><br><span class="line">    handleError();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpConnection::handleClose()</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  LOG_TRACE &lt;&lt; &quot;fd = &quot; &lt;&lt; channel_-&gt;fd() &lt;&lt; &quot; state = &quot; &lt;&lt; stateToString();</span><br><span class="line">  assert(state_ == kConnected || state_ == kDisconnecting);</span><br><span class="line">  // we don&#x27;t close fd, leave it to dtor, so we can find leaks easily.</span><br><span class="line">  setState(kDisconnected);</span><br><span class="line">  channel_-&gt;disableAll();</span><br><span class="line"></span><br><span class="line">  TcpConnectionPtr guardThis(shared_from_this());</span><br><span class="line">  connectionCallback_(guardThis);//这一行可以不调用</span><br><span class="line">  // must be the last line</span><br><span class="line">  closeCallback_(guardThis);//调用TcpServer::removeConnection</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpConnection::handleError()</span><br><span class="line">&#123;</span><br><span class="line">  int err = sockets::getSocketError(channel_-&gt;fd());</span><br><span class="line">  LOG_ERROR &lt;&lt; &quot;TcpConnection::handleError [&quot; &lt;&lt; name_</span><br><span class="line">            &lt;&lt; &quot;] - SO_ERROR = &quot; &lt;&lt; err &lt;&lt; &quot; &quot; &lt;&lt; strerror_tl(err);</span><br><span class="line">&#125;</span><br><span class="line">void TcpConnection::connectEstablished()</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  assert(state_ == kConnecting);</span><br><span class="line">  setState(kConnected);</span><br><span class="line">  channel_-&gt;tie(shared_from_this());//void tie(const std::shared_ptr&lt;void&gt;&amp;);</span><br><span class="line">  //但是tie_不会更改计数，还是shared_from_this()加一后的，因为它是弱引用，但是shared_from_this()是临死对象，加1后会减1</span><br><span class="line">  //shared_from_this()继承自std::enable_shared_from_this&lt;TcpConnection&gt;，返回一个shared_ptr类型的TcpConnection对象</span><br><span class="line">  channel_-&gt;enableReading();//Tcpconnection所对应的通道加入到Poller关注</span><br><span class="line"></span><br><span class="line">  connectionCallback_(shared_from_this());</span><br><span class="line">&#125;</span><br><span class="line">void TcpServer::removeConnectionInLoop(const TcpConnectionPtr&amp; conn)</span><br><span class="line">// &#123;</span><br><span class="line">//   loop_-&gt;assertInLoopThread();</span><br><span class="line">//   LOG_INFO &lt;&lt; &quot;TcpServer::removeConnectionInLoop [&quot; &lt;&lt; name_</span><br><span class="line">//            &lt;&lt; &quot;] - connection &quot; &lt;&lt; conn-&gt;name();</span><br><span class="line">//   size_t n = connections_.erase(conn-&gt;name());//引用计数减一,从容器中删除相应的键值对</span><br><span class="line">//   (void)n;</span><br><span class="line">//   assert(n == 1);</span><br><span class="line">//   EventLoop* ioLoop = conn-&gt;getLoop();</span><br><span class="line">//   ioLoop-&gt;queueInLoop(//handEvent事件处理完毕后处理functors</span><br><span class="line">//       std::bind(&amp;TcpConnection::connectDestroyed, conn));//引用计数加一</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">void TcpConnection::connectDestroyed()</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  if (state_ == kConnected)//如果handleClose中已调用回调函数，这里就不会再调用</span><br><span class="line">  &#123;</span><br><span class="line">    setState(kDisconnected);</span><br><span class="line">    channel_-&gt;disableAll();</span><br><span class="line"></span><br><span class="line">    connectionCallback_(shared_from_this());//shared_from_this()将当前对象转换成shared_ptr获取，会使shared_ptr引用计数加1，但是是临时对象，马上会销毁</span><br><span class="line">  &#125;</span><br><span class="line">  channel_-&gt;remove();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Channel::handleEvent(Timestamp receiveTime)</span><br><span class="line">&#123;</span><br><span class="line">  std::shared_ptr&lt;void&gt; guard;</span><br><span class="line">  if (tied_)</span><br><span class="line">  &#123;</span><br><span class="line">    guard = tie_.lock();//如果 lock 成功，即 guard 不为空，那么表示资源仍然有效，可以安全地执行 handleEventWithGuard 函数</span><br><span class="line">    if (guard)</span><br><span class="line">    &#123;</span><br><span class="line">      handleEventWithGuard(receiveTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else//如果 lock 失败，即 guard 为空，那么表示被 std::weak_ptr 管理的资源已经失效，不再存在</span><br><span class="line">  &#123;</span><br><span class="line">    handleEventWithGuard(receiveTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tie_.lock()</code> 是 <code>std::weak_ptr</code> 的一个方法，用于创建一个有效的 <code>std::shared_ptr</code>，以便在某个范围内使用这个资源。如果资源仍然有效，<code>lock()</code> 方法将返回一个非空的 <code>std::shared_ptr</code>；如果资源已经失效，它将返回一个空的 <code>std::shared_ptr</code>。</p>
<p>因此，<code>tie_.lock()</code> 方法不是针对 <code>std::shared_ptr</code> 或 <code>std::weak_ptr</code> 类的全局方法，而是 <code>std::weak_ptr</code> 的成员方法，用于操作 <code>std::weak_ptr</code> 对象以检查被观察的资源是否仍然存在。</p>
<p><code>std::shared_ptr</code> 和 <code>std::weak_ptr</code> 是 C++ 标准库中两种用于管理动态分配的对象的智能指针类型。它们之间有关联，主要用于解决循环引用问题以及确保动态分配对象的正确管理。</p>
<p>下面是它们之间的关系：</p>
<ol>
<li><strong>std::shared_ptr</strong>：是一种强引用智能指针，它允许多个 <code>shared_ptr</code> 共享同一个对象，并且通过引用计数来追踪对象的生命周期。当最后一个 <code>shared_ptr</code> 对象释放其引用时，引用计数会降为零，从而释放对象并释放其分配的内存。<code>std::shared_ptr</code> 本身会增加对象的引用计数。</li>
<li><strong>std::weak_ptr</strong>：是一种弱引用智能指针，它不会增加对象的引用计数。它允许观察由 <code>shared_ptr</code> 管理的对象，但不会影响对象的生命周期。最常见的用途是避免循环引用问题，其中两个对象彼此持有对方的 <code>shared_ptr</code>，导致对象无法被正确释放。通过使用 <code>std::weak_ptr</code>，可以解决循环引用问题，因为它不会增加引用计数，但仍然可以用于检查对象是否仍然存在。</li>
</ol>
<p>总结来说，<code>std::shared_ptr</code> 允许多个智能指针共享所有权，并且通过引用计数来管理对象的生命周期。<code>std::weak_ptr</code> 允许观察 <code>std::shared_ptr</code> 管理的对象，但不会影响其生命周期。这两种智能指针在一起使用，可以有效地解决资源管理和循环引用问题。</p>
<p>如果 <code>p</code> 是一个 <code>std::shared_ptr</code> 对象，那么 <code>p.get()</code> 的含义是获取 <code>std::shared_ptr</code> 对象所管理的原始指针</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">肖汇林</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">66</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">肖汇林</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
