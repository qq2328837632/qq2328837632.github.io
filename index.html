<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="选择有时候比努力更重要">
<meta property="og:type" content="website">
<meta property="og:title" content="肖汇林的博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="肖汇林的博客">
<meta property="og:description" content="选择有时候比努力更重要">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="肖汇林">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>肖汇林的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖汇林的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/22/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/22/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-1/" class="post-title-link" itemprop="url">muduo库使用示例-1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-22 20:40:33 / 修改时间：21:37:02" itemprop="dateCreated datePublished" datetime="2023-08-22T20:40:33+08:00">2023-08-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="五个简单TCP协议"><a href="#五个简单TCP协议" class="headerlink" title="五个简单TCP协议"></a>五个简单TCP协议</h1><ul>
<li>discard -丢弃所有收到的数据;</li>
<li>daytime -服务端accept连接之后，以字符串形式发送当前时间，然后主动断开连接;</li>
<li>time -服务端accept连接之后，以二进制形式发送当前时间(从Epoch到现在的秒数)，然后主动断开连接;我们需要一个客户程序来把收到的时间转换为字符串。</li>
<li>echo-回显服务，把收到的数据发回客户端;</li>
<li>chargen-服务端accept连接之后，不停地发送测试数据。</li>
</ul>
<p>网络编程关注三个半事件:</p>
<ul>
<li>连接建立</li>
<li>连接断开</li>
<li>消息到达</li>
<li>消息发送完毕（对于低流量的服务来说，通常不需要关注该事件)</li>
</ul>
<p>提供一个XXXServer类<br>在该类中包含一个Tcpserver对象,和三个半事件，就说明该类是一个TCP服务器了。</p>
<p>muduo库网络模型使用示例(sudoku求解服务器	MuduoManual.pdf P35 )<br>    reactor (一个IO线程)<br>    multiple reactor（多个IO线程)<br>    one loop per thread + thread pool（多个IO线程＋计算线程池）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/22/muduo-inspect%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/22/muduo-inspect%E5%BA%93/" class="post-title-link" itemprop="url">muduo_inspect库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-22 14:59:49 / 修改时间：17:50:24" itemprop="dateCreated datePublished" datetime="2023-08-22T14:59:49+08:00">2023-08-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="muduo-inspect库"><a href="#muduo-inspect库" class="headerlink" title="muduo_inspect库"></a>muduo_inspect库</h1><h2 id="通过HTTP方式为服务器提供监控接口"><a href="#通过HTTP方式为服务器提供监控接口" class="headerlink" title="通过HTTP方式为服务器提供监控接口"></a>通过HTTP方式为服务器提供监控接口</h2><p>接受了多少个TCP连接<br>当前有多少个活动连接</p>
<p>一共响应了多少次请求<br>每次请求的平均响应时间多少毫秒</p>
<p>。。。</p>
<p>要实现这些可以模仿ProcessInspector设置回调函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class ProcessInspector : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  void registerCommands(Inspector* ins);//注册命令接口</span><br><span class="line"></span><br><span class="line">  static string overview(HttpRequest::Method, const Inspector::ArgList&amp;);</span><br><span class="line">  static string pid(HttpRequest::Method, const Inspector::ArgList&amp;);</span><br><span class="line">  static string procStatus(HttpRequest::Method, const Inspector::ArgList&amp;);</span><br><span class="line">  static string openedFiles(HttpRequest::Method, const Inspector::ArgList&amp;);</span><br><span class="line">  static string threads(HttpRequest::Method, const Inspector::ArgList&amp;);</span><br><span class="line"></span><br><span class="line">  static string username_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void ProcessInspector::registerCommands(Inspector* ins)</span><br><span class="line">&#123;</span><br><span class="line">  ins-&gt;add(&quot;proc&quot;, &quot;overview&quot;, ProcessInspector::overview, &quot;print basic overview&quot;);</span><br><span class="line">  ins-&gt;add(&quot;proc&quot;, &quot;pid&quot;, ProcessInspector::pid, &quot;print pid&quot;);</span><br><span class="line">  ins-&gt;add(&quot;proc&quot;, &quot;status&quot;, ProcessInspector::procStatus, &quot;print /proc/self/status&quot;);</span><br><span class="line">  // ins-&gt;add(&quot;proc&quot;, &quot;opened_files&quot;, ProcessInspector::openedFiles, &quot;count /proc/self/fd&quot;);</span><br><span class="line">  ins-&gt;add(&quot;proc&quot;, &quot;threads&quot;, ProcessInspector::threads, &quot;list /proc/self/task&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Inspector"><a href="#Inspector" class="headerlink" title="Inspector"></a>Inspector</h2><p>包含了一个HttpServer对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//如add(&quot;proc&quot;,&quot;pid&quot;，ProcessInspector::pid,&quot;print pid&quot;);</span><br><span class="line">  //http://192.168.48.128:12345/proc/pid这个http请求就会相应的调用ProcessInspector::pid来处理</span><br><span class="line">  /// Add a Callback for handling the special uri : /mudule/command</span><br><span class="line">  void add(const string&amp; module,//模块，命令，回调函数，帮助文本</span><br><span class="line">           const string&amp; command,</span><br><span class="line">           const Callback&amp; cb,</span><br><span class="line">           const string&amp; help);</span><br><span class="line">           private:</span><br><span class="line">  typedef std::map&lt;string, Callback&gt; CommandList;</span><br><span class="line">  typedef std::map&lt;string, string&gt; HelpList;</span><br><span class="line"></span><br><span class="line">  void start();</span><br><span class="line">  void onRequest(const HttpRequest&amp; req, HttpResponse* resp);</span><br><span class="line"></span><br><span class="line">  HttpServer server_;//因为它是一个http服务器</span><br><span class="line">  std::unique_ptr&lt;ProcessInspector&gt; processInspector_;</span><br><span class="line">  std::unique_ptr&lt;PerformanceInspector&gt; performanceInspector_;</span><br><span class="line">  std::unique_ptr&lt;SystemInspector&gt; systemInspector_;</span><br><span class="line">  MutexLock mutex_;</span><br><span class="line">  std::map&lt;string, CommandList&gt; modules_ GUARDED_BY(mutex_);//module,command,Callback</span><br><span class="line">  std::map&lt;string, HelpList&gt; helps_ GUARDED_BY(mutex_);//module,conenand,hellp</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">namespace</span><br><span class="line">&#123;</span><br><span class="line">Inspector* g_globalInspector = 0;</span><br><span class="line"></span><br><span class="line">// Looks buggy</span><br><span class="line">std::vector&lt;string&gt; split(const string&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">  std::vector&lt;string&gt; result;</span><br><span class="line">  size_t start = 0;</span><br><span class="line">  size_t pos = str.find(&#x27;/&#x27;);</span><br><span class="line">  //在使用find()函数查找子字符串时，如果未找到匹配的子字符串，find()函数将返回string::npos作为索引位置，以指示没有找到匹配</span><br><span class="line">  while (pos != string::npos)</span><br><span class="line">  &#123;</span><br><span class="line">    if (pos &gt; start)</span><br><span class="line">    &#123;</span><br><span class="line">      result.push_back(str.substr(start, pos-start));</span><br><span class="line">    &#125;</span><br><span class="line">    start = pos+1;</span><br><span class="line">    pos = str.find(&#x27;/&#x27;, start);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (start &lt; str.length())//说明最后一个字符不是&#x27;/&#x27;</span><br><span class="line">  &#123;</span><br><span class="line">    result.push_back(str.substr(start));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace</span><br><span class="line"></span><br><span class="line">Inspector::Inspector(EventLoop* loop,</span><br><span class="line">                     const InetAddress&amp; httpAddr,</span><br><span class="line">                     const string&amp; name)</span><br><span class="line">    : server_(loop, httpAddr, &quot;Inspector:&quot;+name),</span><br><span class="line">      processInspector_(new ProcessInspector),</span><br><span class="line">      systemInspector_(new SystemInspector)</span><br><span class="line">&#123;</span><br><span class="line">  assert(CurrentThread::isMainThread());</span><br><span class="line">  assert(g_globalInspector == 0);</span><br><span class="line">  g_globalInspector = this;</span><br><span class="line">  server_.setHttpCallback(std::bind(&amp;Inspector::onRequest, this, _1, _2));</span><br><span class="line">  processInspector_-&gt;registerCommands(this);</span><br><span class="line"></span><br><span class="line">  systemInspector_-&gt;registerCommands(this);</span><br><span class="line">#ifdef HAVE_TCMALLOC</span><br><span class="line">  performanceInspector_.reset(new PerformanceInspector);</span><br><span class="line">  performanceInspector_-&gt;registerCommands(this);</span><br><span class="line">#endif</span><br><span class="line">  //这样子做法是为了防止竞态问题</span><br><span class="line">  //如果直接调用start,(当前线程不是IO线程，是主线程）那么有可能，当前构造函数还没返回，</span><br><span class="line">  //httpServer所在的IO线程可能已经收到了http客户端的请求了(因为这时候HttpServer已启动)，那么就会回调</span><br><span class="line">  //Inspector::onRequest，而这时候构造函数还没返回，也就是说对象还没完全构造好</span><br><span class="line">  loop-&gt;runAfter(0, std::bind(&amp;Inspector::start, this)); // little race condition，仍然有点问题，可以将时间改长一点</span><br><span class="line">&#125;</span><br><span class="line">void Inspector::add(const string&amp; module,</span><br><span class="line">                    const string&amp; command,</span><br><span class="line">                    const Callback&amp; cb,</span><br><span class="line">                    const string&amp; help)</span><br><span class="line">&#123;</span><br><span class="line">  MutexLockGuard lock(mutex_);</span><br><span class="line">  modules_[module][command] = cb;</span><br><span class="line">  helps_[module][command] = help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Inspector::start()</span><br><span class="line">&#123;</span><br><span class="line">  server_.start();</span><br><span class="line">&#125;</span><br><span class="line">//一旦http请求就会回调这个函数</span><br><span class="line">void Inspector::onRequest(const HttpRequest&amp; req, HttpResponse* resp)</span><br><span class="line">&#123;</span><br><span class="line">  if (req.path() == &quot;/&quot;)</span><br><span class="line">  &#123;</span><br><span class="line">    string result;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    //遍历helps</span><br><span class="line">    for (std::map&lt;string, HelpList&gt;::const_iterator helpListI = helps_.begin();</span><br><span class="line">         helpListI != helps_.end();</span><br><span class="line">         ++helpListI)</span><br><span class="line">    &#123;</span><br><span class="line">      const HelpList&amp; list = helpListI-&gt;second;</span><br><span class="line">      for (const auto&amp; it : list)</span><br><span class="line">      &#123;</span><br><span class="line">        //其中一条/proc/pid                  print pid</span><br><span class="line">        result += &quot;/&quot;;</span><br><span class="line">        result += helpListI-&gt;first;//module  eg:proc</span><br><span class="line">        result += &quot;/&quot;;</span><br><span class="line">        result += it.first;//command  eg:pid</span><br><span class="line">        size_t len = helpListI-&gt;first.size() + it.first.size();</span><br><span class="line">        result += string(len &gt;= 25 ? 1 : 25 - len, &#x27; &#x27;);</span><br><span class="line">        result += it.second;//help  eg: print pid</span><br><span class="line">        result += &quot;\n&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resp-&gt;setStatusCode(HttpResponse::k200Ok);</span><br><span class="line">    resp-&gt;setStatusMessage(&quot;OK&quot;);</span><br><span class="line">    resp-&gt;setContentType(&quot;text/plain&quot;);</span><br><span class="line">    resp-&gt;setBody(result);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    //以&quot;/&quot;进行分割，将得到的字符串保存在result中</span><br><span class="line">    std::vector&lt;string&gt; result = split(req.path());</span><br><span class="line">    // boost::split(result, req.path(), boost::is_any_of(&quot;/&quot;));</span><br><span class="line">    //std::copy(result.begin(), result.end(), std::ostream_iterator&lt;string&gt;(std::cout, &quot;, &quot;));</span><br><span class="line">    //std::cout &lt;&lt; &quot;\n&quot;;</span><br><span class="line">    bool ok = false;</span><br><span class="line">    if (result.size() == 0)</span><br><span class="line">    &#123;</span><br><span class="line">      //这种情况是错误的，因此OK仍未false</span><br><span class="line">      LOG_DEBUG &lt;&lt; req.path();</span><br><span class="line">    &#125;</span><br><span class="line">    else if (result.size() == 1)</span><br><span class="line">    &#123;</span><br><span class="line">      //只有module，没有connand也是错的，因此ok仍为false,除了下面这种情况</span><br><span class="line">      string module = result[0];</span><br><span class="line">      if (module == &quot;favicon.ico&quot;)</span><br><span class="line">      &#123;</span><br><span class="line">        resp-&gt;setStatusCode(HttpResponse::k200Ok);</span><br><span class="line">        resp-&gt;setStatusMessage(&quot;OK&quot;);</span><br><span class="line">        resp-&gt;setContentType(&quot;image/png&quot;);</span><br><span class="line">        resp-&gt;setBody(string(favicon, sizeof favicon));</span><br><span class="line"></span><br><span class="line">        ok = true;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        LOG_ERROR &lt;&lt; &quot;Unimplemented &quot; &lt;&lt; module;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      string module = result[0];</span><br><span class="line">      MutexLockGuard lock(mutex_);</span><br><span class="line">      //查找module所对应的命令列表</span><br><span class="line">      std::map&lt;string, CommandList&gt;::const_iterator commListI = modules_.find(module);</span><br><span class="line">      if (commListI != modules_.end())</span><br><span class="line">      &#123;</span><br><span class="line">        string command = result[1];</span><br><span class="line">        const CommandList&amp; commList = commListI-&gt;second;</span><br><span class="line">        //查找command对应的命令</span><br><span class="line">        CommandList::const_iterator it = commList.find(command);</span><br><span class="line">        if (it != commList.end())</span><br><span class="line">        &#123;</span><br><span class="line">          ArgList args(result.begin()+2, result.end());//传递给回调函数的参数表</span><br><span class="line">          if (it-&gt;second)//callback</span><br><span class="line">          &#123;</span><br><span class="line">            resp-&gt;setStatusCode(HttpResponse::k200Ok);</span><br><span class="line">            resp-&gt;setStatusMessage(&quot;OK&quot;);</span><br><span class="line">            resp-&gt;setContentType(&quot;text/plain&quot;);</span><br><span class="line">            const Callback&amp; cb = it-&gt;second;</span><br><span class="line">            resp-&gt;setBody(cb(req.method(), args));//调用cb将返回的字符串传给setBody</span><br><span class="line">            ok = true;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!ok)</span><br><span class="line">    &#123;</span><br><span class="line">      resp-&gt;setStatusCode(HttpResponse::k404NotFound);</span><br><span class="line">      resp-&gt;setStatusMessage(&quot;Not Found&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //resp-&gt;setCloseConnection(true);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="ProcessInspector"><a href="#ProcessInspector" class="headerlink" title="ProcessInspector"></a>ProcessInspector</h2><p>通过Processlnfo返回进程信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class ProcessInspector : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  void registerCommands(Inspector* ins);//注册命令接口</span><br><span class="line"></span><br><span class="line">  static string overview(HttpRequest::Method, const Inspector::ArgList&amp;);</span><br><span class="line">  static string pid(HttpRequest::Method, const Inspector::ArgList&amp;);</span><br><span class="line">  static string procStatus(HttpRequest::Method, const Inspector::ArgList&amp;);</span><br><span class="line">  static string openedFiles(HttpRequest::Method, const Inspector::ArgList&amp;);</span><br><span class="line">  static string threads(HttpRequest::Method, const Inspector::ArgList&amp;);</span><br><span class="line"></span><br><span class="line">  static string username_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void ProcessInspector::registerCommands(Inspector* ins)</span><br><span class="line">&#123;</span><br><span class="line">  ins-&gt;add(&quot;proc&quot;, &quot;overview&quot;, ProcessInspector::overview, &quot;print basic overview&quot;);</span><br><span class="line">  ins-&gt;add(&quot;proc&quot;, &quot;pid&quot;, ProcessInspector::pid, &quot;print pid&quot;);</span><br><span class="line">  ins-&gt;add(&quot;proc&quot;, &quot;status&quot;, ProcessInspector::procStatus, &quot;print /proc/self/status&quot;);</span><br><span class="line">  // ins-&gt;add(&quot;proc&quot;, &quot;opened_files&quot;, ProcessInspector::openedFiles, &quot;count /proc/self/fd&quot;);</span><br><span class="line">  ins-&gt;add(&quot;proc&quot;, &quot;threads&quot;, ProcessInspector::threads, &quot;list /proc/self/task&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Processlnfo"><a href="#Processlnfo" class="headerlink" title="Processlnfo"></a>Processlnfo</h2><p>获取进程相关信息</p>
<h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/net/inspect/Inspector.h&quot;</span><br><span class="line">#include &quot;muduo/net/EventLoop.h&quot;</span><br><span class="line">#include &quot;muduo/net/EventLoopThread.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  EventLoop loop;//两个线程，一个主线程，一个监控线程，构造函数在主线程调用</span><br><span class="line">  EventLoopThread t;//监控线程</span><br><span class="line">  Inspector ins(t.startLoop(), InetAddress(12345), &quot;test&quot;);</span><br><span class="line">  loop.loop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.48.128:12345/</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/proc/overview             print basic overview</span><br><span class="line">/proc/pid                  print pid</span><br><span class="line">/proc/status               print /proc/self/status</span><br><span class="line">/proc/threads              list /proc/self/task</span><br><span class="line">/sys/cpuinfo               print /proc/cpuinfo</span><br><span class="line">/sys/loadavg               print /proc/loadavg</span><br><span class="line">/sys/meminfo               print /proc/meminfo</span><br><span class="line">/sys/overview              print system overview</span><br><span class="line">/sys/stat                  print /proc/stat</span><br><span class="line">/sys/version               print /proc/version</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/21/muduo-http%E5%BA%93-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/21/muduo-http%E5%BA%93-1/" class="post-title-link" itemprop="url">muduo-http库(1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-21 16:46:26" itemprop="dateCreated datePublished" datetime="2023-08-21T16:46:26+08:00">2023-08-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-22 12:10:24" itemprop="dateModified" datetime="2023-08-22T12:10:24+08:00">2023-08-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="http-request"><a href="#http-request" class="headerlink" title="http request"></a>http request</h1><p>request line + header + body ( header分为普通报头，请求报头与实体报头)</p>
<p>header与body之间有一空行（CRLF：\r\n)</p>
<p>请求方法有:<br>Get, Post, Head, Put,Delete等</p>
<p>协议版本1.0、1.1</p>
<p>常用请求头</p>
<ul>
<li>Accept:浏览器可接受的媒体（MIME）类型;</li>
<li>Accept-Language:浏览器所希望的语言种类</li>
<li>Accept-Encoding:浏览器能够解码的编码方法，如gzip，deflate等</li>
<li>User-Agent:告诉HTTP服务器，客户端使用的操作系统和浏览器的名称和版本</li>
<li>Connection:表示是否需要持久连接，Keep-Alive表示长连接，close表示短连接</li>
</ul>
<h2 id="一个典型的http请求"><a href="#一个典型的http请求" class="headerlink" title="一个典型的http请求"></a>一个典型的http请求</h2><p><img src="/muduo-http%E5%BA%93-1/image-20230821175548800.png" alt="image-20230821175548800"></p>
<img src="/2023/08/21/muduo-http%E5%BA%93-1/image-20230821175548800.png" class title="This is an test image">

<h1 id="http-response"><a href="#http-response" class="headerlink" title="http response"></a>http response</h1><p>status line + header + body ( header分为普通报头，响应报头与实体报头)</p>
<p>header与body之间有一空行（CRLF)</p>
<p>状态响应码</p>
<ul>
<li>1XX提示信息-表示请求已被成功接收，继续处理</li>
<li>2XX成功-表示请求已被成功接收，理解，接受</li>
<li>3XX重定向-要完成请求必须进行更进一步的处理</li>
<li>4XX客户端错误–请求有语法错误或请求无法实现</li>
<li>5XX服务器端错误–服务器执行一个有效请求失败</li>
</ul>
<h2 id="一个典型的http应答"><a href="#一个典型的http应答" class="headerlink" title="一个典型的http应答"></a>一个典型的http应答</h2><p><img src="/muduo-http%E5%BA%93-1/image-20230821175626176.png" alt="image-20230821175626176"></p>
<img src="/2023/08/21/muduo-http%E5%BA%93-1/image-20230821175626176.png" class title="This is an test image">

<h1 id="muduo-http库涉及到的类"><a href="#muduo-http库涉及到的类" class="headerlink" title="muduo_http库涉及到的类"></a>muduo_http库涉及到的类</h1><h2 id="HttpRequest-http请求类封装"><a href="#HttpRequest-http请求类封装" class="headerlink" title="HttpRequest: http请求类封装"></a>HttpRequest: http请求类封装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_NET_HTTP_HTTPREQUEST_H</span><br><span class="line">#define MUDUO_NET_HTTP_HTTPREQUEST_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/copyable.h&quot;</span><br><span class="line">#include &quot;muduo/base/Timestamp.h&quot;</span><br><span class="line">#include &quot;muduo/base/Types.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">class HttpRequest : public muduo::copyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  enum Method//http支持的方法，不止这些方法</span><br><span class="line">  &#123;</span><br><span class="line">    kInvalid, kGet, kPost, kHead, kPut, kDelete</span><br><span class="line">  &#125;;</span><br><span class="line">  enum Version//http协议版本</span><br><span class="line">  &#123;</span><br><span class="line">    kUnknown, kHttp10, kHttp11</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  HttpRequest()</span><br><span class="line">    : method_(kInvalid),</span><br><span class="line">      version_(kUnknown)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void setVersion(Version v)</span><br><span class="line">  &#123;</span><br><span class="line">    version_ = v;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Version getVersion() const</span><br><span class="line">  &#123; return version_; &#125;</span><br><span class="line"></span><br><span class="line">  bool setMethod(const char* start, const char* end)</span><br><span class="line">  &#123;</span><br><span class="line">    assert(method_ == kInvalid);</span><br><span class="line">    string m(start, end);//迭代器的用法，获取start到end的字符串，不包括end</span><br><span class="line">    if (m == &quot;GET&quot;)</span><br><span class="line">    &#123;</span><br><span class="line">      method_ = kGet;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (m == &quot;POST&quot;)</span><br><span class="line">    &#123;</span><br><span class="line">      method_ = kPost;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (m == &quot;HEAD&quot;)</span><br><span class="line">    &#123;</span><br><span class="line">      method_ = kHead;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (m == &quot;PUT&quot;)</span><br><span class="line">    &#123;</span><br><span class="line">      method_ = kPut;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (m == &quot;DELETE&quot;)</span><br><span class="line">    &#123;</span><br><span class="line">      method_ = kDelete;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      method_ = kInvalid;</span><br><span class="line">    &#125;</span><br><span class="line">    return method_ != kInvalid;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Method method() const</span><br><span class="line">  &#123; return method_; &#125;</span><br><span class="line">  //请求方法转换成字符串</span><br><span class="line">  const char* methodString() const</span><br><span class="line">  &#123;</span><br><span class="line">    const char* result = &quot;UNKNOWN&quot;;</span><br><span class="line">    switch(method_)</span><br><span class="line">    &#123;</span><br><span class="line">      case kGet:</span><br><span class="line">        result = &quot;GET&quot;;</span><br><span class="line">        break;</span><br><span class="line">      case kPost:</span><br><span class="line">        result = &quot;POST&quot;;</span><br><span class="line">        break;</span><br><span class="line">      case kHead:</span><br><span class="line">        result = &quot;HEAD&quot;;</span><br><span class="line">        break;</span><br><span class="line">      case kPut:</span><br><span class="line">        result = &quot;PUT&quot;;</span><br><span class="line">        break;</span><br><span class="line">      case kDelete:</span><br><span class="line">        result = &quot;DELETE&quot;;</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void setPath(const char* start, const char* end)</span><br><span class="line">  &#123;</span><br><span class="line">    path_.assign(start, end);//字符串赋值操作，将从指针 start 指向的位置开始，到指针 end 指向的位置结束的字符序列赋值给 path_</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const string&amp; path() const</span><br><span class="line">  &#123; return path_; &#125;</span><br><span class="line"></span><br><span class="line">  void setQuery(const char* start, const char* end)</span><br><span class="line">  &#123;</span><br><span class="line">    query_.assign(start, end);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const string&amp; query() const</span><br><span class="line">  &#123; return query_; &#125;</span><br><span class="line"></span><br><span class="line">  void setReceiveTime(Timestamp t)</span><br><span class="line">  &#123; receiveTime_ = t; &#125;</span><br><span class="line"></span><br><span class="line">  Timestamp receiveTime() const</span><br><span class="line">  &#123; return receiveTime_; &#125;</span><br><span class="line"></span><br><span class="line">  void addHeader(const char* start, const char* colon, const char* end)//colon冒号</span><br><span class="line">  &#123;</span><br><span class="line">    string field(start, colon);//header域</span><br><span class="line">    ++colon;</span><br><span class="line">    //去除左空格</span><br><span class="line">    while (colon &lt; end &amp;&amp; isspace(*colon))</span><br><span class="line">    &#123;</span><br><span class="line">      ++colon;</span><br><span class="line">    &#125;</span><br><span class="line">    string value(colon, end);//header值</span><br><span class="line">    //去除右空格</span><br><span class="line">    while (!value.empty() &amp;&amp; isspace(value[value.size()-1]))</span><br><span class="line">    &#123;</span><br><span class="line">      value.resize(value.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line">    headers_[field] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  //根据头域返回它的值</span><br><span class="line">  string getHeader(const string&amp; field) const</span><br><span class="line">  &#123;</span><br><span class="line">    string result;</span><br><span class="line">    std::map&lt;string, string&gt;::const_iterator it = headers_.find(field);</span><br><span class="line">    if (it != headers_.end())</span><br><span class="line">    &#123;</span><br><span class="line">      result = it-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const std::map&lt;string, string&gt;&amp; headers() const</span><br><span class="line">  &#123; return headers_; &#125;</span><br><span class="line"></span><br><span class="line">  void swap(HttpRequest&amp; that)</span><br><span class="line">  &#123;</span><br><span class="line">    std::swap(method_, that.method_);</span><br><span class="line">    std::swap(version_, that.version_);</span><br><span class="line">    path_.swap(that.path_);</span><br><span class="line">    query_.swap(that.query_);</span><br><span class="line">    receiveTime_.swap(that.receiveTime_);</span><br><span class="line">    headers_.swap(that.headers_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  Method method_;//请求方法</span><br><span class="line">  Version version_;//协议版本1.0 1.1</span><br><span class="line">  string path_;//请求路径</span><br><span class="line">  string query_;</span><br><span class="line">  Timestamp receiveTime_;//请求时间</span><br><span class="line">  std::map&lt;string, string&gt; headers_;//header列表</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_NET_HTTP_HTTPREQUEST_H</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void addHeader(const char* start, const char* colon, const char* end)//colon冒号</span><br><span class="line">&#123;</span><br><span class="line">  string field(start, colon);//header域</span><br><span class="line">  ++colon;</span><br><span class="line">  //去除左空格</span><br><span class="line">  while (colon &lt; end &amp;&amp; isspace(*colon))</span><br><span class="line">  &#123;</span><br><span class="line">    ++colon;</span><br><span class="line">  &#125;</span><br><span class="line">  string value(colon, end);//header值</span><br><span class="line">  //去除右空格</span><br><span class="line">  while (!value.empty() &amp;&amp; isspace(value[value.size()-1]))</span><br><span class="line">  &#123;</span><br><span class="line">    value.resize(value.size()-1);</span><br><span class="line">  &#125;</span><br><span class="line">  headers_[field] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的作用是将从HTTP请求中解析出来的头部信息（header）添加到一个名为<code>headers_</code>的容器中。</p>
<p>具体而言，该函数接受三个指针参数：<code>start</code>指向头部字段（field）的起始位置，<code>colon</code>指向冒号的位置，<code>end</code>指向头部值（value）的结束位置。</p>
<p>首先，该函数通过将<code>start</code>和<code>colon</code>之间的字符创建一个<code>string</code>对象，即头部字段名。然后，它递增<code>colon</code>指针以跳过冒号，并在循环中去除<code>colon</code>及其后面的所有空格字符。</p>
<p>接下来，函数通过将<code>colon</code>和<code>end</code>之间的字符创建一个<code>string</code>对象，即头部值。再次使用循环，它去除头部值的末尾空格字符，使得头部值不包含任何额外的空白。</p>
<p>最后，函数将头部字段名和头部值作为键值对存储在<code>headers_</code>容器中，以便稍后使用。</p>
<p>总而言之，该函数解析并提取了HTTP请求中的单个头部字段和值，并将它们存储在<code>headers_</code>容器中，方便后续对头部信息的访问和处理。</p>
<h2 id="HttpResponse-http响应类封装"><a href="#HttpResponse-http响应类封装" class="headerlink" title="HttpResponse: http响应类封装"></a>HttpResponse: http响应类封装</h2><h3 id="HttpResponse-h"><a href="#HttpResponse-h" class="headerlink" title="HttpResponse.h"></a>HttpResponse.h</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class HttpResponse : public muduo::copyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  enum HttpStatusCode//响应的状态码枚举类型，不全</span><br><span class="line">  &#123;</span><br><span class="line">    kUnknown,</span><br><span class="line">    k200Ok = 200,//成功</span><br><span class="line">    k301MovedPermanently = 301,//301重定向，请求的页面永久性地转移到另一个地址</span><br><span class="line">    k400BadRequest = 400,//错误的请求，语法格式有误，服务器无法处理此请求</span><br><span class="line">    k404NotFound = 404,//请求的网页不存在</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  explicit HttpResponse(bool close)</span><br><span class="line">    : statusCode_(kUnknown),</span><br><span class="line">      closeConnection_(close)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void setStatusCode(HttpStatusCode code)</span><br><span class="line">  &#123; statusCode_ = code; &#125;</span><br><span class="line"></span><br><span class="line">  void setStatusMessage(const string&amp; message)</span><br><span class="line">  &#123; statusMessage_ = message; &#125;</span><br><span class="line"></span><br><span class="line">  void setCloseConnection(bool on)</span><br><span class="line">  &#123; closeConnection_ = on; &#125;</span><br><span class="line"></span><br><span class="line">  bool closeConnection() const</span><br><span class="line">  &#123; return closeConnection_; &#125;</span><br><span class="line">  //设置文档媒体类型(MIME)</span><br><span class="line">  void setContentType(const string&amp; contentType)</span><br><span class="line">  &#123; addHeader(&quot;Content-Type&quot;, contentType); &#125;</span><br><span class="line"></span><br><span class="line">  // FIXME: replace string with StringPiece</span><br><span class="line">  void addHeader(const string&amp; key, const string&amp; value)</span><br><span class="line">  &#123; headers_[key] = value; &#125;</span><br><span class="line"></span><br><span class="line">  void setBody(const string&amp; body)</span><br><span class="line">  &#123; body_ = body; &#125;</span><br><span class="line"></span><br><span class="line">  void appendToBuffer(Buffer* output) const;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  std::map&lt;string, string&gt; headers_;//header列表</span><br><span class="line">  HttpStatusCode statusCode_;//状态响应码</span><br><span class="line">  // FIXME: add http version</span><br><span class="line">  string statusMessage_;//状态响应码对应的文本信息</span><br><span class="line">  bool closeConnection_;//是否关闭连接</span><br><span class="line">  string body_;         //实体</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="HttpResponse-cc"><a href="#HttpResponse-cc" class="headerlink" title="HttpResponse.cc"></a>HttpResponse.cc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void HttpResponse::appendToBuffer(Buffer* output) const</span><br><span class="line">&#123;</span><br><span class="line">  char buf[32];</span><br><span class="line">  //添加响应头</span><br><span class="line">  snprintf(buf, sizeof buf, &quot;HTTP/1.1 %d &quot;, statusCode_);</span><br><span class="line">  output-&gt;append(buf);</span><br><span class="line">  output-&gt;append(statusMessage_);</span><br><span class="line">  output-&gt;append(&quot;\r\n&quot;);</span><br><span class="line"></span><br><span class="line">  if (closeConnection_)</span><br><span class="line">  &#123;</span><br><span class="line">    //如果是短连接，不存在粘包问题，不需要告诉浏览器Content-Length，浏览器也能正确处理</span><br><span class="line">    output-&gt;append(&quot;Connection: close\r\n&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    //长连接</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;Content-Length: %zd\r\n&quot;, body_.size());//实体长度</span><br><span class="line">    output-&gt;append(buf);</span><br><span class="line">    output-&gt;append(&quot;Connection: Keep-Alive\r\n&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  //header列表</span><br><span class="line">  for (const auto&amp; header : headers_)</span><br><span class="line">  &#123;</span><br><span class="line">    output-&gt;append(header.first);</span><br><span class="line">    output-&gt;append(&quot;: &quot;);</span><br><span class="line">    output-&gt;append(header.second);</span><br><span class="line">    output-&gt;append(&quot;\r\n&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  output-&gt;append(&quot;\r\n&quot;);//header与body之间的空行</span><br><span class="line">  output-&gt;append(body_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="HttpContext-http协议解析类"><a href="#HttpContext-http协议解析类" class="headerlink" title="HttpContext: http协议解析类"></a>HttpContext: http协议解析类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">  enum HttpRequestParseState</span><br><span class="line">  &#123;</span><br><span class="line">    kExpectRequestLine,</span><br><span class="line">    kExpectHeaders,</span><br><span class="line">    kExpectBody,</span><br><span class="line">    kGotAll,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  bool gotAll() const</span><br><span class="line">  &#123; return state_ == kGotAll; &#125;</span><br><span class="line">  //重置HttpContext状态</span><br><span class="line">  HttpRequestParseState state_;//请求解析状态</span><br><span class="line">  HttpRequest request_;//http请求</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  //解析请求行</span><br><span class="line">  bool HttpContext::processRequestLine(const char* begin, const char* end)</span><br><span class="line">&#123;</span><br><span class="line">  bool succeed = false;</span><br><span class="line">  const char* start = begin;</span><br><span class="line">  const char* space = std::find(start, end, &#x27; &#x27;);</span><br><span class="line">  if (space != end &amp;&amp; request_.setMethod(start, space))//解析请求方法</span><br><span class="line">  &#123;</span><br><span class="line">    start = space+1;</span><br><span class="line">    space = std::find(start, end, &#x27; &#x27;);</span><br><span class="line">    if (space != end)</span><br><span class="line">    &#123;</span><br><span class="line">      const char* question = std::find(start, space, &#x27;?&#x27;);</span><br><span class="line">      if (question != space)</span><br><span class="line">      &#123;</span><br><span class="line">        request_.setPath(start, question);</span><br><span class="line">        request_.setQuery(question, space);</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        request_.setPath(start, space);//解析PATH</span><br><span class="line">      &#125;</span><br><span class="line">      start = space+1;</span><br><span class="line">      succeed = end-start == 8 &amp;&amp; std::equal(start, end-1, &quot;HTTP/1.&quot;);</span><br><span class="line">      if (succeed)</span><br><span class="line">      &#123;</span><br><span class="line">        if (*(end-1) == &#x27;1&#x27;)//HTTP/1.1</span><br><span class="line">        &#123;</span><br><span class="line">          request_.setVersion(HttpRequest::kHttp11);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (*(end-1) == &#x27;0&#x27;)//HTTP/1.0</span><br><span class="line">        &#123;</span><br><span class="line">          request_.setVersion(HttpRequest::kHttp10);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">          succeed = false;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return succeed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// return false if any error</span><br><span class="line">bool HttpContext::parseRequest(Buffer* buf, Timestamp receiveTime)</span><br><span class="line">&#123;</span><br><span class="line">  bool ok = true;</span><br><span class="line">  bool hasMore = true;</span><br><span class="line">  while (hasMore)//相当于一个状态机</span><br><span class="line">  &#123;</span><br><span class="line">    if (state_ == kExpectRequestLine)//处于解析请求行的状态</span><br><span class="line">    &#123;</span><br><span class="line">      const char* crlf = buf-&gt;findCRLF();</span><br><span class="line">      if (crlf)</span><br><span class="line">      &#123;</span><br><span class="line">        ok = processRequestLine(buf-&gt;peek(), crlf);//解析请求行</span><br><span class="line">        if (ok)</span><br><span class="line">        &#123;</span><br><span class="line">          request_.setReceiveTime(receiveTime);//设置请求时间</span><br><span class="line">          buf-&gt;retrieveUntil(crlf + 2);//将请求行从buf中取回，包括\r\n</span><br><span class="line">          state_ = kExpectHeaders;//HttpContext将状态改为kExpectHeaders</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">          hasMore = false;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        hasMore = false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (state_ == kExpectHeaders)//解析header</span><br><span class="line">    &#123;</span><br><span class="line">      const char* crlf = buf-&gt;findCRLF();</span><br><span class="line">      if (crlf)</span><br><span class="line">      &#123;</span><br><span class="line">        const char* colon = std::find(buf-&gt;peek(), crlf, &#x27;:&#x27;);//冒号所在位置</span><br><span class="line">        if (colon != crlf)</span><br><span class="line">        &#123;</span><br><span class="line">          request_.addHeader(buf-&gt;peek(), colon, crlf);//函数将头部字段名和头部值作为键值对存储在headers_容器中</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">          // empty line, end of header</span><br><span class="line">          // FIXME:</span><br><span class="line">          state_ = kGotAll;//HttpContext将状态改为 kGotAll</span><br><span class="line">          hasMore = false;</span><br><span class="line">        &#125;</span><br><span class="line">        buf-&gt;retrieveUntil(crlf + 2);//将header从buf中取回，包括\r\n</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        hasMore = false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (state_ == kExpectBody)//当前还不支持请求中带body</span><br><span class="line">    &#123;</span><br><span class="line">      // FIXME:</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是一个基于muduo网络库的HTTP请求解析器，用于解析HTTP请求报文。</p>
<p><code>HttpContext::processRequestLine</code> 函数用于解析请求行，该函数接受两个指针参数 <code>begin</code> 和 <code>end</code>，表示请求行的起始位置和结束位置。函数首先在请求行中寻找空格字符，将请求方法解析出来，并设置到 <code>request_</code> 对象中。然后再次寻找空格字符，解析出路径和查询字符串，并设置到 <code>request_</code> 对象中。最后判断请求的HTTP版本号，并设置到 <code>request_</code> 对象中。</p>
<p><code>HttpContext::parseRequest</code> 函数用于解析完整的HTTP请求报文。该函数接受一个 <code>Buffer</code> 对象和一个时间戳参数。函数通过一个 while 循环来不断解析请求报文的各个部分。</p>
<ul>
<li>当 <code>state_</code> 的值为 <code>kExpectRequestLine</code> 时，表示正在解析请求行。函数调用 <code>buf-&gt;findCRLF()</code> 来查找请求行的结束位置，如果找到了 CRLF（回车换行）字符，则调用 <code>processRequestLine</code> 进行解析。解析成功后，设置请求时间并从 <code>buf</code> 中移除已解析的请求行，然后将 <code>state_</code> 设置为 <code>kExpectHeaders</code>，进入下一个状态。</li>
<li>当 <code>state_</code> 的值为 <code>kExpectHeaders</code> 时，表示正在解析请求头部。函数调用 <code>buf-&gt;findCRLF()</code> 来查找头部的结束位置，如果找到了 CRLF 字符，则调用 <code>request_.addHeader</code> 函数将头部字段名和值存储到 <code>request_</code> 对象中。如果找不到 CRLF 字符，说明还没有解析完所有的头部字段，函数退出循环。</li>
<li>当 <code>state_</code> 的值为 <code>kExpectBody</code> 时，表示请求中带有请求体部分。当前代码中并未实现对请求体的解析。</li>
</ul>
<p>这段代码主要是通过状态机的方式逐步解析HTTP请求报文的各个部分，并将解析结果存储在 <code>request_</code> 对象中。</p>
<h2 id="HttpServer-http服务器类封装"><a href="#HttpServer-http服务器类封装" class="headerlink" title="HttpServer:http服务器类封装"></a>HttpServer:http服务器类封装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">//也是一个Tcp服务器</span><br><span class="line">class HttpServer : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  typedef std::function&lt;void (const HttpRequest&amp;,</span><br><span class="line">                              HttpResponse*)&gt; HttpCallback;</span><br><span class="line"></span><br><span class="line">  HttpServer(EventLoop* loop,</span><br><span class="line">             const InetAddress&amp; listenAddr,</span><br><span class="line">             const string&amp; name,</span><br><span class="line">             TcpServer::Option option = TcpServer::kNoReusePort);</span><br><span class="line"></span><br><span class="line">  EventLoop* getLoop() const &#123; return server_.getLoop(); &#125;</span><br><span class="line"></span><br><span class="line">  /// Not thread safe, callback be registered before calling start().</span><br><span class="line">  void setHttpCallback(const HttpCallback&amp; cb)</span><br><span class="line">  &#123;</span><br><span class="line">    httpCallback_ = cb;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void setThreadNum(int numThreads)</span><br><span class="line">  &#123;</span><br><span class="line">    server_.setThreadNum(numThreads);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void start();</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  void onConnection(const TcpConnectionPtr&amp; conn);</span><br><span class="line">  void onMessage(const TcpConnectionPtr&amp; conn,</span><br><span class="line">                 Buffer* buf,</span><br><span class="line">                 Timestamp receiveTime);</span><br><span class="line">  void onRequest(const TcpConnectionPtr&amp;, const HttpRequest&amp;);</span><br><span class="line"></span><br><span class="line">  TcpServer server_;</span><br><span class="line">  HttpCallback httpCallback_;//在处理http请求(即调用onRequest)的过程中回调此函数，对请求进行具体的处理，boost::any context_;将这个绑定</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line">namespace detail</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">void defaultHttpCallback(const HttpRequest&amp;, HttpResponse* resp)</span><br><span class="line">&#123;</span><br><span class="line">  resp-&gt;setStatusCode(HttpResponse::k404NotFound);</span><br><span class="line">  resp-&gt;setStatusMessage(&quot;Not Found&quot;);</span><br><span class="line">  resp-&gt;setCloseConnection(true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace detail</span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">HttpServer::HttpServer(EventLoop* loop,</span><br><span class="line">                       const InetAddress&amp; listenAddr,</span><br><span class="line">                       const string&amp; name,</span><br><span class="line">                       TcpServer::Option option)</span><br><span class="line">  : server_(loop, listenAddr, name, option),</span><br><span class="line">    httpCallback_(detail::defaultHttpCallback)</span><br><span class="line">&#123;</span><br><span class="line">  server_.setConnectionCallback(</span><br><span class="line">      std::bind(&amp;HttpServer::onConnection, this, _1));</span><br><span class="line">  server_.setMessageCallback(</span><br><span class="line">      std::bind(&amp;HttpServer::onMessage, this, _1, _2, _3));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HttpServer::start()</span><br><span class="line">&#123;</span><br><span class="line">  LOG_WARN &lt;&lt; &quot;HttpServer[&quot; &lt;&lt; server_.name()</span><br><span class="line">    &lt;&lt; &quot;] starts listening on &quot; &lt;&lt; server_.ipPort();</span><br><span class="line">  server_.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HttpServer::onConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">&#123;</span><br><span class="line">  if (conn-&gt;connected())</span><br><span class="line">  &#123;</span><br><span class="line">    conn-&gt;setContext(HttpContext());//TcpConnection与一个HttpContext绑定</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HttpServer::onMessage(const TcpConnectionPtr&amp; conn,</span><br><span class="line">                           Buffer* buf,</span><br><span class="line">                           Timestamp receiveTime)</span><br><span class="line">&#123;</span><br><span class="line">  HttpContext* context = boost::any_cast&lt;HttpContext&gt;(conn-&gt;getMutableContext());</span><br><span class="line">  //解析请求包</span><br><span class="line">  if (!context-&gt;parseRequest(buf, receiveTime))</span><br><span class="line">  &#123;</span><br><span class="line">    conn-&gt;send(&quot;HTTP/1.1 400 Bad Request\r\n\r\n&quot;);</span><br><span class="line">    conn-&gt;shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">  //请求解析完毕</span><br><span class="line">  if (context-&gt;gotAll())</span><br><span class="line">  &#123;</span><br><span class="line">    onRequest(conn, context-&gt;request());</span><br><span class="line">    context-&gt;reset();//本次请求处理完毕，重置Httpcontext，适用于长连接</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HttpServer::onRequest(const TcpConnectionPtr&amp; conn, const HttpRequest&amp; req)</span><br><span class="line">&#123;</span><br><span class="line">  const string&amp; connection = req.getHeader(&quot;Connection&quot;);//根据头域返回它的值</span><br><span class="line">  bool close = connection == &quot;close&quot; ||</span><br><span class="line">    (req.getVersion() == HttpRequest::kHttp10 &amp;&amp; connection != &quot;Keep-Alive&quot;);//1.0版本只支持短连接</span><br><span class="line">  HttpResponse response(close);//处理完请求是否要关闭连接</span><br><span class="line">  httpCallback_(req, &amp;response);//回调用户的函数对HTTP进行相应的处理，处理完，会返回一个response对象</span><br><span class="line">  Buffer buf;</span><br><span class="line">  response.appendToBuffer(&amp;buf);</span><br><span class="line">  conn-&gt;send(&amp;buf);</span><br><span class="line">  if (response.closeConnection())</span><br><span class="line">  &#123;</span><br><span class="line">    conn-&gt;shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">extern char favicon[555];</span><br><span class="line">bool benchmark = false;</span><br><span class="line">//实际的请求处理，返回一个http应答</span><br><span class="line">void onRequest(const HttpRequest&amp; req, HttpResponse* resp)</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; &quot;Headers &quot; &lt;&lt; req.methodString() &lt;&lt; &quot; &quot; &lt;&lt; req.path() &lt;&lt; std::endl;</span><br><span class="line">  if (!benchmark)</span><br><span class="line">  &#123;</span><br><span class="line">    const std::map&lt;string, string&gt;&amp; headers = req.headers();</span><br><span class="line">    for (const auto&amp; header : headers)</span><br><span class="line">    &#123;</span><br><span class="line">      std::cout &lt;&lt; header.first &lt;&lt; &quot;: &quot; &lt;&lt; header.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (req.path() == &quot;/&quot;)</span><br><span class="line">  &#123;</span><br><span class="line">    resp-&gt;setStatusCode(HttpResponse::k200Ok);</span><br><span class="line">    resp-&gt;setStatusMessage(&quot;OK&quot;);</span><br><span class="line">    resp-&gt;setContentType(&quot;text/html&quot;);</span><br><span class="line">    resp-&gt;addHeader(&quot;Server&quot;, &quot;Muduo&quot;);</span><br><span class="line">    string now = Timestamp::now().toFormattedString();</span><br><span class="line">    resp-&gt;setBody(&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;This is title&lt;/title&gt;&lt;/head&gt;&quot;</span><br><span class="line">        &quot;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;Now is &quot; + now +</span><br><span class="line">        &quot;&lt;/body&gt;&lt;/html&gt;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  else if (req.path() == &quot;/favicon.ico&quot;)</span><br><span class="line">  &#123;</span><br><span class="line">    resp-&gt;setStatusCode(HttpResponse::k200Ok);</span><br><span class="line">    resp-&gt;setStatusMessage(&quot;OK&quot;);</span><br><span class="line">    resp-&gt;setContentType(&quot;image/png&quot;);</span><br><span class="line">    resp-&gt;setBody(string(favicon, sizeof favicon));</span><br><span class="line">  &#125;</span><br><span class="line">  else if (req.path() == &quot;/hello&quot;)</span><br><span class="line">  &#123;</span><br><span class="line">    resp-&gt;setStatusCode(HttpResponse::k200Ok);</span><br><span class="line">    resp-&gt;setStatusMessage(&quot;OK&quot;);</span><br><span class="line">    resp-&gt;setContentType(&quot;text/plain&quot;);</span><br><span class="line">    resp-&gt;addHeader(&quot;Server&quot;, &quot;Muduo&quot;);</span><br><span class="line">    resp-&gt;setBody(&quot;hello, world!\n&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    resp-&gt;setStatusCode(HttpResponse::k404NotFound);</span><br><span class="line">    resp-&gt;setStatusMessage(&quot;Not Found&quot;);</span><br><span class="line">    resp-&gt;setCloseConnection(true);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">  int numThreads = 0;</span><br><span class="line">  if (argc &gt; 1)</span><br><span class="line">  &#123;</span><br><span class="line">    benchmark = true;</span><br><span class="line">    Logger::setLogLevel(Logger::WARN);</span><br><span class="line">    numThreads = atoi(argv[1]);</span><br><span class="line">  &#125;</span><br><span class="line">  EventLoop loop;</span><br><span class="line">  HttpServer server(&amp;loop, InetAddress(8000), &quot;dummy&quot;);</span><br><span class="line">  server.setHttpCallback(onRequest);</span><br><span class="line">  server.setThreadNum(numThreads);</span><br><span class="line">  server.start();</span><br><span class="line">  loop.loop();</span><br><span class="line">&#125;</span><br><span class="line">//这是一个图片数据</span><br><span class="line">char favicon[555] = &#123;</span><br><span class="line">  &#x27;\x89&#x27;, &#x27;P&#x27;, &#x27;N&#x27;, &#x27;G&#x27;, &#x27;\xD&#x27;, &#x27;\xA&#x27;, &#x27;\x1A&#x27;, &#x27;\xA&#x27;,</span><br><span class="line">  &#x27;\x0&#x27;, &#x27;\x0&#x27;, &#x27;\x0&#x27;, &#x27;\xD&#x27;, &#x27;I&#x27;, &#x27;H&#x27;, &#x27;D&#x27;, &#x27;R&#x27;,</span><br><span class="line">  &#x27;\x0&#x27;, &#x27;\x0&#x27;, &#x27;\x0&#x27;, &#x27;\x10&#x27;, &#x27;\x0&#x27;, &#x27;\x0&#x27;, &#x27;\x0&#x27;, &#x27;\x10&#x27;,</span><br><span class="line">  &#x27;\x8&#x27;, &#x27;\x6&#x27;, &#x27;\x0&#x27;, &#x27;\x0&#x27;, &#x27;\x0&#x27;, &#x27;\x1F&#x27;, &#x27;\xF3&#x27;, &#x27;\xFF&#x27;,</span><br><span class="line">  &#x27;a&#x27;, &#x27;\x0&#x27;, &#x27;\x0&#x27;, &#x27;\x0&#x27;, &#x27;\x19&#x27;, &#x27;t&#x27;, &#x27;E&#x27;, &#x27;X&#x27;,</span><br><span class="line">  &#x27;t&#x27;, &#x27;S&#x27;, &#x27;o&#x27;, &#x27;f&#x27;, &#x27;t&#x27;, &#x27;w&#x27;, &#x27;a&#x27;, &#x27;r&#x27;,</span><br><span class="line">  &#x27;e&#x27;, &#x27;\x0&#x27;, &#x27;A&#x27;, &#x27;d&#x27;, &#x27;o&#x27;, &#x27;b&#x27;, &#x27;e&#x27;, &#x27;\x20&#x27;,</span><br><span class="line">  &#x27;I&#x27;, &#x27;m&#x27;, &#x27;a&#x27;, &#x27;g&#x27;, &#x27;e&#x27;, &#x27;R&#x27;, &#x27;e&#x27;, &#x27;a&#x27;,</span><br><span class="line">  &#x27;d&#x27;, &#x27;y&#x27;, &#x27;q&#x27;, &#x27;\xC9&#x27;, &#x27;e&#x27;, &#x27;\x3C&#x27;, &#x27;\x0&#x27;, &#x27;\x0&#x27;,</span><br><span class="line">  &#x27;\x1&#x27;, &#x27;\xCD&#x27;, &#x27;I&#x27;, &#x27;D&#x27;, &#x27;A&#x27;, &#x27;T&#x27;, &#x27;x&#x27;, &#x27;\xDA&#x27;,</span><br><span class="line">  &#x27;\x94&#x27;, &#x27;\x93&#x27;, &#x27;9&#x27;, &#x27;H&#x27;, &#x27;\x3&#x27;, &#x27;A&#x27;, &#x27;\x14&#x27;, &#x27;\x86&#x27;,</span><br><span class="line">  &#x27;\xFF&#x27;, &#x27;\x5D&#x27;, &#x27;b&#x27;, &#x27;\xA7&#x27;, &#x27;\x4&#x27;, &#x27;R&#x27;, &#x27;\xC4&#x27;, &#x27;m&#x27;,</span><br><span class="line">  &#x27;\x22&#x27;, &#x27;\x1E&#x27;, &#x27;\xA0&#x27;, &#x27;F&#x27;, &#x27;\x24&#x27;, &#x27;\x8&#x27;, &#x27;\x16&#x27;, &#x27;\x16&#x27;,</span><br><span class="line">  &#x27;v&#x27;, &#x27;\xA&#x27;, &#x27;6&#x27;, &#x27;\xBA&#x27;, &#x27;J&#x27;, &#x27;\x9A&#x27;, &#x27;\x80&#x27;, &#x27;\x8&#x27;,</span><br><span class="line">  &#x27;A&#x27;, &#x27;\xB4&#x27;, &#x27;q&#x27;, &#x27;\x85&#x27;, &#x27;X&#x27;, &#x27;\x89&#x27;, &#x27;G&#x27;, &#x27;\xB0&#x27;,</span><br><span class="line">  &#x27;I&#x27;, &#x27;\xA9&#x27;, &#x27;Q&#x27;, &#x27;\x24&#x27;, &#x27;\xCD&#x27;, &#x27;\xA6&#x27;, &#x27;\x8&#x27;, &#x27;\xA4&#x27;,</span><br><span class="line">  &#x27;H&#x27;, &#x27;c&#x27;, &#x27;\x91&#x27;, &#x27;B&#x27;, &#x27;\xB&#x27;, &#x27;\xAF&#x27;, &#x27;V&#x27;, &#x27;\xC1&#x27;,</span><br><span class="line">  &#x27;F&#x27;, &#x27;\xB4&#x27;, &#x27;\x15&#x27;, &#x27;\xCF&#x27;, &#x27;\x22&#x27;, &#x27;X&#x27;, &#x27;\x98&#x27;, &#x27;\xB&#x27;,</span><br><span class="line">  &#x27;T&#x27;, &#x27;H&#x27;, &#x27;\x8A&#x27;, &#x27;d&#x27;, &#x27;\x93&#x27;, &#x27;\x8D&#x27;, &#x27;\xFB&#x27;, &#x27;F&#x27;,</span><br><span class="line">  &#x27;g&#x27;, &#x27;\xC9&#x27;, &#x27;\x1A&#x27;, &#x27;\x14&#x27;, &#x27;\x7D&#x27;, &#x27;\xF0&#x27;, &#x27;f&#x27;, &#x27;v&#x27;,</span><br><span class="line">  &#x27;f&#x27;, &#x27;\xDF&#x27;, &#x27;\x7C&#x27;, &#x27;\xEF&#x27;, &#x27;\xE7&#x27;, &#x27;g&#x27;, &#x27;F&#x27;, &#x27;\xA8&#x27;,</span><br><span class="line">  &#x27;\xD5&#x27;, &#x27;j&#x27;, &#x27;H&#x27;, &#x27;\x24&#x27;, &#x27;\x12&#x27;, &#x27;\x2A&#x27;, &#x27;\x0&#x27;, &#x27;\x5&#x27;,</span><br><span class="line">  &#x27;\xBF&#x27;, &#x27;G&#x27;, &#x27;\xD4&#x27;, &#x27;\xEF&#x27;, &#x27;\xF7&#x27;, &#x27;\x2F&#x27;, &#x27;6&#x27;, &#x27;\xEC&#x27;,</span><br><span class="line">  &#x27;\x12&#x27;, &#x27;\x20&#x27;, &#x27;\x1E&#x27;, &#x27;\x8F&#x27;, &#x27;\xD7&#x27;, &#x27;\xAA&#x27;, &#x27;\xD5&#x27;, &#x27;\xEA&#x27;,</span><br><span class="line">  &#x27;\xAF&#x27;, &#x27;I&#x27;, &#x27;5&#x27;, &#x27;F&#x27;, &#x27;\xAA&#x27;, &#x27;T&#x27;, &#x27;\x5F&#x27;, &#x27;\x9F&#x27;,</span><br><span class="line">  &#x27;\x22&#x27;, &#x27;A&#x27;, &#x27;\x2A&#x27;, &#x27;\x95&#x27;, &#x27;\xA&#x27;, &#x27;\x83&#x27;, &#x27;\xE5&#x27;, &#x27;r&#x27;,</span><br><span class="line">  &#x27;9&#x27;, &#x27;d&#x27;, &#x27;\xB3&#x27;, &#x27;Y&#x27;, &#x27;\x96&#x27;, &#x27;\x99&#x27;, &#x27;L&#x27;, &#x27;\x6&#x27;,</span><br><span class="line">  &#x27;\xE9&#x27;, &#x27;t&#x27;, &#x27;\x9A&#x27;, &#x27;\x25&#x27;, &#x27;\x85&#x27;, &#x27;\x2C&#x27;, &#x27;\xCB&#x27;, &#x27;T&#x27;,</span><br><span class="line">  &#x27;\xA7&#x27;, &#x27;\xC4&#x27;, &#x27;b&#x27;, &#x27;1&#x27;, &#x27;\xB5&#x27;, &#x27;\x5E&#x27;, &#x27;\x0&#x27;, &#x27;\x3&#x27;,</span><br><span class="line">  &#x27;h&#x27;, &#x27;\x9A&#x27;, &#x27;\xC6&#x27;, &#x27;\x16&#x27;, &#x27;\x82&#x27;, &#x27;\x20&#x27;, &#x27;X&#x27;, &#x27;R&#x27;,</span><br><span class="line">  &#x27;\x14&#x27;, &#x27;E&#x27;, &#x27;6&#x27;, &#x27;S&#x27;, &#x27;\x94&#x27;, &#x27;\xCB&#x27;, &#x27;e&#x27;, &#x27;x&#x27;,</span><br><span class="line">  &#x27;\xBD&#x27;, &#x27;\x5E&#x27;, &#x27;\xAA&#x27;, &#x27;U&#x27;, &#x27;T&#x27;, &#x27;\x23&#x27;, &#x27;L&#x27;, &#x27;\xC0&#x27;,</span><br><span class="line">  &#x27;\xE0&#x27;, &#x27;\xE2&#x27;, &#x27;\xC1&#x27;, &#x27;\x8F&#x27;, &#x27;\x0&#x27;, &#x27;\x9E&#x27;, &#x27;\xBC&#x27;, &#x27;\x9&#x27;,</span><br><span class="line">  &#x27;A&#x27;, &#x27;\x7C&#x27;, &#x27;\x3E&#x27;, &#x27;\x1F&#x27;, &#x27;\x83&#x27;, &#x27;D&#x27;, &#x27;\x22&#x27;, &#x27;\x11&#x27;,</span><br><span class="line">  &#x27;\xD5&#x27;, &#x27;T&#x27;, &#x27;\x40&#x27;, &#x27;\x3F&#x27;, &#x27;8&#x27;, &#x27;\x80&#x27;, &#x27;w&#x27;, &#x27;\xE5&#x27;,</span><br><span class="line">  &#x27;3&#x27;, &#x27;\x7&#x27;, &#x27;\xB8&#x27;, &#x27;\x5C&#x27;, &#x27;\x2E&#x27;, &#x27;H&#x27;, &#x27;\x92&#x27;, &#x27;\x4&#x27;,</span><br><span class="line">  &#x27;\x87&#x27;, &#x27;\xC3&#x27;, &#x27;\x81&#x27;, &#x27;\x40&#x27;, &#x27;\x20&#x27;, &#x27;\x40&#x27;, &#x27;g&#x27;, &#x27;\x98&#x27;,</span><br><span class="line">  &#x27;\xE9&#x27;, &#x27;6&#x27;, &#x27;\x1A&#x27;, &#x27;\xA6&#x27;, &#x27;g&#x27;, &#x27;\x15&#x27;, &#x27;\x4&#x27;, &#x27;\xE3&#x27;,</span><br><span class="line">  &#x27;\xD7&#x27;, &#x27;\xC8&#x27;, &#x27;\xBD&#x27;, &#x27;\x15&#x27;, &#x27;\xE1&#x27;, &#x27;i&#x27;, &#x27;\xB7&#x27;, &#x27;C&#x27;,</span><br><span class="line">  &#x27;\xAB&#x27;, &#x27;\xEA&#x27;, &#x27;x&#x27;, &#x27;\x2F&#x27;, &#x27;j&#x27;, &#x27;X&#x27;, &#x27;\x92&#x27;, &#x27;\xBB&#x27;,</span><br><span class="line">  &#x27;\x18&#x27;, &#x27;\x20&#x27;, &#x27;\x9F&#x27;, &#x27;\xCF&#x27;, &#x27;3&#x27;, &#x27;\xC3&#x27;, &#x27;\xB8&#x27;, &#x27;\xE9&#x27;,</span><br><span class="line">  &#x27;N&#x27;, &#x27;\xA7&#x27;, &#x27;\xD3&#x27;, &#x27;l&#x27;, &#x27;J&#x27;, &#x27;\x0&#x27;, &#x27;i&#x27;, &#x27;6&#x27;,</span><br><span class="line">  &#x27;\x7C&#x27;, &#x27;\x8E&#x27;, &#x27;\xE1&#x27;, &#x27;\xFE&#x27;, &#x27;V&#x27;, &#x27;\x84&#x27;, &#x27;\xE7&#x27;, &#x27;\x3C&#x27;,</span><br><span class="line">  &#x27;\x9F&#x27;, &#x27;r&#x27;, &#x27;\x2B&#x27;, &#x27;\x3A&#x27;, &#x27;B&#x27;, &#x27;\x7B&#x27;, &#x27;7&#x27;, &#x27;f&#x27;,</span><br><span class="line">  &#x27;w&#x27;, &#x27;\xAE&#x27;, &#x27;\x8E&#x27;, &#x27;\xE&#x27;, &#x27;\xF3&#x27;, &#x27;\xBD&#x27;, &#x27;R&#x27;, &#x27;\xA9&#x27;,</span><br><span class="line">  &#x27;d&#x27;, &#x27;\x2&#x27;, &#x27;B&#x27;, &#x27;\xAF&#x27;, &#x27;\x85&#x27;, &#x27;2&#x27;, &#x27;f&#x27;, &#x27;F&#x27;,</span><br><span class="line">  &#x27;\xBA&#x27;, &#x27;\xC&#x27;, &#x27;\xD9&#x27;, &#x27;\x9F&#x27;, &#x27;\x1D&#x27;, &#x27;\x9A&#x27;, &#x27;l&#x27;, &#x27;\x22&#x27;,</span><br><span class="line">  &#x27;\xE6&#x27;, &#x27;\xC7&#x27;, &#x27;\x3A&#x27;, &#x27;\x2C&#x27;, &#x27;\x80&#x27;, &#x27;\xEF&#x27;, &#x27;\xC1&#x27;, &#x27;\x15&#x27;,</span><br><span class="line">  &#x27;\x90&#x27;, &#x27;\x7&#x27;, &#x27;\x93&#x27;, &#x27;\xA2&#x27;, &#x27;\x28&#x27;, &#x27;\xA0&#x27;, &#x27;S&#x27;, &#x27;j&#x27;,</span><br><span class="line">  &#x27;\xB1&#x27;, &#x27;\xB8&#x27;, &#x27;\xDF&#x27;, &#x27;\x29&#x27;, &#x27;5&#x27;, &#x27;C&#x27;, &#x27;\xE&#x27;, &#x27;\x3F&#x27;,</span><br><span class="line">  &#x27;X&#x27;, &#x27;\xFC&#x27;, &#x27;\x98&#x27;, &#x27;\xDA&#x27;, &#x27;y&#x27;, &#x27;j&#x27;, &#x27;P&#x27;, &#x27;\x40&#x27;,</span><br><span class="line">  &#x27;\x0&#x27;, &#x27;\x87&#x27;, &#x27;\xAE&#x27;, &#x27;\x1B&#x27;, &#x27;\x17&#x27;, &#x27;B&#x27;, &#x27;\xB4&#x27;, &#x27;\x3A&#x27;,</span><br><span class="line">  &#x27;\x3F&#x27;, &#x27;\xBE&#x27;, &#x27;y&#x27;, &#x27;\xC7&#x27;, &#x27;\xA&#x27;, &#x27;\x26&#x27;, &#x27;\xB6&#x27;, &#x27;\xEE&#x27;,</span><br><span class="line">  &#x27;\xD9&#x27;, &#x27;\x9A&#x27;, &#x27;\x60&#x27;, &#x27;\x14&#x27;, &#x27;\x93&#x27;, &#x27;\xDB&#x27;, &#x27;\x8F&#x27;, &#x27;\xD&#x27;,</span><br><span class="line">  &#x27;\xA&#x27;, &#x27;\x2E&#x27;, &#x27;\xE9&#x27;, &#x27;\x23&#x27;, &#x27;\x95&#x27;, &#x27;\x29&#x27;, &#x27;X&#x27;, &#x27;\x0&#x27;,</span><br><span class="line">  &#x27;\x27&#x27;, &#x27;\xEB&#x27;, &#x27;n&#x27;, &#x27;V&#x27;, &#x27;p&#x27;, &#x27;\xBC&#x27;, &#x27;\xD6&#x27;, &#x27;\xCB&#x27;,</span><br><span class="line">  &#x27;\xD6&#x27;, &#x27;G&#x27;, &#x27;\xAB&#x27;, &#x27;\x3D&#x27;, &#x27;l&#x27;, &#x27;\x7D&#x27;, &#x27;\xB8&#x27;, &#x27;\xD2&#x27;,</span><br><span class="line">  &#x27;\xDD&#x27;, &#x27;\xA0&#x27;, &#x27;\x60&#x27;, &#x27;\x83&#x27;, &#x27;\xBA&#x27;, &#x27;\xEF&#x27;, &#x27;\x5F&#x27;, &#x27;\xA4&#x27;,</span><br><span class="line">  &#x27;\xEA&#x27;, &#x27;\xCC&#x27;, &#x27;\x2&#x27;, &#x27;N&#x27;, &#x27;\xAE&#x27;, &#x27;\x5E&#x27;, &#x27;p&#x27;, &#x27;\x1A&#x27;,</span><br><span class="line">  &#x27;\xEC&#x27;, &#x27;\xB3&#x27;, &#x27;\x40&#x27;, &#x27;9&#x27;, &#x27;\xAC&#x27;, &#x27;\xFE&#x27;, &#x27;\xF2&#x27;, &#x27;\x91&#x27;,</span><br><span class="line">  &#x27;\x89&#x27;, &#x27;g&#x27;, &#x27;\x91&#x27;, &#x27;\x85&#x27;, &#x27;\x21&#x27;, &#x27;\xA8&#x27;, &#x27;\x87&#x27;, &#x27;\xB7&#x27;,</span><br><span class="line">  &#x27;X&#x27;, &#x27;\x7E&#x27;, &#x27;\x7E&#x27;, &#x27;\x85&#x27;, &#x27;\xBB&#x27;, &#x27;\xCD&#x27;, &#x27;N&#x27;, &#x27;N&#x27;,</span><br><span class="line">  &#x27;b&#x27;, &#x27;t&#x27;, &#x27;\x40&#x27;, &#x27;\xFA&#x27;, &#x27;\x93&#x27;, &#x27;\x89&#x27;, &#x27;\xEC&#x27;, &#x27;\x1E&#x27;,</span><br><span class="line">  &#x27;\xEC&#x27;, &#x27;\x86&#x27;, &#x27;\x2&#x27;, &#x27;H&#x27;, &#x27;\x26&#x27;, &#x27;\x93&#x27;, &#x27;\xD0&#x27;, &#x27;u&#x27;,</span><br><span class="line">  &#x27;\x1D&#x27;, &#x27;\x7F&#x27;, &#x27;\x9&#x27;, &#x27;2&#x27;, &#x27;\x95&#x27;, &#x27;\xBF&#x27;, &#x27;\x1F&#x27;, &#x27;\xDB&#x27;,</span><br><span class="line">  &#x27;\xD7&#x27;, &#x27;c&#x27;, &#x27;\x8A&#x27;, &#x27;\x1A&#x27;, &#x27;\xF7&#x27;, &#x27;\x5C&#x27;, &#x27;\xC1&#x27;, &#x27;\xFF&#x27;,</span><br><span class="line">  &#x27;\x22&#x27;, &#x27;J&#x27;, &#x27;\xC3&#x27;, &#x27;\x87&#x27;, &#x27;\x0&#x27;, &#x27;\x3&#x27;, &#x27;\x0&#x27;, &#x27;K&#x27;,</span><br><span class="line">  &#x27;\xBB&#x27;, &#x27;\xF8&#x27;, &#x27;\xD6&#x27;, &#x27;\x2A&#x27;, &#x27;v&#x27;, &#x27;\x98&#x27;, &#x27;I&#x27;, &#x27;\x0&#x27;,</span><br><span class="line">  &#x27;\x0&#x27;, &#x27;\x0&#x27;, &#x27;\x0&#x27;, &#x27;I&#x27;, &#x27;E&#x27;, &#x27;N&#x27;, &#x27;D&#x27;, &#x27;\xAE&#x27;,</span><br><span class="line">  &#x27;B&#x27;, &#x27;\x60&#x27;, &#x27;\x82&#x27;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/20/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%886%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/20/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%886%EF%BC%89/" class="post-title-link" itemprop="url">muduo-网络库（6）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-20 10:44:58" itemprop="dateCreated datePublished" datetime="2023-08-20T10:44:58+08:00">2023-08-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-21 16:45:29" itemprop="dateModified" datetime="2023-08-21T16:45:29+08:00">2023-08-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="完善TcpConnection"><a href="#完善TcpConnection" class="headerlink" title="完善TcpConnection"></a>完善TcpConnection</h1><h2 id="WriteCompleteCallback含义"><a href="#WriteCompleteCallback含义" class="headerlink" title="WriteCompleteCallback含义"></a>WriteCompleteCallback含义</h2><p><strong>对于大流量的数据</strong><br>不断生成数据,然后发送conn.&gt;send2.<br>如果对等方接受不及时，受到通告窗口的控制，内核发送缓冲不足，这个时候，就会将用户数据添加到应用层发送缓冲区(output buffer);可能会撑爆output buffer.<br>解决方法就是,调整发送频率。<br>关注WriteCompleteCallback<br>当所有的用户数据都拷贝到内核缓冲区，WriteCompleteCallback回调，然后继续发送。output buffer被清空也会回调该函数，可以理解为低水位标回调函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WriteCompleteCallback writeCompleteCallback_;//当所有的用户数据都拷贝到内核缓冲区，WriteCompleteCallback回调，然后继续发送。</span><br><span class="line">                                              //output buffer被清空也会回调该函数（也就是所有的用户数据都拷贝到内核缓冲区），可以理解为低水位标回调函数。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">void TcpConnection::sendInLoop(const void* data, size_t len)</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  ssize_t nwrote = 0;</span><br><span class="line">  size_t remaining = len;</span><br><span class="line">  bool faultError = false;</span><br><span class="line">  if (state_ == kDisconnected)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_WARN &lt;&lt; &quot;disconnected, give up writing&quot;;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  // if no thing in output queue, try writing directly</span><br><span class="line">  //通道没有关注可写事件并且发送缓冲区没有数据，直接write</span><br><span class="line">  if (!channel_-&gt;isWriting() &amp;&amp; outputBuffer_.readableBytes() == 0)</span><br><span class="line">  &#123;</span><br><span class="line">    nwrote = sockets::write(channel_-&gt;fd(), data, len);</span><br><span class="line">    if (nwrote &gt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">      remaining = len - nwrote;</span><br><span class="line">      //写完了，回调writeCompleteCallback_</span><br><span class="line">      if (remaining == 0 &amp;&amp; writeCompleteCallback_)</span><br><span class="line">      &#123;</span><br><span class="line">        loop_-&gt;queueInLoop(std::bind(writeCompleteCallback_, shared_from_this()));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else // nwrote &lt; 0</span><br><span class="line">    &#123;</span><br><span class="line">      nwrote = 0;</span><br><span class="line">      if (errno != EWOULDBLOCK)</span><br><span class="line">      &#123;</span><br><span class="line">        LOG_SYSERR &lt;&lt; &quot;TcpConnection::sendInLoop&quot;;</span><br><span class="line">        if (errno == EPIPE || errno == ECONNRESET) // FIXME: any others?</span><br><span class="line">        &#123;</span><br><span class="line">          faultError = true;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert(remaining &lt;= len);</span><br><span class="line">  //没有错误，并且还有未写完的数据（说明内核发送缓冲区满，要将未写完的数据添加到output buffer中)</span><br><span class="line">  if (!faultError &amp;&amp; remaining &gt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    size_t oldLen = outputBuffer_.readableBytes();</span><br><span class="line">    //如果超过highwaterMark_(高水位标)，回调highwaterMarkCallback_</span><br><span class="line">    if (oldLen + remaining &gt;= highWaterMark_</span><br><span class="line">        &amp;&amp; oldLen &lt; highWaterMark_</span><br><span class="line">        &amp;&amp; highWaterMarkCallback_)</span><br><span class="line">    &#123;</span><br><span class="line">      loop_-&gt;queueInLoop(std::bind(highWaterMarkCallback_, shared_from_this(), oldLen + remaining));</span><br><span class="line">    &#125;</span><br><span class="line">    outputBuffer_.append(static_cast&lt;const char*&gt;(data)+nwrote, remaining);</span><br><span class="line">    if (!channel_-&gt;isWriting())</span><br><span class="line">    &#123;</span><br><span class="line">      channel_-&gt;enableWriting();//关注pollout事件 </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//当内核发送缓冲区有空间了，pollout事件触发就会回调该函数</span><br><span class="line">  //通道可写事件到来的时候，回调TcpConnection::handleWrite</span><br><span class="line">  channel_-&gt;setWriteCallback(</span><br><span class="line">      std::bind(&amp;TcpConnection::handleWrite, this));</span><br><span class="line"></span><br><span class="line">void TcpConnection::handleWrite()</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  if (channel_-&gt;isWriting())</span><br><span class="line">  &#123;</span><br><span class="line">    ssize_t n = sockets::write(channel_-&gt;fd(),</span><br><span class="line">                               outputBuffer_.peek(),</span><br><span class="line">                               outputBuffer_.readableBytes());</span><br><span class="line">    if (n &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      outputBuffer_.retrieve(n);</span><br><span class="line">      if (outputBuffer_.readableBytes() == 0)//发送缓冲区已清空</span><br><span class="line">      &#123;</span><br><span class="line">        channel_-&gt;disableWriting();//停止关注pollout事件，以免出现busyloop</span><br><span class="line">        if (writeCompleteCallback_)//回调writeCompleteCallback_</span><br><span class="line">        &#123;</span><br><span class="line">          //应用层发送缓冲区已被清空，就回调用writeCompleteCallback_</span><br><span class="line">          loop_-&gt;queueInLoop(std::bind(writeCompleteCallback_, shared_from_this()));</span><br><span class="line">        &#125;</span><br><span class="line">        if (state_ == kDisconnecting)//发送缓冲区已被清空并且连接状态是kDisconnecting，要关闭连接</span><br><span class="line">        &#123;</span><br><span class="line">          shutdownInLoop();//关闭连接</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      LOG_SYSERR &lt;&lt; &quot;TcpConnection::handleWrite&quot;;</span><br><span class="line">      // if (state_ == kDisconnecting)</span><br><span class="line">      // &#123;</span><br><span class="line">      //   shutdownInLoop();</span><br><span class="line">      // &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_TRACE &lt;&lt; &quot;Connection fd = &quot; &lt;&lt; channel_-&gt;fd()</span><br><span class="line">              &lt;&lt; &quot; is down, no more writing&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="HighWaterMarkCallback含义"><a href="#HighWaterMarkCallback含义" class="headerlink" title="HighWaterMarkCallback含义"></a>HighWaterMarkCallback含义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HighWaterMarkCallback highWaterMarkCallback_;//高水位标回调函数，也就是output buffer撑到一定程度回调该函数</span><br></pre></td></tr></table></figure>

<h2 id="boost-any-context"><a href="#boost-any-context" class="headerlink" title="boost::any context_"></a>boost::any context_</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void setContext(const boost::any&amp; context)</span><br><span class="line">  &#123; context_ = context; &#125;</span><br><span class="line"></span><br><span class="line">  const boost::any&amp; getContext() const//外部不可以更改</span><br><span class="line">  &#123; return context_; &#125;</span><br><span class="line"></span><br><span class="line">  boost::any* getMutableContext()//可以更改</span><br><span class="line">  &#123; return &amp;context_; &#125;</span><br><span class="line">  boost::any context_;//你可以使用C++17中引入的std::any来替代boost::any，绑定一个未知类型的上下文对象</span><br></pre></td></tr></table></figure>

<h2 id="std-any"><a href="#std-any" class="headerlink" title="std::any"></a>std::any</h2><p>可以使用C++17中引入的std::any来替代boost::any，绑定一个未知类型的上下文对象</p>
<p><code>std::any context_;</code>的目的是创建一个可以存储任意类型对象的变量。</p>
<p>使用<code>std::any</code>可以在不事先知道对象类型的情况下，将其存储在一个统一的容器中。</p>
<p><code>std::any</code>提供了以下功能：</p>
<ol>
<li>存储任意类型的对象：你可以将任何类型的对象赋值给<code>context_</code>，无论是内置类型（例如int、float）还是自定义类型。</li>
<li>类型安全的访问：你可以使用<code>std::any_cast</code>函数来安全地将对象从<code>std::any</code>中检索出来，并进行类型转换。如果尝试将<code>std::any</code>中存储的对象转换为与实际类型不匹配的类型，将会抛出<code>std::bad_any_cast</code>异常。</li>
<li>空状态检查：你可以使用<code>std::any</code>的<code>has_value</code>函数来检查它是否包含了一个有效的对象。</li>
</ol>
<p><code>std::any</code>的灵活性使得它可以用于各种情况，特别适用于需要在运行时处理不同类型对象的场景，例如实现插件系统、通用数据结构等</p>
<h2 id="signal-SIGPIPE-SIG-IGN"><a href="#signal-SIGPIPE-SIG-IGN" class="headerlink" title="signal(SIGPIPE, SIG_IGN)"></a>signal(SIGPIPE, SIG_IGN)</h2><p>EvenLoop.cc中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#pragma GCC diagnostic ignored &quot;-Wold-style-cast&quot;</span><br><span class="line">//编译器不会发出或记录与这种旧式的类型转换相关的警告信息。</span><br><span class="line">//这是因为这段代码中可能使用了旧式的C风格类型转换，而该警告可以帮助开发者避免一些潜在的问题</span><br><span class="line">//封装了系统调用</span><br><span class="line">class IgnoreSigPipe</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  IgnoreSigPipe()</span><br><span class="line">  &#123;</span><br><span class="line">    ::signal(SIGPIPE, SIG_IGN);</span><br><span class="line">    // LOG_TRACE &lt;&lt; &quot;Ignore SIGPIPE&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">#pragma GCC diagnostic error &quot;-Wold-style-cast&quot;</span><br><span class="line">//如果后面的代码中出现了旧式的类型转换，编译器将会将其作为错误处理，终止编译过程</span><br><span class="line">IgnoreSigPipe initObj;</span><br><span class="line">&#125;// namespace 代码被放置在了匿名的 namespace 中。这意味着其中的内容只对当前文件中的代码可见，不会对其他文件中的代码造成影响。这在一定程度上隐藏了实现细节，限制了作用域，并且通过将 IgnoreSigPipe 类声明为 private，限制了类在文件之外的可见性。这样可以帮助控制代码的组织和维护，并减少了潜在的命名冲突。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="可变类型解决方案"><a href="#可变类型解决方案" class="headerlink" title="可变类型解决方案"></a>可变类型解决方案</h2><ul>
<li>void*.这种方法不是类型安全的</li>
<li>boost:any<ul>
<li>任意类型的类型安全存储以及安全的取回</li>
<li>在标准库容器中存放不同类型的方法，比如说<code>vector&lt;boost::any&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">class TestServer&#123;</span><br><span class="line">public:</span><br><span class="line">TestServer(EventLoop*1oop,const InetAddress&amp; listenAddr)</span><br><span class="line">			:loop_(loop),</span><br><span class="line">			server(loop,1istenAddr,&quot;TestServer&quot;)</span><br><span class="line">	&#123;</span><br><span class="line">		server_.setconnectionCa11back(</span><br><span class="line">			boost::bind(&amp;Testserver::onConnection,this，_1));</span><br><span class="line">		server_.setMessageCa11back(</span><br><span class="line">			boost::bind(&amp;TestServer::onMessage, this，_1,_2,_3));</span><br><span class="line">		server_.setWriteCompleteCallback(</span><br><span class="line">			boost::bind(&amp;TestServer::onWriteComplete, this，_1));</span><br><span class="line">		//生成数据</span><br><span class="line">		string line;</span><br><span class="line">		for (int i = 33; i &lt; 127;++i)&#123;</span><br><span class="line">			line.push_back(char(i));</span><br><span class="line">		&#125;</span><br><span class="line">		line += line;</span><br><span class="line">		for (size_t i =0 ; i &lt; 127-33; ++i)&#123;</span><br><span class="line">			message_ += line.substr(i,72)+ &#x27;\n&#x27;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	void start()&#123;</span><br><span class="line">		server_.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	void:onConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">	&#123;</span><br><span class="line">		if( conn-&gt;connected())&#123;</span><br><span class="line">			printf(&quot;onconnection(): new connettion [%s]from %s\n&quot;,</span><br><span class="line">				conn-&gt;name()-&gt;c_str(),</span><br><span class="line">				conn-&gt;peerAddress().toIpPort().c_str());</span><br><span class="line">			conn-&gt;setTcpNoDelay(true);</span><br><span class="line">			conn-&gt;send(message_);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			printf(&quot;onconnection():connettion [%s] is down\n&quot;,</span><br><span class="line">				conn-&gt;name()-&gt;c_str());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	void onMessage(const TcpConnectionPtr&amp; conn,</span><br><span class="line">					Buffer* buf,</span><br><span class="line">					Timestamp receiveTime)</span><br><span class="line">	&#123;</span><br><span class="line">		muduo::string msg(buf-&gt;retrieveAllAsString());</span><br><span class="line">		printf(&quot;onMessage(): received %zd bytes from connection [%s] at %s\n&quot;,</span><br><span class="line">				msg.size(),</span><br><span class="line">				conn-&gt;name().c_str(),</span><br><span class="line">				receiveTime.toFormattedString().c_str());</span><br><span class="line">		conn-&gt;send(msg);</span><br><span class="line">	&#125;</span><br><span class="line">	void onWriteComplete(const TcpConnectionPtr&amp; conn)</span><br><span class="line">	&#123;</span><br><span class="line">		conn-&gt;send(message_);</span><br><span class="line">	&#125;</span><br><span class="line">	EventLoop* 1oop_;</span><br><span class="line">	TcpServer server_;</span><br><span class="line">	muduo::string message_;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">	printf( &quot;main(): pid = %d\n&quot;,getpid());</span><br><span class="line">	InetAddress listenAddr(8888);</span><br><span class="line">	EventLoop 1oop;</span><br><span class="line">	TestServer server(&amp;1oop,listenAddr);</span><br><span class="line">	server.start();</span><br><span class="line">	1oop.loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段示例代码可以实现chargen服务程序</p>
<p>“chargen” 是指字符发生器（Character Generator）服务程序。它是一种网络服务，最初用于测试和诊断网络连接。</p>
<p>chargen 服务程序会向连接到它的客户端发送一系列 ASCII 字符。这些字符通常是可打印字符的连续序列，如字母、数字和标点符号等。服务程序以循环的方式生成字符，并不停地发送给客户端，直到连接关闭为止。</p>
<p>chargen 服务通常用于测试网络传输的稳定性和性能。通过向客户端发送大量的字符数据，可以模拟网络流量的负载情况。这对于查找网络传输问题、测量网络带宽的上限以及评估系统的抗压能力等方面非常有用。</p>
<p>然而，由于 chargen 服务产生大量的网络流量，可能会导致网络拥塞和安全问题。因此，在实际应用中，chargen 服务通常不会被广泛使用，并且在许多系统中默认关闭或禁用。可以用于进行DoS攻击。</p>
<h1 id="muduo库对编写tcp客户端程序的支持"><a href="#muduo库对编写tcp客户端程序的支持" class="headerlink" title="muduo库对编写tcp客户端程序的支持"></a>muduo库对编写tcp客户端程序的支持</h1><h2 id="Connector-h"><a href="#Connector-h" class="headerlink" title="Connector.h"></a>Connector.h</h2><p>主动发起连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_NET_CONNECTOR_H</span><br><span class="line">#define MUDUO_NET_CONNECTOR_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/noncopyable.h&quot;</span><br><span class="line">#include &quot;muduo/net/InetAddress.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">class Channel;</span><br><span class="line">class EventLoop;</span><br><span class="line"></span><br><span class="line">//主动发起连接，带有自动重连功能</span><br><span class="line">class Connector : noncopyable,</span><br><span class="line">                  public std::enable_shared_from_this&lt;Connector&gt;</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  typedef std::function&lt;void (int sockfd)&gt; NewConnectionCallback;</span><br><span class="line"></span><br><span class="line">  Connector(EventLoop* loop, const InetAddress&amp; serverAddr);</span><br><span class="line">  ~Connector();</span><br><span class="line"></span><br><span class="line">  void setNewConnectionCallback(const NewConnectionCallback&amp; cb)</span><br><span class="line">  &#123; newConnectionCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line">  void start();  // can be called in any thread</span><br><span class="line">  void restart();  // must be called in loop thread</span><br><span class="line">  void stop();  // can be called in any thread</span><br><span class="line"></span><br><span class="line">  const InetAddress&amp; serverAddress() const &#123; return serverAddr_; &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  enum States &#123; kDisconnected, kConnecting, kConnected &#125;;</span><br><span class="line">  static const int kMaxRetryDelayMs = 30*1000;//38秒，最大重连延迟时间</span><br><span class="line">  static const int kInitRetryDelayMs = 500;  //0.5秒，初始状态，连接不上，0.5秒后重连</span><br><span class="line"></span><br><span class="line">  void setState(States s) &#123; state_ = s; &#125;</span><br><span class="line">  void startInLoop();</span><br><span class="line">  void stopInLoop();</span><br><span class="line">  void connect();</span><br><span class="line">  void connecting(int sockfd);</span><br><span class="line">  void handleWrite();</span><br><span class="line">  void handleError();</span><br><span class="line">  void retry(int sockfd);</span><br><span class="line">  int removeAndResetChannel();</span><br><span class="line">  void resetChannel();</span><br><span class="line"></span><br><span class="line">  EventLoop* loop_;//所属EventLoop</span><br><span class="line">  InetAddress serverAddr_;//服务器端地址</span><br><span class="line">  bool connect_; // atomic</span><br><span class="line">  States state_;  // FIXME: use atomic variable</span><br><span class="line">  std::unique_ptr&lt;Channel&gt; channel_;//connector所对应的Channel</span><br><span class="line">  NewConnectionCallback newConnectionCallback_;//连接成功回调函数</span><br><span class="line">  int retryDelayMs_;//重连延迟时间（单位：毫秒）</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_NET_CONNECTOR_H</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Connector-cc"><a href="#Connector-cc" class="headerlink" title="Connector.cc"></a>Connector.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line">//可以跨线程调用</span><br><span class="line">void Connector::start()</span><br><span class="line">&#123;</span><br><span class="line">  connect_ = true;</span><br><span class="line">  loop_-&gt;runInLoop(std::bind(&amp;Connector::startInLoop, this)); // FIXME: unsafe</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Connector::startInLoop()</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  assert(state_ == kDisconnected);</span><br><span class="line">  if (connect_)</span><br><span class="line">  &#123;</span><br><span class="line">    connect();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_DEBUG &lt;&lt; &quot;do not connect&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Connector::stop()</span><br><span class="line">&#123;</span><br><span class="line">  connect_ = false;</span><br><span class="line">  loop_-&gt;queueInLoop(std::bind(&amp;Connector::stopInLoop, this)); // FIXME: unsafe</span><br><span class="line">  // FIXME: cancel timer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Connector::stopInLoop()</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  if (state_ == kConnecting)</span><br><span class="line">  &#123;</span><br><span class="line">    setState(kDisconnected);</span><br><span class="line">    int sockfd = removeAndResetChannel();//将通道从poller中移除关注，并将channel置空</span><br><span class="line">    retry(sockfd);//这里并非要重连，只是调用sockets::close(sockfd);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Connector::connect()</span><br><span class="line">&#123;</span><br><span class="line">  int sockfd = sockets::createNonblockingOrDie(serverAddr_.family());//创建非阻塞套接字</span><br><span class="line">  int ret = sockets::connect(sockfd, serverAddr_.getSockAddr());</span><br><span class="line">  int savedErrno = (ret == 0) ? 0 : errno;</span><br><span class="line">  switch (savedErrno)</span><br><span class="line">  &#123;</span><br><span class="line">    case 0:</span><br><span class="line">    case EINPROGRESS://非阻塞套接字，未连接成功返回码是EINPROGRESs表示正在连接</span><br><span class="line">    case EINTR:</span><br><span class="line">    case EISCONN:   //连接成功</span><br><span class="line">      connecting(sockfd);</span><br><span class="line">      break;</span><br><span class="line"></span><br><span class="line">    case EAGAIN:</span><br><span class="line">    case EADDRINUSE:</span><br><span class="line">    case EADDRNOTAVAIL:</span><br><span class="line">    case ECONNREFUSED:</span><br><span class="line">    case ENETUNREACH:</span><br><span class="line">      retry(sockfd);//重连</span><br><span class="line">      break;</span><br><span class="line"></span><br><span class="line">    case EACCES:</span><br><span class="line">    case EPERM:</span><br><span class="line">    case EAFNOSUPPORT:</span><br><span class="line">    case EALREADY:</span><br><span class="line">    case EBADF:</span><br><span class="line">    case EFAULT:</span><br><span class="line">    case ENOTSOCK:</span><br><span class="line">      LOG_SYSERR &lt;&lt; &quot;connect error in Connector::startInLoop &quot; &lt;&lt; savedErrno;</span><br><span class="line">      sockets::close(sockfd);//不能重连，关闭sockfd</span><br><span class="line">      break;</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">      LOG_SYSERR &lt;&lt; &quot;Unexpected error in Connector::startInLoop &quot; &lt;&lt; savedErrno;</span><br><span class="line">      sockets::close(sockfd);</span><br><span class="line">      // connectErrorCallback_();</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Connector::restart()</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  setState(kDisconnected);</span><br><span class="line">  retryDelayMs_ = kInitRetryDelayMs;</span><br><span class="line">  connect_ = true;</span><br><span class="line">  startInLoop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Connector::connecting(int sockfd)</span><br><span class="line">&#123;</span><br><span class="line">  setState(kConnecting);</span><br><span class="line">  assert(!channel_);</span><br><span class="line">  //channel与sockfd关联</span><br><span class="line">  channel_.reset(new Channel(loop_, sockfd));</span><br><span class="line">  //设置可写回调函数，这时候如果socket没有错误，sockfd就处于可写状态</span><br><span class="line">  channel_-&gt;setWriteCallback(</span><br><span class="line">      std::bind(&amp;Connector::handleWrite, this)); // FIXME: unsafe</span><br><span class="line">  channel_-&gt;setErrorCallback(</span><br><span class="line">      std::bind(&amp;Connector::handleError, this)); // FIXME: unsafe</span><br><span class="line"></span><br><span class="line">  // channel_-&gt;tie(shared_from_this()); is not working,</span><br><span class="line">  // as channel_ is not managed by shared_ptr</span><br><span class="line">  channel_-&gt;enableWriting();//让poller关注可写事件</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Connector::removeAndResetChannel()</span><br><span class="line">&#123;</span><br><span class="line">  channel_-&gt;disableAll();</span><br><span class="line">  channel_-&gt;remove();</span><br><span class="line">  int sockfd = channel_-&gt;fd();</span><br><span class="line">  // Can&#x27;t reset channel_ here, because we are inside Channel::handleEvent</span><br><span class="line">  //不能在这里重置channel_，因为正在调用Channel::handleEvent</span><br><span class="line">  loop_-&gt;queueInLoop(std::bind(&amp;Connector::resetChannel, this)); // FIXME: unsafe</span><br><span class="line">  return sockfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Connector::resetChannel()</span><br><span class="line">&#123;</span><br><span class="line">  channel_.reset();//channle_置空</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Connector::handleWrite()</span><br><span class="line">&#123;</span><br><span class="line">  LOG_TRACE &lt;&lt; &quot;Connector::handleWrite &quot; &lt;&lt; state_;</span><br><span class="line"></span><br><span class="line">  if (state_ == kConnecting)</span><br><span class="line">  &#123;</span><br><span class="line">    int sockfd = removeAndResetChannel();//从poller中移除关注，并将channel置空</span><br><span class="line">    //socket可写并不意味着连接一定建立成功</span><br><span class="line">    //还需要用getsockopt(sockfd, SOL_SOCKET，SO_ERROR，.….)再次确认一下.</span><br><span class="line">    int err = sockets::getSocketError(sockfd);</span><br><span class="line">    if (err)</span><br><span class="line">    &#123;</span><br><span class="line">      LOG_WARN &lt;&lt; &quot;Connector::handleWrite - SO_ERROR = &quot;</span><br><span class="line">               &lt;&lt; err &lt;&lt; &quot; &quot; &lt;&lt; strerror_tl(err);</span><br><span class="line">      retry(sockfd);//重连</span><br><span class="line">    &#125;</span><br><span class="line">    //sockets::isSelfConnect函数的作用是通过比较本地地址和对端地址的端口号和IP地址，判断一个连接是否为自连接</span><br><span class="line">    //在网络编程中，自连接指的是本地主机与自身之间建立的连接。这种情况通常发生在客户端和服务器运行在同一台主机上，且使用相同的地址和端口进行通信的情况下</span><br><span class="line">    else if (sockets::isSelfConnect(sockfd))//自连接</span><br><span class="line">    &#123;</span><br><span class="line">      LOG_WARN &lt;&lt; &quot;Connector::handleWrite - Self connect&quot;;</span><br><span class="line">      retry(sockfd);//重连</span><br><span class="line">    &#125;</span><br><span class="line">    else//连接成功</span><br><span class="line">    &#123;</span><br><span class="line">      setState(kConnected);</span><br><span class="line">      if (connect_)</span><br><span class="line">      &#123;</span><br><span class="line">        newConnectionCallback_(sockfd);//回调</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        sockets::close(sockfd);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    // what happened?</span><br><span class="line">    assert(state_ == kDisconnected);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Connector::handleError()</span><br><span class="line">&#123;</span><br><span class="line">  LOG_ERROR &lt;&lt; &quot;Connector::handleError state=&quot; &lt;&lt; state_;</span><br><span class="line">  if (state_ == kConnecting)</span><br><span class="line">  &#123;</span><br><span class="line">    int sockfd = removeAndResetChannel();//从poller中移除关注，并将channel置空</span><br><span class="line">    //需要移除对可写事件的关注的原因是已经建立了与服务器的连接。在连接成功后，我们不再需要关注套接字是否可写，因为我们已经知道它是可写的。移除对可写事件的关注可以减少不必要的事件通知和资源消耗</span><br><span class="line">    int err = sockets::getSocketError(sockfd);</span><br><span class="line">    LOG_TRACE &lt;&lt; &quot;SO_ERROR = &quot; &lt;&lt; err &lt;&lt; &quot; &quot; &lt;&lt; strerror_tl(err);</span><br><span class="line">    retry(sockfd);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//采用back-off策略重连，即重连时间逐渐延长，0.5s，1s，2s，...直至30s</span><br><span class="line">void Connector::retry(int sockfd)</span><br><span class="line">&#123;</span><br><span class="line">  sockets::close(sockfd);</span><br><span class="line">  setState(kDisconnected);</span><br><span class="line">  if (connect_)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_INFO &lt;&lt; &quot;Connector::retry - Retry connecting to &quot; &lt;&lt; serverAddr_.toIpPort()</span><br><span class="line">             &lt;&lt; &quot; in &quot; &lt;&lt; retryDelayMs_ &lt;&lt; &quot; milliseconds. &quot;;</span><br><span class="line">    //注册一个定时操作，重连</span><br><span class="line">    loop_-&gt;runAfter(retryDelayMs_/1000.0,</span><br><span class="line">                    std::bind(&amp;Connector::startInLoop, shared_from_this()));</span><br><span class="line">    retryDelayMs_ = std::min(retryDelayMs_ * 2, kMaxRetryDelayMs);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_DEBUG &lt;&lt; &quot;do not connect&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="TcpClient-h"><a href="#TcpClient-h" class="headerlink" title="TcpClient.h"></a>TcpClient.h</h2><p>包含了一个Connector对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_NET_TCPCLIENT_H</span><br><span class="line">#define MUDUO_NET_TCPCLIENT_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Mutex.h&quot;</span><br><span class="line">#include &quot;muduo/net/TcpConnection.h&quot;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">class Connector;</span><br><span class="line">typedef std::shared_ptr&lt;Connector&gt; ConnectorPtr;</span><br><span class="line"></span><br><span class="line">class TcpClient : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  // TcpClient(EventLoop* loop);</span><br><span class="line">  // TcpClient(EventLoop* loop, const string&amp; host, uint16_t port);</span><br><span class="line">  TcpClient(EventLoop* loop,</span><br><span class="line">            const InetAddress&amp; serverAddr,</span><br><span class="line">            const string&amp; nameArg);</span><br><span class="line">  ~TcpClient();  // force out-line dtor, for std::unique_ptr members.</span><br><span class="line"></span><br><span class="line">  void connect();</span><br><span class="line">  void disconnect();</span><br><span class="line">  void stop();</span><br><span class="line"></span><br><span class="line">  TcpConnectionPtr connection() const</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    return connection_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  EventLoop* getLoop() const &#123; return loop_; &#125;</span><br><span class="line">  bool retry() const &#123; return retry_; &#125;</span><br><span class="line">  void enableRetry() &#123; retry_ = true; &#125;</span><br><span class="line"></span><br><span class="line">  const string&amp; name() const</span><br><span class="line">  &#123; return name_; &#125;</span><br><span class="line"></span><br><span class="line">  /// Set connection callback.</span><br><span class="line">  /// Not thread safe.</span><br><span class="line">  void setConnectionCallback(ConnectionCallback cb)</span><br><span class="line">  &#123; connectionCallback_ = std::move(cb); &#125;</span><br><span class="line"></span><br><span class="line">  /// Set message callback.</span><br><span class="line">  /// Not thread safe.</span><br><span class="line">  void setMessageCallback(MessageCallback cb)</span><br><span class="line">  &#123; messageCallback_ = std::move(cb); &#125;</span><br><span class="line"></span><br><span class="line">  /// Set write complete callback.</span><br><span class="line">  /// Not thread safe.</span><br><span class="line">  void setWriteCompleteCallback(WriteCompleteCallback cb)</span><br><span class="line">  &#123; writeCompleteCallback_ = std::move(cb); &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  /// Not thread safe, but in loop</span><br><span class="line">  void newConnection(int sockfd);</span><br><span class="line">  /// Not thread safe, but in loop</span><br><span class="line">  void removeConnection(const TcpConnectionPtr&amp; conn);</span><br><span class="line"></span><br><span class="line">  EventLoop* loop_;</span><br><span class="line">  ConnectorPtr connector_; // avoid revealing Connector,用于主动发起连接</span><br><span class="line">  const string name_;//名称</span><br><span class="line">  ConnectionCallback connectionCallback_;//连接建立回调函数</span><br><span class="line">  MessageCallback messageCallback_;//消息到来回调函数</span><br><span class="line">  WriteCompleteCallback writeCompleteCallback_;//数据发送完毕回调函数</span><br><span class="line">  bool retry_;   // atomic，重连，是指连接建立之后又断开的时候是否重连</span><br><span class="line">  bool connect_; // atomic</span><br><span class="line">  // always in loop thread</span><br><span class="line">  int nextConnId_;//name_+nextConnId_用于标识一个连接</span><br><span class="line">  mutable MutexLock mutex_;</span><br><span class="line">  TcpConnectionPtr connection_ GUARDED_BY(mutex_);//Connector连接成功之后，得到一个TcpConnection</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_NET_TCPCLIENT_H</span><br></pre></td></tr></table></figure>

<h2 id="TcpClient-cc"><a href="#TcpClient-cc" class="headerlink" title="TcpClient.cc"></a>TcpClient.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (unique)</span><br><span class="line">&#123;</span><br><span class="line">    conn-&gt;forceClose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>connection_</code> 是唯一引用时，说明当前的 <code>TcpConnection</code> 实例没有其他智能指针指向它，也就意味着没有其他地方在使用这个连接对象。</p>
<p>在正常情况下，当需要关闭连接时，应该先发送TCP终止连接的相关消息（如FIN包），等待对方响应并进行优雅关闭的握手过程。这样可以确保数据的完整性和可靠性。</p>
<p>但是，在某些情况下，可能需要立即关闭连接，而不进行优雅关闭的握手过程。这些情况可能包括：</p>
<ol>
<li>程序逻辑需要：根据具体的业务需求，在某些特定的场景下，需要立即终止连接，而不等待握手过程完成。例如，发生了错误或异常情况，需要立即中断连接以防止进一步的数据传输。</li>
<li>资源回收：当 <code>TcpConnection</code> 对象没有其他引用时，为了及时释放与连接相关的资源，可以选择立即强制关闭连接，而不等待未来可能的操作。</li>
</ol>
<p>因此，当 <code>connection_</code> 是唯一引用时，调用 <code>forceClose()</code> 函数可以立即关闭连接，无需等待握手过程完成，以满足上述需求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line">namespace detail</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">void removeConnection(EventLoop* loop, const TcpConnectionPtr&amp; conn)</span><br><span class="line">&#123;</span><br><span class="line">  loop-&gt;queueInLoop(std::bind(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void removeConnector(const ConnectorPtr&amp; connector)</span><br><span class="line">&#123;</span><br><span class="line">  //connector-&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace detail</span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">TcpClient::TcpClient(EventLoop* loop,</span><br><span class="line">                     const InetAddress&amp; serverAddr,</span><br><span class="line">                     const string&amp; nameArg)</span><br><span class="line">  : loop_(CHECK_NOTNULL(loop)),</span><br><span class="line">    connector_(new Connector(loop, serverAddr)),</span><br><span class="line">    name_(nameArg),</span><br><span class="line">    connectionCallback_(defaultConnectionCallback),</span><br><span class="line">    messageCallback_(defaultMessageCallback),</span><br><span class="line">    retry_(false),</span><br><span class="line">    connect_(true),</span><br><span class="line">    nextConnId_(1)</span><br><span class="line">&#123;</span><br><span class="line">  connector_-&gt;setNewConnectionCallback(</span><br><span class="line">      std::bind(&amp;TcpClient::newConnection, this, _1));</span><br><span class="line">  // FIXME setConnectFailedCallback</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;TcpClient::TcpClient[&quot; &lt;&lt; name_</span><br><span class="line">           &lt;&lt; &quot;] - connector &quot; &lt;&lt; get_pointer(connector_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpClient::~TcpClient()</span><br><span class="line">&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;TcpClient::~TcpClient[&quot; &lt;&lt; name_</span><br><span class="line">           &lt;&lt; &quot;] - connector &quot; &lt;&lt; get_pointer(connector_);</span><br><span class="line">  TcpConnectionPtr conn;</span><br><span class="line">  bool unique = false;</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    unique = connection_.unique();//shared_ptr类的成员函数，用于判断该智能指针是否是唯一引用（即没有其他指针指向相同对象）</span><br><span class="line">    //如果当前智能指针是唯一引用，则返回true；否则，返回false</span><br><span class="line">    conn = connection_;</span><br><span class="line">  &#125;</span><br><span class="line">  if (conn)</span><br><span class="line">  &#123;</span><br><span class="line">    assert(loop_ == conn-&gt;getLoop());</span><br><span class="line">    // FIXME: not 100% safe, if we are in different thread</span><br><span class="line">    //重新设置TcpConnection中的closeCallback_为detail::removeConnection</span><br><span class="line">    CloseCallback cb = std::bind(&amp;detail::removeConnection, loop_, _1);</span><br><span class="line">    //不能调用TcpClient::removeConnection，因为它有重连功能</span><br><span class="line">    loop_-&gt;runInLoop(</span><br><span class="line">        std::bind(&amp;TcpConnection::setCloseCallback, conn, cb));</span><br><span class="line">    if (unique)</span><br><span class="line">    &#123;</span><br><span class="line">      conn-&gt;forceClose();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    //这种情况，说明connector处于未连接状态，将connector_停止</span><br><span class="line">    connector_-&gt;stop();</span><br><span class="line">    // FIXME: HACK</span><br><span class="line">    loop_-&gt;runAfter(1, std::bind(&amp;detail::removeConnector, connector_));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpClient::connect()</span><br><span class="line">&#123;</span><br><span class="line">  // FIXME: check state</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;TcpClient::connect[&quot; &lt;&lt; name_ &lt;&lt; &quot;] - connecting to &quot;</span><br><span class="line">           &lt;&lt; connector_-&gt;serverAddress().toIpPort();</span><br><span class="line">  connect_ = true;</span><br><span class="line">  connector_-&gt;start();</span><br><span class="line">&#125;</span><br><span class="line">//用于连接已建立的情况下，关闭连接</span><br><span class="line">void TcpClient::disconnect()</span><br><span class="line">&#123;</span><br><span class="line">  connect_ = false;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    if (connection_)</span><br><span class="line">    &#123;</span><br><span class="line">      connection_-&gt;shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//停止connector_,可能是连接尚未建立成功</span><br><span class="line">void TcpClient::stop()</span><br><span class="line">&#123;</span><br><span class="line">  connect_ = false;</span><br><span class="line">  connector_-&gt;stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpClient::newConnection(int sockfd)</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  InetAddress peerAddr(sockets::getPeerAddr(sockfd));</span><br><span class="line">  char buf[32];</span><br><span class="line">  snprintf(buf, sizeof buf, &quot;:%s#%d&quot;, peerAddr.toIpPort().c_str(), nextConnId_);</span><br><span class="line">  ++nextConnId_;</span><br><span class="line">  string connName = name_ + buf;</span><br><span class="line"></span><br><span class="line">  InetAddress localAddr(sockets::getLocalAddr(sockfd));</span><br><span class="line">  // FIXME poll with zero timeout to double confirm the new connection</span><br><span class="line">  // FIXME use make_shared if necessary</span><br><span class="line">  TcpConnectionPtr conn(new TcpConnection(loop_,</span><br><span class="line">                                          connName,</span><br><span class="line">                                          sockfd,</span><br><span class="line">                                          localAddr,</span><br><span class="line">                                          peerAddr));</span><br><span class="line"></span><br><span class="line">  conn-&gt;setConnectionCallback(connectionCallback_);</span><br><span class="line">  conn-&gt;setMessageCallback(messageCallback_);</span><br><span class="line">  conn-&gt;setWriteCompleteCallback(writeCompleteCallback_);</span><br><span class="line">  conn-&gt;setCloseCallback(</span><br><span class="line">      std::bind(&amp;TcpClient::removeConnection, this, _1)); // FIXME: unsafe</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    connection_ = conn;//保存TcpConnection</span><br><span class="line">  &#125;</span><br><span class="line">  conn-&gt;connectEstablished();//这里回调connectionCallback_</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpClient::removeConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  assert(loop_ == conn-&gt;getLoop());</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    //GUARDED_BY(mutex_)体现在每次对connection_对象使用的时候都需要保护</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    assert(connection_ == conn);</span><br><span class="line">    connection_.reset();//重置</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  loop_-&gt;queueInLoop(std::bind(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class="line">  if (retry_ &amp;&amp; connect_)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_INFO &lt;&lt; &quot;TcpClient::connect[&quot; &lt;&lt; name_ &lt;&lt; &quot;] - Reconnecting to &quot;</span><br><span class="line">             &lt;&lt; connector_-&gt;serverAddress().toIpPort();</span><br><span class="line">    connector_-&gt;restart();//这里的重连是指连接建立成功之后被断开的重连</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="测试程序-1"><a href="#测试程序-1" class="headerlink" title="测试程序"></a>测试程序</h2><h3 id="TcpClient-test-cc-x2F-x2F-echo-client"><a href="#TcpClient-test-cc-x2F-x2F-echo-client" class="headerlink" title="TcpClient_test.cc &#x2F;&#x2F; echo client"></a>TcpClient_test.cc &#x2F;&#x2F; echo client</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">class TestClient&#123;</span><br><span class="line">public:</span><br><span class="line">	TestClient(EventLoop* loop，const InetAddress&amp; listenaddr)</span><br><span class="line">		:loop_(loop),</span><br><span class="line">		client_(loop.listenAddr,&quot;Testclient&quot;),</span><br><span class="line">		stdinchanne1_(loop，0)</span><br><span class="line">	&#123;</span><br><span class="line">		client_.setConnectionCallback(</span><br><span class="line">			boost::bind(&amp;TestClient::onConnection,this,_1));</span><br><span class="line">		//有消息到来回调函数</span><br><span class="line">		client_.setMessageCa11back(</span><br><span class="line">			boost::bind(&amp;TestClient::onMessage,this,_1,_2,_3));</span><br><span class="line">		//client_.enableRetry();客户端已经建立连接成功，因为某种意外断开，是否能够重连的标志</span><br><span class="line">		//标准输入缓冲区中有数据的时候，回调Testclient::handleRead</span><br><span class="line">		stdinChannel_.setReadCallback(boost::bind(&amp;TestClient::handleRead, this));</span><br><span class="line">		stdinChanne1_.enableReading();</span><br><span class="line">	&#125;</span><br><span class="line">	void connect()&#123;</span><br><span class="line">		client_.connect();</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	void:onConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">	&#123;</span><br><span class="line">		if( conn-&gt;connected())&#123;</span><br><span class="line">			printf(&quot;onconnection(): new connettion [%s]from %s\n&quot;,</span><br><span class="line">				conn-&gt;name()-&gt;c_str(),</span><br><span class="line">				conn-&gt;peerAddress().toIpPort().c_str());</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			printf(&quot;onconnection():connettion [%s] is down\n&quot;,</span><br><span class="line">				conn-&gt;name()-&gt;c_str());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	void onMessage(const TcpConnectionPtr&amp; conn,</span><br><span class="line">					Buffer* buf,</span><br><span class="line">					Timestamp receiveTime)</span><br><span class="line">	&#123;</span><br><span class="line">		muduo::string msg(buf-&gt;retrieveAllAsString());</span><br><span class="line">		printf(&quot;onMessage(): received %zd bytes from connection [%s] at %s\n&quot;,</span><br><span class="line">				msg.size(),</span><br><span class="line">				conn-&gt;name().c_str(),</span><br><span class="line">				receiveTime.toFormattedString().c_str());</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	//标准输入缓冲区中有数据的时候,回调该函数</span><br><span class="line">	void handleRead()&#123;</span><br><span class="line">		char buf[1024]=&#123;0&#125;;</span><br><span class="line">		fgets(buf,1024,stdin);</span><br><span class="line">		buf[str1en(buf)-1]=&#x27;\0&#x27;;//去除\n</span><br><span class="line">		client_.connection()-&gt;send(buf);</span><br><span class="line">	&#125;</span><br><span class="line">	EventLoop* 1oop_;</span><br><span class="line">	TcpClient client_;//具有自动重连功能，是指还没建立成功的时候</span><br><span class="line">	Channel stdinChannel;//标准输入chaanel</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">	printf( &quot;main(): pid = %d\n&quot;,getpid());</span><br><span class="line">	InetAddress serverAddr(&quot;127.0.0.1&quot;,8888);</span><br><span class="line">	EventLoop 1oop;</span><br><span class="line">	TestClient client(&amp;1oop,serverAddr);</span><br><span class="line">	client.connect();</span><br><span class="line">	1oop.loop();</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/16/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%885%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/16/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%885%EF%BC%89/" class="post-title-link" itemprop="url">muduo-网络库（5）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-16 19:21:54" itemprop="dateCreated datePublished" datetime="2023-08-16T19:21:54+08:00">2023-08-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-20 15:39:11" itemprop="dateModified" datetime="2023-08-20T15:39:11+08:00">2023-08-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="muduo库如何支持多线程"><a href="#muduo库如何支持多线程" class="headerlink" title="muduo库如何支持多线程"></a>muduo库如何支持多线程</h1><ul>
<li>EventLoopThread (IO线程类)</li>
<li>EventLoopThreadPool(IO线程池类)<ul>
<li>IO线程池的功能是开启若干个IO线程，并让这些IO线程处于事件循环的状态</li>
</ul>
</li>
</ul>
<p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%885%EF%BC%89/image-20230816193049699.png" alt="image-20230816193049699"></p>
<img src="/2023/08/16/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%885%EF%BC%89/image-20230816193049699.png" class title="This is an test image">

<h2 id="TcpServer-cc关于EventLoopThreadPool部分"><a href="#TcpServer-cc关于EventLoopThreadPool部分" class="headerlink" title="TcpServer.cc关于EventLoopThreadPool部分"></a>TcpServer.cc关于EventLoopThreadPool部分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">std::shared_ptr&lt;EventLoopThreadPool&gt; threadPool_;</span><br><span class="line">void setThreadInitCallback(const ThreadInitCallback&amp; cb)</span><br><span class="line">  &#123; threadInitCallback_ = cb; &#125;</span><br><span class="line">构造函数</span><br><span class="line">threadPool_(new EventLoopThreadPool(loop, name_))</span><br><span class="line"></span><br><span class="line">void TcpServer::setThreadNum(int numThreads)</span><br><span class="line">&#123;</span><br><span class="line">  assert(0 &lt;= numThreads);</span><br><span class="line">  threadPool_-&gt;setThreadNum(numThreads);//不包含主线程</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpServer::start()</span><br><span class="line">&#123;</span><br><span class="line">  if (started_.getAndSet(1) == 0)</span><br><span class="line">  &#123;</span><br><span class="line">    threadPool_-&gt;start(threadInitCallback_);//启动线程池</span><br><span class="line"></span><br><span class="line">    assert(!acceptor_-&gt;listening());</span><br><span class="line">    //get_pointer返回原生指针</span><br><span class="line">    loop_-&gt;runInLoop(</span><br><span class="line">        std::bind(&amp;Acceptor::listen, get_pointer(acceptor_)));//ptr.get();裸指针是为了将对象指针传递给 std::bind，从而在可调用对象中使用</span><br><span class="line">  &#125;//acceptor_.get() 是 std::unique_ptr 类提供的成员函数 get() 的调用，它用于获取被智能指针管理的对象的原始裸指针</span><br><span class="line">  //智能指针不能直接传递对象，是因为智能指针对对象进行了所有权管理</span><br><span class="line">&#125;</span><br><span class="line">void TcpServer::newConnection(int sockfd, const InetAddress&amp; peerAddr)&#123;</span><br><span class="line"> //按照轮叫的方式选择一个EventLoop</span><br><span class="line">  EventLoop* ioLoop = threadPool_-&gt;getNextLoop();</span><br><span class="line">  TcpConnectionPtr conn(new TcpConnection(ioLoop,</span><br><span class="line">                                          connName,</span><br><span class="line">                                          sockfd,</span><br><span class="line">                                          localAddr,</span><br><span class="line">                                          peerAddr));</span><br><span class="line"> ioLoop-&gt;runInLoop(std::bind(&amp;TcpConnection::connectEstablished, conn));//再ioLoop所属线程调用connectEstablished</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>EventLoopThreadPool::start</code> 方法中，线程池会根据指定的线程数量创建并启动多个 <code>EventLoopThread</code> 线程，然后每个线程会创建一个 <code>EventLoop</code> 实例。通过调用 <code>threadInitCallback_</code> 回调函数，你可以在每个线程开始事件循环之前执行一些初始化操作，以确保线程处于正确的状态。</p>
<p>因此，<code>threadPool_-&gt;start(threadInitCallback_)</code> 是用于启动整个线程池，其中每个线程会拥有自己的事件循环，并在事件循环开始之前调用 <code>threadInitCallback_</code> 进行初始化。这样就为每个线程提供了一个适当的上下文，以便它们可以正常地处理连接和事件。</p>
<h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%885%EF%BC%89/image-20230817192430816.png" alt="image-20230817192430816"></p>
<img src="/2023/08/16/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%885%EF%BC%89/image-20230817192430816.png" class title="This is an test image">

<p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%885%EF%BC%89/image-20230817192738143.png" alt="image-20230817192738143"></p>
<img src="/2023/08/16/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%885%EF%BC%89/image-20230817192738143.png" class title="This is an test image">

<p>主线程的文件描述符创建先后，3：pollerfd，4：timerfd，5：wakeupfd，6：listenfd，7：idlefd，再创建其它子线程（线程池）依此类推,子线程没有listenfd和idlefd,处理读事件的都是wakeupfd</p>
<h2 id="EventLoopThreadPool-h"><a href="#EventLoopThreadPool-h" class="headerlink" title="EventLoopThreadPool.h"></a>EventLoopThreadPool.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_NET_EVENTLOOPTHREADPOOL_H</span><br><span class="line">#define MUDUO_NET_EVENTLOOPTHREADPOOL_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/noncopyable.h&quot;</span><br><span class="line">#include &quot;muduo/base/Types.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">class EventLoop;</span><br><span class="line">class EventLoopThread;</span><br><span class="line"></span><br><span class="line">class EventLoopThreadPool : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  typedef std::function&lt;void(EventLoop*)&gt; ThreadInitCallback;</span><br><span class="line"></span><br><span class="line">  EventLoopThreadPool(EventLoop* baseLoop, const string&amp; nameArg);</span><br><span class="line">  ~EventLoopThreadPool();</span><br><span class="line">  void setThreadNum(int numThreads) &#123; numThreads_ = numThreads; &#125;</span><br><span class="line">  void start(const ThreadInitCallback&amp; cb = ThreadInitCallback());</span><br><span class="line"></span><br><span class="line">  // valid after calling start()</span><br><span class="line">  /// round-robin</span><br><span class="line">  EventLoop* getNextLoop();</span><br><span class="line"></span><br><span class="line">  /// with the same hash code, it will always return the same EventLoop</span><br><span class="line">  EventLoop* getLoopForHash(size_t hashCode);</span><br><span class="line"></span><br><span class="line">  std::vector&lt;EventLoop*&gt; getAllLoops();</span><br><span class="line"></span><br><span class="line">  bool started() const</span><br><span class="line">  &#123; return started_; &#125;</span><br><span class="line"></span><br><span class="line">  const string&amp; name() const</span><br><span class="line">  &#123; return name_; &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line"></span><br><span class="line">  EventLoop* baseLoop_;//与Acceptor所属EventLoop相同</span><br><span class="line">  string name_;</span><br><span class="line">  bool started_;</span><br><span class="line">  int numThreads_;//线程数</span><br><span class="line">  int next_;//新连接到来，所选择EventLoop对象下标</span><br><span class="line">  std::vector&lt;std::unique_ptr&lt;EventLoopThread&gt;&gt; threads_;//IO线程列表</span><br><span class="line">  std::vector&lt;EventLoop*&gt; loops_;//EventLoop列表，EventLoop 对象的生命周期由其他IO线程负责</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_NET_EVENTLOOPTHREADPOOL_H</span><br></pre></td></tr></table></figure>

<h2 id="EventLoopThreadPool-cc"><a href="#EventLoopThreadPool-cc" class="headerlink" title="EventLoopThreadPool.cc"></a>EventLoopThreadPool.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/net/EventLoopThreadPool.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/net/EventLoop.h&quot;</span><br><span class="line">#include &quot;muduo/net/EventLoopThread.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">EventLoopThreadPool::EventLoopThreadPool(EventLoop* baseLoop, const string&amp; nameArg)</span><br><span class="line">  : baseLoop_(baseLoop),</span><br><span class="line">    name_(nameArg),</span><br><span class="line">    started_(false),</span><br><span class="line">    numThreads_(0),</span><br><span class="line">    next_(0)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventLoopThreadPool::~EventLoopThreadPool()</span><br><span class="line">&#123;</span><br><span class="line">  // Don&#x27;t delete loop, it&#x27;s stack variable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void EventLoopThreadPool::start(const ThreadInitCallback&amp; cb)</span><br><span class="line">&#123;</span><br><span class="line">  assert(!started_);</span><br><span class="line">  baseLoop_-&gt;assertInLoopThread();</span><br><span class="line"></span><br><span class="line">  started_ = true;</span><br><span class="line"></span><br><span class="line">  for (int i = 0; i &lt; numThreads_; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    char buf[name_.size() + 32];</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%s%d&quot;, name_.c_str(), i);</span><br><span class="line">    EventLoopThread* t = new EventLoopThread(cb, buf);</span><br><span class="line">    threads_.push_back(std::unique_ptr&lt;EventLoopThread&gt;(t));</span><br><span class="line">    loops_.push_back(t-&gt;startLoop());//启动EventLoopThread线程，将返回的loop压入容器，在进入事件循环之前，会调用cb即启动调用EventLoopThread::threadFunc</span><br><span class="line">  &#125;</span><br><span class="line">  if (numThreads_ == 0 &amp;&amp; cb)</span><br><span class="line">  &#123;</span><br><span class="line">    //只有一个EventLoop，在这个EventLoop进入事件循环之前，调用cb,baseLoop_ 表示了一个已经存在的 EventLoop 实例，通常是主线程的事件循环</span><br><span class="line">    cb(baseLoop_);//在每个 EventLoopThread 启动之前，让用户有机会在新线程的事件循环开始之前执行自定义的初始化操作</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventLoop* EventLoopThreadPool::getNextLoop()</span><br><span class="line">&#123;</span><br><span class="line">  baseLoop_-&gt;assertInLoopThread();</span><br><span class="line">  assert(started_);</span><br><span class="line">  EventLoop* loop = baseLoop_;</span><br><span class="line">  //如果1oops_为空，则1oop指向baseLoop</span><br><span class="line">  //如果不为空，按照round-robin (RR，轮叫）的调度方式选择一个EventLoop</span><br><span class="line">  if (!loops_.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    // round-robin</span><br><span class="line">    loop = loops_[next_];</span><br><span class="line">    ++next_;</span><br><span class="line">    if (implicit_cast&lt;size_t&gt;(next_) &gt;= loops_.size())</span><br><span class="line">    &#123;</span><br><span class="line">      next_ = 0;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventLoop* EventLoopThreadPool::getLoopForHash(size_t hashCode)</span><br><span class="line">&#123;</span><br><span class="line">  baseLoop_-&gt;assertInLoopThread();</span><br><span class="line">  EventLoop* loop = baseLoop_;</span><br><span class="line"></span><br><span class="line">  if (!loops_.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    loop = loops_[hashCode % loops_.size()];</span><br><span class="line">  &#125;</span><br><span class="line">  return loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;EventLoop*&gt; EventLoopThreadPool::getAllLoops()</span><br><span class="line">&#123;</span><br><span class="line">  baseLoop_-&gt;assertInLoopThread();</span><br><span class="line">  assert(started_);</span><br><span class="line">  if (loops_.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    return std::vector&lt;EventLoop*&gt;(1, baseLoop_);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    return loops_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**<code>EventLoop\* EventLoopThreadPool::getLoopForHash(size_t hashCode)</code>**：</p>
<p>此函数根据提供的哈希码从线程池中获取一个事件循环。哈希码用于确定应该为特定任务分配哪个事件循环。此函数的主要目的是确保不同的任务以一致的方式分配给不同的事件循环。这有助于在各个事件循环之间分布负载。</p>
<p><code>getLoopForHash</code> 函数的步骤如下：</p>
<ul>
<li>它断言调用线程与与基本事件循环关联的线程相同。</li>
<li>如果事件循环向量（<code>loops_</code>）不为空，则根据提供的哈希码从向量中选择一个事件循环。</li>
<li>哈希码用于计算在 <code>loops_</code> 向量中的索引，从而在可用的事件循环之间分配任务。</li>
<li>如果向量为空，则函数返回基本事件循环（<code>baseLoop_</code>）。</li>
</ul>
<h1 id="应用层缓冲区Buffer设计"><a href="#应用层缓冲区Buffer设计" class="headerlink" title="应用层缓冲区Buffer设计"></a>应用层缓冲区Buffer设计</h1><h2 id="Buffer-h"><a href="#Buffer-h" class="headerlink" title="Buffer.h"></a>Buffer.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_NET_BUFFER_H</span><br><span class="line">#define MUDUO_NET_BUFFER_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/copyable.h&quot;</span><br><span class="line">#include &quot;muduo/base/StringPiece.h&quot;</span><br><span class="line">#include &quot;muduo/base/Types.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/net/Endian.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">//#include &lt;unistd.h&gt;  // ssize_t</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">/// A buffer class modeled after org.jboss.netty.buffer.ChannelBuffer</span><br><span class="line">///</span><br><span class="line">/// @code</span><br><span class="line">/// +-------------------+------------------+------------------+</span><br><span class="line">/// | prependable bytes |  readable bytes  |  writable bytes  |</span><br><span class="line">/// |                   |     (CONTENT)    |                  |</span><br><span class="line">/// +-------------------+------------------+------------------+</span><br><span class="line">/// |                   |                  |                  |</span><br><span class="line">/// 0      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=     size</span><br><span class="line">/// @endcode</span><br><span class="line">class Buffer : public muduo::copyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  static const size_t kCheapPrepend = 8;</span><br><span class="line">  static const size_t kInitialSize = 1024;</span><br><span class="line"></span><br><span class="line">  explicit Buffer(size_t initialSize = kInitialSize)</span><br><span class="line">    : buffer_(kCheapPrepend + initialSize),//预先分配了1032字节</span><br><span class="line">      readerIndex_(kCheapPrepend),</span><br><span class="line">      writerIndex_(kCheapPrepend)</span><br><span class="line">  &#123;</span><br><span class="line">    assert(readableBytes() == 0);</span><br><span class="line">    assert(writableBytes() == initialSize);</span><br><span class="line">    assert(prependableBytes() == kCheapPrepend);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // implicit copy-ctor, move-ctor, dtor and assignment are fine</span><br><span class="line">  // NOTE: implicit move-ctor is added in g++ 4.6</span><br><span class="line"></span><br><span class="line">  void swap(Buffer&amp; rhs)</span><br><span class="line">  &#123;</span><br><span class="line">    buffer_.swap(rhs.buffer_);</span><br><span class="line">    std::swap(readerIndex_, rhs.readerIndex_);</span><br><span class="line">    std::swap(writerIndex_, rhs.writerIndex_);</span><br><span class="line">  &#125;</span><br><span class="line">  size_t readableBytes() const</span><br><span class="line">  &#123; return writerIndex_ - readerIndex_; &#125;</span><br><span class="line"></span><br><span class="line">  size_t writableBytes() const</span><br><span class="line">  &#123; return buffer_.size() - writerIndex_; &#125;</span><br><span class="line"></span><br><span class="line">  size_t prependableBytes() const</span><br><span class="line">  &#123; return readerIndex_; &#125;</span><br><span class="line"></span><br><span class="line">  const char* peek() const//返回读的指针</span><br><span class="line">  &#123; return begin() + readerIndex_; &#125;</span><br><span class="line"></span><br><span class="line">  const char* findCRLF() const</span><br><span class="line">  &#123;</span><br><span class="line">    // FIXME: replace with memmem()?</span><br><span class="line">    const char* crlf = std::search(peek(), beginWrite(), kCRLF, kCRLF+2);</span><br><span class="line">    //从peek()到beginWrite()的范围内搜索回车换行字符序列 (&quot;\r\n&quot;) 是否存在，并返回匹配的第一个位置的迭代器或指针</span><br><span class="line">    return crlf == beginWrite() ? NULL : crlf;</span><br><span class="line">  &#125;</span><br><span class="line">   void retrieve(size_t len)//取数据</span><br><span class="line">  &#123;</span><br><span class="line">    assert(len &lt;= readableBytes());</span><br><span class="line">    if (len &lt; readableBytes())</span><br><span class="line">    &#123;</span><br><span class="line">      readerIndex_ += len;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      retrieveAll();//取所有</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  void retrieveAll()</span><br><span class="line">  &#123;</span><br><span class="line">    readerIndex_ = kCheapPrepend;</span><br><span class="line">    writerIndex_ = kCheapPrepend;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  string retrieveAllAsString()</span><br><span class="line">  &#123;</span><br><span class="line">    return retrieveAsString(readableBytes());</span><br><span class="line">  &#125;</span><br><span class="line">  //用于从数据源中读取指定长度的数据，将其存储为字符串，并将数据源中已读取的数据删除</span><br><span class="line">  string retrieveAsString(size_t len)</span><br><span class="line">  &#123;</span><br><span class="line">    assert(len &lt;= readableBytes());</span><br><span class="line">    string result(peek(), len);</span><br><span class="line">    retrieve(len);</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">  //确保缓冲区可写空间&gt;=len，如果不足则扩充</span><br><span class="line">  void ensureWritableBytes(size_t len)</span><br><span class="line">  &#123;</span><br><span class="line">    if (writableBytes() &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">      makeSpace(len);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(writableBytes() &gt;= len);</span><br><span class="line">  &#125;</span><br><span class="line">  //从缓冲区中读取一个32位大端字节序的整数，然后将其转换为主机字节序，并返回转换后的整数值</span><br><span class="line">  int32_t peekInt32() const</span><br><span class="line">  &#123;</span><br><span class="line">    assert(readableBytes() &gt;= sizeof(int32_t));</span><br><span class="line">    int32_t be32 = 0;</span><br><span class="line">    ::memcpy(&amp;be32, peek(), sizeof be32);</span><br><span class="line">    return sockets::networkToHost32(be32);</span><br><span class="line">  &#125;</span><br><span class="line">//在缓冲区的头部插入给定长度的数据。它会通过将已读索引向前移动，并将新数据复制到头部位置来实现</span><br><span class="line">  void prepend(const void* /*restrict*/ data, size_t len)</span><br><span class="line">  &#123;</span><br><span class="line">    assert(len &lt;= prependableBytes());</span><br><span class="line">    readerIndex_ -= len;</span><br><span class="line">    const char* d = static_cast&lt;const char*&gt;(data);</span><br><span class="line">    std::copy(d, d+len, begin()+readerIndex_);</span><br><span class="line">  &#125;</span><br><span class="line">  //伸缩空间，保留reserve个字节</span><br><span class="line">  //这个函数的作用是缩小当前缓冲区的容量，以释放不必要的内存。</span><br><span class="line">  //它通过创建一个临时的 other 缓冲区，将当前缓冲区中的数据追加到其中，然后交换它们的内容，实现缓冲区的内存收缩</span><br><span class="line">  void shrink(size_t reserve)</span><br><span class="line">  &#123;</span><br><span class="line">    // FIXME: use vector::shrink_to_fit() in C++ 11 if possible.</span><br><span class="line">    Buffer other;</span><br><span class="line">    other.ensureWritableBytes(readableBytes()+reserve);</span><br><span class="line">    other.append(toStringPiece());</span><br><span class="line">    swap(other);</span><br><span class="line">  &#125;</span><br><span class="line">private:</span><br><span class="line">	 void makeSpace(size_t len)</span><br><span class="line">  &#123;</span><br><span class="line">    if (writableBytes() + prependableBytes() &lt; len + kCheapPrepend)</span><br><span class="line">    &#123;</span><br><span class="line">      // FIXME: move readable data</span><br><span class="line">      buffer_.resize(writerIndex_+len);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      // move readable data to the front, make space inside buffer</span><br><span class="line">      assert(kCheapPrepend &lt; readerIndex_);</span><br><span class="line">      size_t readable = readableBytes();</span><br><span class="line">      //将位于 buffer_ 中 readerIndex_ 到 writerIndex_ 范围内的数据复制到 buffer_ 中的另一个位置，从 kCheapPrepend 开始</span><br><span class="line">      std::copy(begin()+readerIndex_,</span><br><span class="line">                begin()+writerIndex_,</span><br><span class="line">                begin()+kCheapPrepend);</span><br><span class="line">      readerIndex_ = kCheapPrepend;</span><br><span class="line">      writerIndex_ = readerIndex_ + readable;</span><br><span class="line">      assert(readable == readableBytes());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  private:</span><br><span class="line">  std::vector&lt;char&gt; buffer_;</span><br><span class="line">  size_t readerIndex_;</span><br><span class="line">  size_t writerIndex_;</span><br><span class="line"></span><br><span class="line">  static const char kCRLF[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_NET_BUFFER_H</span><br></pre></td></tr></table></figure>

<h2 id="Buffer-cc"><a href="#Buffer-cc" class="headerlink" title="Buffer.cc"></a>Buffer.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/net/Buffer.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/net/SocketsOps.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;sys/uio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">const char Buffer::kCRLF[] = &quot;\r\n&quot;;</span><br><span class="line"></span><br><span class="line">const size_t Buffer::kCheapPrepend;</span><br><span class="line">const size_t Buffer::kInitialSize;</span><br><span class="line">//结合栈上的空间，避免内存使用过大,提高内存使用率</span><br><span class="line">//如果有5k个连接，每个连接就分配64K+64k的缓冲区的话，将占用640M内存，而大多数时候，这些缓冲区的使用率很低</span><br><span class="line">ssize_t Buffer::readFd(int fd, int* savedErrno)</span><br><span class="line">&#123;</span><br><span class="line">  // saved an ioctl()/FIONREAD call to tell how much to read</span><br><span class="line">  char extrabuf[65536];//栈上的空间足够大，节省一次ioctl系统调用（获取有多少可读数据）</span><br><span class="line">  struct iovec vec[2];</span><br><span class="line">  const size_t writable = writableBytes();</span><br><span class="line">  //第一块缓冲区</span><br><span class="line">  vec[0].iov_base = begin()+writerIndex_;</span><br><span class="line">  vec[0].iov_len = writable;</span><br><span class="line">  //第二块缓冲区</span><br><span class="line">  vec[1].iov_base = extrabuf;</span><br><span class="line">  vec[1].iov_len = sizeof extrabuf;</span><br><span class="line">  // when there is enough space in this buffer, don&#x27;t read into extrabuf.</span><br><span class="line">  // when extrabuf is used, we read 128k-1 bytes at most.</span><br><span class="line">  const int iovcnt = (writable &lt; sizeof extrabuf) ? 2 : 1;//根据当前缓冲区的可写入大小与 extrabuf 的大小，确定要传递给 readv 函数的 iovec 结构体数量</span><br><span class="line">  const ssize_t n = sockets::readv(fd, vec, iovcnt);</span><br><span class="line">  if (n &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    *savedErrno = errno;</span><br><span class="line">  &#125;</span><br><span class="line">  else if (implicit_cast&lt;size_t&gt;(n) &lt;= writable)//第一块缓冲区足够容纳</span><br><span class="line">  &#123;</span><br><span class="line">    writerIndex_ += n;</span><br><span class="line">  &#125;</span><br><span class="line">  else       //当前缓冲区，不够容纳，因而数据放不到第一块的故接收到了第二块缓冲区extrabuf，将其append至buffer,</span><br><span class="line">  &#123;</span><br><span class="line">    writerIndex_ = buffer_.size();</span><br><span class="line">    append(extrabuf, n - writable);</span><br><span class="line">  &#125;</span><br><span class="line">  // if (n == writable + sizeof extrabuf)</span><br><span class="line">  // &#123;</span><br><span class="line">  //   goto line_30;</span><br><span class="line">  // &#125;</span><br><span class="line">  return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="为什么需要有应用层缓冲区"><a href="#为什么需要有应用层缓冲区" class="headerlink" title="为什么需要有应用层缓冲区"></a>为什么需要有应用层缓冲区</h2><p>Non-blocking IO的核心思想是避免阻塞在read()或write()或其他IO系统调用上，这样可以最大限度地复用thread-of-control，让一个线程能服务于多个socket连接。IO线程只能阻塞在IO-multiplexing函数上，如 select()&#x2F;poll()&#x2F;epoll_wait()。这样一来，应用层的缓冲是必须的，每个TCP socket都要有stateful的 input buffer和 output buffer。</p>
<p>TcpConnection必须要有output buffer考虑一个常见场景:程序想通过TCP连接发送100k字节的数据，但是在write()调用中，操作系统只接受了80k字节(受TCPadvertised window的控制，细节见TCPv1)，你肯定不想在原地等待，因为不知道会等多久(取决于对方什么时候接受数据，然后滑动TCP窗口)。程序应该尽快交出控制权，返回event loop。在这种情况下，剩余的20k字节数据怎么办?</p>
<p>对于应用程序而言，它只管生成数据，它不应该关心到底数据是一次性发送还是分成几次发送，这些应该由网络库来操心，程序只要调用TcpConnection:send()就行了，网络库会负责到底。网络库应该接管这剩余的20k字节数据，把它保存在该TCP connection 的output buffer 里，然后注册POLLOUT事件，一旦socket变得可写就立刻发送数据。当然，这第二次write()也不一定能完全写入20k字节，如果还有剩余，网络库应该继续关注POLLOUT事件;如果写完了20k字节，网络库应该停止关注 POLLOUT，以免造成busy loop。(Muduo EventLoop采用的是epoll level trigger）</p>
<p>如果程序又写入了50k字节，而这时候output buffer里还有待发送的20k数据，那么网络库不应该直接调用write()，而应该把这50k数据append在那20k数据之后，等socket变得可写的时候再一并写入。</p>
<p>如果 output buffer里还有待发送的数据，而程序又想关闭连接（对程序而言，调用TcpConnection:send()之后他就认为数据迟早会发出去)，那么这时候网络库不能立刻关闭连接，而要等数据发送完毕。</p>
<p>综上，要让程序在write操作上不阻塞，网络库必须要给每个tcp connection配置output buffer .</p>
<h3 id="TcpConnection必须要有input-buffer"><a href="#TcpConnection必须要有input-buffer" class="headerlink" title="TcpConnection必须要有input buffer"></a>TcpConnection必须要有input buffer</h3><p>TCP是一个无边界的字节流协议，接收方必须要处理“收到的数据尚不构成一条完整的消息”和“一次收到两条消息的数据”等等情况。</p>
<p>网络库在处理“socket可读”事件的时候，必须一次性把socket里的数据读完（从操作系统buffer搬到应用层buffer)，否则会反复触发POLLIN事件，造成busy-loop。</p>
<p>那么网络库必然要应对“数据不完整”的情况，收到的数据先放到input buffer里，等构成一条完整的消息再通知程序的业务逻辑。这通常是codec的职责。</p>
<p>最好一次性把内核缓冲区中的数据读完，当然分多次读也没有关系<br>接收到数据，存至input buffer,通知上层的应用程序,OnMessage(Buffer* buff)回调，根据应用层协议是否是一个完整的包，codec,如果不是一条完整的消息，不会取走数据，也不会进行相应的处理，如果是一条完整的消息，将取走这条消息，并进行相应的处理。 </p>
<p>所以，在 tcp 网络编程中，网络库必须要给每个tcp connection配置inputbuffer。</p>
<p>所有muduo中的IO都是带缓冲的IO (buffered IO)，你不会自己去read()或write()某个socket，只会操作TcpConnection 的 input buffer和 output buffer。更确切的说，是在onMessage()回调里读取 input buffer;调用TcpConnection:send()来间接操作output buffer，一般不会直接操作 output buffer。</p>
<h2 id="Buffer结构"><a href="#Buffer结构" class="headerlink" title="Buffer结构"></a>Buffer结构</h2><p>Muduo Buffer的设计要点:</p>
<ul>
<li>对外表现为一块连续的内存(char*, len)，以方便客户代码的编写。</li>
<li>其size()可以自动增长，以适应不同大小的消息。它不是一个fixed size array(即char buf[8192])。</li>
<li>内部以vector of char来保存数据，并提供相应的访问函数。</li>
</ul>
<p>Buffer其实像是一个queue，从末尾写入数据，从头部读出数据。</p>
<p>谁会用Buffer?谁写谁读?根据前文分析，TcpConnection会有两个 Buffer成员，input buffer 与output buffer。</p>
<ul>
<li>input buffer，TcpConnection会从 socket读取数据，然后写入input buffer(其实这一步是用 BufferreadFd()完成的);客户代码从input buffer读取数据。</li>
<li>output buffer，客户代码会把数据写入 output buffer(其实这一步是用Tcp-Connection:send()完成的);TcpConnection 从 output buffer 读取数据并写入socket。</li>
</ul>
<p>其实，input和 output是针对客户代码而言，客户代码从input读，往output写。TcpConnection的读写正好相反。</p>
<h3 id="Muduo-Buffer的数据结构"><a href="#Muduo-Buffer的数据结构" class="headerlink" title="Muduo Buffer的数据结构"></a>Muduo Buffer的数据结构</h3><p>Muduo中的<code>Buffer</code>类设计得很巧妙。它的实现主要基于一个<code>std::vector&lt;char&gt;</code>，但不同于一般的缓冲区，Muduo的<code>Buffer</code>具有前置空间(prependable space)、可读数据(readable data)和可写空间(writable space)三部分。</p>
<p>以下是其核心的数据结构的概述：</p>
<ol>
<li><strong>std::vector<char> buffer_</char></strong>:<ul>
<li>它是存储数据的核心结构。<code>buffer_</code>的大小通常大于实际数据量，以支持高效的数据插入和删除。</li>
</ul>
</li>
<li><strong>size_t readerIndex_</strong>:<ul>
<li>这是一个索引，指向<code>buffer_</code>中的第一个可读字节。所有在<code>readerIndex_</code>之前的字节都是前置空间，可用于某些特殊的前置操作。</li>
</ul>
</li>
<li><strong>size_t writerIndex_</strong>:<ul>
<li>这是一个索引，指向<code>buffer_</code>中的第一个可写字节。所有在<code>writerIndex_</code>之后的字节都是可写空间。</li>
</ul>
</li>
</ol>
<p>基于这些索引，<code>Buffer</code>的数据布局如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+------------------+------------------+</span><br><span class="line">| prependable bytes |  readable bytes  |  writable bytes  |</span><br><span class="line">+-------------------+------------------+------------------+</span><br><span class="line">|                   |                  |                  |</span><br><span class="line">0      &lt;=      readerIndex_   &lt;=   writerIndex_   &lt;=   size()</span><br></pre></td></tr></table></figure>

<p>以下是一些<code>Buffer</code>的基本操作及其对应的实现逻辑：</p>
<ul>
<li><strong>空闲空间</strong>: 使用<code>buffer_.capacity()</code>与<code>buffer_.size()</code>之间的差值来获取。</li>
<li><strong>确保空间</strong>: 如果可写空间不足以容纳新的数据，<code>Buffer</code>可能需要重新分配空间。</li>
<li><strong>读操作</strong>: 通常会移动<code>readerIndex_</code>。</li>
<li><strong>写操作</strong>: 会移动<code>writerIndex_</code>，并在需要时重新分配空间。</li>
<li><strong>prepend操作</strong>: 使用前置空间，在<code>readerIndex_</code>之前添加数据。</li>
<li><strong>清空或重置</strong>: 通过重置<code>readerIndex_</code>和<code>writerIndex_</code>来实现。</li>
</ul>
<hr>
<p>为什么我们不需要调用reserve()来预先分配空间?因为Buffer在构造函数里把初始size()设为1k，这样当size()超过1k的时候vector 会把 capacity()加倍，等于说resize()替我们做了reserve()的事。用一段简单的代码验证一下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;char&gt; vec;</span><br><span class="line">printf(”%zd %zd\n”, vec.size(), vec.capacity());</span><br><span class="line">vec.resize(1024);</span><br><span class="line">printf(”%zd %zd\n”, vec.size(), vec.capacity());</span><br><span class="line">vec.resize( 1300);</span><br><span class="line">printf(”%zd %zd\n”，vec.size(), vec.capacity());</span><br></pre></td></tr></table></figure>

<ul>
<li>初始时，空的vector <code>vec</code> 没有元素，因此大小和容量都为0。</li>
<li>在调用 <code>vec.resize(1024)</code> 后，vector会分配至少1024个字节的内存空间，使其大小变为1024，而容量与大小相等，都为1024。</li>
<li>接着调用 <code>vec.resize(1300)</code> 后，由于容量不足以容纳1300个元素，vector会重新分配内存空间，并将原来的1024个元素复制到新的内存空间中。此时，大小变为1300，而容量增长到2048。</li>
</ul>
<p>请注意，在这个过程中，vector的容量在需要时会自动增长，并且可能会超过当前元素的数量。</p>
<h1 id="epoll使用LT模式的原因"><a href="#epoll使用LT模式的原因" class="headerlink" title="epoll使用LT模式的原因"></a>epoll使用LT模式的原因</h1><p>与poll兼容</p>
<p>LT模式不会发生漏掉事件的BUG，但POLLOUT事件不能一开始就关注，否则会出现busy loop，而应该在write无法写入内核缓冲区的时候才关注，将未写入内核缓冲区的数据添加到应用层output buffer，直到应用层output buffer写完，停止关注POLLOUT事件。</p>
<p>读写的时候不必等候EAGAIN，可以节省系统调用次效，降低迟。（注:如果用ET模式，读的时候读到EAGAIN,写的时候直到output buffer写完或者EAGAIN)</p>
<h1 id="其他缓冲区设计方案"><a href="#其他缓冲区设计方案" class="headerlink" title="其他缓冲区设计方案"></a>其他缓冲区设计方案</h1><p>谈谈其他可能的应用层 buffer设计方案</p>
<h2 id="不用vector-lt-char-gt"><a href="#不用vector-lt-char-gt" class="headerlink" title="不用vector&lt;char&gt;"></a>不用<code>vector&lt;char&gt;</code></h2><p>如果放弃“连续性”要求，可以用circular buffer，这样可以减少一点内存拷贝（没有“内部腾挪”)</p>
<p>使用连续性要求（元素在内存中连续存储）的容器，如 <code>std::vector</code>，在许多情况下提供了高效的随机访问和尾部操作，但在某些情况下，可能会涉及内存的重新分配和数据复制，这可能会带来性能开销。</p>
<p>C++ 标准库中没有直接支持的循环缓冲区（circular buffer）容器，但循环缓冲区在一些特定的应用场景中非常有用，特别是在需要在不断写入数据的同时，高效地读取最早写入的数据的情况下。</p>
<p>循环缓冲区的主要特点包括：</p>
<ol>
<li><strong>环形结构</strong>: 循环缓冲区的内部数据结构是环形的，数据从队列的尾部写入，从队列的头部读取。当队列尾部到达缓冲区末尾时，写入操作会回到缓冲区的开头，实现循环的效果。</li>
<li><strong>无需内存重分配</strong>: 循环缓冲区不需要频繁地进行内存重分配，因为其大小是固定的，当写入数据时，只需移动尾指针。这减少了内存分配和复制的开销。</li>
<li><strong>减少内存拷贝</strong>: 由于数据在循环缓冲区中是连续存储的，而且没有内存重分配，读取最早写入的数据时，不需要进行大量的内存拷贝操作。读取操作只需调整头指针即可。</li>
<li><strong>适用于实时流式数据</strong>: 循环缓冲区适用于需要实时处理流式数据的场景，如音频处理、网络数据包的缓冲等。通过不断写入新数据，同时高效读取最早写入的数据，可以实现数据的缓冲和流式处理。</li>
</ol>
<p>总之，循环缓冲区适用于需要高效地循环读取和写入数据的场景，它通过维护一个固定大小的环形结构，避免了内存重分配和大量的内存拷贝，从而在某些情况下提供了更好的性能和内存利用率。</p>
<h2 id="Zero-copy"><a href="#Zero-copy" class="headerlink" title="Zero copy"></a>Zero copy</h2><p>实际上也不是真正意义上的零拷贝，因为数据从内核到用户空间，总是有一次拷贝的。除非把应用程序放到内核中才能实现真正的零拷贝。</p>
<p><code>libevent</code> 2.0.x 提供了以下设计方案来实现分段连续的零拷贝缓冲区和散收 I&#x2F;O：</p>
<ol>
<li><strong>evbuffer 的分段连续缓冲区设计</strong>：<ul>
<li><code>evbuffer</code> 是 <code>libevent</code> 中用于管理缓冲区的数据结构。它可以容纳多个内存块，这些内存块可以是连续的，也可以是分散的。这种设计允许在不进行数据拷贝的情况下管理和操作多个数据段。</li>
<li>您可以使用 <code>evbuffer_add()</code> 函数将数据添加到 <code>evbuffer</code> 中。如果数据不连续，<code>evbuffer</code> 会自动将它们合并成连续的数据段。</li>
<li>使用 <code>evbuffer_remove()</code> 函数可以从 <code>evbuffer</code> 中读取数据。这个函数允许您在一次操作中读取并删除数据，而不需要额外的拷贝。</li>
</ul>
</li>
<li><strong>散收 I&#x2F;O 的应用</strong>：<ul>
<li>散收 I&#x2F;O 是一种优化技术，用于将数据分散存储到多个缓冲区中或从多个缓冲区中进行聚集写入。这避免了将数据从用户空间到内核空间的拷贝，提高了性能。</li>
<li>在 <code>libevent</code> 中，当数据从套接字读取到 <code>evbuffer</code> 时，<code>libevent</code> 可以使用散收 I&#x2F;O 将数据分散存储到多个数据段中，而不需要在用户空间进行拷贝。</li>
<li>类似地，在写入数据到套接字时，<code>libevent</code> 可以使用聚集写入的方式，从 <code>evbuffer</code> 中聚集多个数据段，然后一次性进行写入。</li>
</ul>
</li>
</ol>
<h1 id="TcpConnection中增加send"><a href="#TcpConnection中增加send" class="headerlink" title="TcpConnection中增加send"></a>TcpConnection中增加send</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"> // void send(string&amp;&amp; message); // C++11</span><br><span class="line">  void send(const void* message, int len);</span><br><span class="line">  void send(const StringPiece&amp; message);</span><br><span class="line">  // void send(Buffer&amp;&amp; message); // C++11</span><br><span class="line">  void send(Buffer* message);  // this one will swap data</span><br><span class="line">  void shutdown(); // NOT thread safe, no simultaneous calling</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Buffer inputBuffer_;//应用层接受缓冲区</span><br><span class="line">Buffer outputBuffer_;//应用层发送缓冲区</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void TcpConnection::send(const void* data, int len)</span><br><span class="line">&#123;</span><br><span class="line">  send(StringPiece(static_cast&lt;const char*&gt;(data), len));</span><br><span class="line">&#125;</span><br><span class="line">//线程安全，可以跨线程调用</span><br><span class="line">void TcpConnection::send(const StringPiece&amp; message)</span><br><span class="line">&#123;</span><br><span class="line">  if (state_ == kConnected)</span><br><span class="line">  &#123;</span><br><span class="line">    if (loop_-&gt;isInLoopThread())</span><br><span class="line">    &#123;</span><br><span class="line">      sendInLoop(message);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      void (TcpConnection::*fp)(const StringPiece&amp; message) = &amp;TcpConnection::sendInLoop;</span><br><span class="line">      loop_-&gt;runInLoop(</span><br><span class="line">          std::bind(fp,</span><br><span class="line">                    this,     // FIXME</span><br><span class="line">                    message.as_string()));</span><br><span class="line">                    //std::forward&lt;string&gt;(message)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// FIXME efficiency!!!</span><br><span class="line">void TcpConnection::send(Buffer* buf)</span><br><span class="line">&#123;</span><br><span class="line">  if (state_ == kConnected)</span><br><span class="line">  &#123;</span><br><span class="line">    if (loop_-&gt;isInLoopThread())</span><br><span class="line">    &#123;</span><br><span class="line">      sendInLoop(buf-&gt;peek(), buf-&gt;readableBytes());</span><br><span class="line">      buf-&gt;retrieveAll();</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      void (TcpConnection::*fp)(const StringPiece&amp; message) = &amp;TcpConnection::sendInLoop;</span><br><span class="line">      loop_-&gt;runInLoop(</span><br><span class="line">          std::bind(fp,</span><br><span class="line">                    this,     // FIXME</span><br><span class="line">                    buf-&gt;retrieveAllAsString()));</span><br><span class="line">                    //std::forward&lt;string&gt;(message)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpConnection::sendInLoop(const StringPiece&amp; message)</span><br><span class="line">&#123;</span><br><span class="line">  sendInLoop(message.data(), message.size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpConnection::sendInLoop(const void* data, size_t len)</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  sockets::write(channe1_-&gt;fd(),data,len);</span><br><span class="line">&#125;</span><br><span class="line">//通道可读事件到来的时候，回调TcpConnection::handleRead，_1是事件发生时间</span><br><span class="line">/*channel_-&gt;setReadCallback(</span><br><span class="line">      std::bind(&amp;TcpConnection::handleRead, this, _1));*/</span><br><span class="line">void TcpConnection::handleRead(Timestamp receiveTime)</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  int savedErrno = 0;</span><br><span class="line">  /*typedef std::function&lt;void (const TcpConnectionPtr&amp;,</span><br><span class="line">                            Buffer*,</span><br><span class="line">                            Timestamp)&gt; MessageCallback;*/</span><br><span class="line">  ssize_t n = inputBuffer_.readFd(channel_-&gt;fd(), &amp;savedErrno);</span><br><span class="line">  if (n &gt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    messageCallback_(shared_from_this(), &amp;inputBuffer_, receiveTime);//shared_from_this()将当前对象转换成shared_ptr，而不是裸指针</span><br><span class="line">  &#125;</span><br><span class="line">  else if (n == 0)</span><br><span class="line">  &#123;</span><br><span class="line">    handleClose();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    errno = savedErrno;</span><br><span class="line">    LOG_SYSERR &lt;&lt; &quot;TcpConnection::handleRead&quot;;</span><br><span class="line">    handleError();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释掉的C++11用法是使用右值引用（rvalue reference）和移动语义（move semantics）。在这段代码中，定义了两个使用右值引用的发送函数。</p>
<p>首先是<code>void send(string&amp;&amp; message)</code>函数，它接受一个右值引用参数 <code>message</code>。右值引用通过使用 <code>&amp;&amp;</code> 修饰类型来标识，表示该参数可以接受临时对象或将要被移动的对象。这种方式可以避免不必要的复制操作，并通过移动语义将资源（如内存）从一个对象转移到另一个对象，提高性能。</p>
<p>其次是<code>void send(Buffer&amp;&amp; message)</code>函数。它也接受一个右值引用参数 <code>message</code>，但这里的类型是 <code>Buffer</code>，而不是普通的 <code>string</code> 类型。通过右值引用和移动语义，可以高效地将 <code>Buffer</code> 对象的数据从原始对象转移到接收方，而不需要进行深拷贝。</p>
<h1 id="TcpConnection中shutdown的处理方法"><a href="#TcpConnection中shutdown的处理方法" class="headerlink" title="TcpConnection中shutdown的处理方法"></a>TcpConnection中shutdown的处理方法</h1><p>连接状态更改为kDisconnecting,并没有关闭连接<br>服务器端主动断开与客户端的连接<br>这意味着客户端read返回为0,close(conn) ;</p>
<p><code>conn-&gt;shutdown()</code> 会关闭服务器与客户端之间的连接，而不是关闭客户端。客户端可以通过相应的关闭操作来结束自己的连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">void TcpConnection::shutdown()</span><br><span class="line">&#123;</span><br><span class="line">  // FIXME: use compare and swap</span><br><span class="line">  //可以使用原子操作来比较当前状态是否为 kConnected，如果是，则使用原子操作修改状态为 kDisconnecting。</span><br><span class="line">  //这可以避免在多线程环境中多个线程同时检查并修改状态，从而避免竞态条件</span><br><span class="line">  /*AtomicIntegerT(const AtomicIntegerT&amp; that)</span><br><span class="line">     : value_(that.get())</span><br><span class="line">  &#123;&#125;*/</span><br><span class="line">  if (state_ == kConnected)</span><br><span class="line">  &#123;</span><br><span class="line">    setState(kDisconnecting);</span><br><span class="line">    // FIXME: shared_from_this()?</span><br><span class="line">    loop_-&gt;runInLoop(std::bind(&amp;TcpConnection::shutdownInLoop, this));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpConnection::shutdownInLoop()</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  if (!channel_-&gt;isWriting())//不再关注pollout事件</span><br><span class="line">  &#123;</span><br><span class="line">    // we are not writing</span><br><span class="line">    socket_-&gt;shutdownWrite();//关闭写的这一半</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//只关闭写的这一半</span><br><span class="line">void sockets::shutdownWrite(int sockfd)</span><br><span class="line">&#123;</span><br><span class="line">  if (::shutdown(sockfd, SHUT_WR) &lt; 0)//关闭套接字 sockfd 的写入端</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSERR &lt;&lt; &quot;sockets::shutdownWrite&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">class TestServer&#123;</span><br><span class="line">public:</span><br><span class="line">TestServer(EventLoop*1oop,const InetAddress&amp; listenAddr)</span><br><span class="line">			:loop_(loop),</span><br><span class="line">			server(loop,1istenAddr,&quot;TestServer&quot;)</span><br><span class="line">	&#123;</span><br><span class="line">	server_.setconnectionCa11back(</span><br><span class="line">		boost::bind(&amp;Testserver::onConnection,this，_1));</span><br><span class="line">	server_.setMessageCa11back(</span><br><span class="line">		boost::bind(&amp;TestServer::onMessage, this，_1,_2,_3));</span><br><span class="line">	message1_.resize(100);</span><br><span class="line">	message2_.resize(200);</span><br><span class="line">	std::fill(message1_.begin(),message1_.end(),&#x27;A&#x27;);</span><br><span class="line">	std::fill(message2_.begin(),message2_.end(),&#x27;B&#x27;);</span><br><span class="line">	&#125;</span><br><span class="line">	void start()&#123;</span><br><span class="line">		server_.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	void:onConnection(const TcpConnectionPtr&amp; conn)</span><br><span class="line">	&#123;</span><br><span class="line">		if( conn-&gt;connected())&#123;</span><br><span class="line">			printf(&quot;onconnection(): new connettion [%s]from %s\n&quot;,</span><br><span class="line">				conn-&gt;name()-&gt;c_str(),</span><br><span class="line">				conn-&gt;peerAddress().toIpPort().c_str());</span><br><span class="line">			conn-&gt;send(message1_);</span><br><span class="line">			conn-&gt;send(message2_);</span><br><span class="line">			conn-&gt;shutdown();//关闭服务器与客户端之间的连接，而不是关闭客户端。</span><br><span class="line">			//这将导致服务端无法再向客户端发送数据，但服务端仍然可以接收来自客户端的数据</span><br><span class="line">			//这将关闭服务端连接的写入端，这在服务器端会导致客户端的read操作返回0,close(conn)和POLLHUP | POLLIN事件</span><br><span class="line">			//POLLHUP事件表示连接被挂起，即连接的一方关闭了连接或异常断开</span><br><span class="line">			//POLLIN事件表示连接上有数据可读</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			printf(&quot;onconnection():connettion [%s] is down\n&quot;,</span><br><span class="line">				conn-&gt;name()-&gt;c_str());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	void onMessage(const TcpConnectionPtr&amp; conn,</span><br><span class="line">					Buffer* buf,</span><br><span class="line">					Timestamp receiveTime)</span><br><span class="line">	&#123;</span><br><span class="line">		muduo::string msg(buf-&gt;retrieveAllAsString());</span><br><span class="line">		printf(&quot;onMessage(): received %zd bytes from connection [%s] at %s\n&quot;,</span><br><span class="line">				msg.size(),</span><br><span class="line">				conn-&gt;name().c_str(),</span><br><span class="line">				receiveTime.toFormattedString().c_str());</span><br><span class="line">		conn-&gt;send(msg);</span><br><span class="line">	&#125;</span><br><span class="line">	EventLoop* 1oop_;</span><br><span class="line">	TcpServer server_;</span><br><span class="line">	muduo::string message1_;</span><br><span class="line">	muduo::string message2_;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">	printf( &quot;main(): pid = %d\n&quot;,getpid());</span><br><span class="line">	InetAddress listenAddr(8888);</span><br><span class="line">	EventLoop 1oop;</span><br><span class="line">	TestServer server(&amp;1oop,listenAddr);</span><br><span class="line">	server.start();</span><br><span class="line">	1oop.loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常情况下，服务端使用 <code>::shutdown(sockfd, SHUT_WR)</code> 来实现优雅的连接关闭，就像之前讨论的一样。这样，服务端会通知客户端它已经完成了数据的发送，并且客户端应该停止发送数据，但仍然可以接收来自客户端的数据。然后，服务端可以在需要的时候关闭整个连接。这种关闭方式可以确保连接的正常结束，而不会丢失任何数据或造成不必要的中断。</p>
<p>当服务器关闭写入端时，会产生POLLHUP事件，用于通知客户端连接已关闭；同时，由于连接未完全关闭，客户端仍然可以从连接中读取数据，所以也会产生POLLIN事件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/15/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%884%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/15/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%884%EF%BC%89/" class="post-title-link" itemprop="url">muduo-网络库（4）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-15 11:25:01" itemprop="dateCreated datePublished" datetime="2023-08-15T11:25:01+08:00">2023-08-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-16 16:31:41" itemprop="dateModified" datetime="2023-08-16T16:31:41+08:00">2023-08-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="TcpServer-x2F-TcpConnection"><a href="#TcpServer-x2F-TcpConnection" class="headerlink" title="TcpServer&#x2F;TcpConnection"></a>TcpServer&#x2F;TcpConnection</h1><ul>
<li>Acceptor类的主要功能是socket、bind、listen</li>
<li>一般来说，在上层应用程序中，我们不直接使用Acceptor，而是把它作为TcpServer的成员</li>
<li>TcpServer还包含了一个TcpConnection列表</li>
<li>TcpConnection与Acceptor类似，有两个重要的数据成员，Socket与Channel,Channel关注Socket的可读可写事件</li>
</ul>
<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%884%EF%BC%89/image-20230815112907646.png" alt="image-20230815112907646"></p>
<img src="/2023/08/15/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%884%EF%BC%89/image-20230815112907646.png" class title="This is an test image">

<h2 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h2><p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%884%EF%BC%89/image-20230815155937436.png" alt="image-20230815155937436"></p>
<img src="/2023/08/15/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%884%EF%BC%89/image-20230815155937436.png" class title="This is an test image">

<p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%884%EF%BC%89/image-20230815155828886.png" alt="image-20230815155828886"></p>
<img src="/2023/08/15/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%884%EF%BC%89/image-20230815155828886.png" class title="This is an test image">

<p>在TcpServer.cc中，TcpServer类通过监听指定的IP地址和端口号，接受客户端的连接，并管理多个TcpConnection对象。下面是对TcpServer类对连接客户端的一步步操作的总结：</p>
<ol>
<li><p>在构造函数中创建一个Acceptor对象，并设置新连接回调函数<code>newConnectionCallback</code>。Acceptor负责监听并接受新的客户端连接。</p>
</li>
<li><p>在<code>start()</code>函数中启动服务器，包括启动EventLoop线程池、绑定地址、开始监听等操作。</p>
</li>
<li><p>当Acceptor接受到新的客户端连接时，在<code>TcpServer</code>类中的私有成员函数<code>newConnection()</code>被回调。在<code>newConnection()</code>函数中，会创建一个新的TcpConnection对象，并将其添加到连接管理字典<code>connections_</code>中。</p>
</li>
<li><p>在创建TcpConnection对象时，会设置相应的回调函数，包括连接建立回调函数、消息到达回调函数、写操作完成回调函数以及连接关闭回调函数。</p>
</li>
<li><p>创建TcpConnection后，通过调用<code>connectEstablished()</code>函数通知TcpConnection所属的EventLoop连接已经建立完毕，并触发用户设置的连接建立回调函数。（<code>connectEstablished()</code>函数会在TcpConnection对象所属的EventLoop线程中被回调，具体发生的时机是在新的客户端连接建立完成后。</p>
<p>当TcpServer监听到新的连接请求并接受连接时，会在<code>TcpServer::newConnection()</code>函数中创建一个新的TcpConnection对象，并通过<code>ioLoop-&gt;runInLoop()</code>将<code>TcpConnection::connectEstablished()</code>函数添加到所属的EventLoop线程的任务队列中。</p>
<p>随后，在EventLoop线程的下一个事件循环周期中，会从任务队列中取出<code>TcpConnection::connectEstablished()</code>函数并执行。这时，会触发用户设置的连接建立回调函数，并通知用户连接已经建立完毕。</p>
<p>因此，<code>connectEstablished()</code>函数的回调时机是在新的客户端连接建立完成后，即连接建立时机已经稳定，可以进行后续数据收发操作。）</p>
</li>
<li><p>在TcpConnection中，会监听连接的读事件，当有数据到达时，会调用用户设置的消息到达回调函数。</p>
</li>
<li><p>用户可以通过TcpConnection对象发送消息给客户端，TcpConnection内部会处理发送缓冲区，并通过调用底层的Socket API发送数据。</p>
</li>
<li><p>当连接关闭时，会触发连接关闭回调函数，并将TcpConnection从连接管理字典<code>connections_</code>中移除。</p>
</li>
</ol>
<p>这样，TcpServer实现了对连接客户端的一步步操作，包括接受连接、创建TcpConnection对象、监听事件、处理数据收发等过程。</p>
<p>以下是一个简单的例子来说明TcpServer的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;TcpServer.h&quot;</span><br><span class="line"></span><br><span class="line">void onConnection(const TcpConnectionPtr&amp; conn) &#123;</span><br><span class="line">    if (conn-&gt;connected()) &#123;</span><br><span class="line">        printf(&quot;New connection from %s\n&quot;, conn-&gt;peerAddress().toIpPort().c_str());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        printf(&quot;Connection %s is closed\n&quot;, conn-&gt;peerAddress().toIpPort().c_str());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void onMessage(const TcpConnectionPtr&amp; conn, Buffer* buffer) &#123;</span><br><span class="line">    std::string message = buffer-&gt;retrieveAllAsString();</span><br><span class="line">    printf(&quot;Received message from %s: %s\n&quot;, conn-&gt;peerAddress().toIpPort().c_str(), message.c_str());</span><br><span class="line">    conn-&gt;send(message); // Echo back the received message to the client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    EventLoop loop;</span><br><span class="line">    TcpServer server(&amp;loop, InetAddress(1234), &quot;TestServer&quot;);</span><br><span class="line">    server.setConnectionCallback(onConnection);</span><br><span class="line">    server.setMessageCallback(onMessage);</span><br><span class="line"></span><br><span class="line">    server.start();</span><br><span class="line"></span><br><span class="line">    loop.loop();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们首先创建一个EventLoop对象和一个TcpServer对象。然后，我们设置了连接建立回调函数<code>onConnection</code>和消息到达回调函数<code>onMessage</code>。最后，我们启动服务器并运行事件循环。</p>
<p>当有新的客户端连接时，会调用<code>onConnection</code>函数进行处理，输出连接建立信息。当有消息到达时，会调用<code>onMessage</code>函数进行处理，输出接收到的消息，并将该消息回传给客户端。</p>
<h2 id="TcpServer-h"><a href="#TcpServer-h" class="headerlink" title="TcpServer.h"></a>TcpServer.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">class TcpServer : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  typedef std::function&lt;void(EventLoop*)&gt; ThreadInitCallback;</span><br><span class="line">  enum Option</span><br><span class="line">  &#123;</span><br><span class="line">    kNoReusePort,</span><br><span class="line">    kReusePort,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  //TcpServer(EventLoop* loop, const InetAddress&amp; listenAddr);</span><br><span class="line">  TcpServer(EventLoop* loop,</span><br><span class="line">            const InetAddress&amp; listenAddr,</span><br><span class="line">            const string&amp; nameArg,</span><br><span class="line">            Option option = kNoReusePort);</span><br><span class="line">  ~TcpServer();  // force out-line dtor, for std::unique_ptr members.</span><br><span class="line"></span><br><span class="line">  const string&amp; ipPort() const &#123; return ipPort_; &#125;</span><br><span class="line">  const string&amp; name() const &#123; return name_; &#125;</span><br><span class="line">  EventLoop* getLoop() const &#123; return loop_; &#125;</span><br><span class="line"></span><br><span class="line">  void setThreadNum(int numThreads);</span><br><span class="line">  void setThreadInitCallback(const ThreadInitCallback&amp; cb)</span><br><span class="line">  &#123; threadInitCallback_ = cb; &#125;</span><br><span class="line">  /// valid after calling start()</span><br><span class="line">  std::shared_ptr&lt;EventLoopThreadPool&gt; threadPool()</span><br><span class="line">  &#123; return threadPool_; &#125;</span><br><span class="line"></span><br><span class="line">  /// Starts the server if it&#x27;s not listening.</span><br><span class="line">  ///</span><br><span class="line">  /// It&#x27;s harmless to call it multiple times.</span><br><span class="line">  /// Thread safe.</span><br><span class="line">  void start();</span><br><span class="line"></span><br><span class="line">  /// Set connection callback.</span><br><span class="line">  /// Not thread safe.</span><br><span class="line">  //设置连接到来或者连接关闭回调函数</span><br><span class="line">  void setConnectionCallback(const ConnectionCallback&amp; cb)</span><br><span class="line">  &#123; connectionCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line">  /// Set message callback.</span><br><span class="line">  /// Not thread safe.</span><br><span class="line">  //设置消息到来回调函数</span><br><span class="line">  void setMessageCallback(const MessageCallback&amp; cb)</span><br><span class="line">  &#123; messageCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line">  /// Set write complete callback.</span><br><span class="line">  /// Not thread safe.</span><br><span class="line">  void setWriteCompleteCallback(const WriteCompleteCallback&amp; cb)</span><br><span class="line">  &#123; writeCompleteCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  /// Not thread safe, but in loop</span><br><span class="line">  void newConnection(int sockfd, const InetAddress&amp; peerAddr);</span><br><span class="line">  /// Thread safe.</span><br><span class="line">  void removeConnection(const TcpConnectionPtr&amp; conn);</span><br><span class="line">  /// Not thread safe, but in loop</span><br><span class="line">  void removeConnectionInLoop(const TcpConnectionPtr&amp; conn);</span><br><span class="line"></span><br><span class="line">  typedef std::map&lt;string, TcpConnectionPtr&gt; ConnectionMap;//typedef std::shared_ptr&lt;TcpConnection&gt; TcpConnectionPtr;</span><br><span class="line"></span><br><span class="line">  EventLoop* loop_;  // the acceptor loop</span><br><span class="line">  const string ipPort_;//服务端口</span><br><span class="line">  const string name_;//服务名</span><br><span class="line">  std::unique_ptr&lt;Acceptor&gt; acceptor_; // avoid revealing Acceptor</span><br><span class="line">  std::shared_ptr&lt;EventLoopThreadPool&gt; threadPool_;</span><br><span class="line">  ConnectionCallback connectionCallback_;</span><br><span class="line">  MessageCallback messageCallback_;</span><br><span class="line">  WriteCompleteCallback writeCompleteCallback_;</span><br><span class="line">  ThreadInitCallback threadInitCallback_;</span><br><span class="line">  AtomicInt32 started_;</span><br><span class="line">  </span><br><span class="line">  ConnectionMap connections_;//连接列表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="TcpServer-cc"><a href="#TcpServer-cc" class="headerlink" title="TcpServer.cc"></a>TcpServer.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/net/TcpServer.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line">#include &quot;muduo/net/Acceptor.h&quot;</span><br><span class="line">#include &quot;muduo/net/EventLoop.h&quot;</span><br><span class="line">#include &quot;muduo/net/EventLoopThreadPool.h&quot;</span><br><span class="line">#include &quot;muduo/net/SocketsOps.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;  // snprintf</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">TcpServer::TcpServer(EventLoop* loop,</span><br><span class="line">                     const InetAddress&amp; listenAddr,</span><br><span class="line">                     const string&amp; nameArg,</span><br><span class="line">                     Option option)</span><br><span class="line">  : loop_(CHECK_NOTNULL(loop)),//是Logging.h定义的CHECK_NOTNULL</span><br><span class="line">    ipPort_(listenAddr.toIpPort()),</span><br><span class="line">    name_(nameArg),</span><br><span class="line">    acceptor_(new Acceptor(loop, listenAddr, option == kReusePort)),</span><br><span class="line">    threadPool_(new EventLoopThreadPool(loop, name_)),</span><br><span class="line">    connectionCallback_(defaultConnectionCallback),</span><br><span class="line">    messageCallback_(defaultMessageCallback),</span><br><span class="line">    nextConnId_(1)</span><br><span class="line">&#123;</span><br><span class="line">  //Acceptor: :handleRead函数中会回调用TcpSeruer::newConnection</span><br><span class="line">  //_1对应的是socket文件描述符，2对应的是对等方的地址( InetAddress)</span><br><span class="line">  acceptor_-&gt;setNewConnectionCallback(</span><br><span class="line">      std::bind(&amp;TcpServer::newConnection, this, _1, _2));</span><br><span class="line">&#125;</span><br><span class="line">//该函数多次调用是无害的</span><br><span class="line">//该函数可改跨线程调用</span><br><span class="line">void TcpServer::start()</span><br><span class="line">&#123;</span><br><span class="line">  if (started_.getAndSet(1) == 0)</span><br><span class="line">  &#123;</span><br><span class="line">    threadPool_-&gt;start(threadInitCallback_);</span><br><span class="line"></span><br><span class="line">    assert(!acceptor_-&gt;listening());</span><br><span class="line">    //get_pointer返回原生指针</span><br><span class="line">    loop_-&gt;runInLoop(</span><br><span class="line">        std::bind(&amp;Acceptor::listen, get_pointer(acceptor_)));//ptr.get();裸指针是为了将对象指针传递给 std::bind，从而在可调用对象中使用</span><br><span class="line">  &#125;//acceptor_.get() 是 std::unique_ptr 类提供的成员函数 get() 的调用，它用于获取被智能指针管理的对象的原始裸指针</span><br><span class="line">  //智能指针不能直接传递对象，是因为智能指针对对象进行了所有权管理</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpServer::newConnection(int sockfd, const InetAddress&amp; peerAddr)</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  EventLoop* ioLoop = threadPool_-&gt;getNextLoop();</span><br><span class="line">  char buf[64];</span><br><span class="line">  snprintf(buf, sizeof buf, &quot;-%s#%d&quot;, ipPort_.c_str(), nextConnId_);</span><br><span class="line">  ++nextConnId_;</span><br><span class="line">  string connName = name_ + buf;</span><br><span class="line"></span><br><span class="line">  LOG_INFO &lt;&lt; &quot;TcpServer::newConnection [&quot; &lt;&lt; name_</span><br><span class="line">           &lt;&lt; &quot;] - new connection [&quot; &lt;&lt; connName</span><br><span class="line">           &lt;&lt; &quot;] from &quot; &lt;&lt; peerAddr.toIpPort();</span><br><span class="line">  InetAddress localAddr(sockets::getLocalAddr(sockfd));</span><br><span class="line">  // FIXME poll with zero timeout to double confirm the new connection</span><br><span class="line">  // FIXME use make_shared if necessary</span><br><span class="line">  TcpConnectionPtr conn(new TcpConnection(ioLoop,</span><br><span class="line">                                          connName,</span><br><span class="line">                                          sockfd,</span><br><span class="line">                                          localAddr,</span><br><span class="line">                                          peerAddr));</span><br><span class="line">  connections_[connName] = conn;</span><br><span class="line">  conn-&gt;setConnectionCallback(connectionCallback_);</span><br><span class="line">  conn-&gt;setMessageCallback(messageCallback_);</span><br><span class="line">  conn-&gt;setWriteCompleteCallback(writeCompleteCallback_);</span><br><span class="line">  conn-&gt;setCloseCallback(</span><br><span class="line">      std::bind(&amp;TcpServer::removeConnection, this, _1)); // FIXME: unsafe</span><br><span class="line">  ioLoop-&gt;runInLoop(std::bind(&amp;TcpConnection::connectEstablished, conn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当服务器监听到新的客户端连接请求时，Acceptor类会调用<code>handleRead</code>函数，在<code>handleRead</code>函数中会回调<code>TcpServer</code>类的<code>newConnection</code>函数来处理新的连接。</p>
<p>无论是第一个连接还是后续的连接，都会通过调用<code>newConnection</code>函数来创建相应的TcpConnection对象，并进行必要的初始化和设置。</p>
<h2 id="TcpConnection-h"><a href="#TcpConnection-h" class="headerlink" title="TcpConnection.h"></a>TcpConnection.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void setConnectionCallback(const ConnectionCallback&amp; cb)</span><br><span class="line">  &#123; connectionCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line">  void setMessageCallback(const MessageCallback&amp; cb)</span><br><span class="line">  &#123; messageCallback_ = cb; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="TcpConnection-cc"><a href="#TcpConnection-cc" class="headerlink" title="TcpConnection.cc"></a>TcpConnection.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">TcpConnection::TcpConnection(EventLoop* loop,</span><br><span class="line">                             const string&amp; nameArg,</span><br><span class="line">                             int sockfd,</span><br><span class="line">                             const InetAddress&amp; localAddr,</span><br><span class="line">                             const InetAddress&amp; peerAddr)</span><br><span class="line">  : loop_(CHECK_NOTNULL(loop)),</span><br><span class="line">    name_(nameArg),</span><br><span class="line">    state_(kConnecting),</span><br><span class="line">    reading_(true),</span><br><span class="line">    socket_(new Socket(sockfd)),</span><br><span class="line">    channel_(new Channel(loop, sockfd)),</span><br><span class="line">    localAddr_(localAddr),</span><br><span class="line">    peerAddr_(peerAddr),</span><br><span class="line">    highWaterMark_(64*1024*1024)</span><br><span class="line">&#123;</span><br><span class="line">  //通道可读事件到来的时候，回调TcpConnection::handleRead，_1是事件发生时间</span><br><span class="line">  channel_-&gt;setReadCallback(</span><br><span class="line">      std::bind(&amp;TcpConnection::handleRead, this, _1));</span><br><span class="line">  channel_-&gt;setWriteCallback(</span><br><span class="line">      std::bind(&amp;TcpConnection::handleWrite, this));</span><br><span class="line">  channel_-&gt;setCloseCallback(</span><br><span class="line">      std::bind(&amp;TcpConnection::handleClose, this));</span><br><span class="line">  channel_-&gt;setErrorCallback(</span><br><span class="line">      std::bind(&amp;TcpConnection::handleError, this));</span><br><span class="line">  LOG_DEBUG &lt;&lt; &quot;TcpConnection::ctor[&quot; &lt;&lt;  name_ &lt;&lt; &quot;] at &quot; &lt;&lt; this</span><br><span class="line">            &lt;&lt; &quot; fd=&quot; &lt;&lt; sockfd;</span><br><span class="line">  socket_-&gt;setKeepAlive(true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpConnection::connectEstablished()</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  assert(state_ == kConnecting);</span><br><span class="line">  setState(kConnected);</span><br><span class="line">  channel_-&gt;tie(shared_from_this());</span><br><span class="line">  channel_-&gt;enableReading();//Tcpconnection所对应的通道加入到Poller关注</span><br><span class="line"></span><br><span class="line">  connectionCallback_(shared_from_this());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpConnection::handleRead(Timestamp receiveTime)</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  int savedErrno = 0;</span><br><span class="line">  ssize_t n = inputBuffer_.readFd(channel_-&gt;fd(), &amp;savedErrno);</span><br><span class="line">  if (n &gt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    messageCallback_(shared_from_this(), &amp;inputBuffer_, receiveTime);//shared_from_this()将当前对象转换成shared_ptr，而不是裸指针</span><br><span class="line">  &#125;</span><br><span class="line">  else if (n == 0)</span><br><span class="line">  &#123;</span><br><span class="line">    handleClose();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    errno = savedErrno;</span><br><span class="line">    LOG_SYSERR &lt;&lt; &quot;TcpConnection::handleRead&quot;;</span><br><span class="line">    handleError();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TcpConnection::connectEstablished()</code>函数是TcpConnection类的成员函数，用于在连接成功建立后进行相应的处理。</p>
<p>首先，使用<code>loop_-&gt;assertInLoopThread()</code>断言当前函数被调用的线程是所属的EventLoop线程，以确保函数只能在正确的线程中被调用。</p>
<p>然后，通过<code>assert(state_ == kConnecting)</code>断言当前连接状态<code>state_</code>为正在连接状态，以确保该函数只能在连接状态为正在连接时被调用。</p>
<p>接下来，通过调用<code>setState(kConnected)</code>将连接状态更新为已连接状态。</p>
<p>然后，将TcpConnection所对应的通道<code>channel_</code>与TcpConnection对象自身进行绑定，即调用<code>channel_-&gt;tie(shared_from_this())</code>。这个操作是为了在通道回调函数中可以安全地使用TcpConnection对象。</p>
<p>接着，调用<code>channel_-&gt;enableReading()</code>，将TcpConnection所对应的通道加入到Poller中进行读事件的监听。</p>
<p>最后，调用<code>connectionCallback_(shared_from_this())</code>，即用户设置的连接回调函数，通知用户连接已经建立成功，并将TcpConnection对象作为参数传递给回调函数。</p>
<p>总之，<code>connectEstablished</code>函数在连接成功建立后，会进行一系列的操作，包括更新连接状态、关联通道并进行事件监听，并触发连接回调函数以通知用户连接建立成功。</p>
<h2 id="TcpConnection生存期管理"><a href="#TcpConnection生存期管理" class="headerlink" title="TcpConnection生存期管理"></a>TcpConnection生存期管理</h2><p>当连接到来，创建一个TcpConnection对象，立刻用shared_ptr来管理，引用计数为1<br>在Channel中维护一个<code>weak_ptr(tie_)</code>，将这个<code>shared_ptr</code>对象赋值给<code>tie_</code>引用计数仍为1</p>
<p>当连接关闭，在handleEvent，将<code>tie_</code>提升，得到一个<code>shared_ptr</code>对象，引用计数就变成了2</p>
<p><code>shared_ptr</code> 是 C++ 标准库中的一个智能指针（Smart Pointer）类模板，用于管理动态分配的对象的生命周期。它允许多个 <code>shared_ptr</code> 实例共享同一个堆上的对象，当没有引用指向对象时，对象会自动被销毁，从而避免了内存泄漏。</p>
<p><code>shared_ptr</code> 提供了一种自动引用计数机制，它会跟踪有多少个 <code>shared_ptr</code> 实例指向相同的对象。每当创建一个新的 <code>shared_ptr</code> 指向对象，引用计数会增加；当 <code>shared_ptr</code> 被销毁或重置时，引用计数会减少。当引用计数减少到零时，表示没有 <code>shared_ptr</code> 实例再指向该对象，对象将会被自动删除。</p>
<p>以下是 <code>shared_ptr</code> 的一些重要特性和用法：</p>
<ol>
<li><strong>共享所有权：</strong> 多个 <code>shared_ptr</code> 实例可以共享相同的对象所有权，从而避免了手动管理内存释放。</li>
<li><strong>循环引用问题：</strong> 尽管 <code>shared_ptr</code> 可以有效地管理内存，但如果存在循环引用（两个或多个对象相互引用），可能会导致内存泄漏。为了解决这个问题，可以使用 <code>weak_ptr</code> 来解除循环引用。</li>
<li><strong>自定义删除器：</strong> 可以使用自定义的删除器函数或函数对象来控制对象的销毁过程。</li>
<li><strong>线程安全：</strong> <code>shared_ptr</code> 本身不提供线程安全的保证。多个线程同时修改引用计数可能导致竞态条件。在多线程环境中，需要额外的同步机制来确保安全使用。</li>
<li><strong>使用方便：</strong> <code>shared_ptr</code> 的使用方式类似于常规指针，可以通过 <code>-&gt;</code> 和 <code>*</code> 运算符访问对象的成员。</li>
</ol>
<h3 id="连接关闭时序图"><a href="#连接关闭时序图" class="headerlink" title="连接关闭时序图"></a>连接关闭时序图</h3><p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%884%EF%BC%89/image-20230816112443369.png" alt="image-20230816112443369"></p>
<img src="/2023/08/15/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%884%EF%BC%89/image-20230816112443369.png" class title="This is an test image">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> &#123; /// Internal use only.</span><br><span class="line">  void setCloseCallback(const CloseCallback&amp; cb)</span><br><span class="line">  &#123; closeCallback_ = cb; &#125;</span><br><span class="line">private:</span><br><span class="line">  void connectDestroyed();  // should be called only once</span><br><span class="line">  CloseCallback closeCallback_;//用户内部的连接关闭回调函数</span><br><span class="line">  void handleError();</span><br><span class="line">  void handleClose();</span><br><span class="line"> &#125;; </span><br><span class="line">  typedef std::shared_ptr&lt;TcpConnection&gt; TcpConnectionPtr;</span><br><span class="line">  </span><br><span class="line">  构造函数：</span><br><span class="line">  channel_-&gt;setCloseCallback(</span><br><span class="line">      std::bind(&amp;TcpConnection::handleClose, this));</span><br><span class="line">  channel_-&gt;setErrorCallback(</span><br><span class="line">      std::bind(&amp;TcpConnection::handleError, this));</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">void TcpConnection::handleRead(Timestamp receiveTime)</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  int savedErrno = 0;</span><br><span class="line">  ssize_t n = inputBuffer_.readFd(channel_-&gt;fd(), &amp;savedErrno);</span><br><span class="line">  if (n &gt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    messageCallback_(shared_from_this(), &amp;inputBuffer_, receiveTime);//shared_from_this()将当前对象转换成shared_ptr，而不是裸指针</span><br><span class="line">  &#125;</span><br><span class="line">  else if (n == 0)</span><br><span class="line">  &#123;</span><br><span class="line">    handleClose();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    errno = savedErrno;</span><br><span class="line">    LOG_SYSERR &lt;&lt; &quot;TcpConnection::handleRead&quot;;</span><br><span class="line">    handleError();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpConnection::handleClose()</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  LOG_TRACE &lt;&lt; &quot;fd = &quot; &lt;&lt; channel_-&gt;fd() &lt;&lt; &quot; state = &quot; &lt;&lt; stateToString();</span><br><span class="line">  assert(state_ == kConnected || state_ == kDisconnecting);</span><br><span class="line">  // we don&#x27;t close fd, leave it to dtor, so we can find leaks easily.</span><br><span class="line">  setState(kDisconnected);</span><br><span class="line">  channel_-&gt;disableAll();</span><br><span class="line"></span><br><span class="line">  TcpConnectionPtr guardThis(shared_from_this());</span><br><span class="line">  connectionCallback_(guardThis);//这一行可以不调用</span><br><span class="line">  // must be the last line</span><br><span class="line">  closeCallback_(guardThis);//调用TcpServer::removeConnection</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpConnection::handleError()</span><br><span class="line">&#123;</span><br><span class="line">  int err = sockets::getSocketError(channel_-&gt;fd());</span><br><span class="line">  LOG_ERROR &lt;&lt; &quot;TcpConnection::handleError [&quot; &lt;&lt; name_</span><br><span class="line">            &lt;&lt; &quot;] - SO_ERROR = &quot; &lt;&lt; err &lt;&lt; &quot; &quot; &lt;&lt; strerror_tl(err);</span><br><span class="line">&#125;</span><br><span class="line">void TcpConnection::connectEstablished()</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  assert(state_ == kConnecting);</span><br><span class="line">  setState(kConnected);</span><br><span class="line">  channel_-&gt;tie(shared_from_this());//void tie(const std::shared_ptr&lt;void&gt;&amp;);</span><br><span class="line">  //但是tie_不会更改计数，还是shared_from_this()加一后的，因为它是弱引用，但是shared_from_this()是临死对象，加1后会减1</span><br><span class="line">  //shared_from_this()继承自std::enable_shared_from_this&lt;TcpConnection&gt;，返回一个shared_ptr类型的TcpConnection对象</span><br><span class="line">  channel_-&gt;enableReading();//Tcpconnection所对应的通道加入到Poller关注</span><br><span class="line"></span><br><span class="line">  connectionCallback_(shared_from_this());</span><br><span class="line">&#125;</span><br><span class="line">void TcpServer::removeConnectionInLoop(const TcpConnectionPtr&amp; conn)</span><br><span class="line">// &#123;</span><br><span class="line">//   loop_-&gt;assertInLoopThread();</span><br><span class="line">//   LOG_INFO &lt;&lt; &quot;TcpServer::removeConnectionInLoop [&quot; &lt;&lt; name_</span><br><span class="line">//            &lt;&lt; &quot;] - connection &quot; &lt;&lt; conn-&gt;name();</span><br><span class="line">//   size_t n = connections_.erase(conn-&gt;name());//引用计数减一,从容器中删除相应的键值对</span><br><span class="line">//   (void)n;</span><br><span class="line">//   assert(n == 1);</span><br><span class="line">//   EventLoop* ioLoop = conn-&gt;getLoop();</span><br><span class="line">//   ioLoop-&gt;queueInLoop(//handEvent事件处理完毕后处理functors</span><br><span class="line">//       std::bind(&amp;TcpConnection::connectDestroyed, conn));//引用计数加一</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">void TcpConnection::connectDestroyed()</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  if (state_ == kConnected)//如果handleClose中已调用回调函数，这里就不会再调用</span><br><span class="line">  &#123;</span><br><span class="line">    setState(kDisconnected);</span><br><span class="line">    channel_-&gt;disableAll();</span><br><span class="line"></span><br><span class="line">    connectionCallback_(shared_from_this());//shared_from_this()将当前对象转换成shared_ptr获取，会使shared_ptr引用计数加1，但是是临时对象，马上会销毁</span><br><span class="line">  &#125;</span><br><span class="line">  channel_-&gt;remove();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Channel::handleEvent(Timestamp receiveTime)</span><br><span class="line">&#123;</span><br><span class="line">  std::shared_ptr&lt;void&gt; guard;</span><br><span class="line">  if (tied_)</span><br><span class="line">  &#123;</span><br><span class="line">    guard = tie_.lock();//如果 lock 成功，即 guard 不为空，那么表示资源仍然有效，可以安全地执行 handleEventWithGuard 函数</span><br><span class="line">    if (guard)</span><br><span class="line">    &#123;</span><br><span class="line">      handleEventWithGuard(receiveTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else//如果 lock 失败，即 guard 为空，那么表示被 std::weak_ptr 管理的资源已经失效，不再存在</span><br><span class="line">  &#123;</span><br><span class="line">    handleEventWithGuard(receiveTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tie_.lock()</code> 是 <code>std::weak_ptr</code> 的一个方法，用于创建一个有效的 <code>std::shared_ptr</code>，以便在某个范围内使用这个资源。如果资源仍然有效，<code>lock()</code> 方法将返回一个非空的 <code>std::shared_ptr</code>；如果资源已经失效，它将返回一个空的 <code>std::shared_ptr</code>。</p>
<p>因此，<code>tie_.lock()</code> 方法不是针对 <code>std::shared_ptr</code> 或 <code>std::weak_ptr</code> 类的全局方法，而是 <code>std::weak_ptr</code> 的成员方法，用于操作 <code>std::weak_ptr</code> 对象以检查被观察的资源是否仍然存在。</p>
<p><code>std::shared_ptr</code> 和 <code>std::weak_ptr</code> 是 C++ 标准库中两种用于管理动态分配的对象的智能指针类型。它们之间有关联，主要用于解决循环引用问题以及确保动态分配对象的正确管理。</p>
<p>下面是它们之间的关系：</p>
<ol>
<li><strong>std::shared_ptr</strong>：是一种强引用智能指针，它允许多个 <code>shared_ptr</code> 共享同一个对象，并且通过引用计数来追踪对象的生命周期。当最后一个 <code>shared_ptr</code> 对象释放其引用时，引用计数会降为零，从而释放对象并释放其分配的内存。<code>std::shared_ptr</code> 本身会增加对象的引用计数。</li>
<li><strong>std::weak_ptr</strong>：是一种弱引用智能指针，它不会增加对象的引用计数。它允许观察由 <code>shared_ptr</code> 管理的对象，但不会影响对象的生命周期。最常见的用途是避免循环引用问题，其中两个对象彼此持有对方的 <code>shared_ptr</code>，导致对象无法被正确释放。通过使用 <code>std::weak_ptr</code>，可以解决循环引用问题，因为它不会增加引用计数，但仍然可以用于检查对象是否仍然存在。</li>
</ol>
<p>总结来说，<code>std::shared_ptr</code> 允许多个智能指针共享所有权，并且通过引用计数来管理对象的生命周期。<code>std::weak_ptr</code> 允许观察 <code>std::shared_ptr</code> 管理的对象，但不会影响其生命周期。这两种智能指针在一起使用，可以有效地解决资源管理和循环引用问题。</p>
<p>如果 <code>p</code> 是一个 <code>std::shared_ptr</code> 对象，那么 <code>p.get()</code> 的含义是获取 <code>std::shared_ptr</code> 对象所管理的原始指针</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/13/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%883%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/13/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%883%EF%BC%89/" class="post-title-link" itemprop="url">muduo-网络库（3）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-13 15:37:10" itemprop="dateCreated datePublished" datetime="2023-08-13T15:37:10+08:00">2023-08-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-17 20:08:57" itemprop="dateModified" datetime="2023-08-17T20:08:57+08:00">2023-08-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="进程-线程-wait-x2F-notify"><a href="#进程-线程-wait-x2F-notify" class="headerlink" title="进程(线程)wait&#x2F;notify"></a>进程(线程)wait&#x2F;notify</h1><ul>
<li><p>pipe</p>
<ul>
<li>单向通信</li>
</ul>
</li>
<li><p>socketpair</p>
<ul>
<li>双向通信</li>
</ul>
</li>
<li><p>eventfd</p>
<ul>
<li>eventfd是一个比 pipe更高效的线程间事件通知机制，一方面它比 pipe少用一个file descripor,节省了资源;另一方面，eventfd的缓冲区管理也简单得多，全部“buffer”只有定长8 bytes，不像pipe那样可能有不定长的真正 buffer。</li>
</ul>
</li>
</ul>
<p>线程间还多一个条件变量，但是上面三个有文件描述符，可以用IO复用，即poll&#x2F;epoll&#x2F;select,条件变量不行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int wakeupFd_;//用于eventfd</span><br><span class="line">  // unlike in TimerQueue, which is an internal class,</span><br><span class="line">  // we don&#x27;t expose Channel to client.</span><br><span class="line"> std::unique_ptr&lt;Channel&gt; wakeupChannel_;//wakeupFd_通道的管理，将会纳入poller_管理,是一个智能指针</span><br><span class="line">  //这里EventLoop和Channel是组合关系，EventLoop销毁则channel也要销毁，也就是wakeupFd_销毁</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wakeupFd_(createEventfd()),</span><br><span class="line">    wakeupChannel_(new Channel(this, wakeupFd_)),</span><br><span class="line"></span><br><span class="line">int createEventfd()</span><br><span class="line">&#123;</span><br><span class="line">  int evtfd = ::eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC);</span><br><span class="line">  if (evtfd &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSERR &lt;&lt; &quot;Failed in eventfd&quot;;</span><br><span class="line">    abort();</span><br><span class="line">  &#125;</span><br><span class="line">  return evtfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="EventLoop-runInLoop"><a href="#EventLoop-runInLoop" class="headerlink" title="EventLoop::runInLoop"></a>EventLoop::runInLoop</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//在IO线程中执行某个回调函数，该函数可以跨线程调用，调用这个函数可以保证不用加锁</span><br><span class="line">void EventLoop::runInLoop(Functor cb)</span><br><span class="line">&#123;</span><br><span class="line">  if (isInLoopThread())</span><br><span class="line">  &#123;</span><br><span class="line">  	//如果是当前线程调用runInLoop，则同步调用cb</span><br><span class="line">    cb();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">  	//如果是其它线程调用，则异步地将cb添加到队列</span><br><span class="line">    queueInLoop(std::move(cb));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="EventLoop-queueInLoop"><a href="#EventLoop-queueInLoop" class="headerlink" title="EventLoop::queueInLoop"></a>EventLoop::queueInLoop</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void EventLoop::queueInLoop(Functor cb)</span><br><span class="line">&#123;</span><br><span class="line">  &#123;</span><br><span class="line">  MutexLockGuard lock(mutex_);</span><br><span class="line">  pendingFunctors_.push_back(std::move(cb));</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">//调用queuelnLoop的线程不是当前IO线程需要唤醒</span><br><span class="line">//或者调用queueInLoop的线程是当前IO线程，并且此时正在调用pending functor，需要唤醒</span><br><span class="line">//只有当前IO线程的事件回调中调用queuelnLoop才不需要唤醒</span><br><span class="line">  if (!isInLoopThread() || callingPendingFunctors_)//callingPendingFunctors_ 这个变量用于跟踪事件循环是否正在执行已添加到事件循环任务队列中的待处理函数（也称为回调）</span><br><span class="line">  &#123;</span><br><span class="line">    wakeup();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void EventLoop::doPendingFunctors()</span><br><span class="line">&#123;</span><br><span class="line">  std::vector&lt;Functor&gt; functors;</span><br><span class="line">  callingPendingFunctors_ = true;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    functors.swap(pendingFunctors_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for (const Functor&amp; functor : functors)</span><br><span class="line">  &#123;</span><br><span class="line">    functor();</span><br><span class="line">  &#125;</span><br><span class="line">  callingPendingFunctors_ = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是其功能解释：</p>
<ol>
<li>它在处理待处理函数之前将 <code>callingPendingFunctors_</code> 设置为 <code>true</code>。这是为了防止在事件循环执行函数时，其他部分的代码同时修改待处理函数列表。</li>
<li>它使用 <code>MutexLockGuard</code> 以确保对 <code>pendingFunctors_</code>（待处理函数队列）的访问受到互斥锁的保护。这很重要，以避免在添加或删除函数时出现竞争条件。</li>
<li>它通过将 <code>pendingFunctors_</code> 队列的内容与本地向量 <code>functors</code> 进行交换。交换允许事件循环快速处理待处理函数，而无需保持锁定，从而减少竞争和潜在的阻塞。</li>
<li>然后，它遍历 <code>functors</code> 向量并执行每个函数。这些函数是使用 <code>queueInLoop()</code> 向事件循环添加的回调函数。</li>
<li>最后，在执行所有待处理函数之后，它将 <code>callingPendingFunctors_</code> 设置回 <code>false</code>。</li>
</ol>
<p>总之，<code>callingPendingFunctors_</code> 是一个状态变量，有助于在事件循环内以安全和同步的方式管理待处理的回调（函数）。</p>
<h2 id="EventLoop-loop"><a href="#EventLoop-loop" class="headerlink" title="EventLoop::loop"></a>EventLoop::loop</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">while (!quit_)</span><br><span class="line">  &#123;</span><br><span class="line">    activeChannels_.clear();</span><br><span class="line">    pollReturnTime_ = poller_-&gt;poll(kPollTimeMs, &amp;activeChannels_);</span><br><span class="line">    ++iteration_;</span><br><span class="line">    if (Logger::logLevel() &lt;= Logger::TRACE)</span><br><span class="line">    &#123;</span><br><span class="line">      printActiveChannels();</span><br><span class="line">    &#125;</span><br><span class="line">    // TODO sort channel by priority</span><br><span class="line">    eventHandling_ = true;</span><br><span class="line">    for (Channel* channel : activeChannels_)</span><br><span class="line">    &#123;</span><br><span class="line">      currentActiveChannel_ = channel;</span><br><span class="line">      currentActiveChannel_-&gt;handleEvent(pollReturnTime_);</span><br><span class="line">    &#125;</span><br><span class="line">    currentActiveChannel_ = NULL;</span><br><span class="line">    eventHandling_ = false;</span><br><span class="line">    doPendingFunctors();//让IO线程也能执行一些计算任务，即IO不繁忙的时候添加计算任务让他来处理</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%883%EF%BC%89/image-20230813163113214.png" alt="image-20230813163113214"></p>
<img src="/2023/08/13/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%883%EF%BC%89/image-20230813163113214.png" class title="This is an test image">

<h2 id="EventLoop-doPendingFunctors"><a href="#EventLoop-doPendingFunctors" class="headerlink" title="EventLoop::doPendingFunctors"></a><strong>EventLoop</strong>::doPendingFunctors</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void EventLoop::doPendingFunctors()</span><br><span class="line">&#123;</span><br><span class="line">  std::vector&lt;Functor&gt; functors;</span><br><span class="line">  callingPendingFunctors_ = true;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">  MutexLockGuard lock(mutex_);//</span><br><span class="line">  functors.swap(pendingFunctors_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for (const Functor&amp; functor : functors)</span><br><span class="line">  &#123;</span><br><span class="line">    functor();</span><br><span class="line">  &#125;</span><br><span class="line">  callingPendingFunctors_ = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不是简单地在临界区内依次调用Functor，而是把回调列表swap到functors中，这样一方面减小了临界区的长度（意味着不会阻塞其它线程的queuelnLoop()），另一方面，也避免了死锁(因为Functor可能再次调用queuelnLoop())</li>
<li>由于doPendingFunctors()调用的Functor可能再次调用queuelnLoop(cb)，这时，queuelnLoop()就必须wakeup(),否则新增的cb可能就不能及时调用了</li>
<li>muduo没有反复执行doPendingFunctors()直到pendingFunctors为空，这是有意的，否则IO线程可能陷入死循环，无法处理IO事件。</li>
</ul>
<h1 id="EventLoopThread"><a href="#EventLoopThread" class="headerlink" title="EventLoopThread"></a>EventLoopThread</h1><ul>
<li>任何一个线程，只要创建并运行了EventLoop,都称之为IO线程</li>
<li>IO线程不一定是主线程</li>
<li>muduo并发模型one loop per thread + threadpool，(包括了IO线程池和计算线程池)</li>
<li>为了方便今后使用，定义了EventLoopThread类，该类封装了IO线程<ul>
<li>EventLoopThread创建了一个线程</li>
<li>在线程函数中创建了一个EvenLoop对象并调用EventLoop:loop</li>
</ul>
</li>
</ul>
<p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%883%EF%BC%89/image-20230813203826232.png" alt="image-20230813203826232"></p>
<img src="/2023/08/13/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%883%EF%BC%89/image-20230813203826232.png" class title="This is an test image">

<p>在startLoop时会 thread_.<strong>start</strong>()，进入线程回调函数并绑定 <code>loop_ = &amp;loop;</code>再 <code>return loop;</code>，也就是说loop的runInLoop,runAfter都是同一个线程。</p>
<h2 id="EventLoopThread-h"><a href="#EventLoopThread-h" class="headerlink" title="EventLoopThread.h"></a>EventLoopThread.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_NET_EVENTLOOPTHREAD_H</span><br><span class="line">#define MUDUO_NET_EVENTLOOPTHREAD_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Condition.h&quot;</span><br><span class="line">#include &quot;muduo/base/Mutex.h&quot;</span><br><span class="line">#include &quot;muduo/base/Thread.h&quot;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">class EventLoop;</span><br><span class="line"></span><br><span class="line">class EventLoopThread : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  typedef std::function&lt;void(EventLoop*)&gt; ThreadInitCallback;</span><br><span class="line"></span><br><span class="line">  EventLoopThread(const ThreadInitCallback&amp; cb = ThreadInitCallback(),</span><br><span class="line">                  const string&amp; name = string());</span><br><span class="line">  ~EventLoopThread();</span><br><span class="line">  EventLoop* startLoop();//启动线程，该线程就成为了IO线程</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  void threadFunc();//线程函数</span><br><span class="line"></span><br><span class="line">  EventLoop* loop_ GUARDED_BY(mutex_);//loop指针指向了eventloop对象</span><br><span class="line">  bool exiting_;</span><br><span class="line">  Thread thread_;//因为是基于对象编程思想，所以包含了一个thread类</span><br><span class="line">  MutexLock mutex_;</span><br><span class="line">  Condition cond_ GUARDED_BY(mutex_);</span><br><span class="line">  ThreadInitCallback callback_;//回调函数在EventLoop::loop事件循环之前被调用</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_NET_EVENTLOOPTHREAD_H</span><br></pre></td></tr></table></figure>

<h2 id="EventLoopThread-cc"><a href="#EventLoopThread-cc" class="headerlink" title="EventLoopThread.cc"></a>EventLoopThread.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/net/EventLoopThread.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/net/EventLoop.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">EventLoopThread::EventLoopThread(const ThreadInitCallback&amp; cb,</span><br><span class="line">                                 const string&amp; name)</span><br><span class="line">  : loop_(NULL),</span><br><span class="line">    exiting_(false),</span><br><span class="line">    thread_(std::bind(&amp;EventLoopThread::threadFunc, this), name),</span><br><span class="line">    mutex_(),</span><br><span class="line">    cond_(mutex_),</span><br><span class="line">    callback_(cb)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventLoopThread::~EventLoopThread()</span><br><span class="line">&#123;</span><br><span class="line">  exiting_ = true;</span><br><span class="line">  if (loop_ != NULL) // not 100% race-free, eg. threadFunc could be running callback_.</span><br><span class="line">  &#123;</span><br><span class="line">    // still a tiny chance to call destructed object, if threadFunc exits just now.</span><br><span class="line">    // but when EventLoopThread destructs, usually programming is exiting anyway.</span><br><span class="line">    loop_-&gt;quit();//退出IO线程，让IO线程的loop循环退出，从而退出了IO线程</span><br><span class="line">    thread_.join();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventLoop* EventLoopThread::startLoop()</span><br><span class="line">&#123;</span><br><span class="line">  assert(!thread_.started());//断言线程还未启动</span><br><span class="line">  thread_.start();//启动调用EventLoopThread::threadFunc</span><br><span class="line"></span><br><span class="line">  EventLoop* loop = NULL;</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    while (loop_ == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      cond_.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    loop = loop_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void EventLoopThread::threadFunc()</span><br><span class="line">&#123;</span><br><span class="line">  EventLoop loop;</span><br><span class="line"></span><br><span class="line">  if (callback_)//可以有选择的传递回调函数</span><br><span class="line">  &#123;</span><br><span class="line">    callback_(&amp;loop);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    //1oop_指针指向了一个栈上的对象，threadFunc函数退出之后，这个指针就失效了.</span><br><span class="line">    //threadFunc函教退出，就意味着线程退出了，EventLoopThread对象也就没有存在的价值了.</span><br><span class="line">    loop_ = &amp;loop;</span><br><span class="line">    cond_.notify();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  loop.loop();//退出了，也就相当于整个线程退出了</span><br><span class="line">  //assert(exiting_);</span><br><span class="line">  MutexLockGuard lock(mutex_);</span><br><span class="line">  loop_ = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Socket封装"><a href="#Socket封装" class="headerlink" title="Socket封装"></a>Socket封装</h1><h2 id="Endian-h"><a href="#Endian-h" class="headerlink" title="Endian.h"></a>Endian.h</h2><ul>
<li>封装了字节序转换函数（全局函数，位于muduo::net::sockets名称空间中）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_NET_ENDIAN_H</span><br><span class="line">#define MUDUO_NET_ENDIAN_H</span><br><span class="line"></span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;endian.h&gt;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line">namespace sockets</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">// the inline assembler code makes type blur,</span><br><span class="line">// so we disable warnings for a while.</span><br><span class="line">#pragma GCC diagnostic push//这个指令将当前的警告和错误状态入栈，保存起来，以便稍后可以使用 #pragma GCC diagnostic pop 恢复到先前的状态。在这个代码块中，它保存了当前的警告状态，以便可以在代码块结束后还原</span><br><span class="line">#pragma GCC diagnostic ignored &quot;-Wconversion&quot;//这个指令告诉编译器在接下来的代码块中忽略与隐式类型转换相关的警告（-Wconversion 警告）。这样，代码块内的类型转换不会触发编译器的警告信息</span><br><span class="line">#pragma GCC diagnostic ignored &quot;-Wold-style-cast&quot;//这个指令告诉编译器在接下来的代码块中忽略与旧式的C风格类型转换相关的警告。这种类型的转换在现代C++中被认为是不安全的，通过这个指令可以禁用与它相关的警告</span><br><span class="line">//#pragma GCC diagnostic push 和 #pragma GCC diagnostic pop 用于临时禁用编译器的警告，以便在进行字节序转换函数的实现时，不受 -Wconversion 和 -Wold-style-cast 这两种警告的干扰。这些警告与类型转换相关，可能在你的代码中的转换操作时触发</span><br><span class="line">inline uint64_t hostToNetwork64(uint64_t host64)</span><br><span class="line">&#123;</span><br><span class="line">  return htobe64(host64);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline uint32_t hostToNetwork32(uint32_t host32)</span><br><span class="line">&#123;</span><br><span class="line">  return htobe32(host32);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline uint16_t hostToNetwork16(uint16_t host16)</span><br><span class="line">&#123;</span><br><span class="line">  return htobe16(host16);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline uint64_t networkToHost64(uint64_t net64)</span><br><span class="line">&#123;</span><br><span class="line">  return be64toh(net64);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline uint32_t networkToHost32(uint32_t net32)</span><br><span class="line">&#123;</span><br><span class="line">  return be32toh(net32);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline uint16_t networkToHost16(uint16_t net16)</span><br><span class="line">&#123;</span><br><span class="line">  return be16toh(net16);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma GCC diagnostic pop</span><br><span class="line"></span><br><span class="line">&#125;  // namespace sockets</span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_NET_ENDIAN_H</span><br></pre></td></tr></table></figure>

<p>上面的方法只适用于Linux，不能跨平台。</p>
<h2 id="SocketsOps-h-x2F-SocketsOps-cc"><a href="#SocketsOps-h-x2F-SocketsOps-cc" class="headerlink" title="SocketsOps.h&#x2F; SocketsOps.cc"></a>SocketsOps.h&#x2F; SocketsOps.cc</h2><ul>
<li>封装了socket相关系统调用（全局函数，位于muduo::net::sockets名称空间中)。</li>
</ul>
<p>这些函数看起来是用于类型转换，主要是在Socket编程中对网络地址结构 <code>sockaddr</code> 及其 IPv4 (<code>sockaddr_in</code>) 和 IPv6 (<code>sockaddr_in6</code>) 版本之间的转换。让我们分析每个函数的区别和用途：</p>
<ol>
<li><strong><code>const struct sockaddr* sockets::sockaddr_cast(const struct sockaddr_in6* addr)</code></strong>:<ul>
<li>参数类型：<code>sockaddr_in6</code> 指针</li>
<li>返回类型：<code>const sockaddr*</code></li>
<li>作用：将IPv6地址结构 (<code>sockaddr_in6</code>) 转换为通用的地址结构 (<code>sockaddr</code>) 的常量指针。</li>
<li>使用场景：通常在需要操作IPv6地址的网络编程中，可能需要将 <code>sockaddr_in6</code> 类型的地址转换为通用的 <code>sockaddr</code> 类型。</li>
</ul>
</li>
<li><strong><code>struct sockaddr* sockets::sockaddr_cast(struct sockaddr_in6* addr)</code></strong>:<ul>
<li>参数类型：<code>sockaddr_in6</code> 指针</li>
<li>返回类型：<code>sockaddr*</code></li>
<li>作用：将IPv6地址结构 (<code>sockaddr_in6</code>) 转换为通用的地址结构 (<code>sockaddr</code>) 的指针。</li>
<li>使用场景：类似于上一个函数，但这个函数返回的是非常量指针，可能用于修改地址结构。</li>
</ul>
</li>
<li><strong><code>const struct sockaddr* sockets::sockaddr_cast(const struct sockaddr_in* addr)</code></strong>:<ul>
<li>参数类型：<code>sockaddr_in</code> 指针</li>
<li>返回类型：<code>const sockaddr*</code></li>
<li>作用：将IPv4地址结构 (<code>sockaddr_in</code>) 转换为通用的地址结构 (<code>sockaddr</code>) 的常量指针。</li>
<li>使用场景：类似于第一个函数，但这个函数针对IPv4地址结构。</li>
</ul>
</li>
<li><strong><code>const struct sockaddr_in* sockets::sockaddr_in_cast(const struct sockaddr* addr)</code></strong>:<ul>
<li>参数类型：<code>sockaddr</code> 指针</li>
<li>返回类型：<code>const sockaddr_in*</code></li>
<li>作用：将通用的地址结构 (<code>sockaddr</code>) 转换为IPv4地址结构 (<code>sockaddr_in</code>) 的常量指针。</li>
<li>使用场景：通常在需要获取 <code>sockaddr</code> 类型的指针指向 IPv4 地址结构的情况下使用。</li>
</ul>
</li>
<li><strong><code>const struct sockaddr_in6* sockets::sockaddr_in6_cast(const struct sockaddr* addr)</code></strong>:<ul>
<li>参数类型：<code>sockaddr</code> 指针</li>
<li>返回类型：<code>const sockaddr_in6*</code></li>
<li>作用：将通用的地址结构 (<code>sockaddr</code>) 转换为IPv6地址结构 (<code>sockaddr_in6</code>) 的常量指针。</li>
<li>使用场景：类似于第四个函数，但这个函数针对IPv6地址结构。</li>
</ul>
</li>
</ol>
<p>这些函数的主要目的是在不同类型的网络地址结构之间进行安全的类型转换，以便在网络编程中处理不同的地址类型。它们使用了 <code>implicit_cast</code>（隐式转换）来实现这些转换，确保了正确的指针类型。</p>
<h3 id="SocketsOps-h"><a href="#SocketsOps-h" class="headerlink" title="SocketsOps.h"></a>SocketsOps.h</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_NET_SOCKETSOPS_H</span><br><span class="line">#define MUDUO_NET_SOCKETSOPS_H</span><br><span class="line"></span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line">namespace sockets</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">///</span><br><span class="line">/// Creates a non-blocking socket file descriptor,</span><br><span class="line">/// abort if any error.</span><br><span class="line">int createNonblockingOrDie(sa_family_t family);</span><br><span class="line"></span><br><span class="line">int  connect(int sockfd, const struct sockaddr* addr);</span><br><span class="line">void bindOrDie(int sockfd, const struct sockaddr* addr);</span><br><span class="line">void listenOrDie(int sockfd);</span><br><span class="line">int  accept(int sockfd, struct sockaddr_in6* addr);</span><br><span class="line">ssize_t read(int sockfd, void *buf, size_t count);</span><br><span class="line">ssize_t readv(int sockfd, const struct iovec *iov, int iovcnt);</span><br><span class="line">ssize_t write(int sockfd, const void *buf, size_t count);</span><br><span class="line">void close(int sockfd);</span><br><span class="line">void shutdownWrite(int sockfd);</span><br><span class="line"></span><br><span class="line">void toIpPort(char* buf, size_t size,</span><br><span class="line">              const struct sockaddr* addr);</span><br><span class="line">void toIp(char* buf, size_t size,</span><br><span class="line">          const struct sockaddr* addr);</span><br><span class="line"></span><br><span class="line">void fromIpPort(const char* ip, uint16_t port,</span><br><span class="line">                struct sockaddr_in* addr);</span><br><span class="line">void fromIpPort(const char* ip, uint16_t port,</span><br><span class="line">                struct sockaddr_in6* addr);</span><br><span class="line"></span><br><span class="line">int getSocketError(int sockfd);</span><br><span class="line"></span><br><span class="line">const struct sockaddr* sockaddr_cast(const struct sockaddr_in* addr);</span><br><span class="line">const struct sockaddr* sockaddr_cast(const struct sockaddr_in6* addr);</span><br><span class="line">struct sockaddr* sockaddr_cast(struct sockaddr_in6* addr);</span><br><span class="line">const struct sockaddr_in* sockaddr_in_cast(const struct sockaddr* addr);</span><br><span class="line">const struct sockaddr_in6* sockaddr_in6_cast(const struct sockaddr* addr);</span><br><span class="line"></span><br><span class="line">struct sockaddr_in6 getLocalAddr(int sockfd);</span><br><span class="line">struct sockaddr_in6 getPeerAddr(int sockfd);</span><br><span class="line">bool isSelfConnect(int sockfd);</span><br><span class="line"></span><br><span class="line">&#125;  // namespace sockets</span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_NET_SOCKETSOPS_H</span><br></pre></td></tr></table></figure>

<h3 id="SocketsOps-cc"><a href="#SocketsOps-cc" class="headerlink" title="SocketsOps.cc"></a>SocketsOps.cc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line">int sockets::createNonblockingOrDie(sa_family_t family)//创建非阻塞套接字，失败就终止</span><br><span class="line">&#123;</span><br><span class="line">#if VALGRIND//VALGRIND可以检测内存泄漏和文件描述符</span><br><span class="line">  int sockfd = ::socket(family, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">  if (sockfd &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSFATAL &lt;&lt; &quot;sockets::createNonblockingOrDie&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setNonBlockAndCloseOnExec(sockfd);</span><br><span class="line">#else</span><br><span class="line">  int sockfd = ::socket(family, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, IPPROTO_TCP);</span><br><span class="line">  //IPPROTO_TCP 是一个常量，用于指定套接字选项或协议参数中的 TCP（Transmission Control Protocol）协议</span><br><span class="line">  if (sockfd &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSFATAL &lt;&lt; &quot;sockets::createNonblockingOrDie&quot;;//FATAL 终止</span><br><span class="line">  &#125;</span><br><span class="line">#endif</span><br><span class="line">  return sockfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sockets::bindOrDie(int sockfd, const struct sockaddr* addr)</span><br><span class="line">&#123;</span><br><span class="line">  int ret = ::bind(sockfd, addr, static_cast&lt;socklen_t&gt;(sizeof(struct sockaddr_in6)));</span><br><span class="line">  if (ret &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSFATAL &lt;&lt; &quot;sockets::bindOrDie&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sockets::listenOrDie(int sockfd)</span><br><span class="line">&#123;</span><br><span class="line">  int ret = ::listen(sockfd, SOMAXCONN);//SOMAXCONN 的值表示操作系统允许的监听队列的最大长度。这个值可能因操作系统而异，但通常是一个相对较大的数字。当连接请求超过这个队列长度时，客户端的连接请求可能会被拒绝。</span><br><span class="line">  if (ret &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSFATAL &lt;&lt; &quot;sockets::listenOrDie&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sockets::accept(int sockfd, struct sockaddr_in6* addr)</span><br><span class="line">&#123;</span><br><span class="line">  socklen_t addrlen = static_cast&lt;socklen_t&gt;(sizeof *addr);</span><br><span class="line">#if VALGRIND || defined (NO_ACCEPT4)</span><br><span class="line">  int connfd = ::accept(sockfd, sockaddr_cast(addr), &amp;addrlen);</span><br><span class="line">  setNonBlockAndCloseOnExec(connfd);</span><br><span class="line">#else</span><br><span class="line">  int connfd = ::accept4(sockfd, sockaddr_cast(addr),</span><br><span class="line">                         &amp;addrlen, SOCK_NONBLOCK | SOCK_CLOEXEC);</span><br><span class="line">#endif</span><br><span class="line">  if (connfd &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    int savedErrno = errno;</span><br><span class="line">    LOG_SYSERR &lt;&lt; &quot;Socket::accept&quot;;</span><br><span class="line">    switch (savedErrno)</span><br><span class="line">    &#123;</span><br><span class="line">      case EAGAIN:</span><br><span class="line">      case ECONNABORTED:</span><br><span class="line">      case EINTR:</span><br><span class="line">      case EPROTO: // ???</span><br><span class="line">      case EPERM:</span><br><span class="line">      case EMFILE: // per-process lmit of open file desctiptor ???</span><br><span class="line">        // expected errors</span><br><span class="line">        errno = savedErrno;//上面的都不是致命错误</span><br><span class="line">        break;</span><br><span class="line">      case EBADF:</span><br><span class="line">      case EFAULT:</span><br><span class="line">      case EINVAL:</span><br><span class="line">      case ENFILE:</span><br><span class="line">      case ENOBUFS:</span><br><span class="line">      case ENOMEM:</span><br><span class="line">      case ENOTSOCK:</span><br><span class="line">      case EOPNOTSUPP:</span><br><span class="line">        // unexpected errors</span><br><span class="line">        LOG_FATAL &lt;&lt; &quot;unexpected error of ::accept &quot; &lt;&lt; savedErrno;</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        LOG_FATAL &lt;&lt; &quot;unknown error of ::accept &quot; &lt;&lt; savedErrno;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return connfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sockets::connect(int sockfd, const struct sockaddr* addr)</span><br><span class="line">&#123;</span><br><span class="line">  return ::connect(sockfd, addr, static_cast&lt;socklen_t&gt;(sizeof(struct sockaddr_in6)));</span><br><span class="line">&#125;</span><br><span class="line">//read与readv不同之处在于</span><br><span class="line">ssize_t sockets::read(int sockfd, void *buf, size_t count)</span><br><span class="line">&#123;</span><br><span class="line">  return ::read(sockfd, buf, count);</span><br><span class="line">&#125;</span><br><span class="line">//readv与read不同之处在于，接受的数据可以填充到多个缓冲区中</span><br><span class="line">ssize_t sockets::readv(int sockfd, const struct iovec *iov, int iovcnt)</span><br><span class="line">&#123;</span><br><span class="line">  return ::readv(sockfd, iov, iovcnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ssize_t sockets::write(int sockfd, const void *buf, size_t count)//struct iovec 是一个结构体，用于描述一组分散的内存缓冲区</span><br><span class="line">&#123;</span><br><span class="line">  return ::write(sockfd, buf, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sockets::close(int sockfd)</span><br><span class="line">&#123;</span><br><span class="line">  if (::close(sockfd) &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSERR &lt;&lt; &quot;sockets::close&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//只关闭写的这一半</span><br><span class="line">void sockets::shutdownWrite(int sockfd)</span><br><span class="line">&#123;</span><br><span class="line">  if (::shutdown(sockfd, SHUT_WR) &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSERR &lt;&lt; &quot;sockets::shutdownWrite&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//将addr转换成IP与端口的形式保存在buf中</span><br><span class="line">void sockets::toIpPort(char* buf, size_t size,</span><br><span class="line">                       const struct sockaddr* addr)</span><br><span class="line">&#123;</span><br><span class="line">  if (addr-&gt;sa_family == AF_INET6)</span><br><span class="line">  &#123;</span><br><span class="line">    buf[0] = &#x27;[&#x27;;</span><br><span class="line">    toIp(buf+1, size-1, addr);</span><br><span class="line">    size_t end = ::strlen(buf);</span><br><span class="line">    const struct sockaddr_in6* addr6 = sockaddr_in6_cast(addr);</span><br><span class="line">    uint16_t port = sockets::networkToHost16(addr6-&gt;sin6_port);</span><br><span class="line">    assert(size &gt; end);</span><br><span class="line">    snprintf(buf+end, size-end, &quot;]:%u&quot;, port);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  toIp(buf, size, addr);</span><br><span class="line">  size_t end = ::strlen(buf);</span><br><span class="line">  const struct sockaddr_in* addr4 = sockaddr_in_cast(addr);</span><br><span class="line">  uint16_t port = sockets::networkToHost16(addr4-&gt;sin_port);</span><br><span class="line">  assert(size &gt; end);</span><br><span class="line">  snprintf(buf+end, size-end, &quot;:%u&quot;, port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sockets::toIp(char* buf, size_t size,</span><br><span class="line">                   const struct sockaddr* addr)</span><br><span class="line">&#123;</span><br><span class="line">  if (addr-&gt;sa_family == AF_INET)</span><br><span class="line">  &#123;</span><br><span class="line">    assert(size &gt;= INET_ADDRSTRLEN);</span><br><span class="line">    const struct sockaddr_in* addr4 = sockaddr_in_cast(addr);</span><br><span class="line">    ::inet_ntop(AF_INET, &amp;addr4-&gt;sin_addr, buf, static_cast&lt;socklen_t&gt;(size));</span><br><span class="line">  &#125;</span><br><span class="line">  else if (addr-&gt;sa_family == AF_INET6)</span><br><span class="line">  &#123;</span><br><span class="line">    assert(size &gt;= INET6_ADDRSTRLEN);</span><br><span class="line">    const struct sockaddr_in6* addr6 = sockaddr_in6_cast(addr);</span><br><span class="line">    ::inet_ntop(AF_INET6, &amp;addr6-&gt;sin6_addr, buf, static_cast&lt;socklen_t&gt;(size));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sockets::fromIpPort(const char* ip, uint16_t port,</span><br><span class="line">                         struct sockaddr_in* addr)</span><br><span class="line">&#123;</span><br><span class="line">  addr-&gt;sin_family = AF_INET;</span><br><span class="line">  addr-&gt;sin_port = hostToNetwork16(port);</span><br><span class="line">  if (::inet_pton(AF_INET, ip, &amp;addr-&gt;sin_addr) &lt;= 0)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSERR &lt;&lt; &quot;sockets::fromIpPort&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sockets::fromIpPort(const char* ip, uint16_t port,</span><br><span class="line">                         struct sockaddr_in6* addr)//从IP和port构造一个网际协议地址addr</span><br><span class="line">&#123;</span><br><span class="line">  addr-&gt;sin6_family = AF_INET6;</span><br><span class="line">  addr-&gt;sin6_port = hostToNetwork16(port);</span><br><span class="line">  if (::inet_pton(AF_INET6, ip, &amp;addr-&gt;sin6_addr) &lt;= 0)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSERR &lt;&lt; &quot;sockets::fromIpPort&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sockets::getSocketError(int sockfd)</span><br><span class="line">&#123;</span><br><span class="line">  int optval;</span><br><span class="line">  socklen_t optlen = static_cast&lt;socklen_t&gt;(sizeof optval);</span><br><span class="line"></span><br><span class="line">  if (::getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &amp;optval, &amp;optlen) &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    return errno;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    return optval;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct sockaddr_in6 sockets::getLocalAddr(int sockfd)</span><br><span class="line">&#123;</span><br><span class="line">  struct sockaddr_in6 localaddr;</span><br><span class="line">  memZero(&amp;localaddr, sizeof localaddr);</span><br><span class="line">  socklen_t addrlen = static_cast&lt;socklen_t&gt;(sizeof localaddr);</span><br><span class="line">  if (::getsockname(sockfd, sockaddr_cast(&amp;localaddr), &amp;addrlen) &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSERR &lt;&lt; &quot;sockets::getLocalAddr&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  return localaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct sockaddr_in6 sockets::getPeerAddr(int sockfd)</span><br><span class="line">&#123;</span><br><span class="line">  struct sockaddr_in6 peeraddr;</span><br><span class="line">  memZero(&amp;peeraddr, sizeof peeraddr);</span><br><span class="line">  socklen_t addrlen = static_cast&lt;socklen_t&gt;(sizeof peeraddr);</span><br><span class="line">  if (::getpeername(sockfd, sockaddr_cast(&amp;peeraddr), &amp;addrlen) &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSERR &lt;&lt; &quot;sockets::getPeerAddr&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  return peeraddr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Socket-h-x2F-Socket-cc-Socket类"><a href="#Socket-h-x2F-Socket-cc-Socket类" class="headerlink" title="Socket.h&#x2F;Socket.cc ( Socket类)"></a>Socket.h&#x2F;Socket.cc ( Socket类)</h2><ul>
<li>用RAIl方法封装socket file descriptor</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Socket::~Socket()</span><br><span class="line">&#123;</span><br><span class="line">  sockets::close(sockfd_);</span><br><span class="line">&#125;</span><br><span class="line">void Socket::bindAddress(const InetAddress&amp; addr)</span><br><span class="line">&#123;</span><br><span class="line">  sockets::bindOrDie(sockfd_, addr.getSockAddr());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Socket::listen()</span><br><span class="line">&#123;</span><br><span class="line">  sockets::listenOrDie(sockfd_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Socket::accept(InetAddress* peeraddr)</span><br><span class="line">&#123;</span><br><span class="line">  struct sockaddr_in6 addr;</span><br><span class="line">  memZero(&amp;addr, sizeof addr);</span><br><span class="line">  int connfd = sockets::accept(sockfd_, &amp;addr);</span><br><span class="line">  if (connfd &gt;= 0)</span><br><span class="line">  &#123;</span><br><span class="line">    peeraddr-&gt;setSockAddrInet6(addr);</span><br><span class="line">  &#125;</span><br><span class="line">  return connfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Socket::shutdownWrite()</span><br><span class="line">&#123;</span><br><span class="line">  sockets::shutdownWrite(sockfd_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="InetAddress-h-x2F-InetAddress-cc-InetAddress类）"><a href="#InetAddress-h-x2F-InetAddress-cc-InetAddress类）" class="headerlink" title="InetAddress.h&#x2F;InetAddress.cc (InetAddress类）"></a>InetAddress.h&#x2F;InetAddress.cc (InetAddress类）</h2><ul>
<li>网际地址sockaddr_in封装,就不用关注底层</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">InetAddress::InetAddress(uint16_t portArg, bool loopbackOnly, bool ipv6)</span><br><span class="line">&#123;</span><br><span class="line">  static_assert(offsetof(InetAddress, addr6_) == 0, &quot;addr6_ offset 0&quot;);</span><br><span class="line">  static_assert(offsetof(InetAddress, addr_) == 0, &quot;addr_ offset 0&quot;);</span><br><span class="line">  if (ipv6)</span><br><span class="line">  &#123;</span><br><span class="line">    memZero(&amp;addr6_, sizeof addr6_);</span><br><span class="line">    addr6_.sin6_family = AF_INET6;</span><br><span class="line">    in6_addr ip = loopbackOnly ? in6addr_loopback : in6addr_any;</span><br><span class="line">    addr6_.sin6_addr = ip;</span><br><span class="line">    addr6_.sin6_port = sockets::hostToNetwork16(portArg);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    memZero(&amp;addr_, sizeof addr_);</span><br><span class="line">    addr_.sin_family = AF_INET;</span><br><span class="line">    in_addr_t ip = loopbackOnly ? kInaddrLoopback : kInaddrAny;</span><br><span class="line">    addr_.sin_addr.s_addr = sockets::hostToNetwork32(ip);</span><br><span class="line">    addr_.sin_port = sockets::hostToNetwork16(portArg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InetAddress::InetAddress(StringArg ip, uint16_t portArg, bool ipv6)</span><br><span class="line">&#123;</span><br><span class="line">  if (ipv6 || strchr(ip.c_str(), &#x27;:&#x27;))</span><br><span class="line">  &#123;</span><br><span class="line">    memZero(&amp;addr6_, sizeof addr6_);</span><br><span class="line">    sockets::fromIpPort(ip.c_str(), portArg, &amp;addr6_);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    memZero(&amp;addr_, sizeof addr_);</span><br><span class="line">    sockets::fromIpPort(ip.c_str(), portArg, &amp;addr_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string InetAddress::toIpPort() const</span><br><span class="line">&#123;</span><br><span class="line">  char buf[64] = &quot;&quot;;</span><br><span class="line">  sockets::toIpPort(buf, sizeof buf, getSockAddr());</span><br><span class="line">  return buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string InetAddress::toIp() const</span><br><span class="line">&#123;</span><br><span class="line">  char buf[64] = &quot;&quot;;</span><br><span class="line">  sockets::toIp(buf, sizeof buf, getSockAddr());</span><br><span class="line">  return buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint32_t InetAddress::ipv4NetEndian() const</span><br><span class="line">&#123;</span><br><span class="line">  assert(family() == AF_INET);</span><br><span class="line">  return addr_.sin_addr.s_addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint16_t InetAddress::port() const</span><br><span class="line">&#123;</span><br><span class="line">  return sockets::networkToHost16(portNetEndian());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个函数似乎是C++中用于创建网络地址（InetAddress）对象的构造函数。它们的功能是根据提供的参数（IP地址、端口等）创建网络地址对象，并根据需要支持IPv6和IPv4。</p>
<p>下面是这两个函数的功能和区别的解释：</p>
<h3 id="构造函数-1-InetAddress-InetAddress-uint16-t-portArg-bool-loopbackOnly-bool-ipv6"><a href="#构造函数-1-InetAddress-InetAddress-uint16-t-portArg-bool-loopbackOnly-bool-ipv6" class="headerlink" title="构造函数 1: InetAddress::InetAddress(uint16_t portArg, bool loopbackOnly, bool ipv6)"></a>构造函数 1: InetAddress::InetAddress(uint16_t portArg, bool loopbackOnly, bool ipv6)</h3><p>这个构造函数用于创建一个网络地址对象，参数包括：</p>
<ul>
<li><code>portArg</code>：端口号。</li>
<li><code>loopbackOnly</code>：一个布尔值，指示是否只能在回环地址上监听。</li>
<li><code>ipv6</code>：一个布尔值，指示是否使用IPv6。</li>
</ul>
<p>函数的功能如下：</p>
<ol>
<li>如果 <code>ipv6</code> 为 <code>true</code>，则会初始化IPv6地址结构 <code>addr6_</code>，并根据 <code>loopbackOnly</code> 的值设置IP地址为回环地址或任意地址，然后设置端口号。</li>
<li>如果 <code>ipv6</code> 为 <code>false</code>，则会初始化IPv4地址结构 <code>addr_</code>，并根据 <code>loopbackOnly</code> 的值设置IP地址为回环地址或任意地址，然后设置端口号。</li>
</ol>
<h3 id="构造函数-2-InetAddress-InetAddress-StringArg-ip-uint16-t-portArg-bool-ipv6"><a href="#构造函数-2-InetAddress-InetAddress-StringArg-ip-uint16-t-portArg-bool-ipv6" class="headerlink" title="构造函数 2: InetAddress::InetAddress(StringArg ip, uint16_t portArg, bool ipv6)"></a>构造函数 2: InetAddress::InetAddress(StringArg ip, uint16_t portArg, bool ipv6)</h3><p>这个构造函数也用于创建一个网络地址对象，参数包括：</p>
<ul>
<li><code>ip</code>：一个字符串类型的IP地址。</li>
<li><code>portArg</code>：端口号。</li>
<li><code>ipv6</code>：一个布尔值，指示是否使用IPv6。</li>
</ul>
<p>函数的功能如下：</p>
<ol>
<li>如果 <code>ipv6</code> 为 <code>true</code> 或者 <code>ip</code> 中包含 <code>:</code>，则会初始化IPv6地址结构 <code>addr6_</code>，并通过调用 <code>sockets::fromIpPort</code> 函数从提供的IP地址和端口号解析填充 <code>addr6_</code>。</li>
<li>如果 <code>ipv6</code> 为 <code>false</code> 且 <code>ip</code> 中不包含 <code>:</code>，则会初始化IPv4地址结构 <code>addr_</code>，并通过调用 <code>sockets::fromIpPort</code> 函数从提供的IP地址和端口号解析填充 <code>addr_</code>。</li>
</ol>
<p>总之，这两个构造函数都用于创建网络地址对象，根据提供的参数不同，可以支持IPv6和IPv4，并根据需要设置端口号和IP地址。区别在于第一个构造函数的参数直接指定了是否使用回环地址，而第二个构造函数根据提供的IP地址字符串判断是否使用IPv6。</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">bool InetAddress::resolve(StringArg hostname, InetAddress* out)</span><br><span class="line">&#123;</span><br><span class="line">  assert(out != NULL);</span><br><span class="line">  struct hostent hent;</span><br><span class="line">  struct hostent* he = NULL;</span><br><span class="line">  int herrno = 0;</span><br><span class="line">  memZero(&amp;hent, sizeof(hent));</span><br><span class="line"></span><br><span class="line">  int ret = gethostbyname_r(hostname.c_str(), &amp;hent, t_resolveBuffer, sizeof t_resolveBuffer, &amp;he, &amp;herrno);</span><br><span class="line">  if (ret == 0 &amp;&amp; he != NULL)</span><br><span class="line">  &#123;</span><br><span class="line">    assert(he-&gt;h_addrtype == AF_INET &amp;&amp; he-&gt;h_length == sizeof(uint32_t));</span><br><span class="line">    out-&gt;addr_.sin_addr = *reinterpret_cast&lt;struct in_addr*&gt;(he-&gt;h_addr);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    if (ret)</span><br><span class="line">    &#123;</span><br><span class="line">      LOG_SYSERR &lt;&lt; &quot;InetAddress::resolve&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数是用于将主机名（hostname）解析为 IPv4 地址（InetAddress 对象）的功能。IPv4 地址结构在网络编程中用于表示 IP 地址。</p>
<p>以下是这个函数的作用：</p>
<ol>
<li>接收一个主机名（hostname）作为输入参数，以及一个指向 InetAddress 对象的指针 <code>out</code>，用于存储解析后的结果。</li>
<li>使用 <code>gethostbyname_r</code> 函数来解析主机名。该函数是线程安全的，它接受主机名、用于存储结果的结构体 <code>hent</code>、缓冲区 <code>t_resolveBuffer</code> 以及其他参数，然后尝试解析主机名并将结果存储在 <code>hent</code> 中。</li>
<li>如果解析成功（<code>ret</code> 等于 0，并且 <code>he</code> 非空），则验证返回的结果确实是 IPv4 地址类型，并且地址长度是 <code>sizeof(uint32_t)</code>。</li>
<li>将解析到的 IPv4 地址复制到 <code>out</code> 的 <code>addr_</code> 成员中，然后返回 <code>true</code> 表示解析成功。</li>
<li>如果解析失败（<code>ret</code> 不等于 0，或者 <code>he</code> 为空），则根据情况输出错误日志，然后返回 <code>false</code> 表示解析失败。</li>
</ol>
<p>总之，这个函数是用于将主机名解析为 IPv4 地址的工具函数，如果解析成功，会将解析结果存储在 <code>out</code> 参数中，并返回 <code>true</code>，否则返回 <code>false</code>。</p>
<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/net/InetAddress.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line"></span><br><span class="line">//#define BOOST_TEST_MODULE InetAddressTest</span><br><span class="line">#define BOOST_TEST_MAIN</span><br><span class="line">#define BOOST_TEST_DYN_LINK</span><br><span class="line">#include &lt;boost/test/unit_test.hpp&gt;</span><br><span class="line"></span><br><span class="line">using muduo::string;</span><br><span class="line">using muduo::net::InetAddress;</span><br><span class="line"></span><br><span class="line">BOOST_AUTO_TEST_CASE(testInetAddress)</span><br><span class="line">&#123;</span><br><span class="line">  InetAddress addr0(1234);</span><br><span class="line">  BOOST_CHECK_EQUAL(addr0.toIp(), string(&quot;0.0.0.0&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(addr0.toIpPort(), string(&quot;0.0.0.0:1234&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(addr0.port(), 1234);</span><br><span class="line"></span><br><span class="line">  InetAddress addr1(4321, true);</span><br><span class="line">  BOOST_CHECK_EQUAL(addr1.toIp(), string(&quot;127.0.0.1&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(addr1.toIpPort(), string(&quot;127.0.0.1:4321&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(addr1.port(), 4321);</span><br><span class="line"></span><br><span class="line">  InetAddress addr2(&quot;1.2.3.4&quot;, 8888);</span><br><span class="line">  BOOST_CHECK_EQUAL(addr2.toIp(), string(&quot;1.2.3.4&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(addr2.toIpPort(), string(&quot;1.2.3.4:8888&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(addr2.port(), 8888);</span><br><span class="line"></span><br><span class="line">  InetAddress addr3(&quot;255.254.253.252&quot;, 65535);</span><br><span class="line">  BOOST_CHECK_EQUAL(addr3.toIp(), string(&quot;255.254.253.252&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(addr3.toIpPort(), string(&quot;255.254.253.252:65535&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(addr3.port(), 65535);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOST_AUTO_TEST_CASE(testInet6Address)</span><br><span class="line">&#123;</span><br><span class="line">  InetAddress addr0(1234, false, true);</span><br><span class="line">  BOOST_CHECK_EQUAL(addr0.toIp(), string(&quot;::&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(addr0.toIpPort(), string(&quot;[::]:1234&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(addr0.port(), 1234);</span><br><span class="line"></span><br><span class="line">  InetAddress addr1(1234, true, true);</span><br><span class="line">  BOOST_CHECK_EQUAL(addr1.toIp(), string(&quot;::1&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(addr1.toIpPort(), string(&quot;[::1]:1234&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(addr1.port(), 1234);</span><br><span class="line"></span><br><span class="line">  InetAddress addr2(&quot;2001:db8::1&quot;, 8888, true);</span><br><span class="line">  BOOST_CHECK_EQUAL(addr2.toIp(), string(&quot;2001:db8::1&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(addr2.toIpPort(), string(&quot;[2001:db8::1]:8888&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(addr2.port(), 8888);</span><br><span class="line"></span><br><span class="line">  InetAddress addr3(&quot;fe80::1234:abcd:1&quot;, 8888);</span><br><span class="line">  BOOST_CHECK_EQUAL(addr3.toIp(), string(&quot;fe80::1234:abcd:1&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(addr3.toIpPort(), string(&quot;[fe80::1234:abcd:1]:8888&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(addr3.port(), 8888);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOST_AUTO_TEST_CASE(testInetAddressResolve)</span><br><span class="line">&#123;</span><br><span class="line">  InetAddress addr(80);</span><br><span class="line">  if (InetAddress::resolve(&quot;google.com&quot;, &amp;addr))</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_INFO &lt;&lt; &quot;google.com resolved to &quot; &lt;&lt; addr.toIpPort();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_ERROR &lt;&lt; &quot;Unable to resolve google.com&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%883%EF%BC%89/image-20230814161825526.png" alt="image-20230814161825526"></p>
<img src="/2023/08/13/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%883%EF%BC%89/image-20230814161825526.png" class title="This is an test image">

<h1 id="Acceptor"><a href="#Acceptor" class="headerlink" title="Acceptor"></a>Acceptor</h1><p>Acceptor用于accept(2)接受TCP连接<br>Acceptor的数据成员包括Socket、Channel,Acceptor的socket是listening socket ( serversocket)。Channel用于观察此socket的readable事件，并回调Accptor:handleRead()，后者调用accept(2)来接受新连接，并回调用户callback.</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%883%EF%BC%89/image-20230814200106610.png" alt="image-20230814200106610"></p>
<img src="/2023/08/13/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%883%EF%BC%89/image-20230814200106610.png" class title="This is an test image">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_NET_ACCEPTOR_H</span><br><span class="line">#define MUDUO_NET_ACCEPTOR_H</span><br><span class="line"></span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/net/Channel.h&quot;</span><br><span class="line">#include &quot;muduo/net/Socket.h&quot;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">class EventLoop;</span><br><span class="line">class InetAddress;</span><br><span class="line"></span><br><span class="line">///</span><br><span class="line">/// Acceptor of incoming TCP connections.</span><br><span class="line">///</span><br><span class="line">class Acceptor : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  typedef std::function&lt;void (int sockfd, const InetAddress&amp;)&gt; NewConnectionCallback;</span><br><span class="line"></span><br><span class="line">  Acceptor(EventLoop* loop, const InetAddress&amp; listenAddr, bool reuseport);</span><br><span class="line">  ~Acceptor();</span><br><span class="line"></span><br><span class="line">  void setNewConnectionCallback(const NewConnectionCallback&amp; cb)</span><br><span class="line">  &#123; newConnectionCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line">  void listen();</span><br><span class="line"></span><br><span class="line">  bool listening() const &#123; return listening_; &#125;</span><br><span class="line"></span><br><span class="line">  // Deprecated, use the correct spelling one above.</span><br><span class="line">  // Leave the wrong spelling here in case one needs to grep it for error messages.</span><br><span class="line">  // bool listenning() const &#123; return listening(); &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  void handleRead();</span><br><span class="line"></span><br><span class="line">  EventLoop* loop_;</span><br><span class="line">  Socket acceptSocket_;</span><br><span class="line">  Channel acceptChannel_;</span><br><span class="line">  NewConnectionCallback newConnectionCallback_;</span><br><span class="line">  bool listening_;</span><br><span class="line">  int idleFd_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_NET_ACCEPTOR_H</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;muduo/net/Acceptor.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line">#include &quot;muduo/net/EventLoop.h&quot;</span><br><span class="line">#include &quot;muduo/net/InetAddress.h&quot;</span><br><span class="line">#include &quot;muduo/net/SocketsOps.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">//#include &lt;sys/types.h&gt;</span><br><span class="line">//#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">Acceptor::Acceptor(EventLoop* loop, const InetAddress&amp; listenAddr, bool reuseport)</span><br><span class="line">  : loop_(loop),</span><br><span class="line">    acceptSocket_(sockets::createNonblockingOrDie(listenAddr.family())),</span><br><span class="line">    acceptChannel_(loop, acceptSocket_.fd()),</span><br><span class="line">    listening_(false),</span><br><span class="line">    idleFd_(::open(&quot;/dev/null&quot;, O_RDONLY | O_CLOEXEC))</span><br><span class="line">&#123;</span><br><span class="line">  assert(idleFd_ &gt;= 0);</span><br><span class="line">  acceptSocket_.setReuseAddr(true);</span><br><span class="line">  acceptSocket_.setReusePort(reuseport);</span><br><span class="line">  acceptSocket_.bindAddress(listenAddr);</span><br><span class="line">  acceptChannel_.setReadCallback(</span><br><span class="line">      std::bind(&amp;Acceptor::handleRead, this));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Acceptor::~Acceptor()</span><br><span class="line">&#123;</span><br><span class="line">  acceptChannel_.disableAll();</span><br><span class="line">  acceptChannel_.remove();</span><br><span class="line">  ::close(idleFd_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Acceptor::listen()</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  listening_ = true;</span><br><span class="line">  acceptSocket_.listen();</span><br><span class="line">  acceptChannel_.enableReading();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Acceptor::handleRead()</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  InetAddress peerAddr;</span><br><span class="line">  //FIXME loop until no more</span><br><span class="line">  int connfd = acceptSocket_.accept(&amp;peerAddr);</span><br><span class="line">  if (connfd &gt;= 0)</span><br><span class="line">  &#123;</span><br><span class="line">    // string hostport = peerAddr.toIpPort();</span><br><span class="line">    // LOG_TRACE &lt;&lt; &quot;Accepts of &quot; &lt;&lt; hostport;</span><br><span class="line">    if (newConnectionCallback_)</span><br><span class="line">    &#123;</span><br><span class="line">      newConnectionCallback_(connfd, peerAddr);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      sockets::close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSERR &lt;&lt; &quot;in Acceptor::handleRead&quot;;</span><br><span class="line">    // Read the section named &quot;The special problem of</span><br><span class="line">    // accept()ing when you can&#x27;t&quot; in libev&#x27;s doc.</span><br><span class="line">    // By Marc Lehmann, author of libev.</span><br><span class="line">    if (errno == EMFILE)</span><br><span class="line">    &#123;</span><br><span class="line">      ::close(idleFd_);</span><br><span class="line">      idleFd_ = ::accept(acceptSocket_.fd(), NULL, NULL);</span><br><span class="line">      ::close(idleFd_);</span><br><span class="line">      idleFd_ = ::open(&quot;/dev/null&quot;, O_RDONLY | O_CLOEXEC);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>server:<br>    1. socket()	创建socket</p>
<ol start="2">
<li><p>bind()	绑定服务器地址结构</p>
</li>
<li><p>listen()	设置监听上限</p>
</li>
<li><p>accept()	阻塞监听客户端连接</p>
</li>
<li><p>read(fd)	读socket获取客户端数据</p>
</li>
<li><p>小–大写	toupper()</p>
</li>
<li><p>write(fd)，567回调函数</p>
</li>
<li><p>close();</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/10/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%882%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/10/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%882%EF%BC%89/" class="post-title-link" itemprop="url">muduo-网络库（2）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-10 10:48:35" itemprop="dateCreated datePublished" datetime="2023-08-10T10:48:35+08:00">2023-08-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-13 17:36:31" itemprop="dateModified" datetime="2023-08-13T17:36:31+08:00">2023-08-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="定时器函数选择"><a href="#定时器函数选择" class="headerlink" title="定时器函数选择"></a>定时器函数选择</h1><p>定时函数，用于让程序等待一段时间或安排计划任务:</p>
<p>sleep</p>
<p>alarm</p>
<p>usleep</p>
<p>nanosleep<br>clock_nanosleep</p>
<p>getitimer &#x2F; setitimer</p>
<p>timer_create &#x2F; timer_settime &#x2F; timer_gettime &#x2F; timer_delete</p>
<p>timerfd_create &#x2F; timerfd_gettime &#x2F; timerfd_settime</p>
<h2 id="timerfd-入选的原因"><a href="#timerfd-入选的原因" class="headerlink" title="timerfd_入选的原因:"></a>timerfd_入选的原因:</h2><ul>
<li>sleep &#x2F; alarm &#x2F; usleep在实现时有可能用了信号SIGALRM，在多线程程序中处理信号是个相当麻烦的事情，应当尽量避免</li>
<li>nanosleep和 clock_nanosleep是线程安全的，但是在非阻塞网络编程中，绝对不能用让线程挂起的方式来等待一段时间，程序会失去响应。正确的做法是注册一个时间回调函数。</li>
<li>getitimer和l timer_create 也是用信号来deliver 超时，在多线程程序中也会有麻烦。</li>
<li>timer_create 可以指定信号的接收方是进程还是线程，算是一个进步，不过在信号处理函数(signal handler)能做的事情实在很受限。</li>
<li>timerfd_create <strong>把时间变成了一个文件描述符</strong>，该“文件”在定时器超时的那一刻变得可读，这样就能很方便地融入到select&#x2F;poll框架中，用统一的方式来处理IO事件和超时事件，这也正是 Reactor模式的长处。</li>
</ul>
<h3 id="函数签名："><a href="#函数签名：" class="headerlink" title="函数签名："></a>函数签名：</h3><p><code>int signalfd(int fd,const sigset_t *mask, int flags);</code></p>
<h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><p><code>fd</code>：一个整数，表示文件描述符。通常设置为 <code>-1</code>，这将导致内核创建一个新的文件描述符。</p>
</li>
<li><p><code>mask</code>：一个指向 <code>sigset_t</code> 类型的指针，表示要监视的信号集。通过将感兴趣的信号添加到这个集合中，您可以选择性地监控特定信号。</p>
</li>
<li><p>&#96;&#96;&#96;<br>flags</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ：整数标志，可以使用以下标志进行按位或运算：</span><br><span class="line"></span><br><span class="line">  - `SFD_CLOEXEC`：在执行 `exec` 系统调用时关闭文件描述符。</span><br><span class="line">  - `SFD_NONBLOCK`：以非阻塞模式打开文件描述符。</span><br><span class="line"></span><br><span class="line">### 返回值：</span><br><span class="line"></span><br><span class="line">- 如果函数调用成功，它将返回一个非负整数，表示新创建的文件描述符。如果失败，它将返回 `-1` 并设置 `errno` 来指示错误类型。</span><br><span class="line"></span><br><span class="line">### 示例用法：</span><br><span class="line"></span><br><span class="line">下面是一个详细的示例，演示了如何使用 `signalfd` 函数来监视 `SIGINT` 信号的到来：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>c复制代码#include &lt;stdio.h&gt;</p>
</li>
</ul>
<p>#include &lt;stdlib.h&gt;<br>#include &lt;signal.h&gt;<br>#include &lt;sys&#x2F;signalfd.h&gt;<br>#include &lt;unistd.h&gt;</p>
<p>int main() {<br>    sigset_t mask;<br>    sigemptyset(&amp;mask);<br>    sigaddset(&amp;mask, SIGINT);  &#x2F;&#x2F; 监控 SIGINT 信号</p>
<pre><code>int sfd = signalfd(-1, &amp;mask, 0);  // 创建 signalfd
if (sfd == -1) &#123;
    perror(&quot;signalfd&quot;);
    exit(EXIT_FAILURE);
&#125;

// 使用 select 或 epoll 监视 sfd

printf(&quot;Waiting for SIGINT...\n&quot;);

// 在此处执行 I/O 多路复用等待

// 当 SIGINT 信号到达时，处理逻辑会在此处触发

close(sfd);
return 0;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在此示例中，我们创建了一个新的 signalfd 文件描述符以监视 `SIGINT` 信号的到来。然后，您可以使用适当的多路复用机制（如 `select`、`poll`、`epoll` 等）来监视该文件描述符，并在信号到达时触发相应的处理逻辑。</span><br><span class="line"></span><br><span class="line">这个方法可以起到timerfd_create同样作用</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">下面是 `timerfd_create`、`timerfd_gettime` 和 `timerfd_settime` 函数的原型和简要说明。这些函数是用于创建和操作定时器事件的 Linux 系统调用。</span><br><span class="line"></span><br><span class="line">1. **timerfd_create**：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#include &lt;sys&#x2F;timerfd.h&gt;</p>
<p>int timerfd_create(int clockid, int flags);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **参数**：</span><br><span class="line">  - `clockid`：用于指定定时器的时钟类型，可以是 `CLOCK_REALTIME` 或 `CLOCK_MONOTONIC`。一般使用 `CLOCK_MONOTONIC` 以避免受系统时间的影响。</span><br><span class="line">  - `flags`：额外的选项标志，通常设置为 0。</span><br><span class="line">- **返回值**：</span><br><span class="line">  - 成功：返回一个新的文件描述符，用于访问创建的定时器。</span><br><span class="line">  - 失败：返回 -1，并设置 `errno` 表示错误原因。</span><br><span class="line"></span><br><span class="line">1. **timerfd_gettime**：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#include &lt;sys&#x2F;timerfd.h&gt;</p>
<p>int timerfd_gettime(int fd, struct itimerspec *curr_value);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **参数**：</span><br><span class="line">  - `fd`：定时器的文件描述符。</span><br><span class="line">  - `curr_value`：指向 `struct itimerspec` 的指针，用于存储当前定时器的配置信息。</span><br><span class="line">- **返回值**：</span><br><span class="line">  - 成功：返回 0，`curr_value` 结构体被填充为当前定时器的配置信息。</span><br><span class="line">  - 失败：返回 -1，并设置 `errno` 表示错误原因。</span><br><span class="line"></span><br><span class="line">1. **timerfd_settime**：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#include &lt;sys&#x2F;timerfd.h&gt;</p>
<p>int timerfd_settime(int fd, int flags, const struct itimerspec *new_value, struct itimerspec *old_value);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **参数**：</span><br><span class="line">  - `fd`：定时器的文件描述符。</span><br><span class="line">  - `flags`：设置定时器的选项标志，一般设置为 0。</span><br><span class="line">  - `new_value`：指向 `struct itimerspec` 的指针，用于设置新的定时器配置。</span><br><span class="line">  - `old_value`：指向 `struct itimerspec` 的指针，用于存储之前的定时器配置（如果不需要，可以传递 NULL）。</span><br><span class="line">- **返回值**：</span><br><span class="line">  - 成功：返回 0，`old_value` 结构体被填充为之前的定时器配置。</span><br><span class="line">  - 失败：返回 -1，并设置 `errno` 表示错误原因。</span><br><span class="line"></span><br><span class="line">这些函数主要用于创建定时器、获取定时器配置和修改定时器配置，通常用于实现高精度的定时操作，例如事件循环中的定时器管理。请注意，这里的结构体 `struct itimerspec` 包含了定时器的详细配置信息。</span><br><span class="line"></span><br><span class="line">## 示例</span><br><span class="line"></span><br><span class="line">![image-20230810112723867](muduo-网络库（2）/image-20230810112723867.png)</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20230810112723867.png This is an test image %&#125;</span><br><span class="line"></span><br><span class="line">因为howlong.it_interval=0，所以间隔时间为0，这是一次性的。enableReading将通道注册到poll或epoll当中。</span><br><span class="line"></span><br><span class="line">loop.loop(),处于事件循环状态，一旦可读事件产生，也就是定时器超时，1秒，EventLoop调用poll（`poller_-&gt;**poll**(kPollTimeMs, &amp;activeChannels_);`）返回activeChannels，再调用handleEvent（`currentActiveChannel_-&gt;**handleEvent**(pollReturnTime_);`）。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;该函数可以跨线程调用<br>void EventLoop::quit()<br>{<br>  quit_ &#x3D; true;&#x2F;&#x2F;多个线程都有quit_变量，因为它是bool类型，因为在Linux下bool是原子类型<br>  &#x2F;&#x2F; There is a chance that loop() just executes while(!quit_) and exits,<br>  &#x2F;&#x2F; then EventLoop destructs, then we are accessing an invalid object.<br>  &#x2F;&#x2F; Can be fixed using mutex_ in both places.<br>  if (!isInLoopThread())<br>  {<br>    wakeup();&#x2F;&#x2F;如果不是再当前线程，还需要唤醒，因为线程本身在loop循环阻塞poll<br>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 定时器</span><br><span class="line"></span><br><span class="line">muduo的定时器由三个类实现，Timerld、Timer、TimerQueue,用户只能看到第一个类，其它两个都是内部实现细节</span><br><span class="line"></span><br><span class="line">TimerQueue的接口很简单，只有两个函数addTimer和cancel</span><br><span class="line"></span><br><span class="line">EventLoop</span><br><span class="line"></span><br><span class="line">- ​	runAt								在某个时刻运行定时器</span><br><span class="line">- ​	runAfter							过一段时间运行定时器</span><br><span class="line">- ​	runEvery							每隔一段时间运行定时器</span><br><span class="line">- ​	cancel								取消定时器</span><br><span class="line"></span><br><span class="line">TimerQueue数据结构的选择，能快速根据当前时间找到已到期的定时器，也要高效的添加和删除Timer，因而可以用二叉搜索树，用</span><br><span class="line"></span><br><span class="line">map或者set</span><br><span class="line"></span><br><span class="line">- ​	`typedef std:pair&lt;Timestamp, Timer*&gt; Entry;`</span><br><span class="line"></span><br><span class="line">- ​	`typedef std:set&lt;Entry&gt; TimerList;``std::set` 是 C++ 标准库中的一个关联容器，它会对存储的元素自动排序，以保持有序状态</span><br><span class="line"></span><br><span class="line">## 时序图</span><br><span class="line"></span><br><span class="line">![image-20230811105332742](muduo-网络库（2）/image-20230811105332742.png)</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20230811105332742.png This is an test image %&#125;</span><br><span class="line"></span><br><span class="line">## EventLoop.cc部分调用</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>std::unique_ptr<TimerQueue> timerQueue_;<br>TimerId EventLoop::runAt(Timestamp time, TimerCallback cb)&#x2F;&#x2F;某个时刻调用，一次性定时器<br>{<br>  return timerQueue_-&gt;addTimer(std::move(cb), time, 0.0);<br>}</TimerQueue></p>
<p>TimerId EventLoop::runAfter(double delay, TimerCallback cb)&#x2F;&#x2F;延迟一会调用，一次性定时器<br>{<br>  Timestamp time(addTime(Timestamp::now(), delay));<br>  return runAt(time, std::move(cb));<br>}</p>
<p>TimerId EventLoop::runEvery(double interval, TimerCallback cb)&#x2F;&#x2F;间隔性定时器，interval大于0，repeat就是true，就是重复的定时器，也就可以Timer::restart<br>{<br>  Timestamp time(addTime(Timestamp::now(), interval));<br>  return timerQueue_-&gt;addTimer(std::move(cb), time, interval);<br>}</p>
<p>void EventLoop::cancel(TimerId timerId)<br>{<br>  return timerQueue_-&gt;cancel(timerId);<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## TimerId.h</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#ifndef MUDUO_NET_TIMERID_H<br>#define MUDUO_NET_TIMERID_H</p>
<p>#include “muduo&#x2F;base&#x2F;copyable.h”</p>
<p>namespace muduo<br>{<br>namespace net<br>{</p>
<p>class Timer;</p>
<p>&#x2F;&#x2F;&#x2F;<br>&#x2F;&#x2F;&#x2F; An opaque identifier, for canceling Timer.<br>&#x2F;&#x2F;&#x2F;<br>class TimerId : public muduo::copyable<br>{<br> public:<br>  TimerId()<br>    : timer_(NULL),<br>      sequence_(0)<br>  {<br>  }</p>
<p>  TimerId(Timer* timer, int64_t seq)<br>    : timer_(timer),<br>      sequence_(seq)<br>  {<br>  }</p>
<p>  &#x2F;&#x2F; default copy-ctor, dtor and assignment are okay</p>
<p>  friend class TimerQueue;</p>
<p> private:<br>  Timer* timer_;&#x2F;&#x2F;定时器地址<br>  int64_t sequence_;&#x2F;&#x2F;定时器序号<br>};</p>
<p>}  &#x2F;&#x2F; namespace net<br>}  &#x2F;&#x2F; namespace muduo</p>
<p>#endif  &#x2F;&#x2F; MUDUO_NET_TIMERID_H</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Timer.h</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#ifndef MUDUO_NET_TIMER_H<br>#define MUDUO_NET_TIMER_H</p>
<p>#include “muduo&#x2F;base&#x2F;Atomic.h”<br>#include “muduo&#x2F;base&#x2F;Timestamp.h”<br>#include “muduo&#x2F;net&#x2F;Callbacks.h”</p>
<p>namespace muduo<br>{<br>namespace net<br>{</p>
<p>&#x2F;&#x2F;&#x2F;<br>&#x2F;&#x2F;&#x2F; Internal class for timer event.<br>&#x2F;&#x2F;&#x2F;<br>class Timer : noncopyable<br>{<br> public:<br>  Timer(TimerCallback cb, Timestamp when, double interval)<br>    : callback_(std::move(cb)),<br>      expiration_(when),<br>      interval_(interval),<br>      repeat_(interval &gt; 0.0),<br>      sequence_(s_numCreated_.incrementAndGet())&#x2F;&#x2F;sequence唯一的<br>  { }</p>
<p>  void run() const<br>  {<br>    callback_();<br>  }</p>
<p>  Timestamp expiration() const  { return expiration_; }<br>  bool repeat() const { return repeat_; }<br>  int64_t sequence() const { return sequence_; }</p>
<p>  void restart(Timestamp now);</p>
<p>  static int64_t numCreated() { return s_numCreated_.get(); }</p>
<p> private:<br>  const TimerCallback callback_;&#x2F;&#x2F;定时器回调函数<br>  Timestamp expiration_;&#x2F;&#x2F;下一次的超时时刻<br>  const double interval_;&#x2F;&#x2F;超时时间间隔，如果是一次性定时器，该值为0<br>  const bool repeat_;&#x2F;&#x2F;是否重复<br>  const int64_t sequence_;&#x2F;&#x2F;定时器序号</p>
<p>  static AtomicInt64 s_numCreated_;&#x2F;&#x2F;定时器计数，当前已经创建的定时器数量<br>};</p>
<p>}  &#x2F;&#x2F; namespace net<br>}  &#x2F;&#x2F; namespace muduo</p>
<p>#endif  &#x2F;&#x2F; MUDUO_NET_TIMER_H</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Timer.cc</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#include “muduo&#x2F;net&#x2F;Timer.h”</p>
<p>using namespace muduo;<br>using namespace muduo::net;</p>
<p>AtomicInt64 Timer::s_numCreated_;</p>
<p>void Timer::restart(Timestamp now)&#x2F;&#x2F;重启<br>{<br>  &#x2F;&#x2F;如果是重复的计时器，则重新计算下一个超时时刻<br>  if (repeat_)<br>  {<br>    expiration_ &#x3D; addTime(now, interval_);<br>    &#x2F;&#x2F;全局函数，因为Timestamp相当于一个整数，所以是值传递，不是类传递都是引用传递<br>  }<br>  else<br>  {<br>    expiration_ &#x3D; Timestamp::invalid();&#x2F;&#x2F;非法的时间<br>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## TimerQueue.h</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>#ifndef MUDUO_NET_TIMERQUEUE_H<br>#define MUDUO_NET_TIMERQUEUE_H</p>
<p>#include <set><br>#include <vector></vector></set></p>
<p>#include “muduo&#x2F;base&#x2F;Mutex.h”<br>#include “muduo&#x2F;base&#x2F;Timestamp.h”<br>#include “muduo&#x2F;net&#x2F;Callbacks.h”<br>#include “muduo&#x2F;net&#x2F;Channel.h”</p>
<p>namespace muduo<br>{<br>namespace net<br>{</p>
<p>class EventLoop;<br>class Timer;<br>class TimerId;</p>
<p>&#x2F;&#x2F;&#x2F;<br>&#x2F;&#x2F;&#x2F; A best efforts timer queue.<br>&#x2F;&#x2F;&#x2F; No guarantee that the callback will be on time.<br>&#x2F;&#x2F;&#x2F;<br>class TimerQueue : noncopyable<br>{<br> public:<br>  explicit TimerQueue(EventLoop* loop);&#x2F;&#x2F;一个TimerQueue属于EventLoop对象<br>  ~TimerQueue();</p>
<p>  &#x2F;&#x2F;&#x2F;<br>  &#x2F;&#x2F;&#x2F; Schedules the callback to be run at given time,<br>  &#x2F;&#x2F;&#x2F; repeats if @c interval &gt; 0.0.<br>  &#x2F;&#x2F;&#x2F;<br>  &#x2F;&#x2F;&#x2F; Must be thread safe. Usually be called from other threads.<br>  &#x2F;&#x2F;一定是线程安全的，可以跨线程调用。通常情况下被其它线程调用<br>  TimerId addTimer(TimerCallback cb,<br>                   Timestamp when,<br>                   double interval);<br>  &#x2F;&#x2F;也可以跨线程调用<br>  void cancel(TimerId timerId);</p>
<p> private:</p>
<p>  &#x2F;&#x2F; FIXME: use unique_ptr<Timer> instead of raw pointers.<br>  &#x2F;&#x2F; This requires heterogeneous comparison lookup (N3465) from C++14<br>  &#x2F;&#x2F; so that we can find an T* in a set&lt;unique_ptr<T>&gt;.<br>  &#x2F;&#x2F;unique_ptr是c++11标准的一个独享所有权的智能指针<br>  &#x2F;&#x2F;无法得到指向同一对象的两个unique_ptr指针<br>  &#x2F;&#x2F;但可以进行移动构造与移动赋值操作，即所有权可以移动到另一个对象（而非拷贝构造)<br>  typedef std::pair&lt;Timestamp, Timer*&gt; Entry;<br>  typedef std::set<Entry> TimerList;<br>  typedef std::pair&lt;Timer*, int64_t&gt; ActiveTimer;<br>  typedef std::set<ActiveTimer> ActiveTimerSet;<br>  &#x2F;&#x2F;事实上 TimerList和 ActiveTimerSet表示的是同一样东西定时器列表，只是一个是地址排序，一个是按时间排序<br>  &#x2F;&#x2F;以下成员函数只可能在其所属的IO线程中调用，因而不必加锁<br>  &#x2F;&#x2F;服务器性能杀手之一是锁竞争，所以尽量减少锁的使用<br>  void addTimerInLoop(Timer* timer);<br>  void cancelInLoop(TimerId timerId);<br>  &#x2F;&#x2F; called when timerfd alarms<br>  void handleRead();&#x2F;&#x2F;定时器事件到来，调用回调函数handleRead()<br>  &#x2F;&#x2F; move out all expired timers</ActiveTimer></Entry></T></Timer></p>
<p>  &#x2F;&#x2F;返回超时的定时器列表<br>  std::vector<Entry> getExpired(Timestamp now);<br>  &#x2F;&#x2F;对于重复的定时器我们需要重置<br>  void reset(const std::vector<Entry>&amp; expired, Timestamp now);<br>  &#x2F;&#x2F;插入定时器<br>  bool insert(Timer* timer);</Entry></Entry></p>
<p>  EventLoop* loop_;&#x2F;&#x2F;所属EventLoop<br>  const int timerfd_;&#x2F;&#x2F;定时器文件描述符<br>  Channel timerfdChannel_;&#x2F;&#x2F;定时器通道<br>  &#x2F;&#x2F; Timer list sorted by expiration<br>  TimerList timers_;&#x2F;&#x2F;是按到期时间排序的</p>
<p>  &#x2F;&#x2F; for cancel()<br>  &#x2F;&#x2F;事实上 TimerList和 ActiveTimerSet表示的是同一样东西定时器列表，只是一个是地址排序，一个是按时间排序<br>  ActiveTimerSet activeTimers_;<br>  bool callingExpiredTimers_; &#x2F;* atomic *&#x2F;<br>  &#x2F;&#x2F;是否处于调用那些超时定时器处理当中<br>  ActiveTimerSet cancelingTimers_;&#x2F;&#x2F;保存的是被取消的定时器<br>};</p>
<p>}  &#x2F;&#x2F; namespace net<br>}  &#x2F;&#x2F; namespace muduo<br>#endif  &#x2F;&#x2F; MUDUO_NET_TIMERQUEUE_H</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## TimerQueue.cc</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#ifndef __STDC_LIMIT_MACROS<br>#define __STDC_LIMIT_MACROS<br>#endif</p>
<p>#include “muduo&#x2F;net&#x2F;TimerQueue.h”</p>
<p>#include “muduo&#x2F;base&#x2F;Logging.h”<br>#include “muduo&#x2F;net&#x2F;EventLoop.h”<br>#include “muduo&#x2F;net&#x2F;Timer.h”<br>#include “muduo&#x2F;net&#x2F;TimerId.h”</p>
<p>#include &lt;sys&#x2F;timerfd.h&gt;<br>#include &lt;unistd.h&gt;</p>
<p>namespace muduo<br>{<br>namespace net<br>{<br>namespace detail<br>{</p>
<p>int createTimerfd()<br>{<br>  int timerfd &#x3D; ::timerfd_create(CLOCK_MONOTONIC,<br>                                 TFD_NONBLOCK | TFD_CLOEXEC);<br>  if (timerfd &lt; 0)<br>  {<br>    LOG_SYSFATAL &lt;&lt; “Failed in timerfd_create”;<br>  }<br>  return timerfd;<br>}</p>
<p>struct timespec howMuchTimeFromNow(Timestamp when)<br>{<br>  int64_t microseconds &#x3D; when.microSecondsSinceEpoch()<br>                         - Timestamp::now().microSecondsSinceEpoch();<br>  if (microseconds &lt; 100)<br>  {<br>    microseconds &#x3D; 100;<br>  }<br>  struct timespec ts;<br>  ts.tv_sec &#x3D; static_cast<time_t>(<br>      microseconds &#x2F; Timestamp::kMicroSecondsPerSecond);<br>  ts.tv_nsec &#x3D; static_cast<long>(<br>      (microseconds % Timestamp::kMicroSecondsPerSecond) * 1000);<br>  return ts;<br>}</long></time_t></p>
<p>void readTimerfd(int timerfd, Timestamp now)<br>{<br>  uint64_t howmany;<br>  ssize_t n &#x3D; ::read(timerfd, &amp;howmany, sizeof howmany);<br>  LOG_TRACE &lt;&lt; “TimerQueue::handleRead() “ &lt;&lt; howmany &lt;&lt; “ at “ &lt;&lt; now.toString();<br>  if (n !&#x3D; sizeof howmany)<br>  {<br>    LOG_ERROR &lt;&lt; “TimerQueue::handleRead() reads “ &lt;&lt; n &lt;&lt; “ bytes instead of 8”;<br>  }<br>}<br>&#x2F;&#x2F;重置定时器的超时时间<br>void resetTimerfd(int timerfd, Timestamp expiration)<br>{<br>  &#x2F;&#x2F; wake up loop by timerfd_settime()<br>  struct itimerspec newValue;<br>  struct itimerspec oldValue;<br>  memZero(&amp;newValue, sizeof newValue);<br>  memZero(&amp;oldValue, sizeof oldValue);<br>  newValue.it_value &#x3D; howMuchTimeFromNow(expiration);<br>  int ret &#x3D; ::timerfd_settime(timerfd, 0, &amp;newValue, &amp;oldValue);<br>  if (ret)<br>  {<br>    LOG_SYSERR &lt;&lt; “timerfd_settime()”;<br>  }<br>}</p>
<p>}  &#x2F;&#x2F; namespace detail<br>}  &#x2F;&#x2F; namespace net<br>}  &#x2F;&#x2F; namespace muduo</p>
<p>using namespace muduo;<br>using namespace muduo::net;<br>using namespace muduo::net::detail;</p>
<p>TimerQueue::TimerQueue(EventLoop* loop)<br>  : loop_(loop),<br>    timerfd_(createTimerfd()),<br>    timerfdChannel_(loop, timerfd_),<br>    timers_(),<br>    callingExpiredTimers_(false)<br>{<br>  timerfdChannel_.setReadCallback(<br>      std::bind(&amp;TimerQueue::handleRead, this));<br>  &#x2F;&#x2F; we are always reading the timerfd, we disarm it with timerfd_settime.<br>  timerfdChannel_.enableReading();&#x2F;&#x2F;把timerfdChannel_这个通道加入poll关注<br>}</p>
<p>TimerQueue::~TimerQueue()<br>{<br>  timerfdChannel_.disableAll();<br>  timerfdChannel_.remove();<br>  ::close(timerfd_);<br>  &#x2F;&#x2F; do not remove channel, since we’re in EventLoop::dtor();<br>  for (const Entry&amp; timer : timers_)<br>  {<br>    delete timer.second;&#x2F;&#x2F;只需要删除其中一个的原因是因为Timer 对象同时被 timers_ 集合和 activeTimers_ 集合所拥有<br>  }<br>}</p>
<p>TimerId TimerQueue::addTimer(TimerCallback cb,<br>                             Timestamp when,&#x2F;&#x2F;超时时间<br>                             double interval)<br>{<br>  Timer* timer &#x3D; new Timer(std::move(cb), when, interval);&#x2F;&#x2F;每隔interval就会产生定时事件，回调cb<br>  loop_-&gt;runInLoop(<br>      std::bind(&amp;TimerQueue::addTimerInLoop, this, timer));&#x2F;&#x2F;用来保证跨线程调用，并且保证线程安全<br>  return TimerId(timer, timer-&gt;sequence());<br>}</p>
<p>void TimerQueue::cancel(TimerId timerId)<br>{<br>  loop_-&gt;runInLoop(<br>      std::bind(&amp;TimerQueue::cancelInLoop, this, timerId));<br>}</p>
<p>void TimerQueue::addTimerInLoop(Timer* timer)<br>{<br>  loop_-&gt;assertInLoopThread();<br>  &#x2F;&#x2F;插入一个定时器，有可能会使得最早到期的定时器发生改变<br>  bool earliestChanged &#x3D; insert(timer);&#x2F;&#x2F;不用加锁，因为loop_-&gt;runInLoop异步有加锁这一步</p>
<p>  if (earliestChanged)&#x2F;&#x2F;最早的定时器会到期<br>  {<br>    &#x2F;&#x2F;重置定时器的超时时刻（timerfd_settime）<br>    resetTimerfd(timerfd_, timer-&gt;expiration());<br>  }<br>}</p>
<p>void TimerQueue::cancelInLoop(TimerId timerId)<br>{<br>  loop_-&gt;assertInLoopThread();<br>  assert(timers_.size() &#x3D;&#x3D; activeTimers_.size());<br>  ActiveTimer timer(timerId.timer_, timerId.sequence_);<br>  &#x2F;&#x2F;查找该定时器<br>  ActiveTimerSet::iterator it &#x3D; activeTimers_.find(timer);<br>  if (it !&#x3D; activeTimers_.end())<br>  {<br>    size_t n &#x3D; timers_.erase(Entry(it-&gt;first-&gt;expiration(), it-&gt;first));<br>    assert(n &#x3D;&#x3D; 1); (void)n;<br>    delete it-&gt;first; &#x2F;&#x2F; FIXME: no delete please，如果用了unique_ptr就不用手动删除了，typedef std::pair&lt;Timestamp, std::unique_ptr<Timer>&gt; Entry;<br>    activeTimers_.erase(it);<br>  }<br>  else if (callingExpiredTimers_)<br>  {<br>    &#x2F;&#x2F;已经到期，并且正在调用回调函数的定时器<br>    cancelingTimers_.insert(timer);<br>  }<br>  assert(timers_.size() &#x3D;&#x3D; activeTimers_.size());<br>}</Timer></p>
<p>void TimerQueue::handleRead()<br>{<br>  loop_-&gt;assertInLoopThread();<br>  Timestamp now(Timestamp::now());<br>  readTimerfd(timerfd_, now);&#x2F;&#x2F;清除该事件，避免一直触发<br>  &#x2F;&#x2F;获取该时刻之前所以的定时器列表（即超时定时器列表）<br>  std::vector<Entry> expired &#x3D; getExpired(now);</Entry></p>
<p>  callingExpiredTimers_ &#x3D; true;<br>  cancelingTimers_.clear();<br>  &#x2F;&#x2F; safe to callback outside critical section<br>  for (const Entry&amp; it : expired)<br>  {<br>    &#x2F;&#x2F;这里回调定时器处理函数<br>    it.second-&gt;run();<br>  }<br>  callingExpiredTimers_ &#x3D; false;<br>  &#x2F;&#x2F;不是一次性定时器，需要重启<br>  reset(expired, now);<br>}<br>&#x2F;&#x2F;不会对expired拷贝构造，rvo<br>std::vector<a href="TimerQueue::Entry">TimerQueue::Entry</a> TimerQueue::getExpired(Timestamp now)<br>{<br>  assert(timers_.size() &#x3D;&#x3D; activeTimers_.size());<br>  std::vector<Entry> expired;<br>  Entry sentry(now, reinterpret_cast&lt;Timer*&gt;(UINTPTR_MAX));&#x2F;&#x2F;将机器指针的最大值（UINTPTR_MAX）转换为 Timer* 类型的指针<br>  &#x2F;&#x2F;返回第一个未到期timer迭代器<br>  &#x2F;&#x2F;lower_bound表示返回第一个大于等于sentry的元素的iterator<br>  &#x2F;&#x2F;即*end&gt;&#x3D;sentry,从而end-&gt;first&gt;now</Entry></p>
<p>  TimerList::iterator end &#x3D; timers_.lower_bound(sentry);<br>  assert(end &#x3D;&#x3D; timers_.end() || now &lt; end-&gt;first);<br>  &#x2F;&#x2F;将到期的定时器插入到expired<br>  std::copy(timers_.begin(), end, back_inserter(expired));<br>  timers_.erase(timers_.begin(), end);&#x2F;&#x2F;删除timers_到期的定时器<br>  &#x2F;&#x2F;移除ActiveTimer到期的定时器<br>  for (const Entry&amp; it : expired)<br>  {<br>    ActiveTimer timer(it.second, it.second-&gt;sequence());<br>    size_t n &#x3D; activeTimers_.erase(timer);<br>    assert(n &#x3D;&#x3D; 1); (void)n;<br>  }</p>
<p>  assert(timers_.size() &#x3D;&#x3D; activeTimers_.size());<br>  return expired;<br>}</p>
<p>void TimerQueue::reset(const std::vector<Entry>&amp; expired, Timestamp now)<br>{<br>  Timestamp nextExpire;</Entry></p>
<p>  for (const Entry&amp; it : expired)<br>  {<br>    ActiveTimer timer(it.second, it.second-&gt;sequence());<br>    &#x2F;&#x2F;如果是重复的定时器并且是未取消的定时器，则重启该定时器<br>    if (it.second-&gt;repeat()<br>        &amp;&amp; cancelingTimers_.find(timer) &#x3D;&#x3D; cancelingTimers_.end())<br>    {<br>      &#x2F;&#x2F;一次性定时器或者被取消的定时器是不能重置的，因此删除该定时器<br>      it.second-&gt;restart(now);<br>      insert(it.second);<br>    }<br>    else<br>    {<br>      &#x2F;&#x2F; FIXME move to a free list<br>      delete it.second; &#x2F;&#x2F; FIXME: no delete please<br>    }<br>  }</p>
<p>  if (!timers_.empty())<br>  {<br>    nextExpire &#x3D; timers_.begin()-&gt;second-&gt;expiration();<br>  }</p>
<p>  if (nextExpire.valid())<br>  {<br>    resetTimerfd(timerfd_, nextExpire);<br>  }<br>}</p>
<p>bool TimerQueue::insert(Timer* timer)<br>{<br>  loop_-&gt;assertInLoopThread();<br>  assert(timers_.size() &#x3D;&#x3D; activeTimers_.size());<br>  &#x2F;&#x2F;最早到期时间是否改变<br>  bool earliestChanged &#x3D; false;<br>  Timestamp when &#x3D; timer-&gt;expiration();&#x2F;&#x2F;timer的到期时间取出来<br>  TimerList::iterator it &#x3D; timers_.begin();&#x2F;&#x2F;时间最早的定时器<br>  &#x2F;&#x2F;如果timers_为空或者when小于timers_最早到期时间<br>  if (it &#x3D;&#x3D; timers_.end() || when &lt; it-&gt;first)<br>  {<br>    earliestChanged &#x3D; true;<br>  }<br>  {<br>    &#x2F;&#x2F;插入到timers_<br>    std::pair&lt;TimerList::iterator, bool&gt; result<br>      &#x3D; timers_.insert(Entry(when, timer));&#x2F;&#x2F;Entry是一个pair,when是到期时间，timer是地址<br>    assert(result.second); (void)result;<br>  }<br>  {<br>    &#x2F;&#x2F;插入到activeTimers_<br>    std::pair&lt;ActiveTimerSet::iterator, bool&gt; result<br>      &#x3D; activeTimers_.insert(ActiveTimer(timer, timer-&gt;sequence()));<br>    assert(result.second); (void)result;<br>  }</p>
<p>  assert(timers_.size() &#x3D;&#x3D; activeTimers_.size());<br>  return earliestChanged;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### RVO优化</span><br><span class="line"></span><br><span class="line">在C++中，RVO（Return Value Optimization）是一种优化技术，旨在减少函数返回对象时的不必要拷贝构造或移动构造操作，从而提高程序的性能和效率。</span><br><span class="line"></span><br><span class="line">通常情况下，当一个函数返回一个临时对象时，编译器会生成一个临时对象的副本，然后将这个副本返回给调用者。这可能会导致额外的开销，特别是对于大型对象。RVO优化的目标是避免这种额外的拷贝操作。</span><br><span class="line"></span><br><span class="line">RVO优化的原理是在编译器级别进行优化，使得函数返回的临时对象直接构造在调用者提供的内存空间中，从而避免了中间的拷贝步骤。这样可以显著提高程序的性能，减少内存和时间开销。</span><br><span class="line"></span><br><span class="line">以下是一个简单的示例，说明RVO优化是如何工作的：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#include <iostream></iostream></p>
<p>&#x2F;&#x2F; 返回一个临时对象的函数<br>std::string createString() {<br>    std::string str &#x3D; “Hello, RVO!”;<br>    return str; &#x2F;&#x2F; 在RVO优化下，str将直接构造在调用者提供的内存中<br>}</p>
<p>int main() {<br>    std::string result &#x3D; createString();<br>    std::cout &lt;&lt; result &lt;&lt; std::endl;<br>    return 0;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在上述示例中，当RVO优化启用时，函数`createString`返回的临时对象将直接构造在`main`函数中的`result`对象所占用的内存中，而不会发生额外的拷贝操作。</span><br><span class="line"></span><br><span class="line">需要注意的是，RVO并非在所有编译器和所有情况下都会发生。在某些情况下，由于编译器的实现或代码的复杂性，RVO可能无法进行。然而，现代的编译器通常都会支持RVO优化，以提高程序的性能和效率。</span><br><span class="line"></span><br><span class="line">## 测试文件Timerqueue_unittest.cc</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>using namespace muduo;<br>using namespace muduo::net;</p>
<p>int cnt &#x3D; 0;<br>EventLoop* g_loop;</p>
<p>void printTid()<br>{<br>  printf(“pid &#x3D; %d, tid &#x3D; %d\n”, getpid(), CurrentThread::tid());<br>  printf(“now %s\n”, Timestamp::now().toString().c_str());<br>}</p>
<p>void print(const char* msg)<br>{<br>  printf(“msg %s %s\n”, Timestamp::now().toString().c_str(), msg);<br>  if (++cnt &#x3D;&#x3D; 20)<br>  {<br>    g_loop-&gt;quit();<br>  }<br>}</p>
<p>void cancel(TimerId timer)<br>{<br>  g_loop-&gt;cancel(timer);<br>  printf(“cancelled at %s\n”, Timestamp::now().toString().c_str());<br>}</p>
<p>int main()<br>{<br>  printTid();<br>  sleep(1);<br>  {<br>    EventLoop loop;<br>    g_loop &#x3D; &amp;loop;</p>
<pre><code>print(&quot;main&quot;);
loop.runAfter(1, std::bind(print, &quot;once1&quot;));
loop.runAfter(1.5, std::bind(print, &quot;once1.5&quot;));
loop.runAfter(2.5, std::bind(print, &quot;once2.5&quot;));
loop.runAfter(3.5, std::bind(print, &quot;once3.5&quot;));
TimerId t45 = loop.runAfter(4.5, std::bind(print, &quot;once4.5&quot;));
loop.runAfter(4.2, std::bind(cancel, t45));//在4.2秒提前取消
loop.runAfter(4.8, std::bind(cancel, t45));//没有意义
loop.runEvery(2, std::bind(print, &quot;every2&quot;));//每隔2秒运行一下
TimerId t3 = loop.runEvery(3, std::bind(print, &quot;every3&quot;));
loop.runAfter(9.001, std::bind(cancel, t3));

loop.loop();
print(&quot;main loop exits&quot;);
</code></pre>
<p>  }</p>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![image-20230811182546845](muduo-网络库（2）/image-20230811182546845.png)</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20230811182546845.png This is an test image %&#125;</span><br><span class="line"></span><br><span class="line">只有TimerId对外可见，其余两个都是内部封装的。</span><br><span class="line"></span><br><span class="line">这段代码实现了一个定时器队列 `TimerQueue`，用于在事件循环中管理定时器的触发和处理。以下是它是如何添加定时器的过程：</span><br><span class="line"></span><br><span class="line">1. 在 `TimerQueue` 的构造函数中，创建了一个 `timerfd`，用于实现定时器的底层计时。</span><br><span class="line">2. 当需要添加一个定时器时，调用 `addTimer` 函数，传递定时器的回调函数 `cb`、超时时间 `when` 和重复间隔 `interval`。</span><br><span class="line">3. 在 `addTimer` 函数中，创建一个新的 `Timer` 对象，将回调函数 `cb`、超时时间 `when` 和重复间隔 `interval` 存储在该定时器对象中。</span><br><span class="line">4. 调用 `loop_-&gt;runInLoop`，将添加定时器的操作安排在事件循环线程中执行，以确保跨线程调用的安全性。</span><br><span class="line">5. 在 `addTimerInLoop` 函数中，首先调用 `insert` 函数将定时器插入到定时器列表 `timers_` 和活跃定时器集合 `activeTimers_` 中。</span><br><span class="line">6. 如果插入定时器后，它成为了最早到期的定时器（即 `earliestChanged` 为 `true`），那么需要调用 `resetTimerfd` 函数来重置 `timerfd` 的超时时间为该定时器的到期时间。</span><br><span class="line">7. 在 `handleRead` 函数中，会处理 `timerfd` 的读事件，即定时器到期事件。它首先获取已到期的定时器列表，然后依次调用它们的回调函数。</span><br><span class="line">8. 如果定时器是重复定时器且没有被取消，它会被重新插入定时器列表，以便下一次触发。否则，被取消的定时器将会被删除。</span><br><span class="line"></span><br><span class="line">总之，通过调用 `addTimer`，代码会创建一个 `Timer` 对象，并将其插入到定时器列表和活跃定时器集合中。在每个事件循环迭代中，会检查定时器列表中是否有已到期的定时器，并触发它们的回调函数。如果定时器是重复定时器且未被取消，它将被重新插入列表中，以便下次触发。</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">当插入一个定时器时，可能会导致最早到期的定时器发生改变。这是因为新插入的定时器有可能比当前最早到期的定时器更早到期，从而改变了整个定时器队列的顺序。</span><br><span class="line"></span><br><span class="line">具体地，以下是插入定时器可能引起的操作：</span><br><span class="line"></span><br><span class="line">1. 首先，插入定时器操作将定时器对象插入到定时器列表 `timers_` 和活跃定时器集合 `activeTimers_` 中。</span><br><span class="line">2. 然后，会检查插入的定时器是否比当前最早到期的定时器更早到期。如果是，那么最早到期的定时器发生了改变，需要进行相应操作。</span><br><span class="line">3. 如果最早到期的定时器发生了改变，会调用 `resetTimerfd` 函数，将 `timerfd` 的超时时间设置为新的最早到期定时器的到期时间。这样做是为了确保 `timerfd` 在最早到期定时器到期时触发读事件。</span><br><span class="line"></span><br><span class="line">总之，插入定时器可能会改变最早到期的定时器，如果发生了这种改变，代码会通过 `resetTimerfd` 函数更新 `timerfd` 的超时时间，以确保及时触发最早到期定时器的事件</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>TimerId TimerQueue::addTimer(TimerCallback cb,<br>                             Timestamp when,&#x2F;&#x2F;超时时间<br>                             double interval)<br>{<br>  Timer* timer &#x3D; new Timer(std::move(cb), when, interval);&#x2F;&#x2F;每隔interval就会产生定时事件，回调cb<br>  loop_-&gt;runInLoop(<br>      std::bind(&amp;TimerQueue::addTimerInLoop, this, timer));&#x2F;&#x2F;用来保证跨线程调用<br>  return TimerId(timer, timer-&gt;sequence());<br>}</p>
<p>void TimerQueue::addTimerInLoop(Timer* timer)<br>{<br>  loop_-&gt;assertInLoopThread();<br>  &#x2F;&#x2F;插入一个定时器，有可能会使得最早到期的定时器发生改变<br>  bool earliestChanged &#x3D; insert(timer);</p>
<p>  if (earliestChanged)&#x2F;&#x2F;最早到期的定时器会<br>  {<br>    &#x2F;&#x2F;重置定时器的超时时刻（timerfd_settime）<br>    resetTimerfd(timerfd_, timer-&gt;expiration());<br>  }<br>}<br>&#x2F;&#x2F;判断是否需要改变最早到期的定时器<br>bool TimerQueue::insert(Timer* timer)<br>{<br>  loop_-&gt;assertInLoopThread();<br>  assert(timers_.size() &#x3D;&#x3D; activeTimers_.size());<br>  &#x2F;&#x2F;最早到期时间是否改变<br>  bool earliestChanged &#x3D; false;<br>  Timestamp when &#x3D; timer-&gt;expiration();&#x2F;&#x2F;timer的到期时间取出来<br>  TimerList::iterator it &#x3D; timers_.begin();&#x2F;&#x2F;时间最早的定时器<br>  &#x2F;&#x2F;如果timers_为空或者when小于timers_最早到期时间<br>  if (it &#x3D;&#x3D; timers_.end() || when &lt; it-&gt;first)<br>  {<br>    earliestChanged &#x3D; true;<br>  }<br>  {<br>    &#x2F;&#x2F;插入到timers_<br>    std::pair&lt;TimerList::iterator, bool&gt; result<br>      &#x3D; timers_.insert(Entry(when, timer));&#x2F;&#x2F;Entry是一个pair,when是到期时间，timer是地址<br>    assert(result.second); (void)result;<br>  }<br>  {<br>    &#x2F;&#x2F;插入到activeTimers_<br>    std::pair&lt;ActiveTimerSet::iterator, bool&gt; result<br>      &#x3D; activeTimers_.insert(ActiveTimer(timer, timer-&gt;sequence()));<br>    assert(result.second); (void)result;<br>  }</p>
<p>  assert(timers_.size() &#x3D;&#x3D; activeTimers_.size());<br>  return earliestChanged;<br>}</p>
<pre><code>
函数 `resetTimerfd`，用于通过调用 `timerfd_settime` 函数来重置定时器的超时时间。以下是每个步骤的解释：

1. `struct itimerspec newValue;` 和 `struct itimerspec oldValue;`：定义了两个 `itimerspec` 结构体，用于存储新旧定时器的超时时间信息。
2. `memZero(&amp;newValue, sizeof newValue);` 和 `memZero(&amp;oldValue, sizeof oldValue);`：将 `newValue` 和 `oldValue` 结构体初始化为全零，以确保没有未初始化的内存数据。
3. `newValue.it_value = howMuchTimeFromNow(expiration);`：计算从当前时间到目标到期时间 `expiration` 的时间间隔，并将其设置为 `newValue` 结构体的 `it_value` 字段。这将在定时器到期时触发定时器事件。
4. `int ret = ::timerfd_settime(timerfd, 0, &amp;newValue, &amp;oldValue);`：调用 `timerfd_settime` 函数，将 `newValue` 结构体应用到指定的定时器文件描述符 `timerfd` 上，从而重置定时器的超时时间。第一个参数为定时器文件描述符，第二个参数为标志（此处为0，表示相对时间），第三个参数为新的定时器超时时间，第四个参数为旧的定时器超时时间。
5. `if (ret)`：检查 `timerfd_settime` 函数的返回值，如果返回值非零，表示函数调用失败。
6. `LOG_SYSERR &lt;&lt; &quot;timerfd_settime()&quot;;`：如果函数调用失败，通过日志记录错误信息。

总之，这段代码通过计算时间间隔并调用 `timerfd_settime` 函数，实现了对定时器超时时间的重置，以便在定时器到期时触发相应的事件。
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1/" class="post-title-link" itemprop="url">数据结构-1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-09 21:57:14 / 修改时间：22:20:51" itemprop="dateCreated datePublished" datetime="2023-08-09T21:57:14+08:00">2023-08-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="二分查找算法"><a href="#二分查找算法" class="headerlink" title="二分查找算法"></a>二分查找算法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">void search(int nums[],int size,int x)</span><br><span class="line">&#123;</span><br><span class="line"> 	int left=0;</span><br><span class="line"> 	int right=size-1;</span><br><span class="line"> 	int flag=0;</span><br><span class="line"> 	int sum=1;</span><br><span class="line"> 	while(left&lt;=right)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		int mid;</span><br><span class="line"> 		//mid=(left+right)/2;</span><br><span class="line"> 		mid=left+(right-left)*(x-nums[left])/(nums[right]-nums[left]);</span><br><span class="line"> 		printf(&quot;%dth\t:left=%d\tmid=%d\tright=%d\n&quot;,sum++,nums[left],nums[mid],nums[right]);</span><br><span class="line"> 		if(x==nums[mid])</span><br><span class="line"> 		&#123;</span><br><span class="line"> 			printf(&quot;第%d次查找到值为%d的数\n&quot;,sum-1,x);</span><br><span class="line"> 			flag=1;</span><br><span class="line"> 			break;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		else if(x&lt;nums[mid])</span><br><span class="line"> 		&#123;</span><br><span class="line"> 			right=mid-1;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		else if(x&gt;nums[mid])</span><br><span class="line"> 		&#123;</span><br><span class="line"> 			left=mid+1;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	if(flag==0)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		printf(&quot;没有找到相关值。\n&quot;);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;	</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> 	int x;</span><br><span class="line"> 	int nums[]=&#123;0,7,12,13,19,31,40,55,66,77,88&#125;;</span><br><span class="line"> 	int size=sizeof(nums)/sizeof(nums[0]);</span><br><span class="line"> 	printf(&quot;Input your number:\n&quot;);</span><br><span class="line"> 	scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line"> 	search(nums,size,x);</span><br><span class="line"> 	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mid=left+(right-left)*(x-nums[left])/(nums[right]-nums[left]);</code>是用来计算二分查找中间元素的下标 <code>mid</code> 的一种特殊方式，以避免整数溢出的问题。让我来解释这个计算的含义：</p>
<p>在标准的二分查找中，通常计算中间元素下标的方式是 <code>(left + right) / 2</code>。然而，当 <code>left</code> 和 <code>right</code> 的值非常大时，相加操作可能导致整数溢出，从而得到错误的中间元素下标。</p>
<p>为了避免这个问题，代码中使用了一个等价的计算方法，即 <code>mid = left + (right - left) * (x - nums[left]) / (nums[right] - nums[left])</code>。这个计算涉及到几个步骤：</p>
<ol>
<li><code>x - nums[left]</code>：计算目标值 <code>x</code> 与左边界元素值的差，即在当前查找范围内，目标值相对于左边界的偏移量。</li>
<li><code>nums[right] - nums[left]</code>：计算右边界元素值与左边界元素值的差，即在当前查找范围内，元素值的范围。</li>
<li><code>(right - left) * (x - nums[left]) / (nums[right] - nums[left])</code>：将偏移量与元素值的范围相乘，然后除以范围的差值。这个操作会产生一个相对于范围的偏移量，将这个偏移量加到左边界的下标上，就得到了一个在当前查找范围内的中间位置的下标。</li>
</ol>
<p>总之，这种计算方法的目的是避免整数溢出，并在大整数范围内也能够正确计算出中间元素的下标，从而确保二分查找的正确性。虽然这个计算方法比标准的 <code>(left + right) / 2</code> 更复杂，但它在处理大整数时更加安全。</p>
<h1 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br><span class="line">#define ElemType int</span><br><span class="line">#define KeyType int</span><br><span class="line"></span><br><span class="line">/* 二叉排序树的节点结构定义 */</span><br><span class="line">typedef struct BiTNode &#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct BiTNode *lchild, *rchild;</span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line">// 二叉排序树查找算法</span><br><span class="line">int SearchBST(BiTree T, KeyType key, BiTree f, BiTree *p) &#123;</span><br><span class="line">	//如果 T 指针为空，说明查找失败，令 p 指针指向查找过程中最后一个叶子结点，并返回查找失败的信息</span><br><span class="line">    if (!T) &#123;</span><br><span class="line">        *p = f;</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125; </span><br><span class="line">    //如果相等，令 p 指针指向该关键字，并返回查找成功信息</span><br><span class="line">    else if (key == T-&gt;data) &#123;</span><br><span class="line">        *p = T;</span><br><span class="line">        return TRUE;</span><br><span class="line">    &#125; </span><br><span class="line">    //如果 key 值比 T 根结点的值小，则查找其左子树；反之，查找其右子树</span><br><span class="line">	else if (key &lt; T-&gt;data) &#123;</span><br><span class="line">		//使用递归的方式</span><br><span class="line">        return SearchBST(T-&gt;lchild, key, T, p);</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">        return SearchBST(T-&gt;rchild, key, T, p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 插入节点</span><br><span class="line">int InsertBST(BiTree *T, ElemType e) &#123;</span><br><span class="line">    BiTree p = NULL;</span><br><span class="line">    //如果查找不成功，需做插入操作</span><br><span class="line">    if (!SearchBST(*T, e, NULL, &amp;p)) &#123;</span><br><span class="line">		//初始化插入结点</span><br><span class="line">        BiTree s = (BiTree)malloc(sizeof(BiTNode));</span><br><span class="line">        s-&gt;data = e;</span><br><span class="line">        s-&gt;lchild = s-&gt;rchild = NULL;</span><br><span class="line">        //如果 p 为NULL，说明该二叉排序树为空树，此时插入的结点为整棵树的根结点</span><br><span class="line">        if (!p) &#123;</span><br><span class="line">            *T = s;</span><br><span class="line">        &#125; </span><br><span class="line">        //如果 p 不为 NULL，则 p 指向的为查找失败的最后一个叶子结点，只需要通过比较 p 和 e 的值确定 s 到底</span><br><span class="line">是 p 的左孩子还是右孩子</span><br><span class="line">        else if (e &lt; p-&gt;data) &#123;</span><br><span class="line">            p-&gt;lchild = s;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            p-&gt;rchild = s;</span><br><span class="line">        &#125;</span><br><span class="line">        return TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果查找成功，不需要做插入操作，插入失败</span><br><span class="line">    return FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除节点</span><br><span class="line">int Delete(BiTree *p) &#123;</span><br><span class="line">    BiTree q, s;</span><br><span class="line">    //情况 1，结点 p 本身为叶子结点，直接删除即可</span><br><span class="line">    if ((*p)-&gt;lchild == NULL &amp;&amp; (*p)-&gt;rchild == NULL) &#123;</span><br><span class="line">        *p = NULL;</span><br><span class="line">    &#125; else if ((*p)-&gt;lchild == NULL) &#123;//左子树为空，只需用结点 p 的右子树根结点代替结点 p 即可；</span><br><span class="line">        q = *p;</span><br><span class="line">        *p = (*p)-&gt;rchild;</span><br><span class="line">        free(q);</span><br><span class="line">    &#125; else if ((*p)-&gt;rchild == NULL) &#123;//右子树为空，只需用结点 p 的左子树根结点代替结点 p 即可；</span><br><span class="line">        q = *p;</span><br><span class="line">        *p = (*p)-&gt;lchild;//这里不是指针 *p 指向左子树，而是将左子树存储的结点的地址赋值给指针变量 p</span><br><span class="line">        free(q);</span><br><span class="line">    &#125; else &#123;//左右子树均不为空，采用第 2 种方式</span><br><span class="line">        q = *p;</span><br><span class="line">        s = (*p)-&gt;lchild;</span><br><span class="line">        //遍历，找到结点 p 的直接前驱</span><br><span class="line">        while (s-&gt;rchild) &#123;</span><br><span class="line">            q = s;</span><br><span class="line">            s = s-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        //直接改变结点 p 的值</span><br><span class="line">        (*p)-&gt;data = s-&gt;data;</span><br><span class="line">        //判断结点 p 的左子树 s 是否有右子树，分为两种情况讨论</span><br><span class="line">        if (q != *p) &#123;</span><br><span class="line">            q-&gt;rchild = s-&gt;lchild;//若有，则在删除直接前驱结点的同时，令前驱的左孩子结点改为 q 指向结点的</span><br><span class="line">孩子结点</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            q-&gt;lchild = s-&gt;lchild;//否则，直接将左子树上移即可</span><br><span class="line">        &#125;</span><br><span class="line">        free(s);</span><br><span class="line">    &#125;</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int DeleteBST(BiTree *T, int key) &#123;</span><br><span class="line">    if (!(*T)) &#123;//不存在关键字等于key的数据元素</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (key == (*T)-&gt;data) &#123;</span><br><span class="line">            Delete(T);</span><br><span class="line">            return TRUE;</span><br><span class="line">        &#125; else if (key &lt; (*T)-&gt;data) &#123;</span><br><span class="line">        	//使用递归的方式</span><br><span class="line">            return DeleteBST(&amp;(*T)-&gt;lchild, key);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return DeleteBST(&amp;(*T)-&gt;rchild, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void midOrder(BiTree t) &#123;</span><br><span class="line">    if (t == NULL) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    midOrder(t-&gt;lchild);</span><br><span class="line">    printf(&quot;%d &quot;, t-&gt;data);</span><br><span class="line">    midOrder(t-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int i;</span><br><span class="line">    int a[8] = &#123; 3, 4, 2, 5, 9, 12, 8, 21 &#125;;</span><br><span class="line">    BiTree T = NULL;</span><br><span class="line">    for (i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">        InsertBST(&amp;T, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;中序遍历二叉排序树：\n&quot;);</span><br><span class="line">    midOrder(T);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    printf(&quot;请输入要删除的值：\n&quot;);</span><br><span class="line">    int x;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">    printf(&quot;删除 %d 后，中序遍历二叉排序树：\n&quot;, x);</span><br><span class="line">    DeleteBST(&amp;T, x);</span><br><span class="line">    midOrder(T);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>直接前驱是指在二叉排序树（BST）中，一个节点的“直接前驱”是在中序遍历中位于该节点之前的节点，即值小于该节点值的最大节点。换句话说，直接前驱是紧邻在该节点之前的节点中的最大节点。</p>
<p>具体来说，假设有一个二叉排序树，并且你希望找到某个节点的直接前驱：</p>
<ol>
<li>如果该节点有左子树，直接前驱是其左子树的最右边节点。因为中序遍历中，左子树的最右节点会位于该节点的左下方。</li>
<li>如果该节点没有左子树，你需要从根节点开始，从上往下搜索，直到找到第一个小于该节点值的节点。这个节点就是直接前驱。</li>
</ol>
<p>直接前驱在二叉排序树中具有重要作用，特别是在删除节点的操作中。当你要删除一个节点时，如果该节点有左子树，你可以找到其直接前驱来替代该节点，从而保持树的结构和有序性。这样的替代操作可以保持二叉排序树的性质不变。</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct BiTNode &#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct BiTNode *lchild, *rchild;</span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>不带星号的情况</strong>：</li>
</ol>
<p>当你声明一个不带星号的变量，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BiTNode node;</span><br></pre></td></tr></table></figure>

<p>这意味着你在声明一个实际的 <code>BiTNode</code> 类型的变量，这个变量将会<strong>存储实际的结构体数据</strong>。你可以直接访问这个变量的成员，比如 <code>node.data</code> 或者 <code>node.lchild</code>。</p>
<ol>
<li><strong>带星号的情况</strong>：</li>
</ol>
<p>当你声明一个带星号的变量，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BiTree ptr;</span><br></pre></td></tr></table></figure>

<p>这意味着你在声明一个指针变量，这个指针变量将用来<strong>存储一个内存地址</strong>，这个地址指向了一个实际的 <code>BiTNode</code> 类型的对象。你可以通过这个指针来访问所指向的实际对象的成员，比如 <code>ptr-&gt;data</code> 或者 <code>ptr-&gt;lchild</code>。</p>
<p>实际上，带星号的变量就是指针，它存储了一个内存地址，而这个地址指向了某个实际的对象（比如结构体）。因此，通过这个指针，你可以在程序中操作和修改实际对象的数据。</p>
<p>总结起来，带星号的变量是指向实际对象的指针，而不带星号的变量则直接存储实际对象的数据。在代码中使用它们的时候，需要根据具体情况来决定是要访问实际对象的数据，还是要操作指向实际对象的指针。</p>
<hr>
<p>中序遍历的过程，按照从小到大的顺序遍历二叉树的所有节点，即先遍历左子树，再遍历根节点，最后遍历右子树。这种遍历方式可以帮助我们得到一个有序的节点序列</p>
<p>前序遍历和后序遍历是二叉树的另外两种遍历方式，与中序遍历不同。下面我会分别解释前序遍历和后序遍历的过程。</p>
<h3 id="前序遍历（Preorder-Traversal）"><a href="#前序遍历（Preorder-Traversal）" class="headerlink" title="前序遍历（Preorder Traversal）"></a>前序遍历（Preorder Traversal）</h3><p>前序遍历是指首先访问根节点，然后按照先左后右的顺序递归地遍历左子树和右子树。</p>
<p>前序遍历的过程：</p>
<ol>
<li>访问当前节点的值。</li>
<li>递归地对左子树进行前序遍历。</li>
<li>递归地对右子树进行前序遍历。</li>
</ol>
<h3 id="后序遍历（Postorder-Traversal）"><a href="#后序遍历（Postorder-Traversal）" class="headerlink" title="后序遍历（Postorder Traversal）"></a>后序遍历（Postorder Traversal）</h3><p>后序遍历是指先递归地遍历左子树和右子树，然后再访问根节点。</p>
<p>后序遍历的过程：</p>
<ol>
<li>递归地对左子树进行后序遍历。</li>
<li>递归地对右子树进行后序遍历。</li>
<li>访问当前节点的值。</li>
</ol>
<p>这两种遍历方式与中序遍历相比，输出节点的顺序有所不同，也会得到不同的遍历结果。</p>
<p>总结起来：</p>
<ul>
<li>前序遍历：根 - 左子树 - 右子树</li>
<li>中序遍历：左子树 - 根 - 右子树</li>
<li>后序遍历：左子树 - 右子树 - 根</li>
</ul>
<p>根据遍历方式的不同，你可以得到不同的节点序列，从而更好地理解二叉树的结构和内容。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/08/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/08/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/" class="post-title-link" itemprop="url">muduo-网络库（1）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-08 11:10:38" itemprop="dateCreated datePublished" datetime="2023-08-08T11:10:38+08:00">2023-08-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-13 15:57:20" itemprop="dateModified" datetime="2023-08-13T15:57:20+08:00">2023-08-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="TCP网络编程本质"><a href="#TCP网络编程本质" class="headerlink" title="TCP网络编程本质"></a>TCP网络编程本质</h1><p>TCP网络编程最本质是处理三个半事件</p>
<ul>
<li>连接建立:服务器accept（被动）接受连接，客户端connect（主动）发起连接</li>
<li>连接断开:主动断开（close、shutdown），被动断开(read返回0)</li>
<li>消息到达:文件描述符可读</li>
<li>消息发送完毕:这算半个。对于低流量的服务，可不必关心这个事件;这里的发送完毕是指数据写入操作系统缓冲区，将由TCP协议栈负责数据的发送与重传不代表对方已经接收到数据。</li>
</ul>
<p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230808151011083.png" alt="image-20230808151011083"></p>
<img src="/2023/08/08/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230808151011083.png" class title="This is an test image">

<p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230808152449591.png" alt="image-20230808152449591"></p>
<p>也是基于对象编程思想</p>
<h1 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h1><ul>
<li>one loop per thread意思是说每个线程最多只能有一个EventLoop对象。</li>
<li>EventLoop对象构造的时候，会检查当前线程是否己经创建了具他EventLoop,如果已创建，终止程序（LOG FATAL)</li>
<li>EventLoop构造函数会记住本对象所属线程（threadld_)</li>
<li>创建了EventLoop对象的线程称为lO线程，其功能是运行事件循环（EventLoop::loop)</li>
</ul>
<h2 id="EventLoop-h部分"><a href="#EventLoop-h部分" class="headerlink" title="EventLoop.h部分"></a>EventLoop.h部分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">class Channel;</span><br><span class="line">class Poller;</span><br><span class="line">class TimerQueue;</span><br><span class="line"></span><br><span class="line">///</span><br><span class="line">/// Reactor, at most one per thread.</span><br><span class="line">///</span><br><span class="line">/// This is an interface class, so don&#x27;t expose too much details.</span><br><span class="line">class EventLoop : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  typedef std::function&lt;void()&gt; Functor;</span><br><span class="line"></span><br><span class="line">  EventLoop();</span><br><span class="line">  ~EventLoop();  // force out-line dtor, for std::unique_ptr members.</span><br><span class="line">  void updateChannel(Channel* channel);//在Poller中添加或更新通道</span><br><span class="line">  void removeChannel(Channel* channel);//从Poller中移除通道</span><br><span class="line">  // pid_t threadId() const &#123; return threadId_; &#125;</span><br><span class="line">  void assertInLoopThread()</span><br><span class="line">  &#123;</span><br><span class="line">    if (!isInLoopThread())</span><br><span class="line">    &#123;</span><br><span class="line">      abortNotInLoopThread();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  bool isInLoopThread() const &#123; return threadId_ == CurrentThread::tid(); &#125;</span><br><span class="line">  // bool callingPendingFunctors() const &#123; return callingPendingFunctors_; &#125;</span><br><span class="line">  bool eventHandling() const &#123; return eventHandling_; &#125;</span><br><span class="line"> private:</span><br><span class="line">  void abortNotInLoopThread();</span><br><span class="line">  void handleRead();  // waked up</span><br><span class="line">  void doPendingFunctors();</span><br><span class="line"></span><br><span class="line">  void printActiveChannels() const; // DEBUG</span><br><span class="line">  typedef std::vector&lt;Channel*&gt; ChannelList;</span><br><span class="line"></span><br><span class="line">  bool looping_; /* atomic */</span><br><span class="line">  std::atomic&lt;bool&gt; quit_;</span><br><span class="line">  bool eventHandling_; /* atomic */</span><br><span class="line">  bool callingPendingFunctors_; /* atomic */</span><br><span class="line">  int64_t iteration_;</span><br><span class="line">  const pid_t threadId_;//当前对象所属线程id</span><br><span class="line">  Timestamp pollReturnTime_;//调用poll返回的时间戳</span><br><span class="line">  std::unique_ptr&lt;Poller&gt; poller_;</span><br><span class="line">  std::unique_ptr&lt;TimerQueue&gt; timerQueue_;</span><br><span class="line">  ChannelList activeChannels_;//Poller返回的活动通道</span><br><span class="line">  Channel* currentActiveChannel_;//当前正在处理的活动通道</span><br><span class="line"></span><br><span class="line">  mutable MutexLock mutex_;</span><br><span class="line">  std::vector&lt;Functor&gt; pendingFunctors_ GUARDED_BY(mutex_);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h2 id="EventLoop-cc部分"><a href="#EventLoop-cc部分" class="headerlink" title="EventLoop.cc部分"></a>EventLoop.cc部分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">namespace</span><br><span class="line">&#123;</span><br><span class="line">//当前线程EventLoop对象指针</span><br><span class="line">//线程局部存储</span><br><span class="line">__thread EventLoop* t_loopInThisThread = 0;//__thread表示每个线程都有这样一个对象</span><br><span class="line"></span><br><span class="line">const int kPollTimeMs = 10000;</span><br><span class="line"></span><br><span class="line">int createEventfd()</span><br><span class="line">&#123;</span><br><span class="line">  int evtfd = ::eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC);</span><br><span class="line">  if (evtfd &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSERR &lt;&lt; &quot;Failed in eventfd&quot;;</span><br><span class="line">    abort();</span><br><span class="line">  &#125;</span><br><span class="line">  return evtfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma GCC diagnostic ignored &quot;-Wold-style-cast&quot;</span><br><span class="line">class IgnoreSigPipe</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  IgnoreSigPipe()</span><br><span class="line">  &#123;</span><br><span class="line">    ::signal(SIGPIPE, SIG_IGN);</span><br><span class="line">    // LOG_TRACE &lt;&lt; &quot;Ignore SIGPIPE&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">#pragma GCC diagnostic error &quot;-Wold-style-cast&quot;</span><br><span class="line"></span><br><span class="line">IgnoreSigPipe initObj;</span><br><span class="line">&#125;  // namespace 代码被放置在了匿名的 namespace 中。这意味着其中的内容只对当前文件中的代码可见，不会对其他文件中的代码造成影响。这在一定程度上隐藏了实现细节，限制了作用域，并且通过将 IgnoreSigPipe 类声明为 private，限制了类在文件之外的可见性。这样可以帮助控制代码的组织和维护，并减少了潜在的命名冲突。</span><br><span class="line">EventLoop* EventLoop::getEventLoopOfCurrentThread()</span><br><span class="line">&#123;</span><br><span class="line">  return t_loopInThisThread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventLoop::EventLoop()</span><br><span class="line">  : looping_(false),</span><br><span class="line">    quit_(false),</span><br><span class="line">    eventHandling_(false),</span><br><span class="line">    callingPendingFunctors_(false),</span><br><span class="line">    iteration_(0),</span><br><span class="line">    threadId_(CurrentThread::tid()),</span><br><span class="line">    poller_(Poller::newDefaultPoller(this)),</span><br><span class="line">    timerQueue_(new TimerQueue(this)),</span><br><span class="line">    wakeupFd_(createEventfd()),</span><br><span class="line">    wakeupChannel_(new Channel(this, wakeupFd_)),</span><br><span class="line">    currentActiveChannel_(NULL)</span><br><span class="line">&#123;</span><br><span class="line">  LOG_DEBUG &lt;&lt; &quot;EventLoop created &quot; &lt;&lt; this &lt;&lt; &quot; in thread &quot; &lt;&lt; threadId_;</span><br><span class="line">  //如果当前线程已经创建了EventLoop对象，终止（LOG_FATAL）</span><br><span class="line">  if (t_loopInThisThread)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_FATAL &lt;&lt; &quot;Another EventLoop &quot; &lt;&lt; t_loopInThisThread</span><br><span class="line">              &lt;&lt; &quot; exists in this thread &quot; &lt;&lt; threadId_;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    t_loopInThisThread = this;</span><br><span class="line">  &#125;</span><br><span class="line">  wakeupChannel_-&gt;setReadCallback(</span><br><span class="line">      std::bind(&amp;EventLoop::handleRead, this));</span><br><span class="line">  // we are always reading the wakeupfd</span><br><span class="line">  wakeupChannel_-&gt;enableReading();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventLoop::~EventLoop()</span><br><span class="line">&#123;</span><br><span class="line">  LOG_DEBUG &lt;&lt; &quot;EventLoop &quot; &lt;&lt; this &lt;&lt; &quot; of thread &quot; &lt;&lt; threadId_</span><br><span class="line">            &lt;&lt; &quot; destructs in thread &quot; &lt;&lt; CurrentThread::tid();</span><br><span class="line">  wakeupChannel_-&gt;disableAll();</span><br><span class="line">  wakeupChannel_-&gt;remove();</span><br><span class="line">  ::close(wakeupFd_);</span><br><span class="line">  t_loopInThisThread = NULL;</span><br><span class="line">&#125;</span><br><span class="line">//事件循环，该函数不能跨线程调用</span><br><span class="line">//只能在创建该对象的线程中调用</span><br><span class="line">void EventLoop::loop()</span><br><span class="line">&#123;</span><br><span class="line">  assert(!looping_);</span><br><span class="line">  assertInLoopThread();//断言当前处于创建该对象的线程中</span><br><span class="line">  looping_ = true;</span><br><span class="line">  quit_ = false;  // FIXME: what if someone calls quit() before loop() ?</span><br><span class="line">  LOG_TRACE &lt;&lt; &quot;EventLoop &quot; &lt;&lt; this &lt;&lt; &quot; start looping&quot;;</span><br><span class="line"></span><br><span class="line">  while (!quit_)</span><br><span class="line">  &#123;</span><br><span class="line">    activeChannels_.clear();</span><br><span class="line">    pollReturnTime_ = poller_-&gt;poll(kPollTimeMs, &amp;activeChannels_);</span><br><span class="line">    ++iteration_;</span><br><span class="line">    if (Logger::logLevel() &lt;= Logger::TRACE)</span><br><span class="line">    &#123;</span><br><span class="line">      printActiveChannels();</span><br><span class="line">    &#125;</span><br><span class="line">    // TODO sort channel by priority</span><br><span class="line">    eventHandling_ = true;</span><br><span class="line">    for (Channel* channel : activeChannels_)</span><br><span class="line">    &#123;</span><br><span class="line">      currentActiveChannel_ = channel;</span><br><span class="line">      currentActiveChannel_-&gt;handleEvent(pollReturnTime_);</span><br><span class="line">    &#125;</span><br><span class="line">    currentActiveChannel_ = NULL;</span><br><span class="line">    eventHandling_ = false;</span><br><span class="line">    doPendingFunctors();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LOG_TRACE &lt;&lt; &quot;EventLoop &quot; &lt;&lt; this &lt;&lt; &quot; stop looping&quot;;</span><br><span class="line">  looping_ = false;</span><br><span class="line">&#125;</span><br><span class="line">void EventLoop::updateChannel(Channel* channel)</span><br><span class="line">&#123;</span><br><span class="line">  assert(channel-&gt;ownerLoop() == this);</span><br><span class="line">  assertInLoopThread();</span><br><span class="line">  poller_-&gt;updateChannel(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void EventLoop::removeChannel(Channel* channel)</span><br><span class="line">&#123;</span><br><span class="line">  assert(channel-&gt;ownerLoop() == this);</span><br><span class="line">  assertInLoopThread();</span><br><span class="line">  if (eventHandling_)</span><br><span class="line">  &#123;</span><br><span class="line">    assert(currentActiveChannel_ == channel ||</span><br><span class="line">        std::find(activeChannels_.begin(), activeChannels_.end(), channel) == activeChannels_.end());</span><br><span class="line">  &#125;</span><br><span class="line">  poller_-&gt;removeChannel(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool EventLoop::hasChannel(Channel* channel)</span><br><span class="line">&#123;</span><br><span class="line">  assert(channel-&gt;ownerLoop() == this);</span><br><span class="line">  assertInLoopThread();</span><br><span class="line">  return poller_-&gt;hasChannel(channel);</span><br><span class="line">&#125;</span><br><span class="line">//终止程序</span><br><span class="line">void EventLoop::abortNotInLoopThread()</span><br><span class="line">&#123;</span><br><span class="line">  LOG_FATAL &lt;&lt; &quot;EventLoop::abortNotInLoopThread - EventLoop &quot; &lt;&lt; this</span><br><span class="line">            &lt;&lt; &quot; was created in threadId_ = &quot; &lt;&lt; threadId_</span><br><span class="line">            &lt;&lt; &quot;, current thread id = &quot; &lt;&lt;  CurrentThread::tid();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="muduo网络库相关类图的关系"><a href="#muduo网络库相关类图的关系" class="headerlink" title="muduo网络库相关类图的关系"></a>muduo网络库相关类图的关系</h1><p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230809104948379.png" alt="image-20230809104948379"></p>
<img src="/2023/08/08/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230809104948379.png" class title="This is an test image">

<p>白色的是外部类，对外是可见的，黑色的是内部类，对外是不可见的</p>
<p>Poller是muduo库唯一一个用面向对象封装的，3个都是纯虚函数。</p>
<p>EventLoop和Poller是组合关系，<strong>一个EventLoop包含一个Poller</strong>，并且Poller生存周期由EventLoop控制，EventLoop的loop函数是调用Poller的poll函数实现的。</p>
<p>Channel是对IO事件的注册与响应的封装，handleEvent对所发生的IO事件进行处理，当调用Channel的update来注册和更新IO的可读可写事件时候，又会调用到EventLoop的updateChannel函数，从而又调用了Poller的updateChannel，相当于把Channel注册到Poller当中，或者说将文件描述符的可读可写事件注册到Poller，<strong>一个EventLoop包含多个Channel</strong>，也就是说可以用来捕捉多个通道的可读可写事件，一对多，<strong>聚合关系</strong>，也就是说不负责Channel生存期控制，并且Channel不拥有文件描述符，也就是说当它销毁的时候不close关闭文件描述符。Channel跟TcpConnection，Acceptor，Connector是组合关系，并且Channel生存周期由他们控制。</p>
<p>FileDescriptor不是一个类，跟Channel是关联关系，<strong>一对一</strong>，<strong>一个EventLoop有多个fd</strong>,FileDescriptor是由Socket拥有的，生存周期由套接字控制。</p>
<p>Acceptor是对被动连接的抽象，关注的是监听套接字的可读事件，这个事件由Channel的handleEvent注册，从而调用了handleRead，是基于对象的编程思想，回调了handleRead。</p>
<p>Connector是对主动连接的抽象，与Acceptor差不多。不管是被动连接还是主动成功后，都会得到一个已连接套接字，对已连接套接字的抽象就是TcpConnection，TcpServer和Acceptor是组合关系，Acceptor生存期由TcpServer控制，但是一个TcpServer有多个TcpConnection，是聚合关系，但是不控制生存期。</p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><ul>
<li>Channel是selectable lO channel，负责注册与响应IO事件，它不拥有file descriptor。</li>
<li>Channel是Acceptor、Connector、EventLoopTimerQueue、TcpConnection的成员，生命期由后者控制。</li>
</ul>
<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230809113131684.png" alt="image-20230809113131684"></p>
<img src="/2023/08/08/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230809113131684.png" class title="This is an test image">

<p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230809163337743.png" alt="image-20230809163337743"></p>
<img src="/2023/08/08/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230809163337743.png" class title="This is an test image">

<h2 id="Channel-h"><a href="#Channel-h" class="headerlink" title="Channel.h"></a>Channel.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">class EventLoop;</span><br><span class="line"></span><br><span class="line">///</span><br><span class="line">/// A selectable I/O channel.</span><br><span class="line">///</span><br><span class="line">/// This class doesn&#x27;t own the file descriptor.</span><br><span class="line">/// The file descriptor could be a socket,</span><br><span class="line">/// an eventfd, a timerfd, or a signalfd</span><br><span class="line">class Channel : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  typedef std::function&lt;void()&gt; EventCallback;</span><br><span class="line">  typedef std::function&lt;void(Timestamp)&gt; ReadEventCallback;</span><br><span class="line"></span><br><span class="line">  Channel(EventLoop* loop, int fd);</span><br><span class="line">  ~Channel();</span><br><span class="line"></span><br><span class="line">  void handleEvent(Timestamp receiveTime);</span><br><span class="line">  void setReadCallback(ReadEventCallback cb)</span><br><span class="line">  &#123; readCallback_ = std::move(cb); &#125;</span><br><span class="line">  void setWriteCallback(EventCallback cb)</span><br><span class="line">  &#123; writeCallback_ = std::move(cb); &#125;</span><br><span class="line">  void setCloseCallback(EventCallback cb)</span><br><span class="line">  &#123; closeCallback_ = std::move(cb); &#125;</span><br><span class="line">  void setErrorCallback(EventCallback cb)</span><br><span class="line">  &#123; errorCallback_ = std::move(cb); &#125;</span><br><span class="line"></span><br><span class="line">  /// Tie this channel to the owner object managed by shared_ptr,</span><br><span class="line">  /// prevent the owner object being destroyed in handleEvent.</span><br><span class="line">  void tie(const std::shared_ptr&lt;void&gt;&amp;);</span><br><span class="line"></span><br><span class="line">  int fd() const &#123; return fd_; &#125;</span><br><span class="line">  int events() const &#123; return events_; &#125;</span><br><span class="line">  void set_revents(int revt) &#123; revents_ = revt; &#125; // used by pollers</span><br><span class="line">  // int revents() const &#123; return revents_; &#125;</span><br><span class="line">  bool isNoneEvent() const &#123; return events_ == kNoneEvent; &#125;</span><br><span class="line"></span><br><span class="line">  void enableReading() &#123; events_ |= kReadEvent; update(); &#125;</span><br><span class="line">  void disableReading() &#123; events_ &amp;= ~kReadEvent; update(); &#125;</span><br><span class="line">  void enableWriting() &#123; events_ |= kWriteEvent; update(); &#125;</span><br><span class="line">  void disableWriting() &#123; events_ &amp;= ~kWriteEvent; update(); &#125;</span><br><span class="line">  void disableAll() &#123; events_ = kNoneEvent; update(); &#125;</span><br><span class="line">  bool isWriting() const &#123; return events_ &amp; kWriteEvent; &#125;</span><br><span class="line">  bool isReading() const &#123; return events_ &amp; kReadEvent; &#125;</span><br><span class="line"></span><br><span class="line">  // for Poller</span><br><span class="line">  int index() &#123; return index_; &#125;</span><br><span class="line">  void set_index(int idx) &#123; index_ = idx; &#125;</span><br><span class="line"></span><br><span class="line">  // for debug</span><br><span class="line">  string reventsToString() const;</span><br><span class="line">  string eventsToString() const;</span><br><span class="line"></span><br><span class="line">  void doNotLogHup() &#123; logHup_ = false; &#125;</span><br><span class="line"></span><br><span class="line">  EventLoop* ownerLoop() &#123; return loop_; &#125;</span><br><span class="line">  void remove();</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  static string eventsToString(int fd, int ev);</span><br><span class="line"></span><br><span class="line">  void update();</span><br><span class="line">  void handleEventWithGuard(Timestamp receiveTime);</span><br><span class="line"></span><br><span class="line">  static const int kNoneEvent;</span><br><span class="line">  static const int kReadEvent;</span><br><span class="line">  static const int kWriteEvent;</span><br><span class="line"></span><br><span class="line">  EventLoop* loop_;//所属EventLoop</span><br><span class="line">  const int  fd_;//文件描述符，但不负责关闭</span><br><span class="line">  int        events_;//关注的事件</span><br><span class="line">  int        revents_; // it&#x27;s the received event types of epoll or poll，poll/epoll返回的事件</span><br><span class="line">  int        index_; // used by Poller.表示在poll的事件数组中的序号</span><br><span class="line">  bool       logHup_;</span><br><span class="line"></span><br><span class="line">  std::weak_ptr&lt;void&gt; tie_;</span><br><span class="line">  bool tied_;</span><br><span class="line">  bool eventHandling_;//是否处于处理事件中</span><br><span class="line">  bool addedToLoop_;</span><br><span class="line">  ReadEventCallback readCallback_;</span><br><span class="line">  EventCallback writeCallback_;</span><br><span class="line">  EventCallback closeCallback_;</span><br><span class="line">  EventCallback errorCallback_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br></pre></td></tr></table></figure>

<h2 id="Channel-cc"><a href="#Channel-cc" class="headerlink" title="Channel.cc"></a>Channel.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">const int Channel::kNoneEvent = 0;</span><br><span class="line">const int Channel::kReadEvent = POLLIN | POLLPRI;</span><br><span class="line">const int Channel::kWriteEvent = POLLOUT;</span><br><span class="line"></span><br><span class="line">Channel::Channel(EventLoop* loop, int fd__)</span><br><span class="line">  : loop_(loop),</span><br><span class="line">    fd_(fd__),</span><br><span class="line">    events_(0),</span><br><span class="line">    revents_(0),</span><br><span class="line">    index_(-1),</span><br><span class="line">    logHup_(true),</span><br><span class="line">    tied_(false),</span><br><span class="line">    eventHandling_(false),</span><br><span class="line">    addedToLoop_(false)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Channel::~Channel()</span><br><span class="line">&#123;</span><br><span class="line">  assert(!eventHandling_);</span><br><span class="line">  assert(!addedToLoop_);</span><br><span class="line">  if (loop_-&gt;isInLoopThread())</span><br><span class="line">  &#123;</span><br><span class="line">    assert(!loop_-&gt;hasChannel(this));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Channel::tie(const std::shared_ptr&lt;void&gt;&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">  tie_ = obj;</span><br><span class="line">  tied_ = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Channel::update()</span><br><span class="line">&#123;</span><br><span class="line">  addedToLoop_ = true;</span><br><span class="line">  loop_-&gt;updateChannel(this);</span><br><span class="line">&#125;</span><br><span class="line">//调用这个函数之前确保调用disableAll</span><br><span class="line">void Channel::remove()</span><br><span class="line">&#123;</span><br><span class="line">  assert(isNoneEvent());</span><br><span class="line">  addedToLoop_ = false;</span><br><span class="line">  loop_-&gt;removeChannel(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Channel::handleEvent(Timestamp receiveTime)</span><br><span class="line">&#123;</span><br><span class="line">  std::shared_ptr&lt;void&gt; guard;</span><br><span class="line">  if (tied_)</span><br><span class="line">  &#123;</span><br><span class="line">    guard = tie_.lock();//tie_.lock() 是用于从 std::weak_ptr 类型对象获取其关联的 std::shared_ptr 对象的方法</span><br><span class="line">    //在 Channel::handleEvent() 函数中，tie_.lock() 被用来获取与 tie_ 关联的 std::shared_ptr&lt;void&gt;，如果该 std::shared_ptr 有效，则执行相关的事件处理。这种方式可以确保在事件处理期间，与 Channel 关联的对象仍然有效，避免了因为对象被释放而导致的问题。</span><br><span class="line">    if (guard)</span><br><span class="line">    &#123;</span><br><span class="line">      handleEventWithGuard(receiveTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    handleEventWithGuard(receiveTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">void Channel::handleEventWithGuard(Timestamp receiveTime)</span><br><span class="line">&#123;</span><br><span class="line">  eventHandling_ = true;</span><br><span class="line">  LOG_TRACE &lt;&lt; reventsToString();</span><br><span class="line">  if ((revents_ &amp; POLLHUP) &amp;&amp; !(revents_ &amp; POLLIN))//如果发生了挂起事件，并且没有发生可读事件</span><br><span class="line">  &#123;</span><br><span class="line">    if (logHup_)</span><br><span class="line">    &#123;</span><br><span class="line">      LOG_WARN &lt;&lt; &quot;fd = &quot; &lt;&lt; fd_ &lt;&lt; &quot; Channel::handle_event() POLLHUP&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    if (closeCallback_) closeCallback_();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (revents_ &amp; POLLNVAL)//fd not open</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_WARN &lt;&lt; &quot;fd = &quot; &lt;&lt; fd_ &lt;&lt; &quot; Channel::handle_event() POLLNVAL&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (revents_ &amp; (POLLERR | POLLNVAL))</span><br><span class="line">  &#123;</span><br><span class="line">    if (errorCallback_) errorCallback_();</span><br><span class="line">  &#125;</span><br><span class="line">  if (revents_ &amp; (POLLIN | POLLPRI | POLLRDHUP))</span><br><span class="line">  &#123;</span><br><span class="line">    if (readCallback_) readCallback_(receiveTime);</span><br><span class="line">  &#125;</span><br><span class="line">  if (revents_ &amp; POLLOUT)</span><br><span class="line">  &#123;</span><br><span class="line">    if (writeCallback_) writeCallback_();</span><br><span class="line">  &#125;</span><br><span class="line">  eventHandling_ = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string Channel::reventsToString() const</span><br><span class="line">&#123;</span><br><span class="line">  return eventsToString(fd_, revents_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string Channel::eventsToString() const</span><br><span class="line">&#123;</span><br><span class="line">  return eventsToString(fd_, events_);</span><br><span class="line">&#125;</span><br><span class="line">//用来调试的，发生了什么事件</span><br><span class="line">string Channel::eventsToString(int fd, int ev)</span><br><span class="line">&#123;</span><br><span class="line">  std::ostringstream oss;</span><br><span class="line">  oss &lt;&lt; fd &lt;&lt; &quot;: &quot;;</span><br><span class="line">  if (ev &amp; POLLIN)</span><br><span class="line">    oss &lt;&lt; &quot;IN &quot;;</span><br><span class="line">  if (ev &amp; POLLPRI)</span><br><span class="line">    oss &lt;&lt; &quot;PRI &quot;;</span><br><span class="line">  if (ev &amp; POLLOUT)</span><br><span class="line">    oss &lt;&lt; &quot;OUT &quot;;</span><br><span class="line">  if (ev &amp; POLLHUP)</span><br><span class="line">    oss &lt;&lt; &quot;HUP &quot;;</span><br><span class="line">  if (ev &amp; POLLRDHUP)</span><br><span class="line">    oss &lt;&lt; &quot;RDHUP &quot;;</span><br><span class="line">  if (ev &amp; POLLERR)</span><br><span class="line">    oss &lt;&lt; &quot;ERR &quot;;</span><br><span class="line">  if (ev &amp; POLLNVAL)</span><br><span class="line">    oss &lt;&lt; &quot;NVAL &quot;;</span><br><span class="line"></span><br><span class="line">  return oss.str();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Channel::tie(const std::shared_ptr&lt;void&gt;&amp; obj)</code> 函数的功能是在 <code>Channel</code> 类中设置一个关联对象，以便在事件处理期间使用。这个函数在事件循环中处理事件时很有用，可以保证关联的对象在事件处理期间有效，避免在处理过程中被释放导致的错误。</p>
<p>在具体代码中，函数的作用如下：</p>
<ol>
<li>接受一个 <code>std::shared_ptr&lt;void&gt;</code> 类型的参数 <code>obj</code>，这是一个指向任意类型的 <code>std::shared_ptr</code> 智能指针。<code>std::shared_ptr</code> 是一个可以共享拥有资源所有权的智能指针，它可以确保资源在不再需要时自动释放。</li>
<li>将传入的 <code>obj</code> 赋值给成员变量 <code>tie_</code>，这是一个 <code>std::weak_ptr&lt;void&gt;</code> 类型的成员变量。<code>std::weak_ptr</code> 是一种弱引用指针，它不会增加资源的引用计数，也不会阻止资源的释放。</li>
<li>将成员变量 <code>tied_</code> 设置为 <code>true</code>，表示已经关联了一个对象。</li>
</ol>
<p>函数的目的是在事件处理期间保证相关联的对象不会被提前释放。在事件处理函数 <code>Channel::handleEvent()</code> 中，首先会检查 <code>tied_</code> 是否为 <code>true</code>，如果是，就会尝试使用 <code>std::shared_ptr&lt;void&gt;</code> 类型的 <code>guard</code> 对象来保持关联对象的有效性。这样可以防止在处理事件时，关联对象已经被释放导致的问题。</p>
<p>总之，<code>Channel::tie()</code> 函数允许用户将一个智能指针与 <code>Channel</code> 对象关联起来，以确保在事件处理期间关联对象不会被过早地释放，从而增强了代码的健壮性。这在多线程环境中尤其有用，可以避免悬空指针和资源竞争等问题。</p>
<h2 id="Poller-h"><a href="#Poller-h" class="headerlink" title="Poller.h"></a>Poller.h</h2><p>是面向对象实现的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">class Channel;</span><br><span class="line"></span><br><span class="line">///</span><br><span class="line">/// Base class for IO Multiplexing</span><br><span class="line">///</span><br><span class="line">/// This class doesn&#x27;t own the Channel objects.</span><br><span class="line">class Poller : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  typedef std::vector&lt;Channel*&gt; ChannelList;</span><br><span class="line"></span><br><span class="line">  Poller(EventLoop* loop);</span><br><span class="line">  virtual ~Poller();</span><br><span class="line"></span><br><span class="line">  /// Polls the I/O events.</span><br><span class="line">  /// Must be called in the loop thread.</span><br><span class="line">  virtual Timestamp poll(int timeoutMs, ChannelList* activeChannels) = 0;</span><br><span class="line"></span><br><span class="line">  /// Changes the interested I/O events.</span><br><span class="line">  /// Must be called in the loop thread.</span><br><span class="line">  virtual void updateChannel(Channel* channel) = 0;</span><br><span class="line"></span><br><span class="line">  /// Remove the channel, when it destructs.</span><br><span class="line">  /// Must be called in the loop thread.</span><br><span class="line">  virtual void removeChannel(Channel* channel) = 0;</span><br><span class="line"></span><br><span class="line">  virtual bool hasChannel(Channel* channel) const;</span><br><span class="line"></span><br><span class="line">  static Poller* newDefaultPoller(EventLoop* loop);</span><br><span class="line"></span><br><span class="line">  void assertInLoopThread() const</span><br><span class="line">  &#123;</span><br><span class="line">    ownerLoop_-&gt;assertInLoopThread();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> protected:</span><br><span class="line">  typedef std::map&lt;int, Channel*&gt; ChannelMap;</span><br><span class="line">  ChannelMap channels_;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  EventLoop* ownerLoop_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br></pre></td></tr></table></figure>

<p>在代码片段中，<code>class Channel;</code> 的写法在 <code>namespace muduo::net</code> 命名空间中的作用是进行前向声明（forward declaration）。</p>
<p>前向声明是一种在编译器还未看到实际类定义的情况下，告诉编译器某个类的存在的方式。这在处理循环引用（circular dependencies）或减少编译依赖性时非常有用。在这个特定的情况下，前向声明的目的是在 <code>Poller</code> 类中声明一个指向 <code>Channel</code> 类的指针或引用，而不需要知道 <code>Channel</code> 类的完整定义。</p>
<p>具体来说，<code>class Channel;</code> 的作用是：</p>
<ol>
<li><strong>解决编译依赖性问题：</strong> 如果在 <code>Poller</code> 类中包含了 <code>Channel</code> 类的完整定义，那么在编译 <code>Poller</code> 类时，编译器会需要知道 <code>Channel</code> 类的所有细节。而如果 <code>Channel</code> 类也依赖于 <code>Poller</code> 类，就会导致循环依赖，从而编译错误。通过使用前向声明，<code>Poller</code> 类可以在不知道 <code>Channel</code> 类的完整定义的情况下编译，从而解决了这种依赖性问题。</li>
<li><strong>降低编译时间：</strong> 前向声明可以减少编译时间，因为编译器不需要读取和处理完整的 <code>Channel</code> 类定义，而只需要知道有一个名为 <code>Channel</code> 的类存在即可。</li>
<li><strong>避免不必要的头文件包含：</strong> 如果不需要在 <code>Poller</code> 类中使用 <code>Channel</code> 类的成员变量或方法，而只需要一个指针或引用，那么可以通过前向声明避免包含 <code>Channel</code> 类的完整头文件，从而减少编译依赖和编译时间。</li>
</ol>
<p>综上所述，<code>class Channel;</code> 的写法在这个上下文中用于进行前向声明，以解决编译依赖性问题和提高编译效率。这是 C++ 中常见的用法，可以帮助代码模块化和降低耦合度。</p>
<h2 id="Poller-cc"><a href="#Poller-cc" class="headerlink" title="Poller.cc"></a>Poller.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">Poller::Poller(EventLoop* loop)</span><br><span class="line">  : ownerLoop_(loop)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Poller::~Poller() = default;</span><br><span class="line"></span><br><span class="line">bool Poller::hasChannel(Channel* channel) const</span><br><span class="line">&#123;</span><br><span class="line">  assertInLoopThread();</span><br><span class="line">  ChannelMap::const_iterator it = channels_.find(channel-&gt;fd());</span><br><span class="line">  return it != channels_.end() &amp;&amp; it-&gt;second == channel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="PollPoller-h"><a href="#PollPoller-h" class="headerlink" title="PollPoller.h"></a>PollPoller.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">struct pollfd;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">///</span><br><span class="line">/// IO Multiplexing with poll(2).</span><br><span class="line">///</span><br><span class="line">class PollPoller : public Poller</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line"></span><br><span class="line">  PollPoller(EventLoop* loop);</span><br><span class="line">  ~PollPoller() override;</span><br><span class="line"></span><br><span class="line">  Timestamp poll(int timeoutMs, ChannelList* activeChannels) override;</span><br><span class="line">  void updateChannel(Channel* channel) override;</span><br><span class="line">  void removeChannel(Channel* channel) override;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  void fillActiveChannels(int numEvents,</span><br><span class="line">                          ChannelList* activeChannels) const;</span><br><span class="line"></span><br><span class="line">  typedef std::vector&lt;struct pollfd&gt; PollFdList;</span><br><span class="line">  PollFdList pollfds_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br></pre></td></tr></table></figure>

<h2 id="PollPoller-cc"><a href="#PollPoller-cc" class="headerlink" title="PollPoller.cc"></a>PollPoller.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">PollPoller::PollPoller(EventLoop* loop)</span><br><span class="line">  : Poller(loop)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PollPoller::~PollPoller() = default;</span><br><span class="line"></span><br><span class="line">Timestamp PollPoller::poll(int timeoutMs, ChannelList* activeChannels)</span><br><span class="line">&#123;</span><br><span class="line">  // XXX pollfds_ shouldn&#x27;t change</span><br><span class="line">  int numEvents = ::poll(&amp;*pollfds_.begin(), pollfds_.size(), timeoutMs);</span><br><span class="line">  int savedErrno = errno;</span><br><span class="line">  Timestamp now(Timestamp::now());</span><br><span class="line">  if (numEvents &gt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_TRACE &lt;&lt; numEvents &lt;&lt; &quot; events happened&quot;;</span><br><span class="line">    fillActiveChannels(numEvents, activeChannels);//loop调用，pollReturnTime_ = poller_-&gt;poll(kPollTimeMs, &amp;activeChannels_);是一个地址传递</span><br><span class="line">  &#125;</span><br><span class="line">  else if (numEvents == 0)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_TRACE &lt;&lt; &quot; nothing happened&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    if (savedErrno != EINTR)</span><br><span class="line">    &#123;</span><br><span class="line">      errno = savedErrno;</span><br><span class="line">      LOG_SYSERR &lt;&lt; &quot;PollPoller::poll()&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PollPoller::fillActiveChannels(int numEvents,</span><br><span class="line">                                    ChannelList* activeChannels) const</span><br><span class="line">&#123;</span><br><span class="line">  for (PollFdList::const_iterator pfd = pollfds_.begin();</span><br><span class="line">      pfd != pollfds_.end() &amp;&amp; numEvents &gt; 0; ++pfd)</span><br><span class="line">  &#123;</span><br><span class="line">    if (pfd-&gt;revents &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      --numEvents;</span><br><span class="line">      //声明了一个常量迭代器ch</span><br><span class="line">      ChannelMap::const_iterator ch = channels_.find(pfd-&gt;fd);</span><br><span class="line">      assert(ch != channels_.end());</span><br><span class="line">      Channel* channel = ch-&gt;second;//second成员是std::map中键值对的值部分</span><br><span class="line">      assert(channel-&gt;fd() == pfd-&gt;fd);</span><br><span class="line">      channel-&gt;set_revents(pfd-&gt;revents);</span><br><span class="line">      // pfd-&gt;revents = 0;</span><br><span class="line">      activeChannels-&gt;push_back(channel);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//注册和更新事件</span><br><span class="line">void PollPoller::updateChannel(Channel* channel)</span><br><span class="line">&#123;</span><br><span class="line">  Poller::assertInLoopThread();</span><br><span class="line">  LOG_TRACE &lt;&lt; &quot;fd = &quot; &lt;&lt; channel-&gt;fd() &lt;&lt; &quot; events = &quot; &lt;&lt; channel-&gt;events();</span><br><span class="line">  if (channel-&gt;index() &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    //index小于0说明是一个新通道</span><br><span class="line">    // a new one, add to pollfds_</span><br><span class="line">    //断言在 channels_ 容器中不能找到具有与 channel 对象相同文件描述符的 Channel 对象</span><br><span class="line">    assert(channels_.find(channel-&gt;fd()) == channels_.end());</span><br><span class="line">    struct pollfd pfd;</span><br><span class="line">    pfd.fd = channel-&gt;fd();</span><br><span class="line">    pfd.events = static_cast&lt;short&gt;(channel-&gt;events());</span><br><span class="line">    pfd.revents = 0;</span><br><span class="line">    pollfds_.push_back(pfd);</span><br><span class="line">    int idx = static_cast&lt;int&gt;(pollfds_.size())-1;</span><br><span class="line">    channel-&gt;set_index(idx);</span><br><span class="line">    channels_[pfd.fd] = channel;//key是文件描述符，值是channel</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    // update existing one</span><br><span class="line">    assert(channels_.find(channel-&gt;fd()) != channels_.end());</span><br><span class="line">    assert(channels_[channel-&gt;fd()] == channel);</span><br><span class="line">    int idx = channel-&gt;index();</span><br><span class="line">    assert(0 &lt;= idx &amp;&amp; idx &lt; static_cast&lt;int&gt;(pollfds_.size()));</span><br><span class="line">    struct pollfd&amp; pfd = pollfds_[idx];//引用，不需要拷贝</span><br><span class="line">    assert(pfd.fd == channel-&gt;fd() || pfd.fd == -channel-&gt;fd()-1);</span><br><span class="line">    pfd.fd = channel-&gt;fd();</span><br><span class="line">    pfd.events = static_cast&lt;short&gt;(channel-&gt;events());</span><br><span class="line">    pfd.revents = 0;</span><br><span class="line">    //将一个通道暂时更改为不关注事件，但不从Poller中移除该通道</span><br><span class="line">    if (channel-&gt;isNoneEvent())</span><br><span class="line">    &#123;</span><br><span class="line">      // ignore this pollfd</span><br><span class="line">      //暂时忽略该文件描述符的事件</span><br><span class="line">      //这里pfd.fd可以直接设置为-1</span><br><span class="line">      pfd.fd = -channel-&gt;fd()-1;//这样子设置是为了removeChannel优化</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//移除调用removeChannel之前一定要设置成不关注事件，即要先调用isNoneEvent()</span><br><span class="line">void PollPoller::removeChannel(Channel* channel)</span><br><span class="line">&#123;</span><br><span class="line">  Poller::assertInLoopThread();</span><br><span class="line">  LOG_TRACE &lt;&lt; &quot;fd = &quot; &lt;&lt; channel-&gt;fd();</span><br><span class="line">  assert(channels_.find(channel-&gt;fd()) != channels_.end());</span><br><span class="line">  assert(channels_[channel-&gt;fd()] == channel);</span><br><span class="line">  assert(channel-&gt;isNoneEvent());</span><br><span class="line">  int idx = channel-&gt;index();</span><br><span class="line">  assert(0 &lt;= idx &amp;&amp; idx &lt; static_cast&lt;int&gt;(pollfds_.size()));</span><br><span class="line">  const struct pollfd&amp; pfd = pollfds_[idx]; (void)pfd;</span><br><span class="line">  assert(pfd.fd == -channel-&gt;fd()-1 &amp;&amp; pfd.events == channel-&gt;events());</span><br><span class="line">  size_t n = channels_.erase(channel-&gt;fd());</span><br><span class="line">  assert(n == 1); (void)n;</span><br><span class="line">  if (implicit_cast&lt;size_t&gt;(idx) == pollfds_.size()-1)</span><br><span class="line">  &#123;</span><br><span class="line">    //如果是最后一个</span><br><span class="line">    pollfds_.pop_back();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    //这里移除的算法复杂度是O(1)，将待删除元素与最后一个元素交换再pop_back</span><br><span class="line">    int channelAtEnd = pollfds_.back().fd;</span><br><span class="line">    iter_swap(pollfds_.begin()+idx, pollfds_.end()-1);</span><br><span class="line">    if (channelAtEnd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      channelAtEnd = -channelAtEnd-1;</span><br><span class="line">    &#125;</span><br><span class="line">    channels_[channelAtEnd]-&gt;set_index(idx);</span><br><span class="line">    pollfds_.pop_back();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">肖汇林</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">62</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">肖汇林</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
