<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="选择有时候比努力更重要">
<meta property="og:type" content="website">
<meta property="og:title" content="肖汇林的博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="肖汇林的博客">
<meta property="og:description" content="选择有时候比努力更重要">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="肖汇林">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>肖汇林的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖汇林的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/09/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/09/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">Linux高性能服务器编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-09 19:40:17" itemprop="dateCreated datePublished" datetime="2023-07-09T19:40:17+08:00">2023-07-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-11 22:42:56" itemprop="dateModified" datetime="2023-07-11T22:42:56+08:00">2023-07-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第1章TCP-x2F-IP协议族"><a href="#第1章TCP-x2F-IP协议族" class="headerlink" title="第1章	TCP&#x2F;IP协议族"></a>第1章	TCP&#x2F;IP协议族</h1><p>TCP&#x2F;IP协议族是一个四层协议系统，自底而上分别是数据链路层、网络层、传输层和应用层。每一层完成不同的功能，且通过若干协议来实现，上层协议使用下层协议提供的服务，如图1-1所示。</p>
<p><img src="/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230709194157137.png" alt="image-20230709194157137"></p>
<img src="/2023/07/09/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230709194157137.png" class title="This is an test image">

<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>数据链路层两个常用的协议是ARP协议(Address Resolve Protocol，地址解析协议）和RARP协议(Reverse Address Resolve Protocol，逆地址解析协议)。它们实现了IP地址和机器物理地址（通常是MAC地址，以太网、令牌环和802.11无线网络都使用MAC地址）之间的相互转换。</p>
<p>网络层使用IP地址寻址一台机器，而数据链路层使用物理地址寻址一台机器，因此网络层必须先将目标机器的IP地址转化成其物理地址，才能使用数据链路层提供的服务，这就是ARP协议的用途。RARP协议仅用于网络上的某些无盘工作站。因为缺乏存储设备，无盘工作站无法记住自己的IP地址，但它们可以利用网卡上的物理地址来向网络管理者（服务器或网络管理软件）查询自身的IP地址。运行RARP服务的网络管理者通常存有该网络上所有机器的物理地址到IP地址的映射。</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>网络层实现数据包的选路和转发。WAN (Wide Area Network，广域网）通常使用众多分级的路由器来连接分散的主机或LAN (Local Area Network，局域网)，因此，通信的两台主机一般不是直接相连的，而是通过多个中间节点（路由器）连接的。网络层的任务就是选择这些中间节点，以确定两台主机之间的通信路径。同时，网络层对上层协议隐藏了网络拓扑连接的细节，使得在传输层和网络应用程序看来，通信的双方是直接相连的。</p>
<p>网络层最核心的协议是IP协议（Internet Protocol，因特网协议)。IP协议根据数据包的目的IP地址来决定如何投递它。如果数据包不能直接发送给目标主机，那么IP协议就为它寻找一个合适的下一跳(next hop）路由器，并将数据包交付给该路由器来转发。多次重复这一过程，数据包最终到达目标主机，或者由于发送失败而被丢弃。可见，IP协议使用逐跳( hop by hop）的方式确定通信路径。</p>
<p>网络层另外一个重要的协议是ICMP协议(Internet Control Message Protocol，因特网控制报文协议)。它是IP协议的重要补充，主要用于检测网络连接。</p>
<p>需要指出的是，ICMP协议并非严格意义上的网络层协议，因为它使用处于同一层的IP协议提供的服务（一般来说，上层协议使用下层协议提供的服务)。</p>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>传输层为两台主机上的应用程序提供端到端(end to end）的通信。与网络层使用的逐跳通信方式不同，传输层只关心通信的起始端和目的端，而不在乎数据包的中转过程。图1-3展示了传输层和网络层的这种区别。</p>
<p><img src="/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230709194848882.png" alt="image-20230709194848882"></p>
<img src="/2023/07/09/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230709194848882.png" class title="This is an test image">

<p>图1-3中，垂直的实线箭头表示TCP&#x2F;IP协议族各层之间的实体通信（数据包确实是沿着这些线路传递的)，而水平的虚线箭头表示逻辑通信线路。该图中还附带描述了不同物理网络的连接方法。可见，数据链路层（驱动程序）封装了物理网络的电气细节；网络层封装了网络连接的细节；传输层则为应用程序封装了一条端到端的逻辑通信链路，它负责数据的收发、链路的超时重连等。</p>
<p>传输层协议主要有三个:TCP协议、UDP协议和SCTP协议。</p>
<p>TCP协议（Transmission Control Protocol，传输控制协议）为应用层提供可靠的、面向连接的和基于流〈 stream）的服务。TCP协议使用超时重传、数据确认等方式来确保数据包被正确地发送至目的端，因此TCP服务是可靠的。使用TCP协议通信的双方必须先建立TCP连接，并在内核中为该连接维持一些必要的数据结构，比如连接的状态、读写缓冲区,以及诸多定时器等。当通信结束时，双方必须关闭连接以释放这些内核数据。TCP服务是基于流的。基于流的数据没有边界（长度）限制，它源源不断地从通信的一端流入另一端。发送端可以逐个字节地向数据流中写人数据，接收端也可以逐个字节地将它们读出。</p>
<p>UDP协议(User Datagram Protocol，用户数据报协议）则与TCP协议完全相反，它为应用层提供不可靠、无连接和基于数据报的服务。“不可靠”意味着UDP协议无法保证数据从发送端正确地传送到目的端。如果数据在中途丢失，或者目的端通过数据校验发现数据错误而将其丢弃，则UDP协议只是简单地通知应用程序发送失败。因此，使用UDP协议的应用程序通常要自己处理数据确认、超时重传等逻辑。UDP协议是无连接的，即通信双方不保持一个长久的联系，因此应用程序每次发送数据都要明确指定接收端的地址（IP地址等信息)。基于数据报的服务，是相对基于流的服务而言的。每个UDP数据报都有一个长度，接收端必须以该长度为最小单位将其所有内容一次性读出，否则数据将被截断。</p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层负责处理应用程序的逻辑。数据链路层、网络层和传输层负责处理网络通信细节，这部分必须既稳定又高效，因此它们都在内核空间中实现，如图1-1所示。而应用层则在用户空间实现，因为它负责处理众多逻辑，比如文件传输、名称查询和网络管理等。如果应用层也在内核中实现，则会使内核变得非常庞大。当然，也有少数服务器程序是在内核中实现的，这样代码就无须在用户空间和内核空间来回切换（主要是数据的复制)，极大地提高了工作效率。不过这种代码实现起来较复杂，不够灵活，且不便于移植。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>上层协议是如何使用下层协议提供的服务的呢?其实这是通过封装（encapsulation）实现的。应用程序数据在发送到物理网络上之前，将沿着协议栈从上往下依次传递。每层协议都将在上层数据的基础上加上自己的头部信息（有时还包括尾部信息)，以实现该层的功能,这个过程就称为封装，如图1-4所示。</p>
<p><img src="/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230709204438647.png" alt="image-20230709204438647"></p>
<img src="/2023/07/09/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230709204438647.png" class title="This is an test image">

<p>帧才是最终在物理网络上传送的字节序列。</p>
<h2 id="分用"><a href="#分用" class="headerlink" title="分用"></a>分用</h2><p>当帧到达目的主机时，将沿着协议栈自底向上依次传递。各层协议依次处理帧中本层负责的头部数据，以获取所需的信息，并最终将处理后的帧交给目标应用程序。这个过程称为分用(demultiplexing)。分用是依靠头部信息中的类型字段实现的。标准文档RFC 1700定义了所有标识上层协议的类型字段以及每个上层协议对应的数值。图1-7显示了以太网帧的分用过程。</p>
<p><img src="/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230709204638829.png" alt="image-20230709204638829"></p>
<img src="/2023/07/09/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230709204638829.png" class title="This is an test image">

<p>因为IP协议、ARP协议和RARP协议都使用帧传输数据，所以帧的头部需要提供某个字段（具体情况取决于帧的类型）来区分它们。以以太网帧为例，它使用2字节的类型字段来标识上层协议（见图1-6)。如果主机接收到的以太网帧类型字段的值为0x800，则帧的数据部分为IP数据报（见图1-4)，以太网驱动程序就将帧交付给IP模块﹔若类型字段的值为0x806，则帧的数据部分为ARP请求或应答报文，以太网驱动程序就将帧交付给ARP模块;若类型字段的值为0x835，则帧的数据部分为RARP请求或应答报文，以太网驱动程序就将帧交付给RARP模块。</p>
<p>同样，因为ICMP 协议、TCP协议和UDP协议都使用IP协议，所以IP数据报的头部采用16位的协议（protocol）字段来区分它们。</p>
<p>TCP报文段和UDP数据报则通过其头部中的16位的端口号(port number）字段来区分上层应用程序。比如 DNS协议对应的端口号是53，HTTP协议（Hyper-Text TransferProtocol，超文本传送协议）对应的端口号是80。所有知名应用层协议使用的端口号都可在letcl&#x2F;services 文件中找到。</p>
<p>帧通过上述分用步骤后，最终将封装前的原始数据送至目标服务（图1-7中的ARP服务、RARP服务、ICMP服务或者应用程序)。这样，在顶层目标服务看来，封装和分用似乎没有发生过。</p>
<h2 id="Linux下访问DNS服务"><a href="#Linux下访问DNS服务" class="headerlink" title="Linux下访问DNS服务"></a>Linux下访问DNS服务</h2><p>我们要访问DNS服务，就必须先知道DNS服务器的IP地址。Linux使用&#x2F;etc&#x2F;reso1conf文件来存放DNS服务器的IP地址。机器ernest-laptop上，该文件的内容如下:<br><code>#Generated by Network Manager</code><br><code>nameserver 219.239.26.42</code><br><code>narmeserver 124.207.160.106</code><br>其中的两个IP地址分别是首选 DNS服务器地址和备选DNS服务器地址。文件中的注释语句“Generated by Network Manager”告诉我们，这两个DNS服务器地址是由网络管理程序写入的。<br>Linux 下一个常用的访问DNS服务器的客户端程序是host，比如下面的命令是向首选DNS服务器219.239.26.42查询机器<code>www.baidu.com</code>的IP地址:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xiaohuilin@Ubuntu:~$ host -t A www.baidu.com</span><br><span class="line">www.baidu.com is an alias for www.a.shifen.com.</span><br><span class="line">www.a.shifen.com has address 14.119.104.254</span><br><span class="line">www.a.shifen.com has address 14.119.104.189</span><br></pre></td></tr></table></figure>

<p>host命令的输出告诉我们，机器名<code>www.baidu.com</code>是<code>www.a.shifen.com</code>的别名，并且该机器名对应两个IP地址。host命令使用DNS协议和DNS服务器通信，其-t选项告诉DNS 协议使用哪种查询类型。我们这里使用的是A类型，即通过机器的域名获得其IP地址(但实际上返回的资源记录中还包含机器的别名)。关于host命令的详细使用方法，请参考其man手册。</p>
<h1 id="第2章-IP协议详解"><a href="#第2章-IP协议详解" class="headerlink" title="第2章 IP协议详解"></a>第2章 IP协议详解</h1><h2 id="IP服务特点"><a href="#IP服务特点" class="headerlink" title="IP服务特点"></a>IP服务特点</h2><p>IP协议是TCP&#x2F;IP协议族的动力，它为上层协议提供无状态、无连接、不可靠的服务。</p>
<p>无状态（ stateless）是指IP通信双方不同步传输数据的状态信息，因此所有IP数据报的发送、传输和接收都是相互独立、没有上下文关系的。这种服务最大的缺点是无法处理乱序和重复的IP数据报。比如发送端发送出的第N个IP数据报可能比第N+1个IP数据报后到达接收端，而同一个IP数据报也可能经过不同的路径多次到达接收端。在这两种情况下，接收端的IP模块无法检测到乱序和重复，因为这些IP数据报之间没有任何上下文关系。接收端的P模块只要收到了完整的IP数据报（如果是IP分片的话，IP模块将先执行重组)，就将其数据部分（TCP报文段、UDP数据报或者ICMP报文）上交给上层协议。那么从上层协议来看，这些数据就可能是乱序的、重复的。面向连接的协议，比如TCP协议，则能够自己处理乱序的、重复的报文段，它递交给上层协议的内容绝对是有序的、正确的。</p>
<p>虽然IP数据报头部提供了一个标识字段（见后文）用以唯一标识一个IP数据报，但它是被用来处理IP分片和重组的，而不是用来指示接收顺序的。</p>
<p>无状态服务的优点也很明显:简单、高效。我们无须为保持通信的状态而分配一些内核资源，也无须每次传输数据时都携带状态信息。在网络协议中，无状态是很常见的，比如UDP协议和HTTP协议都是无状态协议。以HTTP协议为例，一个浏览器的连续两次网页请求之间没有任何关联，它们将被Web 服务器独立地处理。</p>
<p>无连接(connectionless）是指IP通信双方都不长久地维持对方的任何信息。这样，上层协议每次发送数据的时候，都必须明确指定对方的IP地址。</p>
<p>不可靠是指IP协议不能保证IP数据报准确地到达接收端，它只是承诺尽最大努力(best effort)。很多种情况都能导致IP数据报发送失败。比如，某个中转路由器发现IP数据报在网络上存活的时间太长（根据IP数据报头部字段TTL判断，见后文)，那么它将丢弃之，并返回一个ICMP错误消息（超时错误）给发送端。又比如，接收端发现收到的IP数据报不正确（通过校验机制)，它也将丢弃之，并返回一个ICMP错误消息（IP头部参数错误)给发送端。无论哪种情况，发送端的IP模块一旦检测到IP数据报发送失败，就通知上层协议发送失败，而不会试图重传。因此，使用IP服务的上层协议（比如TCP协议）需要自己实现数据确认、超时重传等机制以达到可靠传输的目的。</p>
<h2 id="IP路由"><a href="#IP路由" class="headerlink" title="IP路由"></a>IP路由</h2><p><img src="/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230711223803620.png" alt="image-20230711223803620"></p>
<img src="/2023/07/09/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230711223803620.png" class title="This is an test image">

<p>我们从右往左来分析图2-3。当IP模块接收到来自数据链路层的IP数据报时，它首先对该数据报的头部做CRC校验，确认无误之后就分析其头部的具体信息。</p>
<p>如果该IP数据报的头部设置了源站选路选项（松散源路由选择或严格源路由选择)，则IP模块调用数据报转发子模块来处理该数据报。如果该IP数据报的头部中目标IP地址是本机的某个IP地址，或者是广播地址，即该数据报是发送给本机的，则IP模块就根据数据报头部中的协议字段来决定将它派发给哪个上层应用（分用)。如果IP模块发现这个数据报不是发送给本机的，则也调用数据报转发子模块来处理该数据报。</p>
<p>数据报转发子模块将首先检测系统是否允许转发，如果不允许,IP模块就将数据报丢弃。如果允许，数据报转发子模块将对该数据报执行一些操作，然后将它交给IP数据报输出子模块。我们将在后面讨论数据报转发的具体过程。</p>
<p>IP数据报应该发送至哪个下一跳路由（或者目标机器)，以及经过哪个网卡来发送，就是P路由过程，即图2-3中“计算下一跳路由”子模块。IP模块实现数据报路由的核心数据结构是路由表。这个表按照数据报的目标IP地址分类，同一类型的IP数据报将被发往相同的下一跳路由器（或者目标机器)。我们将在后面讨论IP路由过程。</p>
<p>IP输出队列中存放的是所有等待发送的IP数据报，其中除了需要转发的IP数据报外，还包括封装了本机上层数据（ICMP报文、TCP报文段和UDP数据报）的IP数据报。</p>
<p>图2-3中的虚线箭头显示了路由表更新的过程。这一过程是指通过路由协议或者route命令调整路由表，使之更适应最新的网络拓扑结构，称为IP路由策略。</p>
<h2 id="IP转发"><a href="#IP转发" class="headerlink" title="IP转发"></a>IP转发</h2><p>对于允许IP数据报转发的系统（主机或路由器)，数据报转发子模块将对期望转发的数据报执行如下操作:<br>1）检查数据报头部的TTL值。如果 TTL值已经是0，则丢弃该数据报。<br>2〉查看数据报头部的严格源路由选择选项。如果该选项被设置，则检测数据报的目标IP地址是否是本机的某个IP地址。如果不是，则发送一个ICMP源站选路失败报文给发送端。<br>3）如果有必要，则给源端发送一个ICMP重定向报文，以告诉它一个更合理的下一跳路由器。<br>4）将TTL值减1。</p>
<p>5）处理IP头部选项。<br>6）如果有必要，则执行IP分片操作。</p>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p><img src="/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230711224117951.png" alt="image-20230711224117951"></p>
<img src="/2023/07/09/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230711224117951.png" class title="This is an test image">

<h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p>IPv6协议是网络层技术发展的必然趋势。它不仅解决了IPv4地址不够用的问题，还做了很大的改进。比如，增加了多播和流的功能，为网络上多媒体内容的质量提供精细的控制;引入自动配置功能，使得局域网管理更方便﹔增加了专门的网络安全功能等。</p>
<p>注意:IPv6协议并不是IPv4协议的简单扩展，而是完全独立的协议。用以太网帧封装的IPv6数据报和IPv4数据报具有不同的类型值。第1章提到，IPv4数据报的以太网帧封装类型值是0x800，而IPv6数据报的以太网帧封装类型值是0x86dd (见RFC2464)。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/" class="post-title-link" itemprop="url">深入理解计算机系统-第七章-链接</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-07 16:48:11" itemprop="dateCreated datePublished" datetime="2023-07-07T16:48:11+08:00">2023-07-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-08 19:55:27" itemprop="dateModified" datetime="2023-07-08T19:55:27+08:00">2023-07-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="编译器驱动程序"><a href="#编译器驱动程序" class="headerlink" title="编译器驱动程序"></a>编译器驱动程序</h2><p>考虑图7-1中的C语言程序。它将作为贯穿本章的一个小的运行示例，帮助我们说明关于链接是如何工作的一些重要知识点。</p>
<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/image-20230707164930218.png" alt="image-20230707164930218"></p>


<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/image-20230707165006374.png" alt="image-20230707165006374"></p>


<p>驱动程序经过相同的过程生成sum.o。最后，它运行链接器程序ld，将main.o和sum.o以及一些必要的系统目标文件组合起来，创建一个可执行目标文件(executable ob-ject file)prog:<br><code>ld -o prog [system object files and args]  /tmp/main.o /tmp/sum.o</code><br>要运行可执行文件 prog，我们在Linux shell的命令行上输入它的名字:</p>
<p>linux&gt; .&#x2F;prog</p>
<p>shell调用操作系统中一个叫做加载器(loader)的函数，它将可执行文件prog中的代码和数据复制到内存，然后将控制转移到这个程序的开头。</p>
<h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>像Linux LD程序这样的静态链接器(static linker)以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的代码和数据节(section)组成，每一节都是一个连续的字节序列。指令在一节中，初始化了的全局变量在另一节中，而未初始化的变量又在另外一节中。</p>
<p>为了构造可执行文件，链接器必须完成两个主要任务:</p>
<ul>
<li>符号解析(symbol resolution)。目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或一个静态变量(即C语言中任何以static属性声明的变量)。符号解析的目的是将每个符号引用正好和一个符号定义关联起来。</li>
<li>重定位(relocation)。编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置。链接器使用汇编器产生的重定位条目(relocation entry)的详细指令，不加甄别地执行这样的重定位。</li>
</ul>
<h2 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h2><p>目标文件有三种形式:</p>
<ul>
<li>可重定位目标文件。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。</li>
<li>可执行目标文件。包含二进制代码和数据，其形式可以被直接复制到内存并执行。</li>
<li>共享目标文件。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。</li>
</ul>
<p>编译器和汇编器生成可重定位目标文件(包括共享目标文件)。链接器生成可执行目标文件。从技术上来说，一个目标模块(object module)就是一个字节序列，而一个目标文件(ob-ject file)就是一个以文件形式存放在磁盘中的目标模块。不过，我们会互换地使用这些术语。</p>
<p>目标文件是按照特定的目标文件格式来组织的，各个系统的目标文件格式都不相同。</p>
<p>从贝尔实验室诞生的第一个Unix系统使用的是 a.out格式(直到今天，可执行文件仍然称为a.out 文件)。Windows使用可移植可执行(Portable Executable，PE)格式。MacOS-X使用Mach-O格式。现代x86-64 Linux和Unix系统使用可执行可链接格式(Execut-able and Linkable Format，ELF)。尽管我们的讨论集中在ELF上，但是不管是哪种格式，基本的概念是相似的。</p>
<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/image-20230708195433833.png" alt="image-20230708195433833"></p>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/07/Linux-socket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/07/Linux-socket/" class="post-title-link" itemprop="url">Linux-socket</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-07 14:12:22" itemprop="dateCreated datePublished" datetime="2023-07-07T14:12:22+08:00">2023-07-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-11 15:54:49" itemprop="dateModified" datetime="2023-07-11T15:54:49+08:00">2023-07-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h2><p>网络字节序：</p>
<p>  小端法：（pc本地存储）  高位存高地址。地位存低地址。  int a &#x3D; 0x12345678</p>
<p>  大端法：（网络存储） 高位存低地址。低位存高地址 </p>
<p>  htonl –&gt; 本地–》网络 （IP）     192.168.1.11 –&gt; string –&gt; atoi –&gt; int –&gt; htonl –&gt; 网络字节序</p>
<p>  htons –&gt; 本地–》网络 (port)</p>
<p>  ntohl –&gt; 网络–》 本地（IP）</p>
<p>  ntohs –&gt; 网络–》 本地（Port）</p>
<p>ntohl函数用于字节顺序转换，将32位整数从网络字节顺序转换为主机字节顺序，对应于网络编程中的网络字节顺序的转换。它接收一个32位整数（网络字节顺序是大端法因为是tcp，早期大型机采用的是大端字节序，而大部分网络协议设计也遵循了这个约定）并返回主机字节顺序(一般是小端法)的整数。</p>
<h2 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h2><p>IP地址转换函数：</p>
<p>  <code>int inet_pton(int af, const char *src, void *dst);</code>   本地字节序（string IP） —&gt; 网络字节序</p>
<p>​    af：AF_INET、AF_INET6</p>
<p>​    src：传入，IP地址（点分十进制）</p>
<p>​    dst：传出，转换后的 网络字节序的 IP地址。 </p>
<p>​    返回值：</p>
<p>​      成功： 1</p>
<p>​      异常： 0， 说明src指向的不是一个有效的ip地址。</p>
<p>​      失败：-1</p>
<p>​    <code>const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);</code> 网络字节序 —&gt; 本地字节序（string IP）</p>
<p>​    af：AF_INET、AF_INET6</p>
<p>​    src: 网络字节序IP地址</p>
<p>​    dst：本地字节序（string IP）</p>
<p>​    size： dst 的大小。</p>
<p>​    返回值： 成功：dst。   </p>
<p>​      失败：NULL</p>
<p>inet_ntop函数用于将IP地址从二进制格式转换为可打印的字符串格式。它接收一个指向存储IP地址的结构体（如struct in_addr或struct in6_addr）以及地址族（AF_INET或AF_INET6），将二进制格式的IP地址转换为点分十进制的字符串表示形式。</p>
<h2 id="sockaddr地址结构"><a href="#sockaddr地址结构" class="headerlink" title="sockaddr地址结构"></a>sockaddr地址结构</h2><p><img src="/Linux-socket/image-20230707141717803.png" alt="image-20230707141717803"></p>
<img src="/2023/07/07/Linux-socket/image-20230707141717803.png" class title="This is an test image">

<p>sockaddr地址结构：  IP + port –&gt; 在网络环境中唯一标识一个进程。</p>
<p>  struct sockaddr_in addr;</p>
<p>  addr.sin_family &#x3D; AF_INET&#x2F;AF_INET6      man 7 ip</p>
<p>  addr.sin_port &#x3D; htons(9527);</p>
<p>​    <code>int dst;</code></p>
<p>​    <code>inet_pton(AF_INET, &quot;192.157.22.45&quot;, (void *)&amp;dst);</code></p>
<p>  <code>addr.sin_addr.s_addr = dst;</code>相当于addr.sin_addr.s_addr &#x3D; htonl(INADDR_ANY);一般用后者简单</p>
<p>  <code>【*】addr.sin_addr.s_addr = htonl(INADDR_ANY);</code>    取出系统中有效的任意IP地址。二进制类型。</p>
<p>  <code>bind(fd, (struct sockaddr *)&amp;addr, size);</code></p>
<h3 id="socket和bind"><a href="#socket和bind" class="headerlink" title="socket和bind"></a>socket和bind</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">socket函数：</span><br><span class="line"></span><br><span class="line">	#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">	int socket(int domain, int type, int protocol);		创建一个 套接字</span><br><span class="line"></span><br><span class="line">		domain：AF_INET、AF_INET6、AF_UNIX</span><br><span class="line"></span><br><span class="line">		type：SOCK_STREAM、SOCK_DGRAM</span><br><span class="line"></span><br><span class="line">		protocol: 0 </span><br><span class="line"></span><br><span class="line">		返回值：</span><br><span class="line">	</span><br><span class="line">			成功： 新套接字所对应文件描述符</span><br><span class="line"></span><br><span class="line">			失败: -1 errno</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">	 int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);		给socket绑定一个 地址结构 (IP+port)</span><br><span class="line"></span><br><span class="line">		sockfd: socket 函数返回值</span><br><span class="line"></span><br><span class="line">			struct sockaddr_in addr;</span><br><span class="line"></span><br><span class="line">			addr.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line">			addr.sin_port = htons(8888);</span><br><span class="line"></span><br><span class="line">			addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">		addr: 传入参数(struct sockaddr *)&amp;addr</span><br><span class="line"></span><br><span class="line">		addrlen: sizeof(addr) 地址结构的大小。</span><br><span class="line"></span><br><span class="line">		返回值：</span><br><span class="line"></span><br><span class="line">			成功：0</span><br><span class="line"></span><br><span class="line">			失败：-1 errno</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="listen和accept"><a href="#listen和accept" class="headerlink" title="listen和accept"></a>listen和accept</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">int listen(int sockfd, int backlog);		设置同时与服务器建立连接的上限数。（同时进行3次握手的客户端数量）</span><br><span class="line"></span><br><span class="line">		sockfd: socket 函数返回值</span><br><span class="line"></span><br><span class="line">		backlog：上限数值。最大值 128.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		返回值：</span><br><span class="line"></span><br><span class="line">			成功：0</span><br><span class="line"></span><br><span class="line">			失败：-1 errno	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);	阻塞等待客户端建立连接，成功的话，返回一个与客户端成功连接的socket文件描述符。</span><br><span class="line"></span><br><span class="line">		sockfd: socket 函数返回值</span><br><span class="line"></span><br><span class="line">		addr：传出参数。成功与服务器建立连接的那个客户端的地址结构（IP+port）</span><br><span class="line"></span><br><span class="line">			socklen_t clit_addr_len = sizeof(addr);</span><br><span class="line"></span><br><span class="line">		addrlen：传入传出。 &amp;clit_addr_len</span><br><span class="line"></span><br><span class="line">			 入：addr的大小。 出：客户端addr实际大小。</span><br><span class="line"></span><br><span class="line">		返回值：</span><br><span class="line"></span><br><span class="line">			成功：能与客户端进行数据通信的 socket 对应的文件描述。</span><br><span class="line"></span><br><span class="line">			失败： -1 ， errno</span><br><span class="line">		</span><br></pre></td></tr></table></figure>

<h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);	  使用现有的 socket 与服务器建立连接</span><br><span class="line"></span><br><span class="line">		sockfd： socket 函数返回值</span><br><span class="line"></span><br><span class="line">			struct sockaddr_in srv_addr;		// 服务器地址结构</span><br><span class="line"></span><br><span class="line">			srv_addr.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line">			srv_addr.sin_port = 9527 	跟服务器bind时设定的 port 完全一致。</span><br><span class="line"></span><br><span class="line">			inet_pton(AF_INET, &quot;服务器的IP地址&quot;，&amp;srv_adrr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">		addr：传入参数。服务器的地址结构</span><br><span class="line"></span><br><span class="line">			</span><br><span class="line">		addrlen：服务器的地址结构的大小</span><br><span class="line"></span><br><span class="line">		返回值：</span><br><span class="line"></span><br><span class="line">			成功：0</span><br><span class="line"></span><br><span class="line">			失败：-1 errno</span><br><span class="line"></span><br><span class="line">		如果不使用bind绑定客户端地址结构, 采用&quot;隐式绑定&quot;.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="CS模型的TCP通信分析"><a href="#CS模型的TCP通信分析" class="headerlink" title="CS模型的TCP通信分析"></a>CS模型的TCP通信分析</h2><p>TCP通信流程分析:</p>
<p>server:<br>    1. socket()	创建socket</p>
<ol start="2">
<li><p>bind()	绑定服务器地址结构</p>
</li>
<li><p>listen()	设置监听上限</p>
</li>
<li><p>accept()	阻塞监听客户端连接</p>
</li>
<li><p>read(fd)	读socket获取客户端数据</p>
</li>
<li><p>小–大写	toupper()</p>
</li>
<li><p>write(fd)</p>
</li>
<li><p>close();</p>
</li>
</ol>
<p>client:</p>
<ol>
<li><p>socket()	创建socket</p>
</li>
<li><p>connect();	与服务器建立连接</p>
</li>
<li><p>write()	写数据到 socket</p>
</li>
<li><p>read()	读转换后的数据。</p>
</li>
<li><p>显示读取结果</p>
</li>
<li><p>close()</p>
</li>
</ol>
<h2 id="server的实现"><a href="#server的实现" class="headerlink" title="server的实现"></a>server的实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include &lt;ctype.h&gt;  </span><br><span class="line">#include &lt;sys/socket.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;errno.h&gt;  </span><br><span class="line">#include &lt;pthread.h&gt;  </span><br><span class="line">#define SERV_PORT 9527  </span><br><span class="line"></span><br><span class="line">void sys_err(const char *str)  </span><br><span class="line">&#123;  </span><br><span class="line">        perror(str);  </span><br><span class="line">        exit(1);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">        int lfd = 0, cfd = 0;  </span><br><span class="line">        int ret, i;  </span><br><span class="line">        char buf[BUFSIZ], client_IP[1024]; //[+d查看系统定义的BUFSIZ的大小 </span><br><span class="line"></span><br><span class="line">        struct sockaddr_in serv_addr, clit_addr;  // 定义服务器地址结构 和 客户端地址结构  </span><br><span class="line">        socklen_t clit_addr_len;                  // 客户端地址结构大小  </span><br><span class="line"></span><br><span class="line">        serv_addr.sin_family = AF_INET;             // IPv4  </span><br><span class="line">        serv_addr.sin_port = htons(SERV_PORT);      // 转为网络字节序的 端口号  </span><br><span class="line">        serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  // 获取本机任意有效IP  </span><br><span class="line"></span><br><span class="line">        lfd = socket(AF_INET, SOCK_STREAM, 0);      //创建一个 socket  </span><br><span class="line">        if (lfd == -1) &#123;  </span><br><span class="line">                sys_err(&quot;socket error&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        bind(lfd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr));//给服务器socket绑定地址结构（IP+port)  </span><br><span class="line"></span><br><span class="line">        listen(lfd, 128);                   //  设置监听上限  </span><br><span class="line"></span><br><span class="line">        clit_addr_len = sizeof(clit_addr);  //  获取客户端地址结构大小  </span><br><span class="line"></span><br><span class="line">        cfd = accept(lfd, (struct sockaddr *)&amp;clit_addr, &amp;clit_addr_len);   // 阻塞等待客户端连接请求  </span><br><span class="line">        if (cfd == -1)  </span><br><span class="line">                sys_err(&quot;accept error&quot;);  </span><br><span class="line"></span><br><span class="line">        printf(&quot;client ip:%s port:%d\n&quot;,   </span><br><span class="line">                        inet_ntop(AF_INET, &amp;clit_addr.sin_addr.s_addr, client_IP, sizeof(client_IP)),                        ntohs(clit_addr.sin_port));         // 根据accept传出参数，获取客户端 ip 和 port  </span><br><span class="line"></span><br><span class="line">        while (1) &#123;  </span><br><span class="line">                ret = read(cfd, buf, sizeof(buf));      // 读客户端数据 ssize_t read(int fd, void *buf, size_t count); </span><br><span class="line">                //read函数的返回值是读取到的字节数，将其赋给ret变量。</span><br><span class="line">                write(STDOUT_FILENO, buf, ret);         // 写到屏幕查看  ssize_t write(int fd, const void *buf, size_t count);</span><br><span class="line"></span><br><span class="line">                for (i = 0; i &lt; ret; i++)                // 小写 -- 大写  </span><br><span class="line">                        buf[i] = toupper(buf[i]);  </span><br><span class="line"></span><br><span class="line">                write(cfd, buf, ret);                   // 将大写，写回给客户端。  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        close(lfd);  </span><br><span class="line">        close(cfd);  </span><br><span class="line"></span><br><span class="line">        return 0;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="获取客户端地址结构"><a href="#获取客户端地址结构" class="headerlink" title="获取客户端地址结构"></a>获取客户端地址结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cfd = accept(lfd, (struct sockaddr *)&amp;clit_addr, &amp;clit_addr_len);</span><br><span class="line">accept函数中的clit_addr传出的就是客户端地址结构，IP+port</span><br><span class="line"></span><br><span class="line">于是，在代码中增加此段代码，可获取客户端信息：</span><br><span class="line">printf(&quot;client ip:%s port:%d\n&quot;, </span><br><span class="line">            inet_ntop(AF_INET,&amp;clit_addr.sin_addr.s_addr, client_IP, sizeof(client_IP)), </span><br><span class="line">            ntohs(clit_addr.sin_port));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="client的实现"><a href="#client的实现" class="headerlink" title="client的实现"></a>client的实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;sys/socket.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;errno.h&gt;  </span><br><span class="line">#include &lt;pthread.h&gt;  </span><br><span class="line"></span><br><span class="line">#define SERV_PORT 9527  </span><br><span class="line"></span><br><span class="line">void sys_err(const char* str)  </span><br><span class="line">&#123;  </span><br><span class="line">    perror(str);  </span><br><span class="line">    exit(1);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">    int cfd;  </span><br><span class="line">    int conter = 10;  </span><br><span class="line">    char buf[BUFSIZ];  </span><br><span class="line">    </span><br><span class="line">    struct sockaddr_in serv_addr;          //服务器地址结构  </span><br><span class="line"></span><br><span class="line">    serv_addr.sin_family = AF_INET;  </span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);  </span><br><span class="line">    //inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;serv_addr.sin_addr.s_addr);  </span><br><span class="line">    inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;serv_addr.sin_addr);  </span><br><span class="line"></span><br><span class="line">    cfd = socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">    if (cfd == -1)  </span><br><span class="line">        sys_err(&quot;socket error&quot;);  </span><br><span class="line"></span><br><span class="line">    int ret = connect(cfd, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr));  </span><br><span class="line">    if (ret != 0)  </span><br><span class="line">        sys_err(&quot;connect err&quot;);  </span><br><span class="line"></span><br><span class="line">    while (--conter) &#123;  </span><br><span class="line">        write(cfd, &quot;hello\n&quot;, 6);  </span><br><span class="line">        ret = read(cfd, buf, sizeof(buf));  </span><br><span class="line">        write(STDOUT_FILENO, buf, ret);  </span><br><span class="line">        sleep(1);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    close(cfd);  </span><br><span class="line"></span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里遇到过一个问题，如果之前运行server，用Ctrl+z终止进程，ps aux列表里会有服务器进程残留，这个会影响当前服务器。解决方法是kill掉这些服务器进程。不然端口被占用，当前运行的服务器进程接收不到东西，没有回显。</p>
<h2 id="错误处理函数的封装思路"><a href="#错误处理函数的封装思路" class="headerlink" title="错误处理函数的封装思路"></a>错误处理函数的封装思路</h2><p>wrap.h文件如下，就是包裹函数的声明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __WRAP_H_  </span><br><span class="line">#define __WRAP_H_  </span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">void perr_exit(const char* s);</span><br><span class="line">int Accept(int fd, struct sockaddr* sa, socklen_t* salenptr);</span><br><span class="line">int Bind(int fd, const struct sockaddr* sa, socklen_t salen);</span><br><span class="line">int Connect(int fd, const struct sockaddr* sa, socklen_t salen);</span><br><span class="line">int Listen(int fd, int backlog);</span><br><span class="line">int Socket(int family, int type, int protocol);</span><br><span class="line">ssize_t Read(int fd, void* ptr, size_t nbytes);</span><br><span class="line">ssize_t Write(int fd, const void* ptr, size_t nbytes);</span><br><span class="line">int Close(int fd);</span><br><span class="line">ssize_t Readn(int fd, void* vptr, size_t n);</span><br><span class="line">ssize_t Writen(int fd, const void* vptr, size_t n);</span><br><span class="line">ssize_t my_read(int fd, char* ptr);</span><br><span class="line">ssize_t Readline(int fd, void* vptr, size_t maxlen);</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>wrap.c随便取一部分，如下，就是包裹函数的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;wrap.h&quot;</span><br><span class="line"></span><br><span class="line">void perr_exit(const char *s)</span><br><span class="line">&#123;</span><br><span class="line">	perror(s);</span><br><span class="line">	exit(1);</span><br><span class="line">&#125;</span><br><span class="line">int Accept(int fd, struct sockaddr *sa, socklen_t *salenptr)</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	again:</span><br><span class="line">	if ( (n = accept(fd, sa, salenptr)) &lt; 0) &#123;</span><br><span class="line">		if ((errno == ECONNABORTED) || (errno == EINTR))</span><br><span class="line">			goto again;</span><br><span class="line">		else</span><br><span class="line">			perr_exit(&quot;accept error&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br><span class="line">int Bind(int fd, const struct sockaddr *sa, socklen_t salen)</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	if ((n = bind(fd, sa, salen)) &lt; 0)</span><br><span class="line">		perr_exit(&quot;bind error&quot;);</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br><span class="line">int Connect(int fd, const struct sockaddr *sa, socklen_t salen)</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	if ((n = connect(fd, sa, salen)) &lt; 0)</span><br><span class="line">		perr_exit(&quot;connect error&quot;);</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br><span class="line">int Listen(int fd, int backlog)</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	if ((n = listen(fd, backlog)) &lt; 0)</span><br><span class="line">		perr_exit(&quot;listen error&quot;);</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br><span class="line">int Socket(int family, int type, int protocol)</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	if ( (n = socket(family, type, protocol)) &lt; 0)</span><br><span class="line">		perr_exit(&quot;socket error&quot;);</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br><span class="line">ssize_t Read(int fd, void *ptr, size_t nbytes)</span><br><span class="line">&#123;</span><br><span class="line">	ssize_t n;</span><br><span class="line">again:</span><br><span class="line">	if ( (n = read(fd, ptr, nbytes)) == -1) &#123;</span><br><span class="line">		if (errno == EINTR)</span><br><span class="line">			goto again;</span><br><span class="line">		else</span><br><span class="line">			return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br><span class="line">ssize_t Write(int fd, const void *ptr, size_t nbytes)</span><br><span class="line">&#123;</span><br><span class="line">	ssize_t n;</span><br><span class="line">again:</span><br><span class="line">	if ( (n = write(fd, ptr, nbytes)) == -1) &#123;</span><br><span class="line">		if (errno == EINTR)</span><br><span class="line">			goto again;</span><br><span class="line">		else</span><br><span class="line">			return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br><span class="line">int Close(int fd)</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	if ((n = close(fd)) == -1)</span><br><span class="line">		perr_exit(&quot;close error&quot;);</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br><span class="line">ssize_t Readn(int fd, void *vptr, size_t n)</span><br><span class="line">&#123;</span><br><span class="line">	size_t nleft;</span><br><span class="line">	ssize_t nread;</span><br><span class="line">	char *ptr;</span><br><span class="line"></span><br><span class="line">	ptr = vptr;</span><br><span class="line">	nleft = n;</span><br><span class="line"></span><br><span class="line">	while (nleft &gt; 0) &#123;</span><br><span class="line">		if ( (nread = read(fd, ptr, nleft)) &lt; 0) &#123;</span><br><span class="line">			if (errno == EINTR)</span><br><span class="line">				nread = 0;</span><br><span class="line">			else</span><br><span class="line">				return -1;</span><br><span class="line">		&#125; else if (nread == 0)</span><br><span class="line">			break;</span><br><span class="line">		nleft -= nread;</span><br><span class="line">		ptr += nread;</span><br><span class="line">	&#125;</span><br><span class="line">	return n - nleft;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ssize_t Writen(int fd, const void *vptr, size_t n)</span><br><span class="line">&#123;</span><br><span class="line">	size_t nleft;</span><br><span class="line">	ssize_t nwritten;</span><br><span class="line">	const char *ptr;</span><br><span class="line"></span><br><span class="line">	ptr = vptr;</span><br><span class="line">	nleft = n;</span><br><span class="line"></span><br><span class="line">	while (nleft &gt; 0) &#123;</span><br><span class="line">		if ( (nwritten = write(fd, ptr, nleft)) &lt;= 0) &#123;</span><br><span class="line">			if (nwritten &lt; 0 &amp;&amp; errno == EINTR)</span><br><span class="line">				nwritten = 0;</span><br><span class="line">			else</span><br><span class="line">				return -1;</span><br><span class="line">		&#125;</span><br><span class="line">		nleft -= nwritten;</span><br><span class="line">		ptr += nwritten;</span><br><span class="line">	&#125;</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ssize_t my_read(int fd, char *ptr)</span><br><span class="line">&#123;</span><br><span class="line">	static int read_cnt;</span><br><span class="line">	static char *read_ptr;</span><br><span class="line">	static char read_buf[100];</span><br><span class="line"></span><br><span class="line">	if (read_cnt &lt;= 0) &#123;</span><br><span class="line">again:</span><br><span class="line">		if ((read_cnt = read(fd, read_buf, sizeof(read_buf))) &lt; 0) &#123;</span><br><span class="line">			if (errno == EINTR)</span><br><span class="line">				goto again;</span><br><span class="line">			return -1;	</span><br><span class="line">		&#125; else if (read_cnt == 0)</span><br><span class="line">			return 0;</span><br><span class="line">		read_ptr = read_buf;</span><br><span class="line">	&#125;</span><br><span class="line">	read_cnt--;</span><br><span class="line">	*ptr = *read_ptr++;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ssize_t Readline(int fd, void *vptr, size_t maxlen)</span><br><span class="line">&#123;</span><br><span class="line">	ssize_t n, rc;</span><br><span class="line">	char c, *ptr;</span><br><span class="line">	ptr = vptr;</span><br><span class="line"></span><br><span class="line">	for (n = 1; n &lt; maxlen; n++) &#123;</span><br><span class="line">		if ( (rc = my_read(fd, &amp;c)) == 1) &#123;</span><br><span class="line">			*ptr++ = c;</span><br><span class="line">			if (c == &#x27;\n&#x27;)</span><br><span class="line">				break;</span><br><span class="line">		&#125; else if (rc == 0) &#123;</span><br><span class="line">			*ptr = 0;</span><br><span class="line">			return n - 1;</span><br><span class="line">		&#125; else</span><br><span class="line">			return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	*ptr = 0;</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里原函数和包裹函数的函数名差异只有首字母大写，这是因为man page对字母大小写不敏感，同名的包裹函数一样可以跳转至man page</p>
<hr>
<p>错误处理函数： </p>
<p>  封装目的：</p>
<p>​    在 server.c 编程过程中突出逻辑，将出错处理与逻辑分开，可以直接跳转man手册。</p>
<p>  【wrap.c】             【wrap.h】</p>
<p>  存放网络通信相关常用 自定义函数         存放 网络通信相关常用 自定义函数原型(声明)。</p>
<p>  命名方式：系统调用函数首字符大写, 方便查看man手册</p>
<p>​     如：Listen()、Accept();</p>
<p>  函数功能：调用系统调用函数，处理出错场景。</p>
<p>  在 server.c 和 client.c 中调用 自定义函数 </p>
<p>  联合编译 server.c 和 wrap.c 生成 server</p>
<p>​     			client.c 和 wrap.c 生成 client </p>
<p>readn：</p>
<p>  读 N 个字节 </p>
<p>readline：</p>
<p>  读一行</p>
<h2 id="多进程并发服务器思路分析"><a href="#多进程并发服务器思路分析" class="headerlink" title="多进程并发服务器思路分析"></a>多进程并发服务器思路分析</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">多线程并发服务器： server.c </span><br><span class="line"></span><br><span class="line">	1. Socket();		创建 监听套接字 lfd</span><br><span class="line"></span><br><span class="line">	2. Bind()		绑定地址结构 Strcut scokaddr_in addr;</span><br><span class="line"></span><br><span class="line">	3. Listen();		</span><br><span class="line"></span><br><span class="line">	4. while (1) &#123;		</span><br><span class="line"></span><br><span class="line">		cfd = Accept(lfd, );</span><br><span class="line"></span><br><span class="line">		pthread_create(&amp;tid, NULL, tfn, (void *)cfd);</span><br><span class="line"></span><br><span class="line">		pthread_detach(tid);  				// pthead_join(tid, void **);  新线程---专用于回收子线程。</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	5. 子线程：</span><br><span class="line"></span><br><span class="line">		void *tfn(void *arg) </span><br><span class="line">		&#123;</span><br><span class="line">			// close(lfd)			不能关闭。 主线程要使用lfd</span><br><span class="line"></span><br><span class="line">			read(cfd)</span><br><span class="line"></span><br><span class="line">			小--大</span><br><span class="line"></span><br><span class="line">			write(cfd)</span><br><span class="line"></span><br><span class="line">			pthread_exit（(void *)10）;	</span><br><span class="line">		&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="多进程并发服务器实现"><a href="#多进程并发服务器实现" class="headerlink" title="多进程并发服务器实现"></a>多进程并发服务器实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;ctype.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;sys/wait.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;strings.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;errno.h&gt;  </span><br><span class="line">#include &lt;signal.h&gt;  </span><br><span class="line">#include &lt;sys/socket.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">#include &lt;pthread.h&gt;  </span><br><span class="line"></span><br><span class="line">#include &quot;wrap.h&quot;  </span><br><span class="line"></span><br><span class="line">#define SRV_PORT 9999  </span><br><span class="line"></span><br><span class="line">void catch_child(int signum)  //当子进程退出时，父进程收到信号，就会去回收子进程了，不会出现僵尸进程</span><br><span class="line">&#123;  </span><br><span class="line">    while ((waitpid(0, NULL, WNOHANG)) &gt; 0);  </span><br><span class="line">    return;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;</span><br><span class="line">    int lfd, cfd;  </span><br><span class="line">    pid_t pid;  </span><br><span class="line">    struct sockaddr_in srv_addr, clt_addr;  </span><br><span class="line">    socklen_t clt_addr_len;   </span><br><span class="line">    char buf[BUFSIZ];  </span><br><span class="line">    int ret, i;  </span><br><span class="line">    </span><br><span class="line">    //memset(&amp;srv_addr, 0, sizeof(srv_addr));                 // 将地址结构清零  </span><br><span class="line">    bzero(&amp;srv_addr, sizeof(srv_addr));  </span><br><span class="line">    </span><br><span class="line">    srv_addr.sin_family = AF_INET;  </span><br><span class="line">    srv_addr.sin_port = htons(SRV_PORT);  </span><br><span class="line">    srv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">    </span><br><span class="line">    lfd = Socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">    </span><br><span class="line">    Bind(lfd, (struct sockaddr *)&amp;srv_addr, sizeof(srv_addr));  </span><br><span class="line">    </span><br><span class="line">    Listen(lfd, 128);  </span><br><span class="line">    </span><br><span class="line">    clt_addr_len = sizeof(clt_addr);  </span><br><span class="line">    </span><br><span class="line">    while (1) &#123;  </span><br><span class="line">    </span><br><span class="line">        cfd = Accept(lfd, (struct sockaddr *)&amp;clt_addr, &amp;clt_addr_len);  </span><br><span class="line">    </span><br><span class="line">        pid = fork();  </span><br><span class="line">        if (pid &lt; 0) &#123;  </span><br><span class="line">            perr_exit(&quot;fork error&quot;);  </span><br><span class="line">        &#125; else if (pid == 0) &#123;  </span><br><span class="line">            close(lfd);  </span><br><span class="line">            break;          </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            struct sigaction act;  </span><br><span class="line">    </span><br><span class="line">            act.sa_handler = catch_child;  </span><br><span class="line">            sigemptyset(&amp;act.sa_mask);  </span><br><span class="line">            act.sa_flags = 0;  </span><br><span class="line">    </span><br><span class="line">            ret = sigaction(SIGCHLD, &amp;act, NULL);  </span><br><span class="line">            if (ret != 0) &#123;  </span><br><span class="line">               perr_exit(&quot;sigaction error&quot;);  </span><br><span class="line">            &#125;  </span><br><span class="line">            close(cfd);   </span><br><span class="line">            continue;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    if (pid == 0) &#123;  </span><br><span class="line">        for (;;) &#123;  </span><br><span class="line">            ret = Read(cfd, buf, sizeof(buf));  </span><br><span class="line">            if (ret == 0) &#123;  </span><br><span class="line">                close(cfd);  </span><br><span class="line">                exit(1);  </span><br><span class="line">            &#125;   </span><br><span class="line">    </span><br><span class="line">            for (i = 0; i &lt; ret; i++)  </span><br><span class="line">                buf[i] = toupper(buf[i]);  </span><br><span class="line">    </span><br><span class="line">            write(cfd, buf, ret);  </span><br><span class="line">            write(STDOUT_FILENO, buf, ret);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    return 0；</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>使用桥接模式，让自己主机和其他人主机处于同一个网段</p>
<p><img src="/Linux-socket/image-20230709110056462.png" alt="image-20230709110056462"></p>
<img src="/2023/07/07/Linux-socket/image-20230709110056462.png" class title="This is an test image">

<p><img src="/Linux-socket/image-20230709110238005.png" alt="image-20230709110238005"></p>
<img src="/2023/07/07/Linux-socket/image-20230709110238005.png" class title="This is an test image">

<p>然后再断开再桥接连一下，这个是你自己取的名字。</p>
<h3 id="服务器程序上传外网服务器并访问"><a href="#服务器程序上传外网服务器并访问" class="headerlink" title="服务器程序上传外网服务器并访问"></a>服务器程序上传外网服务器并访问</h3><p>scp -r 命令，将本地文件拷贝至远程服务器上目标位置</p>
<p>scp -r 源地址 目标地址</p>
<h2 id="多线程服务器代码review"><a href="#多线程服务器代码review" class="headerlink" title="多线程服务器代码review"></a>多线程服务器代码review</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;ctype.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;wrap.h&quot;</span><br><span class="line"></span><br><span class="line">#define MAXLINE 8192</span><br><span class="line">#define SERV_PORT 8000</span><br><span class="line"></span><br><span class="line">struct s_info &#123;											//定义一个结构体, 将地址结构跟cfd捆绑</span><br><span class="line">    struct sockaddr_in cliaddr;</span><br><span class="line">    int connfd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void *do_work(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    int n, i;</span><br><span class="line">    struct s_info *ts = (struct s_info *) arg;</span><br><span class="line">    char buf[MAXLINE];</span><br><span class="line">    char str[INET_ADDRSTRLEN];				//#define INET_ADDRSTRLEN 16  可用&quot;[+d&quot;查看</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        n = Read(ts-&gt;connfd, buf, MAXLINE);	//读客户端</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            printf(&quot;the client %d closed...\n&quot;, ts-&gt;connfd);</span><br><span class="line">            break;							//跳出循环,关闭cfd </span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;received from %s at PORT %d\n&quot;,</span><br><span class="line">               inet_ntop(AF_INET, &amp;(*ts).cliaddr.sin_addr, str, sizeof(str)),</span><br><span class="line">               ntohs((*ts).cliaddr.sin_port));			//打印客户端信息(IP/PORT)</span><br><span class="line"></span><br><span class="line">        for (i = 0; i &lt; n; i++)</span><br><span class="line">            buf[i] = toupper(buf[i]);					  //小写--&gt;大写  </span><br><span class="line"></span><br><span class="line">        Write(STDOUT_FILENO, buf, n);					//写出至屏幕  </span><br><span class="line">        Write(ts-&gt;connfd, buf, n);						  //回写给客户端 </span><br><span class="line">    &#125;</span><br><span class="line">    Close(ts-&gt;connfd);</span><br><span class="line"></span><br><span class="line">    return (void *) 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    struct sockaddr_in servaddr, cliaddr;</span><br><span class="line">    socklen_t cliaddr_len;</span><br><span class="line">    int listenfd, connfd;</span><br><span class="line">    pthread_t tid;</span><br><span class="line"></span><br><span class="line">    struct s_info ts[256];								 //创建结构体数组</span><br><span class="line">    int i = 0;</span><br><span class="line">	</span><br><span class="line">    listenfd = Socket(AF_INET, SOCK_STREAM, 0);			//创建一个socket, 得到lfd  </span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, sizeof(servaddr));					//地址结构清零	</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);					//指定本地任意IP  </span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);				    //指定端口号   </span><br><span class="line"></span><br><span class="line">    Bind(listenfd, (struct sockaddr *) &amp;servaddr, sizeof(servaddr)); //绑定  	</span><br><span class="line"></span><br><span class="line">    Listen(listenfd, 128);		     //设置同一时刻链接服务器上限数  </span><br><span class="line"></span><br><span class="line">    printf(&quot;Accepting client connect ...\n&quot;);</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        cliaddr_len = sizeof(cliaddr);</span><br><span class="line">        connfd = Accept(listenfd, (struct sockaddr *) &amp;cliaddr, &amp;cliaddr_len); //阻塞监听客户端链接请求  </span><br><span class="line">        ts[i].cliaddr = cliaddr;</span><br><span class="line">        ts[i].connfd = connfd;</span><br><span class="line"></span><br><span class="line">        pthread_create(&amp;tid, NULL, do_work, (void *) &amp;ts[i]);//这里可以传地址是因为不会改变</span><br><span class="line">        pthread_detach(tid);			  //子线程分离,防止僵线程产生.  </span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多路IO转接服务器设计思路"><a href="#多路IO转接服务器设计思路" class="headerlink" title="多路IO转接服务器设计思路"></a>多路IO转接服务器设计思路</h2><p><img src="/Linux-socket/image-20230711110952097.png" alt="image-20230711110952097"></p>
<img src="/2023/07/07/Linux-socket/image-20230711110952097.png" class title="This is an test image">

<h2 id="select函数参数简介"><a href="#select函数参数简介" class="headerlink" title="select函数参数简介"></a>select函数参数简介</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout);</span><br><span class="line"></span><br><span class="line">		nfds：监听的所有文件描述符中，最大文件描述符+1</span><br><span class="line"></span><br><span class="line">		readfds： 读 文件描述符监听集合。	传入、传出参数</span><br><span class="line"></span><br><span class="line">		writefds：写 文件描述符监听集合。	传入、传出参数		NULL</span><br><span class="line"></span><br><span class="line">		exceptfds：异常 文件描述符监听集合	传入、传出参数		NULL</span><br><span class="line"></span><br><span class="line">		timeout： 	&gt; 0: 	设置监听超时时长。</span><br><span class="line"></span><br><span class="line">				NULL:	阻塞监听</span><br><span class="line"></span><br><span class="line">				0：	非阻塞监听，轮询</span><br><span class="line">		返回值：</span><br><span class="line"></span><br><span class="line">			&gt; 0:	所有监听集合（3个）中， 满足对应事件的总数。</span><br><span class="line"></span><br><span class="line">			0：	没有满足监听条件的文件描述符</span><br><span class="line"></span><br><span class="line">			-1： 	errno</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="select相关函数参数分析"><a href="#select相关函数参数分析" class="headerlink" title="select相关函数参数分析"></a>select相关函数参数分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void FD_CLR(int fd, fd_set *set)		把某一个fd清除出去</span><br><span class="line">int FD_ISSET(int fd, fd_set *set)		判定某个fd是否在位图中</span><br><span class="line">void FD_SET(int fd, fd_set *set)		把某一个fd添加到位图</span><br><span class="line">void FD_ZERO(fd_set *set)				位图所有二进制位置零</span><br><span class="line"></span><br><span class="line">select多路IO转接：</span><br><span class="line"></span><br><span class="line">	原理：  借助内核， select 来监听， 客户端连接、数据通信事件。</span><br><span class="line"></span><br><span class="line">	void FD_ZERO(fd_set *set);	--- 清空一个文件描述符集合。</span><br><span class="line"></span><br><span class="line">		fd_set rset;</span><br><span class="line"></span><br><span class="line">		FD_ZERO(&amp;rset);</span><br><span class="line"></span><br><span class="line">	void FD_SET(int fd, fd_set *set);	--- 将待监听的文件描述符，添加到监听集合中</span><br><span class="line"></span><br><span class="line">		FD_SET(3, &amp;rset);	FD_SET(5, &amp;rset);	FD_SET(6, &amp;rset);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	void FD_CLR(int fd, fd_set *set);	--- 将一个文件描述符从监听集合中 移除。</span><br><span class="line"></span><br><span class="line">		FD_CLR（4， &amp;rset）;</span><br><span class="line"></span><br><span class="line">	int  FD_ISSET(int fd, fd_set *set);	--- 判断一个文件描述符是否在监听集合中。</span><br><span class="line"></span><br><span class="line">		返回值： 在：1；不在：0；</span><br><span class="line"></span><br><span class="line">		FD_ISSET（4， &amp;rset）;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="select实现多路IO转接设计思路"><a href="#select实现多路IO转接设计思路" class="headerlink" title="select实现多路IO转接设计思路"></a>select实现多路IO转接设计思路</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">思路分析：</span><br><span class="line"></span><br><span class="line">	int maxfd = 0；</span><br><span class="line"></span><br><span class="line">	lfd = socket() ;			创建套接字</span><br><span class="line"></span><br><span class="line">	maxfd = lfd；</span><br><span class="line"></span><br><span class="line">	bind();					绑定地址结构</span><br><span class="line"></span><br><span class="line">	listen();				设置监听上限</span><br><span class="line"></span><br><span class="line">	fd_set rset， allset;			创建r监听集合</span><br><span class="line"></span><br><span class="line">	FD_ZERO(&amp;allset);				将r监听集合清空</span><br><span class="line"></span><br><span class="line">	FD_SET(lfd, &amp;allset);			将 lfd 添加至读集合中。</span><br><span class="line"></span><br><span class="line">	while（1） &#123;</span><br><span class="line"></span><br><span class="line">		rset = allset；			保存监听集合</span><br><span class="line">	</span><br><span class="line">		ret  = select(lfd+1， &amp;rset， NULL， NULL， NULL);		监听文件描述符集合对应事件。</span><br><span class="line"></span><br><span class="line">		if（ret &gt; 0） &#123;							有监听的描述符满足对应事件</span><br><span class="line">		</span><br><span class="line">			if (FD_ISSET(lfd, &amp;rset)) &#123;				// 1 在。 0不在。</span><br><span class="line"></span><br><span class="line">				cfd = accept（）；				建立连接，返回用于通信的文件描述符</span><br><span class="line"></span><br><span class="line">				maxfd = cfd；</span><br><span class="line"></span><br><span class="line">				FD_SET(cfd, &amp;allset);				添加到监听通信描述符集合中。</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			for （i = lfd+1； i &lt;= 最大文件描述符; i++）&#123;</span><br><span class="line"></span><br><span class="line">				FD_ISSET(i, &amp;rset)				有read、write事件</span><br><span class="line"></span><br><span class="line">				read（）</span><br><span class="line"></span><br><span class="line">				小 -- 大</span><br><span class="line"></span><br><span class="line">				write();</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="select实现多路IO转接-代码review"><a href="#select实现多路IO转接-代码review" class="headerlink" title="select实现多路IO转接-代码review"></a>select实现多路IO转接-代码review</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;arpa/inet.h&gt;  </span><br><span class="line">#include &lt;ctype.h&gt;  </span><br><span class="line"></span><br><span class="line">#include &quot;wrap.h&quot;  </span><br><span class="line"></span><br><span class="line">#define SERV_PORT 6666  </span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">    int i, j, n, nready;  </span><br><span class="line"></span><br><span class="line">    int maxfd = 0;  </span><br><span class="line"></span><br><span class="line">    int listenfd, connfd;  </span><br><span class="line"></span><br><span class="line">    char buf[BUFSIZ];         /* #define INET_ADDRSTRLEN 16 */  </span><br><span class="line"></span><br><span class="line">    struct sockaddr_in clie_addr, serv_addr;  </span><br><span class="line">    socklen_t clie_addr_len;  </span><br><span class="line"></span><br><span class="line">    listenfd = Socket(AF_INET, SOCK_STREAM, 0);    </span><br><span class="line">    int opt = 1;  </span><br><span class="line">    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, (void *)&amp;opt, sizeof(opt));  </span><br><span class="line">    </span><br><span class="line">    bzero(&amp;serv_addr, sizeof(serv_addr));  </span><br><span class="line">    serv_addr.sin_family= AF_INET;  </span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">    serv_addr.sin_port= htons(SERV_PORT);  </span><br><span class="line">    Bind(listenfd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr));  </span><br><span class="line">    Listen(listenfd, 128);  </span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">    fd_set rset, allset;                            /* rset 读事件文件描述符集合 allset用来暂存 */  </span><br><span class="line">  </span><br><span class="line">    maxfd = listenfd;  </span><br><span class="line">  </span><br><span class="line">    FD_ZERO(&amp;allset);  </span><br><span class="line">    FD_SET(listenfd, &amp;allset);                                  /* 构造select监控文件描述符集 */  </span><br><span class="line">  </span><br><span class="line">    while (1) &#123;     </span><br><span class="line">        rset = allset;                                          /* 每次循环时都从新设置select监控信号集 */  </span><br><span class="line">        nready = select(maxfd+1, &amp;rset, NULL, NULL, NULL);  </span><br><span class="line">        if (nready &lt; 0)  </span><br><span class="line">            perr_exit(&quot;select error&quot;);  </span><br><span class="line">  </span><br><span class="line">        if (FD_ISSET(listenfd, &amp;rset)) &#123;                        /* 说明有新的客户端链接请求 */  </span><br><span class="line">  </span><br><span class="line">            clie_addr_len = sizeof(clie_addr);  </span><br><span class="line">            connfd = Accept(listenfd, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);       /* Accept 不会阻塞 */  </span><br><span class="line">  </span><br><span class="line">            FD_SET(connfd, &amp;allset);                            /* 向监控文件描述符集合allset添加新的文件描述符connfd */  </span><br><span class="line">  </span><br><span class="line">            if (maxfd &lt; connfd)  </span><br><span class="line">                maxfd = connfd;  </span><br><span class="line">  </span><br><span class="line">            if (0 == --nready)                                  /* 只有listenfd有事件, 后续的 for 不需执行 */  </span><br><span class="line">                continue;  </span><br><span class="line">        &#125;   </span><br><span class="line">  </span><br><span class="line">        for (i = listenfd+1; i &lt;= maxfd; i++) &#123;                 /* 检测哪个clients 有数据就绪 */  </span><br><span class="line">  </span><br><span class="line">            if (FD_ISSET(i, &amp;rset)) &#123;  </span><br><span class="line">  </span><br><span class="line">                if ((n = Read(i, buf, sizeof(buf))) == 0) &#123;    /* 当client关闭链接时,服务器端也关闭对应链接 */  </span><br><span class="line">                    Close(i);  </span><br><span class="line">                    FD_CLR(i, &amp;allset);                        /* 解除select对此文件描述符的监控 */  </span><br><span class="line">                    &#125; else if (n &gt; 0) &#123;  </span><br><span class="line">	  </span><br><span class="line">	                    for (j = 0; j &lt; n; j++)  </span><br><span class="line">	                        buf[j] = toupper(buf[j]);  </span><br><span class="line">	                    Write(i, buf, n);  </span><br><span class="line">	                &#125;  </span><br><span class="line">	            &#125;  </span><br><span class="line">	        &#125;  </span><br><span class="line">	    &#125;  </span><br><span class="line">	  </span><br><span class="line">	    Close(listenfd);  </span><br><span class="line">	  </span><br><span class="line">	    return 0;  </span><br><span class="line">	&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用 Ctrl+Z 组合键是一种在命令行界面下停止（暂停）进程的方法，而不是正确关闭连接或套接字。</p>
<p>在大多数操作系统中，Ctrl+Z 组合键用于发送一个 SIGTSTP 信号给当前运行的进程，以暂停其执行。这通常是在后台运行的进程或任务中使用的，如在 Linux 或 UNIX 系统中运行的程序。通过按下 Ctrl+Z，您可以使进程进入后台挂起状态，并返回到命令行提示符，从而可以执行其他操作。</p>
<p>然而，Ctrl+Z 并不会主动关闭连接或套接字，它只是将进程暂停，但连接可能仍然处于活动状态。如果您希望正确关闭连接或套接字，应该在适当的时间调用相应的方法或函数来明确地关闭它们。具体取决于所使用的编程语言和网络库。</p>
<p>对于大多数命令行界面，使用 <strong>Ctrl+C</strong> 组合键是一种常用的方法来停止正在运行的进程或程序，包括网络连接和套接字。</p>
<p>按下 Ctrl+C 组合键会发送一个 SIGINT 信号给当前运行的进程，这通常会中断进程的执行并终止它。在网络编程中，当您想要停止正在进行的连接时，可以按下 Ctrl+C 组合键来关闭连接并终止与该连接相关的进程。</p>
<p>需要注意的是，按下 Ctrl+C 组合键将会立即终止进程，可能导致一些未完成的操作无法正确处理。因此，在关闭连接或套接字之前，建议在适当的时机进行必要的清理和处理操作，以确保数据的完整性和资源的正确释放。</p>
<p>总而言之，Ctrl+C 是一种常见且有效的方式来停止正在运行的进程，包括关闭网络连接和套接字。但请谨慎使用，确保在终止进程之前进行必要的清理和处理操作，以避免可能的问题。</p>
<h3 id="select优缺点"><a href="#select优缺点" class="headerlink" title="select优缺点"></a>select优缺点</h3><p>select优缺点：</p>
<p>  缺点： 监听上限受文件描述符限制。 最大 1024.</p>
<p>​    检测满足条件的fd， 自己添加业务逻辑提高小。 提高了编码难度。</p>
<p>  优点： 跨平台。win、linux、macOS、Unix、类Unix、mips</p>
<p>select代码里有个可以优化的地方，用数组存下文件描述符，这样就不需要每次扫描一大堆无关文件描述符了</p>
<h2 id="添加一个自定义数组提高效率"><a href="#添加一个自定义数组提高效率" class="headerlink" title="添加一个自定义数组提高效率"></a>添加一个自定义数组提高效率</h2><p>这里就是改进之前代码的问题，之前的代码，如果最大fd是1023，每次确定有事件发生的fd时，就要扫描3-1023的所有文件描述符，这看起来很蠢。于是定义一个数组，把要监听的文件描述符存下来，每次扫描这个数组就行了。看起来科学得多。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">1.	#include &lt;stdio.h&gt;  </span><br><span class="line">2.	#include &lt;stdlib.h&gt;  </span><br><span class="line">3.	#include &lt;unistd.h&gt;  </span><br><span class="line">4.	#include &lt;string.h&gt;  </span><br><span class="line">5.	#include &lt;arpa/inet.h&gt;  </span><br><span class="line">6.	#include &lt;ctype.h&gt;  </span><br><span class="line">7.	  </span><br><span class="line">8.	#include &quot;wrap.h&quot;  </span><br><span class="line">9.	  </span><br><span class="line">10.	#define SERV_PORT 6666  </span><br><span class="line">11.	  </span><br><span class="line">12.	int main(int argc, char *argv[])  </span><br><span class="line">13.	&#123;  </span><br><span class="line">14.	    int i, j, n, maxi;  </span><br><span class="line">15.	  </span><br><span class="line">16.	    int nready, client[FD_SETSIZE];                 /* 自定义数组client, 防止遍历1024个文件描述符  FD_SETSIZE默认为1024 */  </span><br><span class="line">17.	    int maxfd, listenfd, connfd, sockfd;  </span><br><span class="line">18.	    char buf[BUFSIZ], str[INET_ADDRSTRLEN];         /* #define INET_ADDRSTRLEN 16 */  </span><br><span class="line">19.	  </span><br><span class="line">20.	    struct sockaddr_in clie_addr, serv_addr;  </span><br><span class="line">21.	    socklen_t clie_addr_len;  </span><br><span class="line">22.	    fd_set rset, allset;                            /* rset 读事件文件描述符集合 allset用来暂存 */  </span><br><span class="line">23.	  </span><br><span class="line">24.	    listenfd = Socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">25.	  </span><br><span class="line">26.	    int opt = 1;  </span><br><span class="line">27.	    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt));  </span><br><span class="line">28.	  </span><br><span class="line">29.	    bzero(&amp;serv_addr, sizeof(serv_addr));  </span><br><span class="line">30.	    serv_addr.sin_family= AF_INET;  </span><br><span class="line">31.	    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">32.	    serv_addr.sin_port= htons(SERV_PORT);  </span><br><span class="line">33.	  </span><br><span class="line">34.	    Bind(listenfd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr));  </span><br><span class="line">35.	    Listen(listenfd, 128);  </span><br><span class="line">36.	  </span><br><span class="line">37.	    maxfd = listenfd;                                           /* 起初 listenfd 即为最大文件描述符 */  </span><br><span class="line">38.	  </span><br><span class="line">39.	    maxi = -1;                                                  /* 将来用作client[]的下标, 初始值指向0个元素之前下标位置 */  </span><br><span class="line">40.	    for (i = 0; i &lt; FD_SETSIZE; i++)  </span><br><span class="line">41.	        client[i] = -1;                                         /* 用-1初始化client[] */  </span><br><span class="line">42.	  </span><br><span class="line">43.	    FD_ZERO(&amp;allset);  </span><br><span class="line">44.	    FD_SET(listenfd, &amp;allset);                                  /* 构造select监控文件描述符集 */  </span><br><span class="line">45.	  </span><br><span class="line">46.	    while (1) &#123;     </span><br><span class="line">47.	        rset = allset;                                          /* 每次循环时都重新设置select监控信号集 */  </span><br><span class="line">48.	  </span><br><span class="line">49.	        nready = select(maxfd+1, &amp;rset, NULL, NULL, NULL);  //2  1--lfd  1--connfd  </span><br><span class="line">50.	        if (nready &lt; 0)  </span><br><span class="line">51.	            perr_exit(&quot;select error&quot;);  </span><br><span class="line">52.	  </span><br><span class="line">53.	        if (FD_ISSET(listenfd, &amp;rset)) &#123;                        /* 说明有新的客户端链接请求 */  </span><br><span class="line">54.	  </span><br><span class="line">55.	            clie_addr_len = sizeof(clie_addr);  </span><br><span class="line">56.	            connfd = Accept(listenfd, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len);       /* Accept 不会阻塞 */  </span><br><span class="line">57.	            printf(&quot;received from %s at PORT %d\n&quot;,  </span><br><span class="line">58.	                    inet_ntop(AF_INET, &amp;clie_addr.sin_addr, str, sizeof(str)),  </span><br><span class="line">59.	                    ntohs(clie_addr.sin_port));  </span><br><span class="line">60.	  </span><br><span class="line">61.	            for (i = 0; i &lt; FD_SETSIZE; i++)  </span><br><span class="line">62.	                if (client[i] &lt; 0) &#123;                            /* 找client[]中没有使用的位置 */  </span><br><span class="line">63.	                    client[i] = connfd;                         /* 保存accept返回的文件描述符到client[]里 */  </span><br><span class="line">64.	                    break;  </span><br><span class="line">65.	                &#125;  </span><br><span class="line">66.	  </span><br><span class="line">67.	            if (i == FD_SETSIZE) &#123;                              /* 达到select能监控的文件个数上限 1024 */  </span><br><span class="line">68.	                fputs(&quot;too many clients\n&quot;, stderr);  </span><br><span class="line">69.	                exit(1);  </span><br><span class="line">70.	            &#125;  </span><br><span class="line">71.	  </span><br><span class="line">72.	            FD_SET(connfd, &amp;allset);                            /* 向监控文件描述符集合allset添加新的文件描述符connfd */  </span><br><span class="line">73.	  </span><br><span class="line">74.	            if (connfd &gt; maxfd)  </span><br><span class="line">75.	                maxfd = connfd;                                 /* select第一个参数需要 */  </span><br><span class="line">76.	  </span><br><span class="line">77.	            if (i &gt; maxi)  </span><br><span class="line">78.	                maxi = i;                                       /* 保证maxi存的总是client[]最后一个元素下标 */  </span><br><span class="line">79.	  </span><br><span class="line">80.	            if (--nready == 0)  </span><br><span class="line">81.	                continue;  </span><br><span class="line">82.	        &#125;   </span><br><span class="line">83.	  </span><br><span class="line">84.	        for (i = 0; i &lt;= maxi; i++) &#123;                               /* 检测哪个clients 有数据就绪 */  </span><br><span class="line">85.	  </span><br><span class="line">86.	            if ((sockfd = client[i]) &lt; 0)  </span><br><span class="line">87.	                continue;  </span><br><span class="line">88.	            if (FD_ISSET(sockfd, &amp;rset)) &#123;  </span><br><span class="line">89.	  </span><br><span class="line">90.	                if ((n = Read(sockfd, buf, sizeof(buf))) == 0) &#123;    /* 当client关闭链接时,服务器端也关闭对应链接 */  </span><br><span class="line">91.	                    Close(sockfd);  </span><br><span class="line">92.	                    FD_CLR(sockfd, &amp;allset);                        /* 解除select对此文件描述符的监控 */  </span><br><span class="line">93.	                    client[i] = -1;  </span><br><span class="line">94.	                &#125; else if (n &gt; 0) &#123;  </span><br><span class="line">95.	                    for (j = 0; j &lt; n; j++)  </span><br><span class="line">96.	                        buf[j] = toupper(buf[j]);  </span><br><span class="line">97.	                    Write(sockfd, buf, n);  </span><br><span class="line">98.	                    Write(STDOUT_FILENO, buf, n);  </span><br><span class="line">99.	                &#125;  </span><br><span class="line">100.	                if (--nready == 0)  </span><br><span class="line">101.	                    break;                                          /* 跳出for, 但还在while中 */  </span><br><span class="line">102.	            &#125;  </span><br><span class="line">103.	        &#125;  </span><br><span class="line">104.	    &#125;  </span><br><span class="line">105.	    Close(listenfd);  </span><br><span class="line">106.	    return 0;  </span><br><span class="line">107.	&#125;  </span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/06/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/06/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Linux-网络基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-06 10:44:33" itemprop="dateCreated datePublished" datetime="2023-07-06T10:44:33+08:00">2023-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-10 15:25:03" itemprop="dateModified" datetime="2023-07-10T15:25:03+08:00">2023-07-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是协议"><a href="#什么是协议" class="headerlink" title="什么是协议"></a>什么是协议</h2><p>从应用的角度出发，协议可理解为“规则”，是数据传输和数据的解释的规则。</p>
<p>假设，A、B双方欲传输文件。规定：</p>
<p>第一次，传输文件名，接收方接收到文件名，应答OK给传输方；</p>
<p>第二次，发送文件的尺寸，接收方接收到该数据再次应答一个OK；</p>
<p>第三次，传输文件内容。同样，接收方接收数据完成后应答OK表示文件内容接收成功。</p>
<p>由此，无论A、B之间传递何种文件，都是通过三次数据传输来完成。A、B之间形成了一个最简单的数据传输规则。双方都按此规则发送、接收数据。A、B之间达成的这个相互遵守的规则即为协议。</p>
<p>这种仅在A、B之间被遵守的协议称之为<strong>原始协议</strong>。当此协议被更多的人采用，不断的增加、改进、维护、完善。最终形成一个稳定的、完整的文件传输协议，被广泛应用于各种文件传输过程中。该协议就成为一个<strong>标准协议</strong>。最早的ftp协议就是由此衍生而来。</p>
<p>TCP协议注重数据的传输。http协议着重于数据的解释。</p>
<p><img src="/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230706104601518.png" alt="image-20230706104601518"></p>
<img src="/2023/07/06/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230706104601518.png" class title="This is an test image">

<h2 id="7层模型和4层模型及代表协议"><a href="#7层模型和4层模型及代表协议" class="headerlink" title="7层模型和4层模型及代表协议"></a>7层模型和4层模型及代表协议</h2><p>分层模型结构： </p>
<p>  OSI七层模型： 物、数、网、传、会、表、应</p>
<p>  TCP&#x2F;IP 4层模型：网（链路层&#x2F;网络接口层）、网、传、应</p>
<p>​    应用层：http、ftp、nfs、ssh、telnet。。。</p>
<p>​    传输层：TCP、UDP</p>
<p>​    网络层：IP、ICMP、IGMP</p>
<p>​    链路层：以太网帧协议、ARP</p>
<p><img src="/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230706104711613.png" alt="image-20230706104711613"></p>
<img src="/2023/07/06/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230706104711613.png" class title="This is an test image">

<p>网络传输流程： </p>
<p>  数据没有封装之前，是不能在网络中传递。</p>
<p>  数据-》应用层-》传输层-》网络层-》链路层 — 网络环境</p>
<h2 id="以太网帧和ARP请求"><a href="#以太网帧和ARP请求" class="headerlink" title="以太网帧和ARP请求"></a>以太网帧和ARP请求</h2><p><img src="/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230706104959831.png" alt="image-20230706104959831"></p>
<img src="/2023/07/06/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230706104959831.png" class title="This is an test image">

<p>以太网帧协议：</p>
<p>  ARP协议：根据 Ip 地址获取 mac 地址。</p>
<p>  以太网帧协议：根据mac地址，完成数据包传输。</p>
<h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p>IP协议：  </p>
<p>  版本： IPv4、IPv6 – 4位</p>
<p>  TTL： time to live 。 设置数据包在路由节点中的跳转上限。每经过一个路由节点，该值-1， 减为0的路由，有义务将该数据包丢弃</p>
<p>  源IP： 32位。— 4字节   192.168.1.108 — 点分十进制 IP地址（string） — 二进制 </p>
<p>  目的IP：32位。— 4字节</p>
<h2 id="端口号和UDP协议"><a href="#端口号和UDP协议" class="headerlink" title="端口号和UDP协议"></a>端口号和UDP协议</h2><p>UDP：</p>
<p>  16位：源端口号。 2^16 &#x3D; 65536 </p>
<p>  16位：目的端口号。</p>
<p>IP地址：可以在网络环境中，唯一标识一台主机。</p>
<p>端口号：可以网络的一台主机上，唯一标识一个进程。</p>
<p>ip地址+端口号：可以在网络环境中，唯一标识一个进程。</p>
<h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><p>TCP协议：</p>
<p>  16位：源端口号。 2^16 &#x3D; 65536 </p>
<p>  16位：目的端口号。</p>
<p>  32序号;</p>
<p>  32确认序号。 </p>
<p>  6个标志位。</p>
<p>  16位窗口大小。  2^16 &#x3D; 65536</p>
<h2 id="BS和CS模型对比"><a href="#BS和CS模型对比" class="headerlink" title="BS和CS模型对比"></a>BS和CS模型对比</h2><p>c&#x2F;s模型： </p>
<p>  client-server </p>
<p>b&#x2F;s模型： </p>
<p>  browser-server </p>
<p>​      C&#x2F;S        																																				B&#x2F;S</p>
<p>  优点： 缓存大量数据、协议选择灵活、速度快、迭代快（只需要发布再client就行）    				 安全性、跨平台、开发工作量较小</p>
<p>  缺点： 安全性、跨平台、开发工作量较大    						 																不能缓存大量数据、严格遵守 http</p>
<h2 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h2><p>网络套接字： socket</p>
<p>  一个文件描述符指向一个套接字（该套接字内部由内核借助两个缓冲区实现。）</p>
<p>  在通信过程中， 套接字一定是成对出现的。</p>
<h2 id="三次握手建立连接"><a href="#三次握手建立连接" class="headerlink" title="三次握手建立连接"></a>三次握手建立连接</h2><p><img src="/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230708145906727.png" alt="image-20230708145906727"></p>
<img src="/2023/07/06/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230708145906727.png" class title="This is an test image">

<p><img src="/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230708145932093.png" alt="image-20230708145932093"></p>
<img src="/2023/07/06/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230708145932093.png" class title="This is an test image">

<h2 id="数据通信"><a href="#数据通信" class="headerlink" title="数据通信"></a>数据通信</h2><p><img src="/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230708150003066.png" alt="image-20230708150003066"></p>
<img src="/2023/07/06/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230708150003066.png" class title="This is an test image">

<p>并不是一次发送，一次应答。也可以批量应答</p>
<h2 id="四次挥手关闭连接"><a href="#四次挥手关闭连接" class="headerlink" title="四次挥手关闭连接"></a>四次挥手关闭连接</h2><p><img src="/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230708150114631.png" alt="image-20230708150114631"></p>
<img src="/2023/07/06/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230708150114631.png" class title="This is an test image">

<p>完成两次挥手后，不是说两端的连接断开了，主动端关闭了写缓冲区，不能再向对端发送数据，被动端关闭了读缓冲区，不能再从对端读取数据。然而主动端还是能够读取对端发来的数据。</p>
<h2 id="滑动窗口和TCP数据包格式"><a href="#滑动窗口和TCP数据包格式" class="headerlink" title="滑动窗口和TCP数据包格式"></a>滑动窗口和TCP数据包格式</h2><p><img src="/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230708150203279.png" alt="image-20230708150203279"></p>
<img src="/2023/07/06/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230708150203279.png" class title="This is an test image">

<p>滑动窗口： </p>
<p>  发送给连接对端，本端的缓冲区大小（实时），保证数据不会丢失。</p>
<p>也就是这里win4096,注意几个阶段win可能含义不同。</p>
<p><img src="/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230708150611193.png" alt="image-20230708150611193"></p>
<img src="/2023/07/06/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230708150611193.png" class title="This is an test image">

<h2 id="通信时序与代码对应关系"><a href="#通信时序与代码对应关系" class="headerlink" title="通信时序与代码对应关系"></a>通信时序与代码对应关系</h2><p><img src="/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230708150636465.png" alt="image-20230708150636465"></p>
<img src="/2023/07/06/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230708150636465.png" class title="This is an test image">

<p>三次握手：</p>
<p>  主动发起连接请求端，发送 SYN 标志位，请求建立连接。 携带序号号、数据字节数(0)、滑动窗口大小。</p>
<p>  被动接受连接请求端，发送 ACK 标志位，同时携带 SYN 请求标志位。携带序号、确认序号、数据字节数(0)、滑动窗口大小。</p>
<p>  主动发起连接请求端，发送 ACK 标志位，应答服务器连接请求。携带确认序号。</p>
<p>四次挥手：</p>
<p>  主动关闭连接请求端， 发送 FIN 标志位。 </p>
<p>  被动关闭连接请求端， 应答 ACK 标志位。      —– 半关闭完成。</p>
<p>  被动关闭连接请求端， 发送 FIN 标志位。</p>
<p>  主动关闭连接请求端， 应答 ACK 标志位。   —– 连接全部关闭</p>
<p>滑动窗口：</p>
<p>  发送给连接对端，本端的缓冲区大小（实时），保证数据不会丢失。</p>
<h2 id="TCP状态"><a href="#TCP状态" class="headerlink" title="TCP状态"></a>TCP状态</h2><p><img src="/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230710142750740.png" alt="image-20230710142750740"></p>
<img src="/2023/07/06/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230710142750740.png" class title="This is an test image">

<p>实线是主动发起连接和关闭连接请求的一端，虚线是被动发起和关闭连接请求的一端。</p>
<p><code>netstat -apn | grep client</code>  查看客户端网络连接状态</p>
<p><code>netstat -apn | grep port</code>   查看端口的网络连接状态</p>
<p><img src="/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230710142832690.png" alt="image-20230710142832690"></p>
<img src="/2023/07/06/Linux-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230710142832690.png" class title="This is an test image">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">TCP状态时序图：</span><br><span class="line"></span><br><span class="line">	结合三次握手、四次挥手 理解记忆。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	1. 主动发起连接请求端：	CLOSE -- 发送SYN -- SEND_SYN -- 接收 ACK、SYN -- SEND_SYN -- 发送 ACK -- ESTABLISHED（数据通信态）</span><br><span class="line"></span><br><span class="line">	2. 主动关闭连接请求端： ESTABLISHED（数据通信态） -- 发送 FIN -- FIN_WAIT_1 -- 接收ACK -- FIN_WAIT_2（半关闭）</span><br><span class="line"></span><br><span class="line">				-- 接收对端发送 FIN -- FIN_WAIT_2（半关闭）-- 回发ACK -- TIME_WAIT（只有主动关闭连接方，会经历该状态）</span><br><span class="line"></span><br><span class="line">				-- 等 2MSL时长 -- CLOSE </span><br><span class="line"></span><br><span class="line">	3. 被动接收连接请求端： CLOSE -- LISTEN -- 接收 SYN -- LISTEN -- 发送 ACK、SYN -- SYN_RCVD -- 接收ACK -- ESTABLISHED（数据通信态）</span><br><span class="line"></span><br><span class="line">	4. 被动关闭连接请求端： ESTABLISHED（数据通信态） -- 接收 FIN -- ESTABLISHED（数据通信态） -- 发送ACK </span><br><span class="line"></span><br><span class="line">				-- CLOSE_WAIT (说明对端【主动关闭连接端】处于半关闭状态) -- 发送FIN -- LAST_ACK -- 接收ACK -- CLOSE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	重点记忆： ESTABLISHED、FIN_WAIT_2 &lt;--&gt; CLOSE_WAIT、TIME_WAIT（2MSL）</span><br><span class="line"></span><br><span class="line">	netstat -apn | grep  端口号</span><br><span class="line"></span><br><span class="line">2MSL时长：</span><br><span class="line"></span><br><span class="line">	一定出现在【主动关闭连接请求端】。 --- 对应 TIME_WAIT 状态。</span><br><span class="line"></span><br><span class="line">	保证，最后一个 ACK 能成功被对端接收。（等待期间，对端没收到我发的ACK，对端会再次发送FIN请求。）</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="端口复用函数"><a href="#端口复用函数" class="headerlink" title="端口复用函数"></a>端口复用函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">端口复用:</span><br><span class="line"></span><br><span class="line">	int opt = 1;		// 设置端口复用。</span><br><span class="line"></span><br><span class="line">	setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, (void *)&amp;opt, sizeof(opt))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以直接套的模板，复用的意思是这个端口是TIME_WAIT（一定出现在【主动关闭连接请求端】），即服务端close，防止等待时间太长，可以连续用这个端口。</p>
<h2 id="半关闭及shutdown函数"><a href="#半关闭及shutdown函数" class="headerlink" title="半关闭及shutdown函数"></a>半关闭及shutdown函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">半关闭：</span><br><span class="line"></span><br><span class="line">	通信双方中，只有一端关闭通信。  --- FIN_WAIT_2</span><br><span class="line"></span><br><span class="line">	close（cfd）;</span><br><span class="line"></span><br><span class="line">	shutdown(int fd, int how);	</span><br><span class="line"></span><br><span class="line">		how: 	SHUT_RD	关读端</span><br><span class="line"></span><br><span class="line">			SHUT_WR	关写端</span><br><span class="line"></span><br><span class="line">			SHUT_RDWR 关读写</span><br><span class="line"></span><br><span class="line">	shutdown在关闭多个文件描述符应用的文件时，采用全关闭方法。close，只关闭一个。即dup2多个文件描述符指向同一个时，shutdown关闭一个会将指向同一个的都关闭。</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/20/Linux-%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/20/Linux-%E9%94%81/" class="post-title-link" itemprop="url">Linux-锁</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-20 20:14:42" itemprop="dateCreated datePublished" datetime="2023-06-20T20:14:42+08:00">2023-06-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-04 11:05:21" itemprop="dateModified" datetime="2023-07-04T11:05:21+08:00">2023-07-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="线程同步概念"><a href="#线程同步概念" class="headerlink" title="线程同步概念"></a>线程同步概念</h2><p>线程同步： 协同步调，对公共区域数据按序访问。防止数据混乱，产生与时间有关的错误。</p>
<p>数据混乱的原因：</p>
<ol>
<li>资源共享(独享资源则不会)</li>
<li>调度随机(意味着数据访问会出现竞争)</li>
<li>线程间缺乏必要同步机制</li>
</ol>
<h2 id="锁使用的注意事项"><a href="#锁使用的注意事项" class="headerlink" title="锁使用的注意事项"></a>锁使用的注意事项</h2><p>锁的使用： 建议锁！对公共数据进行保护。所有线程【应该】在访问公共数据前先拿锁再访问。但，锁本身 不具备强制性。</p>
<h2 id="借助互斥锁管理共享数据实现同步"><a href="#借助互斥锁管理共享数据实现同步" class="headerlink" title="借助互斥锁管理共享数据实现同步"></a>借助互斥锁管理共享数据实现同步</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">主要应用函数：</span><br><span class="line">pthread_mutex_init 函数</span><br><span class="line">pthread_mutex_destory 函数</span><br><span class="line">pthread_mutex_lock 函数</span><br><span class="line">pthread_mutex_trylock 函数</span><br><span class="line">pthread_mutex_unlock 函数</span><br><span class="line">以上 5 个函数的返回值都是：成功返回 0，失败返回错误号</span><br><span class="line">pthread_mutex_t 类型，其本质是一个结构体。为简化理解，应用时可忽略其实现细节，简单当成整数看待</span><br><span class="line">pthread_mutex_t mutex；变量 mutex 只有两种取值：0,1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">使用 mutex(互斥量、互斥锁)一般步骤：</span><br><span class="line">pthread_mutex_t 类型。</span><br><span class="line">1. pthread_mutex_t lock; 创建锁</span><br><span class="line">2 pthread_mutex_init; 初始化 1</span><br><span class="line">3. pthread_mutex_lock;加锁 1-- --&gt; 0</span><br><span class="line">4. 访问共享数据（stdout)</span><br><span class="line">5. pthrad_mutext_unlock();解锁 0++ --&gt; 1</span><br><span class="line">6. pthead_mutex_destroy；销毁锁</span><br><span class="line"></span><br><span class="line">int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr)</span><br><span class="line">这里的 restrict 关键字，表示指针指向的内容只能通过这个指针进行修改</span><br><span class="line">restrict 关键字：用来限定指针变量。被该关键字限定的指针变量所指向的内存操作，必须由本指针完成。</span><br><span class="line">初始化互斥量：</span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line">1. pthread_mutex_init(&amp;mutex, NULL); 动态初始化。</span><br><span class="line">2. pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; 静态初始化。</span><br></pre></td></tr></table></figure>

<p>使用锁实现互斥访问共享区：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;string.h&gt;</span><br><span class="line">3. #include &lt;pthread.h&gt;</span><br><span class="line">4. #include &lt;stdlib.h&gt;</span><br><span class="line">5. #include &lt;unistd.h&gt;</span><br><span class="line">6.</span><br><span class="line">7. pthread_mutex_t mutex; // 定义一把互斥锁</span><br><span class="line">8.</span><br><span class="line">9. void *tfn(void *arg)</span><br><span class="line">10. &#123;</span><br><span class="line">11. srand(time(NULL));</span><br><span class="line">12.</span><br><span class="line">13. while (1) &#123;</span><br><span class="line">14. pthread_mutex_lock(&amp;mutex); // 加锁</span><br><span class="line">15. printf(&quot;hello &quot;);</span><br><span class="line">16. sleep(rand() % 3); // 模拟长时间操作共享资源，导致 cpu 易主，产生与时间有关的错误</span><br><span class="line">17. printf(&quot;world\n&quot;);</span><br><span class="line">18. pthread_mutex_unlock(&amp;mutex); // 解锁</span><br><span class="line">19. sleep(rand() % 3);</span><br><span class="line">20. &#125;</span><br><span class="line">21.</span><br><span class="line">22. return NULL;</span><br><span class="line">23. &#125;</span><br><span class="line">24.</span><br><span class="line">25. int main(void)</span><br><span class="line">26. &#123;</span><br><span class="line">27. pthread_t tid;</span><br><span class="line">28. srand(time(NULL));</span><br><span class="line">29. int ret = pthread_mutex_init(&amp;mutex, NULL); // 初始化互斥锁</span><br><span class="line">30. if(ret != 0)&#123;</span><br><span class="line">31. fprintf(stderr, &quot;mutex init error:%s\n&quot;, strerror(ret));</span><br><span class="line">32. exit(1);</span><br><span class="line">33. &#125;</span><br><span class="line">34.</span><br><span class="line">35. pthread_create(&amp;tid, NULL, tfn, NULL);</span><br><span class="line">36. while (1) &#123;</span><br><span class="line">37. pthread_mutex_lock(&amp;mutex); // 加锁</span><br><span class="line">38. printf(&quot;HELLO &quot;);</span><br><span class="line">39. sleep(rand() % 3);</span><br><span class="line">40. printf(&quot;WORLD\n&quot;);</span><br><span class="line">41. pthread_mutex_unlock(&amp;mutex); // 解锁</span><br><span class="line">42. sleep(rand() % 3);</span><br><span class="line">43. &#125;</span><br><span class="line">44. pthread_join(tid, NULL);</span><br><span class="line">45.</span><br><span class="line">46. pthread_mutex_destory(&amp;mutex); // 销毁互斥锁</span><br><span class="line">47.</span><br><span class="line">48. return 0;</span><br><span class="line">49. &#125;</span><br></pre></td></tr></table></figure>

<h3 id="互斥锁使用技巧"><a href="#互斥锁使用技巧" class="headerlink" title="互斥锁使用技巧"></a>互斥锁使用技巧</h3><p>注意事项：<br>尽量保证锁的粒度， 越小越好。（访问共享数据前，加锁。访问结束【立即】解锁。）<br>互斥锁，本质是结构体。 我们可以看成整数。 初值为 1。（pthread_mutex_init() 函数调用成功。）</p>
<p>加锁： –操作， 阻塞线程。<br>解锁： ++操作， 唤醒阻塞在锁上的线程。<br>try 锁：尝试加锁，成功–，加锁失败直接返回错误号(如 EBUSY)，不阻塞</p>
<h2 id="读写锁操作函数原型"><a href="#读写锁操作函数原型" class="headerlink" title="读写锁操作函数原型"></a>读写锁操作函数原型</h2><p>读写锁：<br>锁只有一把。以读方式给数据加锁——读锁。以写方式给数据加锁——写锁。<br>读共享，写独占。<br>写锁优先级高。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">相较于互斥量而言，当读线程多的时候，提高访问效率</span><br><span class="line">pthread_rwlock_t rwlock;</span><br><span class="line">pthread_rwlock_init(&amp;rwlock, NULL);</span><br><span class="line">pthread_rwlock_rdlock(&amp;rwlock);//有对应的try版本</span><br><span class="line">pthread_rwlock_wrlock(&amp;rwlock);//有对应的try版本</span><br><span class="line">pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line">以上函数都是成功返回 0，失败返回错误号。</span><br><span class="line">pthread_rwlock_t 类型 用于定义一个读写锁变量</span><br><span class="line">pthread_rwlock_t rwlock</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>读写锁也叫共享-独占锁。当读写锁以读模式锁住时，它是以共享模式锁住的，当它以写模式锁住时，它是以独占模式锁住的。写独占、读共享。<br>读写锁非常适合于<strong>对数据结构读的次数</strong>远大于写的情况。相较于互斥量来说，可以提高多线程的访问效率。</p>
<h3 id="rwlock"><a href="#rwlock" class="headerlink" title="rwlock"></a>rwlock</h3><p>一个读写锁的例子，核心还是 读共享，写独占。 写锁优先级高。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">1. /* 3 个线程不定时 &quot;写&quot; 全局资源，5 个线程不定时 &quot;读&quot; 同一全局资源 */</span><br><span class="line">2.</span><br><span class="line">3. #include &lt;stdio.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;pthread.h&gt;</span><br><span class="line">6.</span><br><span class="line">7. int counter; //全局资源</span><br><span class="line">8. pthread_rwlock_t rwlock;</span><br><span class="line">9.</span><br><span class="line">10. void *th_write(void *arg)</span><br><span class="line">11. &#123;</span><br><span class="line">12. int t;</span><br><span class="line">13. int i = (int)arg;</span><br><span class="line">14.</span><br><span class="line">15. while (1) &#123;</span><br><span class="line">16. t = counter; // 保存写之前的值</span><br><span class="line">17. usleep(1000);</span><br><span class="line">18.</span><br><span class="line">19. pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">20. printf(&quot;=======write %d: %lu: counter=%d ++counter=%d\n&quot;, i, pthread_self(), t, ++counter)</span><br><span class="line">;</span><br><span class="line">21. pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">22.</span><br><span class="line">23. usleep(9000); // 给 r 锁提供机会</span><br><span class="line">24. &#125;</span><br><span class="line">25. return NULL;</span><br><span class="line">26. &#125;</span><br><span class="line">27.</span><br><span class="line">28. void *th_read(void *arg)</span><br><span class="line">29. &#123;</span><br><span class="line">30. int i = (int)arg;</span><br><span class="line">31.</span><br><span class="line">32. while (1) &#123;</span><br><span class="line">33. pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">34. printf(&quot;----------------------------read %d: %lu: %d\n&quot;, i, pthread_self(), counter);</span><br><span class="line">35. pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">36.</span><br><span class="line">37. usleep(2000); // 给写锁提供机会</span><br><span class="line">38. &#125;</span><br><span class="line">39. return NULL;</span><br><span class="line">40. &#125;</span><br><span class="line">41.</span><br><span class="line">42. int main(void)</span><br><span class="line">43. &#123;</span><br><span class="line">44. int i;</span><br><span class="line">45. pthread_t tid[8];</span><br><span class="line">46.</span><br><span class="line">47. pthread_rwlock_init(&amp;rwlock, NULL);</span><br><span class="line">48.</span><br><span class="line">49. for (i = 0; i &lt; 3; i++)</span><br><span class="line">50. pthread_create(&amp;tid[i], NULL, th_write, (void *)i);</span><br><span class="line">51.</span><br><span class="line">52. for (i = 0; i &lt; 5; i++)</span><br><span class="line">53. pthread_create(&amp;tid[i+3], NULL, th_read, (void *)i);</span><br><span class="line">54.</span><br><span class="line">55. for (i = 0; i &lt; 8; i++)</span><br><span class="line">56. pthread_join(tid[i], NULL);</span><br><span class="line">57.</span><br><span class="line">58. pthread_rwlock_destroy(&amp;rwlock); //释放读写琐</span><br><span class="line">59.</span><br><span class="line">60. return 0;</span><br><span class="line">61. &#125;</span><br></pre></td></tr></table></figure>



<h2 id="两种死锁"><a href="#两种死锁" class="headerlink" title="两种死锁"></a>两种死锁</h2><p>【死锁】： 是使用锁不恰当导致的现象： 1. 对一个锁反复 lock。 2. 两个线程，各自持有一把锁，请求另一把。</p>
<p><img src="/Linux-%E9%94%81/image-20230620202333099.png" alt="image-20230620202333099"></p>
<img src="/2023/06/20/Linux-%E9%94%81/image-20230620202333099.png" class title="This is an test image">

<h2 id="静态初始化条件变量和互斥量"><a href="#静态初始化条件变量和互斥量" class="headerlink" title="静态初始化条件变量和互斥量"></a>静态初始化条件变量和互斥量</h2><p>条件变量： 本身不是锁！ 但是通常结合锁来使用。 mutex 主要应用函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_init函数。</span><br><span class="line">pthread_cond_destroy函数,</span><br><span class="line">pthread_cond_wait函数。</span><br><span class="line">pthread_cond_timedwait函数。</span><br><span class="line">pthread_cond_signal函数。</span><br><span class="line">pthread_cond_broadcast函数。</span><br><span class="line">以上6个函数的返回值都是:成功返回o，失败直接返回错误号。</span><br><span class="line">pthread_cond_t类型用于定义条件变量</span><br><span class="line">pthread_cond_ t cond;</span><br><span class="line">初始化条件变量：</span><br><span class="line">1. pthread_cond_init(&amp;cond, NULL); 动态初始化。</span><br><span class="line">2. pthread_cond_t cond = PTHREAD_COND_INITIALIZER; 静态初始化。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="条件变量和相关函数-wait"><a href="#条件变量和相关函数-wait" class="headerlink" title="条件变量和相关函数 wait"></a>条件变量和相关函数 wait</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">阻塞等待条件：</span><br><span class="line">pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">作用：</span><br><span class="line">1） 阻塞等待条件变量满足</span><br><span class="line">2） 解锁已经加锁成功的信号量 （相当于pthread_mutex_unlock(&amp;mutex)），12 两步为一个原子操作</span><br><span class="line">3) 当条件满足，函数返回时，解除阻塞并重新申请获取互斥锁。重新加锁信号量 （相当于， pthread_mutex_lock(&amp;mutex);）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="条件变量的生产者消费者模型分析"><a href="#条件变量的生产者消费者模型分析" class="headerlink" title="条件变量的生产者消费者模型分析"></a>条件变量的生产者消费者模型分析</h2><p><img src="/Linux-%E9%94%81/image-20230704103808582.png" alt="image-20230704103808582"></p>
<img src="/2023/06/20/Linux-%E9%94%81/image-20230704103808582.png" class title="This is an test image">

<h2 id="条件变量生产者消费者代码预览"><a href="#条件变量生产者消费者代码预览" class="headerlink" title="条件变量生产者消费者代码预览"></a>条件变量生产者消费者代码预览</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;errno.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">void err_thread(int ret,char *str)</span><br><span class="line">&#123;</span><br><span class="line">        if(ret!=0)&#123;</span><br><span class="line">                fprintf(stderr,&quot;%s:%s\n&quot;,str,strerror(ret));</span><br><span class="line">                pthread_exit(NULL);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*链表作为公享数据,需被互斥量保护*/</span><br><span class="line">struct msg&#123;</span><br><span class="line">        int num;</span><br><span class="line">        struct msg *next;</span><br><span class="line">&#125;;</span><br><span class="line">struct msg *head;</span><br><span class="line">. /* 静态初始化 一个条件变量 和 一个互斥量*/</span><br><span class="line">pthread_mutex_t mutex=PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line">pthread_cond_t has_data=PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void *produser(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">                struct msg *mp=malloc(sizeof(struct msg));</span><br><span class="line">                mp-&gt;num =rand()%1000 + 1;//模拟生产一个产品</span><br><span class="line">                printf(&quot;--produce %d\n&quot;,mp-&gt;num);</span><br><span class="line">                pthread_mutex_lock(&amp;mutex);</span><br><span class="line">                mp-&gt;next = head;</span><br><span class="line">                head =mp;</span><br><span class="line">                pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">                pthread_cond_signal(&amp;has_data);//将等待在该条件变量上的一个线程唤醒</span><br><span class="line">                sleep(rand() % 3);</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *consumer(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">                struct msg *mp;</span><br><span class="line">                pthread_mutex_lock(&amp;mutex);</span><br><span class="line">                while(head == NULL)&#123;//头指针为空,说明没有节点,多个消费者用while循环可以先判断条件是否成立</span><br><span class="line">                        pthread_cond_wait(&amp;has_data,&amp;mutex);// 解锁，并阻塞等待，pthread_cond_wait返回时，重新加锁mutex</span><br><span class="line">                &#125;</span><br><span class="line">                mp =head;</span><br><span class="line">                head=mp-&gt;next;//模拟消费掉一个产品</span><br><span class="line"></span><br><span class="line">                pthread_mutex_unlock(&amp;mutex);//解锁互斥量</span><br><span class="line">                printf(&quot;------consumer:%d\n&quot;,mp-&gt;num);</span><br><span class="line">                free(mp);</span><br><span class="line">                sleep(rand()%3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc,char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">        int ret;</span><br><span class="line">        pthread_t pid,cid;</span><br><span class="line">        srand(time(NULL));</span><br><span class="line">        ret=pthread_create(&amp;pid,NULL,produser,NULL);</span><br><span class="line"></span><br><span class="line">        if(ret!=0)</span><br><span class="line">                err_thread(ret,&quot;pthread_create produser error&quot;);</span><br><span class="line"></span><br><span class="line">        ret=pthread_create(&amp;cid,NULL,consumer,NULL);</span><br><span class="line">        if(ret!=0)</span><br><span class="line">                err_thread(ret,&quot;pthread_create consumer error&quot;);</span><br><span class="line">        pthread_join(pid,NULL);</span><br><span class="line"></span><br><span class="line">        pthread_join(cid,NULL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">由于是Linux新手，所以现在才开始接触线程编程，照着GUN/Linux编程指南中的一个例子输入编译，结果出现如下错误：</span><br><span class="line">undefined reference to &#x27;pthread_create&#x27;</span><br><span class="line">undefined reference to &#x27;pthread_join&#x27;</span><br><span class="line"></span><br><span class="line">问题原因：</span><br><span class="line">   pthread 库不是 Linux 系统默认的库，连接时需要使用静态库 libpthread.a，所以在使用pthread_create()创建线程，以及调用 pthread_atfork()函数建立fork处理程序时，需要链接该库。</span><br><span class="line"></span><br><span class="line">问题解决：</span><br><span class="line">    在编译中要加 -lpthread参数</span><br><span class="line">    gcc thread.c -o thread -lpthread</span><br><span class="line">    thread.c为你些的源文件，不要忘了加上头文件#include&lt;pthread.h&gt;</span><br></pre></td></tr></table></figure>

<p>多个消费者使用 while 做 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> int ret;</span><br><span class="line"> pthread_t pid, cid;</span><br><span class="line"></span><br><span class="line"> srand(time(NULL));</span><br><span class="line"></span><br><span class="line"> ret = pthread_create(&amp;pid, NULL, produser, NULL); // 生产者</span><br><span class="line"> if (ret != 0)</span><br><span class="line"> err_thread(ret, &quot;pthread_create produser error&quot;);</span><br><span class="line"></span><br><span class="line"> ret = pthread_create(&amp;cid, NULL, consumer, NULL); // 消费者</span><br><span class="line"> if (ret != 0)</span><br><span class="line"> err_thread(ret, &quot;pthread_create consuer error&quot;);</span><br><span class="line"></span><br><span class="line"> ret = pthread_create(&amp;cid, NULL, consumer, NULL); // 消费者</span><br><span class="line"> if (ret != 0)</span><br><span class="line"> err_thread(ret, &quot;pthread_create consuer error&quot;);</span><br><span class="line"></span><br><span class="line"> ret = pthread_create(&amp;cid, NULL, consumer, NULL); // 消费者</span><br><span class="line"> if (ret != 0)</span><br><span class="line"> err_thread(ret, &quot;pthread_create consuer error&quot;);</span><br><span class="line"></span><br><span class="line"> pthread_join(pid, NULL);</span><br><span class="line"> pthread_join(cid, NULL);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="条件变量-signal-注意事项"><a href="#条件变量-signal-注意事项" class="headerlink" title="条件变量 signal 注意事项"></a>条件变量 signal 注意事项</h3><p><code>pthread_cond_signal()</code>: 唤醒阻塞在条件变量上的 (至少)一个线程。 <code>pthread_cond_broadcast()</code>： 唤醒阻塞在条件变量上的 所有线程。</p>
<h2 id="信号量概念及其相关操作函数"><a href="#信号量概念及其相关操作函数" class="headerlink" title="信号量概念及其相关操作函数"></a>信号量概念及其相关操作函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">信号量：</span><br><span class="line">应用于线程、进程间同步。</span><br><span class="line">相当于 初始化值为 N 的互斥量。 N 值，表示可以同时访问共享数据区的线程数。</span><br><span class="line">函数：</span><br><span class="line">sem_t sem; 定义类型。</span><br><span class="line">int sem_init(sem_t *sem, int pshared, unsigned int value);</span><br><span class="line">参数：</span><br><span class="line">sem： 信号量</span><br><span class="line">pshared： 0： 用于线程间同步</span><br><span class="line">			1： 用于进程间同步</span><br><span class="line">value：N 值。（指定同时访问的线程数）</span><br><span class="line">sem_destroy();</span><br><span class="line">sem_wait(); 一次调用，做一次-- 操作，当信号量的值为 0 时，再次 -- 就会阻塞。（对比 pthread_mutex_lock）</span><br><span class="line">sem_post(); 一次调用，做一次++ 操作. 当信号量的值为 N 时, 再次 ++ 就会阻塞。（对比 pthread_mutex_unlock）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="信号量实现的生产者消费者"><a href="#信号量实现的生产者消费者" class="headerlink" title="信号量实现的生产者消费者"></a>信号量实现的生产者消费者</h2><p><img src="/Linux-%E9%94%81/image-20230704110250997.png" alt="image-20230704110250997"></p>
<img src="/2023/06/20/Linux-%E9%94%81/image-20230704110250997.png" class title="This is an test image">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">1. /*信号量实现 生产者 消费者问题*/</span><br><span class="line">2.</span><br><span class="line">3. #include &lt;stdlib.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;pthread.h&gt;</span><br><span class="line">6. #include &lt;stdio.h&gt;</span><br><span class="line">7. #include &lt;semaphore.h&gt;</span><br><span class="line">8.</span><br><span class="line">9. #define NUM 5</span><br><span class="line">10.</span><br><span class="line">11. int queue[NUM]; //全局数组实现环形队列</span><br><span class="line">12. sem_t blank_number, product_number; //空格子信号量, 产品信号量</span><br><span class="line">13.</span><br><span class="line">14. void *producer(void *arg)</span><br><span class="line">15. &#123;</span><br><span class="line">16. int i = 0;</span><br><span class="line">17.</span><br><span class="line">18. while (1) &#123;</span><br><span class="line">19. sem_wait(&amp;blank_number); //生产者将空格子数--,为 0 则阻塞等待</span><br><span class="line">20. queue[i] = rand() % 1000 + 1; //生产一个产品</span><br><span class="line">21. printf(&quot;----Produce---%d\n&quot;, queue[i]);</span><br><span class="line">22. sem_post(&amp;product_number); //将产品数++</span><br><span class="line">23.</span><br><span class="line">24. i = (i+1) % NUM; //借助下标实现环形</span><br><span class="line">25. sleep(rand()%1);</span><br><span class="line">26. &#125;</span><br><span class="line">27. &#125;</span><br><span class="line">28.</span><br><span class="line">29. void *consumer(void *arg)</span><br><span class="line">30. &#123;</span><br><span class="line">31. int i = 0;</span><br><span class="line">32.</span><br><span class="line">33. while (1) &#123;</span><br><span class="line">34. sem_wait(&amp;product_number); //消费者将产品数--,为 0 则阻塞等待</span><br><span class="line">35. printf(&quot;-Consume---%d\n&quot;, queue[i]);</span><br><span class="line">36. queue[i] = 0; //消费一个产品</span><br><span class="line">37. sem_post(&amp;blank_number); //消费掉以后,将空格子数++</span><br><span class="line">38.</span><br><span class="line">39. i = (i+1) % NUM;</span><br><span class="line">40. sleep(rand()%3);</span><br><span class="line">41. &#125;</span><br><span class="line">42. &#125;</span><br><span class="line">43.</span><br><span class="line">44. int main(int argc, char *argv[])</span><br><span class="line">45. &#123;</span><br><span class="line">46. pthread_t pid, cid;</span><br><span class="line">47.</span><br><span class="line">48. sem_init(&amp;blank_number, 0, NUM); //初始化空格子信号量为 5, 线程间共享 -- 0</span><br><span class="line">49. sem_init(&amp;product_number, 0, 0); //产品数为 0</span><br><span class="line">50.</span><br><span class="line">51. pthread_create(&amp;pid, NULL, producer, NULL);</span><br><span class="line">52. pthread_create(&amp;cid, NULL, consumer, NULL);</span><br><span class="line">53.</span><br><span class="line">54. pthread_join(pid, NULL);</span><br><span class="line">55. pthread_join(cid, NULL);</span><br><span class="line">56.</span><br><span class="line">57. sem_destroy(&amp;blank_number);</span><br><span class="line">58. sem_destroy(&amp;product_number);</span><br><span class="line">59.</span><br><span class="line">60. return 0;</span><br><span class="line">61. &#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/18/Linux-%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/18/Linux-%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">Linux-线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-18 11:40:33" itemprop="dateCreated datePublished" datetime="2023-06-18T11:40:33+08:00">2023-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-07 09:54:11" itemprop="dateModified" datetime="2023-07-07T09:54:11+08:00">2023-07-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h2><p>线程概念：<br>进程：有独立的 进程地址空间。有独立的 pcb。 分配资源的最小单位。<br>线程：有独立的 pcb。没有独立的进程地址空间。 最小单位的执行。<br>ps -Lf 进程 id —&gt; 线程号。LWP –》cpu 执行的最小单位（线程）。</p>
<p>ps -Lf 进程号 查看进程的线程</p>
<p><img src="/Linux-%E7%BA%BF%E7%A8%8B/image-20230617155342436.png" alt="image-20230617155342436"></p>
<img src="/2023/06/18/Linux-%E7%BA%BF%E7%A8%8B/image-20230617155342436.png" class title="This is an test image">

<p>一个进程的线程越多，争取cpu的概率越大，但是会有峰值，然后降低</p>
<h2 id="三级映射"><a href="#三级映射" class="headerlink" title="三级映射"></a>三级映射</h2><h3 id="Linux内核线程实现原理"><a href="#Linux内核线程实现原理" class="headerlink" title="Linux内核线程实现原理"></a>Linux内核线程实现原理</h3><p>类Unix系统中，早期是没有“线程”概念的，80年代才引入，借助进程机制实现出了线程的概念。因此在这类系统中，进程和线程关系密切。</p>
<p>1.轻量级进程(light-weight process)，也有 PCB，创建线程使用的底层函数和进程一样，都是clone</p>
<p>2.从内核里看进程和线程是一样的，都有各自不同的PCB，但是PCB 中指向内存资源的三级页表是相同的</p>
<p>3.进程可以蜕变成线程。</p>
<p>4.线程可看做寄存器和栈的集合（寄存器在cpu上用来计算，栈帧开辟在栈上，目的是执行函数和存放局部变量，临时值和形参）</p>
<p>5.在 linux 下，线程是最小的执行单位;进程是最小的分配资源单位。</p>
<p>查看Lwp号:<code>ps -lf pid</code>查看指定线程的 lwp号。</p>
<h3 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB."></a>进程控制块PCB.</h3><p>我们知道,每个进程在内核中都有一个进程控制块(PCB)来维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。</p>
<p><code>/usr/src/linux-headers-3.16.0-30/include/linux/sched.h</code>.文件中可以查看struct task_struct结构体定义。其内部成员有很多，我们重点掌握以下部分即可:</p>
<ul>
<li>进程id。系统中每个进程有唯一的id，在c语言中用pid_t类型表示，其实就是一个非负整数。</li>
<li>进程的状态，有就绪、运行、挂起、停止等状态。</li>
<li>进程切换时需要保存和恢复的一些cPu寄存器。</li>
<li>描述虚拟地址空间的信息</li>
<li>描述控制终端的信息。</li>
<li>当前工作目录(Current Working Directory)。</li>
<li>umask掩码。</li>
<li>文件描述符表，包含很多指向file结构体的指针。</li>
<li>和信号相关的信息。</li>
<li>用户id和组id。</li>
<li>会话(Session）和进程组。</li>
<li>进程可以使用的资源上限（Resource Limit) 。</li>
</ul>
<p><img src="/Linux-%E7%BA%BF%E7%A8%8B/image-20230617160559643.png" alt="image-20230617160559643"></p>
<img src="/2023/06/18/Linux-%E7%BA%BF%E7%A8%8B/image-20230617160559643.png" class title="This is an test image">

<p>如果是fork则另外一个进程，指向的就不一样。我们之前讲没有pcb，其实映射是需要经过pcb的。</p>
<h2 id="线程共享和非共享"><a href="#线程共享和非共享" class="headerlink" title="线程共享和非共享"></a>线程共享和非共享</h2><p>线程共享资源</p>
<ul>
<li>1.文件描述符表</li>
<li>2.每种信号的处理方式</li>
<li>3.当前工作目录</li>
<li>4.用户ID和组ID</li>
<li>5.内存地址空间(.text&#x2F;.data&#x2F;.bss&#x2F;heap&#x2F;共享库)，就是没有<strong>栈</strong>（栈执行函数和存放局部变量，临时值和形参）</li>
</ul>
<p>线程非共享资源</p>
<ul>
<li>1.线程id</li>
<li>2.处理器现场（寄存器计算的数据在处理器保存）和<strong>栈</strong>指针(内核栈)</li>
<li>3.独立的栈空间(用户空间栈)</li>
<li>4.errno变量</li>
<li>5.信号屏蔽字</li>
<li>6.调度优先级</li>
</ul>
<p>线程优、缺点：<br>优点:1.提高程序并发性	2.开销小 	3.数据通信、共享数据方便。（可以共享全局变量，不像父子进程，读时共享、写时复制）<br>缺点:1.库函数，不稳定	2.调试、编写困难、gdb不支持	3.对信号支持不好。</p>
<p>优点相对突出，缺点均不是硬伤。Linux下由于实现方法导致进程、线程差别不是很大。一般能使用线程就使用线程。</p>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pthread_t *tid是传出参数</span><br><span class="line">C++ 中的参数，既可以当做传入参数，也可以当做传出参数，具体要看参数的数据类型。</span><br><span class="line"></span><br><span class="line">非指针，非引用类型：一定是当做传入参数；</span><br><span class="line">指针，引用类型：既可以当做传入参数；也可以当做传出参数；甚至可以同时是传入参数，也是传出参数。</span><br><span class="line">其次要看对参数进行的操作：</span><br><span class="line"></span><br><span class="line">如果是只有读取，没有修改的，那就是传入参数，这时可以加上 const 限定符，以防不小心修改了参数。</span><br><span class="line">如果只有对参数进行写入，没有读取的，那就是当做传出参数的。</span><br><span class="line">如果对参数先进行了读取操作，然后又进行了写入操作，那么就是既当传入参数也当传出参数了。</span><br></pre></td></tr></table></figure>

<p><code>pthread_t pthread_self(void)</code>; 获取线程 id。 线程 id 是在进程地址空间内部，用来标识线程身份的 id 号。<br>    返回值：本线程 id<br>检查出错返回： 线程中。<br>    fprintf(stderr, “xxx error: %s\n”, strerror(ret));<br><code>int pthread_create(pthread_t *tid, const pthread_attr_t *attr, void *(*start_rountn)(void *), void *arg);</code> 创建子线程。<br>    参 1：传出参数，表新创建的子线程 id<br>    参 2：线程属性。传 NULL 表使用默认属性。<br>    参 3：子线程回调函数。创建成功，ptherad_create 函数返回时，该函数会被自动调用。<br>    参 4：参 3 的参数。没有的话，传 NULL<br>    返回值：成功：0<br>        失败：errno</p>
<p>下面这个例子，创建一个子线程去执行其他任务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;errno.h&gt;</span><br><span class="line">6. #include &lt;pthread.h&gt;</span><br><span class="line">7.</span><br><span class="line">8. void sys_err(const char *str)&#123;</span><br><span class="line">9. perror(str);</span><br><span class="line">10. exit(1);</span><br><span class="line">11. &#125;</span><br><span class="line">12.</span><br><span class="line">13. void *tfn(void *arg)&#123;</span><br><span class="line">14. printf(&quot;thread: pid = %d, tid = %lu\n&quot;, getpid(), pthread_self());</span><br><span class="line">15.</span><br><span class="line">16. return NULL;</span><br><span class="line">17. &#125;</span><br><span class="line">18.</span><br><span class="line">19. int main(int argc, char *argv[])&#123;</span><br><span class="line">20. pthread_t tid;</span><br><span class="line">21.</span><br><span class="line">22. printf(&quot;main: pid = %d, tid = %lu\n&quot;, getpid(), pthread_self());</span><br><span class="line">23.</span><br><span class="line">24. int ret = pthread_create(&amp;tid, NULL, tfn, NULL);</span><br><span class="line">25. if (ret != 0) &#123;</span><br><span class="line">26. perror(&quot;pthread_create error&quot;);</span><br><span class="line">27. &#125;</span><br><span class="line">28.</span><br><span class="line">29. return 0;</span><br><span class="line">30. &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，子线程的打印信息并未出现。原因在于，主线程执行完之后，就销毁了整个进程的地址空间，于是子线程就无法打印。简单粗暴的方法就是让主线程睡 1 秒，等子线程执行。</p>
<h2 id="循环创建多个子线程"><a href="#循环创建多个子线程" class="headerlink" title="循环创建多个子线程"></a>循环创建多个子线程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;errno.h&gt;</span><br><span class="line">6. #include &lt;pthread.h&gt;</span><br><span class="line">7.</span><br><span class="line">8. void sys_err(const char *str)&#123;</span><br><span class="line">9. perror(str);</span><br><span class="line">10. exit(1);</span><br><span class="line">11. &#125;</span><br><span class="line">12.</span><br><span class="line">13. void *tfn(void *arg)&#123;</span><br><span class="line">14. int i = (int)arg;//int i = *((int *)arg)和(void *)&amp;i，子线程如果用地址传递 i，会去读取主线程里的 i 值，而主线程里的 i 是动态变化的，不固定。所以，应该采用值传递，不用指针传递。</span><br><span class="line"></span><br><span class="line">15. sleep(i);</span><br><span class="line">16. printf(&quot;--I&#x27;m %dth thread: pid = %d, tid = %lu\n&quot;,i+1, getpid(), pthread_self());</span><br><span class="line">17.</span><br><span class="line">18. return NULL;</span><br><span class="line">19. &#125;</span><br><span class="line">20.</span><br><span class="line">21. int main(int argc, char *argv[])&#123;</span><br><span class="line">22. int i;</span><br><span class="line">23. int ret;</span><br><span class="line">24. pthread_t tid;</span><br><span class="line">25.</span><br><span class="line">26. for(i=0;i&lt;5;i++)&#123;</span><br><span class="line">27. ret = pthread_create(&amp;tid, NULL, tfn, (void *)i);//(void *)&amp;i</span><br><span class="line">28. if (ret != 0) &#123;</span><br><span class="line">29. sys_err(&quot;pthread_create error&quot;);</span><br><span class="line">30. &#125;</span><br><span class="line">31. &#125;</span><br><span class="line">32. sleep(i);</span><br><span class="line">33. printf(&quot;I&#x27;m main, pid = %d, tid = %lu\n&quot;, getpid(), pthread_self());</span><br><span class="line">34.</span><br><span class="line">35. return 0;</span><br><span class="line">36. &#125;</span><br></pre></td></tr></table></figure>

<h2 id="pthread-exit-退出"><a href="#pthread-exit-退出" class="headerlink" title="pthread_exit 退出"></a>pthread_exit 退出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void pthread_exit(void *retval); 退出当前线程。</span><br><span class="line">    retval：退出值。 无退出值时，NULL</span><br><span class="line">    exit(); 退出当前进程。</span><br><span class="line">    return: 返回到调用者那里去。</span><br><span class="line">    pthread_exit(): 退出当前线程。</span><br><span class="line">如果在回调函数里加一段代码：</span><br><span class="line">if(i == 2)</span><br><span class="line">	exit(0);</span><br><span class="line">看起来好像是退出了第三个子线程，然而运行时，发现后续的 4,5 也没了。这是因为，exit 是退</span><br><span class="line">出进程。</span><br><span class="line">一、修改一下，换成：</span><br><span class="line">if(i == 2)</span><br><span class="line">	return NULL;</span><br><span class="line">这样运行一下，发现后续线程不会凉凉，说明 return 是可以达到退出线程的目的。然而真正意义上，return 是返回到函数调用者那里去，线程并没有退出。</span><br><span class="line">二、再修改一下，再定义一个函数 func，直接返回那种</span><br><span class="line">void *func(void)&#123;</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line">if(i == 2)</span><br><span class="line">	func();</span><br><span class="line">运行，发现 1,2,3,4,5 线程都还在，说明没有达到退出目的。</span><br><span class="line">三、再次修改：</span><br><span class="line">void *func(void)&#123;</span><br><span class="line">	pthread_exit(NULL);</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line">if(i == 2)</span><br><span class="line">	func();</span><br><span class="line">编译运行，发现 3 没了，看起来很科学的样子。pthread_exit 表示将当前线程退出。放在函数里，还是直接调用，都可以。</span><br><span class="line">回到之前说的一个问题，由于主线程可能先于子线程结束，所以子线程的输出可能不会打印出来，当时是用主线程 sleep 等待子线程结束来解决的。现在就可以使用 pthread_exit 来解决了。方法就是将 return 0 替换为 pthread_exit，只退出当前线程，不会对其他线程造成影响。</span><br><span class="line">void pthread_exit(void *retval); 退出当前线程。</span><br><span class="line">    retval：退出值。 无退出值时，NULL</span><br><span class="line">    exit(); 退出当前进程。</span><br><span class="line">    return: 返回到调用者那里去。</span><br><span class="line">    pthread_exit(): 退出当前线程。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join"></a>pthread_join</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int pthread_join(pthread_t thread, void **retval); 阻塞 回收线程。</span><br><span class="line">	thread: 待回收的线程 id</span><br><span class="line">	retval：传出参数。 回收的那个线程的退出值。return</span><br><span class="line">线程异常解除，值为 -1。成功被 pthread_cancel() 杀死的线程，返回 -1.使用 pthead_join 回收。</span><br><span class="line">	返回值：成功：0</span><br><span class="line">	失败：errno</span><br></pre></td></tr></table></figure>

<p>下面这个是回收线程并获取子线程返回值的小例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;errno.h&gt;</span><br><span class="line">6. #include &lt;pthread.h&gt;</span><br><span class="line">7.</span><br><span class="line">8. struct thrd &#123;</span><br><span class="line">9. int var;</span><br><span class="line">10. char str[256];</span><br><span class="line">11. &#125;;</span><br><span class="line">12.</span><br><span class="line">13. void sys_err(const char *str)</span><br><span class="line">14. &#123;</span><br><span class="line">15. perror(str);</span><br><span class="line">16. exit(1);</span><br><span class="line">17. &#125;</span><br><span class="line">18.</span><br><span class="line">19. void *tfn(void *arg)</span><br><span class="line">20. &#123;</span><br><span class="line">21. struct thrd *tval;</span><br><span class="line">22.</span><br><span class="line">23. tval = malloc(sizeof(tval));</span><br><span class="line">24. tval-&gt;var = 100;</span><br><span class="line">25. strcpy(tval-&gt;str, &quot;hello thread&quot;);</span><br><span class="line">26.</span><br><span class="line">27. return (void *)tval;</span><br><span class="line">28. &#125;</span><br><span class="line">29.</span><br><span class="line">30. int main(int argc, char *argv[])</span><br><span class="line">31. &#123;</span><br><span class="line">32. pthread_t tid;</span><br><span class="line">33.</span><br><span class="line">34. struct thrd *retval;</span><br><span class="line">35.</span><br><span class="line">36. int ret = pthread_create(&amp;tid, NULL, tfn, NULL);</span><br><span class="line">37. if (ret != 0)</span><br><span class="line">38. sys_err(&quot;pthread_create error&quot;);</span><br><span class="line">39.</span><br><span class="line">40. //int pthread_join(pthread_t thread, void **retval);//void **retval同样是传出参数</span><br><span class="line">41. ret = pthread_join(tid, (void **)&amp;retval);</span><br><span class="line">42. if (ret != 0)</span><br><span class="line">43. sys_err(&quot;pthread_join error&quot;);</span><br><span class="line">44.</span><br><span class="line">45. printf(&quot;child thread exit with var= %d, str= %s\n&quot;, retval-&gt;var, retval-&gt;str);</span><br><span class="line">46.</span><br><span class="line">47. pthread_exit(NULL);//由于主线程可能先于子线程结束，所以子线程的输出可能不会打印出来，当时是用主线程 sleep 等待子线程结束来解决的。现在就可以使用 pthread_exit 来解决了。方法就是将 return 0 替换为 pthread_exit，只退出当前线程，不会对其他线程造成影响。</span><br><span class="line">48.</span><br><span class="line">49. &#125;</span><br></pre></td></tr></table></figure>

<p>还可以改为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void *tfn(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    struct thrd *tval = (struct thrd *)arg;</span><br><span class="line">    tval-&gt;var = 100;</span><br><span class="line">    strcpy(tval-&gt;str,&quot;hello thread&quot;);</span><br><span class="line">    return (void *)tvai;//返回的是arg地址所以可以用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc,char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    pthread_t tid;</span><br><span class="line">    struct thrd arg;</span><br><span class="line">    struct thrd *retval;</span><br><span class="line">    int ret = pthread_create(&amp;tid，NULL, tfn，(void *)&amp;arg);</span><br><span class="line">    if (ret != 0)</span><br><span class="line">        sys_err( &quot;pthread_create error&quot;);</span><br><span class="line">    //int pthread_join(pthread_t thread, void **retval);</span><br><span class="line">    ret = pthread_join(tid,(void **)&amp;retval);</span><br><span class="line">    if (ret != 0)</span><br><span class="line">        sys_err( &quot;pthread_join error&quot;);</span><br><span class="line">    printf( &quot; child thread exit with var= %d，str= %s\n&quot;,retval-&gt;var,retval-&gt;str);</span><br><span class="line">    pthreadexit(NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="pthread-cancel-函数"><a href="#pthread-cancel-函数" class="headerlink" title="pthread_cancel 函数"></a>pthread_cancel 函数</h2><p><code>int pthread_cancel(pthread_t thread);</code> 杀死一个线程。 需要到达取消点（保存点），即需要调动系统内核<br>    thread: 待杀死的线程 id<br>    返回值：成功：0<br>    失败：errno<br>如果，子线程没有到达取消点， 那么 pthread_cancel 无效。<br>我们可以在程序中，手动添加一个取消点。使用 pthread_testcancel();<br>成功被 pthread_cancel() 杀死的线程，返回 -1.使用 pthead_join 回收。</p>
<p>小例子，主线程调用 pthread_cancel 杀死子线程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;errno.h&gt;</span><br><span class="line">6. #include &lt;pthread.h&gt;</span><br><span class="line">7.</span><br><span class="line">8.</span><br><span class="line">9. void *tfn(void *arg)&#123;</span><br><span class="line">10. while (1) &#123;</span><br><span class="line">11. printf(&quot;thread: pid = %d, tid = %lu\n&quot;, getpid(), pthread_self());</span><br><span class="line">12. sleep(1);</span><br><span class="line">13. &#125;</span><br><span class="line">14.</span><br><span class="line">15. return NULL;</span><br><span class="line">16. &#125;</span><br><span class="line">17.</span><br><span class="line">18. int main(int argc, char *argv[])&#123;</span><br><span class="line">19. pthread_t tid;</span><br><span class="line">20.</span><br><span class="line">21. int ret = pthread_create(&amp;tid, NULL, tfn, NULL);</span><br><span class="line">22. if (ret != 0) &#123;</span><br><span class="line">23. fprintf(stderr, &quot;pthread_create error:%s\n&quot;, strerror(ret));</span><br><span class="line">24. exit(1);</span><br><span class="line">25. &#125;</span><br><span class="line">26.</span><br><span class="line">27. printf(&quot;main: pid = %d, tid = %lu\n&quot;, getpid(), pthread_self());</span><br><span class="line">28.</span><br><span class="line">29. sleep(5);</span><br><span class="line">30.</span><br><span class="line">31. ret = pthread_cancel(tid); // 终止线程</span><br><span class="line">32. if (ret != 0) &#123;</span><br><span class="line">33. fprintf(stderr, &quot;pthread_cancel error:%s\n&quot;, strerror(ret));</span><br><span class="line">34. exit(1);</span><br><span class="line">35. &#125;</span><br><span class="line">36.</span><br><span class="line">37. while (1);</span><br><span class="line">38.</span><br><span class="line">39. pthread_exit((void *)0);//由于主线程可能先于子线程结束，所以子线程的输出可能不会打印出来，当时是用主线程 sleep 等待子线程结束来解决的。现在就可以使用 pthread_exit 来解决了。方法就是将 return 0 替换为 pthread_exit，只退出当前线程，不会对其他线程造成影响。</span><br><span class="line">40. &#125;</span><br></pre></td></tr></table></figure>

<p>这里要注意一点，pthread_cancel 工作的必要条件是进入内核，如果 tfn 真的奇葩到没有进入内核， 则 pthread_cancel 不能杀死线程，此时需要手动设置取消点，就是 pthread_testcancel()</p>
<h2 id="检查出错返回"><a href="#检查出错返回" class="headerlink" title="检查出错返回"></a>检查出错返回</h2><p>int pthread_detach(pthread_t thread); 设置线程分离<br>    thread: 待分离的线程 id<br>    返回值：成功：0<br>    失败：errno</p>
<p>下面这个例子，使用 detach 分离线程，照理来说，分离后的线程会自动回收：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;errno.h&gt;</span><br><span class="line">6. #include &lt;pthread.h&gt;</span><br><span class="line">7.</span><br><span class="line">8.</span><br><span class="line">9. void *tfn(void *arg)</span><br><span class="line">10. &#123;</span><br><span class="line">11. printf(&quot;thread: pid = %d, tid = %lu\n&quot;, getpid(), pthread_self());</span><br><span class="line">12.</span><br><span class="line">13. return NULL;</span><br><span class="line">14. &#125;</span><br><span class="line">15.</span><br><span class="line">16. int main(int argc, char *argv[])</span><br><span class="line">17. &#123;</span><br><span class="line">18. pthread_t tid;</span><br><span class="line">19.</span><br><span class="line">20. int ret = pthread_create(&amp;tid, NULL, tfn, NULL);</span><br><span class="line">21. if (ret != 0) &#123;</span><br><span class="line">22. perror(&quot;pthread_create error&quot;);</span><br><span class="line">23. &#125;</span><br><span class="line">24. ret = pthread_detach(tid); // 设置线程分离` 线程终止,会自动清理 pcb,无需回收</span><br><span class="line">25. if (ret != 0) &#123;</span><br><span class="line">26. perror(&quot;pthread_detach error&quot;);</span><br><span class="line">27. &#125;</span><br><span class="line">28.</span><br><span class="line">29. sleep(1);</span><br><span class="line">30.</span><br><span class="line">31. ret = pthread_join(tid, NULL);</span><br><span class="line">32. printf(&quot;join ret = %d\n&quot;, ret);</span><br><span class="line">33. if (ret != 0) &#123;</span><br><span class="line">34. perror(&quot;pthread_join error&quot;);</span><br><span class="line">35. &#125;</span><br><span class="line">36.</span><br><span class="line">37. printf(&quot;main: pid = %d, tid = %lu\n&quot;, getpid(), pthread_self());</span><br><span class="line">38.</span><br><span class="line">39. pthread_exit((void *)0);</span><br><span class="line">40. &#125;</span><br></pre></td></tr></table></figure>

<p>这里，问题出现了，join 出错了，但是没打印错误原因。之前的 perror 方法检查线程错误是有 问题的。应该使用 strerror，修改代码如下，因为perror方法是底层的一个全局变量，线程不能用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">20. int ret = pthread_create(&amp;tid, NULL, tfn, NULL);</span><br><span class="line">21. if (ret != 0) &#123;</span><br><span class="line">22. fprintf(stderr, &quot;pthread_create error: %s\n&quot;, strerror(ret));//stderr,直接输出到终端</span><br><span class="line">23. exit(1);</span><br><span class="line">24. &#125;</span><br></pre></td></tr></table></figure>

<p>出错，是因为线程分离后，系统会自动回收资源，用 pthread_join 去回收已经被系统 回收的线程，那个线程号就是无效参数。</p>
<p><code>pthread_join()</code>和<code>pthread_detach()</code>是用于管理线程资源的两种方式，但它们的作用是不同的。</p>
<ul>
<li><code>pthread_join(thread, status)</code>函数会将主线程阻塞，直到指定的线程 <code>thread</code> 终止。一旦目标线程终止，调用线程将从阻塞状态返回，并可以获取目标线程的退出状态信息。通过这种方式，<code>pthread_join()</code>可以实现对子线程的资源回收和同步等待操作。</li>
<li><code>pthread_detach(thread)</code>函数则是将指定的线程 <code>thread</code> 设置为分离状态，从而使得线程结束后自动释放其相关资源，包括线程栈空间和线程描述符等。相当于告诉系统不需要进行显式的资源回收操作，由系统自动回收资源。</li>
</ul>
<p>所以，虽然<code>pthread_join()</code>和<code>pthread_detach()</code>都能起到资源回收的作用，它们的使用场景和效果略有差异。<code>pthread_join()</code>适用于需要等待线程执行完毕并获取其返回状态的情况，而<code>pthread_detach()</code>适用于不关心线程返回状态，只希望在线程结束后自动回收资源的情况</p>
<h2 id="进程和线程控制原语对比"><a href="#进程和线程控制原语对比" class="headerlink" title="进程和线程控制原语对比"></a>进程和线程控制原语对比</h2><p>线程控制原语 			进程控制原语<br>pthread_create() 		fork();<br>pthread_self() 			getpid();<br>pthread_exit() 			exit(); 	&#x2F; return &#x2F;&#x2F;exit实际是退出进程，无论在哪个线程都会将整个进程都退出，return是退回到上一次调用的地方，所有只有都在主函数调用的时候效果一样。<br>pthread_join() 			wait()&#x2F;waitpid()<br>pthread_cancel() 		kill()<br>pthread_detach()</p>
<h2 id="线程属性设置分离线程"><a href="#线程属性设置分离线程" class="headerlink" title="线程属性设置分离线程"></a>线程属性设置分离线程</h2><p>线程属性：<br>设置分离属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pthread_attr_t attr 创建一个线程属性结构体变量</span><br><span class="line">pthread_attr_init(&amp;attr); 初始化线程属性</span><br><span class="line">pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED); 设置线程属性为分离态</span><br><span class="line">pthread_create(&amp;tid, &amp;attr, tfn, NULL); 借助修改后的 设置线程属性 创建为分离态的新线程</span><br><span class="line">pthread_attr_destroy(&amp;attr); 销毁线程属性</span><br></pre></td></tr></table></figure>

<p>调整线程状态，使线程创建出来就是分离态，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;errno.h&gt;</span><br><span class="line">6. #include &lt;pthread.h&gt;</span><br><span class="line">7.</span><br><span class="line">8.</span><br><span class="line">9. void *tfn(void *arg)</span><br><span class="line">10. &#123;</span><br><span class="line">11. printf(&quot;thread: pid = %d, tid = %lu\n&quot;, getpid(), pthread_self());</span><br><span class="line">12.</span><br><span class="line">13. return NULL;</span><br><span class="line">14. &#125;</span><br><span class="line">15.</span><br><span class="line">16. int main(int argc, char *argv[])</span><br><span class="line">17. &#123;</span><br><span class="line">18. pthread_t tid;</span><br><span class="line">19.</span><br><span class="line">20. pthread_attr_t attr;</span><br><span class="line">21.</span><br><span class="line">22. int ret = pthread_attr_init(&amp;attr);</span><br><span class="line">23. if (ret != 0) &#123;</span><br><span class="line">24. fprintf(stderr, &quot;attr_init error:%s\n&quot;, strerror(ret));</span><br><span class="line">25. exit(1);</span><br><span class="line">26. &#125;</span><br><span class="line">27.</span><br><span class="line">28. ret = pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED); // 设置线程属性为 分离属性</span><br><span class="line">29. if (ret != 0) &#123;</span><br><span class="line">30. fprintf(stderr, &quot;attr_setdetachstate error:%s\n&quot;, strerror(ret));</span><br><span class="line">31. exit(1);</span><br><span class="line">32. &#125;</span><br><span class="line">33.</span><br><span class="line">34. ret = pthread_create(&amp;tid, &amp;attr, tfn, NULL);</span><br><span class="line">35. if (ret != 0) &#123;</span><br><span class="line">36. perror(&quot;pthread_create error&quot;);</span><br><span class="line">37. &#125;</span><br><span class="line">38.</span><br><span class="line">39. ret = pthread_attr_destroy(&amp;attr);</span><br><span class="line">40. if (ret != 0) &#123;</span><br><span class="line">41. fprintf(stderr, &quot;attr_destroy error:%s\n&quot;, strerror(ret));</span><br><span class="line">42. exit(1);</span><br><span class="line">43. &#125;</span><br><span class="line">44.</span><br><span class="line">45. ret = pthread_join(tid, NULL);</span><br><span class="line">46. if (ret != 0) &#123;</span><br><span class="line">47. fprintf(stderr, &quot;pthread_join error:%s\n&quot;, strerror(ret));</span><br><span class="line">48. exit(1);</span><br><span class="line">49. &#125;</span><br><span class="line">50.</span><br><span class="line">51. printf(&quot;main: pid = %d, tid = %lu\n&quot;, getpid(), pthread_self());</span><br><span class="line">52.</span><br><span class="line">53. pthread_exit((void *)0);</span><br><span class="line">54. &#125;</span><br></pre></td></tr></table></figure>

<p>pthread_join 报错，说明线程已经自动回收，设置分离成功</p>
<h2 id="线程使用注意事项"><a href="#线程使用注意事项" class="headerlink" title="线程使用注意事项"></a>线程使用注意事项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.主线程退出其他线程不退出，主线程应调用`pthread_exit`</span><br><span class="line">2.避免僵尸线程。</span><br><span class="line">`pthread_joine`</span><br><span class="line">`pthread_detach`</span><br><span class="line">`pthread_create`	指定分离属性</span><br><span class="line">join线程可能在join函数返回前就释放完自己的所有内存资源，所以不应当返回被回收线程楼中的值;</span><br><span class="line">3. malloc和mmap申请的内存可以被其他线程释放</span><br><span class="line">4.应避免在多线程模型中调用fork，除非马上exec，子进程中只有调用fork 的线程存在，其他线程在子进程中均pthread_exit</span><br><span class="line">5.信号的复杂语义很难和多线程共存，应避免在多线程引入信号机制,因为信号处理是同概率的，每一个的mask是不同的，但是未决信号集是一样的，所有才能在信号来时都会主动处理。</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/15/Linux-%E4%BF%A1%E5%8F%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/15/Linux-%E4%BF%A1%E5%8F%B7/" class="post-title-link" itemprop="url">Linux-信号</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-15 11:10:21" itemprop="dateCreated datePublished" datetime="2023-06-15T11:10:21+08:00">2023-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-18 11:41:12" itemprop="dateModified" datetime="2023-06-18T11:41:12+08:00">2023-06-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="信号的概念和机制"><a href="#信号的概念和机制" class="headerlink" title="信号的概念和机制"></a>信号的概念和机制</h2><p>信号共性：<br>    简单、不能携带大量信息、满足条件才发送。<br>信号的特质：<br>    信号是软件层面上的“中断”。一旦信号产生，无论程序执行到什么位置，必须立即停止运行，处理信号，处理结束，再继续执行后续指令。<br>    所有信号的产生及处理全部都是由【内核】完成的。</p>
<h2 id="与信号相关的概念"><a href="#与信号相关的概念" class="headerlink" title="与信号相关的概念"></a>与信号相关的概念</h2><p>信号相关的概念：<br>产生信号：</p>
<ol>
<li>按键产生</li>
<li>系统调用产生</li>
<li>软件条件产生</li>
<li>硬件异常产生</li>
<li>命令产生</li>
</ol>
<p>概念：<br>    未决：产生与递达之间状态。<br>    递达：产生并且送达到进程。直接被内核处理掉。<br>    信号处理方式： 执行默认处理动作、忽略、捕捉（自定义）<br>    阻塞信号集（信号屏蔽字）： 本质：位图。用来记录信号的屏蔽状态。一旦被屏蔽的信号，在解除屏蔽前，一直处于未决态。<br>    未决信号集：本质：位图。用来记录信号的处理状态。该信号集中的信号，表示，已经产生，但尚未被处理。</p>
<p><img src="/Linux-%E4%BF%A1%E5%8F%B7/image-20230615210105991.png" alt="image-20230615210105991"></p>
<img src="/2023/06/15/Linux-%E4%BF%A1%E5%8F%B7/image-20230615210105991.png" class title="This is an test image">

<p>默认2号为0.一旦有信号要2，则2处于未决变为1，如果信号屏蔽字为1一直处于未决态，未阻塞状态默认为0，则0变1会阻塞，默认下没阻塞这个过程很快。</p>
<h2 id="信号四要素和常规信号一览"><a href="#信号四要素和常规信号一览" class="headerlink" title="信号四要素和常规信号一览"></a>信号四要素和常规信号一览</h2><p>变量三要素：变量类型，变量名，变量值</p>
<p>kill -l 	查看当前系统中常规信号 </p>
<p>信号 4 要素： 信号使用之前，应先确定其 4 要素，而后再用！！！ </p>
<p>​						编号、名称、对应事件、默认处理动作。</p>
<h2 id="kill-函数和-kill-命令"><a href="#kill-函数和-kill-命令" class="headerlink" title="kill 函数和 kill 命令"></a>kill 函数和 kill 命令</h2><p>kill 命令 和 kill 函数：<br>    <code>int kill（pid_t pid, int signum）</code><br>    参数：<br>    pid: &gt; 0:发送信号给指定进程<br>            &#x3D; 0：发送信号给跟调用 kill 函数的那个进程处于同一进程组的进程。<br>            &lt; -1: 取绝对值，发送信号给该绝对值所对应的进程组的所有组员。<br>            &#x3D; -1：发送信号给，有权限发送的所有进程。<br>    signum：待发送的信号<br>返回值：<br>        成功： 0<br>        失败： -1 errno</p>
<p>子进程发送信号 kill 父进程</p>
<p><img src="/Linux-%E4%BF%A1%E5%8F%B7/image-20230615211148166.png" alt="image-20230615211148166"></p>
<img src="/2023/06/15/Linux-%E4%BF%A1%E5%8F%B7/image-20230615211148166.png" class title="This is an test image">

<p>这里子进程不发送 kill 信号，发其他信号也行，比如段错误什么的。 </p>
<p><code>kill -9 -groupname</code> 杀一个进程组</p>
<h2 id="alarm-函数"><a href="#alarm-函数" class="headerlink" title="alarm 函数"></a>alarm 函数</h2><p>alarm 函数：使用自然计时法。<br>        定时发送 SIGALRM 给当前进程。<br>        <code>unsigned int alarm(unsigned int seconds);</code><br>            seconds：定时秒数<br>            返回值：上次定时剩余时间。<br>                        无错误现象。<br>            <code>alarm（0）；</code> 取消闹钟。<br>        time 命令 ： 查看程序执行时间。 实际时间 &#x3D; 用户时间 + 内核时间 + 等待时间。 –》	优化瓶颈 IO（写入文件比在终端输出效率更高）</p>
<h2 id="setitimer-函数"><a href="#setitimer-函数" class="headerlink" title="setitimer 函数"></a>setitimer 函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">setitimer 函数：</span><br><span class="line">	int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);</span><br><span class="line">	参数：</span><br><span class="line">		which： ITIMER_REAL： 采用自然计时。 ——&gt; SIGALRM</span><br><span class="line">			ITIMER_VIRTUAL: 采用用户空间计时 ---&gt; SIGVTALRM</span><br><span class="line">			ITIMER_PROF: 采用内核+用户空间计时 ---&gt; SIGPROF</span><br><span class="line">		new_value：定时秒数</span><br><span class="line"> 			类型：struct itimerval &#123;</span><br><span class="line"> 						struct timeval &#123;</span><br><span class="line"> 							time_t tv_sec; /* seconds */</span><br><span class="line"> 							suseconds_t tv_usec; /* microseconds */</span><br><span class="line"> 						&#125;it_interval;---&gt; 周期定时秒数</span><br><span class="line"> 						struct timeval &#123;</span><br><span class="line"> 							time_t tv_sec; </span><br><span class="line"> 							suseconds_t tv_usec; </span><br><span class="line"> 						&#125;it_value; ---&gt; 第一次定时秒数 </span><br><span class="line"> 			&#125;;</span><br><span class="line">old_value：传出参数，上次定时剩余时间。</span><br><span class="line">e.g.</span><br><span class="line">    struct itimerval new_t;</span><br><span class="line">    struct itimerval old_t;</span><br><span class="line">    new_t.it_interval.tv_sec = 0;</span><br><span class="line">    new_t.it_interval.tv_usec = 0;</span><br><span class="line">    new_t.it_value.tv_sec = 1;</span><br><span class="line">    new_t.it_value.tv_usec = 0;</span><br><span class="line">    int ret = setitimer(&amp;new_t, &amp;old_t); 定时 1 秒</span><br><span class="line">返回值：</span><br><span class="line">	成功： 0</span><br><span class="line">	失败： -1 errno</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用 setitimer 定时，向屏幕打印信息：</p>
<p><img src="/Linux-%E4%BF%A1%E5%8F%B7/image-20230615212147397.png" alt="image-20230615212147397"></p>
<img src="/2023/06/15/Linux-%E4%BF%A1%E5%8F%B7/image-20230615212147397.png" class title="This is an test image">

<p>第一次信息打印是两秒间隔，之后都是 5 秒间隔打印一次。可以理解为第一次是有个定时器，什么时候触发打印，之后就是间隔时间。</p>
<h2 id="信号集操作函数"><a href="#信号集操作函数" class="headerlink" title="信号集操作函数"></a>信号集操作函数</h2><p><img src="/Linux-%E4%BF%A1%E5%8F%B7/image-20230616164625460.png" alt="image-20230616164625460"></p>
<img src="/2023/06/15/Linux-%E4%BF%A1%E5%8F%B7/image-20230616164625460.png" class title="This is an test image">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">信号集操作函数：</span><br><span class="line">    sigset_t set; 自定义信号集。</span><br><span class="line">    sigemptyset(sigset_t *set); 清空信号集</span><br><span class="line">    sigfillset(sigset_t *set); 全部置 1</span><br><span class="line">    sigaddset(sigset_t *set, int signum); 将一个信号添加到集合中</span><br><span class="line">    sigdelset(sigset_t *set, int signum); 将一个信号从集合中移除</span><br><span class="line">    sigismember（const sigset_t *set，int signum); 判断一个信号是否在集合中。 在--》1，不在--》0</span><br><span class="line">设置信号屏蔽字和解除屏蔽：</span><br><span class="line">    int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</span><br><span class="line">    how: SIG_BLOCK: 设置阻塞</span><br><span class="line">        SIG_UNBLOCK: 取消阻塞</span><br><span class="line">        SIG_SETMASK: 用自定义 set 替换 mask。</span><br><span class="line">    set： 自定义 set</span><br><span class="line">    oldset：旧有的 mask。</span><br><span class="line">查看未决信号集：</span><br><span class="line">    int sigpending(sigset_t *set);</span><br><span class="line">    set： 传出的 未决信号集。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="信号集操作函数练习"><a href="#信号集操作函数练习" class="headerlink" title="信号集操作函数练习"></a>信号集操作函数练习</h2><p>信号列表：<img src="/Linux-%E4%BF%A1%E5%8F%B7/image-20230616165025942.png" alt="image-20230616165025942"></p>
<img src="/2023/06/15/Linux-%E4%BF%A1%E5%8F%B7/image-20230616165025942.png" class title="This is an test image">

<p>其中 9 号和 19 号信号比较特殊，只能执行默认动作，不能忽略捕捉，不能设置阻塞。</p>
<p>下面这个小例子，利用自定义集合，来设置信号阻塞，我们输入被设置阻塞的信号，可以看到未决信号集发生变化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;signal.h&gt;</span><br><span class="line">3. #include &lt;stdlib.h&gt;</span><br><span class="line">4. #include &lt;string.h&gt;</span><br><span class="line">5. #include &lt;unistd.h&gt;</span><br><span class="line">6. #include &lt;errno.h&gt;</span><br><span class="line">7. #include &lt;pthread.h&gt;</span><br><span class="line">8.</span><br><span class="line">9. void sys_err(const char *str)</span><br><span class="line">10. &#123;</span><br><span class="line">11. perror(str);</span><br><span class="line">12. exit(1);</span><br><span class="line">13. &#125;</span><br><span class="line">14.</span><br><span class="line">15. void print_set(sigset_t *set)</span><br><span class="line">16. &#123;</span><br><span class="line">17. int i;</span><br><span class="line">18. for (i = 1; i&lt;32; i++) &#123;</span><br><span class="line">19. if (sigismember(set, i))</span><br><span class="line">20. putchar(&#x27;1&#x27;);</span><br><span class="line">21. else</span><br><span class="line">22. putchar(&#x27;0&#x27;);</span><br><span class="line">23. &#125;</span><br><span class="line">24. printf(&quot;\n&quot;);</span><br><span class="line">25. &#125;</span><br><span class="line">26. int main(int argc, char *argv[])</span><br><span class="line">27. &#123;</span><br><span class="line">28. sigset_t set, oldset, pedset;</span><br><span class="line">29. int ret = 0;</span><br><span class="line">30.</span><br><span class="line">31. sigemptyset(&amp;set);</span><br><span class="line">32. sigaddset(&amp;set, SIGINT);</span><br><span class="line">33. sigaddset(&amp;set, SIGQUIT);</span><br><span class="line">34. sigaddset(&amp;set, SIGBUS);</span><br><span class="line">35. sigaddset(&amp;set, SIGKILL);</span><br><span class="line">36.</span><br><span class="line">37. ret = sigprocmask(SIG_BLOCK, &amp;set, &amp;oldset);</span><br><span class="line">38. if (ret == -1)</span><br><span class="line">39. sys_err(&quot;sigprocmask error&quot;);</span><br><span class="line">40.</span><br><span class="line">41. while (1) &#123;</span><br><span class="line">42. ret = sigpending(&amp;pedset);</span><br><span class="line">43. print_set(&amp;pedset);</span><br><span class="line">44. sleep(1);</span><br><span class="line">45. &#125;</span><br><span class="line">46.</span><br><span class="line">47. return 0;</span><br><span class="line">48. &#125;</span><br></pre></td></tr></table></figure>

<p>编译运行，如下图所示：</p>
<p><img src="/Linux-%E4%BF%A1%E5%8F%B7/image-20230616165908670.png" alt="image-20230616165908670"></p>
<img src="/2023/06/15/Linux-%E4%BF%A1%E5%8F%B7/image-20230616165908670.png" class title="This is an test image">

<p>可以看到，在输入 Ctrl+C 之后，进程捕捉到信号，但由于设置阻塞，没有处理，未决信号集对应位 置变为 1.</p>
<h2 id="signal-实现信号捕捉"><a href="#signal-实现信号捕捉" class="headerlink" title="signal 实现信号捕捉"></a>signal 实现信号捕捉</h2><p><img src="/Linux-%E4%BF%A1%E5%8F%B7/image-20230616170009398.png" alt="image-20230616170009398"></p>
<img src="/2023/06/15/Linux-%E4%BF%A1%E5%8F%B7/image-20230616170009398.png" class title="This is an test image">

<p>参数： </p>
<p>​	signum ：待捕捉信号 </p>
<p>​	handler：捕捉信号后的操纵函数</p>
<p>返回值：<img src="/Linux-%E4%BF%A1%E5%8F%B7/image-20230616170104431.png" alt="image-20230616170104431"></p>
<img src="/2023/06/15/Linux-%E4%BF%A1%E5%8F%B7/image-20230616170104431.png" class title="This is an test image">

<p>信号捕捉特性：</p>
<ol>
<li>捕捉函数执行期间，信号屏蔽字 由 mask –&gt; sa_mask , 捕捉函数执行结束。 恢复回 mask</li>
<li>捕捉函数执行期间，本信号自动被屏蔽(sa_flgs &#x3D; 0).</li>
<li>捕捉函数执行期间，被屏蔽信号多次发送，解除屏蔽后只处理一次！</li>
</ol>
<p>一个信号捕捉的小例子：<img src="/Linux-%E4%BF%A1%E5%8F%B7/image-20230616170159382.png" alt="image-20230616170159382"></p>
<img src="/2023/06/15/Linux-%E4%BF%A1%E5%8F%B7/image-20230616170159382.png" class title="This is an test image">

<p>在上述代码中，函数<code>sig_cath</code>是一个信号处理函数，它被注册为了<code>SIGINT</code>信号的处理器。当程序接收到<code>SIGINT</code>信号（通常由终端按下Ctrl+C触发）时，该处理函数会被调用。在此处，参数<code>signo</code>代表接收到的信号编号，因此在函数定义中声明了参数<code>int signo</code>。</p>
<p>在<code>main</code>函数中，通过调用<code>signal(SIGINT, sig_cath)</code>将<code>sig_cath</code>函数注册为<code>SIGINT</code>信号（终端中断信号）的处理函数。这样，当程序接收到<code>SIGINT</code>信号时，就会调用<code>sig_cath</code>函数进行相关处理。</p>
<p>总结起来，参数<code>signo</code>是由系统自动传递给信号处理函数的，在这段代码中并不需要手动传入。</p>
<h2 id="sigaction-实现信号捕捉"><a href="#sigaction-实现信号捕捉" class="headerlink" title="sigaction 实现信号捕捉"></a>sigaction 实现信号捕捉</h2><p>sigaction 也是注册一个信号捕捉函数</p>
<p><img src="/Linux-%E4%BF%A1%E5%8F%B7/image-20230616170313810.png" alt="image-20230616170313810"></p>
<img src="/2023/06/15/Linux-%E4%BF%A1%E5%8F%B7/image-20230616170313810.png" class title="This is an test image">

<p>下面的小例子，使用 sigaction 捕捉两个信号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;signal.h&gt;</span><br><span class="line">3. #include &lt;stdlib.h&gt;</span><br><span class="line">4. #include &lt;string.h&gt;</span><br><span class="line">5. #include &lt;unistd.h&gt;</span><br><span class="line">6. #include &lt;errno.h&gt;</span><br><span class="line">7. #include &lt;pthread.h&gt;</span><br><span class="line">8.</span><br><span class="line">9. void sys_err(const char *str)</span><br><span class="line">10. &#123;</span><br><span class="line">11. perror(str);</span><br><span class="line">12. exit(1);</span><br><span class="line">13. &#125;</span><br><span class="line">14.</span><br><span class="line">15. void sig_catch(int signo) // 回调函数</span><br><span class="line">16. &#123;</span><br><span class="line">17. if (signo == SIGINT) &#123;</span><br><span class="line">18. printf(&quot;catch you!! %d\n&quot;, signo);</span><br><span class="line">19. sleep(10);</span><br><span class="line">20. &#125;</span><br><span class="line">21.</span><br><span class="line">22. else if (signo == SIGQUIT)</span><br><span class="line">23. printf(&quot;-----------catch you!! %d\n&quot;, signo);</span><br><span class="line">24.</span><br><span class="line">25. return ;</span><br><span class="line">26. &#125;</span><br><span class="line">27.</span><br><span class="line">28. int main(int argc, char *argv[])</span><br><span class="line">29. &#123;</span><br><span class="line">30. struct sigaction act, oldact;</span><br><span class="line">31.</span><br><span class="line">32. act.sa_handler = sig_catch; // set callback function name 设置回调函数</span><br><span class="line">33. sigemptyset(&amp;(act.sa_mask)); // set mask when sig_catch working. 清空 sa_mask 屏蔽字, 只在sig_catch 工作时有效</span><br><span class="line">34. //sigaddset(&amp;act.sa_mask, SIGQUIT);</span><br><span class="line">35. act.sa_flags = 0; // usually use. 默认值</span><br><span class="line">36.</span><br><span class="line">37. int ret = sigaction(SIGINT, &amp;act, &amp;oldact); //注册信号捕捉函数</span><br><span class="line">38. if (ret == -1)</span><br><span class="line">39. sys_err(&quot;sigaction error&quot;);</span><br><span class="line">40. ret = sigaction(SIGQUIT, &amp;act, &amp;oldact); //注册信号捕捉函数</span><br><span class="line">41.</span><br><span class="line">42. while (1);</span><br><span class="line">43.</span><br><span class="line">44. return 0;</span><br><span class="line">45. &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/Linux-%E4%BF%A1%E5%8F%B7/image-20230616170558665.png" alt="image-20230616170558665"></p>
<img src="/2023/06/15/Linux-%E4%BF%A1%E5%8F%B7/image-20230616170558665.png" class title="This is an test image">

<h2 id="信号捕捉的特性"><a href="#信号捕捉的特性" class="headerlink" title="信号捕捉的特性"></a>信号捕捉的特性</h2><p>信号捕捉特性：</p>
<ol>
<li>捕捉函数执行期间，信号屏蔽字 由 mask –&gt; sa_mask , 捕捉函数执行结束。 恢复回 mask</li>
<li>捕捉函数执行期间，本信号自动被屏蔽(sa_flgs &#x3D; 0).</li>
<li>捕捉函数执行期间，被屏蔽信号多次发送，解除屏蔽后只处理一次！</li>
</ol>
<h2 id="内核实现信号捕捉简析"><a href="#内核实现信号捕捉简析" class="headerlink" title="内核实现信号捕捉简析"></a>内核实现信号捕捉简析</h2><p><img src="/Linux-%E4%BF%A1%E5%8F%B7/image-20230616170745748.png" alt="image-20230616170745748"></p>
<img src="/2023/06/15/Linux-%E4%BF%A1%E5%8F%B7/image-20230616170745748.png" class title="This is an test image">

<h2 id="借助信号捕捉回收子进程"><a href="#借助信号捕捉回收子进程" class="headerlink" title="借助信号捕捉回收子进程"></a>借助信号捕捉回收子进程</h2><p>SIGCHLD 的产生条件： </p>
<p>​	子进程终止时 </p>
<p>​	子进程接收到 SIGSTOP </p>
<p>​	子进程处于停止态，接收到 SIGCONT 后唤醒时</p>
<p>下面是一个例子，创建子进程，并使用信号回收：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;signal.h&gt;</span><br><span class="line">6. #include &lt;sys/wait.h&gt;</span><br><span class="line">7. #include &lt;errno.h&gt;</span><br><span class="line">8. #include &lt;pthread.h&gt;</span><br><span class="line">9.</span><br><span class="line">10. void sys_err(const char *str)</span><br><span class="line">11. &#123;</span><br><span class="line">12. perror(str);</span><br><span class="line">13. exit(1);</span><br><span class="line">14. &#125;</span><br><span class="line">15.</span><br><span class="line">16. void catch_child(int signo)// 有子进程终止，发送 SGCHLD 信号时，该函数会被内核回调</span><br><span class="line">17. &#123;</span><br><span class="line">18. pid_t wpid;</span><br><span class="line">19.</span><br><span class="line">20. wpid = wait(NULL);</span><br><span class="line">21. printf(&quot;-----------catch child id %d\n&quot;, wpid);</span><br><span class="line">22.</span><br><span class="line">23. return ;</span><br><span class="line">24. &#125;</span><br><span class="line">25.</span><br><span class="line">26. int main(int argc, char *argv[])</span><br><span class="line">27. &#123;</span><br><span class="line">28. pid_t pid;</span><br><span class="line">29. //阻塞,和解除阻塞一起用可以避免出现还未注册信号捕捉函数，子进程就直接接受信号默认过程，参考信号集操作函数</span><br><span class="line">	sigset_t set;</span><br><span class="line">	sigemptyset(&amp;set);</span><br><span class="line">	sigaddset(&amp;set, SIGCHLD);</span><br><span class="line">	sigprocmask(SIG_BLOCK, &amp;set, NULL);</span><br><span class="line">30. int i;</span><br><span class="line">31. for (i = 0; i &lt; 5; i++)</span><br><span class="line">32. if ((pid = fork()) == 0) // 创建多个子进程</span><br><span class="line">33. break;</span><br><span class="line">34.</span><br><span class="line">35. if (5 == i) &#123;</span><br><span class="line">36. struct sigaction act;</span><br><span class="line">37.</span><br><span class="line">38. act.sa_handler = catch_child; // 设置回调函数</span><br><span class="line">39. sigemptyset(&amp;act.sa_mask); // 设置捕捉函数执行期间屏蔽字</span><br><span class="line">40. act.sa_flags = 0; // 设置默认属性, 本信号自动屏蔽</span><br><span class="line">41.</span><br><span class="line">42. sigaction(SIGCHLD, &amp;act, NULL); // 注册信号捕捉函数</span><br><span class="line">43. //解除阻塞</span><br><span class="line">44.sigprocmask(SIG_UNBLOCK, &amp;set, NULL);</span><br><span class="line">45. printf(&quot;I&#x27;m parent, pid = %d\n&quot;, getpid());</span><br><span class="line">46.</span><br><span class="line">47. while (1);</span><br><span class="line">48.</span><br><span class="line">49. &#125; else &#123;</span><br><span class="line">50. printf(&quot;I&#x27;m child pid = %d\n&quot;, getpid());</span><br><span class="line">51. return i;</span><br><span class="line">52. &#125;</span><br><span class="line">53.</span><br><span class="line">54. return 0;</span><br><span class="line">55. &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/Linux-%E4%BF%A1%E5%8F%B7/image-20230616171436271.png" alt="image-20230616171436271"></p>
<img src="/2023/06/15/Linux-%E4%BF%A1%E5%8F%B7/image-20230616171436271.png" class title="This is an test image">

<p>如图，只回收到 1 个子进程，多次执行，会发现回收到的子进程数量不是固定的。 原因分析： 问题出在，一次回调只回收一个子进程这里。同时出现多个子进程死亡时，其中一个子进程死亡 信号被捕捉，父进程去处理这个信号，此时其他子进程死亡信号发送过来，由于相同信号的不排队原 则，就只会回收累积信号中的一个子进程。</p>
<p>修改代码，回调函数中添加循环，一次回调可以回收多个子进程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void catch_child(int signo)// 有子进程终止，发送 SGCHLD 信号时，该函数会被内核回调</span><br><span class="line">&#123;</span><br><span class="line"> 	pid_t wpid;</span><br><span class="line"> 	int status;</span><br><span class="line"> 	//while((wpid = wait(NULL)) != -1)&#123;</span><br><span class="line"> 	while((wpid = waitpid(-1, &amp;status, 0)) != -1) &#123;// 循环回收,防止僵尸进程出现.</span><br><span class="line"> 		if (WIFEXITED(status))</span><br><span class="line"> 			printf(&quot;-----------catch child id %d, ret=%d\n&quot;, wpid, WEXITSTATUS(status));</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这下就是回收了所有子进程，很强势。 </p>
<p>还有一个问题需要注意，这里有可能父进程还没注册完捕捉函数，子进程就死亡了，解决这个问 题的方法，首先是让子进程 sleep，但这个不太科学。在 fork 之前注册也行，但这个也不是很科学。 最科学的方法是在 int i 之前设置屏蔽，等父进程注册完捕捉函数再解除屏蔽。这样即使子进程先死亡了，信号也因为被屏蔽而无法到达父进程。解除屏蔽过后，父进程就能处理累积起来的信号了。</p>
<h2 id="中断系统调用"><a href="#中断系统调用" class="headerlink" title="中断系统调用"></a>中断系统调用</h2><p>系统调用可分为两类:慢速系统调用和其他系统调用。<br>1.慢速系统调用:可能会使进程永远阻塞的一类。如果在阻塞期间收到一个信号，该系统调用就被中断,不再继续执行(早期);也可以设定系统调用是否重启。如，read、 write、pause 、 wait…<br>2.其他系统调用:getpid、getppid、fork…<br>结合pause，回顾慢速系统调用:<br>    慢速系统调用被中断的相关行为，实际上就是pause的行为:如，read</p>
<ul>
<li>想中断pause，信号不能被屏蔽。</li>
<li>信号的处理方式必须是捕捉(默认、忽略都不可以)</li>
<li>中断后返回-1，设置errno为EINTR(表“被信号中断”)</li>
</ul>
<p>可修改sa_flags参数来设置被信号中断后系统调用是否重启。SA_INTERRURT不重启。SA_RESTART重启。</p>
<p>sa_flags 还有很多可选参数，适用于不同情况。如:捕捉到信号后，在执行捕捉函数期间，不希望自动阻塞该信号，可将sa_flags设置为SA_NODEFER，除非sa_mask中包含该信号。</p>
<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>会话：多个进程组的集合<br>创建会话的 6 点注意事项：</p>
<ol>
<li>调用进程不能是进程组组长，该进程变成新会话首进程</li>
<li>该进程成为一个新进程组的组长进程</li>
<li>需要 root 权限（ubuntu 不需要）</li>
<li>新会话丢弃原有的控制终端，该会话没有控制终端</li>
<li>该调用进程是组长进程，则出错返回</li>
<li>建立新会话时，先调用 fork，父进程终止，子进程调用 setsid</li>
</ol>
<p>getsid 函数：<br><code>pid_t getsid(pid_t pid)</code> 获取当前进程的会话 id<br>成功返回调用进程会话 ID，失败返回-1，设置 error<br>setsid 函数：<br><code>pid_t setsid(void)</code> 创建一个会话，并以自己的 ID 设置进程组 ID，同时也是新会话的 ID<br>成功返回调用进程的会话 ID，失败返回-1，设置 error</p>
<h2 id="守护进程创建步骤分析"><a href="#守护进程创建步骤分析" class="headerlink" title="守护进程创建步骤分析"></a>守护进程创建步骤分析</h2><p>守护进程：<br>daemon 进程。通常运行于操作系统后台，脱离控制终端。一般不与用户直接交互。周期性的等待某个事件发生或周期性执行某一动作。<br>不受用户登录注销影响。通常采用以 d 结尾的命名方式。</p>
<p>创建守护进程，最关键的一步是调用 setsid 函数创建一个新的 Session，并成为 Session Leader</p>
<p>守护进程创建步骤：</p>
<ol>
<li>fork 子进程，让父进程终止。</li>
<li>子进程调用 setsid() 创建新会话</li>
<li>通常根据需要，改变工作目录位置 chdir()， 防止目录被卸载。比如目录是在U盘上，卸载就会出问题。</li>
<li>通常根据需要，重设 umask 文件权限掩码，影响新文件的创建权限。 022 – 755 0345 — 432 r—wx-w- 422,x权限默认不给，创建目录是432，创建文件没有x就是422.（可能是<strong>出于安全的考虑，linux系统新建文件默认没有执行权限</strong>，其最大权限为rw-rw-rw-（666），新建目录的最大权限为rwx-rwx-rwx（777）。）</li>
<li>通常根据需要，关闭&#x2F;重定向 文件描述符</li>
<li>守护进程 业务逻辑。while（）</li>
</ol>
<p>下面这个例子，创建一个守护进程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;sys/stat.h&gt;</span><br><span class="line">3. #include &lt;fcntl.h&gt;</span><br><span class="line">4. #include &lt;stdlib.h&gt;</span><br><span class="line">5. #include &lt;string.h&gt;</span><br><span class="line">6. #include &lt;unistd.h&gt;</span><br><span class="line">7. #include &lt;errno.h&gt;</span><br><span class="line">8. #include &lt;pthread.h&gt;</span><br><span class="line">9.</span><br><span class="line">10. void sys_err(const char *str)</span><br><span class="line">11. &#123;</span><br><span class="line">12. perror(str);</span><br><span class="line">13. exit(1);</span><br><span class="line">14. &#125;</span><br><span class="line">15.</span><br><span class="line">16. int main(int argc, char *argv[])</span><br><span class="line">17. &#123;</span><br><span class="line">18. pid_t pid;</span><br><span class="line">19. int ret, fd;</span><br><span class="line">20.</span><br><span class="line">21. pid = fork();</span><br><span class="line">22. if (pid &gt; 0) // 父进程终止</span><br><span class="line">23. exit(0);</span><br><span class="line">24.</span><br><span class="line">25. pid = setsid(); //创建新会话</span><br><span class="line">26. if (pid == -1)</span><br><span class="line">27. sys_err(&quot;setsid error&quot;);</span><br><span class="line">28.</span><br><span class="line">29. ret = chdir(&quot;/home/zhcode/Code/code146&quot;); // 改变工作目录位置</span><br><span class="line">30. if (ret == -1)</span><br><span class="line">31. sys_err(&quot;chdir error&quot;);</span><br><span class="line">32.</span><br><span class="line">33. umask(0022); // 改变文件访问权限掩码</span><br><span class="line">34.</span><br><span class="line">35. close(STDIN_FILENO); // 关闭文件描述符 0</span><br><span class="line">36.</span><br><span class="line">37. fd = open(&quot;/dev/null&quot;, O_RDWR); // fd --&gt; 0**文件描述符fd默认会给最小的，如果0，1，2关闭，则会给0**</span><br><span class="line">38. if (fd == -1)</span><br><span class="line">39. sys_err(&quot;open error&quot;);</span><br><span class="line">40.</span><br><span class="line">41. dup2(fd, STDOUT_FILENO); // 重定向 stdout 和 stderr,因为不需要与用户交互，/dev/null这是一个空洞文件</span><br><span class="line">42. dup2(fd, STDERR_FILENO);</span><br><span class="line">43.</span><br><span class="line">44. while (1); // 模拟 守护进程业务.</span><br><span class="line">45.</span><br><span class="line">46. return 0;</span><br><span class="line">47. &#125;</span><br></pre></td></tr></table></figure>

<p>不会受到用户登录注销影响，会话不会结束，只有kill才行。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">Linux进程相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-01 21:35:45" itemprop="dateCreated datePublished" datetime="2023-06-01T21:35:45+08:00">2023-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-17 15:19:14" itemprop="dateModified" datetime="2023-06-17T15:19:14+08:00">2023-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="进程和程序以及-CPU-相关"><a href="#进程和程序以及-CPU-相关" class="headerlink" title="进程和程序以及 CPU 相关"></a>进程和程序以及 CPU 相关</h2><p>进程：<br>        程序：死的。只占用磁盘空间。 ——剧本。<br>        进程；活的。运行起来的程序。占用内存、cpu 等系统资源。 ——戏。<br>并发和并行：并行是宏观上并发，微观上串行</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230601213825110.png" alt="image-20230601213825110"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230601213825110.png" class title="This is an test image">

<h2 id="虚拟内存和物理内存映射关系"><a href="#虚拟内存和物理内存映射关系" class="headerlink" title="虚拟内存和物理内存映射关系"></a>虚拟内存和物理内存映射关系</h2><p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230601215722575.png" alt="image-20230601215722575"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230601215722575.png" class title="This is an test image">

<p>Linux下只有两级。从用户空间到内核空间进的时候，需要借助mmu，帮助完成全级切换。</p>
<h2 id="pcb-进程控制块"><a href="#pcb-进程控制块" class="headerlink" title="pcb 进程控制块"></a>pcb 进程控制块</h2><p>PCB 进程控制块：进程 id<br>文件描述符表<br>进程状态： 初始态、就绪态、运行态、挂起态、终止态。<br>进程工作目录位置<br>*umask 掩码 （进程的概念）<br>信号相关信息资源。<br>用户 id 和组 id<br>ps aux 返回结果里，第二列是进程 id</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609212449400.png" alt="image-20230609212449400"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609212449400.png" class title="This is an test image">

<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH 查看环境变量</span><br><span class="line">path 环境变量里记录了一系列的值，当运行一个可执行文件时，系统会去环境变量记录的位置里查</span><br><span class="line">找这个文件并执行。</span><br><span class="line">echo $TERM 查看终端</span><br><span class="line">echo $LANG 查看语言</span><br><span class="line">env 查看所有环境变量</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="fork-函数原理"><a href="#fork-函数原理" class="headerlink" title="fork 函数原理"></a>fork 函数原理</h2><p>fork 函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pid_t fork(void)</span><br><span class="line">创建子进程。父子进程各自返回。父进程返回子进程 pid。 子进程返回 0.</span><br><span class="line">getpid();getppid();</span><br><span class="line">循环创建 N 个子进程模型。 每个子进程标识自己的身份。</span><br></pre></td></tr></table></figure>

<p>父子进程相同： 刚 fork 后。 data 段、text 段、堆、栈、环境变量、全局变量、宿主目录位置、进程工作目录位 置、信号处理方式</p>
<p>父子进程不同： 进程 id、返回值、各自的父进程、进程创建时间、闹钟、未决信号集</p>
<p>父子进程共享： 读时共享、写时复制。———————— 全局变量。 1. 文件描述符 2. mmap 映射区</p>
<h2 id="fork-创建子进程"><a href="#fork-创建子进程" class="headerlink" title="fork 创建子进程"></a>fork 创建子进程</h2><p>下面是一个 fork 函数的例子，代码如下：</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609212838706.png" alt="image-20230609212838706"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609212838706.png" class title="This is an test image">

<p>fork 之前的代码，父子进程都有，但是只有父进程执行了，子进程没有执行，fork 之后的代码，父子进程都有机会执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">两个函数：</span><br><span class="line">pid_t getpid() 获取当前进程 id</span><br><span class="line">pid_t getppid() 获取当前进程的父进程 id</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609212951089.png" alt="image-20230609212951089"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609212951089.png" class title="This is an test image">

<h2 id="循环创建多个子进程"><a href="#循环创建多个子进程" class="headerlink" title="循环创建多个子进程"></a>循环创建多个子进程</h2><p>所以，直接用个 for 循环是要出事情的，因为子进程也会 fork 新的进程 这里，对调用 fork 的进程进行判定，只让父进程 fork 新的进程就行，代码如下：</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609213428815.png" alt="image-20230609213428815"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609213428815.png" class title="This is an test image">

<p>出现了问题：进程多了一个，而且不是按顺序来的。这里多出的一个，是父进程，因为父进程才有 i&#x3D;5 跳出循环这一步。所以，对父进程进行判定并处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(i=5)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;parent&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">	printf(&quot;..&quot;,i+1);</span><br></pre></td></tr></table></figure>

<p>现在还有两个问题，<br>    一个就是包括父进程在内的所有进程不是按顺序出现，多运行几次，发现是随机序列出现的。这<br>是要因为，对操作系统而言，这几个子进程几乎是同时出现的，它们和父进程一起争夺 cpu，谁抢到，<br>谁打印，所以出现顺序是随机的。<br>    第二问题就是终端提示符混在了输出里，这个是因为，loop_fork 是终端的子进程，一旦<br>loop_fork 执行完，终端就会打印提示符。就像之前没有子进程的程序，一旦执行完，就出现了终端<br>提示符。这里也就是这个道理，loop_fork 执行完了，终端提示符出现，然而 loop_fork 的子进程还<br>没执行完，所以输出就混在一起了。</p>
<p>通过 sleep 延时来解决父进程先结束这个问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(i=5)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;parent&quot;);</span><br><span class="line">	sleep(1);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">	printf(&quot;..&quot;,i+1);</span><br></pre></td></tr></table></figure>

<p>最后来解决子进程乱序输出的问题，解决方法很简单，让第 1 个子进程少等，第二个子进程多等， 后面子进程等待时间依次增加，这样就能实现有序输出。</p>
<h2 id="父子进程共享哪些内容"><a href="#父子进程共享哪些内容" class="headerlink" title="父子进程共享哪些内容"></a>父子进程共享哪些内容</h2><p>父子进程相同： 刚 fork 后。 data 段、text 段、堆、栈、环境变量、全局变量、宿主目录位置、进程工作目录位 置、信号处理方式</p>
<p>父子进程不同： 进程 id、返回值、各自的父进程、进程创建时间、闹钟、未决信号集</p>
<p>父子进程共享： 读时共享、写时复制。———————— 全局变量。如果只是读，则公用一个地址，写，则复制一份，不一起。</p>
<ol>
<li>文件描述符 2. mmap 映射区</li>
</ol>
<h2 id="父子进程-gdb-调试"><a href="#父子进程-gdb-调试" class="headerlink" title="父子进程 gdb 调试"></a>父子进程 gdb 调试</h2><p>gdb 调试：<br>设置父进程调试路径：set follow-fork-mode parent (默认)<br>设置子进程调试路径：set follow-fork-mode child<br>注意，一定要在 fork 函数调用之前设置才有效。</p>
<h2 id="exec-函数族"><a href="#exec-函数族" class="headerlink" title="exec 函数族"></a>exec 函数族</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">exec 函数族：</span><br><span class="line">使进程执行某一程序。成功无返回值，失败返回 -1</span><br><span class="line">int execlp(const char *file, const char *arg, ...); 借助 PATH 环境变量找寻待执</span><br><span class="line">行程序</span><br><span class="line">参 1： 程序名</span><br><span class="line">参 2： argv0</span><br><span class="line">参 3： argv1</span><br><span class="line">...： argvN</span><br><span class="line">哨兵：NULL</span><br><span class="line">int execl(const char *path, const char *arg, ...); 自己指定待执行程序路径。</span><br><span class="line">int execvp();</span><br><span class="line">ps ajx --&gt; pid ppid gid sid</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>fork创建子进程后执行的是和父进程相同的程序（但有可能执行不同的代码分支)，子进程往往要调用一种 exec函数以执行另一个程序。当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用exec并不创建新进程，所以调用exec前后该进程的id并未改变。<br>将当前进程的.text、.data替换为所要加载的程序的.text、.data，然后让进程从新的.text第一条指令开始执行，但进程ID不变，换核不换壳。即exec后面的子进程代码不执行了，因为进入了新的程序。</p>
<h3 id="execlp-和-ececl-函数"><a href="#execlp-和-ececl-函数" class="headerlink" title="execlp 和 ececl 函数"></a>execlp 和 ececl 函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int execlp(const char *file, const char *arg, …)</span><br><span class="line">成功，无返回，失败返回-1</span><br><span class="line">参数 1：要加载的程序名字，该函数需要配合 PATH 环境变量来使用，当 PATH 所有目录搜素后没</span><br><span class="line">有参数 1 则返回出错。</span><br><span class="line">该函数通常用来调用系统程序。如 ls、date、cp、cat 命令。</span><br><span class="line">execlp 这里面的 p，表示要借助环境变量来加载可执行文件</span><br></pre></td></tr></table></figure>

<p>示例代码，通过 execlp 让子进程去执行 ls 命令：</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215110094.png" alt="image-20230610215110094"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215110094.png" class title="This is an test image">

<p>只有父进程正确执行并输出了，子进程的 ls 输出有问题。 问题出在参数上，可变参数那里，是从 argv[0]开始计算的。 修改代码，就是将缺失的 argv[0]补上，然后让父进程延时 1 秒，保证终端提示符不和输出干扰。如 下：</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215242121.png" alt="image-20230610215242121"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215242121.png" class title="This is an test image">

<p>下面使用 execl 来让子程序调用自定义的程序。 int execl(const char *path, const char *arg, …) 这里要注意，和 execlp 不同的是，第一个参数是路径，不是文件名。 这个路径用相对路径和绝对路径都行。</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215316774.png" alt="image-20230610215316774"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215316774.png" class title="This is an test image">

<p>用 execl 也能执行 ls 这些，把路径给出来就行，但是这样麻烦，所以对于系统指令一般还是用 execlp</p>
<h2 id="exec-函数族特性"><a href="#exec-函数族特性" class="headerlink" title="exec 函数族特性"></a>exec 函数族特性</h2><p>写一个程序，使用 execlp 执行进程查看，并将结果输出到文件里。 要用到 open, execlp, dup2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">        int fd;</span><br><span class="line">        fd = open( &quot;ps.out&quot;, O_WRONLY|O_CREAT|O_TRUNC,0644);</span><br><span class="line">        if(fd &lt; 0)&#123;</span><br><span class="line">                perror(&quot;open ps.out error&quot;);</span><br><span class="line">                exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        dup2(fd,STDOUT_FILENO);</span><br><span class="line">        execlp(&quot;ps&quot;,&quot;ps&quot;,&quot;aux&quot;,NULL);</span><br><span class="line">        close(fd); //have no need to</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>exec 函数族一般规律： </p>
<p>exec 函数一旦调用成功，即执行新的程序，不返回。只有失败才返回，错误值-1，所以通常我们直接在 exec 函数调用后直接调用 perror()，和 exit()，无需 if 判断。</p>
<p>事实上，只有 execve 是真正的系统调用，其他 5 个函数最终都调用 execve，是库函数，所以 execve 在 man 手册第二节，其它函数在 man 手册第 3 节。</p>
<h2 id="孤儿进程和僵尸进程"><a href="#孤儿进程和僵尸进程" class="headerlink" title="孤儿进程和僵尸进程"></a>孤儿进程和僵尸进程</h2><p>孤儿进程：<br>父进程先于子进终止，子进程沦为“孤儿进程”，会被 init 进程领养。<br>僵尸进程：<br>子进程终止，父进程尚未对子进程进行回收，在此期间，子进程为“僵尸进程”。 kill 对其<br>无效。这里要注意，每个进程结束后都必然会经历僵尸态，时间长短的差别而已。<br>子进程终止时，子进程残留资源 PCB 存放于内核中，PCB 记录了进程结束原因，进程回收就是回<br>收 PCB。回收僵尸进程，得 kill 它的父进程，让孤儿院去回收它。</p>
<h2 id="wait-回收子进程"><a href="#wait-回收子进程" class="headerlink" title="wait 回收子进程"></a>wait 回收子进程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">wait 函数： 回收子进程退出资源， 阻塞回收任意一个。</span><br><span class="line">pid_t wait(int *status)</span><br><span class="line">参数：（传出） 回收进程的状态。</span><br><span class="line">返回值：成功： 回收进程的 pid</span><br><span class="line">失败： -1， errno</span><br><span class="line">函数作用 1： 阻塞等待子进程退出</span><br><span class="line">函数作用 2： 清理子进程残留在内核的 pcb 资源</span><br><span class="line">函数作用 3： 通过传出参数，得到子进程结束状态</span><br><span class="line">获取子进程正常终止值：</span><br><span class="line">WIFEXITED(status) --》 为真 --》调用 WEXITSTATUS(status) --》 得到 子进程 退出值。</span><br><span class="line">获取导致子进程异常终止信号：</span><br><span class="line">WIFSIGNALED(status) --》 为真 --》调用 WTERMSIG(status) --》 得到 导致子进程异常</span><br><span class="line">终止的信号编号。</span><br><span class="line">一个进程终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的 PCB 还保留着，内</span><br><span class="line">核在其中保存了一些信息：如果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程</span><br><span class="line">终止的信号是哪个。这个进程的父进程可以调用 wait 或者 waitpid 获取这些信息，然后彻底清除掉</span><br><span class="line">这个进程。我们知道一个进程的退出状态可以在 shell 中用特殊变量$？查看，因为 shell 是它的父</span><br><span class="line">进程，当它终止时，shell 调用 wait 或者 waitpid 得到它的退出状态，同时彻底清除掉这个进程。</span><br><span class="line">pid_t wait(int *status)</span><br><span class="line">其中 status 是传出参数</span><br></pre></td></tr></table></figure>

<p>下面这个例子，使用 wait 来阻塞回收子进程</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215813155.png" alt="image-20230610215813155"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215813155.png" class title="This is an test image">

<h2 id="获取子进程退出值和异常终止信号"><a href="#获取子进程退出值和异常终止信号" class="headerlink" title="获取子进程退出值和异常终止信号"></a>获取子进程退出值和异常终止信号</h2><p>获取子进程正常终止值：<br>WIFEXITED(status) –》 为真 –》调用 WEXITSTATUS(status) –》 得到 子进程 退出值。<br>获取导致子进程异常终止信号：<br>WIFSIGNALED(status) –》 为真 –》调用 WTERMSIG(status) –》 得到 导致子进程异常<br>终止的信号编号。</p>
<p>下面这个代码捕获程序异常终止的信号并打印：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;unistd.h&gt;</span><br><span class="line">4. #include &lt;sys/wait.h&gt;</span><br><span class="line">5.</span><br><span class="line">6. int main(void)</span><br><span class="line">7. &#123;</span><br><span class="line">8. pid_t pid, wpid;</span><br><span class="line">9. int status;</span><br><span class="line">10.</span><br><span class="line">11. pid = fork();</span><br><span class="line">12. if (pid == 0) &#123;</span><br><span class="line">13. printf(&quot;---child, my id= %d, going to sleep 10s\n&quot;, getpid());</span><br><span class="line">14. sleep(10);</span><br><span class="line">15. printf(&quot;-------------child die--------------\n&quot;);</span><br><span class="line">16. return 73;</span><br><span class="line">17. &#125; else if (pid &gt; 0) &#123;</span><br><span class="line">18. //wpid = wait(NULL); // 不关心子进程结束原因</span><br><span class="line">19. wpid = wait(&amp;status); // 如果子进程未终止,父进程阻塞在这个函数上</span><br><span class="line">20. if (wpid == -1) &#123;</span><br><span class="line">21. perror(&quot;wait error&quot;);</span><br><span class="line">22. exit(1);</span><br><span class="line">23. &#125;</span><br><span class="line">24. if (WIFEXITED(status)) &#123; //为真,说明子进程正常终止.</span><br><span class="line">25. printf(&quot;child exit with %d\n&quot;, WEXITSTATUS(status));</span><br><span class="line">26.</span><br><span class="line">27. &#125;</span><br><span class="line">28. if (WIFSIGNALED(status)) &#123; //为真,说明子进程是被信号终止.</span><br><span class="line">29.</span><br><span class="line">30. printf(&quot;child kill with signal %d\n&quot;, WTERMSIG(status));</span><br><span class="line">31. &#125;</span><br><span class="line">32.</span><br><span class="line">33. printf(&quot;------------parent wait finish: %d\n&quot;, wpid);</span><br><span class="line">34. &#125; else &#123;</span><br><span class="line">35. perror(&quot;fork&quot;);</span><br><span class="line">36. return 1;</span><br><span class="line">37. &#125;</span><br><span class="line">38.</span><br><span class="line">39. return 0;</span><br><span class="line">40. &#125;</span><br></pre></td></tr></table></figure>

<p>下面发送信号使得子进程异常退出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 id</span><br></pre></td></tr></table></figure>

<h2 id="waitpid-回收子进程"><a href="#waitpid-回收子进程" class="headerlink" title="waitpid 回收子进程"></a>waitpid 回收子进程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">waitpid 函数： 指定某一个进程进行回收。可以设置非阻塞。</span><br><span class="line">waitpid(-1, &amp;status, 0) == wait(&amp;status);</span><br><span class="line">	pid_t waitpid(pid_t pid, int *status, int options)</span><br><span class="line">	参数：</span><br><span class="line">		pid：指定回收某一个子进程 pid</span><br><span class="line">		&gt; 0: 待回收的子进程 pid</span><br><span class="line">		-1：任意子进程</span><br><span class="line">		0：同组的子进程。</span><br><span class="line">		status：（传出） 回收进程的状态。</span><br><span class="line">		options：WNOHANG 指定回收方式为，非阻塞。</span><br><span class="line">	返回值：</span><br><span class="line">		&gt; 0 : 表成功回收的子进程 pid</span><br><span class="line">		0 : 函数调用时， 参 3 指定了 WNOHANG， 并且，没有子进程结束。</span><br><span class="line">		-1: 失败。errno</span><br><span class="line">	一次 wait/waitpid 函数调用，只能回收一个子进程。上一个例子，父进程产生了 5 个子进程，wait 会随机回收一个，捡到哪个算哪个。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ps ajx –&gt; pid ppid gid sid</p>
<p>在演示回收指定子进程的代码时出了问题，这里问题原因在于指定子进程的 pid 传递。父进程里 的 pid 变量和子进程 pid 变量并不是同一个。子进程结束时，父进程的 pid 还是原来的 0。 </p>
<p>原来的代码没有使用 fork 的返回值，导致父进程没有得到指定回收子进程的 pid。</p>
<p>默认情况下，父进程 fork 出来的子进程都属于同一个组。</p>
<p>错误代码如下图所示，它不能回收指定的第 3 个子进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">1. //指定回收一个子进程错误示例</span><br><span class="line">2. #include &lt;stdio.h&gt;</span><br><span class="line">3. #include &lt;stdlib.h&gt;</span><br><span class="line">4. #include &lt;string.h&gt;</span><br><span class="line">5. #include &lt;unistd.h&gt;</span><br><span class="line">6. #include &lt;sys/wait.h&gt;</span><br><span class="line">7. #include &lt;pthread.h&gt;</span><br><span class="line">8.</span><br><span class="line">9. int main(int argc, char *argv[])</span><br><span class="line">10. &#123;</span><br><span class="line">11. int i;</span><br><span class="line">12. pid_t pid, wpid;</span><br><span class="line">13.</span><br><span class="line">14. for (i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">15. if (fork() == 0) &#123; // 循环期间, 子进程不 fork</span><br><span class="line">16. if (i == 2) &#123;</span><br><span class="line">17. pid = getpid();</span><br><span class="line">18. printf(&quot;------pid = %d\n&quot;, pid);</span><br><span class="line">19. &#125;</span><br><span class="line">20. break;</span><br><span class="line">21. &#125;</span><br><span class="line">22. &#125;</span><br><span class="line">23.</span><br><span class="line">24. if (5 == i) &#123; // 父进程, 从 表达式 2 跳出</span><br><span class="line">25. sleep(5);</span><br><span class="line">26.</span><br><span class="line">27. //wait(NULL); // 一次 wait/waitpid 函数调用,只能回收一个子进程.</span><br><span class="line">28. //wpid = waitpid(-1, NULL, WNOHANG); //回收任意子进程,没有结束的子进程,父进程直接返回 0</span><br><span class="line">29. //wpid = waitpid(pid, NULL, WNOHANG); //指定一个进程回收</span><br><span class="line">30.</span><br><span class="line">31. printf(&quot;------in parent , before waitpid, pid= %d\n&quot;, pid);</span><br><span class="line">32. wpid = waitpid(pid, NULL, 0); //指定一个进程回收，这里因为是进的父进程，没有pid的值</span><br><span class="line">33. if (wpid == -1) &#123;</span><br><span class="line">34. perror(&quot;waitpid error&quot;);</span><br><span class="line">35. exit(1);</span><br><span class="line">36. &#125;</span><br><span class="line">37. printf(&quot;I&#x27;m parent, wait a child finish : %d \n&quot;, wpid);</span><br><span class="line">38.</span><br><span class="line">39. &#125; else &#123; // 子进程, 从 break 跳出</span><br><span class="line">40. sleep(i);</span><br><span class="line">41. printf(&quot;I&#x27;m %dth child, pid= %d\n&quot;, i+1, getpid());</span><br><span class="line">42. &#125;</span><br><span class="line">43.</span><br><span class="line">44. return 0;</span><br><span class="line">45. &#125;</span><br></pre></td></tr></table></figure>

<p>这个代码错误如之前所述，父进程里的 pid 还是 0，因为父进程里没有获取指定子进程的 pid， 于是父进程里的 pid 还保持默认值。</p>
<p>下面是正确的示例，循环 fork 出 5 个子进程，并回收指定的子进程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;sys/wait.h&gt;</span><br><span class="line">6. #include &lt;pthread.h&gt;</span><br><span class="line">7.</span><br><span class="line">8.</span><br><span class="line">9. int main(int argc, char *argv[])</span><br><span class="line">10. &#123;</span><br><span class="line">11. int i;</span><br><span class="line">12. pid_t pid, wpid, tmpid;</span><br><span class="line">13.</span><br><span class="line">14. for (i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">15. pid = fork();</span><br><span class="line">16. if (pid == 0) &#123; // 循环期间, 子进程不 fork</span><br><span class="line">17. break;</span><br><span class="line">18. &#125;</span><br><span class="line">19. if (i == 2) &#123;//这里是父进程</span><br><span class="line">20. tmpid = pid;</span><br><span class="line">21. printf(&quot;--------pid = %d\n&quot;, tmpid);</span><br><span class="line">22. &#125;</span><br><span class="line">23. &#125;</span><br><span class="line">24.</span><br><span class="line">25. if (5 == i) &#123; // 父进程, 从 表达式 2 跳出</span><br><span class="line">26. // sleep(5);</span><br><span class="line">27.</span><br><span class="line">28. //wait(NULL); // 一次 wait/waitpid 函数调用,只能回收一个子进程.</span><br><span class="line">29. //wpid = waitpid(-1, NULL, WNOHANG); //回收任意子进程,没有结束的子进程,父进程直接返回 0</span><br><span class="line">30. //wpid = waitpid(tmpid, NULL, 0); //指定一个进程回收, 阻塞等待</span><br><span class="line">31. printf(&quot;i am parent , before waitpid, pid = %d\n&quot;, tmpid);</span><br><span class="line">32.</span><br><span class="line">33. //wpid = waitpid(tmpid, NULL, WNOHANG); //指定一个进程回收, 不阻塞</span><br><span class="line">34. wpid = waitpid(tmpid, NULL, 0); //指定一个进程回收, 阻塞回收</span><br><span class="line">35. if (wpid == -1) &#123;</span><br><span class="line">36. perror(&quot;waitpid error&quot;);</span><br><span class="line">37. exit(1);</span><br><span class="line">38. &#125;</span><br><span class="line">39. printf(&quot;I&#x27;m parent, wait a child finish : %d \n&quot;, wpid);</span><br><span class="line">40.</span><br><span class="line">41. &#125; else &#123; // 子进程, 从 break 跳出</span><br><span class="line">42. sleep(i);</span><br><span class="line">43. printf(&quot;I&#x27;m %dth child, pid= %d\n&quot;, i+1, getpid());</span><br><span class="line">44. &#125;</span><br><span class="line">45.</span><br><span class="line">46. return 0;</span><br><span class="line">47. &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>指定回收的第三个进程，就回收的第三个。这里实现由两种，一个是阻塞等待回收指定 进程，一个是非阻塞，但是用 sleep 延时父进程，以保证待回收的指定子进程已经执行结束。上面这 个代码使用的阻塞回收，这个方案的问题在于终端提示符会和输出混杂在一起。使用非阻塞回收 +延时的方法，这样终端提示符就不会混在输出里。</p>
<h2 id="waitpid-回收多个子进程"><a href="#waitpid-回收多个子进程" class="headerlink" title="waitpid 回收多个子进程"></a>waitpid 回收多个子进程</h2><p>一次 wait&#x2F;waitpid 函数调用，只能回收一个子进程。上一个例子，父进程产生了 5 个子进程， wait 会随机回收一个，捡到哪个算哪个</p>
<p>总结： wait、waitpid 一次调用，回收一个子进程。 想回收多个。while</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if (5 == i) &#123; // 父进程, 从 表达式 2 跳出</span><br><span class="line"> 	/* </span><br><span class="line"> 	while ((wpid = waitpid(-1, NULL, 0))) &#123; // 使用阻塞方式回收子进程</span><br><span class="line">		printf(&quot;wait child %d \n&quot;, wpid);</span><br><span class="line">	&#125;</span><br><span class="line">	*/</span><br><span class="line">	while ((wpid = waitpid(-1, NULL, WNOHANG)) != -1) &#123; //使用非阻塞方式,回收子进程.</span><br><span class="line">		if (wpid &gt; 0) &#123;</span><br><span class="line">			printf(&quot;wait child %d \n&quot;, wpid);</span><br><span class="line">		&#125; else if (wpid == 0) &#123;</span><br><span class="line">			sleep(1);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程间通信常见方式"><a href="#进程间通信常见方式" class="headerlink" title="进程间通信常见方式"></a>进程间通信常见方式</h2><p>IPC(InterProcess Communication)进程间通信</p>
<p>进程间通信的常用方式，特征： </p>
<p>管道：简单 </p>
<p>信号：开销小 </p>
<p>mmap 映射：非血缘关系进程间 </p>
<p>socket（本地套接字）：稳定</p>
<h2 id="管道的特质"><a href="#管道的特质" class="headerlink" title="管道的特质"></a>管道的特质</h2><p>管道：<br>实现原理： 内核借助环形队列机制，使用内核缓冲区实现。<br>特质； </p>
<p>​	1. 伪文件</p>
<ol start="2">
<li>管道中的数据只能一次读取。</li>
<li>数据在管道中，只能单向流动。</li>
</ol>
<p>局限性：</p>
<ol>
<li>自己写，不能自己读。</li>
<li>数据不可以反复读。</li>
<li>半双工通信。</li>
<li>血缘关系进程间可用。</li>
</ol>
<h2 id="管道的基本用法"><a href="#管道的基本用法" class="headerlink" title="管道的基本用法"></a>管道的基本用法</h2><p>pipe 函数： 创建，并打开管道。<br>    int pipe(int fd[2]);<br>        参数： fd[0]: 读端。<br>                    fd[1]: 写端。<br>        返回值： 成功： 0<br>                        失败： -1 errno</p>
<p>一个管道通信的示例，父进程往管道里写，子进程从管道读，然后打印读取的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;errno.h&gt;</span><br><span class="line">6. #include &lt;pthread.h&gt;</span><br><span class="line">7.</span><br><span class="line">8. void sys_err(const char *str)</span><br><span class="line">9. &#123;</span><br><span class="line">10. perror(str);</span><br><span class="line">11. exit(1);</span><br><span class="line">12. &#125;</span><br><span class="line">13.</span><br><span class="line">14. int main(int argc, char *argv[])</span><br><span class="line">15. &#123;</span><br><span class="line">16. int ret;</span><br><span class="line">17. int fd[2];</span><br><span class="line">18. pid_t pid;</span><br><span class="line">19.</span><br><span class="line">20. char *str = &quot;hello pipe\n&quot;;</span><br><span class="line">21. char buf[1024];</span><br><span class="line">22.</span><br><span class="line">23. ret = pipe(fd);</span><br><span class="line">24. if (ret == -1)</span><br><span class="line">25. sys_err(&quot;pipe error&quot;);</span><br><span class="line">26.</span><br><span class="line">27. pid = fork();</span><br><span class="line">28. if (pid &gt; 0) &#123;</span><br><span class="line">29. close(fd[0]); // 父进程关闭读段</span><br><span class="line">30. //sleep(3);</span><br><span class="line">31. write(fd[1], str, strlen(str));</span><br><span class="line">32. close(fd[1]);</span><br><span class="line">33. &#125; else if (pid == 0) &#123;</span><br><span class="line">34. close(fd[1]); // 子进程关闭写段</span><br><span class="line">35. ret = read(fd[0], buf, sizeof(buf));</span><br><span class="line">36. printf(&quot;child read ret = %d\n&quot;, ret);</span><br><span class="line">37. write(STDOUT_FILENO, buf, ret);</span><br><span class="line">38.</span><br><span class="line">39. close(fd[0]);</span><br><span class="line">40. &#125;</span><br><span class="line">41.</span><br><span class="line">42. return 0;</span><br><span class="line">43. &#125;</span><br></pre></td></tr></table></figure>

<h2 id="管道读写行为"><a href="#管道读写行为" class="headerlink" title="管道读写行为"></a>管道读写行为</h2><p>管道的读写行为：<br>读管道：</p>
<ol>
<li>管道有数据，read 返回实际读到的字节数。</li>
<li>管道无数据： 1）无写端，read 返回 0 （类似读到文件尾）<br> 2）有写端，read 阻塞等待。</li>
</ol>
<p>写管道：</p>
<ol>
<li>无读端， 异常终止。 （SIGPIPE 导致的）</li>
<li>有读端： 1） 管道已满， 阻塞等待<br> 2） 管道未满， 返回写出的字节个数。</li>
</ol>
<p>普通文件，目录，软链接，这三个要占磁盘空间 </p>
<p>管道，套接字，字符设备，块设备，不占磁盘空间，伪文件</p>
<p>磁盘访问需要open和read,内存访问用地址，即使用指针访问。</p>
<h2 id="父子进程-lswc-l"><a href="#父子进程-lswc-l" class="headerlink" title="父子进程 lswc-l"></a>父子进程 lswc-l</h2><p>练习：使用管道实现父子进程间通信，完成：ls | wc -l 假定父进程实现 ls，子进程实现 wc<br>ls 命令正常会将结果集写到 stdout，但现在会写入管道写端<br>wc -l 命令正常应该从 stdin 读取数据，但此时会从管道的读端读。<br>要用到 pipe dup2 exec<br>代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;errno.h&gt;</span><br><span class="line">6. #include &lt;pthread.h&gt;</span><br><span class="line">7.</span><br><span class="line">8. void sys_err(const char *str)</span><br><span class="line">9. &#123;</span><br><span class="line">10. perror(str);</span><br><span class="line">11. exit(1);</span><br><span class="line">12. &#125;</span><br><span class="line">13. int main(int argc, char *argv[])</span><br><span class="line">14. &#123;</span><br><span class="line">15. int fd[2];</span><br><span class="line">16. int ret;</span><br><span class="line">17. pid_t pid;</span><br><span class="line">18.</span><br><span class="line">19. ret = pipe(fd); // 父进程先创建一个管道,持有管道的读端和写端</span><br><span class="line">20. if (ret == -1) &#123;</span><br><span class="line">21. sys_err(&quot;pipe error&quot;);</span><br><span class="line">22. &#125;</span><br><span class="line">23.</span><br><span class="line">24. pid = fork(); // 子进程同样持有管道的读和写端</span><br><span class="line">25. if (pid == -1) &#123;</span><br><span class="line">26. sys_err(&quot;fork error&quot;);</span><br><span class="line">27. &#125;</span><br><span class="line">28. else if (pid &gt; 0) &#123; // 父进程 读, 关闭写端</span><br><span class="line">29. close(fd[1]);</span><br><span class="line">30. dup2(fd[0], STDIN_FILENO); // 重定向 stdin 到 管道的 读端</span><br><span class="line">31. execlp(&quot;wc&quot;, &quot;wc&quot;, &quot;-l&quot;, NULL); // 执行 wc -l 程序</span><br><span class="line">32. sys_err(&quot;exclp wc error&quot;);</span><br><span class="line">33. &#125;</span><br><span class="line">34. else if (pid == 0) &#123;</span><br><span class="line">35. close(fd[0]);</span><br><span class="line">36. dup2(fd[1], STDOUT_FILENO); // 重定向 stdout 到 管道写端</span><br><span class="line">37. execlp(&quot;ls&quot;, &quot;ls&quot;, NULL); // 子进程执行 ls 命令</span><br><span class="line">38. sys_err(&quot;exclp ls error&quot;);</span><br><span class="line">39. &#125;</span><br><span class="line">40.</span><br><span class="line">41. return 0;</span><br><span class="line">42. &#125;</span><br></pre></td></tr></table></figure>

<h2 id="兄弟进程间通信"><a href="#兄弟进程间通信" class="headerlink" title="兄弟进程间通信"></a>兄弟进程间通信</h2><p>练习题：兄弟进程间通信<br>兄：ls<br>弟：wc -l<br>父：等待回收子进程<br>要求，使用循环创建 N 个子进程模型创建兄弟进程，使用循环因子 i 标识，注意管道读写行为<br>测试：<br>是否允许，一个 pipe 有一个写端多个读端 可<br>是否允许，一个 pipe 有多个写端一个读端 可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;sys/wait.h&gt;</span><br><span class="line">5. #include &lt;unistd.h&gt;</span><br><span class="line">6. #include &lt;errno.h&gt;</span><br><span class="line">7. #include &lt;pthread.h&gt;</span><br><span class="line">8.</span><br><span class="line">9. void sys_err(const char *str)</span><br><span class="line">10. &#123;</span><br><span class="line">11. perror(str);</span><br><span class="line">12. exit(1);</span><br><span class="line">13. &#125;</span><br><span class="line">14. int main(int argc, char *argv[])</span><br><span class="line">15. &#123;</span><br><span class="line">16. int fd[2];</span><br><span class="line">17. int ret, i;</span><br><span class="line">18. pid_t pid;</span><br><span class="line">19.</span><br><span class="line">20. ret = pipe(fd);</span><br><span class="line">21. if (ret == -1) &#123;</span><br><span class="line">22. sys_err(&quot;pipe error&quot;);</span><br><span class="line">23. &#125;</span><br><span class="line">24.</span><br><span class="line">25. for(i = 0; i &lt; 2; i++) &#123; // 表达式 2 出口,仅限父进程使用</span><br><span class="line">26. pid = fork();</span><br><span class="line">27. if (pid == -1) &#123;</span><br><span class="line">28. sys_err(&quot;fork error&quot;);</span><br><span class="line">29. &#125;</span><br><span class="line">30. if (pid == 0) // 子进程,出口</span><br><span class="line">31. break;</span><br><span class="line">32. &#125;</span><br><span class="line">33.</span><br><span class="line">34. if (i == 2) &#123; // 父进程 . 不参与管道使用.</span><br><span class="line">35. close(fd[0]); // 关闭管道的 读端/写端.</span><br><span class="line">36. close(fd[1]);</span><br><span class="line">37.</span><br><span class="line">38. wait(NULL); // 回收子进程</span><br><span class="line">39. wait(NULL);</span><br><span class="line">40. &#125; else if (i == 0) &#123; // 哥哥</span><br><span class="line">41. close(fd[0]);</span><br><span class="line">42. dup2(fd[1], STDOUT_FILENO); // 重定向 stdout</span><br><span class="line">43. execlp(&quot;ls&quot;, &quot;ls&quot;, NULL);</span><br><span class="line">44. sys_err(&quot;exclp ls error&quot;);</span><br><span class="line">45. &#125; else if (i == 1) &#123; //弟弟</span><br><span class="line">46. close(fd[1]);</span><br><span class="line">47. dup2(fd[0], STDIN_FILENO); // 重定向 stdin</span><br><span class="line">48. execlp(&quot;wc&quot;, &quot;wc&quot;, &quot;-l&quot;, NULL);</span><br><span class="line">49. sys_err(&quot;exclp wc error&quot;);</span><br><span class="line">50. &#125;</span><br><span class="line">51.</span><br><span class="line">52. return 0;</span><br><span class="line">53. &#125;</span><br></pre></td></tr></table></figure>

<p>这个代码需要注意一点，父进程不使用管道，所以一定要关闭父进程的管道，保证数据单向流动。</p>
<h2 id="多个读写端操作管道和管道缓冲区大小"><a href="#多个读写端操作管道和管道缓冲区大小" class="headerlink" title="多个读写端操作管道和管道缓冲区大小"></a>多个读写端操作管道和管道缓冲区大小</h2><p>下面是一个父进程读，俩子进程写的例子，也就是一个读端多个写端。需要调控写入顺序才行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;unistd.h&gt;</span><br><span class="line">3. #include &lt;sys/wait.h&gt;</span><br><span class="line">4. #include &lt;string.h&gt;</span><br><span class="line">5. #include &lt;stdlib.h&gt;</span><br><span class="line">6.</span><br><span class="line">7. int main(void)</span><br><span class="line">8. &#123;</span><br><span class="line">9. pid_t pid;</span><br><span class="line">10. int fd[2], i, n;</span><br><span class="line">11. char buf[1024];</span><br><span class="line">12.</span><br><span class="line">13. int ret = pipe(fd);</span><br><span class="line">14. if(ret == -1)&#123;</span><br><span class="line">15. perror(&quot;pipe error&quot;);</span><br><span class="line">16. exit(1);</span><br><span class="line">17. &#125;</span><br><span class="line">18.</span><br><span class="line">19. for(i = 0; i &lt; 2; i++)&#123;</span><br><span class="line">20. if((pid = fork()) == 0)</span><br><span class="line">21. break;</span><br><span class="line">22. else if(pid == -1)&#123;</span><br><span class="line">23. perror(&quot;pipe error&quot;);</span><br><span class="line">24. exit(1);</span><br><span class="line">25. &#125;</span><br><span class="line">26. &#125;</span><br><span class="line">27.</span><br><span class="line">28. if (i == 0) &#123;</span><br><span class="line">29. close(fd[0]);</span><br><span class="line">30. write(fd[1], &quot;1.hello\n&quot;, strlen(&quot;1.hello\n&quot;));</span><br><span class="line">31. &#125; else if(i == 1) &#123;</span><br><span class="line">32. close(fd[0]);</span><br><span class="line">33. write(fd[1], &quot;2.world\n&quot;, strlen(&quot;2.world\n&quot;));</span><br><span class="line">34. &#125; else &#123;</span><br><span class="line">35. close(fd[1]); //父进程关闭写端,留读端读取数据</span><br><span class="line">36. sleep(1);</span><br><span class="line">37. n = read(fd[0], buf, 1024); //从管道中读数据</span><br><span class="line">38. write(STDOUT_FILENO, buf, n);</span><br><span class="line">39.</span><br><span class="line">40. for(i = 0; i &lt; 2; i++) //两个儿子 wait 两次</span><br><span class="line">41. wait(NULL);</span><br><span class="line">42. &#125;</span><br><span class="line">43.</span><br><span class="line">44. return 0;</span><br><span class="line">45. &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个例子需要注意，父进程必须等一下，不然可能俩子进程只写了一个，父进程就读完跑路了。 </p>
<p>管道大小，默认 4096</p>
<h2 id="命名管道-fifo-的创建和原理图"><a href="#命名管道-fifo-的创建和原理图" class="headerlink" title="命名管道 fifo 的创建和原理图"></a>命名管道 fifo 的创建和原理图</h2><p>管道的优劣：<br>优点：简单，相比信号，套接字实现进程通信，简单很多<br>缺点：1.只能单向通信，双向通信需建立两个管道<br> 2.只能用于有血缘关系的进程间通信。该问题后来使用 fifo 命名管道解决。</p>
<p>fifo 管道：可以用于无血缘关系的进程间通信。<br>命名管道： mkfifo<br>无血缘关系进程间通信：<br>读端，open fifo O_RDONLY<br>写端，open fifo O_WRONLY<br>fifo 操作起来像文件<br>下面的代码创建一个 fifo：</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612214052445.png" alt="image-20230612214052445"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612214052445.png" class title="This is an test image">

<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612215028041.png" alt="image-20230612215028041"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612215028041.png" class title="This is an test image">

<h2 id="fifo-实现非血缘关系进程间通信"><a href="#fifo-实现非血缘关系进程间通信" class="headerlink" title="fifo 实现非血缘关系进程间通信"></a>fifo 实现非血缘关系进程间通信</h2><p>下面这个例子，一个写 fifo，一个读 fifo，操作起来就像文件一样的：</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612214842946.png" alt="image-20230612214842946"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612214842946.png" class title="This is an test image">

<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612214916095.png" alt="image-20230612214916095"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612214916095.png" class title="This is an test image">

<p>编译执行，如图：<img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612215107477.png" alt="image-20230612215107477"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612215107477.png" class title="This is an test image">

<p>测试一个写端多个读端的时候，由于数据一旦被读走就没了，所以多个读端的并集才是写端的写 入数据。</p>
<h2 id="文件用于进程间通信"><a href="#文件用于进程间通信" class="headerlink" title="文件用于进程间通信"></a>文件用于进程间通信</h2><p>文件实现进程间通信： 打开的文件是内核中的一块缓冲区。多个无血缘关系的进程，可以同时访问该文件。</p>
<p><strong>socket套接字也是一种文件格式，和管道文件一样，它是一种伪文件</strong>，存在于内核的缓冲区中，大小不变，一直是0。</p>
<h2 id="mmap-函数原型"><a href="#mmap-函数原型" class="headerlink" title="mmap 函数原型"></a>mmap 函数原型</h2><p>磁盘访问需要open和read,内存访问用地址，即使用指针访问。</p>
<p>内核缓冲区是位于内核空间的一块特定内存区域，用于临时存储和处理数据。在 Linux 内核中，访问内核缓冲区通常需要使用相应的系统调用或函数。一种常见的方式是使用 I&#x2F;O 操作函数来读取或写入内核缓冲区的内容。例如，在文件 I&#x2F;O 中，我们可以使用系统调用 <code>read()</code> 和 <code>write()</code> 来分别从内核缓冲区读取数据到用户空间或将数据从用户空间写入到内核缓冲区。</p>
<p>存储映射 I&#x2F;O(Memory-mapped I&#x2F;O) 使一个磁盘文件与存储空间中的一个缓冲区相映射。于是从缓冲区中取数据，就相当于读文件中的相应字节。与此类似，将数据存入缓冲区，则相应的字节就自动写入文件。这样，就可在不使用 read 和 write 函数的情况下，使地址指针完成 I&#x2F;O 操作。<br>使用这种方法，首先应该通知内核，将一个指定文件映射到存储区域中。这个映射工作可以通过mmap 函数来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</span><br><span class="line">创建共享内存映射</span><br><span class="line">参数：</span><br><span class="line">    addr： 指定映射区的首地址。通常传 NULL，表示让系统自动分配</span><br><span class="line">    length：共享内存映射区的大小。（&lt;= 文件的实际大小）</span><br><span class="line">    prot： 共享内存映射区的读写属性。PROT_READ、PROT_WRITE、PROT_READ|PROT_WRITE</span><br><span class="line">    flags： 标注共享内存的共享属性。MAP_SHARED、MAP_PRIVATE</span><br><span class="line">    fd: 用于创建共享内存映射区的那个文件的 文件描述符。</span><br><span class="line">    offset：默认 0，表示映射文件全部。偏移位置。需是 4k 的整数倍。</span><br><span class="line">返回值：</span><br><span class="line">    成功：映射区的首地址。</span><br><span class="line">    失败：MAP_FAILED (void*(-1))， errno</span><br><span class="line">   flags 里面的 shared 意思是修改会反映到磁盘上</span><br><span class="line">     private 表示修改不反映到磁盘上</span><br><span class="line"> int munmap(void *addr, size_t length); 释放映射区。</span><br><span class="line">    addr：mmap 的返回值</span><br><span class="line">    length：大小</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>出现段错误，gdb然后run停止的地方就是段错误。</p>
<h2 id="mmap-建立映射区"><a href="#mmap-建立映射区" class="headerlink" title="mmap 建立映射区"></a>mmap 建立映射区</h2><p>下面这个示例代码，使用 mmap 创建一个映射区（共享内存），并往映射区里写入内容：</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230614113240142.png" alt="image-20230614113240142"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230614113240142.png" class title="This is an test image">

<h2 id="mmap-使用注意事项"><a href="#mmap-使用注意事项" class="headerlink" title="mmap 使用注意事项"></a>mmap 使用注意事项</h2><p>使用注意事项：</p>
<ol>
<li>用于创建映射区的文件大小为 0，实际指定非 0 大小创建映射区，出 “总线错误”。</li>
<li>用于创建映射区的文件大小为 0，实际制定 0 大小创建映射区， 出 “无效参数”。</li>
<li>用于创建映射区的文件读写属性为，只读。映射区属性为 读、写。 出 “无效参数”。</li>
<li>创建映射区，需要 read 权限。当访问权限指定为 “共享”MAP_SHARED 时， mmap 的读写权限，应该 &lt;&#x3D;文件的 open 权限。 只写不行。</li>
<li>文件描述符 fd，在 mmap 创建映射区完成即可关闭。后续访问文件，用 地址访问。</li>
<li>offset 必须是 4096 的整数倍。（MMU 映射的最小单位 4k ）</li>
<li>对申请的映射区内存，不能越界访问。</li>
<li>munmap 用于释放的 地址，必须是 mmap 申请返回的地址。</li>
<li>映射区访问权限为 “私有”MAP_PRIVATE, 对内存所做的所有修改，只在内存有效，不会反应到物理磁盘上。</li>
<li>映射区访问权限为 “私有”MAP_PRIVATE, 只需要 open 文件时，有读权限，用于创建映射区即可。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mmap 函数的保险调用方式：</span><br><span class="line">1. fd = open（&quot;文件名&quot;， O_RDWR）;</span><br><span class="line">2. mmap(NULL, 有效文件大小， PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);</span><br></pre></td></tr></table></figure>

<p>mmap 总结 </p>
<ol>
<li>创建映射区的过程中，隐含着一次对映射文件的读操作</li>
<li>当 MAP_SHARED 时，要求：映射区的权限应该&lt;&#x3D;文件打开的权限（出于对映射区的保护）。而MAP_PRIVATE 则无所谓，因为 mmap 中的权限是对内存的限制</li>
<li>映射区的释放与文件关闭无关。只要映射建立成功，文件可以立即关闭</li>
<li>特别注意，当映射文件大小为 0 时，不能创建映射区。所以：用于映射的文件必须要有实际大小！！mmap 使用时常常会出现总线错误，通常是由于共享文件存储空间大小引起的。如，400 字节大小的文件，在简历映射区时，offset4096 字节，则会报出总线错误</li>
<li>munmap 传入的地址一定是 mmap 返回的地址。坚决杜绝指针++操作,会改变地址，在指针本身上操作</li>
<li>文件偏移量必须为 4K 的整数倍</li>
<li>mmap 创建映射区出错概率非常高，一定要检查返回值，确保映射区建立成功再进行后续操作。</li>
</ol>
<h2 id="父子进程间-mmap-通信"><a href="#父子进程间-mmap-通信" class="headerlink" title="父子进程间 mmap 通信"></a>父子进程间 mmap 通信</h2><p>父子进程使用 mmap 进程间通信：<br>父进程 先 创建映射区。 <code>open（ O_RDWR） mmap( MAP_SHARED );</code><br>指定 MAP_SHARED 权限<br>fork() 创建子进程。<br>一个进程读， 另外一个进程写</p>
<p>下面这段代码，父子进程 mmap 通信，共享内存是一个 int 变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;unistd.h&gt;</span><br><span class="line">4. #include &lt;fcntl.h&gt;</span><br><span class="line">5. #include &lt;sys/mman.h&gt;</span><br><span class="line">6. #include &lt;sys/wait.h&gt;</span><br><span class="line">7.</span><br><span class="line">8. int var = 100;</span><br><span class="line">9.</span><br><span class="line">10. int main(void)</span><br><span class="line">11. &#123;</span><br><span class="line">12. int *p;</span><br><span class="line">13. pid_t pid;</span><br><span class="line">14.</span><br><span class="line">15. int fd;</span><br><span class="line">16. fd = open(&quot;temp&quot;, O_RDWR|O_CREAT|O_TRUNC, 0644);</span><br><span class="line">17. if(fd &lt; 0)&#123;</span><br><span class="line">18. perror(&quot;open error&quot;);</span><br><span class="line">19. exit(1);</span><br><span class="line">20. &#125;</span><br><span class="line">21. ftruncate(fd, 4);</span><br><span class="line">22.</span><br><span class="line">23. p = (int *)mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);</span><br><span class="line">24. //p = (int *)mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);</span><br><span class="line">25. if(p == MAP_FAILED)&#123; //注意:不是 p == NULL</span><br><span class="line">26. perror(&quot;mmap error&quot;);</span><br><span class="line">27. exit(1);</span><br><span class="line">28. &#125;</span><br><span class="line">29. close(fd); //映射区建立完毕,即可关闭文件</span><br><span class="line">30.</span><br><span class="line">31. pid = fork(); //创建子进程</span><br><span class="line">32. if(pid == 0)&#123;</span><br><span class="line">33. *p = 7000; // 写共享内存</span><br><span class="line">34. var = 1000;</span><br><span class="line">35. printf(&quot;child, *p = %d, var = %d\n&quot;, *p, var);</span><br><span class="line">36. &#125; else &#123;</span><br><span class="line">37. sleep(1);</span><br><span class="line">38. printf(&quot;parent, *p = %d, var = %d\n&quot;, *p, var); // 读共享内存</span><br><span class="line">39. wait(NULL);</span><br><span class="line">40.</span><br><span class="line">41. int ret = munmap(p, 4); //释放映射区</span><br><span class="line">42. if (ret == -1) &#123;</span><br><span class="line">43. perror(&quot;munmap error&quot;);</span><br><span class="line">44. exit(1);</span><br><span class="line">45. &#125;</span><br><span class="line">46. &#125;</span><br><span class="line">47.</span><br><span class="line">48. return 0;</span><br><span class="line">49. &#125;</span><br></pre></td></tr></table></figure>

<h2 id="无血缘关系进程间-mmap-通信"><a href="#无血缘关系进程间-mmap-通信" class="headerlink" title="无血缘关系进程间 mmap 通信"></a>无血缘关系进程间 mmap 通信</h2><p>无血缘关系进程间 mmap 通信：<br>两个进程 打开同一个文件，创建映射区。<br>指定 flags 为 MAP_SHARED。<br>一个进程写入，另外一个进程读出。<br>【注意】：无血缘关系进程间通信。mmap：数据可以重复读取。<br>fifo：数据只能一次读取。</p>
<p>下面是两个无血缘关系的通信代码，先是写进程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;sys/stat.h&gt;</span><br><span class="line">3. #include &lt;sys/types.h&gt;</span><br><span class="line">4. #include &lt;fcntl.h&gt;</span><br><span class="line">5. #include &lt;unistd.h&gt;</span><br><span class="line">6. #include &lt;stdlib.h&gt;</span><br><span class="line">7. #include &lt;sys/mman.h&gt;</span><br><span class="line">8. #include &lt;string.h&gt;</span><br><span class="line">9.</span><br><span class="line">10. struct STU &#123;</span><br><span class="line">11. int id;</span><br><span class="line">12. char name[20];</span><br><span class="line">13. char sex;</span><br><span class="line">14. &#125;;</span><br><span class="line">15.</span><br><span class="line">16. void sys_err(char *str)</span><br><span class="line">17. &#123;</span><br><span class="line">18. perror(str);</span><br><span class="line">19. exit(1);</span><br><span class="line">20. &#125;</span><br><span class="line">21.</span><br><span class="line">22. int main(int argc, char *argv[])</span><br><span class="line">23. &#123;</span><br><span class="line">24. int fd;</span><br><span class="line">25. struct STU student = &#123;10, &quot;xiaoming&quot;, &#x27;m&#x27;&#125;;</span><br><span class="line">26. char *mm;</span><br><span class="line">27.</span><br><span class="line">28. if (argc &lt; 2) &#123;</span><br><span class="line">29. printf(&quot;./a.out file_shared\n&quot;);</span><br><span class="line">30. exit(-1);</span><br><span class="line">31. &#125;</span><br><span class="line">32.</span><br><span class="line">33. fd = open(argv[1], O_RDWR | O_CREAT, 0664);</span><br><span class="line">34. ftruncate(fd, sizeof(student));</span><br><span class="line">35.</span><br><span class="line">36. mm = mmap(NULL, sizeof(student), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);</span><br><span class="line">37. if (mm == MAP_FAILED)</span><br><span class="line">38. sys_err(&quot;mmap&quot;);</span><br><span class="line">39.</span><br><span class="line">40. close(fd);</span><br><span class="line">41.</span><br><span class="line">42. while (1) &#123;</span><br><span class="line">43. memcpy(mm, &amp;student, sizeof(student));</span><br><span class="line">44. student.id++;</span><br><span class="line">45. sleep(1);</span><br><span class="line">46. &#125;</span><br><span class="line">47.</span><br><span class="line">48. munmap(mm, sizeof(student));</span><br><span class="line">49.</span><br><span class="line">50. return 0;</span><br><span class="line">51. &#125;</span><br></pre></td></tr></table></figure>

<p>然后是读进程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;sys/stat.h&gt;</span><br><span class="line">3. #include &lt;fcntl.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;stdlib.h&gt;</span><br><span class="line">6. #include &lt;sys/mman.h&gt;</span><br><span class="line">7. #include &lt;string.h&gt;</span><br><span class="line">8.</span><br><span class="line">9. struct STU &#123;</span><br><span class="line">10. int id;</span><br><span class="line">11. char name[20];</span><br><span class="line">12. char sex;</span><br><span class="line">13. &#125;;</span><br><span class="line">14.</span><br><span class="line">15. void sys_err(char *str)</span><br><span class="line">16. &#123;</span><br><span class="line">17. perror(str);</span><br><span class="line">18. exit(-1);</span><br><span class="line">19. &#125;</span><br><span class="line">20.</span><br><span class="line">21. int main(int argc, char *argv[])</span><br><span class="line">22. &#123;</span><br><span class="line">23. int fd;</span><br><span class="line">24. struct STU student;</span><br><span class="line">25. struct STU *mm;</span><br><span class="line">26.</span><br><span class="line">27. if (argc &lt; 2) &#123;</span><br><span class="line">28. printf(&quot;./a.out file_shared\n&quot;);</span><br><span class="line">29. exit(-1);</span><br><span class="line">30. &#125;</span><br><span class="line">31.</span><br><span class="line">32. fd = open(argv[1], O_RDONLY);</span><br><span class="line">33. if (fd == -1)</span><br><span class="line">34. sys_err(&quot;open error&quot;);</span><br><span class="line">35.</span><br><span class="line">36. mm = mmap(NULL, sizeof(student), PROT_READ, MAP_SHARED, fd, 0);</span><br><span class="line">37. if (mm == MAP_FAILED)</span><br><span class="line">38. sys_err(&quot;mmap error&quot;);</span><br><span class="line">39.</span><br><span class="line">40. close(fd);</span><br><span class="line">41.</span><br><span class="line">42. while (1) &#123;</span><br><span class="line">43. printf(&quot;id=%d\tname=%s\t%c\n&quot;, mm-&gt;id, mm-&gt;name, mm-&gt;sex);</span><br><span class="line">44. sleep(2);</span><br><span class="line">45. &#125;</span><br><span class="line">46. munmap(mm, sizeof(student));</span><br><span class="line">47.</span><br><span class="line">48. return 0;</span><br><span class="line">49. &#125;</span><br></pre></td></tr></table></figure>

<p>如图，一读一写，问题不大。 多个写端一个读端也没问题，打开多个写进程即可，完事儿读进程会读到所有写进程写入的内容。 这里要注意一个，内容被读走之后不会消失，所以如果读进程的读取时间间隔短，它会读到很多重复内容，就是因为写进程没来得及写入新内容。</p>
<h2 id="mmap-匿名映射区"><a href="#mmap-匿名映射区" class="headerlink" title="mmap 匿名映射区"></a>mmap 匿名映射区</h2><p>匿名映射：只能用于 血缘关系进程间通信。 </p>
<p><code>p = (int *)mmap(NULL, 40, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/31/%E5%85%B3%E4%BA%8Evim%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/31/%E5%85%B3%E4%BA%8Evim%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">关于vim的一些配置问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-31 09:39:24 / 修改时间：10:42:27" itemprop="dateCreated datePublished" datetime="2023-05-31T09:39:24+08:00">2023-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/%E5%85%B3%E4%BA%8Evim%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/image-20230531094409134.png" alt="image-20230531094409134"></p>
<img src="/2023/05/31/%E5%85%B3%E4%BA%8Evim%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/image-20230531094409134.png" class title="This is an test image">

<p><img src="/%E5%85%B3%E4%BA%8Evim%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/image-20230531094456531.png" alt="image-20230531094456531"></p>
<img src="/2023/05/31/%E5%85%B3%E4%BA%8Evim%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/image-20230531094456531.png" class title="This is an test image">

<p>总之语法补全我用的是YouCompleteMe，通过插件管理器Vundle来进行安装，需要先git,再正确初始化YouCompleteMe插件的子模块</p>
<p>安装 YouCompleteMe（ycm）插件需要使用 Clang 编译器及其相关组件，因为 ycm 的自动补全和语义分析功能都是基于 Clang 提供的编译器前端实现的。具体来说，ycm 依赖以下的软件&#x2F;库：</p>
<ul>
<li>Python 解释器和开发工具包</li>
<li>Clang 编译器和其相关组件：Libclang、Clangd 等</li>
<li>CMake 构建工具</li>
<li>LLVM 代码生成框架</li>
</ul>
<p>因此，在安装 YouCompleteMe 插件之前，您需要先安装上述软件&#x2F;库，并确保它们能够正常工作。此外，YouCompleteMe 更支持直接使用系统自带的 Clang，不需要单独安装。</p>
<p><img src="/%E5%85%B3%E4%BA%8Evim%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/image-20230531094926944.png" alt="image-20230531094926944"></p>
<img src="/2023/05/31/%E5%85%B3%E4%BA%8Evim%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/image-20230531094926944.png" class title="This is an test image">

<p>如果你需要配置vim，只需在Home目录创建一个**<del>&#x2F;.vimrc**文件即可以配置vim了，如需安装插件，在</del>&#x2F;.vim目录下创建一个bundle文件夹，插件装在里面。我通过Vundle管理插件，这里YouCompleteMe插件需要前面的git，无法直接安装。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">YouCompleteMe是一个基于Python编写的Vim自动补全插件，它需要使用C++编译器和Python 3.x运行时才能正常工作。这是因为插件的代码本身是使用C++编写的，但是它需要使用Python来启动和管理插件进程，并在后台执行代码分析等任务。</span><br><span class="line"></span><br><span class="line">具体来说，ycm 依赖以下的软件/库：</span><br><span class="line"></span><br><span class="line">Python 解释器和开发工具包</span><br><span class="line">Clang 编译器和其相关组件：Libclang、Clangd 等</span><br><span class="line">CMake 构建工具</span><br><span class="line">LLVM 代码生成框架</span><br><span class="line">因此，在安装 YouCompleteMe 插件之前，您需要先安装上述软件/库，并确保它们能够正常工作。此外，YouCompleteMe 更支持直接使用系统自带的 Clang，不需要单独安装。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CMake 是一款独立的构建工具，并不是一个命令行工具，因此您需要在 CMakeLists.txt 文件中定义项目的配置、编译规则和安装步骤等。一般情况下，在终端中运行 cmake 命令来生成对应平台的 Makefile 或 IDE 项目文件，然后使用 make 或者 Visual Studio 等工具来实际编译执行。</span><br><span class="line"></span><br><span class="line">以下是你可以在终端中使用的常用 CMake 命令：</span><br><span class="line"></span><br><span class="line">cmake: 根据当前目录下的 CMakeLists.txt 文件生成 makefiles 或 IDE 项目文件；</span><br><span class="line">cmake-gui: 使用 GUI 界面进行配置和生成构建系统（Windows 和 macOS）；</span><br><span class="line">cmake --build: 调用底层构建系统（如 make 或 Visual Studio）来编译项目；</span><br><span class="line">cmake --install: 安装构建好的程序或库到指定的位置；</span><br><span class="line">ctest: 运行测试套件并输出测试结果；</span><br><span class="line">cpack: 将已构建好的项目打包成单个、可移植的二进制发行版。</span><br><span class="line">需要注意的是，上述命令中的参数和具体用法可能会因不同的项目而有所区别，请根据具体文档来参考使用。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">这个错误提示意味着您的电脑没有安装CMake或者CMake可执行文件的路径没有加入到系统环境变量中。请按照以下步骤来解决此问题：</span><br><span class="line"></span><br><span class="line">如果您没有安装CMake，请先安装最新版的CMake。您可以在Linux上使用包管理器，在终端输入以下命令：</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install cmake</span><br><span class="line">如果您使用的是其他操作系统，请参考相关文档安装CMake。</span><br><span class="line"></span><br><span class="line">确认CMake是否已经添加到系统环境变量中。如果没有，请将CMake的可执行文件路径添加到环境变量中，方法如下：</span><br><span class="line"></span><br><span class="line">在终端中运行以下命令打开.bashrc或.zshrc文件编辑器：</span><br><span class="line"></span><br><span class="line">vim ~/.bashrc # 或者vim ~/.zshrc（取决于您使用的shell）</span><br><span class="line">将以下内容添加到文件末尾，并保存退出：</span><br><span class="line"></span><br><span class="line">export PATH=&quot;$PATH:/path/to/cmake/bin&quot;</span><br><span class="line">运行以下命令使更改生效：</span><br><span class="line"></span><br><span class="line">source ~/.bashrc # 或者source ~/.zshrc</span><br><span class="line">注意替换/path/to/cmake/bin为您自己的CMake可执行文件路径。</span><br><span class="line"></span><br><span class="line">再次执行构建YouCompleteMe插件的命令，并添加--verbose参数以获取更详细的错误信息：</span><br><span class="line"></span><br><span class="line">/usr/bin/python3 /home/xiaohuilin/.vim/bundle/YouCompleteMe/third_party/ycmd/build.py --clang-completer --verbose</span><br><span class="line">总之，以上步骤可以帮助您解决在Linux上构建YouCompleteMe插件时遇到的CMake可执行文件未找到问题。</span><br></pre></td></tr></table></figure>

<p><strong>总之问题注意有些插件需要去git仓库</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NoExtraConfDetected:No.ycm_extra_conf.py file detected,so no compile flags are available.Thus no semantic support for c/c++/objcc++.GoREAD THE DOCS *NOW*,DON&#x27;T file a bug report</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这是 YouCompleteMe 编辑器插件在寻找编译器标志文件时的一种提示。YouCompleteMe 是一个为多种编辑器准备的自动补全和语义补充工具，其中包含对 C/C++/Objective-C 等语言的支持，并可以通过指定编译标志来提供更高级别的语法分析和代码补全功能。</span><br><span class="line"></span><br><span class="line">上述错误信息表明 YouCompleteMe 没有找到名为 ycm_extra_conf.py 的配置文件，因而无法获得程序的编译标志等元数据信息，从而无法提供 C/C++/Objective-C 的地道补全、跳转等方面的支持。</span><br><span class="line"></span><br><span class="line">要解决这个问题，你需要按照 YouCompleteMe 的文档说明中所讲述的，在当前项目根目录下建立名为 ycm_extra_conf.py 的文件，并进行适当的配置修改或编写，以便可以向 YouCompleteMe 提供关于项目代码及编译环境的相关信息。如果还有问题，请参考官方文档或联系相关技术支持。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">没有这个就无法判断头文件吗</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">并非如此。即使没有 ycm_extra_conf.py 文件，YouCompleteMe 也能大概率猜测出头文件的位置。不过在这种情况下，YouCompleteMe 无法准确知道要使用哪些编译选项和库依赖关系，这可能会导致代码补全、错误提示等功能出现误报或不生效。</span><br><span class="line"></span><br><span class="line">如果您不想手动编写 ycm_extra_conf.py 文件，也可以尝试通过其它方式来提供项目信息。比如使用 CMake 来生成 Makefile 或者 IDEA 项目文件，并配置好编译选项；或者按照 YouCompleteMe 的文档指导，手动在配置文件中为每个文件类型设置编译器标志和头文件搜索路径等信息。这取决于具体的开发环境和工具链。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">是的，按照 YouCompleteMe 的要求，在当前项目根目录下创建名为 ycm_extra_conf.py 的文件，并根据实际需要进行配置。</span><br><span class="line"></span><br><span class="line">以 C++ 项目为例，可以在 ycm_extra_conf.py 文件中添加如下代码来提供编译器标志。这里假设编译器为 GCC 或 Clang，并且项目包含了多个源码文件和框架库：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line"># 编译器路径（可选）</span><br><span class="line"># 如果没有安装系统默认编译器，则需要手动指定路径</span><br><span class="line"># os.environ[&#x27;CC&#x27;] = &#x27;/usr/bin/clang&#x27;</span><br><span class="line"># os.environ[&#x27;CXX&#x27;] = &#x27;/usr/bin/clang++&#x27;</span><br><span class="line"></span><br><span class="line"># 全局通用编译器标志</span><br><span class="line">flags = [</span><br><span class="line">    &#x27;-Wall&#x27;,</span><br><span class="line">    &#x27;-Wextra&#x27;,</span><br><span class="line">    # 更多需要的标志</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 针对不同文件类型设置不同的编译器标志和头文件搜索路径</span><br><span class="line">def Settings(**kwargs):</span><br><span class="line">  if kwargs[&#x27;language&#x27;] == &#x27;cfamily&#x27;:</span><br><span class="line">    filename = kwargs[&#x27;filename&#x27;]</span><br><span class="line">    ext = os.path.splitext(filename)[1]</span><br><span class="line"></span><br><span class="line">    # 源码文件</span><br><span class="line">    if ext in [&#x27;.c&#x27;, &#x27;.cpp&#x27;, &#x27;.cxx&#x27;]:</span><br><span class="line">        return &#123;</span><br><span class="line">            &#x27;flags&#x27;: flags + [</span><br><span class="line">                &#x27;-std=c++17&#x27;,   # 或其它版本</span><br><span class="line">                # 可针对特定文件设置标志</span><br><span class="line">            ],</span><br><span class="line">            &#x27;include_paths_relative_to_dir&#x27;: &#x27;./&#x27;,</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    # 框架库头文件</span><br><span class="line">    elif ext in [&#x27;.h&#x27;, &#x27;.hpp&#x27;]:</span><br><span class="line">        return &#123;</span><br><span class="line">            &#x27;flags&#x27;: flags,</span><br><span class="line">            &#x27;include_paths_relative_to_dir&#x27;: &#x27;./&#x27;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  return &#123;&#125;</span><br><span class="line">在配置好 ycm_extra_conf.py 文件后，重新加载编辑器插件或重新打开文件即可。YouCompleteMe 将会根据该文件中的设置来提供适当的代码补全和提示等功能。需要注意的是不同插件有可能采用不同的标志格式和语法。上述代码仅为示例，并不代表全部情况。具体语法和参数请参看相应插件的文档。</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/" class="post-title-link" itemprop="url">深入理解计算机系统-第五章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-29 11:40:04" itemprop="dateCreated datePublished" datetime="2023-05-29T11:40:04+08:00">2023-05-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-06 14:36:01" itemprop="dateModified" datetime="2023-07-06T14:36:01+08:00">2023-07-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第五章优化程序性能"><a href="#第五章优化程序性能" class="headerlink" title="第五章优化程序性能"></a>第五章优化程序性能</h1><p>研究程序的汇编代码表示是理解编译器以及产生的代码会如何运行的最有效手段之一。仔细研究内循环的代码是一个很好的开端，识别出降低性能的属性，例如过多的内存引用和对寄存器使用不当。从汇编代码开始，我们还可以预测什么操作会并行执行，以及它们会如何使用处理器资源。正如我们会看到的，常常通过确认关键路径(critical path)来决定执行一个循环所需要的时间(或者说，至少是一个时间下界)。所谓<strong>关键路径</strong>是在循环的反复执行过程中形成的数据相关链。然后，我们会回过头来修改源代码，试着控制编译器使之产生更有效率的实现。</p>
<p>大多数编译器，包括GCC，一直都在更新和改进，特别是在优化能力方面。一个有用的策略是只重写程序到编译器由此就能产生有效代码所需要的程度就好了。这样，能尽量避免损害代码的可读性、模块性和可移植性，就好像我们使用的是具有最低能力的编译器。同样，通过测量值和检查生成的汇编代码，反复修改源代码和分析它的性能是很有帮助的。</p>
<p>对于新手程序员来说，不断修改源代码，试图欺骗编译器产生有效的代码，看起来很奇怪，但这确实是编写很多高性能程序的方式。比较于另一种方法—用汇编语言写代码，这种间接的方法具有的优点是:虽然性能不一定是最好的，但得到的代码仍然能够在其他机器上运行。</p>
<h2 id="优化编译器的能力和局限性"><a href="#优化编译器的能力和局限性" class="headerlink" title="优化编译器的能力和局限性"></a>优化编译器的能力和局限性</h2><p>现代编译器运用复杂精细的算法来确定一个程序中计算的是什么值，以及它们是被如何使用的。然后会利用一些机会来简化表达式，在几个不同的地方使用同一个计算，以及降低一个给定的计算必须被执行的次数。大多数编译器，包括GCC，向用户提供了一些对它们所使用的优化的控制。就像在第3章中讨论过的，最简单的控制就是指定优化级别。例如，以命令行选项“-Og”调用GCC是让GCC使用一组基本的优化。以选项“-O1”或更高(如“-O2”或“-O3”)调用GCC会让它使用更大量的优化。这样做可以进一步提高程序的性能，但是也可能增加程序的规模，也可能使标准的调试工具更难对程序进行调试。我们的表述，虽然对于大多数使用GCC的软件项目来说，优化级别-O2已经成为了被接受的标准，但是还是主要考虑以优化级别-O1编译出的代码。我们特意限制了优化级别，以展示写C语言函数的不同方法如何影响编译器产生代码的效率。我们会发现可以写出的C代码，即使用-O1选项编译得到的性能，也比用可能的最高的优化等级编译一个更原始的版本得到的性能好。</p>
<p>未经优化的代码是从C语言代码到机器代码的直接翻译，通常效率明显较低。简单地使用命令行选项“-O1”，就会进行一些基本的优化。正如可以看到的，程序员不需要做什么，就会显著地提高程序性能–—超过两个数量级。通常，养成至少使用这个级别优化的习惯是很好的。(使用-Og优化级别能得到相似的性能结果。)</p>
<h3 id="用内联函数替换优化函数调用"><a href="#用内联函数替换优化函数调用" class="headerlink" title="用内联函数替换优化函数调用"></a>用内联函数替换优化函数调用</h3><p>包含函数调用的代码可以用一个称为内联函数替换(inline substitution，或者简称“内联(inlining)”)的过程进行优化，此时，将函数调用替换为函数体。</p>
<p>GCC的最近版本会尝试进行这种形式的优化，要么是被用命令行选项“-finline”指示时，要么是使用优化等级-O1或者更高的等级时。遗憾的是，GCC只尝试在单个文件中定义的函数的内联。这就意味着它将无法应用于常见的情况，即一组库函数在一个文件中被定义，却被其他文件内的函数所调用。</p>
<p>在某些情况下，最好能阻止编译器执行内联替换。一种情况是用符号调试器来评估代码，比如GDB。如果一个函数调用已经用内联替换优化过了，那么任何对这个调用进行追踪或设置断点的尝试都会失败。还有一种情况是用代码剖析的方式来评估程序性能。用内联替换消除的函数调用是无法被正确剖析的。</p>
<h2 id="理解现代处理器"><a href="#理解现代处理器" class="headerlink" title="理解现代处理器"></a>理解现代处理器</h2><p>我们会发现两种下界描述了程序的最大性能。当一系列操作必须按照严格顺序执行时，就会遇到<strong>延迟界限</strong>(latencybound)，因为在下一条指令开始之前，这条指令必须结束。当代码中的数据相关限制了处理器利用指令级并行的能力时，延迟界限能够限制程序性能。<strong>吞吐量界限</strong>(throughpubound)刻画了处理器功能单元的原始计算能力。这个界限是程序性能的终极限制。</p>
<h3 id="整体操作"><a href="#整体操作" class="headerlink" title="整体操作"></a>整体操作</h3><p>ICU从指令高速缓存(instruction cache)中读取指令，指令高速缓存是一个特殊的高速存储器，它包含最近访问的指令。通常，ICU会在当前正在执行的指令很早之前取指，这样它才有足够的时间对指令译码，并把操作发送到EU。不过，一个问题是当程序遇到分支时，程序有两个可能的前进方向。一种可能会选择分支，控制被传递到分支目标。另一种可能是，不选择分支，控制被传递到指令序列的下一条指令。现代处理器采用了一种称为<strong>分支预测</strong>(branch prediction)的技术，处理器会猜测是否会选择分支，同时还预测分支的目标地址。使用<strong>投机执行</strong>(speculative execution)的技术，处理器会开始取出位于它预测的分支会跳到的地方的指令，并对指令译码，甚至在它确定分支预测是否正确之前就开始执行这些操作。如果过后确定分支预测错误，会将状态重新设置到分支点的状态，并开始取出和执行另一个方向上的指令。标记为取指控制的块包括分支预测，以完成确定取哪些指令的任务。</p>
<p>使用<strong>投机执行</strong>技术对操作求值，但是最终结果不会存放在程序寄存器或数据内存中，直到处理器能确定应该实际执行这些指令。分支操作被送到EU，不是确定分支该往哪里去，而是确定分支预测是否正确。如果预测错误，EU会丢弃分支点之后计算出来的结果。它还会发信号给分支单元，说预测是错误的，并指出正确的分支目的。在这种情况中，分支单元开始在新的位置取指。这样的预测错误会导致很大的性能开销。在可以取出新指令、译码和发送到执行单元之前，要花费一点时间。</p>
<p>控制操作数在执行单元间传送的最常见的机制称为<strong>寄存器重命名</strong>(register renaming)。当一条更新寄存器r的指令译码时，产生标记t，得到一个指向该操作结果的唯一的标识符。条目(r，t)被加入到一张表中，该表维护着每个程序寄存器r与会更新该寄存器的操作的标记t之间的关联。当随后以寄存器r作为操作数的指令译码时，发送到执行单元的操作会包含t作为操作数源的值。当某个执行单元完成第一个操作时，会生成-一个结果(v，t)，指明标记为t的操作产生值v。所有等待t作为源的操作都能使用v作为源值，这就是一种形式的数据转发。通过这种机制，值可以从一个操作直接转发到另一个操作，而不是写到寄存器文件再读出来，使得第二个操作能够在第一个操作完成后尽快开始。重命名表只包含关于有未进行写操作的寄存器条目。当一条被译码的指令需要寄存器r，而又没有标记与这个寄存器相关联，那么可以直接从寄存器文件中获取这个操作数。<strong>有了寄存器重命名，即使只有在处理器确定了分支结果之后才能更新寄存器，也可以预测着执行操作的整个序列。</strong></p>
<p>最小化一个计算中的操作数量不一定会提高它的性能。</p>
<p>CPE即是需要的时钟周期。</p>
<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230610161658961.png" alt="image-20230610161658961"></p>
<img src="/2023/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230610161658961.png" class title="This is an test image">

<p>延迟界限给出了任何必须按照严格顺序完成合并运算的函数所需要的最小CPE值。根据功能单元产生结果的最大速率，吞吐量界限给出了CPE的最小界限。例如，因为只有一个整数乘法器，它的发射时间为1个时钟周期，处理器不可能支持每个时钟周期大于1条乘法的速度。另-一方面，四个功能单元都可以执行整数加法，处理器就有可能持续每个周期执行4个操作的速率。不幸的是，因为需要从内存读数据，这造成了另一个吞吐量界限。两个加载单元限制了处理器每个时钟周期最多只能读取两个数据值，从而使得吞吐量界限为0.50。</p>
<h2 id="让编译器展开循环"><a href="#让编译器展开循环" class="headerlink" title="让编译器展开循环"></a>让编译器展开循环</h2><p>编译器可以很容易地执行循环展开。只要优化级别设置得足够高，许多编译器都能例行公事地做到这一点。用优化等级3或更高等级调用GCC，它就会执行循环展开。</p>
<p>循环展开，英文中称Loop unwinding或loop unrolling，是一种牺牲程序的尺寸来加快程序的执行速度的优化方法。可以由程序员完成，也可由编译器自动优化完成。循环展开最常用来降低循环开销，为具有多个功能单元的处理器提供指令级并行。也有利于指令流水线的调度。</p>
<h3 id="循环展开对程序性能的影响"><a href="#循环展开对程序性能的影响" class="headerlink" title="循环展开对程序性能的影响"></a>循环展开对程序性能的影响</h3><p>我们直接以实际代码向大家展示循环展开的作用，首先看未经过循环展开优化的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    auto start = std::chrono::system_clock::now();</span><br><span class="line">    int sum = 0;</span><br><span class="line">    int count = 10000;</span><br><span class="line">    //循环10000次累加</span><br><span class="line">    for(int i = 0;i &lt; count;i++)&#123;  </span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    auto end = std::chrono::system_clock::now();</span><br><span class="line">    std::chrono::duration&lt;double&gt; dura = end - start;</span><br><span class="line">    std::cout &lt;&lt;&quot;共耗时：&quot;&lt;&lt; dura.count() &lt;&lt; &quot;s&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们将循环展开一次，即把上述代码中的循环改为如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; count;i += <span class="number">2</span>)&#123;</span><br><span class="line">    sum += i;</span><br><span class="line">    sum += i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即每次循环将i和i+1一起累加到sum变量上，这样可以把循环次数从10000次降低到5000次，由于CPU的高度流水线化，连续两个加法指令增加耗时很低，所以此版本代码可以一定程度上提高程序运行速度</p>
<p>代码运行耗时0.0000159秒，相较于未优化代码速度快了将近一倍。</p>
<p>当然，我们可以继续增加循环展开次数以进一步提高程序运行速度，但是这个增加循环展开次数也是有限度的，<em>当达到了CPU的最高吞吐量之后，继续增加循环展开次数是没有意义的</em>。</p>
<p>上述循环展开后的代码依然有进一步优化的空间，那就是消除连续指令的相关性，以达到指令级并行，我们可以看到循环展开后的代码，循环体中有两条语句：sum +&#x3D; i 和 sum +&#x3D; i+1，第二条语句sum +&#x3D; i+1依赖于第一条命来sum +&#x3D; i的执行结果，所以这两条语句只能依次执行，限制了CPU进一步提高性能的可能。如果我们将循环体改为如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum1=<span class="number">0</span>,sum2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; count;i+=<span class="number">2</span>)&#123;</span><br><span class="line">    sum1 += i;</span><br><span class="line">    sum2 += i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">sum = sum1 + sum2;</span><br></pre></td></tr></table></figure>

<p>我们新建了两个变量sum1和sum2用于存储循环展开时两个累加语句的累加结果，最后在循环体外将两部分结果相加得到最终结果。该代码中两个累加语句之间是互不相关的，所以CPU可以并行执行这两条指令，以达到性能的进一步提高。相较于只进行循环展开的代码速度又快了将近一倍。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由上面三段代码的运行速度对比可以看出，循环展开对程序性能有着很重要的影响，可以减少分支预测错误次数，增加取消数据相关进一步利用并行执行提高速度的机会。但是，<strong>并不建议大家进行手动的循环展开</strong>，在代码中进行循环展开会导致程序的可读性下降，代码膨胀。为了直观感受循环展开对性能的影响，上述代码运行结果均是在不开编译器优化的情况下进行的测试，其实在我们<strong>开启了编译器优化</strong>的时候，编译器会自动对我们的循环代码进行循环展开，让我们可以在保持了代码可读性的同时，又能享受到循环展开对我们程序性能的提高。</p>
<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230613165045230.png" alt="image-20230613165045230"></p>
<img src="/2023/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230613165045230.png" class title="This is an test image">

<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230613165134725.png" alt="image-20230613165134725"></p>
<img src="/2023/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230613165134725.png" class title="This is an test image">



<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230613165149509.png" alt="image-20230613165149509"></p>
<img src="/2023/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230613165149509.png" class title="This is an test image">



<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230613165207581.png" alt="image-20230613165207581"></p>
<img src="/2023/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230613165207581.png" class title="This is an test image">

<h2 id="SIMD-用向量指令达到更高的并行度"><a href="#SIMD-用向量指令达到更高的并行度" class="headerlink" title="SIMD:用向量指令达到更高的并行度"></a>SIMD:用向量指令达到更高的并行度</h2><p><em>Single Instruction Multiple Data</em>，单指令多数据流，可以使用一条指令同时完成多个数据的运算操作。传统的指令架构是SISD就是单指令单数据流，每条指令只能对一个数据执行操作。</p>
<p>单纯使用SIMD指令并没有什么技术含量，一般程序员也不太会使用 Intrinsics 函数来优化 SIMD，基本上都是靠编译器帮我们进行自动矢量化。想要代码能尽量的自动矢量化，以下几点需要多注意：</p>
<ul>
<li>避免使用全局指针和全局变量以帮助编译器生成 SIMD 代码。</li>
<li>合理安排循环的嵌套，以便最内层的嵌套没有迭代间的依赖关系。尤其要避免在较早的迭代中存储数据，而在往后的迭代中加载该数据。</li>
<li>避免在循环内使用条件分支。</li>
<li>保持循环变量表达式简单。</li>
</ul>
<p>现代编译器已经能为我们自动做很多优化工作，不过这不代表我们学习手写SIMD代码就没有意义了。在向量、矩阵运算等基础库函数中，每个函数通常代码量不大，复杂度不高，但编译器并不能保证会给你优化好，手撸SIMD还是很有必要的。更重要的是，我们能在学习的过程中去接触更底层的一些东西（指令集，内存架构，汇编等），进而提升对整体的编程实力。</p>
<h2 id="一些限制因素"><a href="#一些限制因素" class="headerlink" title="一些限制因素"></a>一些限制因素</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (i = 0; i &lt; n; i++)&#123;</span><br><span class="line">    if (a[i] &gt; b[i]) &#123;</span><br><span class="line">    	long t = a[i];a[i] = b[i];b[i] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在随机数据上测试这个函数，得到的CPE大约为13.50，而对于可预测的数据，CPE为2.5～3.5，其预测错误惩罚约为20个周期。</p>
<p>用功能式的风格实现这个函数是计算每个位置i的最大值和最小值，然后将这些值分别赋给a[i]和 b[i]:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (i = 0; i &lt; n; i++)&#123;</span><br><span class="line">    long min = a[i] &lt; b[i] ? a[i] : b[i];</span><br><span class="line">    long max = a[i] &lt;b[i] ? b[i] : a[i];</span><br><span class="line">    a[i] = min;</span><br><span class="line">    b[i] = max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对这个函数的测试表明无论数据是任意的，还是可预测的，CPE都大约为4.0。(我们还检查了产生的汇编代码，确认它确实使用了条件传送。)</p>
<p>讨论过，不是所有的条件行为都能用条件数据传送来实现，所以无可避免地在某些情况中，程序员不能避免写出会导致条件分支的代码，而对于这些条件分支，处理器用分支预测可能会处理得很糟糕。但是，正如我们讲过的，程序员方面用一点点聪明，有时就能使代码更容易被翻译成条件数据传送。这需要一些试验，写出函数的不同版本，然后检查产生的汇编代码，并测试性能。</p>
<p>分支预测只对有规律的模式可行。程序中的许多测试是完全不可预测的，依赖于数据的任意特性，例如一个数是负数还是正数。对于这些测试，分支预测逻辑会处理得很糟糕。对于本质上无法预测的情况，如果编译器能够产生使用条件数据传送而不是使用条件控制转移的代码，可以极大地提高程序的性能。这不是C语言程序员可以直接控制的，但是有些表达条件行为的方法能够更直接地被翻译成条件传送，而不是其他操作。</p>
<h2 id="理解内存性能"><a href="#理解内存性能" class="headerlink" title="理解内存性能"></a>理解内存性能</h2><p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230705114807883.png" alt="image-20230705114807883"></p>
<img src="/2023/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230705114807883.png" class title="This is an test image">

<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230705114829177.png" alt="image-20230705114829177"></p>
<img src="/2023/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230705114829177.png" class title="This is an test image">

<p>原代码</p>
<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230705114934148.png" alt="image-20230705114934148"></p>
<p>后者vmovss有内存读取，即有了写读相关，导致数据相关。每次需要pi就得先写再读取，导致CPE高，如果是上面就没有。</p>
<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230705115802949.png" alt="image-20230705115802949"></p>
<img src="/2023/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230705115802949.png" class title="This is an test image">

<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230705115942271.png" alt="image-20230705115942271"></p>
<img src="/2023/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230705115942271.png" class title="This is an test image">

<h2 id="确认和消除性能瓶颈"><a href="#确认和消除性能瓶颈" class="headerlink" title="确认和消除性能瓶颈"></a>确认和消除性能瓶颈</h2><p>至此，我们只考虑了优化小的程序，在这样的小程序中有一些很明显限制性能的地方，因此应该是集中注意力对它们进行优化。在处理大程序时，连知道应该优化什么地方都是很难的。本节会描述如何使用代码剖析程序(code profiler)，这是在程序执行时收集性能数据的分析工具。我们还展示了一个系统优化的通用原则，称为Amdahl定律。</p>
<h3 id="程序剖析"><a href="#程序剖析" class="headerlink" title="程序剖析"></a>程序剖析</h3><p>程序剖析(profiling)运行程序的一个版本，其中插人了工具代码，以确定程序的各个部分需要多少时间。这对于确认程序中我们需要集中注意力优化的部分是很有用的。剖析的一个有力之处在于可以在现实的基准数据(benchmark data)上运行实际程序的同时，进行剖析。</p>
<p>Unix系统提供了一个剖析程序GPROF。这个程序产生两种形式的信息。首先，它确定程序中每个函数花费了多少CPU时间。其次，它计算每个函数被调用的次数，以执行调用的函数来分类。这两种形式的信息都非常有用。这些计时给出了不同函数在确定整体运行时间中的相对重要性。调用信息使得我们能理解程序的动态行为。</p>
<p>用GPROF进行剖析需要3个步骤，就像C程序prog.c所示，它运行时命令行参数为file.txt:</p>
<p>1）程序必须为剖析而编译和链接。使用GCC(以及其他C编译器)，就是在命令行上简单地包括运行时标志“-pg”。确保编译器不通过内联替换来尝试执行任何优化是很重要的，否则就可能无法正确刻画函数调用。我们使用优化标志-Og，以保证能正确跟踪函数调用<br><code>linux&gt; gcc -Og -pg prog.c -o prog</code></p>
<p>2）然后程序像往常一样执行:</p>
<p><code>linux&gt; ./prog file.txt</code><br>它运行得会比正常时稍微慢一点(大约慢2倍)，不过除此之外唯一的区别就是它产生了一个文件 gmon.out。<br>3）调用GPROF来分析gmon. out中的数据。</p>
<p><code>linux&gt; gprof prog</code></p>
<p>剖析报告的第一部分列出了执行各个函数花费的时间，按照降序排列。作为一个示例，下面列出了报告的一部分，是关于程序中最耗费时间的三个函数的:</p>
<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230706112821635.png" alt="image-20230706112821635"></p>
<img src="/2023/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230706112821635.png" class title="This is an test image">

<p>每一行代表对某个函数的所有调用所花费的时间。第一列表明花费在这个函数上的时间占整个时间的百分比。第二列显示的是直到这一行并包括这一行的函数所花费的累计时间。第三列显示的是花费在这个函数上的时间，而第四列显示的是它被调用的次数(递归调用不计算在内)。在例子中，函数sort_words只被调用了一次，但就是这一次调用需要203.66秒，而函数find ele_rec被调用了965 027次(递归调用不计算在内)，总共需要4.85秒。函数 strlen通过调用库函数strlen来计算字符串的长度。GPROF的结果中通常不显示库函数调用。库函数耗费的时间通常计算在调用它们的函数内。通过创建这个“包装函数( wrapper function)”strlen，我们可以可靠地跟踪对strlen的调用，表明它被调用了12511 031次，但是一共只需要0.30秒。</p>
<p>剖析报告的第二部分是函数的调用历史。下面是一个递归函数find ele rec的历史:</p>
<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230706113048681.png" alt="image-20230706113048681"></p>
<img src="/2023/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230706113048681.png" class title="This is an test image">

<p>这个历史既显示了调用find_ele_rec的函数，也显示了它调用的函数。头两行显示的是对这个函数的调用:被它自身递归地调用了158655725次，被函数insert_string调用了965 027次(它本身被调用了965027次)。函数find_ele_rec也调用了另外两个函数save_string和 new_ele，每个函数总共被调用了363039次。<br>根据这个调用信息，我们通常可以推断出关于程序行为的有用信息。例如，函数find_ele_rec是一个递归过程，它扫描一个哈希桶(hash bucket)的链表，查找一个特殊的字符串。对于这个函数，比较递归调用的数量和顶层调用的数量，提供了关于遍历这些链表的长度的统计信息。这里递归与顶层调用的比率是164.4，我们可以推断出程序每次平均大约扫描164个元素。</p>
<h2 id="使用剖析程序来指导优化"><a href="#使用剖析程序来指导优化" class="headerlink" title="使用剖析程序来指导优化"></a>使用剖析程序来指导优化</h2><p>迭代和递归是两种常见的函数调用方式，它们在实现方式和执行过程上有一些区别。</p>
<p>迭代（Iteration）是通过循环结构来重复执行一段代码，达到需要的结果。迭代通常使用循环变量作为计数器或条件判断，每次循环都更新循环变量，并基于该变量进行操作。迭代函数通常使用较少的系统资源，对于处理大规模数据集和性能要求较高的场景，迭代通常是更有效的选择。</p>
<p>递归（Recursion）是一种函数自身调用自身的方法。递归函数包含两部分：基准情况（Base Case）和递归调用（Recursive Call）。基准情况定义了递归结束的条件，当满足基准情况时，递归停止并开始回溯。递归调用是函数在自身调用期间的执行过程，每次递归调用会解决一个更小或更简单的子问题。递归函数通常比较简洁，但可能会占用较多的系统资源，并且在处理大规模数据集时可能导致堆栈溢出的问题。</p>
<p>总结区别：</p>
<ul>
<li>迭代是通过循环来完成重复执行，而递归是函数自身调用自身的方式。</li>
<li>迭代函数使用循环变量进行迭代和操作，而递归函数通过不断调用自身来解决子问题。</li>
<li>迭代通常使用较少的系统资源，适用于处理大规模数据集和性能要求较高的场景；递归通常较简洁但可能会占用较多系统资源，并且在处理大规模数据时有堆栈溢出的风险。</li>
</ul>
<p>在选择使用迭代还是递归时，需要考虑问题的特点、性能需求、代码可读性等因素。有些问题更适合使用迭代，而有些问题则可以利用递归的特性更好地表达和解决。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">肖汇林</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">肖汇林</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
