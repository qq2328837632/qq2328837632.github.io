<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="选择有时候比努力更重要">
<meta property="og:type" content="website">
<meta property="og:title" content="肖汇林的博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="肖汇林的博客">
<meta property="og:description" content="选择有时候比努力更重要">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="肖汇林">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>肖汇林的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖汇林的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/18/Linux-%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/18/Linux-%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">Linux-线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-18 11:40:33 / 修改时间：21:43:04" itemprop="dateCreated datePublished" datetime="2023-06-18T11:40:33+08:00">2023-06-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h2><p>线程概念：<br>进程：有独立的 进程地址空间。有独立的 pcb。 分配资源的最小单位。<br>线程：有独立的 pcb。没有独立的进程地址空间。 最小单位的执行。<br>ps -Lf 进程 id —&gt; 线程号。LWP –》cpu 执行的最小单位（线程）。</p>
<p>ps -Lf 进程号 查看进程的线程</p>
<p><img src="/Linux-%E7%BA%BF%E7%A8%8B/image-20230617155342436.png" alt="image-20230617155342436"></p>
<img src="/2023/06/18/Linux-%E7%BA%BF%E7%A8%8B/image-20230617155342436.png" class title="This is an test image">

<p>一个进程的线程越多，争取cpu的概率越大，但是会有峰值，然后降低</p>
<h2 id="三级映射"><a href="#三级映射" class="headerlink" title="三级映射"></a>三级映射</h2><h3 id="Linux内核线程实现原理"><a href="#Linux内核线程实现原理" class="headerlink" title="Linux内核线程实现原理"></a>Linux内核线程实现原理</h3><p>类Unix系统中，早期是没有“线程”概念的，80年代才引入，借助进程机制实现出了线程的概念。因此在这类系统中，进程和线程关系密切。</p>
<p>1.轻量级进程(light-weight process)，也有 PCB，创建线程使用的底层函数和进程一样，都是clone</p>
<p>2.从内核里看进程和线程是一样的，都有各自不同的PCB，但是PCB 中指向内存资源的三级页表是相同的</p>
<p>3.进程可以蜕变成线程。</p>
<p>4.线程可看做寄存器和栈的集合（寄存器在cpu上用来计算，栈帧开辟在栈上，目的是执行函数和存放局部变量，临时值和形参）</p>
<p>5.在 linux 下，线程是最小的执行单位;进程是最小的分配资源单位。</p>
<p>查看Lwp号:<code>ps -lf pid</code>查看指定线程的 lwp号。</p>
<h3 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB."></a>进程控制块PCB.</h3><p>我们知道,每个进程在内核中都有一个进程控制块(PCB)来维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。</p>
<p><code>/usr/src/linux-headers-3.16.0-30/include/linux/sched.h</code>.文件中可以查看struct task_struct结构体定义。其内部成员有很多，我们重点掌握以下部分即可:</p>
<ul>
<li>进程id。系统中每个进程有唯一的id，在c语言中用pid_t类型表示，其实就是一个非负整数。</li>
<li>进程的状态，有就绪、运行、挂起、停止等状态。</li>
<li>进程切换时需要保存和恢复的一些cPu寄存器。</li>
<li>描述虚拟地址空间的信息</li>
<li>描述控制终端的信息。</li>
<li>当前工作目录(Current Working Directory)。</li>
<li>umask掩码。</li>
<li>文件描述符表，包含很多指向file结构体的指针。</li>
<li>和信号相关的信息。</li>
<li>用户id和组id。</li>
<li>会话(Session）和进程组。</li>
<li>进程可以使用的资源上限（Resource Limit) 。</li>
</ul>
<p><img src="/Linux-%E7%BA%BF%E7%A8%8B/image-20230617160559643.png" alt="image-20230617160559643"></p>
<img src="/2023/06/18/Linux-%E7%BA%BF%E7%A8%8B/image-20230617160559643.png" class title="This is an test image">

<p>如果是fork则另外一个进程，指向的就不一样。我们之前讲没有pcb，其实映射是需要经过pcb的。</p>
<h2 id="线程共享和非共享"><a href="#线程共享和非共享" class="headerlink" title="线程共享和非共享"></a>线程共享和非共享</h2><p>线程共享资源</p>
<ul>
<li>1.文件描述符表</li>
<li>2.每种信号的处理方式</li>
<li>3.当前工作目录</li>
<li>4.用户ID和组ID</li>
<li>5.内存地址空间(.text&#x2F;.data&#x2F;.bss&#x2F;heap&#x2F;共享库)，就是没有<strong>栈</strong>（栈执行函数和存放局部变量，临时值和形参）</li>
</ul>
<p>线程非共享资源</p>
<ul>
<li>1.线程id</li>
<li>2.处理器现场（寄存器计算的数据在处理器保存）和<strong>栈</strong>指针(内核栈)</li>
<li>3.独立的栈空间(用户空间栈)</li>
<li>4.errno变量</li>
<li>5.信号屏蔽字</li>
<li>6.调度优先级</li>
</ul>
<p>线程优、缺点：<br>优点:1.提高程序并发性	2.开销小 	3.数据通信、共享数据方便。（可以共享全局变量，不像父子进程，读时共享、写时复制）<br>缺点:1.库函数，不稳定	2.调试、编写困难、gdb不支持	3.对信号支持不好。</p>
<p>优点相对突出，缺点均不是硬伤。Linux下由于实现方法导致进程、线程差别不是很大。一般能使用线程就使用线程。</p>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pthread_t *tid是传出参数</span><br><span class="line">C++ 中的参数，既可以当做传入参数，也可以当做传出参数，具体要看参数的数据类型。</span><br><span class="line"></span><br><span class="line">非指针，非引用类型：一定是当做传入参数；</span><br><span class="line">指针，引用类型：既可以当做传入参数；也可以当做传出参数；甚至可以同时是传入参数，也是传出参数。</span><br><span class="line">其次要看对参数进行的操作：</span><br><span class="line"></span><br><span class="line">如果是只有读取，没有修改的，那就是传入参数，这时可以加上 const 限定符，以防不小心修改了参数。</span><br><span class="line">如果只有对参数进行写入，没有读取的，那就是当做传出参数的。</span><br><span class="line">如果对参数先进行了读取操作，然后又进行了写入操作，那么就是既当传入参数也当传出参数了。</span><br></pre></td></tr></table></figure>

<p><code>pthread_t pthread_self(void)</code>; 获取线程 id。 线程 id 是在进程地址空间内部，用来标识线程身<br>份的 id 号。<br>    返回值：本线程 id<br>检查出错返回： 线程中。<br>    fprintf(stderr, “xxx error: %s\n”, strerror(ret));<br><code>int pthread_create(pthread_t *tid, const pthread_attr_t *attr, void *(*start_rountn)(void *), void *arg);</code> 创建子线程。<br>    参 1：传出参数，表新创建的子线程 id<br>    参 2：线程属性。传 NULL 表使用默认属性。<br>    参 3：子线程回调函数。创建成功，ptherad_create 函数返回时，该函数会被自动调用。<br>    参 4：参 3 的参数。没有的话，传 NULL<br>    返回值：成功：0<br>        失败：errno</p>
<p>下面这个例子，创建一个子线程去执行其他任务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;errno.h&gt;</span><br><span class="line">6. #include &lt;pthread.h&gt;</span><br><span class="line">7.</span><br><span class="line">8. void sys_err(const char *str)&#123;</span><br><span class="line">9. perror(str);</span><br><span class="line">10. exit(1);</span><br><span class="line">11. &#125;</span><br><span class="line">12.</span><br><span class="line">13. void *tfn(void *arg)&#123;</span><br><span class="line">14. printf(&quot;thread: pid = %d, tid = %lu\n&quot;, getpid(), pthread_self());</span><br><span class="line">15.</span><br><span class="line">16. return NULL;</span><br><span class="line">17. &#125;</span><br><span class="line">18.</span><br><span class="line">19. int main(int argc, char *argv[])&#123;</span><br><span class="line">20. pthread_t tid;</span><br><span class="line">21.</span><br><span class="line">22. printf(&quot;main: pid = %d, tid = %lu\n&quot;, getpid(), pthread_self());</span><br><span class="line">23.</span><br><span class="line">24. int ret = pthread_create(&amp;tid, NULL, tfn, NULL);</span><br><span class="line">25. if (ret != 0) &#123;</span><br><span class="line">26. perror(&quot;pthread_create error&quot;);</span><br><span class="line">27. &#125;</span><br><span class="line">28.</span><br><span class="line">29. return 0;</span><br><span class="line">30. &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，子线程的打印信息并未出现。原因在于，主线程执行完之后，就销毁了整个进程的地址空间，于是子线程就无法打印。简单粗暴的方法就是让主线程睡 1 秒，等子线程执行。</p>
<h2 id="循环创建多个子线程"><a href="#循环创建多个子线程" class="headerlink" title="循环创建多个子线程"></a>循环创建多个子线程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;errno.h&gt;</span><br><span class="line">6. #include &lt;pthread.h&gt;</span><br><span class="line">7.</span><br><span class="line">8. void sys_err(const char *str)&#123;</span><br><span class="line">9. perror(str);</span><br><span class="line">10. exit(1);</span><br><span class="line">11. &#125;</span><br><span class="line">12.</span><br><span class="line">13. void *tfn(void *arg)&#123;</span><br><span class="line">14. int i = (int)arg;//int i = *((int *)arg)和(void *)&amp;i，子线程如果用地址传递 i，会去读取主线程里的 i 值，而主线程里的 i 是动态变化的，不固定。所以，应该采用值传递，不用指针传递。</span><br><span class="line"></span><br><span class="line">15. sleep(i);</span><br><span class="line">16. printf(&quot;--I&#x27;m %dth thread: pid = %d, tid = %lu\n&quot;,i+1, getpid(), pthread_self());</span><br><span class="line">17.</span><br><span class="line">18. return NULL;</span><br><span class="line">19. &#125;</span><br><span class="line">20.</span><br><span class="line">21. int main(int argc, char *argv[])&#123;</span><br><span class="line">22. int i;</span><br><span class="line">23. int ret;</span><br><span class="line">24. pthread_t tid;</span><br><span class="line">25.</span><br><span class="line">26. for(i=0;i&lt;5;i++)&#123;</span><br><span class="line">27. ret = pthread_create(&amp;tid, NULL, tfn, (void *)i);//(void *)&amp;i</span><br><span class="line">28. if (ret != 0) &#123;</span><br><span class="line">29. sys_err(&quot;pthread_create error&quot;);</span><br><span class="line">30. &#125;</span><br><span class="line">31. &#125;</span><br><span class="line">32. sleep(i);</span><br><span class="line">33. printf(&quot;I&#x27;m main, pid = %d, tid = %lu\n&quot;, getpid(), pthread_self());</span><br><span class="line">34.</span><br><span class="line">35. return 0;</span><br><span class="line">36. &#125;</span><br></pre></td></tr></table></figure>

<h2 id="pthread-exit-退出"><a href="#pthread-exit-退出" class="headerlink" title="pthread_exit 退出"></a>pthread_exit 退出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">void pthread_exit(void *retval); 退出当前线程。</span><br><span class="line">    retval：退出值。 无退出值时，NULL</span><br><span class="line">    exit(); 退出当前进程。</span><br><span class="line">    return: 返回到调用者那里去。</span><br><span class="line">    pthread_exit(): 退出当前线程。</span><br><span class="line">如果在回调函数里加一段代码：</span><br><span class="line">if(i == 2)</span><br><span class="line">	exit(0);</span><br><span class="line">看起来好像是退出了第三个子线程，然而运行时，发现后续的 4,5 也没了。这是因为，exit 是退</span><br><span class="line">出进程。</span><br><span class="line">一、修改一下，换成：</span><br><span class="line">if(i == 2)</span><br><span class="line">	return NULL;</span><br><span class="line">这样运行一下，发现后续线程不会凉凉，说明 return 是可以达到退出线程的目的。然而真正意义上，return 是返回到函数调用者那里去，线程并没有退出。</span><br><span class="line">二、再修改一下，再定义一个函数 func，直接返回那种</span><br><span class="line">void *func(void)&#123;</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line">if(i == 2)</span><br><span class="line">	func();</span><br><span class="line">运行，发现 1,2,3,4,5 线程都还在，说明没有达到退出目的。</span><br><span class="line">三、再次修改：</span><br><span class="line">void *func(void)&#123;</span><br><span class="line">	pthread_exit(NULL);</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line">if(i == 2)</span><br><span class="line">	func();</span><br><span class="line">编译运行，发现 3 没了，看起来很科学的样子。pthread_exit 表示将当前线程退出。放在函数里，还</span><br><span class="line">是直接调用，都可以。</span><br><span class="line">回到之前说的一个问题，由于主线程可能先于子线程结束，所以子线程的输出可能不会打印出来，当时是用主线程 sleep 等待子线程结束来解决的。现在就可以使用 pthread_exit 来解决了。方法就是将 return 0 替换为 pthread_exit，只退出当先线程，不会对其他线程造成影响。</span><br><span class="line">void pthread_exit(void *retval); 退出当前线程。</span><br><span class="line">    retval：退出值。 无退出值时，NULL</span><br><span class="line">    exit(); 退出当前进程。</span><br><span class="line">    return: 返回到调用者那里去。</span><br><span class="line">    pthread_exit(): 退出当前线程。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join"></a>pthread_join</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int pthread_join(pthread_t thread, void **retval); 阻塞 回收线程。</span><br><span class="line">	thread: 待回收的线程 id</span><br><span class="line">	retval：传出参数。 回收的那个线程的退出值。return</span><br><span class="line">线程异常解除，值为 -1。成功被 pthread_cancel() 杀死的线程，返回 -1.使用 pthead_join 回收。</span><br><span class="line">	返回值：成功：0</span><br><span class="line">	失败：errno</span><br></pre></td></tr></table></figure>

<p>下面这个是回收线程并获取子线程返回值的小例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;errno.h&gt;</span><br><span class="line">6. #include &lt;pthread.h&gt;</span><br><span class="line">7.</span><br><span class="line">8. struct thrd &#123;</span><br><span class="line">9. int var;</span><br><span class="line">10. char str[256];</span><br><span class="line">11. &#125;;</span><br><span class="line">12.</span><br><span class="line">13. void sys_err(const char *str)</span><br><span class="line">14. &#123;</span><br><span class="line">15. perror(str);</span><br><span class="line">16. exit(1);</span><br><span class="line">17. &#125;</span><br><span class="line">18.</span><br><span class="line">19. void *tfn(void *arg)</span><br><span class="line">20. &#123;</span><br><span class="line">21. struct thrd *tval;</span><br><span class="line">22.</span><br><span class="line">23. tval = malloc(sizeof(tval));</span><br><span class="line">24. tval-&gt;var = 100;</span><br><span class="line">25. strcpy(tval-&gt;str, &quot;hello thread&quot;);</span><br><span class="line">26.</span><br><span class="line">27. return (void *)tval;</span><br><span class="line">28. &#125;</span><br><span class="line">29.</span><br><span class="line">30. int main(int argc, char *argv[])</span><br><span class="line">31. &#123;</span><br><span class="line">32. pthread_t tid;</span><br><span class="line">33.</span><br><span class="line">34. struct thrd *retval;</span><br><span class="line">35.</span><br><span class="line">36. int ret = pthread_create(&amp;tid, NULL, tfn, NULL);</span><br><span class="line">37. if (ret != 0)</span><br><span class="line">38. sys_err(&quot;pthread_create error&quot;);</span><br><span class="line">39.</span><br><span class="line">40. //int pthread_join(pthread_t thread, void **retval);//void **retval同样是传出参数</span><br><span class="line">41. ret = pthread_join(tid, (void **)&amp;retval);</span><br><span class="line">42. if (ret != 0)</span><br><span class="line">43. sys_err(&quot;pthread_join error&quot;);</span><br><span class="line">44.</span><br><span class="line">45. printf(&quot;child thread exit with var= %d, str= %s\n&quot;, retval-&gt;var, retval-&gt;str);</span><br><span class="line">46.</span><br><span class="line">47. pthread_exit(NULL);</span><br><span class="line">48.</span><br><span class="line">49. &#125;</span><br></pre></td></tr></table></figure>

<p>还可以改为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void *tfn(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    struct thrd *tval = (struct thrd *)arg;</span><br><span class="line">    tval-&gt;var = 100;</span><br><span class="line">    strcpy(tval-&gt;str,&quot;hello thread&quot;);</span><br><span class="line">    return (void *)tvai;//返回的是arg地址所以可以用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc,char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    pthread_t tid;</span><br><span class="line">    struct thrd arg;</span><br><span class="line">    struct thrd *retval;</span><br><span class="line">    int ret = pthread_create(&amp;tid，NULL, tfn，(void *)&amp;arg);</span><br><span class="line">    if (ret != 0)</span><br><span class="line">        sys_err( &quot;pthread_create error&quot;);</span><br><span class="line">    //int pthread_join(pthread_t thread, void **retval);</span><br><span class="line">    ret = pthread_join(tid,(void **)&amp;retval);</span><br><span class="line">    if (ret != 0)</span><br><span class="line">        sys_err( &quot;pthread_join error&quot;);</span><br><span class="line">    printf( &quot; child thread exit with var= %d，str= %s\n&quot;,retval-&gt;var,retval-&gt;str);</span><br><span class="line">    pthread exit(NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="pthread-cancel-函数"><a href="#pthread-cancel-函数" class="headerlink" title="pthread_cancel 函数"></a>pthread_cancel 函数</h2><p><code>int pthread_cancel(pthread_t thread);</code> 杀死一个线程。 需要到达取消点（保存点）<br>    thread: 待杀死的线程 id<br>    返回值：成功：0<br>    失败：errno<br>如果，子线程没有到达取消点， 那么 pthread_cancel 无效。<br>我们可以在程序中，手动添加一个取消点。使用 pthread_testcancel();<br>成功被 pthread_cancel() 杀死的线程，返回 -1.使用 pthead_join 回收。</p>
<p>小例子，主线程调用 pthread_cancel 杀死子线程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;errno.h&gt;</span><br><span class="line">6. #include &lt;pthread.h&gt;</span><br><span class="line">7.</span><br><span class="line">8.</span><br><span class="line">9. void *tfn(void *arg)&#123;</span><br><span class="line">10. while (1) &#123;</span><br><span class="line">11. printf(&quot;thread: pid = %d, tid = %lu\n&quot;, getpid(), pthread_self());</span><br><span class="line">12. sleep(1);</span><br><span class="line">13. &#125;</span><br><span class="line">14.</span><br><span class="line">15. return NULL;</span><br><span class="line">16. &#125;</span><br><span class="line">17.</span><br><span class="line">18. int main(int argc, char *argv[])&#123;</span><br><span class="line">19. pthread_t tid;</span><br><span class="line">20.</span><br><span class="line">21. int ret = pthread_create(&amp;tid, NULL, tfn, NULL);</span><br><span class="line">22. if (ret != 0) &#123;</span><br><span class="line">23. fprintf(stderr, &quot;pthread_create error:%s\n&quot;, strerror(ret));</span><br><span class="line">24. exit(1);</span><br><span class="line">25. &#125;</span><br><span class="line">26.</span><br><span class="line">27. printf(&quot;main: pid = %d, tid = %lu\n&quot;, getpid(), pthread_self());</span><br><span class="line">28.</span><br><span class="line">29. sleep(5);</span><br><span class="line">30.</span><br><span class="line">31. ret = pthread_cancel(tid); // 终止线程</span><br><span class="line">32. if (ret != 0) &#123;</span><br><span class="line">33. fprintf(stderr, &quot;pthread_cancel error:%s\n&quot;, strerror(ret));</span><br><span class="line">34. exit(1);</span><br><span class="line">35. &#125;</span><br><span class="line">36.</span><br><span class="line">37. while (1);</span><br><span class="line">38.</span><br><span class="line">39. pthread_exit((void *)0);</span><br><span class="line">40. &#125;</span><br></pre></td></tr></table></figure>

<p>这里要注意一点，pthread_cancel 工作的必要条件是进入内核，如果 tfn 真的奇葩到没有进入内核， 则 pthread_cancel 不能杀死线程，此时需要手动设置取消点，就是 pthread_testcancel()</p>
<h2 id="检查出错返回"><a href="#检查出错返回" class="headerlink" title="检查出错返回"></a>检查出错返回</h2><p>int pthread_detach(pthread_t thread); 设置线程分离<br>    thread: 待分离的线程 id<br>    返回值：成功：0<br>    失败：errno</p>
<p>下面这个例子，使用 detach 分离线程，照理来说，分离后的线程会自动回收：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;errno.h&gt;</span><br><span class="line">6. #include &lt;pthread.h&gt;</span><br><span class="line">7.</span><br><span class="line">8.</span><br><span class="line">9. void *tfn(void *arg)</span><br><span class="line">10. &#123;</span><br><span class="line">11. printf(&quot;thread: pid = %d, tid = %lu\n&quot;, getpid(), pthread_self());</span><br><span class="line">12.</span><br><span class="line">13. return NULL;</span><br><span class="line">14. &#125;</span><br><span class="line">15.</span><br><span class="line">16. int main(int argc, char *argv[])</span><br><span class="line">17. &#123;</span><br><span class="line">18. pthread_t tid;</span><br><span class="line">19.</span><br><span class="line">20. int ret = pthread_create(&amp;tid, NULL, tfn, NULL);</span><br><span class="line">21. if (ret != 0) &#123;</span><br><span class="line">22. perror(&quot;pthread_create error&quot;);</span><br><span class="line">23. &#125;</span><br><span class="line">24. ret = pthread_detach(tid); // 设置线程分离` 线程终止,会自动清理 pcb,无需回收</span><br><span class="line">25. if (ret != 0) &#123;</span><br><span class="line">26. perror(&quot;pthread_detach error&quot;);</span><br><span class="line">27. &#125;</span><br><span class="line">28.</span><br><span class="line">29. sleep(1);</span><br><span class="line">30.</span><br><span class="line">31. ret = pthread_join(tid, NULL);</span><br><span class="line">32. printf(&quot;join ret = %d\n&quot;, ret);</span><br><span class="line">33. if (ret != 0) &#123;</span><br><span class="line">34. perror(&quot;pthread_join error&quot;);</span><br><span class="line">35. &#125;</span><br><span class="line">36.</span><br><span class="line">37. printf(&quot;main: pid = %d, tid = %lu\n&quot;, getpid(), pthread_self());</span><br><span class="line">38.</span><br><span class="line">39. pthread_exit((void *)0);</span><br><span class="line">40. &#125;</span><br></pre></td></tr></table></figure>

<p>这里，问题出现了，join 出错了，但是没打印错误原因。之前的 perror 方法检查线程错误是有 问题的。应该使用 strerror，修改代码如下，因为perror方法是底层的一个全局变量，线程不能用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">20. int ret = pthread_create(&amp;tid, NULL, tfn, NULL);</span><br><span class="line">21. if (ret != 0) &#123;</span><br><span class="line">22. fprintf(stderr, &quot;pthread_create error: %s\n&quot;, strerror(ret));//stderr,直接输出到终端</span><br><span class="line">23. exit(1);</span><br><span class="line">24. &#125;</span><br></pre></td></tr></table></figure>

<p>出错，是因为线程分离后，系统会自动回收资源，用 pthread_join 去回收已经被系统 回收的线程，那个线程号就是无效参数。</p>
<p><code>pthread_join()</code>和<code>pthread_detach()</code>是用于管理线程资源的两种方式，但它们的作用是不同的。</p>
<ul>
<li><code>pthread_join(thread, status)</code>函数会将主线程阻塞，直到指定的线程 <code>thread</code> 终止。一旦目标线程终止，调用线程将从阻塞状态返回，并可以获取目标线程的退出状态信息。通过这种方式，<code>pthread_join()</code>可以实现对子线程的资源回收和同步等待操作。</li>
<li><code>pthread_detach(thread)</code>函数则是将指定的线程 <code>thread</code> 设置为分离状态，从而使得线程结束后自动释放其相关资源，包括线程栈空间和线程描述符等。相当于告诉系统不需要进行显式的资源回收操作，由系统自动回收资源。</li>
</ul>
<p>所以，虽然<code>pthread_join()</code>和<code>pthread_detach()</code>都能起到资源回收的作用，它们的使用场景和效果略有差异。<code>pthread_join()</code>适用于需要等待线程执行完毕并获取其返回状态的情况，而<code>pthread_detach()</code>适用于不关心线程返回状态，只希望在线程结束后自动回收资源的情况</p>
<h2 id="进程和线程控制原语对比"><a href="#进程和线程控制原语对比" class="headerlink" title="进程和线程控制原语对比"></a>进程和线程控制原语对比</h2><p>线程控制原语 			进程控制原语<br>pthread_create() 		fork();<br>pthread_self() 			getpid();<br>pthread_exit() 			exit(); 	&#x2F; return &#x2F;&#x2F;exit实际是退出进程，无论在哪个线程都会将整个进程都退出，return是退回到上一次调用的地方，所有只有都在主函数调用的时候效果一样。<br>pthread_join() 			wait()&#x2F;waitpid()<br>pthread_cancel() 		kill()<br>pthread_detach()</p>
<h2 id="线程属性设置分离线程"><a href="#线程属性设置分离线程" class="headerlink" title="线程属性设置分离线程"></a>线程属性设置分离线程</h2><p>线程属性：<br>设置分离属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pthread_attr_t attr 创建一个线程属性结构体变量</span><br><span class="line">pthread_attr_init(&amp;attr); 初始化线程属性</span><br><span class="line">pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED); 设置线程属性为分离态</span><br><span class="line">pthread_create(&amp;tid, &amp;attr, tfn, NULL); 借助修改后的 设置线程属性 创建为分离态的新线程</span><br><span class="line">pthread_attr_destroy(&amp;attr); 销毁线程属性</span><br></pre></td></tr></table></figure>

<p>调整线程状态，使线程创建出来就是分离态，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;errno.h&gt;</span><br><span class="line">6. #include &lt;pthread.h&gt;</span><br><span class="line">7.</span><br><span class="line">8.</span><br><span class="line">9. void *tfn(void *arg)</span><br><span class="line">10. &#123;</span><br><span class="line">11. printf(&quot;thread: pid = %d, tid = %lu\n&quot;, getpid(), pthread_self());</span><br><span class="line">12.</span><br><span class="line">13. return NULL;</span><br><span class="line">14. &#125;</span><br><span class="line">15.</span><br><span class="line">16. int main(int argc, char *argv[])</span><br><span class="line">17. &#123;</span><br><span class="line">18. pthread_t tid;</span><br><span class="line">19.</span><br><span class="line">20. pthread_attr_t attr;</span><br><span class="line">21.</span><br><span class="line">22. int ret = pthread_attr_init(&amp;attr);</span><br><span class="line">23. if (ret != 0) &#123;</span><br><span class="line">24. fprintf(stderr, &quot;attr_init error:%s\n&quot;, strerror(ret));</span><br><span class="line">25. exit(1);</span><br><span class="line">26. &#125;</span><br><span class="line">27.</span><br><span class="line">28. ret = pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED); // 设置线程属性为 分离属性</span><br><span class="line">29. if (ret != 0) &#123;</span><br><span class="line">30. fprintf(stderr, &quot;attr_setdetachstate error:%s\n&quot;, strerror(ret));</span><br><span class="line">31. exit(1);</span><br><span class="line">32. &#125;</span><br><span class="line">33.</span><br><span class="line">34. ret = pthread_create(&amp;tid, &amp;attr, tfn, NULL);</span><br><span class="line">35. if (ret != 0) &#123;</span><br><span class="line">36. perror(&quot;pthread_create error&quot;);</span><br><span class="line">37. &#125;</span><br><span class="line">38.</span><br><span class="line">39. ret = pthread_attr_destroy(&amp;attr);</span><br><span class="line">40. if (ret != 0) &#123;</span><br><span class="line">41. fprintf(stderr, &quot;attr_destroy error:%s\n&quot;, strerror(ret));</span><br><span class="line">42. exit(1);</span><br><span class="line">43. &#125;</span><br><span class="line">44.</span><br><span class="line">45. ret = pthread_join(tid, NULL);</span><br><span class="line">46. if (ret != 0) &#123;</span><br><span class="line">47. fprintf(stderr, &quot;pthread_join error:%s\n&quot;, strerror(ret));</span><br><span class="line">48. exit(1);</span><br><span class="line">49. &#125;</span><br><span class="line">50.</span><br><span class="line">51. printf(&quot;main: pid = %d, tid = %lu\n&quot;, getpid(), pthread_self());</span><br><span class="line">52.</span><br><span class="line">53. pthread_exit((void *)0);</span><br><span class="line">54. &#125;</span><br></pre></td></tr></table></figure>

<p>pthread_join 报错，说明线程已经自动回收，设置分离成功</p>
<h2 id="线程使用注意事项"><a href="#线程使用注意事项" class="headerlink" title="线程使用注意事项"></a>线程使用注意事项</h2><p>1.主线程退出其他线程不退出，主线程应调用<code>pthread_exit</code></p>
<p>2.避免僵尸线程。<br><code>pthread_joine</code></p>
<p><code>pthread_detach</code><br><code>pthread_create</code>	指定分离属性<br>join线程可能在join函数返回前就释放完自己的所有内存资源，所以不应当返回被回收线程楼中的值;</p>
<ol start="3">
<li>malloc和mmap申请的内存可以被其他线程释放<br>4.应避免在多线程模型中调用fork，除非马上exec，子进程中只有调用fork 的线程存在，其他线程在子进程中均pthread_exit<br>5.信号的复杂语义很难和多线程共存，应避免在多线程引入信号机制,因为信号处理是同概率的，每一个的mask是不同的，但是未决信号集是一样的，所有才能在信号来时都会主动处理。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/15/Linux-%E4%BF%A1%E5%8F%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/15/Linux-%E4%BF%A1%E5%8F%B7/" class="post-title-link" itemprop="url">Linux-信号</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-15 11:10:21" itemprop="dateCreated datePublished" datetime="2023-06-15T11:10:21+08:00">2023-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-18 11:41:12" itemprop="dateModified" datetime="2023-06-18T11:41:12+08:00">2023-06-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="信号的概念和机制"><a href="#信号的概念和机制" class="headerlink" title="信号的概念和机制"></a>信号的概念和机制</h2><p>信号共性：<br>    简单、不能携带大量信息、满足条件才发送。<br>信号的特质：<br>    信号是软件层面上的“中断”。一旦信号产生，无论程序执行到什么位置，必须立即停止运行，处理信号，处理结束，再继续执行后续指令。<br>    所有信号的产生及处理全部都是由【内核】完成的。</p>
<h2 id="与信号相关的概念"><a href="#与信号相关的概念" class="headerlink" title="与信号相关的概念"></a>与信号相关的概念</h2><p>信号相关的概念：<br>产生信号：</p>
<ol>
<li>按键产生</li>
<li>系统调用产生</li>
<li>软件条件产生</li>
<li>硬件异常产生</li>
<li>命令产生</li>
</ol>
<p>概念：<br>    未决：产生与递达之间状态。<br>    递达：产生并且送达到进程。直接被内核处理掉。<br>    信号处理方式： 执行默认处理动作、忽略、捕捉（自定义）<br>    阻塞信号集（信号屏蔽字）： 本质：位图。用来记录信号的屏蔽状态。一旦被屏蔽的信号，在解除屏蔽前，一直处于未决态。<br>    未决信号集：本质：位图。用来记录信号的处理状态。该信号集中的信号，表示，已经产生，但尚未被处理。</p>
<p><img src="/Linux-%E4%BF%A1%E5%8F%B7/image-20230615210105991.png" alt="image-20230615210105991"></p>
<img src="/2023/06/15/Linux-%E4%BF%A1%E5%8F%B7/image-20230615210105991.png" class title="This is an test image">

<p>默认2号为0.一旦有信号要2，则2处于未决变为1，如果信号屏蔽字为1一直处于未决态，未阻塞状态默认为0，则0变1会阻塞，默认下没阻塞这个过程很快。</p>
<h2 id="信号四要素和常规信号一览"><a href="#信号四要素和常规信号一览" class="headerlink" title="信号四要素和常规信号一览"></a>信号四要素和常规信号一览</h2><p>变量三要素：变量类型，变量名，变量值</p>
<p>kill -l 	查看当前系统中常规信号 </p>
<p>信号 4 要素： 信号使用之前，应先确定其 4 要素，而后再用！！！ </p>
<p>​						编号、名称、对应事件、默认处理动作。</p>
<h2 id="kill-函数和-kill-命令"><a href="#kill-函数和-kill-命令" class="headerlink" title="kill 函数和 kill 命令"></a>kill 函数和 kill 命令</h2><p>kill 命令 和 kill 函数：<br>    <code>int kill（pid_t pid, int signum）</code><br>    参数：<br>    pid: &gt; 0:发送信号给指定进程<br>            &#x3D; 0：发送信号给跟调用 kill 函数的那个进程处于同一进程组的进程。<br>            &lt; -1: 取绝对值，发送信号给该绝对值所对应的进程组的所有组员。<br>            &#x3D; -1：发送信号给，有权限发送的所有进程。<br>    signum：待发送的信号<br>返回值：<br>        成功： 0<br>        失败： -1 errno</p>
<p>子进程发送信号 kill 父进程</p>
<p><img src="/Linux-%E4%BF%A1%E5%8F%B7/image-20230615211148166.png" alt="image-20230615211148166"></p>
<img src="/2023/06/15/Linux-%E4%BF%A1%E5%8F%B7/image-20230615211148166.png" class title="This is an test image">

<p>这里子进程不发送 kill 信号，发其他信号也行，比如段错误什么的。 </p>
<p><code>kill -9 -groupname</code> 杀一个进程组</p>
<h2 id="alarm-函数"><a href="#alarm-函数" class="headerlink" title="alarm 函数"></a>alarm 函数</h2><p>alarm 函数：使用自然计时法。<br>        定时发送 SIGALRM 给当前进程。<br>        <code>unsigned int alarm(unsigned int seconds);</code><br>            seconds：定时秒数<br>            返回值：上次定时剩余时间。<br>                        无错误现象。<br>            <code>alarm（0）；</code> 取消闹钟。<br>        time 命令 ： 查看程序执行时间。 实际时间 &#x3D; 用户时间 + 内核时间 + 等待时间。 –》	优化瓶颈 IO（写入文件比在终端输出效率更高）</p>
<h2 id="setitimer-函数"><a href="#setitimer-函数" class="headerlink" title="setitimer 函数"></a>setitimer 函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">setitimer 函数：</span><br><span class="line">	int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);</span><br><span class="line">	参数：</span><br><span class="line">		which： ITIMER_REAL： 采用自然计时。 ——&gt; SIGALRM</span><br><span class="line">			ITIMER_VIRTUAL: 采用用户空间计时 ---&gt; SIGVTALRM</span><br><span class="line">			ITIMER_PROF: 采用内核+用户空间计时 ---&gt; SIGPROF</span><br><span class="line">		new_value：定时秒数</span><br><span class="line"> 			类型：struct itimerval &#123;</span><br><span class="line"> 						struct timeval &#123;</span><br><span class="line"> 							time_t tv_sec; /* seconds */</span><br><span class="line"> 							suseconds_t tv_usec; /* microseconds */</span><br><span class="line"> 						&#125;it_interval;---&gt; 周期定时秒数</span><br><span class="line"> 						struct timeval &#123;</span><br><span class="line"> 							time_t tv_sec; </span><br><span class="line"> 							suseconds_t tv_usec; </span><br><span class="line"> 						&#125;it_value; ---&gt; 第一次定时秒数 </span><br><span class="line"> 			&#125;;</span><br><span class="line">old_value：传出参数，上次定时剩余时间。</span><br><span class="line">e.g.</span><br><span class="line">    struct itimerval new_t;</span><br><span class="line">    struct itimerval old_t;</span><br><span class="line">    new_t.it_interval.tv_sec = 0;</span><br><span class="line">    new_t.it_interval.tv_usec = 0;</span><br><span class="line">    new_t.it_value.tv_sec = 1;</span><br><span class="line">    new_t.it_value.tv_usec = 0;</span><br><span class="line">    int ret = setitimer(&amp;new_t, &amp;old_t); 定时 1 秒</span><br><span class="line">返回值：</span><br><span class="line">	成功： 0</span><br><span class="line">	失败： -1 errno</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用 setitimer 定时，向屏幕打印信息：</p>
<p><img src="/Linux-%E4%BF%A1%E5%8F%B7/image-20230615212147397.png" alt="image-20230615212147397"></p>
<img src="/2023/06/15/Linux-%E4%BF%A1%E5%8F%B7/image-20230615212147397.png" class title="This is an test image">

<p>第一次信息打印是两秒间隔，之后都是 5 秒间隔打印一次。可以理解为第一次是有个定时器，什么时候触发打印，之后就是间隔时间。</p>
<h2 id="信号集操作函数"><a href="#信号集操作函数" class="headerlink" title="信号集操作函数"></a>信号集操作函数</h2><p><img src="/Linux-%E4%BF%A1%E5%8F%B7/image-20230616164625460.png" alt="image-20230616164625460"></p>
<img src="/2023/06/15/Linux-%E4%BF%A1%E5%8F%B7/image-20230616164625460.png" class title="This is an test image">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">信号集操作函数：</span><br><span class="line">    sigset_t set; 自定义信号集。</span><br><span class="line">    sigemptyset(sigset_t *set); 清空信号集</span><br><span class="line">    sigfillset(sigset_t *set); 全部置 1</span><br><span class="line">    sigaddset(sigset_t *set, int signum); 将一个信号添加到集合中</span><br><span class="line">    sigdelset(sigset_t *set, int signum); 将一个信号从集合中移除</span><br><span class="line">    sigismember（const sigset_t *set，int signum); 判断一个信号是否在集合中。 在--》1，不在--》0</span><br><span class="line">设置信号屏蔽字和解除屏蔽：</span><br><span class="line">    int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</span><br><span class="line">    how: SIG_BLOCK: 设置阻塞</span><br><span class="line">        SIG_UNBLOCK: 取消阻塞</span><br><span class="line">        SIG_SETMASK: 用自定义 set 替换 mask。</span><br><span class="line">    set： 自定义 set</span><br><span class="line">    oldset：旧有的 mask。</span><br><span class="line">查看未决信号集：</span><br><span class="line">    int sigpending(sigset_t *set);</span><br><span class="line">    set： 传出的 未决信号集。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="信号集操作函数练习"><a href="#信号集操作函数练习" class="headerlink" title="信号集操作函数练习"></a>信号集操作函数练习</h2><p>信号列表：<img src="/Linux-%E4%BF%A1%E5%8F%B7/image-20230616165025942.png" alt="image-20230616165025942"></p>
<img src="/2023/06/15/Linux-%E4%BF%A1%E5%8F%B7/image-20230616165025942.png" class title="This is an test image">

<p>其中 9 号和 19 号信号比较特殊，只能执行默认动作，不能忽略捕捉，不能设置阻塞。</p>
<p>下面这个小例子，利用自定义集合，来设置信号阻塞，我们输入被设置阻塞的信号，可以看到未决信号集发生变化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;signal.h&gt;</span><br><span class="line">3. #include &lt;stdlib.h&gt;</span><br><span class="line">4. #include &lt;string.h&gt;</span><br><span class="line">5. #include &lt;unistd.h&gt;</span><br><span class="line">6. #include &lt;errno.h&gt;</span><br><span class="line">7. #include &lt;pthread.h&gt;</span><br><span class="line">8.</span><br><span class="line">9. void sys_err(const char *str)</span><br><span class="line">10. &#123;</span><br><span class="line">11. perror(str);</span><br><span class="line">12. exit(1);</span><br><span class="line">13. &#125;</span><br><span class="line">14.</span><br><span class="line">15. void print_set(sigset_t *set)</span><br><span class="line">16. &#123;</span><br><span class="line">17. int i;</span><br><span class="line">18. for (i = 1; i&lt;32; i++) &#123;</span><br><span class="line">19. if (sigismember(set, i))</span><br><span class="line">20. putchar(&#x27;1&#x27;);</span><br><span class="line">21. else</span><br><span class="line">22. putchar(&#x27;0&#x27;);</span><br><span class="line">23. &#125;</span><br><span class="line">24. printf(&quot;\n&quot;);</span><br><span class="line">25. &#125;</span><br><span class="line">26. int main(int argc, char *argv[])</span><br><span class="line">27. &#123;</span><br><span class="line">28. sigset_t set, oldset, pedset;</span><br><span class="line">29. int ret = 0;</span><br><span class="line">30.</span><br><span class="line">31. sigemptyset(&amp;set);</span><br><span class="line">32. sigaddset(&amp;set, SIGINT);</span><br><span class="line">33. sigaddset(&amp;set, SIGQUIT);</span><br><span class="line">34. sigaddset(&amp;set, SIGBUS);</span><br><span class="line">35. sigaddset(&amp;set, SIGKILL);</span><br><span class="line">36.</span><br><span class="line">37. ret = sigprocmask(SIG_BLOCK, &amp;set, &amp;oldset);</span><br><span class="line">38. if (ret == -1)</span><br><span class="line">39. sys_err(&quot;sigprocmask error&quot;);</span><br><span class="line">40.</span><br><span class="line">41. while (1) &#123;</span><br><span class="line">42. ret = sigpending(&amp;pedset);</span><br><span class="line">43. print_set(&amp;pedset);</span><br><span class="line">44. sleep(1);</span><br><span class="line">45. &#125;</span><br><span class="line">46.</span><br><span class="line">47. return 0;</span><br><span class="line">48. &#125;</span><br></pre></td></tr></table></figure>

<p>编译运行，如下图所示：</p>
<p><img src="/Linux-%E4%BF%A1%E5%8F%B7/image-20230616165908670.png" alt="image-20230616165908670"></p>
<img src="/2023/06/15/Linux-%E4%BF%A1%E5%8F%B7/image-20230616165908670.png" class title="This is an test image">

<p>可以看到，在输入 Ctrl+C 之后，进程捕捉到信号，但由于设置阻塞，没有处理，未决信号集对应位 置变为 1.</p>
<h2 id="signal-实现信号捕捉"><a href="#signal-实现信号捕捉" class="headerlink" title="signal 实现信号捕捉"></a>signal 实现信号捕捉</h2><p><img src="/Linux-%E4%BF%A1%E5%8F%B7/image-20230616170009398.png" alt="image-20230616170009398"></p>
<img src="/2023/06/15/Linux-%E4%BF%A1%E5%8F%B7/image-20230616170009398.png" class title="This is an test image">

<p>参数： </p>
<p>​	signum ：待捕捉信号 </p>
<p>​	handler：捕捉信号后的操纵函数</p>
<p>返回值：<img src="/Linux-%E4%BF%A1%E5%8F%B7/image-20230616170104431.png" alt="image-20230616170104431"></p>
<img src="/2023/06/15/Linux-%E4%BF%A1%E5%8F%B7/image-20230616170104431.png" class title="This is an test image">

<p>信号捕捉特性：</p>
<ol>
<li>捕捉函数执行期间，信号屏蔽字 由 mask –&gt; sa_mask , 捕捉函数执行结束。 恢复回 mask</li>
<li>捕捉函数执行期间，本信号自动被屏蔽(sa_flgs &#x3D; 0).</li>
<li>捕捉函数执行期间，被屏蔽信号多次发送，解除屏蔽后只处理一次！</li>
</ol>
<p>一个信号捕捉的小例子：<img src="/Linux-%E4%BF%A1%E5%8F%B7/image-20230616170159382.png" alt="image-20230616170159382"></p>
<img src="/2023/06/15/Linux-%E4%BF%A1%E5%8F%B7/image-20230616170159382.png" class title="This is an test image">

<p>在上述代码中，函数<code>sig_cath</code>是一个信号处理函数，它被注册为了<code>SIGINT</code>信号的处理器。当程序接收到<code>SIGINT</code>信号（通常由终端按下Ctrl+C触发）时，该处理函数会被调用。在此处，参数<code>signo</code>代表接收到的信号编号，因此在函数定义中声明了参数<code>int signo</code>。</p>
<p>在<code>main</code>函数中，通过调用<code>signal(SIGINT, sig_cath)</code>将<code>sig_cath</code>函数注册为<code>SIGINT</code>信号（终端中断信号）的处理函数。这样，当程序接收到<code>SIGINT</code>信号时，就会调用<code>sig_cath</code>函数进行相关处理。</p>
<p>总结起来，参数<code>signo</code>是由系统自动传递给信号处理函数的，在这段代码中并不需要手动传入。</p>
<h2 id="sigaction-实现信号捕捉"><a href="#sigaction-实现信号捕捉" class="headerlink" title="sigaction 实现信号捕捉"></a>sigaction 实现信号捕捉</h2><p>sigaction 也是注册一个信号捕捉函数</p>
<p><img src="/Linux-%E4%BF%A1%E5%8F%B7/image-20230616170313810.png" alt="image-20230616170313810"></p>
<img src="/2023/06/15/Linux-%E4%BF%A1%E5%8F%B7/image-20230616170313810.png" class title="This is an test image">

<p>下面的小例子，使用 sigaction 捕捉两个信号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;signal.h&gt;</span><br><span class="line">3. #include &lt;stdlib.h&gt;</span><br><span class="line">4. #include &lt;string.h&gt;</span><br><span class="line">5. #include &lt;unistd.h&gt;</span><br><span class="line">6. #include &lt;errno.h&gt;</span><br><span class="line">7. #include &lt;pthread.h&gt;</span><br><span class="line">8.</span><br><span class="line">9. void sys_err(const char *str)</span><br><span class="line">10. &#123;</span><br><span class="line">11. perror(str);</span><br><span class="line">12. exit(1);</span><br><span class="line">13. &#125;</span><br><span class="line">14.</span><br><span class="line">15. void sig_catch(int signo) // 回调函数</span><br><span class="line">16. &#123;</span><br><span class="line">17. if (signo == SIGINT) &#123;</span><br><span class="line">18. printf(&quot;catch you!! %d\n&quot;, signo);</span><br><span class="line">19. sleep(10);</span><br><span class="line">20. &#125;</span><br><span class="line">21.</span><br><span class="line">22. else if (signo == SIGQUIT)</span><br><span class="line">23. printf(&quot;-----------catch you!! %d\n&quot;, signo);</span><br><span class="line">24.</span><br><span class="line">25. return ;</span><br><span class="line">26. &#125;</span><br><span class="line">27.</span><br><span class="line">28. int main(int argc, char *argv[])</span><br><span class="line">29. &#123;</span><br><span class="line">30. struct sigaction act, oldact;</span><br><span class="line">31.</span><br><span class="line">32. act.sa_handler = sig_catch; // set callback function name 设置回调函数</span><br><span class="line">33. sigemptyset(&amp;(act.sa_mask)); // set mask when sig_catch working. 清空 sa_mask 屏蔽字, 只在sig_catch 工作时有效</span><br><span class="line">34. //sigaddset(&amp;act.sa_mask, SIGQUIT);</span><br><span class="line">35. act.sa_flags = 0; // usually use. 默认值</span><br><span class="line">36.</span><br><span class="line">37. int ret = sigaction(SIGINT, &amp;act, &amp;oldact); //注册信号捕捉函数</span><br><span class="line">38. if (ret == -1)</span><br><span class="line">39. sys_err(&quot;sigaction error&quot;);</span><br><span class="line">40. ret = sigaction(SIGQUIT, &amp;act, &amp;oldact); //注册信号捕捉函数</span><br><span class="line">41.</span><br><span class="line">42. while (1);</span><br><span class="line">43.</span><br><span class="line">44. return 0;</span><br><span class="line">45. &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/Linux-%E4%BF%A1%E5%8F%B7/image-20230616170558665.png" alt="image-20230616170558665"></p>
<img src="/2023/06/15/Linux-%E4%BF%A1%E5%8F%B7/image-20230616170558665.png" class title="This is an test image">

<h2 id="信号捕捉的特性"><a href="#信号捕捉的特性" class="headerlink" title="信号捕捉的特性"></a>信号捕捉的特性</h2><p>信号捕捉特性：</p>
<ol>
<li>捕捉函数执行期间，信号屏蔽字 由 mask –&gt; sa_mask , 捕捉函数执行结束。 恢复回 mask</li>
<li>捕捉函数执行期间，本信号自动被屏蔽(sa_flgs &#x3D; 0).</li>
<li>捕捉函数执行期间，被屏蔽信号多次发送，解除屏蔽后只处理一次！</li>
</ol>
<h2 id="内核实现信号捕捉简析"><a href="#内核实现信号捕捉简析" class="headerlink" title="内核实现信号捕捉简析"></a>内核实现信号捕捉简析</h2><p><img src="/Linux-%E4%BF%A1%E5%8F%B7/image-20230616170745748.png" alt="image-20230616170745748"></p>
<img src="/2023/06/15/Linux-%E4%BF%A1%E5%8F%B7/image-20230616170745748.png" class title="This is an test image">

<h2 id="借助信号捕捉回收子进程"><a href="#借助信号捕捉回收子进程" class="headerlink" title="借助信号捕捉回收子进程"></a>借助信号捕捉回收子进程</h2><p>SIGCHLD 的产生条件： </p>
<p>​	子进程终止时 </p>
<p>​	子进程接收到 SIGSTOP </p>
<p>​	子进程处于停止态，接收到 SIGCONT 后唤醒时</p>
<p>下面是一个例子，创建子进程，并使用信号回收：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;signal.h&gt;</span><br><span class="line">6. #include &lt;sys/wait.h&gt;</span><br><span class="line">7. #include &lt;errno.h&gt;</span><br><span class="line">8. #include &lt;pthread.h&gt;</span><br><span class="line">9.</span><br><span class="line">10. void sys_err(const char *str)</span><br><span class="line">11. &#123;</span><br><span class="line">12. perror(str);</span><br><span class="line">13. exit(1);</span><br><span class="line">14. &#125;</span><br><span class="line">15.</span><br><span class="line">16. void catch_child(int signo)// 有子进程终止，发送 SGCHLD 信号时，该函数会被内核回调</span><br><span class="line">17. &#123;</span><br><span class="line">18. pid_t wpid;</span><br><span class="line">19.</span><br><span class="line">20. wpid = wait(NULL);</span><br><span class="line">21. printf(&quot;-----------catch child id %d\n&quot;, wpid);</span><br><span class="line">22.</span><br><span class="line">23. return ;</span><br><span class="line">24. &#125;</span><br><span class="line">25.</span><br><span class="line">26. int main(int argc, char *argv[])</span><br><span class="line">27. &#123;</span><br><span class="line">28. pid_t pid;</span><br><span class="line">29. //阻塞,和解除阻塞一起用可以避免出现还未注册信号捕捉函数，子进程就直接接受信号默认过程，参考信号集操作函数</span><br><span class="line">	sigset_t set;</span><br><span class="line">	sigemptyset(&amp;set);</span><br><span class="line">	sigaddset(&amp;set, SIGCHLD);</span><br><span class="line">	sigprocmask(SIG_BLOCK, &amp;set, NULL);</span><br><span class="line">30. int i;</span><br><span class="line">31. for (i = 0; i &lt; 5; i++)</span><br><span class="line">32. if ((pid = fork()) == 0) // 创建多个子进程</span><br><span class="line">33. break;</span><br><span class="line">34.</span><br><span class="line">35. if (5 == i) &#123;</span><br><span class="line">36. struct sigaction act;</span><br><span class="line">37.</span><br><span class="line">38. act.sa_handler = catch_child; // 设置回调函数</span><br><span class="line">39. sigemptyset(&amp;act.sa_mask); // 设置捕捉函数执行期间屏蔽字</span><br><span class="line">40. act.sa_flags = 0; // 设置默认属性, 本信号自动屏蔽</span><br><span class="line">41.</span><br><span class="line">42. sigaction(SIGCHLD, &amp;act, NULL); // 注册信号捕捉函数</span><br><span class="line">43. //解除阻塞</span><br><span class="line">44.sigprocmask(SIG_UNBLOCK, &amp;set, NULL);</span><br><span class="line">45. printf(&quot;I&#x27;m parent, pid = %d\n&quot;, getpid());</span><br><span class="line">46.</span><br><span class="line">47. while (1);</span><br><span class="line">48.</span><br><span class="line">49. &#125; else &#123;</span><br><span class="line">50. printf(&quot;I&#x27;m child pid = %d\n&quot;, getpid());</span><br><span class="line">51. return i;</span><br><span class="line">52. &#125;</span><br><span class="line">53.</span><br><span class="line">54. return 0;</span><br><span class="line">55. &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/Linux-%E4%BF%A1%E5%8F%B7/image-20230616171436271.png" alt="image-20230616171436271"></p>
<img src="/2023/06/15/Linux-%E4%BF%A1%E5%8F%B7/image-20230616171436271.png" class title="This is an test image">

<p>如图，只回收到 1 个子进程，多次执行，会发现回收到的子进程数量不是固定的。 原因分析： 问题出在，一次回调只回收一个子进程这里。同时出现多个子进程死亡时，其中一个子进程死亡 信号被捕捉，父进程去处理这个信号，此时其他子进程死亡信号发送过来，由于相同信号的不排队原 则，就只会回收累积信号中的一个子进程。</p>
<p>修改代码，回调函数中添加循环，一次回调可以回收多个子进程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void catch_child(int signo)// 有子进程终止，发送 SGCHLD 信号时，该函数会被内核回调</span><br><span class="line">&#123;</span><br><span class="line"> 	pid_t wpid;</span><br><span class="line"> 	int status;</span><br><span class="line"> 	//while((wpid = wait(NULL)) != -1)&#123;</span><br><span class="line"> 	while((wpid = waitpid(-1, &amp;status, 0)) != -1) &#123;// 循环回收,防止僵尸进程出现.</span><br><span class="line"> 		if (WIFEXITED(status))</span><br><span class="line"> 			printf(&quot;-----------catch child id %d, ret=%d\n&quot;, wpid, WEXITSTATUS(status));</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这下就是回收了所有子进程，很强势。 </p>
<p>还有一个问题需要注意，这里有可能父进程还没注册完捕捉函数，子进程就死亡了，解决这个问 题的方法，首先是让子进程 sleep，但这个不太科学。在 fork 之前注册也行，但这个也不是很科学。 最科学的方法是在 int i 之前设置屏蔽，等父进程注册完捕捉函数再解除屏蔽。这样即使子进程先死亡了，信号也因为被屏蔽而无法到达父进程。解除屏蔽过后，父进程就能处理累积起来的信号了。</p>
<h2 id="中断系统调用"><a href="#中断系统调用" class="headerlink" title="中断系统调用"></a>中断系统调用</h2><p>系统调用可分为两类:慢速系统调用和其他系统调用。<br>1.慢速系统调用:可能会使进程永远阻塞的一类。如果在阻塞期间收到一个信号，该系统调用就被中断,不再继续执行(早期);也可以设定系统调用是否重启。如，read、 write、pause 、 wait…<br>2.其他系统调用:getpid、getppid、fork…<br>结合pause，回顾慢速系统调用:<br>    慢速系统调用被中断的相关行为，实际上就是pause的行为:如，read</p>
<ul>
<li>想中断pause，信号不能被屏蔽。</li>
<li>信号的处理方式必须是捕捉(默认、忽略都不可以)</li>
<li>中断后返回-1，设置errno为EINTR(表“被信号中断”)</li>
</ul>
<p>可修改sa_flags参数来设置被信号中断后系统调用是否重启。SA_INTERRURT不重启。SA_RESTART重启。</p>
<p>sa_flags 还有很多可选参数，适用于不同情况。如:捕捉到信号后，在执行捕捉函数期间，不希望自动阻塞该信号，可将sa_flags设置为SA_NODEFER，除非sa_mask中包含该信号。</p>
<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>会话：多个进程组的集合<br>创建会话的 6 点注意事项：</p>
<ol>
<li>调用进程不能是进程组组长，该进程变成新会话首进程</li>
<li>该进程成为一个新进程组的组长进程</li>
<li>需要 root 权限（ubuntu 不需要）</li>
<li>新会话丢弃原有的控制终端，该会话没有控制终端</li>
<li>该调用进程是组长进程，则出错返回</li>
<li>建立新会话时，先调用 fork，父进程终止，子进程调用 setsid</li>
</ol>
<p>getsid 函数：<br><code>pid_t getsid(pid_t pid)</code> 获取当前进程的会话 id<br>成功返回调用进程会话 ID，失败返回-1，设置 error<br>setsid 函数：<br><code>pid_t setsid(void)</code> 创建一个会话，并以自己的 ID 设置进程组 ID，同时也是新会话的 ID<br>成功返回调用进程的会话 ID，失败返回-1，设置 error</p>
<h2 id="守护进程创建步骤分析"><a href="#守护进程创建步骤分析" class="headerlink" title="守护进程创建步骤分析"></a>守护进程创建步骤分析</h2><p>守护进程：<br>daemon 进程。通常运行于操作系统后台，脱离控制终端。一般不与用户直接交互。周期性的等待某个事件发生或周期性执行某一动作。<br>不受用户登录注销影响。通常采用以 d 结尾的命名方式。</p>
<p>创建守护进程，最关键的一步是调用 setsid 函数创建一个新的 Session，并成为 Session Leader</p>
<p>守护进程创建步骤：</p>
<ol>
<li>fork 子进程，让父进程终止。</li>
<li>子进程调用 setsid() 创建新会话</li>
<li>通常根据需要，改变工作目录位置 chdir()， 防止目录被卸载。比如目录是在U盘上，卸载就会出问题。</li>
<li>通常根据需要，重设 umask 文件权限掩码，影响新文件的创建权限。 022 – 755 0345 — 432 r—wx-w- 422,x权限默认不给，创建目录是432，创建文件没有x就是422.（可能是<strong>出于安全的考虑，linux系统新建文件默认没有执行权限</strong>，其最大权限为rw-rw-rw-（666），新建目录的最大权限为rwx-rwx-rwx（777）。）</li>
<li>通常根据需要，关闭&#x2F;重定向 文件描述符</li>
<li>守护进程 业务逻辑。while（）</li>
</ol>
<p>下面这个例子，创建一个守护进程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;sys/stat.h&gt;</span><br><span class="line">3. #include &lt;fcntl.h&gt;</span><br><span class="line">4. #include &lt;stdlib.h&gt;</span><br><span class="line">5. #include &lt;string.h&gt;</span><br><span class="line">6. #include &lt;unistd.h&gt;</span><br><span class="line">7. #include &lt;errno.h&gt;</span><br><span class="line">8. #include &lt;pthread.h&gt;</span><br><span class="line">9.</span><br><span class="line">10. void sys_err(const char *str)</span><br><span class="line">11. &#123;</span><br><span class="line">12. perror(str);</span><br><span class="line">13. exit(1);</span><br><span class="line">14. &#125;</span><br><span class="line">15.</span><br><span class="line">16. int main(int argc, char *argv[])</span><br><span class="line">17. &#123;</span><br><span class="line">18. pid_t pid;</span><br><span class="line">19. int ret, fd;</span><br><span class="line">20.</span><br><span class="line">21. pid = fork();</span><br><span class="line">22. if (pid &gt; 0) // 父进程终止</span><br><span class="line">23. exit(0);</span><br><span class="line">24.</span><br><span class="line">25. pid = setsid(); //创建新会话</span><br><span class="line">26. if (pid == -1)</span><br><span class="line">27. sys_err(&quot;setsid error&quot;);</span><br><span class="line">28.</span><br><span class="line">29. ret = chdir(&quot;/home/zhcode/Code/code146&quot;); // 改变工作目录位置</span><br><span class="line">30. if (ret == -1)</span><br><span class="line">31. sys_err(&quot;chdir error&quot;);</span><br><span class="line">32.</span><br><span class="line">33. umask(0022); // 改变文件访问权限掩码</span><br><span class="line">34.</span><br><span class="line">35. close(STDIN_FILENO); // 关闭文件描述符 0</span><br><span class="line">36.</span><br><span class="line">37. fd = open(&quot;/dev/null&quot;, O_RDWR); // fd --&gt; 0**文件描述符fd默认会给最小的，如果0，1，2关闭，则会给0**</span><br><span class="line">38. if (fd == -1)</span><br><span class="line">39. sys_err(&quot;open error&quot;);</span><br><span class="line">40.</span><br><span class="line">41. dup2(fd, STDOUT_FILENO); // 重定向 stdout 和 stderr,因为不需要与用户交互，/dev/null这是一个空洞文件</span><br><span class="line">42. dup2(fd, STDERR_FILENO);</span><br><span class="line">43.</span><br><span class="line">44. while (1); // 模拟 守护进程业务.</span><br><span class="line">45.</span><br><span class="line">46. return 0;</span><br><span class="line">47. &#125;</span><br></pre></td></tr></table></figure>

<p>不会受到用户登录注销影响，会话不会结束，只有kill才行。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">Linux进程相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-01 21:35:45" itemprop="dateCreated datePublished" datetime="2023-06-01T21:35:45+08:00">2023-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-17 15:19:14" itemprop="dateModified" datetime="2023-06-17T15:19:14+08:00">2023-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="进程和程序以及-CPU-相关"><a href="#进程和程序以及-CPU-相关" class="headerlink" title="进程和程序以及 CPU 相关"></a>进程和程序以及 CPU 相关</h2><p>进程：<br>        程序：死的。只占用磁盘空间。 ——剧本。<br>        进程；活的。运行起来的程序。占用内存、cpu 等系统资源。 ——戏。<br>并发和并行：并行是宏观上并发，微观上串行</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230601213825110.png" alt="image-20230601213825110"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230601213825110.png" class title="This is an test image">

<h2 id="虚拟内存和物理内存映射关系"><a href="#虚拟内存和物理内存映射关系" class="headerlink" title="虚拟内存和物理内存映射关系"></a>虚拟内存和物理内存映射关系</h2><p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230601215722575.png" alt="image-20230601215722575"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230601215722575.png" class title="This is an test image">

<p>Linux下只有两级。从用户空间到内核空间进的时候，需要借助mmu，帮助完成全级切换。</p>
<h2 id="pcb-进程控制块"><a href="#pcb-进程控制块" class="headerlink" title="pcb 进程控制块"></a>pcb 进程控制块</h2><p>PCB 进程控制块：进程 id<br>文件描述符表<br>进程状态： 初始态、就绪态、运行态、挂起态、终止态。<br>进程工作目录位置<br>*umask 掩码 （进程的概念）<br>信号相关信息资源。<br>用户 id 和组 id<br>ps aux 返回结果里，第二列是进程 id</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609212449400.png" alt="image-20230609212449400"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609212449400.png" class title="This is an test image">

<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH 查看环境变量</span><br><span class="line">path 环境变量里记录了一系列的值，当运行一个可执行文件时，系统会去环境变量记录的位置里查</span><br><span class="line">找这个文件并执行。</span><br><span class="line">echo $TERM 查看终端</span><br><span class="line">echo $LANG 查看语言</span><br><span class="line">env 查看所有环境变量</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="fork-函数原理"><a href="#fork-函数原理" class="headerlink" title="fork 函数原理"></a>fork 函数原理</h2><p>fork 函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pid_t fork(void)</span><br><span class="line">创建子进程。父子进程各自返回。父进程返回子进程 pid。 子进程返回 0.</span><br><span class="line">getpid();getppid();</span><br><span class="line">循环创建 N 个子进程模型。 每个子进程标识自己的身份。</span><br></pre></td></tr></table></figure>

<p>父子进程相同： 刚 fork 后。 data 段、text 段、堆、栈、环境变量、全局变量、宿主目录位置、进程工作目录位 置、信号处理方式</p>
<p>父子进程不同： 进程 id、返回值、各自的父进程、进程创建时间、闹钟、未决信号集</p>
<p>父子进程共享： 读时共享、写时复制。———————— 全局变量。 1. 文件描述符 2. mmap 映射区</p>
<h2 id="fork-创建子进程"><a href="#fork-创建子进程" class="headerlink" title="fork 创建子进程"></a>fork 创建子进程</h2><p>下面是一个 fork 函数的例子，代码如下：</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609212838706.png" alt="image-20230609212838706"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609212838706.png" class title="This is an test image">

<p>fork 之前的代码，父子进程都有，但是只有父进程执行了，子进程没有执行，fork 之后的代码，父子进程都有机会执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">两个函数：</span><br><span class="line">pid_t getpid() 获取当前进程 id</span><br><span class="line">pid_t getppid() 获取当前进程的父进程 id</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609212951089.png" alt="image-20230609212951089"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609212951089.png" class title="This is an test image">

<h2 id="循环创建多个子进程"><a href="#循环创建多个子进程" class="headerlink" title="循环创建多个子进程"></a>循环创建多个子进程</h2><p>所以，直接用个 for 循环是要出事情的，因为子进程也会 fork 新的进程 这里，对调用 fork 的进程进行判定，只让父进程 fork 新的进程就行，代码如下：</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609213428815.png" alt="image-20230609213428815"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230609213428815.png" class title="This is an test image">

<p>出现了问题：进程多了一个，而且不是按顺序来的。这里多出的一个，是父进程，因为父进程才有 i&#x3D;5 跳出循环这一步。所以，对父进程进行判定并处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(i=5)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;parent&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">	printf(&quot;..&quot;,i+1);</span><br></pre></td></tr></table></figure>

<p>现在还有两个问题，<br>    一个就是包括父进程在内的所有进程不是按顺序出现，多运行几次，发现是随机序列出现的。这<br>是要因为，对操作系统而言，这几个子进程几乎是同时出现的，它们和父进程一起争夺 cpu，谁抢到，<br>谁打印，所以出现顺序是随机的。<br>    第二问题就是终端提示符混在了输出里，这个是因为，loop_fork 是终端的子进程，一旦<br>loop_fork 执行完，终端就会打印提示符。就像之前没有子进程的程序，一旦执行完，就出现了终端<br>提示符。这里也就是这个道理，loop_fork 执行完了，终端提示符出现，然而 loop_fork 的子进程还<br>没执行完，所以输出就混在一起了。</p>
<p>通过 sleep 延时来解决父进程先结束这个问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(i=5)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;parent&quot;);</span><br><span class="line">	sleep(1);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">	printf(&quot;..&quot;,i+1);</span><br></pre></td></tr></table></figure>

<p>最后来解决子进程乱序输出的问题，解决方法很简单，让第 1 个子进程少等，第二个子进程多等， 后面子进程等待时间依次增加，这样就能实现有序输出。</p>
<h2 id="父子进程共享哪些内容"><a href="#父子进程共享哪些内容" class="headerlink" title="父子进程共享哪些内容"></a>父子进程共享哪些内容</h2><p>父子进程相同： 刚 fork 后。 data 段、text 段、堆、栈、环境变量、全局变量、宿主目录位置、进程工作目录位 置、信号处理方式</p>
<p>父子进程不同： 进程 id、返回值、各自的父进程、进程创建时间、闹钟、未决信号集</p>
<p>父子进程共享： 读时共享、写时复制。———————— 全局变量。如果只是读，则公用一个地址，写，则复制一份，不一起。</p>
<ol>
<li>文件描述符 2. mmap 映射区</li>
</ol>
<h2 id="父子进程-gdb-调试"><a href="#父子进程-gdb-调试" class="headerlink" title="父子进程 gdb 调试"></a>父子进程 gdb 调试</h2><p>gdb 调试：<br>设置父进程调试路径：set follow-fork-mode parent (默认)<br>设置子进程调试路径：set follow-fork-mode child<br>注意，一定要在 fork 函数调用之前设置才有效。</p>
<h2 id="exec-函数族"><a href="#exec-函数族" class="headerlink" title="exec 函数族"></a>exec 函数族</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">exec 函数族：</span><br><span class="line">使进程执行某一程序。成功无返回值，失败返回 -1</span><br><span class="line">int execlp(const char *file, const char *arg, ...); 借助 PATH 环境变量找寻待执</span><br><span class="line">行程序</span><br><span class="line">参 1： 程序名</span><br><span class="line">参 2： argv0</span><br><span class="line">参 3： argv1</span><br><span class="line">...： argvN</span><br><span class="line">哨兵：NULL</span><br><span class="line">int execl(const char *path, const char *arg, ...); 自己指定待执行程序路径。</span><br><span class="line">int execvp();</span><br><span class="line">ps ajx --&gt; pid ppid gid sid</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>fork创建子进程后执行的是和父进程相同的程序（但有可能执行不同的代码分支)，子进程往往要调用一种 exec函数以执行另一个程序。当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用exec并不创建新进程，所以调用exec前后该进程的id并未改变。<br>将当前进程的.text、.data替换为所要加载的程序的.text、.data，然后让进程从新的.text第一条指令开始执行，但进程ID不变，换核不换壳。即exec后面的子进程代码不执行了，因为进入了新的程序。</p>
<h3 id="execlp-和-ececl-函数"><a href="#execlp-和-ececl-函数" class="headerlink" title="execlp 和 ececl 函数"></a>execlp 和 ececl 函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int execlp(const char *file, const char *arg, …)</span><br><span class="line">成功，无返回，失败返回-1</span><br><span class="line">参数 1：要加载的程序名字，该函数需要配合 PATH 环境变量来使用，当 PATH 所有目录搜素后没</span><br><span class="line">有参数 1 则返回出错。</span><br><span class="line">该函数通常用来调用系统程序。如 ls、date、cp、cat 命令。</span><br><span class="line">execlp 这里面的 p，表示要借助环境变量来加载可执行文件</span><br></pre></td></tr></table></figure>

<p>示例代码，通过 execlp 让子进程去执行 ls 命令：</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215110094.png" alt="image-20230610215110094"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215110094.png" class title="This is an test image">

<p>只有父进程正确执行并输出了，子进程的 ls 输出有问题。 问题出在参数上，可变参数那里，是从 argv[0]开始计算的。 修改代码，就是将缺失的 argv[0]补上，然后让父进程延时 1 秒，保证终端提示符不和输出干扰。如 下：</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215242121.png" alt="image-20230610215242121"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215242121.png" class title="This is an test image">

<p>下面使用 execl 来让子程序调用自定义的程序。 int execl(const char *path, const char *arg, …) 这里要注意，和 execlp 不同的是，第一个参数是路径，不是文件名。 这个路径用相对路径和绝对路径都行。</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215316774.png" alt="image-20230610215316774"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215316774.png" class title="This is an test image">

<p>用 execl 也能执行 ls 这些，把路径给出来就行，但是这样麻烦，所以对于系统指令一般还是用 execlp</p>
<h2 id="exec-函数族特性"><a href="#exec-函数族特性" class="headerlink" title="exec 函数族特性"></a>exec 函数族特性</h2><p>写一个程序，使用 execlp 执行进程查看，并将结果输出到文件里。 要用到 open, execlp, dup2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">        int fd;</span><br><span class="line">        fd = open( &quot;ps.out&quot;, O_WRONLY|O_CREAT|O_TRUNC,0644);</span><br><span class="line">        if(fd &lt; 0)&#123;</span><br><span class="line">                perror(&quot;open ps.out error&quot;);</span><br><span class="line">                exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        dup2(fd,STDOUT_FILENO);</span><br><span class="line">        execlp(&quot;ps&quot;,&quot;ps&quot;,&quot;aux&quot;,NULL);</span><br><span class="line">        close(fd); //have no need to</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>exec 函数族一般规律： </p>
<p>exec 函数一旦调用成功，即执行新的程序，不返回。只有失败才返回，错误值-1，所以通常我们直接在 exec 函数调用后直接调用 perror()，和 exit()，无需 if 判断。</p>
<p>事实上，只有 execve 是真正的系统调用，其他 5 个函数最终都调用 execve，是库函数，所以 execve 在 man 手册第二节，其它函数在 man 手册第 3 节。</p>
<h2 id="孤儿进程和僵尸进程"><a href="#孤儿进程和僵尸进程" class="headerlink" title="孤儿进程和僵尸进程"></a>孤儿进程和僵尸进程</h2><p>孤儿进程：<br>父进程先于子进终止，子进程沦为“孤儿进程”，会被 init 进程领养。<br>僵尸进程：<br>子进程终止，父进程尚未对子进程进行回收，在此期间，子进程为“僵尸进程”。 kill 对其<br>无效。这里要注意，每个进程结束后都必然会经历僵尸态，时间长短的差别而已。<br>子进程终止时，子进程残留资源 PCB 存放于内核中，PCB 记录了进程结束原因，进程回收就是回<br>收 PCB。回收僵尸进程，得 kill 它的父进程，让孤儿院去回收它。</p>
<h2 id="wait-回收子进程"><a href="#wait-回收子进程" class="headerlink" title="wait 回收子进程"></a>wait 回收子进程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">wait 函数： 回收子进程退出资源， 阻塞回收任意一个。</span><br><span class="line">pid_t wait(int *status)</span><br><span class="line">参数：（传出） 回收进程的状态。</span><br><span class="line">返回值：成功： 回收进程的 pid</span><br><span class="line">失败： -1， errno</span><br><span class="line">函数作用 1： 阻塞等待子进程退出</span><br><span class="line">函数作用 2： 清理子进程残留在内核的 pcb 资源</span><br><span class="line">函数作用 3： 通过传出参数，得到子进程结束状态</span><br><span class="line">获取子进程正常终止值：</span><br><span class="line">WIFEXITED(status) --》 为真 --》调用 WEXITSTATUS(status) --》 得到 子进程 退出值。</span><br><span class="line">获取导致子进程异常终止信号：</span><br><span class="line">WIFSIGNALED(status) --》 为真 --》调用 WTERMSIG(status) --》 得到 导致子进程异常</span><br><span class="line">终止的信号编号。</span><br><span class="line">一个进程终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的 PCB 还保留着，内</span><br><span class="line">核在其中保存了一些信息：如果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程</span><br><span class="line">终止的信号是哪个。这个进程的父进程可以调用 wait 或者 waitpid 获取这些信息，然后彻底清除掉</span><br><span class="line">这个进程。我们知道一个进程的退出状态可以在 shell 中用特殊变量$？查看，因为 shell 是它的父</span><br><span class="line">进程，当它终止时，shell 调用 wait 或者 waitpid 得到它的退出状态，同时彻底清除掉这个进程。</span><br><span class="line">pid_t wait(int *status)</span><br><span class="line">其中 status 是传出参数</span><br></pre></td></tr></table></figure>

<p>下面这个例子，使用 wait 来阻塞回收子进程</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215813155.png" alt="image-20230610215813155"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230610215813155.png" class title="This is an test image">

<h2 id="获取子进程退出值和异常终止信号"><a href="#获取子进程退出值和异常终止信号" class="headerlink" title="获取子进程退出值和异常终止信号"></a>获取子进程退出值和异常终止信号</h2><p>获取子进程正常终止值：<br>WIFEXITED(status) –》 为真 –》调用 WEXITSTATUS(status) –》 得到 子进程 退出值。<br>获取导致子进程异常终止信号：<br>WIFSIGNALED(status) –》 为真 –》调用 WTERMSIG(status) –》 得到 导致子进程异常<br>终止的信号编号。</p>
<p>下面这个代码捕获程序异常终止的信号并打印：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;unistd.h&gt;</span><br><span class="line">4. #include &lt;sys/wait.h&gt;</span><br><span class="line">5.</span><br><span class="line">6. int main(void)</span><br><span class="line">7. &#123;</span><br><span class="line">8. pid_t pid, wpid;</span><br><span class="line">9. int status;</span><br><span class="line">10.</span><br><span class="line">11. pid = fork();</span><br><span class="line">12. if (pid == 0) &#123;</span><br><span class="line">13. printf(&quot;---child, my id= %d, going to sleep 10s\n&quot;, getpid());</span><br><span class="line">14. sleep(10);</span><br><span class="line">15. printf(&quot;-------------child die--------------\n&quot;);</span><br><span class="line">16. return 73;</span><br><span class="line">17. &#125; else if (pid &gt; 0) &#123;</span><br><span class="line">18. //wpid = wait(NULL); // 不关心子进程结束原因</span><br><span class="line">19. wpid = wait(&amp;status); // 如果子进程未终止,父进程阻塞在这个函数上</span><br><span class="line">20. if (wpid == -1) &#123;</span><br><span class="line">21. perror(&quot;wait error&quot;);</span><br><span class="line">22. exit(1);</span><br><span class="line">23. &#125;</span><br><span class="line">24. if (WIFEXITED(status)) &#123; //为真,说明子进程正常终止.</span><br><span class="line">25. printf(&quot;child exit with %d\n&quot;, WEXITSTATUS(status));</span><br><span class="line">26.</span><br><span class="line">27. &#125;</span><br><span class="line">28. if (WIFSIGNALED(status)) &#123; //为真,说明子进程是被信号终止.</span><br><span class="line">29.</span><br><span class="line">30. printf(&quot;child kill with signal %d\n&quot;, WTERMSIG(status));</span><br><span class="line">31. &#125;</span><br><span class="line">32.</span><br><span class="line">33. printf(&quot;------------parent wait finish: %d\n&quot;, wpid);</span><br><span class="line">34. &#125; else &#123;</span><br><span class="line">35. perror(&quot;fork&quot;);</span><br><span class="line">36. return 1;</span><br><span class="line">37. &#125;</span><br><span class="line">38.</span><br><span class="line">39. return 0;</span><br><span class="line">40. &#125;</span><br></pre></td></tr></table></figure>

<p>下面发送信号使得子进程异常退出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 id</span><br></pre></td></tr></table></figure>

<h2 id="waitpid-回收子进程"><a href="#waitpid-回收子进程" class="headerlink" title="waitpid 回收子进程"></a>waitpid 回收子进程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">waitpid 函数： 指定某一个进程进行回收。可以设置非阻塞。</span><br><span class="line">waitpid(-1, &amp;status, 0) == wait(&amp;status);</span><br><span class="line">	pid_t waitpid(pid_t pid, int *status, int options)</span><br><span class="line">	参数：</span><br><span class="line">		pid：指定回收某一个子进程 pid</span><br><span class="line">		&gt; 0: 待回收的子进程 pid</span><br><span class="line">		-1：任意子进程</span><br><span class="line">		0：同组的子进程。</span><br><span class="line">		status：（传出） 回收进程的状态。</span><br><span class="line">		options：WNOHANG 指定回收方式为，非阻塞。</span><br><span class="line">	返回值：</span><br><span class="line">		&gt; 0 : 表成功回收的子进程 pid</span><br><span class="line">		0 : 函数调用时， 参 3 指定了 WNOHANG， 并且，没有子进程结束。</span><br><span class="line">		-1: 失败。errno</span><br><span class="line">	一次 wait/waitpid 函数调用，只能回收一个子进程。上一个例子，父进程产生了 5 个子进程，wait 会随机回收一个，捡到哪个算哪个。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ps ajx –&gt; pid ppid gid sid</p>
<p>在演示回收指定子进程的代码时出了问题，这里问题原因在于指定子进程的 pid 传递。父进程里 的 pid 变量和子进程 pid 变量并不是同一个。子进程结束时，父进程的 pid 还是原来的 0。 </p>
<p>原来的代码没有使用 fork 的返回值，导致父进程没有得到指定回收子进程的 pid。</p>
<p>默认情况下，父进程 fork 出来的子进程都属于同一个组。</p>
<p>错误代码如下图所示，它不能回收指定的第 3 个子进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">1. //指定回收一个子进程错误示例</span><br><span class="line">2. #include &lt;stdio.h&gt;</span><br><span class="line">3. #include &lt;stdlib.h&gt;</span><br><span class="line">4. #include &lt;string.h&gt;</span><br><span class="line">5. #include &lt;unistd.h&gt;</span><br><span class="line">6. #include &lt;sys/wait.h&gt;</span><br><span class="line">7. #include &lt;pthread.h&gt;</span><br><span class="line">8.</span><br><span class="line">9. int main(int argc, char *argv[])</span><br><span class="line">10. &#123;</span><br><span class="line">11. int i;</span><br><span class="line">12. pid_t pid, wpid;</span><br><span class="line">13.</span><br><span class="line">14. for (i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">15. if (fork() == 0) &#123; // 循环期间, 子进程不 fork</span><br><span class="line">16. if (i == 2) &#123;</span><br><span class="line">17. pid = getpid();</span><br><span class="line">18. printf(&quot;------pid = %d\n&quot;, pid);</span><br><span class="line">19. &#125;</span><br><span class="line">20. break;</span><br><span class="line">21. &#125;</span><br><span class="line">22. &#125;</span><br><span class="line">23.</span><br><span class="line">24. if (5 == i) &#123; // 父进程, 从 表达式 2 跳出</span><br><span class="line">25. sleep(5);</span><br><span class="line">26.</span><br><span class="line">27. //wait(NULL); // 一次 wait/waitpid 函数调用,只能回收一个子进程.</span><br><span class="line">28. //wpid = waitpid(-1, NULL, WNOHANG); //回收任意子进程,没有结束的子进程,父进程直接返回 0</span><br><span class="line">29. //wpid = waitpid(pid, NULL, WNOHANG); //指定一个进程回收</span><br><span class="line">30.</span><br><span class="line">31. printf(&quot;------in parent , before waitpid, pid= %d\n&quot;, pid);</span><br><span class="line">32. wpid = waitpid(pid, NULL, 0); //指定一个进程回收，这里因为是进的父进程，没有pid的值</span><br><span class="line">33. if (wpid == -1) &#123;</span><br><span class="line">34. perror(&quot;waitpid error&quot;);</span><br><span class="line">35. exit(1);</span><br><span class="line">36. &#125;</span><br><span class="line">37. printf(&quot;I&#x27;m parent, wait a child finish : %d \n&quot;, wpid);</span><br><span class="line">38.</span><br><span class="line">39. &#125; else &#123; // 子进程, 从 break 跳出</span><br><span class="line">40. sleep(i);</span><br><span class="line">41. printf(&quot;I&#x27;m %dth child, pid= %d\n&quot;, i+1, getpid());</span><br><span class="line">42. &#125;</span><br><span class="line">43.</span><br><span class="line">44. return 0;</span><br><span class="line">45. &#125;</span><br></pre></td></tr></table></figure>

<p>这个代码错误如之前所述，父进程里的 pid 还是 0，因为父进程里没有获取指定子进程的 pid， 于是父进程里的 pid 还保持默认值。</p>
<p>下面是正确的示例，循环 fork 出 5 个子进程，并回收指定的子进程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;sys/wait.h&gt;</span><br><span class="line">6. #include &lt;pthread.h&gt;</span><br><span class="line">7.</span><br><span class="line">8.</span><br><span class="line">9. int main(int argc, char *argv[])</span><br><span class="line">10. &#123;</span><br><span class="line">11. int i;</span><br><span class="line">12. pid_t pid, wpid, tmpid;</span><br><span class="line">13.</span><br><span class="line">14. for (i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">15. pid = fork();</span><br><span class="line">16. if (pid == 0) &#123; // 循环期间, 子进程不 fork</span><br><span class="line">17. break;</span><br><span class="line">18. &#125;</span><br><span class="line">19. if (i == 2) &#123;//这里是父进程</span><br><span class="line">20. tmpid = pid;</span><br><span class="line">21. printf(&quot;--------pid = %d\n&quot;, tmpid);</span><br><span class="line">22. &#125;</span><br><span class="line">23. &#125;</span><br><span class="line">24.</span><br><span class="line">25. if (5 == i) &#123; // 父进程, 从 表达式 2 跳出</span><br><span class="line">26. // sleep(5);</span><br><span class="line">27.</span><br><span class="line">28. //wait(NULL); // 一次 wait/waitpid 函数调用,只能回收一个子进程.</span><br><span class="line">29. //wpid = waitpid(-1, NULL, WNOHANG); //回收任意子进程,没有结束的子进程,父进程直接返回 0</span><br><span class="line">30. //wpid = waitpid(tmpid, NULL, 0); //指定一个进程回收, 阻塞等待</span><br><span class="line">31. printf(&quot;i am parent , before waitpid, pid = %d\n&quot;, tmpid);</span><br><span class="line">32.</span><br><span class="line">33. //wpid = waitpid(tmpid, NULL, WNOHANG); //指定一个进程回收, 不阻塞</span><br><span class="line">34. wpid = waitpid(tmpid, NULL, 0); //指定一个进程回收, 阻塞回收</span><br><span class="line">35. if (wpid == -1) &#123;</span><br><span class="line">36. perror(&quot;waitpid error&quot;);</span><br><span class="line">37. exit(1);</span><br><span class="line">38. &#125;</span><br><span class="line">39. printf(&quot;I&#x27;m parent, wait a child finish : %d \n&quot;, wpid);</span><br><span class="line">40.</span><br><span class="line">41. &#125; else &#123; // 子进程, 从 break 跳出</span><br><span class="line">42. sleep(i);</span><br><span class="line">43. printf(&quot;I&#x27;m %dth child, pid= %d\n&quot;, i+1, getpid());</span><br><span class="line">44. &#125;</span><br><span class="line">45.</span><br><span class="line">46. return 0;</span><br><span class="line">47. &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>指定回收的第三个进程，就回收的第三个。这里实现由两种，一个是阻塞等待回收指定 进程，一个是非阻塞，但是用 sleep 延时父进程，以保证待回收的指定子进程已经执行结束。上面这 个代码使用的阻塞回收，这个方案的问题在于终端提示符会和输出混杂在一起。使用非阻塞回收 +延时的方法，这样终端提示符就不会混在输出里。</p>
<h2 id="waitpid-回收多个子进程"><a href="#waitpid-回收多个子进程" class="headerlink" title="waitpid 回收多个子进程"></a>waitpid 回收多个子进程</h2><p>一次 wait&#x2F;waitpid 函数调用，只能回收一个子进程。上一个例子，父进程产生了 5 个子进程， wait 会随机回收一个，捡到哪个算哪个</p>
<p>总结： wait、waitpid 一次调用，回收一个子进程。 想回收多个。while</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if (5 == i) &#123; // 父进程, 从 表达式 2 跳出</span><br><span class="line"> 	/* </span><br><span class="line"> 	while ((wpid = waitpid(-1, NULL, 0))) &#123; // 使用阻塞方式回收子进程</span><br><span class="line">		printf(&quot;wait child %d \n&quot;, wpid);</span><br><span class="line">	&#125;</span><br><span class="line">	*/</span><br><span class="line">	while ((wpid = waitpid(-1, NULL, WNOHANG)) != -1) &#123; //使用非阻塞方式,回收子进程.</span><br><span class="line">		if (wpid &gt; 0) &#123;</span><br><span class="line">			printf(&quot;wait child %d \n&quot;, wpid);</span><br><span class="line">		&#125; else if (wpid == 0) &#123;</span><br><span class="line">			sleep(1);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程间通信常见方式"><a href="#进程间通信常见方式" class="headerlink" title="进程间通信常见方式"></a>进程间通信常见方式</h2><p>IPC(InterProcess Communication)进程间通信</p>
<p>进程间通信的常用方式，特征： </p>
<p>管道：简单 </p>
<p>信号：开销小 </p>
<p>mmap 映射：非血缘关系进程间 </p>
<p>socket（本地套接字）：稳定</p>
<h2 id="管道的特质"><a href="#管道的特质" class="headerlink" title="管道的特质"></a>管道的特质</h2><p>管道：<br>实现原理： 内核借助环形队列机制，使用内核缓冲区实现。<br>特质； </p>
<p>​	1. 伪文件</p>
<ol start="2">
<li>管道中的数据只能一次读取。</li>
<li>数据在管道中，只能单向流动。</li>
</ol>
<p>局限性：</p>
<ol>
<li>自己写，不能自己读。</li>
<li>数据不可以反复读。</li>
<li>半双工通信。</li>
<li>血缘关系进程间可用。</li>
</ol>
<h2 id="管道的基本用法"><a href="#管道的基本用法" class="headerlink" title="管道的基本用法"></a>管道的基本用法</h2><p>pipe 函数： 创建，并打开管道。<br>    int pipe(int fd[2]);<br>        参数： fd[0]: 读端。<br>                    fd[1]: 写端。<br>        返回值： 成功： 0<br>                        失败： -1 errno</p>
<p>一个管道通信的示例，父进程往管道里写，子进程从管道读，然后打印读取的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;errno.h&gt;</span><br><span class="line">6. #include &lt;pthread.h&gt;</span><br><span class="line">7.</span><br><span class="line">8. void sys_err(const char *str)</span><br><span class="line">9. &#123;</span><br><span class="line">10. perror(str);</span><br><span class="line">11. exit(1);</span><br><span class="line">12. &#125;</span><br><span class="line">13.</span><br><span class="line">14. int main(int argc, char *argv[])</span><br><span class="line">15. &#123;</span><br><span class="line">16. int ret;</span><br><span class="line">17. int fd[2];</span><br><span class="line">18. pid_t pid;</span><br><span class="line">19.</span><br><span class="line">20. char *str = &quot;hello pipe\n&quot;;</span><br><span class="line">21. char buf[1024];</span><br><span class="line">22.</span><br><span class="line">23. ret = pipe(fd);</span><br><span class="line">24. if (ret == -1)</span><br><span class="line">25. sys_err(&quot;pipe error&quot;);</span><br><span class="line">26.</span><br><span class="line">27. pid = fork();</span><br><span class="line">28. if (pid &gt; 0) &#123;</span><br><span class="line">29. close(fd[0]); // 父进程关闭读段</span><br><span class="line">30. //sleep(3);</span><br><span class="line">31. write(fd[1], str, strlen(str));</span><br><span class="line">32. close(fd[1]);</span><br><span class="line">33. &#125; else if (pid == 0) &#123;</span><br><span class="line">34. close(fd[1]); // 子进程关闭写段</span><br><span class="line">35. ret = read(fd[0], buf, sizeof(buf));</span><br><span class="line">36. printf(&quot;child read ret = %d\n&quot;, ret);</span><br><span class="line">37. write(STDOUT_FILENO, buf, ret);</span><br><span class="line">38.</span><br><span class="line">39. close(fd[0]);</span><br><span class="line">40. &#125;</span><br><span class="line">41.</span><br><span class="line">42. return 0;</span><br><span class="line">43. &#125;</span><br></pre></td></tr></table></figure>

<h2 id="管道读写行为"><a href="#管道读写行为" class="headerlink" title="管道读写行为"></a>管道读写行为</h2><p>管道的读写行为：<br>读管道：</p>
<ol>
<li>管道有数据，read 返回实际读到的字节数。</li>
<li>管道无数据： 1）无写端，read 返回 0 （类似读到文件尾）<br> 2）有写端，read 阻塞等待。</li>
</ol>
<p>写管道：</p>
<ol>
<li>无读端， 异常终止。 （SIGPIPE 导致的）</li>
<li>有读端： 1） 管道已满， 阻塞等待<br> 2） 管道未满， 返回写出的字节个数。</li>
</ol>
<p>普通文件，目录，软链接，这三个要占磁盘空间 </p>
<p>管道，套接字，字符设备，块设备，不占磁盘空间，伪文件</p>
<p>磁盘访问需要open和read,内存访问用地址，即使用指针访问。</p>
<h2 id="父子进程-lswc-l"><a href="#父子进程-lswc-l" class="headerlink" title="父子进程 lswc-l"></a>父子进程 lswc-l</h2><p>练习：使用管道实现父子进程间通信，完成：ls | wc -l 假定父进程实现 ls，子进程实现 wc<br>ls 命令正常会将结果集写到 stdout，但现在会写入管道写端<br>wc -l 命令正常应该从 stdin 读取数据，但此时会从管道的读端读。<br>要用到 pipe dup2 exec<br>代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;errno.h&gt;</span><br><span class="line">6. #include &lt;pthread.h&gt;</span><br><span class="line">7.</span><br><span class="line">8. void sys_err(const char *str)</span><br><span class="line">9. &#123;</span><br><span class="line">10. perror(str);</span><br><span class="line">11. exit(1);</span><br><span class="line">12. &#125;</span><br><span class="line">13. int main(int argc, char *argv[])</span><br><span class="line">14. &#123;</span><br><span class="line">15. int fd[2];</span><br><span class="line">16. int ret;</span><br><span class="line">17. pid_t pid;</span><br><span class="line">18.</span><br><span class="line">19. ret = pipe(fd); // 父进程先创建一个管道,持有管道的读端和写端</span><br><span class="line">20. if (ret == -1) &#123;</span><br><span class="line">21. sys_err(&quot;pipe error&quot;);</span><br><span class="line">22. &#125;</span><br><span class="line">23.</span><br><span class="line">24. pid = fork(); // 子进程同样持有管道的读和写端</span><br><span class="line">25. if (pid == -1) &#123;</span><br><span class="line">26. sys_err(&quot;fork error&quot;);</span><br><span class="line">27. &#125;</span><br><span class="line">28. else if (pid &gt; 0) &#123; // 父进程 读, 关闭写端</span><br><span class="line">29. close(fd[1]);</span><br><span class="line">30. dup2(fd[0], STDIN_FILENO); // 重定向 stdin 到 管道的 读端</span><br><span class="line">31. execlp(&quot;wc&quot;, &quot;wc&quot;, &quot;-l&quot;, NULL); // 执行 wc -l 程序</span><br><span class="line">32. sys_err(&quot;exclp wc error&quot;);</span><br><span class="line">33. &#125;</span><br><span class="line">34. else if (pid == 0) &#123;</span><br><span class="line">35. close(fd[0]);</span><br><span class="line">36. dup2(fd[1], STDOUT_FILENO); // 重定向 stdout 到 管道写端</span><br><span class="line">37. execlp(&quot;ls&quot;, &quot;ls&quot;, NULL); // 子进程执行 ls 命令</span><br><span class="line">38. sys_err(&quot;exclp ls error&quot;);</span><br><span class="line">39. &#125;</span><br><span class="line">40.</span><br><span class="line">41. return 0;</span><br><span class="line">42. &#125;</span><br></pre></td></tr></table></figure>

<h2 id="兄弟进程间通信"><a href="#兄弟进程间通信" class="headerlink" title="兄弟进程间通信"></a>兄弟进程间通信</h2><p>练习题：兄弟进程间通信<br>兄：ls<br>弟：wc -l<br>父：等待回收子进程<br>要求，使用循环创建 N 个子进程模型创建兄弟进程，使用循环因子 i 标识，注意管道读写行为<br>测试：<br>是否允许，一个 pipe 有一个写端多个读端 可<br>是否允许，一个 pipe 有多个写端一个读端 可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;sys/wait.h&gt;</span><br><span class="line">5. #include &lt;unistd.h&gt;</span><br><span class="line">6. #include &lt;errno.h&gt;</span><br><span class="line">7. #include &lt;pthread.h&gt;</span><br><span class="line">8.</span><br><span class="line">9. void sys_err(const char *str)</span><br><span class="line">10. &#123;</span><br><span class="line">11. perror(str);</span><br><span class="line">12. exit(1);</span><br><span class="line">13. &#125;</span><br><span class="line">14. int main(int argc, char *argv[])</span><br><span class="line">15. &#123;</span><br><span class="line">16. int fd[2];</span><br><span class="line">17. int ret, i;</span><br><span class="line">18. pid_t pid;</span><br><span class="line">19.</span><br><span class="line">20. ret = pipe(fd);</span><br><span class="line">21. if (ret == -1) &#123;</span><br><span class="line">22. sys_err(&quot;pipe error&quot;);</span><br><span class="line">23. &#125;</span><br><span class="line">24.</span><br><span class="line">25. for(i = 0; i &lt; 2; i++) &#123; // 表达式 2 出口,仅限父进程使用</span><br><span class="line">26. pid = fork();</span><br><span class="line">27. if (pid == -1) &#123;</span><br><span class="line">28. sys_err(&quot;fork error&quot;);</span><br><span class="line">29. &#125;</span><br><span class="line">30. if (pid == 0) // 子进程,出口</span><br><span class="line">31. break;</span><br><span class="line">32. &#125;</span><br><span class="line">33.</span><br><span class="line">34. if (i == 2) &#123; // 父进程 . 不参与管道使用.</span><br><span class="line">35. close(fd[0]); // 关闭管道的 读端/写端.</span><br><span class="line">36. close(fd[1]);</span><br><span class="line">37.</span><br><span class="line">38. wait(NULL); // 回收子进程</span><br><span class="line">39. wait(NULL);</span><br><span class="line">40. &#125; else if (i == 0) &#123; // 哥哥</span><br><span class="line">41. close(fd[0]);</span><br><span class="line">42. dup2(fd[1], STDOUT_FILENO); // 重定向 stdout</span><br><span class="line">43. execlp(&quot;ls&quot;, &quot;ls&quot;, NULL);</span><br><span class="line">44. sys_err(&quot;exclp ls error&quot;);</span><br><span class="line">45. &#125; else if (i == 1) &#123; //弟弟</span><br><span class="line">46. close(fd[1]);</span><br><span class="line">47. dup2(fd[0], STDIN_FILENO); // 重定向 stdin</span><br><span class="line">48. execlp(&quot;wc&quot;, &quot;wc&quot;, &quot;-l&quot;, NULL);</span><br><span class="line">49. sys_err(&quot;exclp wc error&quot;);</span><br><span class="line">50. &#125;</span><br><span class="line">51.</span><br><span class="line">52. return 0;</span><br><span class="line">53. &#125;</span><br></pre></td></tr></table></figure>

<p>这个代码需要注意一点，父进程不使用管道，所以一定要关闭父进程的管道，保证数据单向流动。</p>
<h2 id="多个读写端操作管道和管道缓冲区大小"><a href="#多个读写端操作管道和管道缓冲区大小" class="headerlink" title="多个读写端操作管道和管道缓冲区大小"></a>多个读写端操作管道和管道缓冲区大小</h2><p>下面是一个父进程读，俩子进程写的例子，也就是一个读端多个写端。需要调控写入顺序才行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;unistd.h&gt;</span><br><span class="line">3. #include &lt;sys/wait.h&gt;</span><br><span class="line">4. #include &lt;string.h&gt;</span><br><span class="line">5. #include &lt;stdlib.h&gt;</span><br><span class="line">6.</span><br><span class="line">7. int main(void)</span><br><span class="line">8. &#123;</span><br><span class="line">9. pid_t pid;</span><br><span class="line">10. int fd[2], i, n;</span><br><span class="line">11. char buf[1024];</span><br><span class="line">12.</span><br><span class="line">13. int ret = pipe(fd);</span><br><span class="line">14. if(ret == -1)&#123;</span><br><span class="line">15. perror(&quot;pipe error&quot;);</span><br><span class="line">16. exit(1);</span><br><span class="line">17. &#125;</span><br><span class="line">18.</span><br><span class="line">19. for(i = 0; i &lt; 2; i++)&#123;</span><br><span class="line">20. if((pid = fork()) == 0)</span><br><span class="line">21. break;</span><br><span class="line">22. else if(pid == -1)&#123;</span><br><span class="line">23. perror(&quot;pipe error&quot;);</span><br><span class="line">24. exit(1);</span><br><span class="line">25. &#125;</span><br><span class="line">26. &#125;</span><br><span class="line">27.</span><br><span class="line">28. if (i == 0) &#123;</span><br><span class="line">29. close(fd[0]);</span><br><span class="line">30. write(fd[1], &quot;1.hello\n&quot;, strlen(&quot;1.hello\n&quot;));</span><br><span class="line">31. &#125; else if(i == 1) &#123;</span><br><span class="line">32. close(fd[0]);</span><br><span class="line">33. write(fd[1], &quot;2.world\n&quot;, strlen(&quot;2.world\n&quot;));</span><br><span class="line">34. &#125; else &#123;</span><br><span class="line">35. close(fd[1]); //父进程关闭写端,留读端读取数据</span><br><span class="line">36. sleep(1);</span><br><span class="line">37. n = read(fd[0], buf, 1024); //从管道中读数据</span><br><span class="line">38. write(STDOUT_FILENO, buf, n);</span><br><span class="line">39.</span><br><span class="line">40. for(i = 0; i &lt; 2; i++) //两个儿子 wait 两次</span><br><span class="line">41. wait(NULL);</span><br><span class="line">42. &#125;</span><br><span class="line">43.</span><br><span class="line">44. return 0;</span><br><span class="line">45. &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个例子需要注意，父进程必须等一下，不然可能俩子进程只写了一个，父进程就读完跑路了。 </p>
<p>管道大小，默认 4096</p>
<h2 id="命名管道-fifo-的创建和原理图"><a href="#命名管道-fifo-的创建和原理图" class="headerlink" title="命名管道 fifo 的创建和原理图"></a>命名管道 fifo 的创建和原理图</h2><p>管道的优劣：<br>优点：简单，相比信号，套接字实现进程通信，简单很多<br>缺点：1.只能单向通信，双向通信需建立两个管道<br> 2.只能用于有血缘关系的进程间通信。该问题后来使用 fifo 命名管道解决。</p>
<p>fifo 管道：可以用于无血缘关系的进程间通信。<br>命名管道： mkfifo<br>无血缘关系进程间通信：<br>读端，open fifo O_RDONLY<br>写端，open fifo O_WRONLY<br>fifo 操作起来像文件<br>下面的代码创建一个 fifo：</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612214052445.png" alt="image-20230612214052445"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612214052445.png" class title="This is an test image">

<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612215028041.png" alt="image-20230612215028041"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612215028041.png" class title="This is an test image">

<h2 id="fifo-实现非血缘关系进程间通信"><a href="#fifo-实现非血缘关系进程间通信" class="headerlink" title="fifo 实现非血缘关系进程间通信"></a>fifo 实现非血缘关系进程间通信</h2><p>下面这个例子，一个写 fifo，一个读 fifo，操作起来就像文件一样的：</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612214842946.png" alt="image-20230612214842946"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612214842946.png" class title="This is an test image">

<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612214916095.png" alt="image-20230612214916095"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612214916095.png" class title="This is an test image">

<p>编译执行，如图：<img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612215107477.png" alt="image-20230612215107477"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230612215107477.png" class title="This is an test image">

<p>测试一个写端多个读端的时候，由于数据一旦被读走就没了，所以多个读端的并集才是写端的写 入数据。</p>
<h2 id="文件用于进程间通信"><a href="#文件用于进程间通信" class="headerlink" title="文件用于进程间通信"></a>文件用于进程间通信</h2><p>文件实现进程间通信： 打开的文件是内核中的一块缓冲区。多个无血缘关系的进程，可以同时访问该文件。</p>
<p><strong>socket套接字也是一种文件格式，和管道文件一样，它是一种伪文件</strong>，存在于内核的缓冲区中，大小不变，一直是0。</p>
<h2 id="mmap-函数原型"><a href="#mmap-函数原型" class="headerlink" title="mmap 函数原型"></a>mmap 函数原型</h2><p>磁盘访问需要open和read,内存访问用地址，即使用指针访问。</p>
<p>内核缓冲区是位于内核空间的一块特定内存区域，用于临时存储和处理数据。在 Linux 内核中，访问内核缓冲区通常需要使用相应的系统调用或函数。一种常见的方式是使用 I&#x2F;O 操作函数来读取或写入内核缓冲区的内容。例如，在文件 I&#x2F;O 中，我们可以使用系统调用 <code>read()</code> 和 <code>write()</code> 来分别从内核缓冲区读取数据到用户空间或将数据从用户空间写入到内核缓冲区。</p>
<p>存储映射 I&#x2F;O(Memory-mapped I&#x2F;O) 使一个磁盘文件与存储空间中的一个缓冲区相映射。于是从缓冲区中取数据，就相当于读文件中的相应字节。与此类似，将数据存入缓冲区，则相应的字节就自动写入文件。这样，就可在不使用 read 和 write 函数的情况下，使地址指针完成 I&#x2F;O 操作。<br>使用这种方法，首先应该通知内核，将一个指定文件映射到存储区域中。这个映射工作可以通过mmap 函数来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</span><br><span class="line">创建共享内存映射</span><br><span class="line">参数：</span><br><span class="line">    addr： 指定映射区的首地址。通常传 NULL，表示让系统自动分配</span><br><span class="line">    length：共享内存映射区的大小。（&lt;= 文件的实际大小）</span><br><span class="line">    prot： 共享内存映射区的读写属性。PROT_READ、PROT_WRITE、PROT_READ|PROT_WRITE</span><br><span class="line">    flags： 标注共享内存的共享属性。MAP_SHARED、MAP_PRIVATE</span><br><span class="line">    fd: 用于创建共享内存映射区的那个文件的 文件描述符。</span><br><span class="line">    offset：默认 0，表示映射文件全部。偏移位置。需是 4k 的整数倍。</span><br><span class="line">返回值：</span><br><span class="line">    成功：映射区的首地址。</span><br><span class="line">    失败：MAP_FAILED (void*(-1))， errno</span><br><span class="line">   flags 里面的 shared 意思是修改会反映到磁盘上</span><br><span class="line">     private 表示修改不反映到磁盘上</span><br><span class="line"> int munmap(void *addr, size_t length); 释放映射区。</span><br><span class="line">    addr：mmap 的返回值</span><br><span class="line">    length：大小</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>出现段错误，gdb然后run停止的地方就是段错误。</p>
<h2 id="mmap-建立映射区"><a href="#mmap-建立映射区" class="headerlink" title="mmap 建立映射区"></a>mmap 建立映射区</h2><p>下面这个示例代码，使用 mmap 创建一个映射区（共享内存），并往映射区里写入内容：</p>
<p><img src="/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230614113240142.png" alt="image-20230614113240142"></p>
<img src="/2023/06/01/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/image-20230614113240142.png" class title="This is an test image">

<h2 id="mmap-使用注意事项"><a href="#mmap-使用注意事项" class="headerlink" title="mmap 使用注意事项"></a>mmap 使用注意事项</h2><p>使用注意事项：</p>
<ol>
<li>用于创建映射区的文件大小为 0，实际指定非 0 大小创建映射区，出 “总线错误”。</li>
<li>用于创建映射区的文件大小为 0，实际制定 0 大小创建映射区， 出 “无效参数”。</li>
<li>用于创建映射区的文件读写属性为，只读。映射区属性为 读、写。 出 “无效参数”。</li>
<li>创建映射区，需要 read 权限。当访问权限指定为 “共享”MAP_SHARED 时， mmap 的读写权限，应该 &lt;&#x3D;文件的 open 权限。 只写不行。</li>
<li>文件描述符 fd，在 mmap 创建映射区完成即可关闭。后续访问文件，用 地址访问。</li>
<li>offset 必须是 4096 的整数倍。（MMU 映射的最小单位 4k ）</li>
<li>对申请的映射区内存，不能越界访问。</li>
<li>munmap 用于释放的 地址，必须是 mmap 申请返回的地址。</li>
<li>映射区访问权限为 “私有”MAP_PRIVATE, 对内存所做的所有修改，只在内存有效，不会反应到物理磁盘上。</li>
<li>映射区访问权限为 “私有”MAP_PRIVATE, 只需要 open 文件时，有读权限，用于创建映射区即可。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mmap 函数的保险调用方式：</span><br><span class="line">1. fd = open（&quot;文件名&quot;， O_RDWR）;</span><br><span class="line">2. mmap(NULL, 有效文件大小， PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);</span><br></pre></td></tr></table></figure>

<p>mmap 总结 </p>
<ol>
<li>创建映射区的过程中，隐含着一次对映射文件的读操作</li>
<li>当 MAP_SHARED 时，要求：映射区的权限应该&lt;&#x3D;文件打开的权限（出于对映射区的保护）。而MAP_PRIVATE 则无所谓，因为 mmap 中的权限是对内存的限制</li>
<li>映射区的释放与文件关闭无关。只要映射建立成功，文件可以立即关闭</li>
<li>特别注意，当映射文件大小为 0 时，不能创建映射区。所以：用于映射的文件必须要有实际大小！！mmap 使用时常常会出现总线错误，通常是由于共享文件存储空间大小引起的。如，400 字节大小的文件，在简历映射区时，offset4096 字节，则会报出总线错误</li>
<li>munmap 传入的地址一定是 mmap 返回的地址。坚决杜绝指针++操作,会改变地址，在指针本身上操作</li>
<li>文件偏移量必须为 4K 的整数倍</li>
<li>mmap 创建映射区出错概率非常高，一定要检查返回值，确保映射区建立成功再进行后续操作。</li>
</ol>
<h2 id="父子进程间-mmap-通信"><a href="#父子进程间-mmap-通信" class="headerlink" title="父子进程间 mmap 通信"></a>父子进程间 mmap 通信</h2><p>父子进程使用 mmap 进程间通信：<br>父进程 先 创建映射区。 <code>open（ O_RDWR） mmap( MAP_SHARED );</code><br>指定 MAP_SHARED 权限<br>fork() 创建子进程。<br>一个进程读， 另外一个进程写</p>
<p>下面这段代码，父子进程 mmap 通信，共享内存是一个 int 变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;unistd.h&gt;</span><br><span class="line">4. #include &lt;fcntl.h&gt;</span><br><span class="line">5. #include &lt;sys/mman.h&gt;</span><br><span class="line">6. #include &lt;sys/wait.h&gt;</span><br><span class="line">7.</span><br><span class="line">8. int var = 100;</span><br><span class="line">9.</span><br><span class="line">10. int main(void)</span><br><span class="line">11. &#123;</span><br><span class="line">12. int *p;</span><br><span class="line">13. pid_t pid;</span><br><span class="line">14.</span><br><span class="line">15. int fd;</span><br><span class="line">16. fd = open(&quot;temp&quot;, O_RDWR|O_CREAT|O_TRUNC, 0644);</span><br><span class="line">17. if(fd &lt; 0)&#123;</span><br><span class="line">18. perror(&quot;open error&quot;);</span><br><span class="line">19. exit(1);</span><br><span class="line">20. &#125;</span><br><span class="line">21. ftruncate(fd, 4);</span><br><span class="line">22.</span><br><span class="line">23. p = (int *)mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);</span><br><span class="line">24. //p = (int *)mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);</span><br><span class="line">25. if(p == MAP_FAILED)&#123; //注意:不是 p == NULL</span><br><span class="line">26. perror(&quot;mmap error&quot;);</span><br><span class="line">27. exit(1);</span><br><span class="line">28. &#125;</span><br><span class="line">29. close(fd); //映射区建立完毕,即可关闭文件</span><br><span class="line">30.</span><br><span class="line">31. pid = fork(); //创建子进程</span><br><span class="line">32. if(pid == 0)&#123;</span><br><span class="line">33. *p = 7000; // 写共享内存</span><br><span class="line">34. var = 1000;</span><br><span class="line">35. printf(&quot;child, *p = %d, var = %d\n&quot;, *p, var);</span><br><span class="line">36. &#125; else &#123;</span><br><span class="line">37. sleep(1);</span><br><span class="line">38. printf(&quot;parent, *p = %d, var = %d\n&quot;, *p, var); // 读共享内存</span><br><span class="line">39. wait(NULL);</span><br><span class="line">40.</span><br><span class="line">41. int ret = munmap(p, 4); //释放映射区</span><br><span class="line">42. if (ret == -1) &#123;</span><br><span class="line">43. perror(&quot;munmap error&quot;);</span><br><span class="line">44. exit(1);</span><br><span class="line">45. &#125;</span><br><span class="line">46. &#125;</span><br><span class="line">47.</span><br><span class="line">48. return 0;</span><br><span class="line">49. &#125;</span><br></pre></td></tr></table></figure>

<h2 id="无血缘关系进程间-mmap-通信"><a href="#无血缘关系进程间-mmap-通信" class="headerlink" title="无血缘关系进程间 mmap 通信"></a>无血缘关系进程间 mmap 通信</h2><p>无血缘关系进程间 mmap 通信：<br>两个进程 打开同一个文件，创建映射区。<br>指定 flags 为 MAP_SHARED。<br>一个进程写入，另外一个进程读出。<br>【注意】：无血缘关系进程间通信。mmap：数据可以重复读取。<br>fifo：数据只能一次读取。</p>
<p>下面是两个无血缘关系的通信代码，先是写进程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;sys/stat.h&gt;</span><br><span class="line">3. #include &lt;sys/types.h&gt;</span><br><span class="line">4. #include &lt;fcntl.h&gt;</span><br><span class="line">5. #include &lt;unistd.h&gt;</span><br><span class="line">6. #include &lt;stdlib.h&gt;</span><br><span class="line">7. #include &lt;sys/mman.h&gt;</span><br><span class="line">8. #include &lt;string.h&gt;</span><br><span class="line">9.</span><br><span class="line">10. struct STU &#123;</span><br><span class="line">11. int id;</span><br><span class="line">12. char name[20];</span><br><span class="line">13. char sex;</span><br><span class="line">14. &#125;;</span><br><span class="line">15.</span><br><span class="line">16. void sys_err(char *str)</span><br><span class="line">17. &#123;</span><br><span class="line">18. perror(str);</span><br><span class="line">19. exit(1);</span><br><span class="line">20. &#125;</span><br><span class="line">21.</span><br><span class="line">22. int main(int argc, char *argv[])</span><br><span class="line">23. &#123;</span><br><span class="line">24. int fd;</span><br><span class="line">25. struct STU student = &#123;10, &quot;xiaoming&quot;, &#x27;m&#x27;&#125;;</span><br><span class="line">26. char *mm;</span><br><span class="line">27.</span><br><span class="line">28. if (argc &lt; 2) &#123;</span><br><span class="line">29. printf(&quot;./a.out file_shared\n&quot;);</span><br><span class="line">30. exit(-1);</span><br><span class="line">31. &#125;</span><br><span class="line">32.</span><br><span class="line">33. fd = open(argv[1], O_RDWR | O_CREAT, 0664);</span><br><span class="line">34. ftruncate(fd, sizeof(student));</span><br><span class="line">35.</span><br><span class="line">36. mm = mmap(NULL, sizeof(student), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);</span><br><span class="line">37. if (mm == MAP_FAILED)</span><br><span class="line">38. sys_err(&quot;mmap&quot;);</span><br><span class="line">39.</span><br><span class="line">40. close(fd);</span><br><span class="line">41.</span><br><span class="line">42. while (1) &#123;</span><br><span class="line">43. memcpy(mm, &amp;student, sizeof(student));</span><br><span class="line">44. student.id++;</span><br><span class="line">45. sleep(1);</span><br><span class="line">46. &#125;</span><br><span class="line">47.</span><br><span class="line">48. munmap(mm, sizeof(student));</span><br><span class="line">49.</span><br><span class="line">50. return 0;</span><br><span class="line">51. &#125;</span><br></pre></td></tr></table></figure>

<p>然后是读进程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;sys/stat.h&gt;</span><br><span class="line">3. #include &lt;fcntl.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;stdlib.h&gt;</span><br><span class="line">6. #include &lt;sys/mman.h&gt;</span><br><span class="line">7. #include &lt;string.h&gt;</span><br><span class="line">8.</span><br><span class="line">9. struct STU &#123;</span><br><span class="line">10. int id;</span><br><span class="line">11. char name[20];</span><br><span class="line">12. char sex;</span><br><span class="line">13. &#125;;</span><br><span class="line">14.</span><br><span class="line">15. void sys_err(char *str)</span><br><span class="line">16. &#123;</span><br><span class="line">17. perror(str);</span><br><span class="line">18. exit(-1);</span><br><span class="line">19. &#125;</span><br><span class="line">20.</span><br><span class="line">21. int main(int argc, char *argv[])</span><br><span class="line">22. &#123;</span><br><span class="line">23. int fd;</span><br><span class="line">24. struct STU student;</span><br><span class="line">25. struct STU *mm;</span><br><span class="line">26.</span><br><span class="line">27. if (argc &lt; 2) &#123;</span><br><span class="line">28. printf(&quot;./a.out file_shared\n&quot;);</span><br><span class="line">29. exit(-1);</span><br><span class="line">30. &#125;</span><br><span class="line">31.</span><br><span class="line">32. fd = open(argv[1], O_RDONLY);</span><br><span class="line">33. if (fd == -1)</span><br><span class="line">34. sys_err(&quot;open error&quot;);</span><br><span class="line">35.</span><br><span class="line">36. mm = mmap(NULL, sizeof(student), PROT_READ, MAP_SHARED, fd, 0);</span><br><span class="line">37. if (mm == MAP_FAILED)</span><br><span class="line">38. sys_err(&quot;mmap error&quot;);</span><br><span class="line">39.</span><br><span class="line">40. close(fd);</span><br><span class="line">41.</span><br><span class="line">42. while (1) &#123;</span><br><span class="line">43. printf(&quot;id=%d\tname=%s\t%c\n&quot;, mm-&gt;id, mm-&gt;name, mm-&gt;sex);</span><br><span class="line">44. sleep(2);</span><br><span class="line">45. &#125;</span><br><span class="line">46. munmap(mm, sizeof(student));</span><br><span class="line">47.</span><br><span class="line">48. return 0;</span><br><span class="line">49. &#125;</span><br></pre></td></tr></table></figure>

<p>如图，一读一写，问题不大。 多个写端一个读端也没问题，打开多个写进程即可，完事儿读进程会读到所有写进程写入的内容。 这里要注意一个，内容被读走之后不会消失，所以如果读进程的读取时间间隔短，它会读到很多重复内容，就是因为写进程没来得及写入新内容。</p>
<h2 id="mmap-匿名映射区"><a href="#mmap-匿名映射区" class="headerlink" title="mmap 匿名映射区"></a>mmap 匿名映射区</h2><p>匿名映射：只能用于 血缘关系进程间通信。 </p>
<p><code>p = (int *)mmap(NULL, 40, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/31/%E5%85%B3%E4%BA%8Evim%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/31/%E5%85%B3%E4%BA%8Evim%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">关于vim的一些配置问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-31 09:39:24 / 修改时间：10:42:27" itemprop="dateCreated datePublished" datetime="2023-05-31T09:39:24+08:00">2023-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/%E5%85%B3%E4%BA%8Evim%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/image-20230531094409134.png" alt="image-20230531094409134"></p>
<img src="/2023/05/31/%E5%85%B3%E4%BA%8Evim%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/image-20230531094409134.png" class title="This is an test image">

<p><img src="/%E5%85%B3%E4%BA%8Evim%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/image-20230531094456531.png" alt="image-20230531094456531"></p>
<img src="/2023/05/31/%E5%85%B3%E4%BA%8Evim%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/image-20230531094456531.png" class title="This is an test image">

<p>总之语法补全我用的是YouCompleteMe，通过插件管理器Vundle来进行安装，需要先git,再正确初始化YouCompleteMe插件的子模块</p>
<p>安装 YouCompleteMe（ycm）插件需要使用 Clang 编译器及其相关组件，因为 ycm 的自动补全和语义分析功能都是基于 Clang 提供的编译器前端实现的。具体来说，ycm 依赖以下的软件&#x2F;库：</p>
<ul>
<li>Python 解释器和开发工具包</li>
<li>Clang 编译器和其相关组件：Libclang、Clangd 等</li>
<li>CMake 构建工具</li>
<li>LLVM 代码生成框架</li>
</ul>
<p>因此，在安装 YouCompleteMe 插件之前，您需要先安装上述软件&#x2F;库，并确保它们能够正常工作。此外，YouCompleteMe 更支持直接使用系统自带的 Clang，不需要单独安装。</p>
<p><img src="/%E5%85%B3%E4%BA%8Evim%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/image-20230531094926944.png" alt="image-20230531094926944"></p>
<img src="/2023/05/31/%E5%85%B3%E4%BA%8Evim%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/image-20230531094926944.png" class title="This is an test image">

<p>如果你需要配置vim，只需在Home目录创建一个**<del>&#x2F;.vimrc**文件即可以配置vim了，如需安装插件，在</del>&#x2F;.vim目录下创建一个bundle文件夹，插件装在里面。我通过Vundle管理插件，这里YouCompleteMe插件需要前面的git，无法直接安装。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">YouCompleteMe是一个基于Python编写的Vim自动补全插件，它需要使用C++编译器和Python 3.x运行时才能正常工作。这是因为插件的代码本身是使用C++编写的，但是它需要使用Python来启动和管理插件进程，并在后台执行代码分析等任务。</span><br><span class="line"></span><br><span class="line">具体来说，ycm 依赖以下的软件/库：</span><br><span class="line"></span><br><span class="line">Python 解释器和开发工具包</span><br><span class="line">Clang 编译器和其相关组件：Libclang、Clangd 等</span><br><span class="line">CMake 构建工具</span><br><span class="line">LLVM 代码生成框架</span><br><span class="line">因此，在安装 YouCompleteMe 插件之前，您需要先安装上述软件/库，并确保它们能够正常工作。此外，YouCompleteMe 更支持直接使用系统自带的 Clang，不需要单独安装。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CMake 是一款独立的构建工具，并不是一个命令行工具，因此您需要在 CMakeLists.txt 文件中定义项目的配置、编译规则和安装步骤等。一般情况下，在终端中运行 cmake 命令来生成对应平台的 Makefile 或 IDE 项目文件，然后使用 make 或者 Visual Studio 等工具来实际编译执行。</span><br><span class="line"></span><br><span class="line">以下是你可以在终端中使用的常用 CMake 命令：</span><br><span class="line"></span><br><span class="line">cmake: 根据当前目录下的 CMakeLists.txt 文件生成 makefiles 或 IDE 项目文件；</span><br><span class="line">cmake-gui: 使用 GUI 界面进行配置和生成构建系统（Windows 和 macOS）；</span><br><span class="line">cmake --build: 调用底层构建系统（如 make 或 Visual Studio）来编译项目；</span><br><span class="line">cmake --install: 安装构建好的程序或库到指定的位置；</span><br><span class="line">ctest: 运行测试套件并输出测试结果；</span><br><span class="line">cpack: 将已构建好的项目打包成单个、可移植的二进制发行版。</span><br><span class="line">需要注意的是，上述命令中的参数和具体用法可能会因不同的项目而有所区别，请根据具体文档来参考使用。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">这个错误提示意味着您的电脑没有安装CMake或者CMake可执行文件的路径没有加入到系统环境变量中。请按照以下步骤来解决此问题：</span><br><span class="line"></span><br><span class="line">如果您没有安装CMake，请先安装最新版的CMake。您可以在Linux上使用包管理器，在终端输入以下命令：</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install cmake</span><br><span class="line">如果您使用的是其他操作系统，请参考相关文档安装CMake。</span><br><span class="line"></span><br><span class="line">确认CMake是否已经添加到系统环境变量中。如果没有，请将CMake的可执行文件路径添加到环境变量中，方法如下：</span><br><span class="line"></span><br><span class="line">在终端中运行以下命令打开.bashrc或.zshrc文件编辑器：</span><br><span class="line"></span><br><span class="line">vim ~/.bashrc # 或者vim ~/.zshrc（取决于您使用的shell）</span><br><span class="line">将以下内容添加到文件末尾，并保存退出：</span><br><span class="line"></span><br><span class="line">export PATH=&quot;$PATH:/path/to/cmake/bin&quot;</span><br><span class="line">运行以下命令使更改生效：</span><br><span class="line"></span><br><span class="line">source ~/.bashrc # 或者source ~/.zshrc</span><br><span class="line">注意替换/path/to/cmake/bin为您自己的CMake可执行文件路径。</span><br><span class="line"></span><br><span class="line">再次执行构建YouCompleteMe插件的命令，并添加--verbose参数以获取更详细的错误信息：</span><br><span class="line"></span><br><span class="line">/usr/bin/python3 /home/xiaohuilin/.vim/bundle/YouCompleteMe/third_party/ycmd/build.py --clang-completer --verbose</span><br><span class="line">总之，以上步骤可以帮助您解决在Linux上构建YouCompleteMe插件时遇到的CMake可执行文件未找到问题。</span><br></pre></td></tr></table></figure>

<p><strong>总之问题注意有些插件需要去git仓库</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NoExtraConfDetected:No.ycm_extra_conf.py file detected,so no compile flags are available.Thus no semantic support for c/c++/objcc++.GoREAD THE DOCS *NOW*,DON&#x27;T file a bug report</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这是 YouCompleteMe 编辑器插件在寻找编译器标志文件时的一种提示。YouCompleteMe 是一个为多种编辑器准备的自动补全和语义补充工具，其中包含对 C/C++/Objective-C 等语言的支持，并可以通过指定编译标志来提供更高级别的语法分析和代码补全功能。</span><br><span class="line"></span><br><span class="line">上述错误信息表明 YouCompleteMe 没有找到名为 ycm_extra_conf.py 的配置文件，因而无法获得程序的编译标志等元数据信息，从而无法提供 C/C++/Objective-C 的地道补全、跳转等方面的支持。</span><br><span class="line"></span><br><span class="line">要解决这个问题，你需要按照 YouCompleteMe 的文档说明中所讲述的，在当前项目根目录下建立名为 ycm_extra_conf.py 的文件，并进行适当的配置修改或编写，以便可以向 YouCompleteMe 提供关于项目代码及编译环境的相关信息。如果还有问题，请参考官方文档或联系相关技术支持。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">没有这个就无法判断头文件吗</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">并非如此。即使没有 ycm_extra_conf.py 文件，YouCompleteMe 也能大概率猜测出头文件的位置。不过在这种情况下，YouCompleteMe 无法准确知道要使用哪些编译选项和库依赖关系，这可能会导致代码补全、错误提示等功能出现误报或不生效。</span><br><span class="line"></span><br><span class="line">如果您不想手动编写 ycm_extra_conf.py 文件，也可以尝试通过其它方式来提供项目信息。比如使用 CMake 来生成 Makefile 或者 IDEA 项目文件，并配置好编译选项；或者按照 YouCompleteMe 的文档指导，手动在配置文件中为每个文件类型设置编译器标志和头文件搜索路径等信息。这取决于具体的开发环境和工具链。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">是的，按照 YouCompleteMe 的要求，在当前项目根目录下创建名为 ycm_extra_conf.py 的文件，并根据实际需要进行配置。</span><br><span class="line"></span><br><span class="line">以 C++ 项目为例，可以在 ycm_extra_conf.py 文件中添加如下代码来提供编译器标志。这里假设编译器为 GCC 或 Clang，并且项目包含了多个源码文件和框架库：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line"># 编译器路径（可选）</span><br><span class="line"># 如果没有安装系统默认编译器，则需要手动指定路径</span><br><span class="line"># os.environ[&#x27;CC&#x27;] = &#x27;/usr/bin/clang&#x27;</span><br><span class="line"># os.environ[&#x27;CXX&#x27;] = &#x27;/usr/bin/clang++&#x27;</span><br><span class="line"></span><br><span class="line"># 全局通用编译器标志</span><br><span class="line">flags = [</span><br><span class="line">    &#x27;-Wall&#x27;,</span><br><span class="line">    &#x27;-Wextra&#x27;,</span><br><span class="line">    # 更多需要的标志</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 针对不同文件类型设置不同的编译器标志和头文件搜索路径</span><br><span class="line">def Settings(**kwargs):</span><br><span class="line">  if kwargs[&#x27;language&#x27;] == &#x27;cfamily&#x27;:</span><br><span class="line">    filename = kwargs[&#x27;filename&#x27;]</span><br><span class="line">    ext = os.path.splitext(filename)[1]</span><br><span class="line"></span><br><span class="line">    # 源码文件</span><br><span class="line">    if ext in [&#x27;.c&#x27;, &#x27;.cpp&#x27;, &#x27;.cxx&#x27;]:</span><br><span class="line">        return &#123;</span><br><span class="line">            &#x27;flags&#x27;: flags + [</span><br><span class="line">                &#x27;-std=c++17&#x27;,   # 或其它版本</span><br><span class="line">                # 可针对特定文件设置标志</span><br><span class="line">            ],</span><br><span class="line">            &#x27;include_paths_relative_to_dir&#x27;: &#x27;./&#x27;,</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    # 框架库头文件</span><br><span class="line">    elif ext in [&#x27;.h&#x27;, &#x27;.hpp&#x27;]:</span><br><span class="line">        return &#123;</span><br><span class="line">            &#x27;flags&#x27;: flags,</span><br><span class="line">            &#x27;include_paths_relative_to_dir&#x27;: &#x27;./&#x27;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  return &#123;&#125;</span><br><span class="line">在配置好 ycm_extra_conf.py 文件后，重新加载编辑器插件或重新打开文件即可。YouCompleteMe 将会根据该文件中的设置来提供适当的代码补全和提示等功能。需要注意的是不同插件有可能采用不同的标志格式和语法。上述代码仅为示例，并不代表全部情况。具体语法和参数请参看相应插件的文档。</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/" class="post-title-link" itemprop="url">深入理解计算机系统-第五章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-29 11:40:04" itemprop="dateCreated datePublished" datetime="2023-05-29T11:40:04+08:00">2023-05-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-13 17:27:42" itemprop="dateModified" datetime="2023-06-13T17:27:42+08:00">2023-06-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第五章优化程序性能"><a href="#第五章优化程序性能" class="headerlink" title="第五章优化程序性能"></a>第五章优化程序性能</h1><p>研究程序的汇编代码表示是理解编译器以及产生的代码会如何运行的最有效手段之一。仔细研究内循环的代码是一个很好的开端，识别出降低性能的属性，例如过多的内存引用和对寄存器使用不当。从汇编代码开始，我们还可以预测什么操作会并行执行，以及它们会如何使用处理器资源。正如我们会看到的，常常通过确认关键路径(critical path)来决定执行一个循环所需要的时间(或者说，至少是一个时间下界)。所谓<strong>关键路径</strong>是在循环的反复执行过程中形成的数据相关链。然后，我们会回过头来修改源代码，试着控制编译器使之产生更有效率的实现。</p>
<p>大多数编译器，包括GCC，一直都在更新和改进，特别是在优化能力方面。一个有用的策略是只重写程序到编译器由此就能产生有效代码所需要的程度就好了。这样，能尽量避免损害代码的可读性、模块性和可移植性，就好像我们使用的是具有最低能力的编译器。同样，通过测量值和检查生成的汇编代码，反复修改源代码和分析它的性能是很有帮助的。</p>
<p>对于新手程序员来说，不断修改源代码，试图欺骗编译器产生有效的代码，看起来很奇怪，但这确实是编写很多高性能程序的方式。比较于另一种方法—用汇编语言写代码，这种间接的方法具有的优点是:虽然性能不一定是最好的，但得到的代码仍然能够在其他机器上运行。</p>
<h2 id="优化编译器的能力和局限性"><a href="#优化编译器的能力和局限性" class="headerlink" title="优化编译器的能力和局限性"></a>优化编译器的能力和局限性</h2><p>现代编译器运用复杂精细的算法来确定一个程序中计算的是什么值，以及它们是被如何使用的。然后会利用一些机会来简化表达式，在几个不同的地方使用同一个计算，以及降低一个给定的计算必须被执行的次数。大多数编译器，包括GCC，向用户提供了一些对它们所使用的优化的控制。就像在第3章中讨论过的，最简单的控制就是指定优化级别。例如，以命令行选项“-Og”调用GCC是让GCC使用一组基本的优化。以选项“-O1”或更高(如“-O2”或“-O3”)调用GCC会让它使用更大量的优化。这样做可以进一步提高程序的性能，但是也可能增加程序的规模，也可能使标准的调试工具更难对程序进行调试。我们的表述，虽然对于大多数使用GCC的软件项目来说，优化级别-O2已经成为了被接受的标准，但是还是主要考虑以优化级别-O1编译出的代码。我们特意限制了优化级别，以展示写C语言函数的不同方法如何影响编译器产生代码的效率。我们会发现可以写出的C代码，即使用-O1选项编译得到的性能，也比用可能的最高的优化等级编译一个更原始的版本得到的性能好。</p>
<p>未经优化的代码是从C语言代码到机器代码的直接翻译，通常效率明显较低。简单地使用命令行选项“-O1”，就会进行一些基本的优化。正如可以看到的，程序员不需要做什么，就会显著地提高程序性能–—超过两个数量级。通常，养成至少使用这个级别优化的习惯是很好的。(使用-Og优化级别能得到相似的性能结果。)</p>
<h3 id="用内联函数替换优化函数调用"><a href="#用内联函数替换优化函数调用" class="headerlink" title="用内联函数替换优化函数调用"></a>用内联函数替换优化函数调用</h3><p>包含函数调用的代码可以用一个称为内联函数替换(inline substitution，或者简称“内联(inlining)”)的过程进行优化，此时，将函数调用替换为函数体。</p>
<p>GCC的最近版本会尝试进行这种形式的优化，要么是被用命令行选项“-finline”指示时，要么是使用优化等级-O1或者更高的等级时。遗憾的是，GCC只尝试在单个文件中定义的函数的内联。这就意味着它将无法应用于常见的情况，即一组库函数在一个文件中被定义，却被其他文件内的函数所调用。</p>
<p>在某些情况下，最好能阻止编译器执行内联替换。一种情况是用符号调试器来评估代码，比如GDB。如果一个函数调用已经用内联替换优化过了，那么任何对这个调用进行追踪或设置断点的尝试都会失败。还有一种情况是用代码剖析的方式来评估程序性能。用内联替换消除的函数调用是无法被正确剖析的。</p>
<h2 id="理解现代处理器"><a href="#理解现代处理器" class="headerlink" title="理解现代处理器"></a>理解现代处理器</h2><p>我们会发现两种下界描述了程序的最大性能。当一系列操作必须按照严格顺序执行时，就会遇到<strong>延迟界限</strong>(latencybound)，因为在下一条指令开始之前，这条指令必须结束。当代码中的数据相关限制了处理器利用指令级并行的能力时，延迟界限能够限制程序性能。<strong>吞吐量界限</strong>(throughpubound)刻画了处理器功能单元的原始计算能力。这个界限是程序性能的终极限制。</p>
<h3 id="整体操作"><a href="#整体操作" class="headerlink" title="整体操作"></a>整体操作</h3><p>ICU从指令高速缓存(instruction cache)中读取指令，指令高速缓存是一个特殊的高速存储器，它包含最近访问的指令。通常，ICU会在当前正在执行的指令很早之前取指，这样它才有足够的时间对指令译码，并把操作发送到EU。不过，一个问题是当程序遇到分支时，程序有两个可能的前进方向。一种可能会选择分支，控制被传递到分支目标。另一种可能是，不选择分支，控制被传递到指令序列的下一条指令。现代处理器采用了一种称为<strong>分支预测</strong>(branch prediction)的技术，处理器会猜测是否会选择分支，同时还预测分支的目标地址。使用<strong>投机执行</strong>(speculative execution)的技术，处理器会开始取出位于它预测的分支会跳到的地方的指令，并对指令译码，甚至在它确定分支预测是否正确之前就开始执行这些操作。如果过后确定分支预测错误，会将状态重新设置到分支点的状态，并开始取出和执行另一个方向上的指令。标记为取指控制的块包括分支预测，以完成确定取哪些指令的任务。</p>
<p>使用<strong>投机执行</strong>技术对操作求值，但是最终结果不会存放在程序寄存器或数据内存中，直到处理器能确定应该实际执行这些指令。分支操作被送到EU，不是确定分支该往哪里去，而是确定分支预测是否正确。如果预测错误，EU会丢弃分支点之后计算出来的结果。它还会发信号给分支单元，说预测是错误的，并指出正确的分支目的。在这种情况中，分支单元开始在新的位置取指。这样的预测错误会导致很大的性能开销。在可以取出新指令、译码和发送到执行单元之前，要花费一点时间。</p>
<p>控制操作数在执行单元间传送的最常见的机制称为<strong>寄存器重命名</strong>(register renaming)。当一条更新寄存器r的指令译码时，产生标记t，得到一个指向该操作结果的唯一的标识符。条目(r，t)被加入到一张表中，该表维护着每个程序寄存器r与会更新该寄存器的操作的标记t之间的关联。当随后以寄存器r作为操作数的指令译码时，发送到执行单元的操作会包含t作为操作数源的值。当某个执行单元完成第一个操作时，会生成-一个结果(v，t)，指明标记为t的操作产生值v。所有等待t作为源的操作都能使用v作为源值，这就是一种形式的数据转发。通过这种机制，值可以从一个操作直接转发到另一个操作，而不是写到寄存器文件再读出来，使得第二个操作能够在第一个操作完成后尽快开始。重命名表只包含关于有未进行写操作的寄存器条目。当一条被译码的指令需要寄存器r，而又没有标记与这个寄存器相关联，那么可以直接从寄存器文件中获取这个操作数。<strong>有了寄存器重命名，即使只有在处理器确定了分支结果之后才能更新寄存器，也可以预测着执行操作的整个序列。</strong></p>
<p>最小化一个计算中的操作数量不一定会提高它的性能。</p>
<p>CPE即是需要的时钟周期。</p>
<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230610161658961.png" alt="image-20230610161658961"></p>
<img src="/2023/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230610161658961.png" class title="This is an test image">

<p>延迟界限给出了任何必须按照严格顺序完成合并运算的函数所需要的最小CPE值。根据功能单元产生结果的最大速率，吞吐量界限给出了CPE的最小界限。例如，因为只有一个整数乘法器，它的发射时间为1个时钟周期，处理器不可能支持每个时钟周期大于1条乘法的速度。另-一方面，四个功能单元都可以执行整数加法，处理器就有可能持续每个周期执行4个操作的速率。不幸的是，因为需要从内存读数据，这造成了另一个吞吐量界限。两个加载单元限制了处理器每个时钟周期最多只能读取两个数据值，从而使得吞吐量界限为0.50。</p>
<h2 id="让编译器展开循环"><a href="#让编译器展开循环" class="headerlink" title="让编译器展开循环"></a>让编译器展开循环</h2><p>编译器可以很容易地执行循环展开。只要优化级别设置得足够高，许多编译器都能例行公事地做到这一点。用优化等级3或更高等级调用GCC，它就会执行循环展开。</p>
<p>循环展开，英文中称Loop unwinding或loop unrolling，是一种牺牲程序的尺寸来加快程序的执行速度的优化方法。可以由程序员完成，也可由编译器自动优化完成。循环展开最常用来降低循环开销，为具有多个功能单元的处理器提供指令级并行。也有利于指令流水线的调度。</p>
<h3 id="循环展开对程序性能的影响"><a href="#循环展开对程序性能的影响" class="headerlink" title="循环展开对程序性能的影响"></a>循环展开对程序性能的影响</h3><p>我们直接以实际代码向大家展示循环展开的作用，首先看未经过循环展开优化的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    auto start = std::chrono::system_clock::now();</span><br><span class="line">    int sum = 0;</span><br><span class="line">    int count = 10000;</span><br><span class="line">    //循环10000次累加</span><br><span class="line">    for(int i = 0;i &lt; count;i++)&#123;  </span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    auto end = std::chrono::system_clock::now();</span><br><span class="line">    std::chrono::duration&lt;double&gt; dura = end - start;</span><br><span class="line">    std::cout &lt;&lt;&quot;共耗时：&quot;&lt;&lt; dura.count() &lt;&lt; &quot;s&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们将循环展开一次，即把上述代码中的循环改为如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; count;i += <span class="number">2</span>)&#123;</span><br><span class="line">    sum += i;</span><br><span class="line">    sum += i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即每次循环将i和i+1一起累加到sum变量上，这样可以把循环次数从10000次降低到5000次，由于CPU的高度流水线化，连续两个加法指令增加耗时很低，所以此版本代码可以一定程度上提高程序运行速度</p>
<p>代码运行耗时0.0000159秒，相较于未优化代码速度快了将近一倍。</p>
<p>当然，我们可以继续增加循环展开次数以进一步提高程序运行速度，但是这个增加循环展开次数也是有限度的，<em>当达到了CPU的最高吞吐量之后，继续增加循环展开次数是没有意义的</em>。</p>
<p>上述循环展开后的代码依然有进一步优化的空间，那就是消除连续指令的相关性，以达到指令级并行，我们可以看到循环展开后的代码，循环体中有两条语句：sum +&#x3D; i 和 sum +&#x3D; i+1，第二条语句sum +&#x3D; i+1依赖于第一条命来sum +&#x3D; i的执行结果，所以这两条语句只能依次执行，限制了CPU进一步提高性能的可能。如果我们将循环体改为如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum1=<span class="number">0</span>,sum2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; count;i+=<span class="number">2</span>)&#123;</span><br><span class="line">    sum1 += i;</span><br><span class="line">    sum2 += i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">sum = sum1 + sum2;</span><br></pre></td></tr></table></figure>

<p>我们新建了两个变量sum1和sum2用于存储循环展开时两个累加语句的累加结果，最后在循环体外将两部分结果相加得到最终结果。该代码中两个累加语句之间是互不相关的，所以CPU可以并行执行这两条指令，以达到性能的进一步提高。相较于只进行循环展开的代码速度又快了将近一倍。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由上面三段代码的运行速度对比可以看出，循环展开对程序性能有着很重要的影响，可以减少分支预测错误次数，增加取消数据相关进一步利用并行执行提高速度的机会。但是，<strong>并不建议大家进行手动的循环展开</strong>，在代码中进行循环展开会导致程序的可读性下降，代码膨胀。为了直观感受循环展开对性能的影响，上述代码运行结果均是在不开编译器优化的情况下进行的测试，其实在我们<strong>开启了编译器优化</strong>的时候，编译器会自动对我们的循环代码进行循环展开，让我们可以在保持了代码可读性的同时，又能享受到循环展开对我们程序性能的提高。</p>
<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230613165045230.png" alt="image-20230613165045230"></p>
<img src="/2023/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230613165045230.png" class title="This is an test image">

<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230613165134725.png" alt="image-20230613165134725"></p>
<img src="/2023/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230613165134725.png" class title="This is an test image">



<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230613165149509.png" alt="image-20230613165149509"></p>
<img src="/2023/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230613165149509.png" class title="This is an test image">



<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230613165207581.png" alt="image-20230613165207581"></p>
<img src="/2023/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0/image-20230613165207581.png" class title="This is an test image">

<h2 id="SIMD-用向量指令达到更高的并行度"><a href="#SIMD-用向量指令达到更高的并行度" class="headerlink" title="SIMD:用向量指令达到更高的并行度"></a>SIMD:用向量指令达到更高的并行度</h2><p><em>Single Instruction Multiple Data</em>，单指令多数据流，可以使用一条指令同时完成多个数据的运算操作。传统的指令架构是SISD就是单指令单数据流，每条指令只能对一个数据执行操作。</p>
<p>单纯使用SIMD指令并没有什么技术含量，一般程序员也不太会使用 Intrinsics 函数来优化 SIMD，基本上都是靠编译器帮我们进行自动矢量化。想要代码能尽量的自动矢量化，以下几点需要多注意：</p>
<ul>
<li>避免使用全局指针和全局变量以帮助编译器生成 SIMD 代码。</li>
<li>合理安排循环的嵌套，以便最内层的嵌套没有迭代间的依赖关系。尤其要避免在较早的迭代中存储数据，而在往后的迭代中加载该数据。</li>
<li>避免在循环内使用条件分支。</li>
<li>保持循环变量表达式简单。</li>
</ul>
<p>现代编译器已经能为我们自动做很多优化工作，不过这不代表我们学习手写SIMD代码就没有意义了。在向量、矩阵运算等基础库函数中，每个函数通常代码量不大，复杂度不高，但编译器并不能保证会给你优化好，手撸SIMD还是很有必要的。更重要的是，我们能在学习的过程中去接触更底层的一些东西（指令集，内存架构，汇编等），进而提升对整体的编程实力。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/21/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/21/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/" class="post-title-link" itemprop="url">Linux系统编程-文件IO</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-21 10:50:39" itemprop="dateCreated datePublished" datetime="2023-05-21T10:50:39+08:00">2023-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-01 21:34:33" itemprop="dateModified" datetime="2023-06-01T21:34:33+08:00">2023-06-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>系统调用 内核提供的函数 </p>
<p>库调用 程序库中的函数</p>
<h2 id="open-函数"><a href="#open-函数" class="headerlink" title="open 函数"></a>open 函数</h2><p>open 函数： <code>int open(char *pathname, int flags)  	#include  &lt;unistd.h&gt;</code> </p>
<p>参数： pathname: 欲打开的文件路径名 	flags：文件打开方式： <code>#include  &lt;unistd.h&gt; O_RDONLY|O_WRONLY|O_RDWR|O_CREAT|O_APPEND|O_TRUNC|O_EXCL|O_NONBLOCK ....</code> </p>
<p>返回值： 成功： 打开文件所得到对应的 文件描述符（整数） </p>
<p>失败： -1， 设置 errno </p>
<p><code>int open(char *pathname, int flags， mode_t mode) 	123 775</code> </p>
<p>参数： pathname: 欲打开的文件路径名 </p>
<p>flags：文件打开方式O_RDONLY|O_WRONLY|O_RDWR|O_CREAT|O_APPEND|O_TRUNC|O_EXCL|O_NONBLOCK …. </p>
<p>mode: 参数 3 使用的前提， 参 2 指定了 O_CREAT。 取值 8 进制数，用来描述文件的 访问权限。</p>
<p> rwx 0664 创建文件最终权限 &#x3D; mode &amp; ~umask (umask是系统默认0002取反775)</p>
<p>返回值： 成功： 打开文件所得到对应的 文件描述符（整数） </p>
<p>失败： -1， 设置 errno </p>
<p>close 函数： <code>int close(int fd);</code></p>
<h2 id="read和write实现cp"><a href="#read和write实现cp" class="headerlink" title="read和write实现cp"></a>read和write实现cp</h2><p>read函数：</p>
<p>  <code>ssize_t read(int fd, void *buf, size_t count);</code></p>
<p>  参数：</p>
<p>​    fd：文件描述符</p>
<p>​    buf：存数据的缓冲区</p>
<p>​    count：缓冲区大小</p>
<p>  返回值：</p>
<p>​    0：读到文件末尾。</p>
<p>​    成功； &gt; 0 读到的字节数。</p>
<p>​    失败： -1， 设置 errno</p>
<p>​    -1： 并且 errno &#x3D; EAGIN 或 EWOULDBLOCK, 说明不是read失败，而是read在以非阻塞方式读一个设备文件（网络文件），并且文件无数据。</p>
<p>write函数：</p>
<p>  <code>ssize_t write(int fd, const void *buf, size_t count);</code></p>
<p>  参数：</p>
<p>​    fd：文件描述符</p>
<p>​    buf：待写出数据的缓冲区</p>
<p>​    count：数据大小</p>
<p>  返回值：</p>
<p>​    成功； 写入的字节数。</p>
<p>​    失败： -1， 设置 errno</p>
<p><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230523223219656.png" alt="image-20230523223219656"></p>
<img src="/2023/05/21/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230523223219656.png" class title="This is an test image">

<p>可以在复制函数里加入错误检测：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(fd1 == -1)&#123;</span><br><span class="line"></span><br><span class="line">  perror(“open argv[1] error”);</span><br><span class="line"></span><br><span class="line">  exit(1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误处理函数：    与 errno 相关。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;xxx error: %d\n&quot;, errno);</span><br><span class="line"></span><br><span class="line">char *strerror(int errnum);</span><br><span class="line"></span><br><span class="line">printf(&quot;xxx error: %s\n&quot;, strerror(errno));</span><br><span class="line"></span><br><span class="line">void perror(const char *s);</span><br><span class="line"></span><br><span class="line">  perror(&quot;open error&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="系统调用和库函数比较—预读入缓输出"><a href="#系统调用和库函数比较—预读入缓输出" class="headerlink" title="系统调用和库函数比较—预读入缓输出"></a>系统调用和库函数比较—预读入缓输出</h2><p>所以系统函数并不是一定比库函数牛逼，能使用库函数的地方就使用库函数。 标准 IO 函数（如fputc&#x2F;fgetc）自带用户缓冲区（一般是4096，即4kb再向内核写入），系统调用（read&#x2F;write 这块，每次写一个字节，自己定义buf为1，会疯狂进行内核态和用户态的切换，所以非常耗时）无用户级缓冲。系统缓冲区是都有的。</p>
<p><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230525171335770.png" alt="image-20230525171335770"></p>
<img src="/2023/05/21/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230525171335770.png" class title="This is an test image">

<h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230525185325288.png" alt="image-20230525185325288"></p>
<img src="/2023/05/21/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230525185325288.png" class title="This is an test image">

<p>文件描述符是指向一个文件结构体的指针 </p>
<p>PCB 进程控制块：本质 结构体。</p>
<p> 成员：文件描述符表。 </p>
<p>文件描述符：0&#x2F;1&#x2F;2&#x2F;3&#x2F;4。。。。&#x2F;1023 表中可用的最小的。 </p>
<p>0 - STDIN_FILENO </p>
<p>1 - STDOUT_FILENO </p>
<p>2 - STDERR_FILENO</p>
<h2 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h2><p>阻塞、非阻塞： 是<strong>设备文件、网络文件</strong>的属性。普通创建的文件没有。</p>
<p>产生阻塞的场景。 读设备文件。读网络文件。（读常规文件无阻塞概念。） &#x2F;dev&#x2F;tty – 终端文件。 </p>
<p>open(“&#x2F;dev&#x2F;tty”, O_RDWR|O_NONBLOCK)	 — 设置 &#x2F;dev&#x2F;tty (当前终端)非阻塞状态。(默认为阻塞状态)</p>
<h2 id="fcntl-改文件属性"><a href="#fcntl-改文件属性" class="headerlink" title="fcntl 改文件属性"></a>fcntl 改文件属性</h2><p>fcntl 用来改变一个【已经打开】的文件的 访问控制属性 </p>
<p>重点掌握两个参数的使用， F_GETFL，F_SETFL </p>
<p>fcntl： </p>
<p>​	int (int fd, int cmd, …) </p>
<p>fd 文件描述符 cmd 命令，决定了后续参数个数 </p>
<p>int flgs &#x3D; fcntl(fd, F_GETFL);</p>
<p>flgs |&#x3D; O_NONBLOCK </p>
<p>fcntl(fd, F_SETFL, flgs); </p>
<p>获取文件状态： F_GETFL </p>
<p>设置文件状态： F_SETFL</p>
<p>终端文件默认是阻塞读的，这里用 fcntl 将其更改为非阻塞读</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;unistd.h&gt;</span><br><span class="line">2. #include &lt;fcntl.h&gt;</span><br><span class="line">3. #include &lt;errno.h&gt;</span><br><span class="line">4. #include &lt;stdio.h&gt;</span><br><span class="line">5. #include &lt;stdlib.h&gt;</span><br><span class="line">6. #include &lt;string.h&gt;</span><br><span class="line">7.</span><br><span class="line">8. #define MSG_TRY &quot;try again\n&quot;</span><br><span class="line">9.</span><br><span class="line">10. int main(void)</span><br><span class="line">11. &#123;</span><br><span class="line">12. char buf[10];</span><br><span class="line">13. int flags, n;</span><br><span class="line">14.</span><br><span class="line">15. flags = fcntl(STDIN_FILENO, F_GETFL); //获取 stdin 属性信息</span><br><span class="line">16. if(flags == -1)&#123;</span><br><span class="line">17. perror(&quot;fcntl error&quot;);</span><br><span class="line">18. exit(1);</span><br><span class="line">19. &#125;</span><br><span class="line">20. flags |= O_NONBLOCK;</span><br><span class="line">21. int ret = fcntl(STDIN_FILENO, F_SETFL, flags);</span><br><span class="line">22. if(ret == -1)&#123;</span><br><span class="line">23. perror(&quot;fcntl error&quot;);</span><br><span class="line">24. exit(1);</span><br><span class="line">25. &#125;</span><br><span class="line">26.</span><br><span class="line">27. tryagain:</span><br><span class="line">28. n = read(STDIN_FILENO, buf, 10);</span><br><span class="line">29. if(n &lt; 0)&#123;</span><br><span class="line">30. if(errno != EAGAIN)&#123;</span><br><span class="line">31. perror(&quot;read /dev/tty&quot;);</span><br><span class="line">32. exit(1);</span><br><span class="line">33. &#125;</span><br><span class="line">34. sleep(3);</span><br><span class="line">35. write(STDOUT_FILENO, MSG_TRY, strlen(MSG_TRY));</span><br><span class="line">36. goto tryagain;</span><br><span class="line">37. &#125;</span><br><span class="line">38. write(STDOUT_FILENO, buf, n);</span><br><span class="line">39.</span><br><span class="line">40. return 0;</span><br><span class="line">41. &#125;</span><br></pre></td></tr></table></figure>

<h2 id="lseek-函数"><a href="#lseek-函数" class="headerlink" title="lseek 函数"></a>lseek 函数</h2><p>lseek 函数： <code>off_t lseek(int fd, off_t offset, int whence);</code></p>
<p> 参数： fd：文件描述符 		offset： 偏移量，就是将读写指针从 whence 指定位置向后偏移 offset 个单位 		whence：起始偏移位置：开始，读到，结尾 SEEK_SET&#x2F;SEEK_CUR&#x2F;SEEK_END </p>
<p>返回值： 成功：较起始位置偏移量 失败：-1 errno </p>
<p>应用场景： </p>
<ol>
<li><p>文件的“读”、“写”使用同一偏移位置。 2. 使用 lseek 获取文件大小 3. 使用 lseek 拓展文件大小：要想使文件大小真正拓展，必须引起 IO 操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int lenth = lseek ( fd,101，SEEK_END);</span><br><span class="line">printf( &quot;file size: %d\n&quot; , lenth) ;</span><br><span class="line">write(fd,&quot;$&quot;，1);</span><br></pre></td></tr></table></figure>

<p>​			 使用 truncate 函数，直接拓展文件。 <code>int ret = truncate(&quot;dict.cp&quot;, 250);</code>&#x2F;&#x2F;dict.cp是必须存在的</p>
</li>
</ol>
<p>lseek 示例，写一个句子到空白文件，完事调整光标位置，读取刚才写那个文件。 这个示例中，如果不调整光标位置，是读取不到内容的，因为读写指针在内容的末尾 代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;unistd.h&gt;</span><br><span class="line">4. #include &lt;string.h&gt;</span><br><span class="line">5. #include &lt;fcntl.h&gt;</span><br><span class="line">6.</span><br><span class="line">7. int main(void)</span><br><span class="line">8. &#123;</span><br><span class="line">9. int fd, n;</span><br><span class="line">10. char msg[] = &quot;It&#x27;s a test for lseek\n&quot;;</span><br><span class="line">11. char ch;</span><br><span class="line">12.</span><br><span class="line">13. fd = open(&quot;lseek.txt&quot;, O_RDWR|O_CREAT, 0644);</span><br><span class="line">14. if(fd &lt; 0)&#123;</span><br><span class="line">15. perror(&quot;open lseek.txt error&quot;);</span><br><span class="line">16. exit(1);</span><br><span class="line">17. &#125;</span><br><span class="line">18.</span><br><span class="line">19. write(fd, msg, strlen(msg)); //使用 fd 对打开的文件进行写操作，问价读写位置位于文件结尾处。</span><br><span class="line">20.</span><br><span class="line">21. lseek(fd, 0, SEEK_SET); //修改文件读写指针位置，位于文件开头。 注释该行会怎样呢？</span><br><span class="line">22.</span><br><span class="line">23. while((n = read(fd, &amp;ch, 1)))&#123;</span><br><span class="line">24. if(n &lt; 0)&#123;</span><br><span class="line">25. perror(&quot;read error&quot;);</span><br><span class="line">26. exit(1);</span><br><span class="line">27. &#125;</span><br><span class="line">28. write(STDOUT_FILENO, &amp;ch, n); //将文件内容按字节读出，写出到屏幕</span><br><span class="line">29. &#125;</span><br><span class="line">30.</span><br><span class="line">31. close(fd);</span><br><span class="line">32.</span><br><span class="line">33. return 0;</span><br><span class="line">34. &#125;</span><br></pre></td></tr></table></figure>

<p>下面这个代码用 lseek 的偏移来读取文件大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int lenth = lseek(fd,0,SEEK_END);</span><br><span class="line">printf ( &quot;file size: %d\n&quot; , lenth) ;</span><br></pre></td></tr></table></figure>

<p>对于写文件再读取那个例子，由于文件写完之后未关闭，读写指针在文件末尾，所以不调节指针，直 接读取不到内容。</p>
<p> lseek 读取的文件大小总是相对文件头部而言。 </p>
<p>用 lseek 读取文件大小实际用的是读写指针初末位置的偏移差，一个新开文件，读写指针初位置都在 文件开头。如果用这个来扩展文件大小，必须引起 IO 才行，于是就至少要写入一个字符。上面代码 出现 lseek 返回 799，ls 查看为 800 的原因是，lseek 读取到偏移差的时候，还没有写入最后的‘$’ 符号. 末尾那一大堆^@，是文件空洞，如果自己写进去的也想保持队形，就写入“\0”。 </p>
<p>拓展文件直接使用 truncate，简单粗暴： 使用 truncate 函数，直接拓展文件。 int ret &#x3D; truncate(“dict.cp”, 250);</p>
<h2 id="传入传出参数"><a href="#传入传出参数" class="headerlink" title="传入传出参数"></a>传入传出参数</h2><p>传入参数： 1. 指针作为函数参数。 2. 同常有 const 关键字修饰。 3. 指针指向有效区域， 在函数内部做读操作。</p>
<p> 传出参数： 1. 指针作为函数参数。 2. 在函数调用之前，指针指向的空间可以无意义，但必须有效。 3. 在函数内部，做写操作。 4。函数调用结束后，充当函数返回值。 </p>
<p>传入传出参数： 1. 指针作为函数参数。 2. 在函数调用之前，指针指向的空间有实际意义。 3. 在函数内部，先做读操作，后做写操作。 4. 函数调用结束后，充当函数返回值</p>
<h2 id="目录项和-inode"><a href="#目录项和-inode" class="headerlink" title="目录项和 inode"></a>目录项和 inode</h2><p>一个文件主要由两部分组成，dentry(目录项)和 </p>
<p>​	inode inode 本质是结构体，存储文件的属性信息，如：权限、类型、大小、时间、用户、盘快位置… 也叫做文件属性管理结构，大多数的 inode 都存储在磁盘上。 </p>
<p>​	少量常用、近期使用的 inode 会被缓存到内存中。 </p>
<p>所谓的删除文件，就是删除 inode，但是数据其实还是在硬盘上，以后会覆盖掉。</p>
<h2 id="stat-函数"><a href="#stat-函数" class="headerlink" title="stat 函数"></a>stat 函数</h2><p>获取文件属性，（从 inode 结构体中获取） </p>
<p>stat&#x2F;lstat 函数： <code>int stat(const char *path, struct stat *buf);</code> </p>
<p>参数： </p>
<p>​	path： 文件路径 </p>
<p>​	buf：（传出参数） 存放文件属性，inode 结构体指针。 </p>
<p>返回值： </p>
<p>​	成功： 0 </p>
<p>​	失败： -1 errno </p>
<p>获取文件大小： buf.st_size </p>
<p>获取文件类型： buf.st_mode </p>
<p>获取文件权限： buf.st_mode </p>
<p>符号穿透：stat 会。lstat 不会。</p>
<p>下面这个例子是获取文件大小的正规军解法，用 stat：</p>
<p><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230526211019247.png" alt="image-20230526211019247"></p>
<img src="/2023/05/21/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230526211019247.png" class title="This is an test image">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">man 2 stat</span><br><span class="line">进入之后G</span><br><span class="line">一般比较大的函数或者是难度大的有example</span><br></pre></td></tr></table></figure>

<p>stat 会拿到符号链接指向那个文件或目录的属性。 不想穿透符号就用 lstat（两个除了穿透符号这个性质以外就一样）</p>
<p><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230526213815013.png" alt="image-20230526213815013"></p>
<img src="/2023/05/21/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230526213815013.png" class title="This is an test image">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">用sb.st_mode &amp; SIFMT前4位就是SIFMT与上文件得出的mode</span><br><span class="line">switch (sb.st_mode &amp; S_IFMT) &#123;</span><br><span class="line">           case S_IFBLK:  printf(&quot;block device\n&quot;);            br</span><br><span class="line">eak;</span><br><span class="line">           case S_IFCHR:  printf(&quot;character device\n&quot;);        br</span><br><span class="line">eak;</span><br><span class="line">           case S_IFDIR:  printf(&quot;directory\n&quot;);               br</span><br><span class="line">eak;</span><br><span class="line">           case S_IFIFO:  printf(&quot;FIFO/pipe\n&quot;);               br</span><br><span class="line">eak;</span><br><span class="line">           case S_IFLNK:  printf(&quot;symlink\n&quot;);                 br</span><br><span class="line">eak;</span><br><span class="line">           case S_IFREG:  printf(&quot;regular file\n&quot;);            br</span><br><span class="line">eak;</span><br><span class="line">           case S_IFSOCK: printf(&quot;socket\n&quot;);                  br</span><br><span class="line">eak;</span><br><span class="line">           default:       printf(&quot;unknown?\n&quot;);                br</span><br><span class="line">eak;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>

<h2 id="link-和-Unlink-隐式回收"><a href="#link-和-Unlink-隐式回收" class="headerlink" title="link 和 Unlink 隐式回收"></a>link 和 Unlink 隐式回收</h2><p>硬链接数就是 dentry 数目 </p>
<p>link 就是用来创建硬链接的 </p>
<p>link 可以用来实现 mv 命令 </p>
<p>函数原型： <code>int link(const char *oldpath, const char *newpath)</code> 用这个来实现 mv，用 oldpath 来创建 newpath，完事儿删除 oldpath 就行。 </p>
<p>删除一个链接 <code>int unlink(const char *pathname)</code> </p>
<p>unlink 是删除一个文件的目录项 dentry，使硬链接数-1 </p>
<p>unlink 函数的特征：清除文件时，如果文件的硬链接数到 0 了，没有 dentry 对应，但该文件仍不会 马上被释放，要等到所有打开文件的进程关闭该文件，系统才会挑时间将该文件释放掉。</p>
<p>在程序中加入段错误成分，段错误在 unlink 之前，由于发生段错误，程序后续删除 temp.txt 的 dentry 部分就不会再执行，temp.txt 就保留了下来，这是不科学的。 </p>
<p>在编程中以下几类做法容易导致段错误,基本上是<strong>错误地使用指针引起的</strong>。 所谓的段错误就是指访问的内存超出了系统所给这个程序的内存空间，段错误应该就是访问了不可访问的内存，这个内存区要么是不存在的，要么是受到系统保护的。</p>
<p>解决办法是检测 fd 有效性后，立即释放 temp.txt，由于进程未结束，虽然 temp.txt 的硬链接数已 经为 0，但还不会立即释放，仍然存在，要等到程序执行完才会释放。这样就能避免程序出错导致临 时文件保留下来。</p>
<p>因为文件创建后，硬链接数立马减为 0，即使程序异常退出，这个文件也会被清理掉。这时候的内容 是写在内核空间的缓冲区。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. /*</span><br><span class="line">2. *unlink 函数是删除一个 dentry</span><br><span class="line">3. */</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;fcntl.h&gt;</span><br><span class="line">6. #include &lt;stdlib.h&gt;</span><br><span class="line">7. #include &lt;string.h&gt;</span><br><span class="line">8. #include &lt;stdio.h&gt;</span><br><span class="line">9.</span><br><span class="line">10.</span><br><span class="line">11. int main(void)</span><br><span class="line">12. &#123;</span><br><span class="line">13. int fd, ret;</span><br><span class="line">14. char *p = &quot;test of unlink\n&quot;;</span><br><span class="line">15. char *p2 = &quot;after write something.\n&quot;;</span><br><span class="line">16.</span><br><span class="line">17. fd = open(&quot;temp.txt&quot;, O_RDWR|O_CREAT|O_TRUNC, 0644);</span><br><span class="line">18. if(fd &lt; 0)&#123;</span><br><span class="line">19. perror(&quot;open temp error&quot;);</span><br><span class="line">20. exit(1);</span><br><span class="line">21. &#125;</span><br><span class="line">22.</span><br><span class="line">23. ret = unlink(&quot;temp.txt&quot;); //具备了被释放的条件</span><br><span class="line">24. if(ret &lt; 0)&#123;</span><br><span class="line">25. perror(&quot;unlink error&quot;);</span><br><span class="line">26. exit(1);</span><br><span class="line">27. &#125;</span><br><span class="line">28.</span><br><span class="line">29. ret = write(fd, p, strlen(p));</span><br><span class="line">30. if (ret == -1) &#123;</span><br><span class="line">31. perror(&quot;-----write error&quot;);</span><br><span class="line">32. &#125;</span><br><span class="line">33.</span><br><span class="line">34. printf(&quot;hi! I&#x27;m printf\n&quot;);</span><br><span class="line">35. ret = write(fd, p2, strlen(p2));</span><br><span class="line">36. if (ret == -1) &#123;</span><br><span class="line">37. perror(&quot;-----write error&quot;);</span><br><span class="line">38. &#125;</span><br><span class="line">39.</span><br><span class="line">40. printf(&quot;Enter anykey continue\n&quot;);</span><br><span class="line">41. getchar();</span><br><span class="line">42.</span><br><span class="line">43. close(fd);</span><br><span class="line">44.</span><br><span class="line">45. return 0;</span><br><span class="line">46. &#125;</span><br></pre></td></tr></table></figure>

<p><strong>隐式回收</strong>： </p>
<p>​		当进程结束运行时，所有进程打开的文件会被关闭，申请的内存空间会被释放。系统的这一特性 称之为隐式回收系统资源。 </p>
<p>​		比如上面那个程序，要是没有在程序中关闭文件描述符，没有隐式回收的话，这个文件描述符会保留， 多次出现这种情况会导致系统文件描述符耗尽。所以隐式回收会在程序结束时收回它打开的文件使用 的文件描述符。</p>
<p><strong>文件描述符</strong>（file descriptor）就是内核为了高效管理这些已经被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I&#x2F;O操作的系统调用都通过文件描述符来实现。同时还规定系统刚刚启动的时候，0是标准输入，1是标准输出，2是标准错误。这意味着如果此时去打开一个新的文件，它的文件描述符会是3，再打开一个文件文件描述符就是4……</p>
<h2 id="文件目录-rwx-权限差异"><a href="#文件目录-rwx-权限差异" class="headerlink" title="文件目录 rwx 权限差异"></a>文件目录 rwx 权限差异</h2><p>vi 目录 会得到目录项的列表</p>
<p><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230527200057726.png" alt="image-20230527200057726"></p>
<img src="/2023/05/21/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230527200057726.png" class title="This is an test image">

<h2 id="目录操作函数"><a href="#目录操作函数" class="headerlink" title="目录操作函数"></a>目录操作函数</h2><p>目录操作函数： <code>DIR * opendir(char *name);</code> </p>
<p><code>int closedir(DIR *dp);</code></p>
<p><code>struct dirent *readdir(DIR * dp);</code> </p>
<p><code>struct dirent &#123; </code></p>
<p><code>inode </code></p>
<p><code>char dname[256]; &#125;</code></p>
<p> 没有写目录操作，因为目录写操作就是创建文件。可以用 touch</p>
<p>下面用目录操作函数实现一个 ls 操作：</p>
<p><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230527200502344.png" alt="image-20230527200502344"></p>
<img src="/2023/05/21/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230527200502344.png" class title="This is an test image">

<p>要隐藏这个.和..的话，在输出文件名的时候判定一下，只输出不是.和..的就行了</p>
<h2 id="应用程序的系统调用过程"><a href="#应用程序的系统调用过程" class="headerlink" title="应用程序的系统调用过程"></a>应用程序的系统调用过程</h2><p>应用程序-&gt;标库函数-&gt;系统调用-&gt;驱动-&gt;硬件</p>
<h2 id="递归遍历目录实现"><a href="#递归遍历目录实现" class="headerlink" title="递归遍历目录实现"></a>递归遍历目录实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">先写个简易版的，可以判定文件，读取文件大小：</span><br><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;pthread.h&gt;</span><br><span class="line">6. #include &lt;sys/stat.h&gt;</span><br><span class="line">7.</span><br><span class="line">8. void isFile(char *name)&#123;</span><br><span class="line">9. int ret = 0;</span><br><span class="line">10. struct stat sb;</span><br><span class="line">11.</span><br><span class="line">12. ret = stat(name, &amp;sb);</span><br><span class="line">13. if(ret == -1)&#123;</span><br><span class="line">14. perror(&quot;stat error&quot;);</span><br><span class="line">15. return;</span><br><span class="line">16. &#125;</span><br><span class="line">17.</span><br><span class="line">18. if(S_ISDIR(sb.st_mode))&#123;</span><br><span class="line">19.</span><br><span class="line">20. &#125;</span><br><span class="line">21. printf(&quot;%s\t%ld\n&quot;, name, sb.st_size);</span><br><span class="line">22.</span><br><span class="line">23. return;</span><br><span class="line">24. &#125;</span><br><span class="line">25. int main(int argc, char *argv[])&#123;</span><br><span class="line">26. if(argc == 1) &#123;</span><br><span class="line">27. isFile(&quot;.&quot;);</span><br><span class="line">28. &#125;</span><br><span class="line">29. else &#123;</span><br><span class="line">30. isFile(argv[1]);</span><br><span class="line">31. &#125;</span><br><span class="line">32.</span><br><span class="line">33. return 0;</span><br><span class="line">34. &#125;</span><br></pre></td></tr></table></figure>

<p>下面完善功能，把对目录的递归处理补全，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">1. #include &lt;stdio.h&gt;</span><br><span class="line">2. #include &lt;stdlib.h&gt;</span><br><span class="line">3. #include &lt;string.h&gt;</span><br><span class="line">4. #include &lt;unistd.h&gt;</span><br><span class="line">5. #include &lt;sys/stat.h&gt;</span><br><span class="line">6. #include &lt;dirent.h&gt;</span><br><span class="line">7. #include &lt;pthread.h&gt;</span><br><span class="line">8.</span><br><span class="line">9. void isFile(char *name);</span><br><span class="line">10.</span><br><span class="line">11. // 打开目录读取,处理目录</span><br><span class="line">12. void read_dir(char *dir, void (*func)(char *))</span><br><span class="line">13. &#123;</span><br><span class="line">14. char path[256];</span><br><span class="line">15. DIR *dp;</span><br><span class="line">16. struct dirent *sdp;</span><br><span class="line">17.</span><br><span class="line">18. dp = opendir(dir);</span><br><span class="line">19. if (dp == NULL) &#123;</span><br><span class="line">20. perror(&quot;opendir error&quot;);</span><br><span class="line">21. return;</span><br><span class="line">22. &#125;</span><br><span class="line">23. // 读取目录项</span><br><span class="line">24. while((sdp = readdir(dp)) != NULL) &#123;</span><br><span class="line">25. if (strcmp(sdp-&gt;d_name, &quot;.&quot;) == 0 || strcmp(sdp-&gt;d_name, &quot;..&quot;) == 0) &#123;</span><br><span class="line">26. continue;</span><br><span class="line">27. &#125;</span><br><span class="line">28. //fprintf();</span><br><span class="line">29. // 目录项本身不可访问, 拼接. 目录/目录项</span><br><span class="line">30. sprintf(path, &quot;%s/%s&quot;, dir, sdp-&gt;d_name);</span><br><span class="line">31.</span><br><span class="line">32. // 判断文件类型,目录递归进入,文件显示名字/大小</span><br><span class="line">33. //isFile(path);</span><br><span class="line">34. (*func)(path);</span><br><span class="line">35. &#125;</span><br><span class="line">36.</span><br><span class="line">37. closedir(dp);</span><br><span class="line">38.</span><br><span class="line">39. return ;</span><br><span class="line">40. &#125;</span><br><span class="line">41.</span><br><span class="line">42. void isFile(char *name)</span><br><span class="line">43. &#123;</span><br><span class="line">44. int ret = 0;</span><br><span class="line">45. struct stat sb;</span><br><span class="line">46.</span><br><span class="line">47. // 获取文件属性, 判断文件类型</span><br><span class="line">48. ret = stat(name, &amp;sb);</span><br><span class="line">49. if (ret == -1) &#123;</span><br><span class="line">50. perror(&quot;stat error&quot;);</span><br><span class="line">51. return ;</span><br><span class="line">52. &#125;</span><br><span class="line">53. // 是目录文件</span><br><span class="line">54. if (S_ISDIR(sb.st_mode)) &#123;</span><br><span class="line">55. read_dir(name, isFile);</span><br><span class="line">56. &#125;</span><br><span class="line">57. // 是普通文件, 显示名字/大小</span><br><span class="line">58. printf(&quot;%10s\t\t%ld\n&quot;, name, sb.st_size);</span><br><span class="line">59.</span><br><span class="line">60. return;</span><br><span class="line">61. &#125;</span><br><span class="line">62.</span><br><span class="line">63.</span><br><span class="line">64. int main(int argc, char *argv[])</span><br><span class="line">65. &#123;</span><br><span class="line">66. // 判断命令行参数</span><br><span class="line">67. if (argc == 1) &#123;</span><br><span class="line">68. isFile(&quot;.&quot;);</span><br><span class="line">69. &#125; else &#123;</span><br><span class="line">70. isFile(argv[1]);</span><br><span class="line">71. &#125;</span><br><span class="line">72.</span><br><span class="line">73. return 0;</span><br><span class="line">74. &#125;</span><br></pre></td></tr></table></figure>

<h2 id="dup-和-dup2"><a href="#dup-和-dup2" class="headerlink" title="dup 和 dup2"></a>dup 和 dup2</h2><p>用来做重定向，本质就是复制文件描述符：<br>dup 和 dup2：<br><code>int dup(int oldfd);</code> 文件描述符复制。<br>oldfd: 已有文件描述符<br>返回：新文件描述符，这个描述符和 oldfd 指向相同内容。<br><code>int dup2(int oldfd, int newfd);</code> 文件描述符复制，oldfd 拷贝给 newfd。返回 newfd</p>
<p>下面讲 dup2（dupto）： 下面这个例子，将一个已有文件描述符 fd1 复制给另一个文件描述符 fd2，<strong>然后用 fd2 修改 fd1</strong> 指向 的文件：</p>
<p><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230531192509565.png" alt="image-20230531192509565"></p>
<img src="/2023/05/21/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230531192509565.png" class title="This is an test image">

<p>上面那个例子，fd1 是打开 hello.c 的文件描述符，fd2 是打开 hello2.c 的文件描述符 用 dup2 将 fd1 复制给了 fd2，于是在对 fd2 指向的文件进行写操作时，实际上就是对 fd1 指向的 hello.c 进行写操作。 这里需要注意一个问题，由于 hello.c 和 hello2.c 都是空文件，所以直接写进去没关系。但如果 hello.c 是非空的，写进去的内容默认从文件头部开始写，会覆盖原有内容。</p>
<p>dup2 也可以用于标准输入输出的重定向。 下面这个例子，将输出到 STDOUT 的内容重定向到文件里：</p>
<p><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230531192739775.png" alt="image-20230531192739775"></p>
<img src="/2023/05/21/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/image-20230531192739775.png" class title="This is an test image">

<p>这个程序，将 fd1 的内容复制给了 fd2，使得原来指向 hello2.c 的 fd2 也指向了 hello.c 并通过 fd2 向 hello.c 里写入了…。完事儿将标准输出重定向至 fd1，就是将要显示在标准输出的内容，写入了 fd1 指向的文件，就是 hello.c 中 这里有一点和上面程序不同，就是 hello.c 是处于打开状态的，连续写入两段话，写入… 的时候，读写指针在这句话末尾，就不会覆盖前面这句话。 这里再强调一下，打开一个文件，读写指针默认在文件头，如果文件本身有内容，直接写入会覆盖有内容。</p>
<h2 id="fcntl-实现-dup-描述符"><a href="#fcntl-实现-dup-描述符" class="headerlink" title="fcntl 实现 dup 描述符"></a>fcntl 实现 dup 描述符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fcntl 函数实现 dup：</span><br><span class="line">	int fcntl(int fd, int cmd, ....)</span><br><span class="line">	cmd: F_DUPFD</span><br><span class="line">	参 3: 被占用的，返回最小可用的。</span><br><span class="line">			未被占用的， 返回=该值的文件描述符。</span><br></pre></td></tr></table></figure>

<p>对于 fcntl 中的参数 0，这个表示 0 被占用，fcntl 使用文件描述符表中的最小文件描述符返回 假设传入 0，传一个 7，且 7 未被占用，则会返回 7 所以这个参数可以这样理解，你传入一个文件描述符 k，如果 k 没被占用，则直接用 k 复制 fd1 的内 容。如果 k 被占用，则返回描述符表中最小可用描述符，也就是自己指定一个一志愿，如果行，就返 回这个。如果不行，国家给你分配一个最小的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/14/Linux%E4%B8%8Agcc%E7%BC%96%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/14/Linux%E4%B8%8Agcc%E7%BC%96%E8%AF%91/" class="post-title-link" itemprop="url">Linux上gcc编译</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-14 10:41:46" itemprop="dateCreated datePublished" datetime="2023-05-14T10:41:46+08:00">2023-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-21 10:34:55" itemprop="dateModified" datetime="2023-05-21T10:34:55+08:00">2023-05-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="gcc-编译-4-步骤"><a href="#gcc-编译-4-步骤" class="headerlink" title="gcc 编译 4 步骤"></a>gcc 编译 4 步骤</h1><p>GCC（GNU Compiler Collection）是由 GNU 开发的编程语言编译器。 GCC最初代表“GNU C Compiler”，当时只支持C语言。 后来又扩展能够支持更多编程语言，包括 C++、Fortran 和 Java 等。</p>
<p>GCC 编译工具链在编译一个C源文件时需要经过以下 4 步：</p>
<ul>
<li>预处理：为把头文件的代码、宏之类的内容转换成生成的.i文件，还是C代码。</li>
<li>编译：把预处理后的.i文件通过编译成.s文件，汇编语言。</li>
<li>汇编：将汇编语言文件生成目标文件.o文件，机器码。</li>
<li>链接：将每个源文件对应的.o文件链接起来，就生成一个可执行程序文件</li>
</ul>
<p><strong>（1）预处理阶段</strong></p>
<p>预处理过程中，对源代码文件中的文件包含 (include)、 预编译语句 (如宏定义define等)进行展开，生成 .i 文件。 可理解为把头文件的代码、宏之类的内容转换成更纯粹的C代码，不过生成的文件以.i为后缀。</p>
<p>使用GCC的参数 “-E”，可以让编译器生成 .i 文件，参数 “-o”，可以指定输出文件的名字。</p>
<p>具体命令如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 预处理，可理解为把头文件的代码汇总成C代码，把*.c转换得到*.i文件</span><br><span class="line">gcc –E hello.c –o hello.i</span><br></pre></td></tr></table></figure>

<p><strong>（2）编译阶段</strong>（消耗时间、系统资源最多）</p>
<p>把预处理后的.i文件通过编译成为汇编语言，生成.s文件，即把代码从C语言转换成汇编语言，这是GCC编译器完成的工作。在这个过程，GCC会检查各个源文件的语法，即使我们调用了一个没有定义的函数，也不会报错。</p>
<p>GCC可以使用-S选项，让编译程序生成汇编语言的代码文件（.s后缀）。</p>
<p>warning时如果有行号，说明是编译阶段出错。</p>
<p>具体命令如下:</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译，可理解为把C代码转换为汇编代码，把*.i转换得到*.s文件</span></span><br><span class="line">gcc –S hello.i –o hello.s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以直接以C文件作为输入进行编译，与上面的命令是等价的</span></span><br><span class="line">gcc –S hello.c –o hello.s</span><br></pre></td></tr></table></figure>

<p><strong>（3）汇编阶段</strong></p>
<p>将汇编语言文件经过汇编，生成目标文件.o文件，每一个源文件都对应一个目标文件。即把汇编语言的代码转换成机器码，这是as汇编器完成的工作。</p>
<p>GCC的参数“c”表示只编译(compile)源文件但不链接，会将源程序编译成目标文件（.o后缀）。计算机只认识0或者1，不懂得C语言，也不懂得汇编语言，经过编译汇编之后，生成的目标文件包含着机器代码，这部分代码就可以直接被计算机执行。一般情况下，可以直接使用参数“c”，跳过上述的两个过程，具体命令 如下：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 汇编，可理解为把汇编代码转换为机器码，把*.s转换得到*.o，即目标文件</span></span><br><span class="line">gcc –c hello.s –o hello.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以直接以C文件作为输入进行汇编，与上面的命令是等价的</span></span><br><span class="line">gcc –c hello.c –o hello.o</span><br></pre></td></tr></table></figure>

<p>Linux下生成的 <em>.o目标文件、</em>so动态库文件以及下一小节链接阶段生成最终的可执行文件都是elf格式的， 可以使用“readelf”工具来查看它们的内容。</p>
<p><strong>（4）链接阶段</strong></p>
<p>最后将每个源文件对应的目标.o文件链接起来，就生成一个可执行程序文件，这是链接器ld完成的工作。</p>
<p>例如一个工程里包含了A和B两个代码文件，在链接阶段， 链接过程需要把A和B之间的函数调用关系理顺，也就是说要告诉A在哪里能够调用到fun函数， 建立映射关系，所以称之为链接。若链接过程中找不到fun函数的具体定义，则会链接报错。</p>
<p>虽然本示例只有一个hello.c文件，但它调用了C标准代码库的printf函数， 所以链接器会把它和printf函数链接起来，生成最终的可执行文件。</p>
<p>链接分为两种：</p>
<ul>
<li>动态链接：GCC编译时的默认选项。动态是指在应用程序运行时才去加载外部的代码库，不同的程序可以共用代码库。 所以动态链接生成的程序比较小，占用较少的内存。</li>
<li>静态链接：链接时使用选项 “–static”，它在编译阶段就会把所有用到的库打包到自己的可执行程序中。 所以静态链接的优点是具有较好的兼容性，不依赖外部环境，但是生成的程序比较大。</li>
</ul>
<p>执行如下命令体验静态链接与动态链接的区别：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在hello.o所在的目录执行如下命令</span></span><br><span class="line"><span class="comment"># 动态链接，生成名为hello的可执行文件</span></span><br><span class="line">//<span class="literal">-o</span>是用来指定生成文件的名字</span><br><span class="line">gcc hello.o –o hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以直接使用C文件一步生成，与上面的命令等价</span></span><br><span class="line">gcc hello.c <span class="literal">-o</span> hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># 静态链接，使用--static参数，生成名为hello_static的可执行文件</span></span><br><span class="line">gcc hello.o –o hello_static <span class="literal">--static</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以直接使用C文件一步生成，与上面的命令等价</span></span><br><span class="line">gcc hello.c <span class="literal">-o</span> hello_static <span class="literal">--static</span></span><br></pre></td></tr></table></figure>

<h2 id="当头文件和源码不在一个目录下时，需要指定头文件"><a href="#当头文件和源码不在一个目录下时，需要指定头文件" class="headerlink" title="当头文件和源码不在一个目录下时，需要指定头文件"></a>当头文件和源码不在一个目录下时，需要指定头文件</h2><p>gcc -I .&#x2F;hellodir hello.c -o hello 其中-I 参数指定头文件所在位置，位置可以在编译文件前，也可以在后面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-I 指定头文件所在目录位置</span><br><span class="line">-c 只做预处理，编译，汇编。得到二进制文件</span><br><span class="line">-g 编译时添加调试文件，用于 gdb 调试</span><br><span class="line">-Wall 显示所有警告信息</span><br><span class="line">-D 向程序中“动态”注册宏定义，一般可以用在调试，制作一个开关，比如ifdef,发布的时候就可以不用删除调试信息</span><br><span class="line">-l 指定动态库库名</span><br><span class="line">-L 指定动态库路径</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="动态库和静态库理论对比"><a href="#动态库和静态库理论对比" class="headerlink" title="动态库和静态库理论对比"></a>动态库和静态库理论对比</h2><p>静态库在文件中静态展开，所以有多少文件就展开多少次，非常吃内存，100M 展开 100 次，就是 1G， 但是这样的好处就是静态加载的速度快 </p>
<p>使用动态库会将动态库加载到内存，10 个文件也只需要加载一次，然后这些文件用到库的时候临时去加载，速度慢一些，但是很省内存 </p>
<p>动态库和静态库各有优劣，根据实际情况合理选用即可。</p>
<ul>
<li>1.动态库是否加载到内存,取决于程序是否运行</li>
<li>2.动态库每次加载的位置不固定</li>
<li>3.动、静态库共存时,编译器默认使用动态库</li>
</ul>
<h3 id="静态库制作"><a href="#静态库制作" class="headerlink" title="静态库制作"></a>静态库制作</h3><p>静态库名字以 lib 开头，以.a 结尾 ，.a是ELF文件，可重定位目标文件。</p>
<p>例如：<code>libmylib.a</code> </p>
<p>静态库生成指令 <code>ar rcs libmylib.a file1.o</code></p>
<p>步骤一： 写好源代码</p>
<p>步骤二： 编译源代码生成.o 文件</p>
<p>步骤三： 制作静态库 ar rcs libname.a file1.o file2.o …</p>
<p>静态库的使用： gcc test.c lib 库名.a -o a.out</p>
<h3 id="动态库制作-生成与位置无关代码"><a href="#动态库制作-生成与位置无关代码" class="headerlink" title="动态库制作-生成与位置无关代码"></a>动态库制作-生成与位置无关代码</h3><p>写在源代码里的函数，相对 main 函数偏移是一定的，链接时，回填 main 函数地址之后，其他源代码里的函数也就得到了地址。 </p>
<p>动态库里的函数会用一个@plt 来标识，当动态库加载到内存时，再用加载进去的地址将@plt 替换掉。</p>
<p>制作动态库的步骤 </p>
<ol>
<li>生成位置无关的.o 文件 <code>gcc -c add.c -o add.o -fPIC</code> 使用这个参数过后，生成的函数就和位置无关，挂上@plt 标识，等待动态绑定 </li>
<li>使用 gcc -shared 制作动态库 <code>gcc -shared -o lib 库名.so add.o sub.o div.o</code> </li>
<li>编译可执行程序时指定所使用的动态库。-l:指定库名 -L:指定库路径 <code>gcc test.c -o a.out -l mymath -L ./lib</code> </li>
<li>运行可执行程序.&#x2F;a.out</li>
</ol>
<h4 id="动态库加载错误原因及解决方式"><a href="#动态库加载错误原因及解决方式" class="headerlink" title="动态库加载错误原因及解决方式"></a>动态库加载错误原因及解决方式</h4><p>出错原因分析： </p>
<p>连接器： 工作于链接阶段，工作时需要 -l 和 -L </p>
<p>动态链接器： 工作于程序运行阶段，工作时需要提供动态库所在目录位置 </p>
<p>指定动态库路径并使其生效，然后再执行文件 </p>
<p>通过环境变量指定动态库所在位置：<code>export LD_LIBRARY_PATH=动态库路径</code></p>
<p>当关闭终端，再次执行 a.out 时，又报错。 </p>
<p>这是因为，环境变量是进程的概念，关闭终端之后再打开，是两个进程，环境变量发生了变化。 </p>
<p>要想永久生效，需要修改 bash 的配置文件：<code>vi ~./bashrc</code> </p>
<p>修改后要使配置文件立即生效：<code>. .bashrc</code> 或者 <code>source .bashrc</code> 或者重开终端让其自己加载 这下再执行 a.out 就不会报错</p>
<h4 id="动态库加载错误原因及解决方式-2"><a href="#动态库加载错误原因及解决方式-2" class="headerlink" title="动态库加载错误原因及解决方式 2"></a>动态库加载错误原因及解决方式 2</h4><p>解决方式： </p>
<p>【1】 通过环境变量： <code>export LD_LIBRARY_PATH=动态库路径</code></p>
<p> .&#x2F;a.out 成功！！！ （临时生效， 终端重启环境变量失效） </p>
<p>【2】 永久生效： 写入 终端配置文件。 .bashrc 建议使用绝对路径。 </p>
<pre><code>1) vi ~/.bashrc
2) 写入 export LD_LIBRARY_PATH=动态库路径 保存 
3) ..bashrc/ source .bashrc / 重启 终端 (三种方法都可以)---&gt; 让修改后的.bashrc 生效 
4) ./a.out 成功！！！ 
</code></pre>
<p>【3】 拷贝自定义动态库 到 &#x2F;lib (标准 C 库所在目录位置) </p>
<p>【4】 配置文件法 </p>
<ul>
<li>sudo vi &#x2F;etc&#x2F;ld.so.conf</li>
<li>写入 动态库绝对路径 保存 </li>
<li>sudo ldconfig -v 使配置文件生效。 </li>
<li>.&#x2F;a.out 成功！！！— 使用 ldd a.out 查看</li>
</ul>
<h3 id="数据段合并"><a href="#数据段合并" class="headerlink" title="数据段合并"></a>数据段合并</h3><p>在链接阶段完成，节省空间，将同样工作（例如只读）的数据段合并。</p>
<h2 id="头文件守卫："><a href="#头文件守卫：" class="headerlink" title="头文件守卫："></a>头文件守卫：</h2><p>防止头文件被重复包含 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ifndef _HEAD_H_ </span><br><span class="line">#define _HEAD_H_ </span><br><span class="line">...... </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h2 id="gdb-调试基础指令"><a href="#gdb-调试基础指令" class="headerlink" title="gdb 调试基础指令"></a>gdb 调试基础指令</h2><p>使用 gdb 之前，要求对文件进行编译时增加-g 参数，加了这个参数过后生成的编译文件会大一些， 这是因为增加了 gdb 调试内容 </p>
<p>gdb 调试工具： 大前提：程序是你自己写的。 —逻辑错误 </p>
<p>基础指令： </p>
<p>​	-g：使用该参数编译可以执行文件，得到调试表。 </p>
<p>​	gdb .&#x2F;a.out </p>
<p>​	list： list 1 列出源码。根据源码指定 行号设置断点。 断点那一行不会执行</p>
<p>​	b： b 20 在 20 行位置设置断点。 </p>
<p>​	run&#x2F;r: 运行程序 </p>
<p>​	n&#x2F;next: 下一条指令（会越过函数） </p>
<p>​	next&#x2F;n :下一个，调用函数就跑 </p>
<p>​	step&#x2F;s :单步，会进入调用的函数 </p>
<p>​	要注意的是，如果是系统函数，按 s 就出不来了，这时用 until+行号直接执行到行号处</p>
<p>​	s&#x2F;step: 下一条指令（会进入函数） </p>
<p>​	p&#x2F;print：p i 查看变量的值。 </p>
<p>​	continue：继续执行断点后续指令。 </p>
<p>​	finish：结束当前函数调用。 </p>
<p>​	quit：退出 gdb 当前调试。 </p>
<p>其他指令： </p>
<p>​	run：使用 run 查找段错误出现位置。 </p>
<p>​	set args： 设置 main 函数命令行参数 （在 start、run 之前） </p>
<p>​	run 字串 1 字串 2 …: 设置 main 函数命令行参数 </p>
<p>​	info b: 查看断点信息表 </p>
<p>​	b 20 if i &#x3D; 5： 设置条件断点。 </p>
<p>​	ptype：查看变量类型。 </p>
<p>​	bt：列出当前程序正存活着的栈帧。 </p>
<p>​	frame： 根据栈帧编号，切换栈帧。 </p>
<p>​	display：设置跟踪变量 </p>
<p>​	undisplay：取消设置跟踪变量。 使用跟踪变量的编号。</p>
<p>没有符号被读取—编译时没加-g 参数 </p>
<p>file 后面加使用-g 编译的文件，可以不用退出，gdb 直接读取后进行调试。</p>
<h2 id="makefile-基础规则"><a href="#makefile-基础规则" class="headerlink" title="makefile 基础规则"></a>makefile 基础规则</h2><p>makefile： 管理项目。 </p>
<p>命名：makefile 	Makefile — make 命令 </p>
<p>1 个规则： </p>
<p>目标：依赖条件 </p>
<p>​	（一个 tab 缩进）命令 </p>
<ol>
<li>目标的时间必须晚于依赖条件的时间，否则，更新目标 </li>
<li>依赖条件如果不存在，找寻新的规则去产生依赖条件。</li>
</ol>
<p>ALL：指定 makefile 的终极目标（第一行）。</p>
<p>2 个函数：</p>
<p>​    src &#x3D; $(wildcard .&#x2F;*.c): 匹配当前工作目录下的所有.c 文件。将文件名组成列表，赋值给变量 src。 src &#x3D; add.c sub.c div1.c </p>
<p>​    obj &#x3D; $(patsubst %.c, %.o, $(src)): 将参数3中，包含参数1的部分，替换为参数2。 obj &#x3D; add.o sub.o div1.o</p>
<p>  clean: (没有依赖)</p>
<p>​    -rm -rf $(obj) a.out “-”：作用是，删除不存在文件时，不报错。顺序执行结束。</p>
<p>  3 个自动变量：</p>
<p>​    $@: 在规则的命令中，表示规则中的目标。</p>
<p>​    $^: 在规则的命令中，表示所有依赖条件。</p>
<p>​    $&lt;: 在规则的命令中，表示第一个依赖条件。如果将该变量应用在模式规则中，它可将依赖条件列表中的依赖依次取出，套用模式规则。</p>
<p>  模式规则：</p>
<p>​    %.o:%.c</p>
<p>​      gcc -c $&lt; -o %@</p>
<p>  静态模式规则：</p>
<p>​    $(obj):%.o:%.c</p>
<p>​      gcc -c $&lt; -o %@  </p>
<p>  伪目标：</p>
<p>​    .PHONY: clean ALL</p>
<p>  参数：</p>
<p>​    -n：模拟执行make、make clean 命令。</p>
<p>​    -f：指定文件执行 make 命令。       xxxx.mk</p>
<p> makefile检测原理：</p>
<p>修改文件后，文件的修改时间发生变化，会出现目标文件的时间早于作为依赖材料的时间，出现这种情况的文件会重新编译。</p>
<p>修改sub.c后，sub.o的时间就早于sub.c ，a.out的时间也早于sub.o的时间了，于是重新编译这俩文件了。</p>
<h2 id="makefile两个函数和clean"><a href="#makefile两个函数和clean" class="headerlink" title="makefile两个函数和clean"></a>makefile两个函数和clean</h2><p>src &#x3D; $(wildcard *.c)</p>
<p>找到当前目录下所有后缀为.c的文件，赋值给src</p>
<p>obj &#x3D; $(patsubset %.c,%.o, $(src))</p>
<p>把src变量里所有后缀为.c的文件替换成.o</p>
<p>rm前面的-，代表出错依然执行。比如，待删除文件集合是5个，已经手动删除了1个，就只剩下4个，然而删除命令里面还是5个的集合，就会有删除不存在文件的问题，不加这-，就会报错，告诉你有一个文件找不到。加了-就不会因为这个报错。</p>
<h2 id="makefile3个自动变量和模式规则"><a href="#makefile3个自动变量和模式规则" class="headerlink" title="makefile3个自动变量和模式规则"></a>makefile3个自动变量和模式规则</h2><p>3个自动变量</p>
<p>$@ ：在规则命令中，表示规则中的目标</p>
<p>$&lt; ：在规则命令中，表示规则中的第一个条件，如果将该变量用在模式规则中，它可以将依赖条件列表中的依赖依次取出，套用模式规则</p>
<p>$^ ：在规则命令中，表示规则中的所有条件，组成一个列表，以空格隔开，如果这个列表中有重复项，则去重</p>
<p>模式规则：</p>
<p>%.o:%.c</p>
<p>  gcc -c $&lt; -o $@</p>
<h2 id="静态模式规则"><a href="#静态模式规则" class="headerlink" title="静态模式规则"></a>静态模式规则</h2><p>继续优化makefile，使用静态模式规则，就是指定模式规则给谁用，这里指定模式规则给obj用，以后文件多了，文件集合会有很多个，就需要指定哪个文件集合用什么规则</p>
<p>$(obj):%.o:%.c</p>
<p>gcc -c $&lt; -o $@</p>
<p>再来一个扩展</p>
<p>当前文件夹下有ALL文件或者clean文件时，会导致makefile瘫痪，如下所示，make clean没有工作</p>
<p>用伪目标来解决，添加一行  .PHONY: clean ALL</p>
<p>还有一个扩展就是，编译时的参数，-g,-Wall这些，可以放在makefile里面</p>
<p>主要是注意%的匹配理解，只匹配文件名，目录位置要手动添加</p>
<p>如果makefile的名字变化一下，比如，叫m6</p>
<p>用m6执行makefile，   make -f m6</p>
<p>用m6执行clean      make -f m6 clean</p>
<p>源码 add.c,sub.c 这些在 src 目录下，.o 文件要放在 obj 目录下，头文件 head.h 在 inc 目录下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">src = $(wildcard ./src/*.c)	# ./src/add.c ./src/ sub.c...</span><br><span class="line">obj = $(patsubst ./src/%.c, ./obj/%.o，$(src))</span><br><span class="line">inc_path = ./inc</span><br><span class="line">myArgs = -Wall -g</span><br><span class="line">ALL:a.out</span><br><span class="line">$(obj):./obj/%.o:./src/%.c</span><br><span class="line">	gcc -c $&lt; -o $@ $(myArgs) -I $(inc_path)</span><br><span class="line">a.out: $(obj)</span><br><span class="line">	gcc $^ -o $@ $(myArgs)</span><br><span class="line">clean:</span><br><span class="line">	-rm -rf $(obj) a.out</span><br><span class="line">.PHONY: clean ALL</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/" class="post-title-link" itemprop="url">深入理解计算机系统 第三章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-13 11:28:04" itemprop="dateCreated datePublished" datetime="2023-05-13T11:28:04+08:00">2023-05-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-28 11:04:18" itemprop="dateModified" datetime="2023-05-28T11:04:18+08:00">2023-05-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第3章程序的机器级表示"><a href="#第3章程序的机器级表示" class="headerlink" title="第3章程序的机器级表示"></a>第3章程序的机器级表示</h1><h2 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h2><p>其中一些关于机器代码和它的反汇编表示的特性值得注意:</p>
<ul>
<li>x86-64的指令长度从1到15个字节不等。常用的指令以及操作数较少的指令所需的字节数少，而那些不太常用或操作数较多的指令所需字节数较多。</li>
<li>设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。例如，只有指令pushq %rbx是以字节值53开头的。</li>
<li>反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码。</li>
<li>反汇编器使用的指令命名规则与GCC生成的汇编代码使用的有些细微的差别。在我们的示例中，它省略了很多指令结尾的‘q’。这些后缀是大小指示符，在大多数情况中可以省略。相反，反汇编器给call和ret 指令添加了‘q’后缀，同样，省略这些后缀也没有问题。</li>
</ul>
<p>虽然C编译器在把程序中表达的计算转换到机器代码方面表现出色，但是仍然有一些机器特性是C程序访问不到的。例如，每次 x86-64处理器执行算术或逻辑运算时，如果得到的运算结果的低8位中有偶数个1，那么就会把一个名为PF的1位条件码(condition code)标志设置为1，否则就设置为0。这里的PF表示“parity flag(奇偶标志)”。在C语言中计算这个信息需要至少7次移位、掩码和异或运算。即使作为每次算术或逻辑运算的一部分，硬件都完成了这项计算，而C程序却无法知道PF条件码标志的值。在程序中插入几条汇编代码指令就能很容易地完成这项任务。</p>
<p>在C程序中插入汇编代码有两种方法。第一种是，我们可以编写完整的函数，放进一个独立的汇编代码文件中，让汇编器和链接器把它和用C语言书写的代码合并起来。第二种方法是，我们可以使用GCC的内联汇编(inline assembly)特性，用asm伪指令可以在C程序中包含简短的汇编代码。这种方法的好处是减少了与机器相关的代码量。</p>
<p>当然，在C程序中包含汇编代码使得这些代码与某类特殊的机器相关(例如x86-64)，所以只应该在想要的特性只能以此种方式才能访问到时才使用它。</p>
<h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><p>由于是从16位体系结构扩展成32位的，Intel用术语“字(word)”表示16位数据类型。因此，称32位数为“双字(double words)”，称64位数为“四字(quad words)”。C语言基本数据类型对应的x86-64表示。标准int值存储为双字(32位)。指针(在此用char *表示)存储为8字节的四字，64位机器本来就预期如此。</p>
<table>
<thead>
<tr>
<th>C声明</th>
<th>Intel数据类型</th>
<th>汇编代码后缀</th>
<th>大小(字节)</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>字节</td>
<td>b</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td>字</td>
<td>w</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>双字</td>
<td>l</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>四字</td>
<td>q</td>
<td>8</td>
</tr>
<tr>
<td>char*</td>
<td>四字</td>
<td>q</td>
<td>8</td>
</tr>
<tr>
<td>float</td>
<td>单精度</td>
<td>s</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>双精度</td>
<td>l</td>
<td>8</td>
</tr>
</tbody></table>
<h2 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h2><p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20230515185054534.jpg" alt="image-20230515185054534"></p>
<img src="/2023/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20230515185054534.jpg" class title="This is an test image">

<h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p>MOV指令源和目的类型的组合。记住，<strong>第一个是源操作数，第二个是目的操作数。</strong></p>
<p>源操作数指定的值是一个立即数，存储在寄存器中或者内存中。目的操作数指定一个位置，要么是一个寄存器或者，要么是一个内存地址。</p>
<p>寄存器部分的大小必须与指令最后一个字符(‘b’，‘w’，‘1’或‘q’)指定的大小匹配。大多数情况中，MOV指令只会更新目的操作数指定的那些寄存器字节或内存位置。唯一的例外是movl指令以寄存器作为目的时，它会把该寄存器的高位4字节设置为0。造成这个例外的原因是x86-64采用的惯例，即任何为寄存器生成32位值的指令都会把该寄存器的高位部分置成0。</p>
<p>常规的movq指令只能以表示为32位补码数字的立即数作为源操作数，然后把这个值符号扩展得到64位的值，放到目的位置。movabsq指令能够以任意64位立即数值作为源操作数，并且只能以寄存器作为目的。</p>
<p>所有这些指令都把数据从源(在寄存器或内存中)复制到目的寄存器。MOVZ类中的指令把目的中剩余的字节填充为0，而MOVS类中的指令通过符号扩展来填充，把源操作的最高位进行复制。可以观察到，每条指令名字的最后两个字符都是大小指示符:第一个字符指定源的大小，而第二个指明目的的大小。</p>
<p><strong>局部变量通常是保存在寄存器中</strong>，而不是内存中。访问寄存器比访问内存要快得多。</p>
<h2 id="算术和逻辑操作"><a href="#算术和逻辑操作" class="headerlink" title="算术和逻辑操作"></a>算术和逻辑操作</h2><h3 id="加载有效地址"><a href="#加载有效地址" class="headerlink" title="加载有效地址"></a>加载有效地址</h3><p>加载有效地址(load effective address)指令leaq实际上是movq指令的变形。它的指令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。它的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读人数据，而是将有效地址写入到目的操作数。</p>
<h3 id="二元操作"><a href="#二元操作" class="headerlink" title="二元操作"></a>二元操作</h3><p>二元操作，其中，第二个操作数既是源又是目的。这种语法让人想起C语言中的赋值运算符，例如x-&#x3D;y。不过，要注意，源操作数是第一-个，目的操作数是第二个,对于不可交换操作来说，这看上去很奇特。例如，指令<code>subq %rax,%rdx</code>使寄存器%rdx的值减去%rax中的值。(将指令解读成“从%rdx中减去%rax”会有所帮助。)第一个操作数可以是立即数、寄存器或是内存位置。第二个操作数可以是<strong>寄存器或是内存位置</strong>。注意,当第二个操作数为内存地址(如果是寄存器地址加操作数格式则表示内存位置)时，处理器必须从内存读出值，执行操作，再把结果写回内存。</p>
<p>通常，编译器产生的代码中，会用一个寄存器存放多个程序值，还会在寄存器之间传送程序值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xorq %rdx, %rdx</span><br></pre></td></tr></table></figure>

<p>但是在产生这段汇编代码的 C 代码中，并没有出现 EXCLUSIVE-OR 操作。</p>
<p>A. 解释这条特殊的 EXCLUSIVE-OR 指令的效果，它实现了什么有用的操作。</p>
<p>B. 更直接地表达这个操作的汇编代码是什么？</p>
<p>C. 比较同样一个操作的两种不同实现的编码字节长度。</p>
<blockquote>
<p>A. 这个指令用来将寄存器 % rdx 设置为 0，运用了对任意 x，x^x&#x3D;0 这一属性。它对应于 C 语句 x&#x3D;0 。</p>
<p>B. 将寄存器 % rdx 设置为 0 的更直接的方法是用指令 movq $0, % rdx 。</p>
<p>C. 汇编和反汇编这段代码，我们发现使用 xorq 的版本只需要 3 个字节，而使用 movq 的版本需要 7 个字节。其他将 % rdx 设置为 0 的方法都依赖于这样一个属性，即任何更新低位 4 字节的指令都会把高位字节设置为 0 。因此，我们可以使用 xorl % edx, % edx（2 字节）或 movl $0, % edx（5 字节）。</p>
</blockquote>
<h3 id="特殊的算术操作"><a href="#特殊的算术操作" class="headerlink" title="特殊的算术操作"></a>特殊的算术操作</h3><p>此外，x86-64 指令集还提供了两条不同的“单操作数”乘法指令，以计算两个64位值的全128位乘积——一个是无符号数乘法(mulq)，而另一个是补码乘法(imulq)。这两条指令都要求一个参数必须在寄存器%rax中，而另一个作为指令的源操作数给出。然后乘积存放在寄存器%rdx(高64位)和%rax(低64位)中。虽然imulq这个名字可以用于两个不同的乘法操作，但是汇编器能够通过计算操作数的数目，分辨出想用哪条指令。</p>
<p>有符号除法指令idivl将寄存器%rdx(高64位)和%rax(低64位)中的128位数作为被除数，而除数作为指令的操作数给出。指令将商存储在寄存器%rax中，将余数存储在寄存器%rdx中。</p>
<p>对于大多数64位除法应用来说，除数也常常是一个64位的值。这个值应该存放在%rax中，%rdx的位应该设置为全0(无符号运算)或者%rax的符号位(有符号运算)。后面这个操作可以用指令cqto来完成。这条指令不需要操作数—它隐含读出%rax的符号位，并将它复制到%rdx的所有位。即汇编代码中除法前一行就是cqto.</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>为了提高空间和时间效率，x86-64过程只分配自己所需要的栈帧部分。例如，许多过程有6个或者更少的参数，那么所有的参数都可以通过寄存器传递。因此，某些栈帧部分可以省略。实际上，许多函数甚至根本不需要栈帧。当所有的局部变量都可以保存在寄存器中，而且该函数不会调用任何其他函数(有时称之为叶子过程，此时把过程调用看做树结构)时，就可以这样处理。</p>
<p>x86-64 中，可以通过寄存器最多传递6个整型(例如整数和指针)参数。寄存器的使用是有特殊顺序的，寄存器使用的名字取决于要传递的数据类型的大小，如果一个函数有大于6个整型参数，超出6个的部分就要通过栈来传递。</p>
<p>T2（callq）是子程序调用指令，这条指令会：</p>
<ol>
<li>调整栈寄存器 (%rsp-8 -&gt; %rsp）</li>
<li>把下一条指令的地址放到栈里（0x40054e-&gt;*%rsp)</li>
<li>以上两步简单来说就是把下一条指令的地址入栈（push）</li>
<li>然后子程序的地址（0x400540）加载至rip</li>
</ol>
<p>然后子程序开始执行。子程序以retq结束会执行出栈（pop）操作：</p>
<ol>
<li>当前的栈内容放入%rip</li>
<li>调整栈寄存器（%rsp+8 -&gt; %rsp）</li>
</ol>
<p>程序从0x40054e继续执行（之前入栈的地址）<strong>栈区的地址分配是从内存的高地址开始向低地址分配；</strong></p>
<h3 id="栈上的局部存储"><a href="#栈上的局部存储" class="headerlink" title="栈上的局部存储"></a>栈上的局部存储</h3><p>到目前为止我们看到的大多数过程示例都不需要超出寄存器大小的本地存储区域。不过有些时候，局部数据必须存放在内存中，常见的情况包括:</p>
<ul>
<li>寄存器不足够存放所有的本地数据。</li>
<li>对一个局部变量使用地址运算符‘&amp;’，因此必须能够为它产生一个地址（用leaq指令生成到这些位置的指针）。</li>
<li>某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到。在描述数组和结构分配时，我们会讨论这个问题。</li>
</ul>
<p>一般来说，过程通过减小栈指针在栈上分配空间。分配的结果作为栈帧的一部分，标号为“局部变量”。</p>
<h3 id="寄存器的局部存储空间"><a href="#寄存器的局部存储空间" class="headerlink" title="寄存器的局部存储空间"></a>寄存器的局部存储空间</h3><p>根据惯例，寄存器rbx、%rbp和%r12～%r15被划分为被调用者保存寄存器。当过程P调用过程Q时，Q必须保存这些寄存器的值，保证它们的值在Q返回到P时与Q被调用时是一样的。过程Q保存一个寄存器的值不变，要么就是根本不去改变它，要么就是把原始值压入栈中，改变寄存器的值，然后在返回前从栈中弹出旧值。压人寄存器的值会在栈帧中创建标号为“保存的寄存器”的一部分。有了这条惯例，P的代码就能安全地把值存在被调用者保存寄存器中(当然，要先把之前的值保存到栈上)，调用Q,然后继续使用寄存器中的值,不用担心值被破坏。</p>
<h2 id="异数的数据结构"><a href="#异数的数据结构" class="headerlink" title="异数的数据结构"></a>异数的数据结构</h2><h3 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h3><p>还可以观察到，一个联合的总的大小等于它最大字段的大小。<br>在一些下上文中，联合十分有用。但是，它也能引起一些讨厌的错误，因为它们绕过了C语言类型系统提供的安全措施。一种应用情况是，我们事先知道对一个数据结构中的两个不同字段的使用是互斥的，那么将这两个字段声明为联合的一部分，而不是结构的一部分，会减小分配空间的总量。</p>
<p>开始的跳转表的汇编代码声明在第2行包含下面这样的命令:<br>.align 8<br>这就保证了它后面的数据(在此，是跳转表的开始)的起始地址是8的倍数。因为每个表项长8个字节，后面的元素都会遵守8字节对齐的限制。</p>
<h2 id="在机器级程序中将控制与数据结合起来"><a href="#在机器级程序中将控制与数据结合起来" class="headerlink" title="在机器级程序中将控制与数据结合起来"></a>在机器级程序中将控制与数据结合起来</h2><h3 id="理解指针"><a href="#理解指针" class="headerlink" title="理解指针"></a>理解指针</h3><p>leaq指令是设计用来计算内存引用的地址的，&amp;运算符的机器代码实现常常用这条指令来计算表达式的值。</p>
<h3 id="GDB命令"><a href="#GDB命令" class="headerlink" title="GDB命令"></a>GDB命令</h3><p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20230524151520753.png" alt="image-20230524151520753"></p>
<img src="/2023/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20230524151520753.png" class title="This is an test image">

<p>GDB的命令语法有点晦涩，但是在线帮助信息(用GDB的 help命令调用)能克服这些毛病。相对于使用命令行接口来访问GDB，许多程序员更愿意使用DDD，它是 GDB的一个扩展，提供了图形用户界面。</p>
<h3 id="内存越界引用和缓冲区溢出"><a href="#内存越界引用和缓冲区溢出" class="headerlink" title="内存越界引用和缓冲区溢出"></a>内存越界引用和缓冲区溢出</h3><p>更好一点的版本是使用fgets函数，它包括一个参数，限制<strong>待读入的最大字节数</strong>。通常，使用gets或其他任何能导致存储溢出的函数，都是不好的编程习惯。不幸的是，很多常用的库函数，包括strcpy、strcat和 sprintf都有一个属性——不需要告诉它们目标缓冲区的大小，就产生一个字节序列[97]。超过待读入最大字节数就可能发生错误，这样的情况就会导致缓冲区溢出漏洞。</p>
<p>如在栈上分配了24个字节，待读入最大字节为8</p>
<p>echo执行时栈的组织。该程序把栈指针减去了24，在栈上分配了24个字节。字符数组buf位于栈顶，可以看到,%rsp被复制到%rdi作为调用gets和puts 的参数。这个调用的参数和存储的返回指针之间的16字节是未被使用的。只要用户输人不超过7个字符，gets返回的字符串(包括结尾的null)就能够放进为buf分配的空间里。不过，长一些的字符串就会导致gets覆盖栈上存储的某些信息。随着字符串变长，下面的信息会被破坏:</p>
<p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20230525102612348.png" alt="image-20230525102612348"></p>
<img src="/2023/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20230525102612348.png" class title="This is an test image">

<h2 id="浮点代码"><a href="#浮点代码" class="headerlink" title="浮点代码"></a>浮点代码</h2><p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20230527153556717.png" alt="image-20230527153556717"></p>
<img src="/2023/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0/image-20230527153556717.png" class title="This is an test image">

<p>在x86-64 中，XMM寄存器用来向函数传递浮点参数，以及从函数返回浮点值。如图3-45所示，可以看到如下规则:</p>
<ul>
<li>XMM寄存器%xmm0～%xmm7最多可以传递8个浮点参数。按照参数列出的顺序使用这些寄存器。可以通过栈传递额外的浮点参数。</li>
<li>函数使用寄存器%xmm0来返回浮点值。</li>
<li>所有的XMM寄存器都是调用者保存的。被调用者可以不用保存就覆盖这些寄存器中任意一个。</li>
</ul>
<p>当函数包含指针、整数和浮点数混合的参数时，指针和整数通过通用寄存器传递，而浮点值通过XMM寄存器传递。也就是说，参数到寄存器的映射取决于它们的类型和排列的顺序。下面是一些例子:<br><code>double f1(int x,double y, long z);</code><br>这个函数会把x存放在% edi中，y放在%xmm0中，而z放在%rsi中。<br><code>double f2(double y, int x，long z);</code><br>这个函数的寄存器分配与函数f1相同。<br><code>double f1(float x, double *y，long*z);</code><br>这个函数会将x放在%xmm0中，y放在%rdi中，而z放在%rsi中。</p>
<h3 id="定义和使用浮点常数"><a href="#定义和使用浮点常数" class="headerlink" title="定义和使用浮点常数"></a>定义和使用浮点常数</h3><p>和整数运算操作不同，AVX浮点操作不能以立即数值作为操作数。相反，编译器必须为所有的常量值分配和初始化存储空间。然后代码在把这些值从内存读人。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">深入理解计算机系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-05 16:12:22" itemprop="dateCreated datePublished" datetime="2023-05-05T16:12:22+08:00">2023-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-11 17:40:00" itemprop="dateModified" datetime="2023-05-11T17:40:00+08:00">2023-05-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第2章-信息的表示和处理"><a href="#第2章-信息的表示和处理" class="headerlink" title="第2章 信息的表示和处理"></a>第2章 信息的表示和处理</h1><h4 id="文字编码的Unicode标准"><a href="#文字编码的Unicode标准" class="headerlink" title="文字编码的Unicode标准"></a>文字编码的Unicode标准</h4><p>基本编码，称为Unicode的“统一字符集”，使用32位来表示字符。这好像要求文本串中每个字符要占用4个字节。不过，可以有一些替代编码，常见的字符只需要1个或2个字节，而不太常用的字符需要多一些的字节数。特别地，UTF-8表示将每个字符编码为一个字节序列，<strong>这样标准ASCII字符还是使用和它们在ASCII 中一样的单字节编码</strong>，这也就意味着所有的ASCII字节序列用ASCII码表示和用UTF-8表示是一样的。</p>
<p>Java编程语言使用Unicode来表示字符串。对于C语言也有支持 Unicode的程序库。</p>
<p>在使用ASCII码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关。因而，<strong>文本数据比二进制数据具有更强的平台独立性</strong>。</p>
<p>不同的机器类型使用不同的且不兼容的指令和编码方式。即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。</p>
<h2 id="c语言的移位运算"><a href="#c语言的移位运算" class="headerlink" title="c语言的移位运算"></a>c语言的移位运算</h2><p>C语言标准并没有明确定义对于有符号数应该使用哪种类型的右移–算术右移或者<strong>逻辑右移</strong>（不管符号均补0）都可以。不幸地，这就意味着任何假设一种或者另一种右移形式的代码都可能会遇到可移植性问题。然而，实际上，几乎所有的编译器&#x2F;机器组合都对有符号数使用<strong>算术右移</strong>（有符号时最高位是1补1），且许多程序员也都假设机器会使用这种右移。另一方面，对于无符号数，右移必须是逻辑的。<br>与C相比，Java对于如何进行右移有明确的定义。表达是x&gt;&gt;k会将x算术右移k个位置，而x&gt;&gt;&gt;k会对x做逻辑右移。</p>
<h3 id="移动k-位，这里k-很大"><a href="#移动k-位，这里k-很大" class="headerlink" title="移动k 位，这里k 很大"></a>移动k 位，这里k 很大</h3><p>对于一个由w位组成的数据类型，如果要移动k≥w位会得到什么结果呢?例如，计算下面的表达式会得到什么结果，假设数据类型int为w&#x3D;32:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">intlval =OxFEDCBA98&lt;&lt; 32;</span><br><span class="line">intaval =OxFEDCBA98&gt;&gt;36;</span><br><span class="line">unsigned uval =OxFEDCBA98u &gt;&gt;40;</span><br></pre></td></tr></table></figure>

<p>C语言标准很小心地规避了说明在这种情况下该如何做。在许多机器上，当移动一个w位的值时，移位指令只考虑位移量的低 log2 w位，因此实际上位移量就是通过计算k mod w得到的。例如，当w&#x3D;32时，上面三个移位运算分别是移动0、4和8位，得到结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lval 0xFEDCBA98</span><br><span class="line">aval 0xFFEDCBA9</span><br><span class="line">uval 0x00FEDCBA</span><br></pre></td></tr></table></figure>

<p>不过这种行为对于C程序来说是没有保证的，所以应该保持位移量小于待移位值的位数。另一方面，Java 特别要求位移数量应该按照我们前面所讲的求模的方法来计算。</p>
<h2 id="补码编码"><a href="#补码编码" class="headerlink" title="补码编码"></a>补码编码</h2><p>采用补码表示的32位大端法机器（符合习惯，先输出低地址的高位）上输出打印16进制时：是看补码来转换。</p>
<p>原理:补码编码的定义<br><img src="/2023/05/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Users\86191\AppData\Roaming\Typora\typora-user-images\image-20230507151108343.png" alt="image-20230507151108343"></p>
<p>例如1001（-1）的补码是1111可以根据上面计算-8+7&#x3D;-1</p>
<p><strong>负数的补码，是能够和其相反数相加通过溢出从而使计算机内计算结果变为0的二进制码</strong>。这是补码设计的初衷，具体目标就是让1+（-1）&#x3D;0，这利用原码是无法得到的</p>
<p>对于大多数C语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是:数值可能会改变，但是<strong>位模式不变</strong>。</p>
<p>无符号表示中的UMax竟有着和补码表示的-1相同的位模式。我们在这两个数之间也能看到这种关系<br>$$<br>:1+UMax_w&#x3D;2^w<br>$$<br>原理:补码转换为无符号数<br>对满足TMin_x≤x≤TMax_w的x有:<br>$$<br>T2U_w(x)&#x3D;\begin{cases} x+2^w,x&lt;0\ x,x&gt;&#x3D;0\end{cases}<br>$$<br>一个无符号数u和与之对应的有符号数U2T_w(u)之间的关系:</p>
<p>原理:无符号数转换为补码</p>
<p>对满足0≤u≤UMax _w的u有:<br>$$<br>U2T_w(u)&#x3D;\begin{cases} u-2^w,u&gt;TMax_w\ u,x&lt;&#x3D;TMax_w\end{cases}<br>$$<br>总结一下，我们考虑无符号与补码表示之间互相转换的结果。对于在范围0≤T&lt;TMax_w之内的值x而言，我们得到T2U_w(x)&#x3D;x和U2T_w(x)&#x3D;x。也就是说，在这个范围内的数字有相同的无符号和补码表示。对于这个范围以外的数值，转换需要加上或者减去2^w。例如，我们有<br>$$<br>T2U_w(-1)&#x3D;-1+2^w&#x3D;UMax_w<br>$$<br>—-最靠近0的负数映射为最大的无符号数</p>
<h2 id="c语言里面TMin不能写成-2147483648的原因"><a href="#c语言里面TMin不能写成-2147483648的原因" class="headerlink" title="c语言里面TMin不能写成-2147483648的原因"></a>c语言里面TMin不能写成-2147483648的原因</h2><p>C语言中，将TMin（32位有符号整数的最小值）写成 <strong>-2147483647-1</strong>，而不是简单地写成 -2147483648 或 0x80000000 。</p>
<p>可见如果不发生溢出，整型常量的值总是非负数。如果前面<strong>出现符号</strong>，则是对整型常量使用的一元运算符，而不是整型常量的一部分。</p>
<p>如果将TMin32写成-2147483648并且将代码在一个32位的机器上面编译，当编译器遇到**-X<strong>形式的数值，它首先会确定</strong>X<strong>的数据类型和值，然后取</strong>X**的。</p>
<p>由于-2147483648超过了int所能够表示的范围，编译器就会再次选择一种可以正确的表示此值的类型。然后它就会按照第一个表格（十进制）的顺序往下继续尝试类型，再假设编译器采用的标准是ISO C90，int-&gt;long-&gt;unsigned，然后就发现unsigned是第一个合适的数据类型。正如我们知道的，2147483648和-2147483648在32位数值上拥有同样的位表示，使得此常量的最终数据类型是unsigned且值为2147483648。这对于16进制的0x80000000也是相同的结果。</p>
<p>用一句话来解释C语言中TMin32的古怪写法的原因：虽然-2147483648 这个数值能够用int类型(4字节)来表示，但在C语言中却没法写出对应这个数值的int类型常量。</p>
<h2 id="补码的非"><a href="#补码的非" class="headerlink" title="补码的非"></a>补码的非</h2><p>原理:补码的非<br>对满足TMin_w≤x≤TMax_w 的x，其补码的非-^t_wx由下式给出<br>$$<br>-^t_wx&#x3D;\begin{cases}TMin_w,x&#x3D;TMin_w\-x,x&gt;TMin_w\end{cases}<br>$$<br>此处设w&#x3D;4，用补码可表示的范围就是[-8,7]，对于-8，它的“补码的非”还是-8,而[-7,7]补码的非就是原数的负数，比如说-4的“补码的非”是-4取负，即：4，而3的“补码的非”是3取负，即：-3。这是“补码的非”的定义；注意：“补码的非”并不是把“一个数的补码按位取非”</p>
<p>TMin_w&#x3D;-2^w-1</p>
<p>执行位级补码非的第一种方法是对每一位求反，再对结果加1。在C语言中，我们可以说，对于任意整数值x，计算表达式-x和~x+1得到的结果完全一样。</p>
<h2 id="对TMin-w-x3D-2-w-1的解释"><a href="#对TMin-w-x3D-2-w-1的解释" class="headerlink" title="对TMin_w&#x3D;-2^w-1的解释"></a>对TMin_w&#x3D;-2^w-1的解释</h2><p>如w&#x3D;4的-8&#x3D;1000，可以参考-2为例</p>
<p>[-2]原 &#x3D; 1 0010    [-2]补 &#x3D; 11110</p>
<p>如我所说，没有符号位，那么11110就是30，也就是说 -2的补码是30（%2^5）</p>
<h2 id="补码移位"><a href="#补码移位" class="headerlink" title="补码移位"></a>补码移位</h2><p>移位也是运算，需要将负数的原码变成补码移位</p>
<p>对无符号运算使用移位是非常简单的，部分原因是由于无符号数的右移一定是逻辑右移（不管最高位符号）。对于x大于等于0的有符号一样逻辑右移。</p>
<p>负数在执行算术右移之前加上一个适当的偏置量是可以导致结果正确舍入的。</p>
<p>补码除以2的幂(<strong>右移之前加上一个偏量</strong>，结果就向零舍入了).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int optarith(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    int t = x;</span><br><span class="line">    x &lt;&lt;= 5;</span><br><span class="line">    x -= t;</span><br><span class="line">    if (y &lt; 0)</span><br><span class="line">        y += 7;//加上一个适当的偏置量111,是为了正确右移3位，若右移4位，则加15（1111）</span><br><span class="line">    y &gt;&gt;= 3; /* Arithmetic shift */</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IEEE浮点标准"><a href="#IEEE浮点标准" class="headerlink" title="IEEE浮点标准"></a>IEEE浮点标准</h2><p>IEEE浮点标准用<br>$$<br>V&#x3D;（-1）^s<em>M</em>2^E<br>$$<br> 的形式来表示一个数，符号s，尾数M，阶码E</p>
<p>C语言中，单精度（float）的s为1b，E为8b，M为23b，双精度（double）的s为1b，E为11b，M为52b。</p>
<p>阶码的值<strong>E&#x3D;e-Bias</strong>，e是无符号数，Bias为偏置值，等于 2^(k-1)−1 (float为127，double为1023)</p>
<h3 id="计算-IEEE-754-标准浮点数的真值"><a href="#计算-IEEE-754-标准浮点数的真值" class="headerlink" title="计算 IEEE 754 标准浮点数的真值"></a>计算 IEEE 754 标准浮点数的真值</h3><p>在上述内容的分析之后，再通过观察分析以下这个 IEEE 754 单精度浮点数格式表示的数，系统性了解如何计算出 IEEE 754 标准浮点数的真值：</p>
<p>1 100 0000 1010 0000 0000 0000 0000 0000<br>上数分别对应图1-1的中 S（符号码，0 正，1 负），E (阶码) ，M (尾数数值)为：</p>
<p>S (红色部分) ：1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1，表示这个浮点数是个负数；</span><br></pre></td></tr></table></figure>

<p>E (蓝色部分) ：100 0000 1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100 0000 1，阶码，其真值为 ：移码 - 偏置值 =&gt; 1000 0001 - 0111 1111 = 0000 0010 = 2D；（对应下面的2^2D）</span><br></pre></td></tr></table></figure>

<p>M (黑色部分) ：010 0000 0000 0000 0000 0000</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">010 0000 0000 0000 0000 0000 表示这个浮点数的尾数部分，其真值为：被隐含的最高位1 + 0.尾数部分 =&gt; 1 + 0.01 = 1.01B;</span><br></pre></td></tr></table></figure>

<p>通过对 S，E，M 的分析，我们可以计算出该浮点数的真值，即：</p>
<p>-1.01B * 2^10B &#x3D; 1.25D （-1.01B）* 2^2D &#x3D; -5.0D</p>
<hr>
<p>十进制数12345具有二进制[0011 0000 0011 1001]（0x3039），通过将二进制小数点左移13位，得到这个数的一个规格化表示 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12345=1.1000000111001_2×2^13 </span><br></pre></td></tr></table></figure>

<p>，为了使用IEEE单精度（float）形式来编码，我们丢弃开头的1，并且在末尾增加10个0（单精度的尾数位23位，13+10&#x3D;23），来构造小数字段，得到二进制[1000000111001<em>0000000000</em>]，为了得到阶码字段，将13加上偏置量127，得到140，二进制表示为[10001100]，加上符号位0，得到12345.0的二进制浮点数[0100 0110 0100 0000 1110 0100 0000 0000]（0x4640E400），比较整数12345（0x3039）和浮点数12345.0（0x4640E400）的位级表示：</p>
<p>（0x00003039）0000000000000000001<em><strong>1000000111001</strong></em></p>
<p>（0x4640E400）010001100<em><strong>1000000111001</strong></em>0000000000</p>
<p>阶码的值E&#x3D;e-Bias,产生指数的取值范围，对于单精度是一126～＋127，而对于双精度是一1022~+1023。</p>
<h3 id="十进制数转为-IEEE-754-浮点数格式"><a href="#十进制数转为-IEEE-754-浮点数格式" class="headerlink" title="十进制数转为 IEEE 754 浮点数格式"></a>十进制数转为 IEEE 754 浮点数格式</h3><p>同样地再用一个例子 十进制数转为 IEEE 754 浮点数的例子，加深对 十进制数 与 IEEE 754 浮点数之间的转换的理解。</p>
<p> 例如：将十进制数 -0.75 转为 IEEE 754 的单精度浮点数格式表示，分析过程如下：</p>
<p>过程A： -0.75D &#x3D; -0.11B &#x3D; -1.1B * 2^(-1B)<br>S：1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-0.75 为负数，故 S 符号码为 1</span><br></pre></td></tr></table></figure>

<p>E：0111 1110</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由 过程A 得，阶码的真值为 -0000 0001(因为是2^(-1B)，与上面例子一致) ，其移码为：-0000 0001 + 0111 1111 = 0111 1110</span><br></pre></td></tr></table></figure>

<p>M：100 0000 0000 0000 0000 0000</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由 过程A 得，尾数码真值为：-1.1，隐含最高位 1 ，取小数部分，得100 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>

<p>最终结果为：</p>
<p>1 011 1111 0100 0000 0000 0000 0000 0000</p>
<h2 id="向偶数舍人在大多数现实情况中避免了这种统计偏差。"><a href="#向偶数舍人在大多数现实情况中避免了这种统计偏差。" class="headerlink" title="向偶数舍人在大多数现实情况中避免了这种统计偏差。"></a><strong>向偶数舍人在大多数现实情况中避免了这种统计偏差</strong>。</h2><p>在50%的时间里，它将向上舍人，而在50%的时间里，它将向下舍入。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/24/c-%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/24/c-%E7%B1%BB/" class="post-title-link" itemprop="url">c++类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-24 09:39:59 / 修改时间：15:12:34" itemprop="dateCreated datePublished" datetime="2023-04-24T09:39:59+08:00">2023-04-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>C++要求对一般的内置函数要用关键字inline声明，但对类内定义的成员函数，可以省略inline，因为<strong>这些成员函数已经被隐含地指定为内置函数了</strong>。</p>
<p>类的隐式内联和显式内联：</p>
<ul>
<li>类内部的内联函数：类内部只要定义在函数其实都是默认inline的（即通常我们说的尽量不要往.h中类定义的地方直接定义函数，最好只是做一个申明，这个说法其实不太好，因为这会破坏隐藏内联的功能）。</li>
<li>虽然说即便是隐藏的内联，也不一定是内联的，最后还是编译器决定，但是定义在.cpp中的内容，等于是放弃了内联功能，这种可能性降低的写法其实是不推荐的。</li>
<li>另外，也可以用inline放在开头，进行显式的内联，但是仍然需要注意：类内部成员函数的申明和最终的成员函数的定义（可以放在类定义的外部，但是还是要在同一个.h中，否则inline不会生效）。所以，从这个角度看，基本上可以引出一条规定：一些简单的函数、构造函数、析构函数，推荐在类内部进行直接定义，这样能够用到inline功能，对于性能来说更加有利的。至于可读性方面的考虑，完全可以加一些范围的注释、分类，将需要inline的定义在一撮，另外需要在cpp中实现的“复杂”函数，申明在另外一撮。</li>
</ul>
<h2 id="C-中常量成员函数"><a href="#C-中常量成员函数" class="headerlink" title="C++中常量成员函数"></a>C++中常量成员函数</h2><p>可以将C++中类的成员函数声明为常量，这种成员函数叫做常量成员函数（const member function）。</p>
<h3 id="1-声明"><a href="#1-声明" class="headerlink" title="1 声明"></a>1 声明</h3><p>将const关键字放在类成员函数的参数列表之后，表示该函数为常量成员函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class MyClass</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">int consFunc() const;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">int m_MyNum;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-定义"><a href="#2-定义" class="headerlink" title="2 定义"></a>2 定义</h3><p>可以在类内定义consFunc()函数，也可以在类外定义。不管是在类内还是类外定义该函数，都要使用关键字const。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int MyClass::consFunc() const</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">return this-&gt;m_MyNum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-含义"><a href="#3-含义" class="headerlink" title="3 含义"></a>3 含义</h3><p>在“2定义”中定义的consFunc()函数中，如果不添加const关键字，此时constFunc()是普通的成员函数，此时this的类型是MyClass* const，即this本身是常量，但是其指向的类型是非常量。这就意味着我们不能把this绑定到一个常量对象上。如果要把this绑定到一个常量对象上，必须要把this定义成const MyClass* const，即指向常量的常量。在类成员函数的参数列表之后添加const关键字，就相当于把this定义成const MyClass* const。</p>
<h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4 注意事项"></a>4 注意事项</h3><h4 id="4-1-常量对象必须调用常量成员函数"><a href="#4-1-常量对象必须调用常量成员函数" class="headerlink" title="4.1 常量对象必须调用常量成员函数"></a>4.1 常量对象必须调用常量成员函数</h4><p>正如“3 含义”中提到的，如果通过常量对象调用类的成员函数，该成员函数必须是常量成员函数。</p>
<h4 id="4-2-非常量对象可以调用常量成员函数"><a href="#4-2-非常量对象可以调用常量成员函数" class="headerlink" title="4.2 非常量对象可以调用常量成员函数"></a>4.2 非常量对象可以调用常量成员函数</h4><p>因为可以将一个非常量赋值给常量，所以非常量对象可以调用常量成员函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass myclass;</span><br><span class="line"></span><br><span class="line">myclass.consFunc();</span><br></pre></td></tr></table></figure>



<h4 id="4-3-常量成员函数中不能修改成员变量"><a href="#4-3-常量成员函数中不能修改成员变量" class="headerlink" title="4.3 常量成员函数中不能修改成员变量"></a>4.3 常量成员函数中不能修改成员变量</h4><p>因为常量成员函数中的this类型是const MyClass* const，所以不能通过this来修改成员变量。</p>
<p>如果consFunc()函数的定义改为如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int MyClass::consFunc() const</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">return this-&gt;m_MyNum++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则此时程序会报错，error C3490: 由于正在通过常量对象访问“m_MyNum”，因此无法对其进行修改。</p>
<hr>
<p>编译器分两步处理类:首先编译成员的声明，然后才轮到成员函数体（如果有的话)。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">肖汇林</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">肖汇林</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
