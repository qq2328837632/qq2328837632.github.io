<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="选择有时候比努力更重要">
<meta property="og:type" content="website">
<meta property="og:title" content="肖汇林的博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="肖汇林的博客">
<meta property="og:description" content="选择有时候比努力更重要">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="肖汇林">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>肖汇林的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖汇林的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/10/%E7%AC%AC%E5%85%AB%E5%A4%A9-c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/10/%E7%AC%AC%E5%85%AB%E5%A4%A9-c/" class="post-title-link" itemprop="url">第八天 c++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-10 16:38:50 / 修改时间：21:37:43" itemprop="dateCreated datePublished" datetime="2023-04-10T16:38:50+08:00">2023-04-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="stack容器"><a href="#stack容器" class="headerlink" title="stack容器"></a>stack容器</h2><h3 id="stack基本概念"><a href="#stack基本概念" class="headerlink" title="stack基本概念"></a>stack基本概念</h3><p>概念: stack是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口</p>
<p>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p>
<h3 id="stack常用接口"><a href="#stack常用接口" class="headerlink" title="stack常用接口"></a>stack常用接口</h3><p>功能描述:栈容器常用的对外接口</p>
<p>构造函数:</p>
<ul>
<li>stack<T> stk;&#x2F;&#x2F;stack采用模板类实现, stack对象的默认构造形式</li>
<li>stack( const stack &amp;stk);&#x2F;&#x2F;拷贝构造函数</li>
</ul>
<p>赋值操作:</p>
<ul>
<li>stack&amp; operator&#x3D;(const stack &amp;stk);&#x2F;&#x2F;重载等号操作符</li>
</ul>
<p>数据存取:</p>
<ul>
<li>push(elem);&#x2F;&#x2F;向栈顶添加元素</li>
<li>pop();&#x2F;&#x2F;从栈顶移除第一个元素</li>
<li>top();&#x2F;&#x2F;返回栈顶元素</li>
</ul>
<p>大小操作:</p>
<ul>
<li>empty();&#x2F;&#x2F;判断堆栈是否为空</li>
<li>size();&#x2F;&#x2F;返回栈的大小</li>
</ul>
<h2 id="queue容器"><a href="#queue容器" class="headerlink" title="queue容器"></a>queue容器</h2><h3 id="queue基本概念"><a href="#queue基本概念" class="headerlink" title="queue基本概念"></a>queue基本概念</h3><p>概念:Queud是一种先进先出(First ln First Out,FIFO)的数据结构，它有两个出口</p>
<ul>
<li>队列容器允许从一端新增元素，从另一端移除元素</li>
<li>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</li>
<li>队列中进数据称为—入队push</li>
<li>队列中出数据称为—出队pop</li>
</ul>
<h3 id="queue-常用接口"><a href="#queue-常用接口" class="headerlink" title="queue 常用接口"></a>queue 常用接口</h3><p>功能描述:栈容器常用的对外接口</p>
<p>构造函数:</p>
<ul>
<li>queue<T> que;&#x2F;&#x2F;queue采用模板类实现，queue对象的默认构造形式</li>
<li>queue(const queue &amp;que) ;&#x2F;&#x2F;拷贝构造函数</li>
</ul>
<p>赋值操作:</p>
<ul>
<li>queue&amp; operator&#x3D;(const queue &amp;que) ;&#x2F;&#x2F;重载等号操作符</li>
</ul>
<p>数据存取:</p>
<ul>
<li>push(elem) ;&#x2F;&#x2F;往队尾添加元素</li>
<li>pop();&#x2F;&#x2F;从队头移除第一个元素</li>
<li>back();&#x2F;&#x2F;返回最后一个元素</li>
<li>front();&#x2F;&#x2F;返回第一个元素</li>
</ul>
<p>大小操作:</p>
<ul>
<li>empty();&#x2F;&#x2F;判断堆栈是否为空</li>
<li>size();&#x2F;&#x2F;返回栈的大小</li>
</ul>
<h2 id="list容器"><a href="#list容器" class="headerlink" title="list容器"></a>list容器</h2><h3 id="list基本概念"><a href="#list基本概念" class="headerlink" title="list基本概念"></a>list基本概念</h3><p>功能:将数据进行链式存储</p>
<p>链表(list)是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p>
<p>链表的组成:链表由一系列结点组成</p>
<p>结点的组成:一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域</p>
<p>STL中的链表是一个双向循环链表</p>
<p>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器</p>
<p>list的优点:</p>
<ul>
<li>采用动态存储分配，不会造成内存浪费和溢出</li>
<li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li>
</ul>
<p>list的缺点:</p>
<ul>
<li>链表灵活，但是空间(指针域)和时间(遍历额外耗费较大</li>
</ul>
<p>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</p>
<p>总结:STL中List和vector是两个最常被使用的容器，各有优缺点</p>
<h3 id="list构造函数"><a href="#list构造函数" class="headerlink" title="list构造函数"></a>list构造函数</h3><p>函数原型:</p>
<ul>
<li>list<T> lst;&#x2F;&#x2F;list采用采用模板类实现,对象的默认构造形式:</li>
<li>list(beg,end) ;&#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。</li>
<li>list(n,elem) ;&#x2F;&#x2F;构造函数将n个elem拷贝给本身。</li>
<li>list(const list &amp;lst);&#x2F;&#x2F;拷贝构造函数。</li>
</ul>
<p>总结:list构造方式同其他几个STL常用容器，熟练掌握即可</p>
<h3 id="list赋值和交换"><a href="#list赋值和交换" class="headerlink" title="list赋值和交换"></a>list赋值和交换</h3><p>函数原型:</p>
<ul>
<li>assign(beg,_end) ;&#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li>assign(n, eiem) ;&#x2F;&#x2F;将n个elem拷贝赋值给本身。</li>
<li>list&amp; operator&#x3D;(const list &amp;lst);&#x2F;&#x2F;重载等号操作符</li>
<li>swap(lst);&#x2F;&#x2F;将lst与本身的元素互换。</li>
</ul>
<h3 id="list大小操作"><a href="#list大小操作" class="headerlink" title="list大小操作"></a>list大小操作</h3><p>函数原型:</p>
<ul>
<li>size();&#x2F;&#x2F;返回容器中元素的个数</li>
<li>empty();&#x2F;&#x2F;判断容器是否为空</li>
<li>resize(num ) ;&#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。&#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</li>
<li>resize(num，elem);&#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。&#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</li>
</ul>
<h3 id="list插入和删除"><a href="#list插入和删除" class="headerlink" title="list插入和删除"></a>list插入和删除</h3><p>函数原型:</p>
<ul>
<li>push_back(elem);&#x2F;&#x2F;在容器尾部加入一个元素.</li>
<li>pop_back();&#x2F;&#x2F;删除容器中最后一个元素</li>
<li>push_front(elem);&#x2F;&#x2F;在容器开头插入一个元素.</li>
<li>pop_front();&#x2F;&#x2F;从容器开头移除第一个元素</li>
<li>insert(pos,elem);&#x2F;&#x2F;在pos位置插elem元素的拷贝，返回新数据的位置。</li>
<li>insert(pos,n,elem);&#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。</li>
<li>insert(pos,beg,end);&#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。</li>
<li>clear();&#x2F;&#x2F;移除容器的所有数据</li>
<li>erase(beg,end);&#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。</li>
<li>erase(pos);&#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。</li>
<li>remove(elem);&#x2F;&#x2F;删除容器中所有与elem值匹配的元素。</li>
</ul>
<h3 id="list数据存取"><a href="#list数据存取" class="headerlink" title="list数据存取"></a>list数据存取</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//L1[0]不可以用[]访问list容器中的元素</span><br><span class="line">//L1.at(O)不可以用at方式访问list容器中的元素</span><br><span class="line">//原因是list本质链表，不是用连续线性空间存储数据，迭代器也是不支持随机访问的</span><br><span class="line">cout &lt;&lt;&quot;第一个元素为:&quot;&lt;&lt; L1.front() &lt;&lt; endl;</span><br><span class="line">cout&lt;&lt;&quot;最后一个元素为:&quot;&lt;&lt; L1. back() &lt;&lt; endl ;</span><br><span class="line">//验证迭代器是不支持随机访问的</span><br><span class="line">list&lt;int&gt; : :iterator it = L1. begin();</span><br><span class="line">it++;//支持双向,可以用来判断其它容器是否支持双向访问，随机访问也一样</span><br><span class="line">it--;</span><br><span class="line">//it = it + 1;//不支持随机访问</span><br></pre></td></tr></table></figure>

<p>总结:</p>
<ul>
<li>list容器中不可以通过[]或者at方式访问数据</li>
<li>返回第一个元素— front</li>
<li>返回最后一个元素— back</li>
</ul>
<h3 id="list反转和排序"><a href="#list反转和排序" class="headerlink" title="list反转和排序"></a>list反转和排序</h3><p>函数原型:</p>
<ul>
<li>reverse();&#x2F;&#x2F;反转链表</li>
<li>sort(); &#x2F;&#x2F;链表排序</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//指定排序规则</span><br><span class="line">bool mycompare( int val1 , int val2)&#123;</span><br><span class="line">	return val1 &gt; val2;</span><br><span class="line">&#125;</span><br><span class="line">//所有不支持随机访问迭代器的容器，不可以用标准算法</span><br><span class="line">//不支持随机访问迭代器的容器，内部会提供对应一些算法</span><br><span class="line">//sort(L1.begin()，L1.end() ) ;</span><br><span class="line">L1.sort();//默认排序规则从小到大升序</span><br><span class="line">L.sort( myCompare); //指定规则，从大到小</span><br></pre></td></tr></table></figure>

<p>总结:</p>
<ul>
<li><p>对于自定义数据类型，必须要指定排序规则(</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool mycompare( int val1 , int val2)&#123;</span><br><span class="line">	return val1 &gt; val2;</span><br><span class="line">&#125;//val可以是任何类型，注意引用</span><br></pre></td></tr></table></figure>

<p>)，否则编译器不知道如何进行排序</p>
</li>
<li><p>高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂</p>
</li>
</ul>
<h2 id="set-x2F-multiset容器"><a href="#set-x2F-multiset容器" class="headerlink" title="set&#x2F; multiset容器"></a>set&#x2F; multiset容器</h2><h3 id="set基本概念"><a href="#set基本概念" class="headerlink" title="set基本概念"></a>set基本概念</h3><p>简介:</p>
<ul>
<li>所有元素都会在插入时自动被排序</li>
</ul>
<p>本质:</p>
<ul>
<li>set&#x2F;multiset属于关联式容器，底层结构是用二叉树实现。</li>
</ul>
<p>set和multiset区别:</p>
<ul>
<li>set不允许容器中有重复的元素（无resize）</li>
<li>multiset允许容器中有重复的元素</li>
</ul>
<p>总结:</p>
<ul>
<li>set容器插入数据时用insert</li>
<li>set容器插入数据的数据会自动排序</li>
</ul>
<p>总结:</p>
<ul>
<li>统计大小— size</li>
<li>判断是否为空— empty</li>
<li>交换容器— swap</li>
</ul>
<p>函数原型:</p>
<ul>
<li><p>insert(elem);&#x2F;&#x2F;在容器中插入元素。</p>
</li>
<li><p>clear();&#x2F;&#x2F;清除所有元素</p>
</li>
<li><p>erase(pos);&#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。</p>
</li>
<li><p>erase(beg, end);&#x2F;&#x2F;删除区间[beg,end)的所有元素，返回下一个元素的迭代器。</p>
</li>
<li><p>erase(elem);&#x2F;&#x2F;删除容器中值为elem的元素。</p>
</li>
<li><p>find(key ) ;&#x2F;&#x2F;查找key是否存在,若存在，返回该键的元素的迭代器;若不存在，返回set.end();</p>
</li>
<li><p>count(key);&#x2F;&#x2F;统计key的元素个数,对于set而言统计结果要么是0要么是1</p>
</li>
</ul>
<h3 id="set和multiset区别"><a href="#set和multiset区别" class="headerlink" title="set和multiset区别"></a>set和multiset区别</h3><p>区别:</p>
<ul>
<li>set不可以插入重复数据，而multiset可以</li>
<li>set插入数据的同时会返回插入结果，表示插入是否成功. multiset不会检测数据，因此可以插入重复数据</li>
</ul>
<p>总结:</p>
<ul>
<li>如果不允许插入重复数据可以利用set</li>
<li>如果需要插入重复数据利用multiset</li>
</ul>
<h3 id="pair对组创建"><a href="#pair对组创建" class="headerlink" title="pair对组创建"></a>pair对组创建</h3><p>功能描述:</p>
<ul>
<li>成对出现的数据，利用对组可以返回两个数据</li>
</ul>
<p>两种创建方式:</p>
<ul>
<li>pair&lt;type, tyie&gt; p ( value1, value2 );</li>
<li>pair&lt;type, type&gt; p &#x3D; make_pair( value1，value2 );</li>
</ul>
<h3 id="set容器排序"><a href="#set容器排序" class="headerlink" title="set容器排序"></a>set容器排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class MyCompare&#123;</span><br><span class="line">public:</span><br><span class="line">	bool operator()(int v1,int v2)//重载（），//自定义数据类型都会指定排序规则</span><br><span class="line">	&#123;</span><br><span class="line">		return v1 &gt; v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test()&#123;</span><br><span class="line">	set&lt;int，MyCompare&gt;s2;//要放在插入之前，int与上面传入的数据类型一致,MyCompare是仿函数</span><br><span class="line">	s2.insert(10) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:利用仿函数可以指定set容器的排序规则</p>
<p>总结:<br>对于自定义数据类型，set必须指定排序规则才可以插入数据</p>
<h2 id="map-x2F-multimap容器"><a href="#map-x2F-multimap容器" class="headerlink" title="map&#x2F;multimap容器"></a>map&#x2F;multimap容器</h2><h3 id="map基本概念"><a href="#map基本概念" class="headerlink" title="map基本概念"></a>map基本概念</h3><p>简介:</p>
<ul>
<li>map中所有元素都是pair</li>
<li>pair中第一个元素为key(键值)，起到索引作期，第二个元素为value(实值)·所有元素都会根据元素的键值自动排序</li>
</ul>
<p>本质:</p>
<ul>
<li>map&#x2F;multimap属于关联式容器，底层结构是用二叉树实现。</li>
</ul>
<p>优点:</p>
<ul>
<li>可以根据key值快速找到value值</li>
</ul>
<p>map和multimap区别:</p>
<ul>
<li>map不允许容器中有重复key值元素</li>
<li>multimap允许容器中有重复key值元素</li>
</ul>
<h3 id="map构造和赋值"><a href="#map构造和赋值" class="headerlink" title="map构造和赋值"></a>map构造和赋值</h3><p>构造:</p>
<ul>
<li>map&lt;T1，T2&gt; mp;&#x2F;&#x2F;map默认构造函数:</li>
<li>map(const ma &amp;mp );&#x2F;&#x2F;拷贝构造函数</li>
</ul>
<p>赋值:</p>
<ul>
<li>map&amp; operator&#x3D;(const map &amp;mp);&#x2F;&#x2F;重载等号操作符</li>
</ul>
<p>总结: map中所有元素都是成对出现，插入数据时候要使用对组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map&lt;int,int&gt;m;//默认构造</span><br><span class="line">m.insert(pair&lt;int, int&gt;(1，10));</span><br></pre></td></tr></table></figure>

<ul>
<li><p>统计大小— size</p>
</li>
<li><p>判断是否为空— empty</p>
</li>
<li><p>交换容器— swap</p>
</li>
<li><p>insert(elem);&#x2F;&#x2F;在容器中插入元素。</p>
</li>
<li><p>clear();&#x2F;&#x2F;清除所有元素</p>
</li>
<li><p>erase(pos);&#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。</p>
</li>
<li><p>erase(beg, end);&#x2F;&#x2F;删除区间[beg,end)的所有元素，返回下一个元素的迭代器。</p>
</li>
<li><p>erase(key);&#x2F;&#x2F;删除容器中值为elem的元素。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m[4] = 40;</span><br><span class="line">//[]不建议插入，用途	可以利用key访问到value</span><br><span class="line">cout &lt;&lt; m[4]&lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<ul>
<li>find(key ) ;&#x2F;&#x2F;查找key是否存在,若存在，返回该键的元素的迭代器;若不存在，返回set.end();返回迭代器，需要迭代器接受map&lt;int,int&gt;: :iterator pos &#x3D; m. find(3) ;</li>
<li>count(key);&#x2F;&#x2F;统计key的元素个数,对于set而言统计结果要么是0要么是1</li>
</ul>
<p>map不允许插入重复key元素，count统计而言结果要么是0要么是1</p>
<p>multimap的count统计可能大于1</p>
<h3 id="map容器排序"><a href="#map容器排序" class="headerlink" title="map容器排序"></a>map容器排序</h3><p>学习目标:</p>
<ul>
<li>map容器默认排序规则为按照key值进行从小到大排序，掌握如何改变排序规则</li>
</ul>
<p>主要技术点:</p>
<ul>
<li>利用仿函数，可以改变排序规则</li>
</ul>
<p>总结:</p>
<ul>
<li>利用仿函数可以指定map容器的排序规则</li>
<li>对于自定义数据类型，map必须要指定排序规则，同set容器</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/08/%E7%AC%AC%E4%B8%83%E5%A4%A9-c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/08/%E7%AC%AC%E4%B8%83%E5%A4%A9-c/" class="post-title-link" itemprop="url">第七天 c++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-08 20:26:50" itemprop="dateCreated datePublished" datetime="2023-04-08T20:26:50+08:00">2023-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-09 20:40:00" itemprop="dateModified" datetime="2023-04-09T20:40:00+08:00">2023-04-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="容器算法迭代器初识"><a href="#容器算法迭代器初识" class="headerlink" title="容器算法迭代器初识"></a>容器算法迭代器初识</h1><h2 id="vector存放内置数据类型"><a href="#vector存放内置数据类型" class="headerlink" title="vector存放内置数据类型"></a>vector存放内置数据类型</h2><p>容器:<code>vector</code></p>
<p>算法:<code>for_each</code></p>
<p>迭代器:<code>vector&lt;int&gt;::iterator</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorilhm&gt;</span><br><span class="line">void MyPrint(int val)&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test01() &#123;</span><br><span class="line">	//创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型</span><br><span class="line">	vector&lt;int&gt; v;</span><br><span class="line">	//向容器中放数据</span><br><span class="line">	v.push_back(10);</span><br><span class="line">	v.push_back(20);</span><br><span class="line">	v.push_back(30);</span><br><span class="line">	v.push_back(40);</span><br><span class="line">	//每一个容器都有自己的迭代器,迭代器是用来遍历容器中的元素</span><br><span class="line">	//v.begin()返回迭代器，这个迭代器指向容器中第一个数据</span><br><span class="line">	//v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置</span><br><span class="line">	//vector&lt;int&gt;::iterator拿到vector&lt;int&gt;这种容器的迭代器类型</span><br><span class="line">	vector&lt;int&gt; ::iterator pBegin = v.begin();</span><br><span class="line">	vector&lt;int&gt; ::iterator pEnd = v.end();</span><br><span class="line">	//第—种遍历方式:</span><br><span class="line">	while (pBegin ! = pEnd)&#123;</span><br><span class="line">		cout &lt;&lt;*pBegin &lt;&lt; endl;</span><br><span class="line">		pBegin++;</span><br><span class="line">	&#125;</span><br><span class="line">	//第二种遍历方式:</span><br><span class="line">	for (vector&lt;int&gt; : :iterator it = v.begin(); it != v.end( ); it++) &#123;</span><br><span class="line">		cout &lt;&lt;*it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt;endl;</span><br><span class="line">	//第三种遍历方式:</span><br><span class="line">	//使用STL提供标准遍历算法头文件algorithm</span><br><span class="line">	for_each(v.begin(), v.end( ), MyPrint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Vector容器嵌套容器"><a href="#Vector容器嵌套容器" class="headerlink" title="Vector容器嵌套容器"></a>Vector容器嵌套容器</h2><p>学习目标:</p>
<p>容器中嵌套容器，我们将所有数据进行遍历输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//容器嵌套容器</span><br><span class="line">void test01() &#123;</span><br><span class="line">	vector&lt; vector&lt;int&gt; &gt;v ;</span><br><span class="line">	vector&lt;int&gt; v1;</span><br><span class="line">	vector&lt;int&gt; v2;</span><br><span class="line">	vector&lt;int&gt; v3;</span><br><span class="line">	vector&lt;int&gt; v4;</span><br><span class="line">	for (int i = ; i &lt; 4; i++) &#123;</span><br><span class="line">		v1.push_back(i + 1);</span><br><span class="line">		v2.push_back(i + 2);</span><br><span class="line">		v3.push_back(i + 3);</span><br><span class="line">		v4.push_back(i + 4);</span><br><span class="line">	&#125;</span><br><span class="line">	//将容器元素插入到vector v中</span><br><span class="line">	v.push_back(v1);</span><br><span class="line">	v.push_back(v2);</span><br><span class="line">	v.push_back(v3);</span><br><span class="line">	v.push_back(v4);</span><br><span class="line">	for (vector&lt;vector&lt;int&gt;&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		for (vector&lt;int&gt;: :iterator vit = (*it).begin(); vit != (*it).end(); vit++) </span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt;*vit &lt;&lt; &quot; &quot;;</span><br><span class="line">		&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="string容器"><a href="#string容器" class="headerlink" title="string容器"></a>string容器</h2><h3 id="string赋值操作"><a href="#string赋值操作" class="headerlink" title="string赋值操作"></a>string赋值操作</h3><p>功能描述:</p>
<ul>
<li>给string字符串进行赋值</li>
</ul>
<p>赋值的函数原型:</p>
<ul>
<li>string&amp; operator&#x3D;(const char* s );&#x2F;&#x2F;char*类型字符串赋值给当前的字符串</li>
<li>string&amp; operator&#x3D;(const string &amp;s );&#x2F;&#x2F;把字符串s赋给当前的字符串</li>
<li>string&amp; operator&#x3D;( char c);&#x2F;&#x2F;字符赋值给当前的字符串</li>
<li>string&amp; assign(const char *s ) ;&#x2F;&#x2F;把字符串s赋给当前的字符串</li>
<li>string&amp; assign(const char *s, int n);&#x2F;&#x2F;把字符串s的前n个字符赋给当前的字符串</li>
<li>string&amp; assign( const sting &amp;s );&#x2F;&#x2F;把字符串s赋给当前字符串</li>
<li>string&amp; assign(int n, char c);&#x2F;&#x2F;用n个字符c赋给当前字符串</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void test01()&#123;</span><br><span class="line">	str1 = &quot;hello vorld&quot;;</span><br><span class="line">	cout &lt;&lt; &quot;str1 - &quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">	string str2;</span><br><span class="line">	str2 = str1;</span><br><span class="line">	cout &lt;&lt; &quot;str2 = &quot; &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">	string str3;</span><br><span class="line">	str3 = &#x27;a &#x27;;</span><br><span class="line">	cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">	string str4;</span><br><span class="line">	str4.assign( &quot;hello c++&quot;);</span><br><span class="line">	cout &lt;&lt; &quot;str4 = &quot; &lt;&lt;str4 &lt;&lt; endl;</span><br><span class="line">	string str5;</span><br><span class="line">	str5.assign(&quot;hello c++&quot;,5);</span><br><span class="line">	cout &lt;&lt; &quot;str5 =&lt;&lt; str5 &lt;&lt; endl;</span><br><span class="line">	string str6;</span><br><span class="line">	str6.assign(str5);</span><br><span class="line">	cout &lt;&lt; &quot;str6 = &quot; &lt;&lt; str6 &lt;&lt; endl;</span><br><span class="line">	string str7;</span><br><span class="line">	str7 .assign(5，&#x27;x&#x27;);</span><br><span class="line">	cout &lt;&lt; &quot;str7 = &quot; &lt;&lt; str7 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:<br>string的赋值方式很多,operator&#x3D;这种方式是比较实用的</p>
<h3 id="string字符串拼接"><a href="#string字符串拼接" class="headerlink" title="string字符串拼接"></a>string字符串拼接</h3><p>功能描述:</p>
<ul>
<li>实现在字符串末尾拼接字符串</li>
</ul>
<p>函数原型:</p>
<ul>
<li>string&amp; operator+&#x3D;(const char* str);&#x2F;&#x2F;重载+&#x3D;操作符</li>
<li>string&amp; operator+&#x3D;( const char c);&#x2F;&#x2F;重载+&#x3D;操作符</li>
<li>string&amp; operator+&#x3D;( const string&amp; str);&#x2F;&#x2F;重载+&#x3D;操作符</li>
<li>string&amp; append(const char *s );&#x2F;&#x2F;把字符串s连接到当前字符串结尾</li>
<li>string&amp; append(const char *s, int n);&#x2F;&#x2F;把字符串s的前n个字符连接到当前字符串结尾</li>
<li>string&amp; append(const string &amp;s );&#x2F;&#x2F;同operator+&#x3D;(const string&amp; str)</li>
<li>string&amp; append(const string &amp;s，int pos，int n);&#x2F;&#x2F;字符串s中从pos开始的n个字符连接到字符串结尾</li>
</ul>
<h3 id="string查找和替换"><a href="#string查找和替换" class="headerlink" title="string查找和替换"></a>string查找和替换</h3><p>函数原型:</p>
<ul>
<li>int find(const string&amp; str, int pos &#x3D; 0) const;&#x2F;&#x2F;查找str第一次出现位置,从pos开始查找</li>
<li>int find( cqhst char* s , int pos &#x3D;0) const;&#x2F;&#x2F;查找s第一次出现位置,从pos开始查找</li>
<li>int find(const char* s, int pos， int n) const;&#x2F;&#x2F;从pos位置查找s的前n个字符第一次位置</li>
<li>int find(const char c, int pos &#x3D;0) const;&#x2F;&#x2F;查找字符c第一次出现位置</li>
<li>int rfind(const string&amp; str, int pos &#x3D; npos) const;&#x2F;&#x2F;查找str最后一次位置,从pos开始查找</li>
<li>int rfind(const char* s, int pos &#x3D; npos) const;&#x2F;&#x2F;查找s最后一次出现位置,从pos开始查找</li>
<li>int rfind(const char* s, int pos, int n) const;&#x2F;&#x2F;从pos查找s的前n个字符最后一次位置</li>
<li>int rfind(const char c, int pos &#x3D; npos) const;&#x2F;&#x2F;查找字符c最后一次出现位置</li>
<li>string&amp; replace(int pos, int n, const string&amp; str);&#x2F;&#x2F;替换从pos开始n个字符为字符串str</li>
<li>string&amp; replace(int pos, int n,const char*s );&#x2F;&#x2F;替换从pos开始的n个字符为字符串s</li>
</ul>
<p>总结:</p>
<ul>
<li><p>. find查找是从左往后，rfind从右往左</p>
</li>
<li><p>. find找到字符串后返回查找的第一个字符位置，找不到返回-1</p>
</li>
<li><p>. replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</p>
<hr>
</li>
</ul>
<p>总结:字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大</p>
<hr>
<p>string中单个字符存取方式有两种</p>
<ul>
<li><p>char&amp; operator[](int n);&#x2F;&#x2F;通过[]方式取字符</p>
</li>
<li><p>char&amp; at(int n);&#x2F;&#x2F;通过at方法获取字符</p>
<hr>
</li>
</ul>
<p>函数原型:</p>
<ul>
<li><p>string&amp; insert(int pos, const char* s );&#x2F;&#x2F;插入字符串</p>
</li>
<li><p>string&amp; insert(int pos, const string&amp; str);&#x2F;&#x2F;插入字符串</p>
</li>
<li><p>string&amp; insert(int pos, int n, char c);&#x2F;&#x2F;在指定位置插入n个字符c</p>
</li>
<li><p>string&amp; erase(int pos, int n &#x3D; npos);&#x2F;&#x2F;删除从Pos开始的n个字符</p>
<hr>
</li>
</ul>
<p>函数原型:</p>
<ul>
<li>string substr(int pos &#x3D; 0,int n &#x3D; npos) const;&#x2F;&#x2F;返回由pos开始的n个字符组成的字符串</li>
</ul>
<h2 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h2><h3 id="vector构造函数"><a href="#vector构造函数" class="headerlink" title="vector构造函数"></a>vector构造函数</h3><p>功能描述:</p>
<ul>
<li>创建vector容器</li>
</ul>
<p>函数原型:</p>
<ul>
<li>vector<T> v;&#x2F;&#x2F;采用模板实现类实现，默认构造函数</li>
<li>vector(v.begin(), v.end());&#x2F;&#x2F;将v[begin(), end())区间中的元素拷贝给本身。</li>
<li>vector(n, elem );&#x2F;&#x2F;构造函数将n个elem拷贝给本身。</li>
<li>vector( const vector &amp;vec);&#x2F;&#x2F;拷贝构造函数。</li>
</ul>
<h3 id="vector赋值操作"><a href="#vector赋值操作" class="headerlink" title="vector赋值操作"></a>vector赋值操作</h3><p>函数原型:</p>
<ul>
<li>vector&amp; operator&#x3D;(const vector &amp;vec);&#x2F;&#x2F;重载等号操作符</li>
<li>assign(beg, end);&#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li>assign(n, elem);&#x2F;&#x2F;将n个elem拷贝赋值给本身。</li>
</ul>
<h3 id="vector容量和大小"><a href="#vector容量和大小" class="headerlink" title="vector容量和大小"></a>vector容量和大小</h3><p>函数原型:</p>
<ul>
<li>empty();&#x2F;&#x2F;判断容器是否为空</li>
<li>capacity();&#x2F;&#x2F;容器的容量</li>
<li>size();&#x2F;&#x2F;返回容器中元素的个数</li>
<li>resize(int num);&#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。&#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</li>
<li>resize(int num，elem);&#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。<br>&#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除</li>
</ul>
<h3 id="vector插入和删除"><a href="#vector插入和删除" class="headerlink" title="vector插入和删除"></a>vector插入和删除</h3><p>函数原型:</p>
<ul>
<li>push_back(ele);&#x2F;&#x2F;尾部插入元素ele</li>
<li>pop_back();&#x2F;&#x2F;删除最后一个元素</li>
<li>insert(const_iterator pos,ele);&#x2F;&#x2F;迭代器指向位置pos插入元素ele</li>
<li>insert(const_iterator pos, int cunt,ele);&#x2F;&#x2F;迭代器指向位置pos插入count个元素ele</li>
<li>erase(const_iterator pos);&#x2F;&#x2F;删除迭代器指向的元素</li>
<li>erase(const_iterator start， const_iterator end);&#x2F;&#x2F;删除迭代器从start到end之间的元素</li>
<li>clear();&#x2F;&#x2F;删除容器中所有元素</li>
</ul>
<h3 id="vector互换容器"><a href="#vector互换容器" class="headerlink" title="vector互换容器"></a>vector互换容器</h3><p>函数原型;</p>
<ul>
<li>swap(vec);&#x2F;&#x2F;将vec与本身的元素互换</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void teste2()</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;int&gt; v;</span><br><span class="line">	for (int i - e; i &lt;100000; i++) &#123;</span><br><span class="line">		v.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt;&quot;v的容量为:&quot;&lt;&lt; v.capacity() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt;&quot;v的大小为:&quot;&lt;&lt; v.size() &lt;&lt; endl;</span><br><span class="line">	v.resize(3);</span><br><span class="line">	cout &lt;&lt;“v的容量为:&quot;&lt;&lt; v.capacity() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt;“v的大小为: &quot; &lt;&lt; v.size()&lt;&lt; endl;</span><br><span class="line">	//收缩内存</span><br><span class="line">	vector&lt;int&gt;(v).swap(v); //匿名对象vector&lt;int&gt;(v),读完这行自动被系统删除，匿名对象创建与v.size相同大小的cap和size</span><br><span class="line">	cout &lt;&lt;“v的容量为:&quot;&lt;&lt; v.capacity() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;v的大小为:&quot; &lt;&lt; v.size() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结: swap可以使两个容器互换，可以达到实用的收缩内存效果.</p>
<h3 id="3-2-8-vector预留空间"><a href="#3-2-8-vector预留空间" class="headerlink" title="3.2.8 vector预留空间"></a>3.2.8 vector预留空间</h3><p>功能描述:</p>
<ul>
<li>减少vector在动态扩展容量时的扩展次数</li>
</ul>
<p>函数原型:</p>
<ul>
<li>reserve(int len);&#x2F;&#x2F;容器预留len个元素长度，预留位置不初始化，元素不可访问。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void teste1()</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;int&gt; v;</span><br><span class="line">	//预留空间</span><br><span class="line">	v.reserve ( 100000);</span><br><span class="line">	int num = 0;</span><br><span class="line">	int* p = NULL;</span><br><span class="line">	for (int i = 0; i &lt; 100080; i++) &#123;</span><br><span class="line">		v.push_back(i);</span><br><span class="line">	if (p != &amp;v[0])&#123;</span><br><span class="line">		p = &amp;v[0];//用来计算开辟了多少次内存,如果没有预留内存，则每次vector容量不够会重新分配，即&amp;v[0]会改变</span><br><span class="line">		num++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;&quot;num=&quot;&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:如果数据量较大，可以一开始利用reserve预留空间</p>
<h2 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h2><h3 id="deque容器基本概念"><a href="#deque容器基本概念" class="headerlink" title="deque容器基本概念"></a>deque容器基本概念</h3><p>功能:</p>
<ul>
<li>双端数组，可以对头端进行插入删除操作</li>
</ul>
<p>deque与yector区别:</p>
<ul>
<li>vector对于头部的插入删除效率低，数据量越大，效率越低.</li>
<li>deque相对而言，对头部的插入删除速度回比vector快</li>
<li>vector访问元素时的速度会比deque快,这和两者内部实现有关</li>
</ul>
<p>deque内部工作原理:</p>
<p>deque内部有个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据</p>
<p>中控器维护的是每个缓冲区的地址，使得使用deque时像—片连续的内存空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void printDeque(const deque&lt;int&gt;&amp; d)&#123;//限制不允许修改，只读，则 const_iterator</span><br><span class="line">	for (deque&lt;int&gt; :: const_iterator it = d.begin(); it != d.end(); it++)&#123;</span><br><span class="line">		cout &lt;&lt;*it&lt;&lt;&quot;&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">// deque构造</span><br><span class="line">void teste1()&#123;</span><br><span class="line">	deque&lt;int&gt; d1;//无参构造函数</span><br><span class="line">	for (int i = e; i &lt; 10; i++)&#123;</span><br><span class="line">		d1.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	printDeque(d1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结: deque容器和vector容器的构造方式几乎一致，灵活使用即可</p>
<h3 id="deque赋值操作"><a href="#deque赋值操作" class="headerlink" title="deque赋值操作"></a>deque赋值操作</h3><p>函数原型:</p>
<ul>
<li>deque&amp; operator&#x3D;(const deque &amp;deq);&#x2F;&#x2F;重载等号操作符</li>
<li>assign(beg, end) ;&#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li>assign(n, elem);&#x2F;&#x2F;将n个elem拷贝赋值给本身。</li>
</ul>
<p>函数原型:</p>
<ul>
<li><p>deque.empty();&#x2F;&#x2F;判断容器是否为空</p>
</li>
<li><p>deque.size();&#x2F;&#x2F;返回容器中元素的个数,deque没有容量概念（cap）</p>
</li>
<li><p>deque.resize(num );&#x2F;&#x2F;重新指定容器的长度为num,若容器变长，则以默认值0填充新位置。&#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
<li><p>deque.resize(num，elem);&#x2F;&#x2F;重新指定容器的长度为num,若容器变长，则以elem值填充新位置</p>
<p>&#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
</ul>
<p>总结:</p>
<ul>
<li>deque没有容量的概念</li>
<li>判断是否为空— empty</li>
<li>返回元素个数— size</li>
<li>重新指定个数— resize</li>
</ul>
<h3 id="3-3-5-deque插入和删除"><a href="#3-3-5-deque插入和删除" class="headerlink" title="3.3.5 deque插入和删除"></a>3.3.5 deque插入和删除</h3><p>功能描述:</p>
<ul>
<li>向deque容器中插入和删除数据</li>
</ul>
<p>函数原型:</p>
<p>​	两端插入操作:</p>
<ul>
<li>push_back(elem);&#x2F;&#x2F;在容器尾部添加一个数据</li>
<li>push_front(elem);&#x2F;&#x2F;在容器头部插入一个数据</li>
<li>pop_back();&#x2F;&#x2F;删除容器最后一个数据</li>
<li>pop_front( );&#x2F;&#x2F;删除容器第一个数据</li>
</ul>
<p>指定位置操作:</p>
<ul>
<li>insert(pos,elem) ;&#x2F;&#x2F;在pos位置插入一个elem元素的拷贝，返回新数据的位置。</li>
<li>insert( pos,n,elem);&#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。</li>
<li>insert(pos ,beg,end);&#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。</li>
<li>clear();清空容器的所有数据</li>
<li>erase(beg,end);&#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。</li>
<li>erase(pos);&#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。</li>
</ul>
<p>总结:</p>
<p>插入和删除提供的位置是迭代器!(如d.begin()),还可以</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;int&gt;::iterator it = d1.begin() ;</span><br><span class="line">it++;</span><br><span class="line">d1.erase(it);</span><br></pre></td></tr></table></figure>

<p>尾插— push_back</p>
<p>尾删— pop_back</p>
<p>头插— push_front</p>
<p>头删— pop_front</p>
<hr>
<p>函数原型:</p>
<ul>
<li>at(int idx);&#x2F;&#x2F;返回索引idx所指的数据</li>
<li>operator[]; &#x2F;&#x2F;返回索引idx所指的数据</li>
<li>front( );&#x2F;&#x2F;返回容器中第一个数据元素</li>
<li>back();&#x2F;&#x2F;返回容器中最后一个数据元素</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/08/c-%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/08/c-%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">c++ 基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-08 13:49:29" itemprop="dateCreated datePublished" datetime="2023-04-08T13:49:29+08:00">2023-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-10 16:03:54" itemprop="dateModified" datetime="2023-04-10T16:03:54+08:00">2023-04-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h1><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>有两种方法可用于定义类型别名。传统的方法是使用关键字typedef:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef double wages;//wages是 double的同义词</span><br><span class="line"></span><br><span class="line">typedef wages base,*p;//base是double的同义词,p是double*的同义词</span><br></pre></td></tr></table></figure>

<p>新标准规定了一种新的方法，使用别名声明(alias declaration)来定义类型的别名:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using SI = Sales_item;/ /SI是sales_item的同义词</span><br></pre></td></tr></table></figure>

<p>这种方法用关键字using 作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。</p>
<p>例如以下声明中的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef long double DBL;</span><br><span class="line"></span><br><span class="line">我们引入了一个新的类型名称DBL，它是long double的别名，并且具有：</span><br><span class="line"></span><br><span class="line">typedef：存储类说明符</span><br><span class="line"></span><br><span class="line">long double：类型说明符</span><br><span class="line"></span><br><span class="line">DBL：声明符</span><br></pre></td></tr></table></figure>



<h3 id="指针、常量和类型别名"><a href="#指针、常量和类型别名" class="headerlink" title="指针、常量和类型别名"></a>指针、常量和类型别名</h3><p>如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。</p>
<p>例如下面的声明语句用到了类型pstring,它实际上是类型char*的别名:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef char *pstring;</span><br><span class="line">const pstring cstr = 0;// cstr是指向char的常量指针</span><br><span class="line">const pstring *ps;// ps是一个指针，它的对象是指向char的常量指针</span><br></pre></td></tr></table></figure>

<p>上述两条声明语句的基本数据类型都是const pstring，和过去一样，const是对给定类型的修饰。pstring 实际上是指向char的指针，因此，const pstring 就是指向char的常量指针，而非指向常量字符的指针。</p>
<p>遇到一条使用了类型别名的声明语句时，人们往往会错误地尝试把类型别名替换成它本来的样子，以理解该语句的含义:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const char *cstr =0;</span><br><span class="line">//是对const pstring cstr的错误理解</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再强调一遍:这种理解是错误的。声明语句中用到pstring时，其基本数据类型是指针。可是用 char重写了声明语句后，数据类型就变成了char，* 成为了声明符的一部分。这样改写的结果是，const char成了基本数据类型。前后两种声明含义截然不同，前者声明了一个指向char的常量指针,改写后的形式则声明了一个指向const char的指针。主要是看  * 具体跟谁。这里的区别在于，typedef出来的类型是看做一个单独的类型，而char <em>这种直接的写法中，char才是单独的类型，</em>需要看做是和p结合在一起，含义不同。</p>
<h2 id="类型说明符"><a href="#类型说明符" class="headerlink" title="类型说明符"></a>类型说明符</h2><p>编程时常常需要把表达式的值赋给变量，这就要求在声明变量的时候清楚地知道表达式的类型。然而要做到这一点并非那么容易，有时甚至根本做不到。为了解决这个问题，C++11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符（比如double）不同，auto让编译器通过初始值来推算变量的类型。显然，auto定义的变量必须有初始值:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//由val1和val2相加的结果可以推断出item的类型</span><br><span class="line">auto item = val1 + val2;// item初始化为vall和val2相加的结果</span><br></pre></td></tr></table></figure>

<p>此处编译器将根据vall和val2相加的结果来推断item的类型。如果val1和val2是类sales item的对象，则item的类型就是Sales_item;如果这两个变量的类型是double，则item的类型就是double，以此类推。</p>
<p>使用auto也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto i = 0, *p=&amp;i;//正确:i是整数、p是整型指针,auto代表int型</span><br><span class="line">auto sz = 0,pi = 3.14;//错误:sz和pi的类型不一致</span><br></pre></td></tr></table></figure>

<p>还可以将引用的类型设为auto，此时原来的初始化规则仍然适用:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto  &amp;g=ci;//g是一个整型常量引用，绑定到ci</span><br><span class="line">auto &amp;h=42;//错误:不能为非常量引用绑定字面值</span><br><span class="line">const auto &amp;j=42; //正确:可以为常量引用绑定字面值</span><br></pre></td></tr></table></figure>

<p>要在一条语句中定义多个变量，切记，符号&amp;和*只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto k=ci, &amp;l= i;//k是整数，1是整型引用</span><br><span class="line">auto &amp;m= ci, *p= &amp;ci;// m是对整型常量(const int)的引用，p是指向整型常量(const int)的指针</span><br><span class="line">//错误:i的类型是int而&amp;ci的类型是const int</span><br><span class="line">auto &amp;n= i, *p2= &amp;ci;//使用引用作为初始类型，初始值中的顶层const属性仍然保存,底层 const 的限制却不能被忽视。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层 const 资格，或者两个对象的数据类型必须能够转换，一般来说，非常量可以转化为常量，反之不行。</span><br></pre></td></tr></table></figure>



<h2 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h2><p>有时会遇到这种情况:希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。为了满足这一要求，C++11新标准引入了第二种类型说明符dec1type，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decltype(f()) sum = x; // sum的类型就是函数f的返回类型</span><br></pre></td></tr></table></figure>

<p>编译器并不实际调用函数f，而是使用当调用发生时f的返回值类型作为sum 的类型。换句话说，编译器为sum 指定的类型是什么呢?就是假如f被调用的话将会返回的那个类型。<br>decltype处理顶层const和引用的方式与auto有些许不同。如果 decltype使用的表达式是一个变量,则decltype返回该变量的类型(包括顶层const和引用在内):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const int ci= 0,&amp;cj=ci;</span><br><span class="line">decltype(ci) x= 0;//x的类型是const int</span><br><span class="line">decltype(cj) y= x;//y的类型是const int&amp;， y绑定到变量x</span><br><span class="line">decltype(cj） z;//错误:z是一个引用，必须初始化</span><br></pre></td></tr></table></figure>

<p>因为cj是一个引用，decltype(cj)的结果就是引用类型，因此作为引用的z必须被初始化。</p>
<p>需要指出的是，引用从来都作为其所指对象的同义词出现，只有用在decltype处是一个例外,作为返回值类型。</p>
<h3 id="decltype-和引用"><a href="#decltype-和引用" class="headerlink" title="decltype 和引用"></a>decltype 和引用</h3><p>如果 decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。如4.1.1节（第120页）将要介绍的，有些表达式将向decltype返回一个引用类型。一般来说当这种情况发生时,意味着该表达式的结果对象能作为一条赋值语句的左值:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// decltype的结果可以是引用类型</span><br><span class="line">int i = 42,*p= &amp;i, &amp;r=i;</span><br><span class="line">decltype(r + 0) b;//正确:加法的结果是int，因此b是一个(未初始化的)int</span><br><span class="line">decltype(*p) c;//错误:c是int&amp;，必须初始化</span><br></pre></td></tr></table></figure>

<p>因为r是一个引用，因此 decltype (r)的结果是引用类型。如果想让结果类型是r所指的类型，可以把r作为表达式的一部分，如r+0，显然这个表达式的结果将是一个具体值而非一个引用。</p>
<p>另一方面，如果表达式的内容是解引用操作，则 decltype 将得到引用类型。正如我们所熟悉的那样，解引用指针可以得到指针所指的对象，而且还能给这个对象赋值。因此，decltype(*p)的结果类型就是int&amp;，而非int。</p>
<p>如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型，切记:decltype ((variable))（注意是双层括号)的结果永远是引用，而decltype(variable)结果只有当variable本身就是一个引用时才是引用。</p>
<blockquote>
<p>赋值是会产生引用的一类典型表达式，<strong>引用的类型就是左值的类型</strong>。也就是说，如果 i 是 int，则表达式 i&#x3D;x 的类型是 int&amp;。根据这一特点，请指出下面的代码中每一个变量的类型和值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) c = a;</span><br><span class="line"><span class="keyword">decltype</span>(a = b) d = a;</span><br><span class="line">a <span class="type">int</span> <span class="number">3</span>；</span><br><span class="line">b <span class="type">int</span> <span class="number">4</span>；</span><br><span class="line">c <span class="type">int</span> <span class="number">3</span>；</span><br><span class="line">d <span class="type">int</span> &amp; <span class="number">3</span>。</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="自定义数据结构"><a href="#自定义数据结构" class="headerlink" title="自定义数据结构"></a>自定义数据结构</h1><h2 id="编写自己的头文件"><a href="#编写自己的头文件" class="headerlink" title="编写自己的头文件"></a>编写自己的头文件</h2><p>为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在头文件的名字应与类的名字一样。例如，库类型string在名为string的头文件中定义。又如,我们应该把Sales_data类定义在名为Sales_data.h的头文件中。</p>
<p>注意：头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明。</p>
<h3 id="预处理器概述"><a href="#预处理器概述" class="headerlink" title="预处理器概述"></a>预处理器概述</h3><p>C++程序还会用到的一项预处理功能是头文件保护符（header guard)，头文件保护符依赖于预处理变量(参见2.3.2节，第48页)。预处理变量有两种状态:已定义和未定义。#define指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义:#ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到#endif指令为止。<br>使用这些功能就能有效地防止重复包含的发生:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#ifndef SALES_DATA_H</span><br><span class="line">#define SALES_DATA_H</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">struct Sales_data &#123;</span><br><span class="line">	std::string bookNo;</span><br><span class="line">	unsigned units_sold = 0;</span><br><span class="line">	double revenue = 0.0;</span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h1 id="字符串、向量和数组"><a href="#字符串、向量和数组" class="headerlink" title="字符串、向量和数组"></a>字符串、向量和数组</h1><h2 id="命名空间的using声明"><a href="#命名空间的using声明" class="headerlink" title="命名空间的using声明"></a>命名空间的using声明</h2><p>头文件不应包含using声明</p>
<p>位于头文件的代码一般来说不应该使用using声明。这是因为头文件的内容会铂贝到所有引用它的文件中去，如果头文件里有某个using 声明,那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字,反而可能产生始料未及的名字冲突。</p>
<h3 id="使用getline读取一整行"><a href="#使用getline读取一整行" class="headerlink" title="使用getline读取一整行"></a>使用getline读取一整行</h3><p>有时我们希望能在最终得到的字符串中保留输入时的空白符，这时应该用getline函数代替原来的&gt;&gt;运算符。getline函数的参数是一个输入流和一个string对象，函数从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了)，然后把所读的内容存入到那个string对象中去(注意不存换行符)。getline只要一遇到换行符就结束读取操作并返回结果，哪怕输入的一开始就是换行符也是如此。如果输入真的一开始就是换行符，那么所得的结果是个空string。</p>
<p>和输入运算符一样，getline也会返回它的流参数。因此既然输入运算符能作为判断的条件，我们也能用getline的结果作为条件。例如，可以通过改写之前的程序让它一次输出一整行，而不再是每行输出一个词了:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while (getline(cin,line))</span><br><span class="line">	cout&lt;&lt; line &lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>注意：触发getline函数返回的那个换行符实际上被丢弃掉了,得到的string对象中并不包含该换行符。</p>
<h3 id="string-size-type类型"><a href="#string-size-type类型" class="headerlink" title="string:size_type类型"></a>string:size_type类型</h3><p>对于size函数来说，返回一个int或者返回一个 unsigned 似乎都是合情合理的。但其实size函数返回的是一个string: :size type类型的值，下面就对这种新的类型稍作解释。</p>
<p>尽管我们不太清楚string::size_type类型的细节，但有一点是肯定的:它是个<strong>无符号类型</strong>的值,而且能足够存放下任何string对象的大小所有用于存放string类的size函数返回值的变量，都应该是 string::size_type类型的。</p>
<p>在c++11标准中，允许编译器通过auto或者decltype来推断变量的类型:<br>auto len &#x3D; line.size();&#x2F;&#x2F; len的类型是string: :size_type</p>
<p>由于size函数返回的是一个无符号整型数，因此切记，如果在表达式中混用了带符号数和无符号数将可能产生意想不到的结果。例如，假设n是一个具有负值的int,则表达式s.size ()&lt;n的判断结果几乎肯定是true。这是因为负值n会自动地转换成一个比较大的无符号值。</p>
<p>注意：如果一条表达式中已经有了size()函数就不要再使用int了,这样可以避免混用int和unsigned可能带来的问题。</p>
<p>因为某些历史原因，也为了与C兼容,所以C++语言中的字符串字面值（如“hello”）并不是标准库类型string 的对象。切记，字符串字面值与string是不同的类型。</p>
<h4 id="建议-使用C-版本的C标准库头文件"><a href="#建议-使用C-版本的C标准库头文件" class="headerlink" title="建议:使用C++版本的C标准库头文件"></a>建议:使用C++版本的C标准库头文件</h4><p>C++标准库中除了定义C++语言特有的功能外，也兼容了C语言的标准库。C语言的头文件形如name.h,C+则将这些文件命名为cname。也就是去掉了.h后缀，而在文件名 name之前添加了字母c，这里的c表示这是一个属于C语言标准库的头文件。</p>
<p>因此，cctype头文件和ctype.h头文件的内容是一样的，只不过从命名规范上来讲更符合C++语言的要求。特别的,在名为cname的头文件中定义的名字从属于命名空间std，而定义在名为.h的头文件中的则不然。</p>
<p>一般来说，C++程序应该使用名为cname的头文件而不使用name.h的形式，标准库中的名字总能在命名空间std中找到。如果使用.h形式的头文件，程序员就不得不时刻牢记哪些是从C语言那儿继承过来的，哪些又是C++语言所独有的。</p>
<hr>
<p>新的例子不再是统计标点符号的个数了，假设我们想要把字符串改写为大写字母的形式。为了做到这一点可以使用标准库函数 toupper，该函数接收一个字符，然后输出其对应的大写形式。这样，为了把整个string对象转换成大写，只要对其中的每个字符调用toupper函数并将结果再赋给原字符就可以了:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s(&quot;Hello World!!!&quot;);</span><br><span class="line">//转换成大写形式。</span><br><span class="line">for (auto &amp;c :s)//对于s中的每个字符（注意:c是引用)</span><br><span class="line">	c= toupper(c);//c是一个引用，因此赋值语句将改变s中字符的值</span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>每次迭代时，变量c引用string对象s的下一个字符，赋值给c也就是在改变s中对应字符的值。因此当执行下面的语句时，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c= toupper(c);//c是一个引用，因此赋值语句将改变s中字符的值</span><br></pre></td></tr></table></figure>

<p>实际上改变了c绑定的字符的值。整个循环结束后, str 中的所有字符都变成了大写形式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">另一个例子是把s的第一个词改成大写形式:</span><br><span class="line">//依次处理s中的字符直至我们处理完全部字符或者遇到一个空白</span><br><span class="line">for (decltype(s.size()） index = 0;</span><br><span class="line">index != s.size () &amp;&amp; !isspace(s[index]); ++index)</span><br><span class="line">	s [index] = toupper (s[index]);//将当前字符改成大写形式</span><br></pre></td></tr></table></figure>

<p>使用下标时必须确保其在合理范围之内，也就是说，下标必须大于等于0而小于字符串的 size()的值。一种简便易行的方法是，总是设下标的类型为string::size_type，因为此类型是<strong>无符号数，可以确保下标不会小于0</strong>。此时，代码只需保证下标小于size()的值就可以了。</p>
<h2 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h2><p>vector能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，所以不存在包含引用的vector。除此之外，其他大多数（非引用）内置类型和类类型都可以构成vector对象，甚至组成vector的元素也可以是vector.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; V1 (10);//v1有10个元素，每个的值都是0</span><br><span class="line">vector&lt;int&gt; V2&#123;10&#125;;//v2有1个元素，该元素的值是10</span><br><span class="line">vector&lt;int&gt; V3(10,1); // v3有10个元素，每个的值都是1</span><br><span class="line">vector&lt;int&gt; v4&#123;10，1&#125;; // v4有2个元素，值分别是10和1</span><br></pre></td></tr></table></figure>

<p>另一方面，如果初始化时使用了花括号的形式但是提供的值又不能用来列表初始化，就要考虑用这样的值来构造vector对象了。例如，要想列表初始化一个含有string对象的vector对象，应该提供能赋给string对象的初值。此时不难区分到底是要列表初始化 vector对象的元素还是用给定的容量值来构造vector对象:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; v5&#123; &quot;hi&quot;&#125;;//列表初始化:v5有一个元素</span><br><span class="line">vector&lt;string&gt; v6(&quot;hi&quot;);//错误:不能使用字符串字面值构建vector对象</span><br><span class="line">vector&lt;string&gt; v7 &#123;10&#125;;//v7有10个默认初始化的元素</span><br><span class="line">vector&lt;string&gt; v8&#123;10,&quot;hi&quot;&#125;;// v8有10个值为&quot;hi&quot;的元素</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">提示:只能对确知已存在的元素执行下标操作!</span><br><span class="line">关于下标必须明确的一点是:只能对确知已存在的元素执行下标操作。例如，</span><br><span class="line">vector&lt;int&gt; ivec;//空vector对象</span><br><span class="line">cout &lt;&lt; ivec[0];//错误:ivec不包含任何元素</span><br><span class="line">vector&lt;int&gt; ivec2 (10);//含有10个元素的vector对象</span><br><span class="line">cout &lt;&lt; ivec2[10];//错误:ivec2元素的合法索引是从0到9</span><br><span class="line">试图用下标的形式去访问一个不存在的元素将引发错误,不过这种错误不会被编译器发现，而是在运行时产生一个不可预知的值。</span><br><span class="line">不幸的是，这种通过下标访问不存在的元素的行为非常常见，而且会产生很严重的后果。所谓的缓冲区溢出(buffer overflow)指的就是这类错误，这也是导致PC及其他设备上应用程序出现安全问题的一个重要原因。</span><br></pre></td></tr></table></figure>

<h3 id="关键概念-泛型编程"><a href="#关键概念-泛型编程" class="headerlink" title="关键概念:泛型编程"></a>关键概念:泛型编程</h3><p>原来使用C或Java的程序员在转而使用C++语言之后,会对for循环中使用!&#x3D;而非&lt;进行判断有点儿奇怪，C++程序员习惯性地使用!&#x3D;,其原因和他们更愿意使用迭代器而非下标的原因一样:因为这种编程风格在标准库提供的所有容器上都有效。</p>
<p>之前已经说过,只有string和 vector等一些标准库类型有下标运算符,而并非全都如此。与之类似,所有标准库容器的迭代器都定义了&#x3D;&#x3D;和!&#x3D;，但是它们中的大多数都没有定义&lt;运算符。因此,只要我们养成使用迭代器和!-的习惯,就不用太在意用的到底是哪种容器类型。</p>
<h3 id="迭代器类型"><a href="#迭代器类型" class="headerlink" title="迭代器类型"></a>迭代器类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; : :iterator it;	// it能读写vector&lt;int&gt;的元素</span><br><span class="line">string::iterator it2;//it2能读写string对象中的字符</span><br><span class="line">vector&lt;int&gt;: :const iterator it3;// it3只能读元素，不能写元素</span><br><span class="line">string : :const iterator it4;// it4只能读字符,不能写字符</span><br></pre></td></tr></table></figure>

<p>const_iterator和常量指针（参见2.4.2节，第56页)差不多，能读取但不能修改它所指的元素值。相反，iterator的对象可读可写。如果vector对象或string对象是一个常量，只能使用const_iterator;如果vector对象或string对象不是常量,那么既能使用iterator也能使用const_iterator。</p>
<h3 id="术语-迭代器和迭代器类型"><a href="#术语-迭代器和迭代器类型" class="headerlink" title="术语:迭代器和迭代器类型"></a>术语:迭代器和迭代器类型</h3><p>迭代器这个名词有三种不同的含义:可能是迭代器概念本身，也可能是指容器定义的迭代器类型,还可能是指某个迭代器对象。</p>
<p>重点是理解存在一组概念上相关的类型，我们认定某个类型是迭代器<strong>当且仅当它支持一套操作</strong>，这套操作使得我们能访问容器的元素或者从某个元素移动到另外一个元素。</p>
<p>每个容器类定义了一个名为 iterator 的类型,该类型支持迭代器概念所规定的一套操作。</p>
<h3 id="结合解引用和成员访问操作"><a href="#结合解引用和成员访问操作" class="headerlink" title="结合解引用和成员访问操作"></a>结合解引用和成员访问操作</h3><p>注意，（*it). empty()中的圆括号必不可少，该表达式的含义是先对it解引用，然后解引用的结果再执行点运算符。如果不加圆括号，点运算符将由it来执行，而非it解引用的结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(*it).empty()//解引用it，然后调用结果对象的empty成员</span><br><span class="line">*it.empty ()//错误:试图访问it的名为empty的成员，但it是个迭代器,</span><br><span class="line">			//没有empty成员</span><br></pre></td></tr></table></figure>

<p>为了简化上述表达式，C++语言定义了箭头运算符(-&gt;)。箭头运算符把解引用和成员访问两个操作结合在一起，也就是说，it-&gt;mem和(*it).mem表达的意思相同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//依次输出text的每一行直至遇到第一个空白行为止</span><br><span class="line">for (auto it = text.cbegin();</span><br><span class="line">	it != text.cend() &amp; &amp; !it-&gt;empty;++it)</span><br><span class="line">	cout&lt;&lt;*it&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>我们首先初始化it令其指向text的第一个元素，循环重复执行直至处理完了text的所有元素或者发现某个元素为空。每次迭代时只要发现还有元素并且尚未遇到空元素，就输出当前正在处理的元素。值得注意的是，因为循环从头到尾只是读取text的元素而未向其中写值，所以使用了<strong>cbegin和 cend</strong>来控制整个迭代过程。</p>
<p>如果对象只需读操作而无须写操作的话最好使用常量类型(比如const_iterator)。为了便于专门得到const iterator类型的返回值,C++11新标准引入了两个新函数,分别是cbegin和 cend:</p>
<p><strong>注意</strong>：<strong>谨记，但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。</strong>（因为每次容量不够时都需要重新创建一个容器，此时迭代器就变了）</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="定义和初始化内置数组"><a href="#定义和初始化内置数组" class="headerlink" title="定义和初始化内置数组"></a>定义和初始化内置数组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">unsigned cnt =42;//不是常量表达式</span><br><span class="line">constexpr unsigned sz = 42;//常量表达式</span><br><span class="line">int arr[10];//含有10个整数的数组</span><br><span class="line">int *parr[sz];//含有42个整型指针的数组</span><br><span class="line">string bad [cnt];//错误:cnt不是常量表达式</span><br><span class="line">string strs[get_size()];//当get_size是constexpr时正确;否则错误</span><br><span class="line">默认情况下，数组的元素被默认初始化</span><br></pre></td></tr></table></figure>

<p>定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。另外和 vector一样，数组的元素应为对象，因此不存在引用的数组。</p>
<h3 id="字符数组的特殊性"><a href="#字符数组的特殊性" class="headerlink" title="字符数组的特殊性"></a>字符数组的特殊性</h3><p>字符数组有一种额外的初始化形式，我们可以用字符串字面值（参见2.1.3节，第36页）对此类数组初始化。当使用这种方式时，一定要注意<strong>字符串字面值的结尾处还有一个空字符</strong>，这个空字符也会像字符串的其他字符一样被拷贝到字符数组中去:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char al[]=[&#x27;C&#x27;, &#x27;+&#x27;,&#x27;+&#x27;&#125;;//列表初始化,没有空字符</span><br><span class="line">char a2[]=&#123;&#x27;C&#x27; + &#x27;+&#x27;，&#x27;+&#x27; + &#x27;\0&#x27;&#125;;//列表初始化，含有显式的空字符</span><br><span class="line">char a3[]=&quot;C++&quot;;//自动添加表示字符串结束的空字符</span><br><span class="line">const char a4[6]=&quot;Daniel&quot;;//错误:没有空间可存放空字符!</span><br></pre></td></tr></table></figure>

<p>al的维度是3,a2和a3的维度都是4,a4的定义是错误的。尽管字符串字面值”Daniel看起来只有6个字符，但是数组的大小必须至少是7，其中6个位置存放字面值的内容，另外1个存放结尾处的空字符。</p>
<h3 id="不允许拷贝和赋值"><a href="#不允许拷贝和赋值" class="headerlink" title="不允许拷贝和赋值"></a>不允许拷贝和赋值</h3><p>不能将数组的内容铂贝给其他数组作为其初始值，也不能用数组为其他数组赋值:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a[]= &#123;0，1，2&#125;;//含有3个整数的数组</span><br><span class="line">int a2[]= a;//错误:不允许使用一个数组初始化另一个数组</span><br><span class="line">a2= a;//错误:不能把一个数组直接赋值给另一个数组</span><br></pre></td></tr></table></figure>

<p>一些编译器支持数组的赋值，这就是所谓的编译器扩展(compiler extension)。但一般来说，最好避免使用非标准特性，因为含有非标准特性的程序很可能在其他编译器上无法正常工作。</p>
<h3 id="理解复杂的数组声明"><a href="#理解复杂的数组声明" class="headerlink" title="理解复杂的数组声明"></a>理解复杂的数组声明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int *ptrs [10];// ptrs是含有10个整型指针的数组</span><br><span class="line">int &amp;refs[10]=/* ?*/;//错误:不存在引用的数组</span><br><span class="line">int (*Parray)[10] =&amp;arr;// Parray指向一个含有10个整数的数组</span><br><span class="line">int (&amp;arrRef)[10]= arr;// arrRef引用一个含有10个整数的数组</span><br></pre></td></tr></table></figure>

<p>默认情况下，类型修饰符从右向左依次绑定。对于ptrs来说，从右向左理解其含义比较简单:首先知道我们定义的是一个大小为10的数组，它的名字是ptrs，然后知道数组中存放的是指向int的指针。</p>
<p>但是对于Parray来说，从右向左理解就不太合理了。因为数组的维度是紧跟着被声明的名字的，所以就数组而言，由内向外阅读要比从右向左好多了。由内向外的顺序可帮助我们更好地理解Parray的含义:首先是圆括号括起来的部分，*Parray意味着Parray是个指针，接下来观察右边，可知道Parray是个指向大小为10的数组的指针,最后观察左边，知道数组中的元素是int。这样最终的含义就明白无误了，Parray是一个指针，它指向一个int 数组，数组中包含10个元素。同理，(&amp;arrRef)表示 arrRef是一个引用，它引用的对象是一个大小为10的数组，数组中元素的类型是int。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int * (&amp;arry)[10] = ptrs;// arry是数组的引用，该数组含有10个指针</span><br></pre></td></tr></table></figure>

<p>按照由内向外的顺序阅读上述语句,首先知道arry是一个引用,然后观察右边知道,arry引用的对象是一个大小为10的数组，最后观察左边知道，数组的元素类型是指向int的指针。这样，arry就是一个含有10个int型指针的数组的引用。</p>
<h2 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h2><p>在使用数组下标的时候，通常将其定义为size_t类型。size_t是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小。在cstddef头文件中定义了size_t类型，这个文件是C标准库stddef.h头文件的C++语言版本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 以10分为一个分数段统计成绩的数量:0~9,10~19,....90~99,100</span><br><span class="line">unsigned scores[11] = &#123;&#125;; //11个分数段，全部初始化为0</span><br><span class="line">unsigned grade;</span><br><span class="line">while (cin &gt;&gt; grade)&#123;</span><br><span class="line">	if (grade &lt;=100)</span><br><span class="line">		++scores [grade/10]; //将当前分数段的计数值加1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与vector和string一样，当需要遍历数组的所有元素时，最好的办法也是使用范围for语句。例如，下面的程序输出所有的scores:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (auto i: scores)//对于scores中的每个计数值</span><br><span class="line">	cout &lt;&lt; i&lt;&lt;&quot;&quot;;//输出当前的计数值</span><br><span class="line">cout&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>因为维度是数组类型的一部分，所以系统知道数组 scores中有多少个元素，使用范围for语句可以减轻人为控制遍历过程的负担。</p>
<h2 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h2><p>在一些情况下数组的操作实际上是指针的操作，这一结论有很多隐含的意思。其中一层意思是当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int ia[] =&#123;0,1,2,3,4,5,6,7,8,9&#125;;// ia是一个含有10个整数的数组</span><br><span class="line">auto ia2(ia);// ia2是一个整型指针，指向ia的第一个元素</span><br><span class="line">ia2 =42;//错误: ia2是一个指针，不能用int值给指针赋值</span><br></pre></td></tr></table></figure>

<p>尽管ia是由10个整数构成的数组，但当使用ia作为初始值时，编译器实际执行的初始化过程类似于下面的形式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto ia2(&amp;ia[0]);//显然ia2的类型是int*</span><br></pre></td></tr></table></figure>

<p>必须指出的是，当使用decltype关键字时上述转换不会发生，decltype(ia)返回的类型是由10个整数构成的数组:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// ia3是一个含有10个整数的数组</span><br><span class="line">decltype(ia) ia3 =&#123;0,1,2,3,4,5,6,7,8,91;</span><br><span class="line">ia3 = p; //错误:不能用整型指针给数组赋值</span><br><span class="line">ia3[4] =i;//正确:把i的值赋给ia3的一个元素</span><br></pre></td></tr></table></figure>

<p>内置的下标运算符可以处理负值，当然，结果地址必须指向原来的指针所指同一数组中的元素(或是同一数组尾元素的下一位置)。</p>
<p>内置的下标运算符所用的索引值不是无符号类型，这一点与vector和string不一样。</p>
<hr>
<p>比较两个C风格字符串的方法和之前学习过的比较标准库string对象的方法大相径庭。比较标准库string对象的时候，用的是普通的关系运算符和相等性运算符;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string sl = &quot;A string example&quot;;</span><br><span class="line">string s2 =&quot;Adifferent string&quot; ;</span><br><span class="line">if (s1 &lt; s2） // false: s2小于s1</span><br></pre></td></tr></table></figure>

<p>如果把这些运算符用在两个C风格字符串上，实际比较的将是指针而非字符串本身:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const char cal[]=&quot;A string example&quot;;</span><br><span class="line">const char ca2[]=&quot;A different string&quot;;</span><br><span class="line">if (cal &lt; ca2)//未定义的:试图比较两个无关地址</span><br></pre></td></tr></table></figure>

<p><strong>注意：对大多数应用来说,使用标准库string要比使用C风格字符串更安全、更高效。</strong></p>
<h2 id="与旧代码的接口"><a href="#与旧代码的接口" class="headerlink" title="与旧代码的接口"></a>与旧代码的接口</h2><p>很多C++程序在标准库出现之前就已经写成了，它们肯定没用到string和 vector类型。而且，有一些C++程序实际上是与C语言或其他语言的接口程序，当然也无法使用C++标准库。因此,现代的C++程序不得不与那些充满了数组和&#x2F;或C风格字符串的代码衔接，为了使这一工作简单易行，C++专门提供了一组功能。</p>
<p>更一般的情况是，任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代:</p>
<ul>
<li>允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值。</li>
<li>在 string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象(不能两个运算对象都是);在 string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。</li>
</ul>
<p>上述性质反过来就不成立了:如果程序的某处需要一个C风格字符串，无法直接用string对象来代替它。例如，不能用string对象直接初始化指向字符的指针。为了完成该功能，string专门提供了一个名为c_str的成员函数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char *str = s;//错误:不能用string对象初始化char*</span><br><span class="line">const char *str = s.c_str();//正确</span><br></pre></td></tr></table></figure>

<p>顾名思义，c_ str函数的返回值是一个C风格的字符串。也就是说，函数的返回结果是一个指针，该指针指向一个以<strong>空字符结束的字符数组</strong>，而这个数组所存的数据恰好与那个string对象的一样。结果指针的类型是const char，从而确保我们不会改变字符数组的内容。</p>
<h3 id="使用数组初始化-vector对象"><a href="#使用数组初始化-vector对象" class="headerlink" title="使用数组初始化 vector对象"></a>使用数组初始化 vector对象</h3><p>介绍过不允许使用一个数组为另一个内置类型的数组赋初值，也不允许使用vector对象初始化数组。相反的，允许使用数组来初始化vector对象。要实现这一目的，只需指明要拷贝区域的首元素地址和尾后地址就可以了:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int int arr[] =&#123;0,1,2,3,4,5);//ivec有6个元素，分别是int_arr中对应元素的副本vector&lt;int&gt; ivec(begin(int_arr) ,end(int_arr));</span><br></pre></td></tr></table></figure>

<h2 id="建议-尽量使用标准库类型而非数组"><a href="#建议-尽量使用标准库类型而非数组" class="headerlink" title="建议:尽量使用标准库类型而非数组"></a>建议:尽量使用标准库类型而非数组</h2><p>使用指针和数组很容易出错。一部分原因是概念上的问题:指针常用于底层操作，因此容易引发一些与烦琐细节有关的错误。其他问题则源于语法错误,特别是声明指针时的语法错误。</p>
<p>现代的C++程序应当尽量使用vector和迭代器，避免使用内置数组和指针;应该尽量使用string,避免使用C风格的基于数组的字符串。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>string和 vector是两种最重要的标准库类型。string对象是一个可变长的字符序列，vector对象是一组同类型对象的容器。</p>
<p>迭代器允许对容器中的对象进行间接访问，对于string对象和vector对象来说，可以通过迭代器访问元素或者在元素间移动。</p>
<p>数组和指向数组元素的指针在一个较低的层次上实现了与标准库类型 string和vector类似的功能。一般来说，应该优先选用标准库提供的类型,之后再考虑C++语言内置的低层的替代品数组或指针。</p>
<p><strong>缓冲区溢出</strong>（buffer overflow)一种严重的程序故障,主要的原因是试图通过一个越界的索引访问容器内容,容器类型包括string、 vector和数组等。</p>
<p><strong>C风格字符串</strong>（C-style string)以空字符结束的字符数组。字符串字面值是C风格字符串，C风格字符串容易出错。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/07/%E7%AC%AC%E5%85%AD%E5%A4%A9-c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/07/%E7%AC%AC%E5%85%AD%E5%A4%A9-c/" class="post-title-link" itemprop="url">第六天 c++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-07 16:10:16" itemprop="dateCreated datePublished" datetime="2023-04-07T16:10:16+08:00">2023-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-08 20:01:43" itemprop="dateModified" datetime="2023-04-08T20:01:43+08:00">2023-04-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="函数模板语法"><a href="#函数模板语法" class="headerlink" title="函数模板语法"></a>函数模板语法</h2><p>函数模板作用:<br>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表。<br>语法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line"></span><br><span class="line">函数声明或定义</span><br></pre></td></tr></table></figure>

<p>解释:</p>
<p>template —声明创建模板Ⅰ</p>
<p>typename —表面其后面的符号是—种数据类型，可以用class代替T—通用的数据类型，名称可以替换，通常为大写字母</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//利用模板提供通用的交换函数</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void mySwap(T&amp; a，T&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	int a = 10;</span><br><span class="line">	int b = 20;</span><br><span class="line">	// swapInt(a，b);</span><br><span class="line">	//利用模板实现交换</span><br><span class="line">	//1、自动类型推导</span><br><span class="line">	mySwap(a，b);</span><br><span class="line">	//2、显示指定类型</span><br><span class="line">	mySwap&lt;int&gt;(a，b);</span><br><span class="line">	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout&lt;&lt; &quot; b = &quot;&lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:</p>
<ul>
<li>函数模板利用关键字template</li>
<li>使用函数模板有两种方式:自动类型推导、显示指定类型</li>
<li>模板的目的是为了提高复用性，将类型参数化</li>
<li>使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型</li>
</ul>
<p>普通函数与函数模板区别:</p>
<ul>
<li>普通函数调用时可以发生自动类型转换(隐式类型转换)</li>
<li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li>
<li>如果利用显示指定类型的方式，可以发生隐式类型转换</li>
</ul>
<p>总结:建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T。</p>
<h2 id="普通函数与函数模板的调用规则"><a href="#普通函数与函数模板的调用规则" class="headerlink" title="普通函数与函数模板的调用规则"></a>普通函数与函数模板的调用规则</h2><p>调用规则如下:</p>
<p>1.如果函数模板和普通函数都可以实现，优先调用普通函数</p>
<p>2.可以通过空模板参数列表来强制调用函数模板</p>
<p>3.函数模板也可以发生重载</p>
<p>4.如果函数模板可以产生更好的匹配,优先调用函数模板</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//普通函数与函数模板调用规则</span><br><span class="line">void myPrint(int a, int b)&#123;</span><br><span class="line">	cout &lt;&lt;&quot;调用的普通函数”&quot;&lt;&lt;endl;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void myPrint(T a， T b)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt;“调用的模板&quot;&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void myPrint(T a， T b， T c)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt;&quot;调用重载的模板&quot;&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">    //1、如果函数模板和普通函数都可以实现，优先调用普通函数</span><br><span class="line">    //注意如果告诉编译器普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到</span><br><span class="line">    int a = 10;</span><br><span class="line">    int b = 20;</span><br><span class="line">    myPrint(a，b);//调用普通函数</span><br><span class="line">    //2、可以通过空模板参数列表&lt;&gt;来强制调用函数模板</span><br><span class="line">    myPrint&lt;&gt;(a, b);//调用函数模板</span><br><span class="line">    //3、函数模板也可以发生重载</span><br><span class="line">    int c = 30;</span><br><span class="line">    myprint(a,b, c);//调用重载的函数模板</span><br><span class="line">    //4、如果函数模板可以产生更好的匹配,优先调用函数模板</span><br><span class="line">    char c1 = &#x27;a&#x27;;</span><br><span class="line">    char c2 = &#x27;b&#x27;;</span><br><span class="line">    myPrint(c1，c2);//调用函数模板</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:</p>
<p>既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性。</p>
<h2 id="模板的局限性"><a href="#模板的局限性" class="headerlink" title="模板的局限性"></a>模板的局限性</h2><p>局限性:</p>
<p>模板的通用性并不是万能的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">void f(T a，T b)</span><br><span class="line">&#123;</span><br><span class="line">    if(a &gt; b) </span><br><span class="line">    &#123; .. &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行</p>
<p>因此C++为了解决这种问题，提供模板的重载，可以为这些特定的类型提供具体化的模板</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">	Person( string name，int age)&#123;</span><br><span class="line">	this- &gt;m_Name I name;</span><br><span class="line">	this-&gt;m_Age - age;</span><br><span class="line">	&#125;</span><br><span class="line">string m_Name;</span><br><span class="line">int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line">//普通函数模板</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">bool myCompare(T&amp; a，T&amp; b)&#123;</span><br><span class="line">	if (a == b)&#123;</span><br><span class="line">	return true;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">	return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型</span><br><span class="line">//具体化优先于常规模板</span><br><span class="line">template&lt;&gt; bool myCompare(Person &amp;p1，Person &amp;p2)</span><br><span class="line">&#123;</span><br><span class="line">	if ( p1.m_Name == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age)&#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">	return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; 	</span><br><span class="line">void test01()&#123;</span><br><span class="line">	int a - 10;</span><br><span class="line">	int b = 20;</span><br><span class="line">	//内置数据类型可以直接使用通用的函数模板</span><br><span class="line">	bool ret = myCompare(a， b);</span><br><span class="line">	if (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;a == b &quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;a != b &quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:</p>
<ul>
<li>利用具体化的模板，可以解决由定义类型的通用化</li>
<li>学习模板并不是为了写模板，而是在STL能够运用系统提供的模板</li>
</ul>
<h2 id="类模板语法"><a href="#类模板语法" class="headerlink" title="类模板语法"></a>类模板语法</h2><p>类模板作用:<br>    建立一个通用类，类中的成员数据类型可以不具体制定，用一个虚拟的类型来代表。<br>语法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">类</span><br></pre></td></tr></table></figure>

<p>解释:</p>
<p>template —声明创建模板</p>
<p>typename —表面其后面的符号是一种数据类型，可以用class代替</p>
<p>T —通用的数据类型，名称可以替换，通常为大写字母</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class NameType,class AgeType&gt;</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Person(NameType name，AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">	this- &gt;mName = name;</span><br><span class="line">	this-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	void showPerson()&#123;</span><br><span class="line">	cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	//指定NameType 为string类型，AgeType 为int类型</span><br><span class="line">	Person&lt;string, int&gt;P1(&quot;孙悟空&quot;,999);</span><br><span class="line">	p1.showPerson( );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类模板与函数模板区别"><a href="#类模板与函数模板区别" class="headerlink" title="类模板与函数模板区别"></a>类模板与函数模板区别</h2><p>类模板与函数模板区别主要有两点:</p>
<p>1.类模板没有自动类型推导的使用方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//1、类模板没有自动类型推导的使用方式</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	// Person p(&quot;孙悟空&quot;,1000); //错误类模板使用时候，不可以用自动类型推导</span><br><span class="line">	Person &lt;string ,int&gt;p(&quot;孙悟空&quot;，1000);//必须使用显示指定类型的方式，使用类模板</span><br><span class="line">	p.showPerson();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⒉类模板在模板参数列表中可以有默认参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//2、类模板在模板参数列表中可以有默认参数</span><br><span class="line">void test02()&#123;</span><br><span class="line">    Person &lt;string&gt; p(&quot;猪八戒&quot;, 999);//类模板中的模板参数列表可以指定默认参数template&lt;class //NameType,class AgeType=int&gt;</span><br><span class="line">    p.showPerson( ) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:</p>
<ul>
<li>类模板使用只能用显示指定类型方式</li>
<li>类模板中的模板参数列表可以有默认参数</li>
</ul>
<h2 id="类模板对象做函数参数"><a href="#类模板对象做函数参数" class="headerlink" title="类模板对象做函数参数"></a>类模板对象做函数参数</h2><p>学习目标:</p>
<p>类模板实例化出的对象，向函数传参的方式</p>
<p>—共有三种传入方式:</p>
<p>​	1.指定传入的类型	—直接显示对象的数据类型</p>
<p>​	2.参数模板化	—将对象中的参数变为模板进行传递</p>
<p>​	3.整个类模板化	—将这个对象类型模板化进行传递</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class NameType,class AgeType=int&gt;</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Person(NameType name，AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">	this- &gt;mName = name;</span><br><span class="line">	this-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	void showPerson()&#123;</span><br><span class="line">	cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line">//1、指定传入的类型</span><br><span class="line">void PrintPerson1( Person&lt;string， int&gt; &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">	p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	person &lt;string， int &gt;p(&quot;孙悟空&quot;，100);</span><br><span class="line">	printPerson1(p);</span><br><span class="line">&#125;</span><br><span class="line">//2、参数模板化</span><br><span class="line">template &lt;class T1，class T2&gt;</span><br><span class="line">void printPerson2(Person&lt;T1，T2&gt;&amp;p)</span><br><span class="line">&#123;</span><br><span class="line">	p.showPerson();</span><br><span class="line">	cout &lt;&lt;&quot;T1的类型为:“ &lt;&lt; typeid(T1).name() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt;&quot;T2的类型为:“ &lt;&lt; typeid(T2).name() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">	Person &lt;string, int &gt;p(&quot;猪八戒&quot;，90);</span><br><span class="line">	printPerson2(p);</span><br><span class="line">&#125;</span><br><span class="line">//3、整个类模板化</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void printPerson3(T &amp; p)(</span><br><span class="line">	cout &lt;&lt;&quot;T的类型为:“ &lt;&lt; typeid(T).name() &lt;&lt; endl;</span><br><span class="line">	p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line">void test03()&#123;</span><br><span class="line">	Person &lt;string, int &gt;p(“唐借&quot;，30);</span><br><span class="line">	printPerson3(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:</p>
<ul>
<li>通过类模板创建的对象，可以有三种方式向函数中进行传参</li>
<li>使用比较广泛是第一种:指定传入的类型</li>
</ul>
<h2 id="类模板与继承"><a href="#类模板与继承" class="headerlink" title="类模板与继承"></a>类模板与继承</h2><p>当类模板碰到继承时，需要注意一下几点:</p>
<ul>
<li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</li>
<li>如果不指定，编译器无法给子类分配内存</li>
<li>如果想灵活指定出父类中T的类型，子类也需变为类模板</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">	T m;</span><br><span class="line">&#125;;</span><br><span class="line">//class Son: public Base//错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承</span><br><span class="line">class Son :public Base&lt;int&gt;//必须指定一个类型</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()&#123;</span><br><span class="line">	son c;</span><br><span class="line">&#125;</span><br><span class="line">//类模板继承类模板,可以用T2指定父类中的T类型</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class Son2 :public Base&lt;T2&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Son2()&#123;</span><br><span class="line">	cout &lt;&lt; typeid(T1).name() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; typeid(T2).name() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test02()&#123;</span><br><span class="line">	Son2&lt;int, char&gt; child1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:如果父类是类模板，子类需要指定出父类中T的数据类型</p>
<h2 id="类模板成员函数类外实现"><a href="#类模板成员函数类外实现" class="headerlink" title="类模板成员函数类外实现"></a>类模板成员函数类外实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//类模板中成员函数类外实现</span><br><span class="line">template&lt;class T1，class T2&gt;</span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">	//成员函数类内声明</span><br><span class="line">	Person(T1 name，T2 age);</span><br><span class="line">	void showPerson();</span><br><span class="line">public:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line">//构造函数类外实现</span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">Person&lt;T1，T2&gt; : : Person(T1 name，T2 age) &#123;</span><br><span class="line">	this-&gt;m_Name = name;</span><br><span class="line">	this-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line">//成员函数类外实现</span><br><span class="line">template&lt;class T1，class T2&gt;</span><br><span class="line">void Person&lt;T1，T2&gt; : : showPerson( ) &#123;</span><br><span class="line">	cout &lt;&lt;“姓名:&quot;&lt;&lt; this-&gt;m_Name &lt;&lt;”年龄:&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test01()&#123;</span><br><span class="line">	Person&lt;string, int&gt; p(&quot;Tom&quot;,20);</span><br><span class="line">	p.showPerson();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类模板分文件编写"><a href="#类模板分文件编写" class="headerlink" title="类模板分文件编写"></a>类模板分文件编写</h2><p>问题:</p>
<ul>
<li>类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</li>
</ul>
<p>解决:</p>
<ul>
<li>解决方式1:直接包含.cpp源文件</li>
<li>解决方式2∶将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制</li>
</ul>
<p>person.hpp中代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">	Person(T1 name，T2 age);</span><br><span class="line">	void showPerson();</span><br><span class="line">public:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line">//构造函数类外实现</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">Person&lt;T1，T2&gt; : :Person(T1 name，T2 age) &#123;</span><br><span class="line">	this-&gt;m_Name = name;</span><br><span class="line">	this-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line">//成员函数类外实现</span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">void Person&lt;T1，T2&gt; : : showPerson() &#123;</span><br><span class="line">	cout &lt;&lt;“姓名;&quot;&lt;&lt; this-&gt;m_Name &lt;&lt;”年龄:&quot;&lt;&lt; this-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类模板分文件编写.cpp中代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iosiream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//#include &quot;person.h&quot;</span><br><span class="line">#include &quot;person.cpp”//解决方式1，包含cpp源文件</span><br><span class="line">//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp</span><br><span class="line">#include &quot;person.hpp&quot;</span><br><span class="line">void teste1()</span><br><span class="line">&#123;</span><br><span class="line">	Person&lt;string, int&gt; p( Tom&quot;，10);</span><br><span class="line">	p.showPerson( );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp</p>
<h2 id="类模板与友元"><a href="#类模板与友元" class="headerlink" title="类模板与友元"></a>类模板与友元</h2><p>学习目标:</p>
<ul>
<li>掌握类模板配合友元函数的类内和类外实现</li>
<li>全局函数类内实现-直接在类内声明友元即可</li>
<li>全局函数类外实现–需要提前让编译器知道全局函数的存在</li>
</ul>
<p>成员函数加friend变为全局函数,可在全局作用于该类对象.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//2、全局函数配合友元类外实现–先做函数模板声明，下方在做函数模板定义，在做友元</span><br><span class="line">template&lt;class T1,class T2&gt; </span><br><span class="line">class Person;</span><br><span class="line">//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到</span><br><span class="line">//template&lt;class T1，class T2&gt; void printPerson2(Person&lt;T1，T2&gt;&amp; p);</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">void printPerson2( Person&lt;T1，T2&gt;&amp; p)&#123;</span><br><span class="line">	cout &lt;&lt;&quot;类外实现----姓名: &quot; &lt;&lt; p.m_Name &lt;&lt;”年龄:&quot;&lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">	//1、全局函数配合友元类内实现</span><br><span class="line">	friend void printPerson(Person&lt;T1，T2&gt; &amp;p)</span><br><span class="line">		cout &lt;&lt;&quot;姓名:&quot;&lt;&lt; p.m_Name &lt;&lt;”年龄:”&lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">	//全局函数配合友元类外实现</span><br><span class="line">	friend void printPerson2&lt;&gt;(Person&lt;T1，T2&gt; &amp; p);</span><br><span class="line">public:</span><br><span class="line">	Person( T1 name，T2 age)&#123;</span><br><span class="line">		this-&gt;m_Name = name;</span><br><span class="line">		this-&gt;m_Age -l age;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line">//1、全局函数在类内实现</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	Person &lt;string， int &gt;p( &quot;Tom&quot;，20);</span><br><span class="line">	printPerson(p);</span><br><span class="line">&#125;</span><br><span class="line">//2、全局函数在类外实现</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">	Person &lt;string, int &gt;p(&quot;Jerry&quot; , 30);</span><br><span class="line">	printPerson2(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:建议全局函数做类内实现，用法简单，而且编译器可以直接识别</p>
<h2 id="类模板案例"><a href="#类模板案例" class="headerlink" title="类模板案例"></a>类模板案例</h2><p>案例描述:实现一个通用的数组类，要求如下:</p>
<ul>
<li>可以对内置数据类型以及自定义数据类型的数据进行存储</li>
<li>将数组中的数据存储到堆区</li>
<li>构造函数中可以传入数组的容量</li>
<li>提供对应的拷贝构造函数以及operator&#x3D;防止浅拷贝问题</li>
<li>提供尾插法和尾删法对数组中的数据进行增加和删除</li>
<li>可以通过下标的方式访问数组中的元素</li>
<li>可以获取数组中当前元素个数和数组的容量</li>
</ul>
<p>myArray.hpp中代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class MyArray&#123;</span><br><span class="line">public:</span><br><span class="line">	//构造函数</span><br><span class="line">	MyArray(int capacity)&#123;</span><br><span class="line">		this-&gt;m_Capacity = capacity;</span><br><span class="line">		this-&gt;m_size = 0;</span><br><span class="line">		pAddress = new T[this-&gt;m_Capacity];</span><br><span class="line">	&#125;</span><br><span class="line">	//拷贝构造</span><br><span class="line">	MyArray(const MyArray &amp; arr)&#123;</span><br><span class="line">		this-&gt;m_Capacity = arr.m_capacity;</span><br><span class="line">		this-&gt;m_Size = arr.m_Size;</span><br><span class="line">		this-&gt;pAddress = new T[this-&gt;m_capacity];</span><br><span class="line">		for (int i =0; i &lt; this-&gt;m_size; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			//如果T为对象，而且还包含指针，必须需要重载=操作符，因为这个等号不是构造而是赋值</span><br><span class="line">			//普通类型可以直接=但是指针类型需要深拷贝</span><br><span class="line">			this-&gt;pAddress[i] = arr. pAddress[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//重载=操作符  防止浅拷贝问题</span><br><span class="line">	MyArray&amp; operator=( const MyArray&amp; myarray) &#123;</span><br><span class="line">		if(this-&gt;pAddress != NULL) &#123;</span><br><span class="line">			delete[] this-&gt;pAddress;</span><br><span class="line">			this-&gt;m_Capacity = 0;</span><br><span class="line">			this-&gt;m_size = 0;</span><br><span class="line">		&#125;</span><br><span class="line">		this-&gt;m_Capacity = myarray.m_capacity;</span><br><span class="line">		this-&gt;m_Size = myarray.m_size;</span><br><span class="line">		this-&gt;pAddress = new T[this-&gt;m_capacity];</span><br><span class="line">		for (int i = 0; i &lt; this-&gt;m_size; i++) &#123;</span><br><span class="line">				this-&gt;pAddress[i] = myarray[i];</span><br><span class="line">		&#125;</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	//重载[]操作符 arr[0]</span><br><span class="line">	T&amp; operator [](int index)</span><br><span class="line">	&#123;</span><br><span class="line">		return this-&gt;pAddress[index]; //不考虑越界，用户自己去处理</span><br><span class="line">	&#125;</span><br><span class="line">	//尾插法</span><br><span class="line">	void Push_back( const T &amp; val)</span><br><span class="line">	&#123;</span><br><span class="line">		if (this-&gt;m_Capacity == this-&gt;m_size)&#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		this-&gt;pAddress[this-&gt;m_size] = val;</span><br><span class="line">		this-&gt;m_size++;</span><br><span class="line">	&#125;</span><br><span class="line">	//尾删法</span><br><span class="line">	void Pop_back()&#123;</span><br><span class="line">		if (this-&gt;m_size == e)&#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		this-&gt;m_size--;</span><br><span class="line">	&#125;</span><br><span class="line">	//获取数组容量</span><br><span class="line">	int getCapacity()&#123;</span><br><span class="line">		return this-&gt;m_capacity;</span><br><span class="line">	&#125;</span><br><span class="line">	//获取数组大小</span><br><span class="line">	int getsize()</span><br><span class="line">	&#123;</span><br><span class="line">		return this-&gt;m_size;</span><br><span class="line">	&#125;</span><br><span class="line">	//析构</span><br><span class="line">	~MyArray()&#123;</span><br><span class="line">		if (this-&gt;pAddress != NULL)&#123;</span><br><span class="line">			delete[] this-&gt;pAddress;</span><br><span class="line">			this-&gt;pAddress = NULL;</span><br><span class="line">			this-&gt;m_Capacity = 0;</span><br><span class="line">			this-&gt;m_Size = 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	T *pAddress;//指向一个堆空间，这个空间存储真正的数据</span><br><span class="line">	int m_Capacity;//容量</span><br><span class="line">	int m_Size;//大小</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类模板案例―数组类封装.cpp中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;myArray.hpp&quot;</span><br><span class="line">include &lt;string&gt;</span><br><span class="line">void printIntArray(MyArray&lt;int&gt;&amp; arr) &#123;</span><br><span class="line">	for (int i =0; i &lt; arr.getsize(); i++) &#123;</span><br><span class="line">	cout &lt;&lt; arr[i] &lt;&lt;&quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">//测试内置数据类型</span><br><span class="line">void test01()&#123;</span><br><span class="line">	MyArray&lt;int&gt; artay1(10);</span><br><span class="line">	for (int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">		array1.Push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; &quot;array1打印输出:” &lt;&lt; endl;</span><br><span class="line">	printIntArray( array1);</span><br><span class="line">	cout &lt;&lt; &quot;array1的大小:&quot; &lt;&lt;array1.getsize() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;array1的容量:&quot;&lt;&lt; array1.getCapacity() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;-------------------&quot;&lt;&lt;endl;</span><br><span class="line">	MyArray&lt;int&gt; array2( array1);//拷贝</span><br><span class="line">	array2.pop_back( );</span><br><span class="line">	cout &lt;&lt; &quot;array2打印输出:” &lt;&lt; endl;printIntArray( array2) ;</span><br><span class="line">	cout &lt;&lt; &quot;array2的大小:&quot; &lt;&lt;array2.getsize() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;array2的容量:&quot;&lt;&lt; array2.getCapacity() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//测试自定义数据类型</span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">	Person()&#123;&#125;</span><br><span class="line">	Person(string name,int age) </span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;m_Name = name;</span><br><span class="line">		this-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	string m_Name;</span><br><span class="line">	int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line">void printPersonArray(MyArray&lt;Person&gt;&amp; personArr)</span><br><span class="line">&#123;</span><br><span class="line">	for (int i = 0; i &lt; personArr.getsize(); i++) &#123;</span><br><span class="line">		cout &lt;&lt;&quot;姓名:&quot; &lt;&lt;personArr[i].m_Name &lt;&lt;”年龄: &quot;&lt;&lt; personArr[i].m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void test02()</span><br><span class="line">	&#123;</span><br><span class="line">	//创建数组</span><br><span class="line">		MyArray&lt;Person&gt; pArray (10);</span><br><span class="line">		Person p1(”孙悟空&quot;，30);</span><br><span class="line">		person p2(“韩信&quot;，20);</span><br><span class="line">		Person p3(&quot;妲己&quot;，18) ;</span><br><span class="line">		Person p4(“王昭君&quot;，15);</span><br><span class="line">		person p5(&quot;赵云&quot;，24);</span><br><span class="line">		//插入数据</span><br><span class="line">		pArray. push_back(p1);</span><br><span class="line">		pArray. Push_back(p2);</span><br><span class="line">		printPersonArray(pArray);</span><br><span class="line">		cout &lt;&lt; &quot;pArray的大小:&quot; &lt;&lt;pArray.getsize() &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; &quot;pArray的容量:&quot;&lt;&lt;pArray.getcapacity() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/03/c-%E8%A1%A5%E5%85%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/03/c-%E8%A1%A5%E5%85%85/" class="post-title-link" itemprop="url">c++补充</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-03 16:59:54" itemprop="dateCreated datePublished" datetime="2023-04-03T16:59:54+08:00">2023-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-08 14:32:28" itemprop="dateModified" datetime="2023-04-08T14:32:28+08:00">2023-04-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>如果以前使用过C语言，您可能觉得前面讨论的#define语句已经足够完成这样的工作了。但const比#defien好。首先，它能够明确指定类型。其次，可以使用C++的作用域规则将定义限制在特定的函数或文件中（作用域规则描述了名称在各种模块中的可知程度，将在第9章讨论)。第三，可以将const用于更复杂的类型，如第4章将介绍的数组和结构。</p>
<p>提示:如果读者在学习C++之前学习过C语言，并打算使用#define来定义符号常量，请不要这样做，而应使用const。</p>
<h3 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h3><p>如果定义变量时没有指定初值，则变量被默认初始化（default initialized)，此时变量被赋予了“默认值”。默认值到底是什么由变量类型决定，同时定义变量的位置也会对此有影响。</p>
<p>如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0。一种例外情况是，定义在函数体内部的内置类型变量将不被初始化（uninitialized)。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。</p>
<p>绝大多数类都支持无须显式初始化而定义对象，这样的类提供了一个合适的默认值。例如，以刚刚所见为例，string类规定如果没有指定初值则生成一个空串。</p>
<p>一些类要求每个对象都显式初始化，此时如果创建了一个该类的对象而未对其做明确的初始化操作，将引发错误。</p>
<p>建议初始化每一个内置类型的变量。虽然并非必须这么做，但如果我们不能硝保初始化后程序安全,那么这么做不失为一种简单可靠的方法。</p>
<hr>
<p>变量能且只能被定义一次,但是可以被多次声明。<br>声明和定义的区别看起来也许微不足道，但实际上却非常重要。如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。</p>
<h3 id="关键概念-静态类型"><a href="#关键概念-静态类型" class="headerlink" title="关键概念:静态类型"></a>关键概念:静态类型</h3><p>C++是一种静态类型(statically typed)语言,其含义是在编译阶段检查类型。其中,检查类型的过程称为类型检查（type checking ).</p>
<p>我们已经知道，对象的类型决定了对象所能参与的运算。在C++语言中，编译器负责检查数据类型是否支持要执行的运算，如果试图执行类型不支持的运算，编译器将报错并且不会生成可执行文件。<br>程序越复杂，静态类型检查越有助于发现问题。然而，前提是编译器必须知道每一个实体对象的类型，这就要求我们在使用某个变量之前必须声明其类型。</p>
<h3 id="变量命名规范"><a href="#变量命名规范" class="headerlink" title="变量命名规范"></a>变量命名规范</h3><p>变量命名有许多约定俗成的规范，下面的这些规范能有效提高程序的可读性:标识符要能体现实际含义。<br>变量名一般用小写字母，如 index，不要使用Index或INDEX。用户自定义的类名一般以大写字母开头，如 Sales item。<br>如果标识符由多个单词组成，则单词间应有明显区分，如 student loan或<br>studentLoan，不要使用 studentloan。</p>
<h3 id="指针值"><a href="#指针值" class="headerlink" title="指针值"></a>指针值</h3><p>指针的值（即地址）应属下列4种状态之一:</p>
<p>1．指向一个对象。</p>
<p>2．指向紧邻对象所占空间的下一个位置。</p>
<p>3.空指针，意味着指针没有指向任何对象。</p>
<p>4．无效指针，也就是上述情况之外的其他值。</p>
<p>试图拷贝或以其他方式访问无效指针的值都将引发错误。编译器并不负责检查此类错误,这一点和试图使用未经初始化的变量是一样的。访问无效指针的后果无法预计，因此程序员必须清楚任意给定的指针是否有效。<br>尽管第2种和第3种形式的指针是有效的，但其使用同样受到限制。显然这些指针没有指向任何具体对象，所以试图访问此类指针（假定的）对象的行为不被允许。如果这样做了，后果也无法预计。</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">int **main**() &#123;</span><br><span class="line"></span><br><span class="line">  **SetConsoleOutputCP**(65001);</span><br><span class="line"></span><br><span class="line">  int i=42;</span><br><span class="line"></span><br><span class="line">  int &amp;r=i;</span><br><span class="line"></span><br><span class="line">  int *p ;</span><br><span class="line"></span><br><span class="line">  p=&amp;i;</span><br><span class="line"></span><br><span class="line">  *p=i;</span><br><span class="line"></span><br><span class="line">  int &amp;r2=*p;</span><br><span class="line"></span><br><span class="line">  // test01();</span><br><span class="line"></span><br><span class="line">  //test02();</span><br><span class="line"></span><br><span class="line">  cout&lt;&lt;r&lt;&lt;endl&lt;&lt;&amp;r&lt;&lt;endl&lt;&lt;*p&lt;&lt; endl&lt;&lt;p &lt;&lt; endl&lt;&lt;&amp;r2 &lt;&lt;endl&lt;&lt;r2&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">  system( &quot;pause&quot; );</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">输出</span><br><span class="line">42</span><br><span class="line">0x61fe04</span><br><span class="line">42</span><br><span class="line">0x61fe04</span><br><span class="line">0x61fe04</span><br><span class="line">42//与上面引用类似</span><br></pre></td></tr></table></figure>

<h3 id="建议-初始化所有指针"><a href="#建议-初始化所有指针" class="headerlink" title="建议:初始化所有指针"></a>建议:初始化所有指针</h3><p>使用未经初始化的指针是引发运行时错误的一大原因，和其他变量一样，访问未经初始化的指针所引发的后果也是无法预计的。通常这一行为将造成程序崩溃,而且一旦崩溃，要想定位到出错位置将是特别棘手的问题。</p>
<p>在大多数编译器环境下，如果使用了未经初始化的指针，则该指针所占内存空间的当前内容将被看作一个地址值。访问该指针,相当于去访问一个本不存在的位置上的本不存在的对象。糟糕的是，如果指针所占内存空间中恰好有内容，而这些内容又被当作了某个地址，我们就很难分清它到底是合法的还是非法的了。</p>
<p>因此建议初始化所有的指针,并且在可能的情况下，尽量等定义了对象之后再定义指向它的指针。如果实在不清楚指针应该指向何处,就把它初始化为nullptr或者0.这样程序就能检测并知道它没有指向任何具体的对象了。</p>
<h3 id="赋值和指针"><a href="#赋值和指针" class="headerlink" title="赋值和指针"></a>赋值和指针</h3><p>指针和引用都能提供对其他对象的间接访问，然而在具体实现细节上二者有很大不同，其中最重要的一点就是引用本身并非一个对象。一旦定义了引用，就无法令其再绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象。</p>
<p>指针和它存放的地址之间就没有这种限制了。和其他任何变量(只要不是引用)一样，给指针赋值就是令它存放一个新的地址，从而指向一个新的对象</p>
<p>有时候要想搞清楚一条赋值语句到底是改变了指针的值还是改变了指针所指对象的值不太容易,最好的办法就是记住赋值永远改变的是等号左侧的对象。当写出如下语句时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int *p=0;</span><br><span class="line">int ival=1;</span><br><span class="line">p=&amp;ival;</span><br><span class="line"></span><br><span class="line">//意思是为pi赋一个新的值，也就是改变了那个存放在pi内的地址值。相反的，如果写出如下语句，</span><br><span class="line">*p=0;//ival的值被改变,指针pi并没有改变,即*(&amp;ival)=0;</span><br><span class="line">//则*pi（也就是指针pi指向的那个对象）发生改变。</span><br></pre></td></tr></table></figure>

<hr>
<p>利用void指针能做的事儿比较有限:拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个 void指针。不能直接操作 void指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。<br>概括说来，以void的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间中所存的对象.</p>
<h3 id="指向指针的引用"><a href="#指向指针的引用" class="headerlink" title="指向指针的引用"></a>指向指针的引用</h3><p>引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i =42;</span><br><span class="line">int *p;//p是一个 int型指针</span><br><span class="line">int *&amp;r =p;// r是一个对指针p的引用</span><br><span class="line">r= &amp;i;//r引用了一个指针，因此给r赋值&amp;i就是令p指向i</span><br><span class="line">*r= 0;//解引用r得到i，也就是p指向的对象，将i的值改为0</span><br></pre></td></tr></table></figure>

<p>要理解r的类型到底是什么，最简单的办法是从右向左阅读r的定义。离变量名最近的符号（此例中是&amp;r的符号&amp;）对变量的类型有最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，此例中的符号*说明r引用的是一个指针。最后，声明的基本数据类型部分指出r引用的是一个int指针。</p>
<p>面对一条比较复杂的指针或引用的声明语句时,从右向左阅读有助于弄清楚它的真实含义。</p>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>某些时候有这样一种const变量，它的初始值不是一个常量表达式，但又确实有必要在文件间共享。这种情况下，我们不希望编译器为每个文件分别生成独立的变量。相反，我们想让这类const对象像其他（非常量）对象一样工作，也就是说，只在一个文件中定义const，而在其他多个文件中声明并使用它。</p>
<p>解决的办法是，对于 const变量不管是声明还是定义都添加extern关键字，这样只需定义一次就可以了:<br>&#x2F;&#x2F; file_l.cc定义并初始化了一个常量，该常量能被其他文件访问</p>
<p>extern const int bufSize &#x3D; fcn();</p>
<p>&#x2F;&#x2F;file l.h头文件</p>
<p>extern const int bufSize;&#x2F;&#x2F;与file_1.cc中定义的bufSize是同一个</p>
<p>如上述程序所示，file_1.cc定义并初始化了bufsize。因为这条语句包含了初始值，所以它(显然）是一次定义。然而，因为bufsize是一个常量，必须用extern加以限定使其被其他文件使用。<br>file_1.h头文件中的声明也由extern做了限定，其作用是指明bufSize并非本文件所独有，它的定义将在别处出现。</p>
<p>如果想在多个文件之间共享 const对象,必须在变量的定义之前添加extern关键字。</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i=42;</span><br><span class="line">const int &amp;r1 = i;//允许将const int&amp;绑定到一个普通int对象上</span><br><span class="line">const int &amp;r2=42; //正确:r1是一个常量引用</span><br><span class="line">const int &amp;r3 = r1* 2; //正确:r3是一个常量引用</span><br><span class="line">int &amp;r4 = r1 * 2;//错误:r4是一个普通的非常量引用</span><br></pre></td></tr></table></figure>

<p>要想理解这种例外情况的原因，最简单的办法是弄清楚当一个常量引用被绑定到另外一种类型上时到底发生了什么:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double dval = 3.14;</span><br><span class="line">const int &amp;ri = dval;</span><br></pre></td></tr></table></figure>

<p>此处ri引用了一个int型的数。对ri的操作应该是整数运算，但dval却是一个双精度浮点数而非整数。因此为了确保让ri绑定一个整数，编译器把上述代码变成了如下形式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int temp = dval;//由双精度浮点数生成一个临时的整型常量</span><br><span class="line">const int &amp;ri = temp;//让ri绑定这个临时量</span><br></pre></td></tr></table></figure>

<p>在这种情况下，ri 绑定了一个<strong>临时量</strong> (temporary）对象。所谓临时量对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。C++程序员们常常把临时量对象简称为临时量。</p>
<p>接下来探讨当ri不是常量时，如果执行了类似于上面的初始化过程将带来什么样的后果。如果ri不是常量，就允许对ri赋值，这样就会改变ri所引用对象的值。注意，此时绑定的对象是一个临时量而非dval。程序员既然让ri引用dval，就肯定想通过ri改变dval的值，否则干什么要给ri赋值呢?如此看来，既然大家基本上不会想着把引用绑定到临时量上，C++语言也就把这种行为归为非法。</p>
<h3 id="指针和-const"><a href="#指针和-const" class="headerlink" title="指针和 const"></a>指针和 const</h3><p>与引用一样，也可以令指针指向常量或非常量。类似于常量引用，指向常量的指针（pointer to const)不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const double pi =3.14;//pi是个常量,它的值不能改变</span><br><span class="line">double *ptr = &amp;pi;//错误:ptr是一个普通指针</span><br><span class="line">const double *cptr = &amp;pi;//正确:cptr可以指向一个双精度常量</span><br><span class="line">*cptr =42;//错误:不能给*cptr赋值</span><br></pre></td></tr></table></figure>

<p>指针的类型必须与其所指对象的类型一致，但是有两个例外。第一种例外情况是允许令一个指向常量的指针指向一个非常量对象:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double dval = 3.14;//dval是一个双精度浮点数，它的值可以改变</span><br><span class="line">cptr=&amp;dval;//正确:但是不能通过cptr改变 dval的值</span><br></pre></td></tr></table></figure>

<p>和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。</p>
<h3 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a>const指针</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int errNumb=0;</span><br><span class="line">int *const curErr=&amp;errNumb;// curErr将一直指向errNumb</span><br><span class="line">const double pi=3.14159;</span><br><span class="line">const double *const pip = &amp;pi;// pip是一个指向常量对象的常量指针</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。常量指针(const pointer)必须初始化，而且一旦初始化完成，则它的值(也就是存放在指针中的那个地址）就不能再改变了。把放在const关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味，即<strong>不变的是指针本身的值</strong>(地址)而非指向的那个值（*curErr &#x3D;0;&#x2F;&#x2F;正确:把curErr所指的对象的值重置）:所以curErr指向的是一个一般的非常量整数，那么就完全可以用curErr去修改errNumb的值（当errNumb不为0时，）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//如果curErr所指的对象（也就是errNumb)的值不为0</span><br><span class="line">if(*curErr) &#123;</span><br><span class="line">	errorHandler ();</span><br><span class="line">	*curErr =0;//正确:把curErr所指的对象的值重置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>要想弄清楚这些声明的含义最行之有效的办法是从右向左阅读。此例中，离curErr最近的符号是const，意味着curErr本身是一个常量对象，对象的类型由声明符的其余部分确定。声明符中的下一个符号是*，意思是curErr是一个常量指针。最后，该声明语句的基本数据类型部分确定了常量指针指向的是一个int对象。与之相似，我们也能推断出，pip是一个常量指针，它指向的对象是一个双精度浮点型常量。</p>
<h3 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层const</h3><p>如前所述，指针本身是一个对象，它又可以指向另外一个对象。因此，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。用名词顶层const( top-level const）表示指针本身是个常量，而用名词底层const(low-level const）表示指针所指的对象是一个常量。<br>更一般的，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用,如算术类型、类、指针等。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const，这一点和其他类型相比区别明显:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int i=0;</span><br><span class="line">int *const pl =&amp;i;//不能改变p1的值，这是一个顶层const</span><br><span class="line">const int ci =42;</span><br><span class="line">//不能改变ci的值，这是一个顶层const</span><br><span class="line">const int *p2= &amp;ci;</span><br><span class="line">//允许改变p2的值，这是一个底层const</span><br><span class="line">const int &amp;r=ci;</span><br><span class="line">//  所有的引用本身都是顶层 const，因为引用一旦初始化就不能再改为其他对象的引用，这里用于声明引用的 const 都是底层 const</span><br></pre></td></tr></table></figure>

<p>当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显。其中，顶层const不受什么影响:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i= ci;//正确:铂贝ci的值，ci是一个顶层const，对此操作无影响</span><br><span class="line">p2 = p3;//正确:p2和p3指向的对象类型相同,p3顶层const的部分不影响</span><br></pre></td></tr></table></figure>

<p>执行拷贝操作并不会改变被拷贝对象的值，因此，拷入和拷出的对象是否是常量都没什么影响。</p>
<p>另一方面，底层 const 的限制却不能忽视。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*int p= p3;</span><br><span class="line">//错误:p3包含底层const的定义，而p没有</span><br><span class="line">p2= p3;</span><br><span class="line">//正确:p2和p3都是底层const</span><br><span class="line">p2 = &amp;i;</span><br><span class="line">//正确:int*能转换成const int*</span><br><span class="line">int &amp;r =ci;</span><br><span class="line">//错误:普通的int&amp;不能绑定到int常量上</span><br><span class="line">const int &amp;r2 =i;</span><br><span class="line">//正确:const int&amp;可以绑定到一个普通int上</span><br></pre></td></tr></table></figure>

<p>p3既是顶层const也是底层const，拷贝p3时可以不在乎它是一个顶层const，但是必须清楚它指向的对象得是一个常量。因此，不能用p3去初始化p，因为p指向的是一个普通的（非常量)整数。另一方面，p3的值可以赋给p2，是因为这两个指针都是底层const，尽管p3同时也是一个常量指针（顶层 const)，仅就这次赋值而言不会有什么影响。</p>
<h3 id="constexpr变量"><a href="#constexpr变量" class="headerlink" title="constexpr变量"></a>constexpr变量</h3><p>在一个复杂系统中，很难（几乎肯定不能）分辨一个初始值到底是不是常量表达式。当然可以定义一个 const变量并把它的初始值设为我们认为的某个常量表达式，但在实际使用时，尽管要求如此却常常发现初始值并非常量表达式的情况。可以这么说，在此种情况下，对象的定义和使用根本就是两回事儿。<br>C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">constexpr int mf = 20;// 20是常量表达式</span><br><span class="line">constexpr int limit = mf +1;// mf +1是常量表达式</span><br><span class="line">constexpr int sz=size();//只有当size是一个constexpr函数时,才是一条正确的声明语句</span><br></pre></td></tr></table></figure>

<p>尽管不能使用普通函数作为constexpr变量的初始值，新标准允许定义一种特殊的constexpr函数。这种函数应该足够简单以使得编译时就可以计算其结果,这样就能用constexpr函数去初始化constexpr变量了。</p>
<p>一般来说，如果你认定变量是一个常量表达式，那就把它声明成constexpr类型。</p>
<h3 id="字面值类型"><a href="#字面值类型" class="headerlink" title="字面值类型"></a>字面值类型</h3><p>常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为“字面值类型”(literal type）。</p>
<p>到目前为止接触过的数据类型中，<strong>算术类型、引用和指针</strong>都属于字面值类型。自定义类sales item、IO库、string 类型则不属于字面值类型，也就不能被定义成constexpr。</p>
<p>尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0,或者是存储于某个固定地址中的对象。</p>
<p>函数体内定义的变量一般来说并非存放在固定地址中，因此constexpr指针不能指向这样的变量。相反的，定义于所有函数体之外的对象其地址固定不变，能用来初始化constexpr 指针。允许函数定义一类有效范围超出函数本身的变量，这类变量和定义在函数体之外的变量一样也有固定地址。因此，constexpr 引用能绑定到这样的变量上，constexpr指针也能指向这样的变量。定义constexpr常量都要在函数体外。</p>
<p>必须明确一点，在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int *p = nullptr;// p是一个指向整型常量的指针</span><br><span class="line">constexpr int *q= nullptr; //q是一个指向整数的常量指针</span><br></pre></td></tr></table></figure>

<p>p和q的类型相差甚远，p是一个指向常量的指针，而q是一个常量指针，其中的关键在于constexpr把它所定义的对象置为了顶层const。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/03/%E7%AC%AC%E4%BA%94%E5%A4%A9-c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/03/%E7%AC%AC%E4%BA%94%E5%A4%A9-c/" class="post-title-link" itemprop="url">第五天 c++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-03 09:24:35 / 修改时间：16:59:18" itemprop="dateCreated datePublished" datetime="2023-04-03T09:24:35+08:00">2023-04-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="多态的基本概念"><a href="#多态的基本概念" class="headerlink" title="多态的基本概念"></a>多态的基本概念</h3><p>多态是C++面向对象三大特性之一</p>
<p>多态分为两类:</p>
<ul>
<li>静态多态:函数重载和运算符重载属于静态多态，复用函数名</li>
<li>动态多态:派生类和虚函数实现运行时多态</li>
</ul>
<p>静态多态和动态多态区别:</p>
<ul>
<li>静态多态的函数地址早绑定–编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定–运行阶段确定函数地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	// Speak函数就是虚函数</span><br><span class="line">	//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span><br><span class="line">	//vfptr-虚函教（表）指针</span><br><span class="line">	//v- virtual</span><br><span class="line">	//f - function</span><br><span class="line">	//ptr - pointer</span><br><span class="line">	virtual void speak()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;动物在说话&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Cat :public Animal&#123;</span><br><span class="line">public:</span><br><span class="line">	void speak()&#123;</span><br><span class="line">		cout &lt;&lt;&quot;小猫在说话&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">class Dog :public Animal&#123;</span><br><span class="line">public:</span><br><span class="line">	void speak( )&#123;</span><br><span class="line">		cout &lt;&lt;&quot;小狗在说话&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//我们希望传入什么对象，那么就调用什么对象的函数</span><br><span class="line">//如果函数地址在编译阶段就能确定，那么静态联编</span><br><span class="line">//如果函数地址在运行阶段才能确定，就是动态联编</span><br><span class="line"></span><br><span class="line">void DoSpeak( Animal &amp; animal)&#123;//Animal &amp; animal=cat;引用指向子类对象,如果没有virtual，则编译阶段就确定函数调用Animal了，则不能实现动态调用了</span><br><span class="line">	animal.speak( );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//多态满足条件:</span><br><span class="line">//1、有继承关系</span><br><span class="line">//2、子类重写父类中的虚函数，这里就是speak函数</span><br><span class="line">//多态使用:</span><br><span class="line">//父类指针或引用指向子类对象</span><br><span class="line">void test01()&#123;</span><br><span class="line">	Cat cat;</span><br><span class="line">	DoSpeak(cat);//用引用也可以。引用不用手动释放内存。指针不用实例化对象。各有优劣,即引用时不能写成	//DoSpeak(new Cat);</span><br><span class="line">	Dog dog;</span><br><span class="line">	DoSpeak( dog);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    SetConsoleOutputCP(65001);</span><br><span class="line">	test01();</span><br><span class="line">	//test02();</span><br><span class="line">	system( &quot;pause&quot; );</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:</p>
<p>多态满足条件</p>
<ul>
<li>有继承关系</li>
<li>子类<strong>重写</strong>父类中的虚函数</li>
</ul>
<p>多态信用条件</p>
<ul>
<li>父类指针或引用指向子类对象</li>
</ul>
<p>重写:函数返回值类型	函数名	参数列表	完全—致称为重写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//重写	函数返回值类型	函数名参	数列表完全相同</span><br><span class="line">virtual void speak ()</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;”小猫在说话”&lt;&lt; endl:</span><br><span class="line">&#125;</span><br><span class="line">当子类重写父类的虚函数</span><br><span class="line">这里不是子类中的虚函数表内部会替换成子类的虚函数地址，而是添加，因为替换的话，子类的虚函数就会丢失父类的虚函数地址，但实际上子类的虚函数表中同时有父类的虚函数地址和它自己的虚函数地址，通过使用方式不同，如利用父类指针或引用指向子类这种方式，来区分到底是使用子类虚数表里两个虚数表中的哪一个</span><br></pre></td></tr></table></figure>

<h3 id="多态案例一-计算器类"><a href="#多态案例一-计算器类" class="headerlink" title="多态案例一-计算器类"></a>多态案例一-计算器类</h3><p>案例描述:</p>
<p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p>
<p>多态的优点:</p>
<ul>
<li>代码组织结构清晰。可读性强</li>
<li>利于前期和后期的扩展以及维护</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">//普通实现</span><br><span class="line">class calculator &#123;</span><br><span class="line">public:</span><br><span class="line">	int getResult( string oper)&#123;</span><br><span class="line">		if (oper == &quot;+&quot;) &#123;</span><br><span class="line">			return m_Num1 + m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (oper == &quot;-&quot;) &#123;</span><br><span class="line">			return m_Num1 - m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (oper ==“*&quot;)&#123;</span><br><span class="line">			return m_Num1 *m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">	//如果要提供新的运算，需要修改源码</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	int m_Num1;</span><br><span class="line">	int m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line">void teste1()&#123;</span><br><span class="line">	//普通实现测试</span><br><span class="line">	Calculator c;</span><br><span class="line">	c.m_Num1 = 10;</span><br><span class="line">	c.m_Num2 = 10;</span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; c.m_Num2&lt;&lt; &quot; - &quot; &lt;&lt; c.getResult(&quot;+&quot;) &lt;&lt; endl;</span><br><span class="line">	cout &lt; c.m_Num1 &lt;&lt; &quot; . &quot; &lt;&lt; c.m_Num2&lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;-&quot;) &lt;&lt; endl;</span><br><span class="line">	cout &lt; c.m_Num1 &lt;&lt;”*&quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;*&quot;) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//多态实现</span><br><span class="line">//抽象计算器类</span><br><span class="line">//多态优点:代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护</span><br><span class="line">class Abstractcalculator</span><br><span class="line">&#123;</span><br><span class="line">public :</span><br><span class="line">	virtual int getResult()&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">		int m_Num1;</span><br><span class="line">		int m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//加法计算器</span><br><span class="line">class Addcalculator :public Abstractcalculator&#123;</span><br><span class="line">public:</span><br><span class="line">	int getResult()&#123;</span><br><span class="line">		return m_Num1 + m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//减法计算器</span><br><span class="line">class Subcalculator :public Abstractcalculator&#123;</span><br><span class="line">public:</span><br><span class="line">	int getResult()&#123;</span><br><span class="line">		return m_Num1 - m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//乘法计算器</span><br><span class="line">class Mulcalculator :public Abstractcalculator&#123;</span><br><span class="line">public:</span><br><span class="line">	int getResult()&#123;</span><br><span class="line">		return m_Num1 * m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void teste2()&#123;</span><br><span class="line">	//创建加法计算器</span><br><span class="line">	Abstractcalculator *abc = new Addcalculator;//多态使用:</span><br><span class="line">	//父类指针或引用指向子类对象,这里是父类指针指向子类对象</span><br><span class="line">	abc-&gt;m_Num1 = 10;</span><br><span class="line">	abc-&gt;m_Num2 = 10;</span><br><span class="line">	cout &lt; abc-&gt;m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;</span><br><span class="line">	delete abc;//用完了记得销毁</span><br><span class="line">	//创建减法计算器</span><br><span class="line">	abc = new Subcalculator;</span><br><span class="line">	abc-&gt;m_Num1 = 10;</span><br><span class="line">	abc-&gt;m_Num2 = 10;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; -&quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;</span><br><span class="line">	delete abc;</span><br><span class="line">	//创建乘法计算器</span><br><span class="line">	abc = new MulCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = 10;</span><br><span class="line">	abc-&gt;m_Num2 = 10;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt;&quot; * &quot; &lt;&lt; abc-&gt;m_Num2 〈&lt; &quot; - &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;</span><br><span class="line">	delete abc;</span><br><span class="line">	&#125; </span><br></pre></td></tr></table></figure>

<p>总结:C++开发提倡利用多森设计程序架构，因为多态优点很多</p>
<h3 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h3><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p>
<p>因此可以将虚函数改为纯虚函数</p>
<p>纯虚函数语法:virtual 	返回值类型	函数名	(参数列表)&#x3D; 0;</p>
<p>当类中有了纯虚函数，这个类也称为<strong>抽象类</strong></p>
<p>抽象类特点:</p>
<ul>
<li>无法实例化对象</li>
<li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Base&#123;</span><br><span class="line">public:</span><br><span class="line">	//纯虚函数</span><br><span class="line">	//类中只要有一个纯虚函数就称为抽象类</span><br><span class="line">	//抽象类无法实例化对象,但是能定义一个指向该类的指针</span><br><span class="line">	//子类必须重写父类中的纯虚函数，否则也属于抽象类</span><br><span class="line">	virtual void func() = 0;</span><br><span class="line">&#125;;</span><br><span class="line">class Son :public Base&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void func()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;func调用&quot;&lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">void teste1()&#123;</span><br><span class="line">	Base * base = NULL;</span><br><span class="line">	// base = new Base; </span><br><span class="line">	//错误，抽象类无法实例化对象</span><br><span class="line">	base = new Son;</span><br><span class="line">	base-&gt;func( );</span><br><span class="line">	delete base; //记得销毁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h3><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>
<p>解决方式:将父类中的析构函数改为<strong>虚析构</strong>或者纯虚析构</p>
<p>虚析构和纯虚析构共性:</p>
<ul>
<li>可以解决父类指针释放子类对象</li>
<li>都需要有具体的函数实现</li>
</ul>
<p>虚析构和纯虚析构区别:</p>
<ul>
<li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li>
</ul>
<p>虚析构语法:</p>
<p><code>virtual 	~类名( )&#123;&#125;</code></p>
<p>纯虚析构语法:</p>
<p><code>virtual	~类名()= 0;</code></p>
<p><code>类名::~类名()&#123;&#125;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">public:</span><br><span class="line">	Animal()&#123;</span><br><span class="line">	cout &lt;&lt; &quot;Animal构造函数调用!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void Speak() = 0;</span><br><span class="line">	//析构函数加上virtual关键字，变成虚析构函数</span><br><span class="line">	//virtual ~Animal()</span><br><span class="line">	//&#123;</span><br><span class="line">	//cout &lt;&lt; &quot;Animal虚析构函数调用! &quot;&lt;&lt;endl;</span><br><span class="line">    //&#125;</span><br><span class="line">	virtual ~Animal() = 0;</span><br><span class="line">&#125;;</span><br><span class="line">Animal : :~Animal()&#123;</span><br><span class="line">	cout &lt;&lt;&quot;Animal纯虚析构函数调用!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span><br><span class="line">class Cat : public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">	Cat(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;cat构造函数调用!&quot; &lt;&lt;endl;</span><br><span class="line">		m_Name = new string( name);</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void Speak()&#123;</span><br><span class="line">		cout &lt;&lt; *m_Name &lt;&lt;&quot;小猫在说话!&quot;&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~Cat()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;cat析构函数调用!&quot;&lt;&lt; endl;</span><br><span class="line">		if (this-&gt;m_Name != NULL)&#123;</span><br><span class="line">		delete m_Name;</span><br><span class="line">		m_Name = NULL;//置空是为了防止出现野指针</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	string *m_Name;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	Animal *animal = new Cat( &quot;Tom&quot; ) ;</span><br><span class="line">	animal-&gt;Speak();</span><br><span class="line">	//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏</span><br><span class="line">	//怎么解决?给基类增加一个虚析构函数</span><br><span class="line">	//虚析构函数就是用来解决通过父类指针释放子类对象</span><br><span class="line">	delete animal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>1.虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p>
<p>2.如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p>
<p>3.拥有纯虚析构函数的类也属于抽象类</p>
<p>抽象类不能实例化,但是能定义一个指向该类的指针</p>
<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>程序运行时产生的数据都属于临时数据，程序—旦运行结束都会被释放通过文件可以将数据持久化</p>
<p>C++中对文件操作需要包含头文件&lt; fstream &gt;</p>
<p>文件类型分为两种:</p>
<p>1.文本文件-文件以文本的ASCII码形式存储在计算机中</p>
<p>2.二进制文件-文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们</p>
<p>操作文件的三大类:</p>
<ul>
<li>ofstream:写操作</li>
<li>ifstream:读操作</li>
<li>fstream :读写操作</li>
</ul>
<h3 id="写文件步骤如下"><a href="#写文件步骤如下" class="headerlink" title="写文件步骤如下:"></a>写文件步骤如下:</h3><p>1.包含头文件</p>
<p>#include <fstream></p>
<p>2.创建流对象<br>ofstream ofs;&#x2F;&#x2F;读文件则为ifstream ofs</p>
<p>3.打开文件<br>ofs.open(“文件路径”,打开方式);&#x2F;&#x2F;读文件则为ifs.open(“文件路径”,打开方式)</p>
<p>4.写数据</p>
<p>ofs &lt;&lt;”写入的数据”;</p>
<p>5.关闭文件</p>
<p>ofs.close();&#x2F;&#x2F;读文件则为ifs.close()</p>
<p>文件打开方式:</p>
<table>
<thead>
<tr>
<th>打开方式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>ios:inl</td>
<td>为读文件而打开文件</td>
</tr>
<tr>
<td>ios::out</td>
<td>为写文件而打开文件</td>
</tr>
<tr>
<td>ios:.ate</td>
<td>初始位置:文件尾</td>
</tr>
<tr>
<td>ios:.app</td>
<td>追加方式写文件</td>
</tr>
<tr>
<td>ios:trunc</td>
<td>如果文件存在先删除，再创建</td>
</tr>
<tr>
<td>ios:binary</td>
<td>二进制方式</td>
</tr>
</tbody></table>
<p>注意:文件打开方式可以配合使用，利用|操作符</p>
<p>例如:用二进制方式写文件<code>ios ::binary | ios:: out</code></p>
<h3 id="读文件步骤如下"><a href="#读文件步骤如下" class="headerlink" title="读文件步骤如下:"></a>读文件步骤如下:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ifstream ifs;</span><br><span class="line">ifs.open(&quot;test.txt&quot;, ios ::in);</span><br><span class="line">if ( !ifs.is_open())</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt;&quot;文件打开失败”&lt;&lt; endl;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">//第—种方式</span><br><span class="line">//char buf[1024] =&#123; 0 &#125;;</span><br><span class="line">// while (ifs &gt;&gt; buf)</span><br><span class="line">//&#123;</span><br><span class="line">	//cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">	//&#125;</span><br><span class="line">//第二种</span><br><span class="line">//char buf[ 1024] - &#123; 0 &#125;;</span><br><span class="line">// while (ifs.getline(buf,sizeof( buf) )); </span><br><span class="line">//&#123;</span><br><span class="line">	//cout &lt;&lt; buf &lt;&lt; endl;	</span><br><span class="line">//&#125;</span><br><span class="line">//第三种</span><br><span class="line">//string buf;</span><br><span class="line">// while (getline(ifs, buf )) </span><br><span class="line">//&#123;</span><br><span class="line">	//cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">// &#125;</span><br><span class="line">char c;</span><br><span class="line">while ((c = ifs.get()) !=EOF)&#123;//EOF end of file</span><br><span class="line">	cout &lt;&lt; c;</span><br><span class="line">&#125;</span><br><span class="line">ifs.close();</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/02/%E7%AC%AC%E5%9B%9B%E5%A4%A9-c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/02/%E7%AC%AC%E5%9B%9B%E5%A4%A9-c/" class="post-title-link" itemprop="url">第四天 c++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-02 10:18:27 / 修改时间：17:55:52" itemprop="dateCreated datePublished" datetime="2023-04-02T10:18:27+08:00">2023-04-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="C-对象模型和this指针"><a href="#C-对象模型和this指针" class="headerlink" title="C++对象模型和this指针"></a>C++对象模型和this指针</h2><h3 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a>成员变量和成员函数分开存储</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Class Person&#123;</span><br><span class="line">	int m_A; //非静态成员变量 属于类的对象上</span><br><span class="line">	static int m_B;//静态成员变量 不属于类对象上</span><br><span class="line">	void func()&#123;&#125;//非静态成员函数 不属于类对象上,即test02测试空间没有包含  不属于类对象上</span><br><span class="line">	static void func2()&#123;&#125;//静态成员函数 不属于类对象上</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">int Person: :m_B = o;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">Person p ;</span><br><span class="line">//空对象占用内存空间为:1</span><br><span class="line">//C++编译器会给每个空对象也分配一个字节空间，是为了区分空对象占内存的位置</span><br><span class="line">//每个空对象也应该有一个独一无二的内存地址</span><br><span class="line">cout &lt;&lt; &quot;size of p = &quot; &lt;&lt; sizeof(p) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test02()&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	cout &lt;&lt; &quot;size of p = &quot; &lt;&lt; sizeof(p) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码，如果有p1,p2,p3…</p>
<p>每一个调用都是调用同一块内存空间</p>
<h3 id="this指针概念"><a href="#this指针概念" class="headerlink" title="this指针概念"></a>this指针概念</h3><p>接上那么问题是:这—块代码是如何区分那个对象调用自己的呢?</p>
<p>C++通i过提供特殊的对象指针， this指针，解决上述问题。</p>
<p>this指针指向被调用的成员函数所属的对象。</p>
<p>this指针是隐含每一个非静态成员函数内的一种指针。</p>
<p>this指针不需要定义，直接使用即可。</p>
<p>静态函数没有this指针。因为静态函数不属于某个对象。</p>
<p>this指针指向的就是对象,通过*this解引用可以访问该对象本身</p>
<p><strong>this指针的用途</strong>:</p>
<p>当形参和成员变量同名时，可用this指针来区分。</p>
<p>在类的非静态成员函数中返回对象本身，可使用return *this。</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">	Person (int age)&#123;</span><br><span class="line">	this-&gt;age = age;//谁调用Person，this就指向谁，比如Person p1;则this指向p1</span><br><span class="line">	&#125;</span><br><span class="line">	Person&amp; PersonAddAge (Person &amp;p)&#123;//引用指向本身内存。不用引用就是拷贝了,而拷贝指向另一个内存</span><br><span class="line">	//不引用就会直接使用复制构造丽数。因为*this这个对象会在函数结束后销毁</span><br><span class="line">	//引用可以让p2使用同一个内存，而*this指向的就是内存地址，所以不加&amp;后面的</span><br><span class="line">	//p2.PersonAddAge(p1).PersonAddAge(p1).PersonAddAge(pl);就和第一个调用的p2无关了</span><br><span class="line">	this-&gt;age += p.age;</span><br><span class="line">	//this指向p2的指针，而*this指向的就是p2这个对象本体</span><br><span class="line">	return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	int age;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">void test02 ()&#123;</span><br><span class="line">	Person p1(10) ;</span><br><span class="line">	Person p2(10);</span><br><span class="line">	//链式编程思想</span><br><span class="line">	p2.PersonAddAge(p1).PersonAddAge(p1). PersonAddAge(pl);//上面如果不加引用，则后面每次创建都是一个新的对象，则输出总是20</span><br><span class="line">	cout &lt;&lt; &quot;p2的年龄为:&quot;&lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h3><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p>
<p>如果用到this指针，需要加以判断保证代码的健壮性</p>
<p>this指针的本质是指针常量,指针的指向是不可以修改的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">	void showPersonAge()&#123;</span><br><span class="line">	//报错原因是因为传入的指针是为NULL</span><br><span class="line">		if (this == NULL)//保证代码健壮性</span><br><span class="line">		&#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; &quot;age = &quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;//当为null时，this空对象，报错</span><br><span class="line">		&#125;</span><br><span class="line">int age;</span><br><span class="line">&#125; ;</span><br><span class="line">void test()&#123;</span><br><span class="line">	Person *p=NULL;</span><br><span class="line">	p-&gt;showPersonAge();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h3><p>常函数:</p>
<p>成员函数后加const后我们称为这个函数为常函数</p>
<p>常函数内不可以修改成员属性</p>
<p>成员属性声明时加关键字mutable后，在常函数中依然可以修改</p>
<p>常对象:</p>
<p>声明对象前加const称该对象为常对象</p>
<p>常对象只能调用常函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Class Person&#123;</span><br><span class="line">public:</span><br><span class="line">	//this指针的本质是指针常量指针的指向是不可以修改的</span><br><span class="line">	// const Person * const this;</span><br><span class="line">	//在成员函数后面加const，修饰的是this指向，让指针指向的值也不可以修改</span><br><span class="line">	void showPerson() const</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;m_B=100; </span><br><span class="line">		//this-&gt;m_A = 100;</span><br><span class="line">		//this = NULL; //this指针不可以修改指针的指向的</span><br><span class="line">	&#125;</span><br><span class="line">	int m_A;</span><br><span class="line">	mutable int m_B;//特殊变量，即使在常函数中，也可以修改这个值</span><br><span class="line">&#125;;</span><br><span class="line">//常对象</span><br><span class="line">void test02 ()</span><br><span class="line">&#123;</span><br><span class="line">	const Person p;//在对象前加const，变为常对象</span><br><span class="line">	//p.m_A = 100;</span><br><span class="line">	p.m_B = 100; //m_B是特殊值，在常对象下也可以修改</span><br><span class="line">	//常对象只能调用常函数</span><br><span class="line">	p.showPerson () ;</span><br><span class="line">	//P.func ();//如果能调用，则可能会出现m_A被修改，其实是不能修改的。常对象不可以调用普通成员函数，因为普通成员函数可以修改属性,常对象可以修改静态变量的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><h3 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h3><p>在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>
<p>友元的目的就是让—个函数或者类访问另一个类中私有成员</p>
<p>友元的关键字为friend </p>
<p>友元的三种实现</p>
<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Building&#123;</span><br><span class="line">	//goodGay全局函数是 Building好朋友，可以访问Building中私有成员</span><br><span class="line">	//告诉编译器goodGay全局函数是Building类的好朋友，可以访问类中的私有内容</span><br><span class="line">	friend void goodGay(Building *building);</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">//全局函数</span><br><span class="line">void goodGay(Building *building)</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;&quot;好基友全局函数正在访问:&quot;&lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout&lt;&lt;&quot;好基友全局函数正在访问: &quot;&lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	Building building;</span><br><span class="line">	goodGay(&amp;building);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Building;</span><br><span class="line">class goodGay&#123;</span><br><span class="line">public:</span><br><span class="line">	goodGay();</span><br><span class="line">	void visit();</span><br><span class="line">private:</span><br><span class="line">	Building *building;</span><br><span class="line">&#125;;</span><br><span class="line">class Building&#123;</span><br><span class="line">	//告诉编译器goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span><br><span class="line">	friend class goodGay;</span><br><span class="line">public :</span><br><span class="line">	Building();</span><br><span class="line">public:</span><br><span class="line">	string m_sittingRoom;//客厅</span><br><span class="line">private:</span><br><span class="line">	string m_BedRoom; //卧室</span><br><span class="line">&#125;;</span><br><span class="line">Building : : Building()&#123;//类的定义可以在类外进行，所以以后文件太大时，声明在头文件中，定义在源文件中</span><br><span class="line">	this-&gt;m_sittingRoom =&quot;客厅&quot;;</span><br><span class="line">	this-&gt;m_BedRoom =&quot;卧室&quot;;</span><br><span class="line">&#125;</span><br><span class="line">goodGay : : goodGay ()&#123;</span><br><span class="line">	building = new Buildng;//创建一个堆区 </span><br><span class="line">&#125;</span><br><span class="line">void goodGay : : visit()&#123;</span><br><span class="line">	cout &lt;&lt;“好基友正在访问”&lt;&lt; building-&gt;m_sittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt;“好基友正在访问”&lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void teste1()&#123;</span><br><span class="line">	goodGay gg;</span><br><span class="line">	gg.visit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Building;</span><br><span class="line">class goodGay&#123;</span><br><span class="line">public:</span><br><span class="line">	goodGay();</span><br><span class="line">	void visit();//只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span><br><span class="line">	void visit2();</span><br><span class="line">private:</span><br><span class="line">	Building *building;</span><br><span class="line">&#125;;</span><br><span class="line">class Building&#123;</span><br><span class="line">	//告诉编译器goodGay类中的visit成员函数是Building类的好朋友，可以访问到Building类中私有内容</span><br><span class="line">	friend void goodGay::visit();</span><br><span class="line">public :</span><br><span class="line">	Building();</span><br><span class="line">public:</span><br><span class="line">	string m_sittingRoom;//客厅</span><br><span class="line">private:</span><br><span class="line">	string m_BedRoom; //卧室</span><br><span class="line">&#125;;</span><br><span class="line">Building : : Building()&#123;//类的定义可以在类外进行，所以以后文件太大时，声明在头文件中，定义在源文件中</span><br><span class="line">	this-&gt;m_sittingRoom =&quot;客厅&quot;;</span><br><span class="line">	this-&gt;m_BedRoom =&quot;卧室&quot;;</span><br><span class="line">&#125;</span><br><span class="line">goodGay : : goodGay ()&#123;</span><br><span class="line">	building = new Buildng;//创建一个堆区 </span><br><span class="line">&#125;</span><br><span class="line">void goodGay : : visit()&#123;</span><br><span class="line">	cout &lt;&lt;“好基友正在访问”&lt;&lt; building-&gt;m_sittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt;“好基友正在访问”&lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void goodGay : : visit2()&#123;</span><br><span class="line">	cout &lt;&lt;“好基友正在访问”&lt;&lt; building-&gt;m_sittingRoom &lt;&lt; endl;</span><br><span class="line">	//cout &lt;&lt;“好基友正在访问”&lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void teste1()&#123;</span><br><span class="line">	goodGay gg;</span><br><span class="line">	gg.visit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>运算符重载概念:对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>
<h3 id="加号运算符重载"><a href="#加号运算符重载" class="headerlink" title="加号运算符重载"></a>加号运算符重载</h3><p>作用:实现两个自定义数据类型相加的运算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">	person()&#123;&#125;;</span><br><span class="line">	person(int a, int b)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;m_A = a;</span><br><span class="line">		this-&gt;m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line">	//成员函数实现＋号运算符重载</span><br><span class="line">	Person operator+( const Person&amp; p)&#123;</span><br><span class="line">		Person temp;</span><br><span class="line">		temp.m_A = this-&gt;m_A + p.m_A;</span><br><span class="line">		temp.m_B = this-&gt;m_B + p.m_B;</span><br><span class="line">		return temp;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	int m_A;</span><br><span class="line">	int m_B;</span><br><span class="line">&#125;</span><br><span class="line">//全局函数实现+号运算符重载 </span><br><span class="line">//Person operator+( const Person &amp;p1, const Person &amp;p2)&#123;</span><br><span class="line">//	Person temp(0，0);</span><br><span class="line">//	temp.m_A = p1.m_A + p2.m_A;</span><br><span class="line">//	temp.m_B = p1.m_B +p2.m_B;</span><br><span class="line">//&#125;</span><br><span class="line">//运算符重载可以发生函数重载</span><br><span class="line">Person operator+(const Person&amp; p2， int val)</span><br><span class="line">&#123;</span><br><span class="line">	Person temp;</span><br><span class="line">	temp.m_A = p2.m_A + val;</span><br><span class="line">	temp.m_B = p2.m_B + val;</span><br><span class="line">	return temp;</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">	Person p1(10，10);</span><br><span class="line">	Person p2(20，20);</span><br><span class="line">	//成员函数方式</span><br><span class="line">	Person p3 = p2 +p1;//相当于p2.operaor+(p1)</span><br><span class="line">	cout &lt;&lt; &quot;mA: &quot; &lt;&lt;p3.m_A &lt;&lt; &quot; mB: &quot; &lt;&lt; p3.m_B &lt;&lt; endl;</span><br><span class="line">	Person p4 = p3 +10;//相当于operator+(p3,10)</span><br><span class="line">	cout &lt;&lt;“mA: &quot; &lt;&lt;p4.m_A &lt;&lt; &quot; mB : &quot;&lt;&lt; p4.m_B &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结1:对于内置的数据类型的表达式的的运算符是不可能改变的</p>
<p>总结2:不要滥用运算符重载</p>
<h3 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h3><p>作用:可以输出自定义数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">	friend ostream&amp; operator&lt;&lt;(ostream&amp; out，Person&amp; p);</span><br><span class="line">public:</span><br><span class="line">	Person(int a, int b)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;m_A = a;this-&gt;m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line">	//成员函数实现不了p &lt;&lt;cout不是我们想要的效果 </span><br><span class="line">	//void operator&lt;&lt;(Person&amp; p)&#123;</span><br><span class="line">	//&#125;</span><br><span class="line">private :</span><br><span class="line">	int m_A;</span><br><span class="line">	int m_B;</span><br><span class="line">&#125;;</span><br><span class="line">//全局函数实现左移重载</span><br><span class="line">//ostream对象只能有一个</span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; cout，Person&amp; p)&#123;</span><br><span class="line">	out &lt;&lt; &quot;a: &quot; &lt;&lt; p.m_A &lt;&lt; &quot; b:&quot; &lt;&lt; p.m_B;</span><br><span class="line">	return cout;</span><br><span class="line">&#125;</span><br><span class="line">void test() &#123;</span><br><span class="line">	Person p1(10，20);</span><br><span class="line">	cout &lt;&lt;p1 &lt;&lt; &quot;hello world&quot; &lt;&lt;endl;//链式编程,需要返回ostream&amp;,才可以接着后面运算</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:重载左移运算符配合友元可以实现输出自定义数据类型</p>
<h3 id="递增运算符重载"><a href="#递增运算符重载" class="headerlink" title="递增运算符重载"></a>递增运算符重载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class MyInteger &#123;</span><br><span class="line">	friend ostream&amp; operator&lt;&lt;(ostream&amp; out,MyInteger myint);</span><br><span class="line">public:</span><br><span class="line">	MyInteger() &#123;</span><br><span class="line">		m_Num = 0;</span><br><span class="line">	&#125;</span><br><span class="line">	//前置++</span><br><span class="line">	MyInteger&amp; operator++()</span><br><span class="line">	&#123;</span><br><span class="line">		//先++</span><br><span class="line">		m_Num++;</span><br><span class="line">		//再返回自身</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	//后置++</span><br><span class="line">	MyInteger operator++(int) &#123;</span><br><span class="line">		//先返回</span><br><span class="line">		MyInteger temp = *this;//记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++;</span><br><span class="line">		m_Num++;</span><br><span class="line">		return temp;//temp是临时变量，完了会释放，所以不会返回引用</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	int m_Num;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; out,MyInteger myint) &#123;</span><br><span class="line">	out &lt;&lt; myint.m_Num;</span><br><span class="line">	return out;</span><br><span class="line">&#125;</span><br><span class="line">//前置++ 先++ 再返回</span><br><span class="line">void test01() &#123;</span><br><span class="line">	MyInteger myInt;</span><br><span class="line">	cout&lt;&lt;(++myInt)++ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt;myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//后置++ 先返回 再++</span><br><span class="line">void test02() &#123;</span><br><span class="line">	MyInteger myInt;</span><br><span class="line">	cout &lt;&lt; myInt++ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	test01();</span><br><span class="line">	//test02();</span><br><span class="line">	system( &quot;pause&quot; );</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:前置递增返回引用，后置递增返回值</p>
<h3 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h3><p>C++编译器至少给一个类添加4个函数</p>
<ul>
<li>1.默认构造函数(无参，函数体为空)</li>
<li>⒉.默认析构函数(无参，函数体为空)</li>
<li>3.默认拷贝构造函数，对属性进行值拷贝</li>
<li>4.赋值运算符operator&#x3D;,对属性进行值拷贝</li>
</ul>
<p><strong>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">	Person( int age)&#123;</span><br><span class="line">	//将年龄数据开辟到堆区</span><br><span class="line">	m_Age = new int(age);</span><br><span class="line">	&#125;</span><br><span class="line">	//重载赋值运算符</span><br><span class="line">	person&amp; operator=(Person &amp;p)&#123;</span><br><span class="line">		if (m_Age != NULL)&#123;</span><br><span class="line">			delete m_Age;</span><br><span class="line">			m_Age = NULL;</span><br><span class="line">		&#125;</span><br><span class="line">		//编译器提供的代码是浅拷贝</span><br><span class="line">		// m_Age = p.m_Age;</span><br><span class="line">		//提供深拷贝解决浅拷贝的问题</span><br><span class="line">		m_Age = new int(*p.m_Age);</span><br><span class="line">		//返回自身,保证了下面能连等</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	~Person()&#123;</span><br><span class="line">		if (m_Age != NULL)&#123;</span><br><span class="line">			delete m_Age;</span><br><span class="line">			m_Age = NULL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//年龄的指针</span><br><span class="line">	int *m_Age;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()&#123;</span><br><span class="line">	Person p1 (18);</span><br><span class="line">	Person p2(20);</span><br><span class="line">	Person p3( 30);</span><br><span class="line"> 	p3=p2= p1;//赋值操作</span><br><span class="line">	cout &lt;&lt;&quot;p1的年龄为:&quot;&lt;&lt;*p1.m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;p2的年龄为:&quot; &lt;&lt;*p2.m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;p3的年龄为:&quot; &lt;&lt;*p3.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h3><p>作用:重载关系运算符，可以让两个<strong>自定义类型对象</strong>进行对比操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">	Person( string name，int age)&#123;</span><br><span class="line">		this-&gt;m_Name = name;</span><br><span class="line">		this-&gt;m_Age = age;</span><br><span class="line">	&#125;;</span><br><span class="line">	bool operator==(Person &amp; p)&#123;</span><br><span class="line">		if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)&#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	bool operator ! =( Person &amp; p)&#123;</span><br><span class="line">		if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)&#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	string m_Name;</span><br><span class="line">	int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	Person a(&quot;孙悟空&quot;，18);</span><br><span class="line">	Person b(&quot;孙悟空&quot;，18);</span><br><span class="line">	if ( a == b)</span><br><span class="line">	&#123;</span><br><span class="line">    	cout &lt;&lt; &quot;a和b相等”&quot;&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">    cout &lt;&lt; &quot;a和b不等”&quot;&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    if (a !=b)&#123;</span><br><span class="line">		cout &lt;&lt;&quot;a和b不相等&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		cout &lt;&lt; &quot;a和b相等”&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a>函数调用运算符重载</h3><p>函数调用运算符()也可以重载</p>
<p>由于重载后使用的方式非常像函数的调用，因此称为仿函数</p>
<p>仿函数没有固定写法，非常灵活</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class MyPrint&#123;</span><br><span class="line">public:</span><br><span class="line">	void operator()(string text)&#123;</span><br><span class="line">		cout &lt;&lt; text &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()&#123;</span><br><span class="line">	//重载的()操作符也称为仿函数</span><br><span class="line">	MyPrint myFunc;</span><br><span class="line">	myFunc( &quot;hello world&quot; ) ;</span><br><span class="line">&#125;</span><br><span class="line">class MyAdd&#123;</span><br><span class="line">public:</span><br><span class="line">	int operator()(int v1,int v2)&#123;</span><br><span class="line">		return v1 +v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test02()&#123;</span><br><span class="line">	MyAdd add;</span><br><span class="line">	int ret = add(10，10);</span><br><span class="line">	cout &lt;&lt; &quot;ret - &quot; &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">	//匿名对象调用</span><br><span class="line">	cout &lt;&lt;&quot;MyAdd()(100,100) = &quot; &lt;&lt; MyAdd() (100，100) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="继承的基本语法"><a href="#继承的基本语法" class="headerlink" title="继承的基本语法"></a>继承的基本语法</h3><p>继承的好处:减少重复代码</p>
<p>语法:class 	子类:	继承方式	父类</p>
<p>子类也称为派生类</p>
<p>父类也称为基类</p>
<h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p>继承的语法:class子类∶继承方式父类</p>
<p>继承方式一共有三种:</p>
<ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承</li>
</ul>
<p><img src="C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20230402164555514.png" alt="image-20230402164555514"></p>
<p>保护权限和私有权限类外都访问不到。</p>
<h3 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Base&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_A;</span><br><span class="line">protected:</span><br><span class="line">	int m_B;</span><br><span class="line">private:</span><br><span class="line">	int m_c; //私有成员只是被隐藏了，但是还是会继承下去</span><br><span class="line">&#125;;</span><br><span class="line">//公共继承</span><br><span class="line">class Son :public Base&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_D;</span><br><span class="line">&#125;;</span><br><span class="line">void teste1()&#123;</span><br><span class="line">	cout &lt;&lt; &quot;sizeof Son = &quot; &lt;&lt; sizeof(Son)&lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论:父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p>
<h3 id="继承中构造和析构顺序"><a href="#继承中构造和析构顺序" class="headerlink" title="继承中构造和析构顺序"></a>继承中构造和析构顺序</h3><p>子拳继承父类后，当创建子类对象，也会调用父类的构造函数</p>
<p>问题:父类和子类的构造和析构顺序是谁先谁后?</p>
<p>总结:继承中先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p>
<h3 id="4-6-5继承同名成员处理方式"><a href="#4-6-5继承同名成员处理方式" class="headerlink" title="4.6.5继承同名成员处理方式"></a>4.6.5继承同名成员处理方式</h3><p>问题:当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢?</p>
<p>访问子类同名成员直接访问即可</p>
<p>访问父类同名成员需要加作用域</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">	Base()&#123;</span><br><span class="line">		m_A = 100;</span><br><span class="line">	&#125;</span><br><span class="line">	void func()&#123;</span><br><span class="line">		cout &lt;&lt;&quot;Base - func()调用”&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	void func(int a)&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Base - func ( int a)调用&quot;&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	int m_A;</span><br><span class="line">&#125;;</span><br><span class="line">class son : public Base &#123;</span><br><span class="line">public:</span><br><span class="line">	son()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A= 200;</span><br><span class="line">	&#125;</span><br><span class="line">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span><br><span class="line">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span><br><span class="line">	void func()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Son - func()调用&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	int m_A;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()&#123;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; &quot;Son下的m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;Base下的m_A = &quot; &lt;&lt; s.Base::m_A&lt;&lt; endl;</span><br><span class="line">	s.func();</span><br><span class="line">	s.Base::func();</span><br><span class="line">	s.Base::func(10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:<br>1.子类对象可以直接访问到子类中同名成员</p>
<p>2.子类对象加作用域可以访问到父类同名成员</p>
<p>3.当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</p>
<h3 id="继承同名静态成员处理方式"><a href="#继承同名静态成员处理方式" class="headerlink" title="继承同名静态成员处理方式"></a>继承同名静态成员处理方式</h3><p>问题:继承中同名的静态成员在子类对象上如何进行访问?</p>
<p>静态成员和非静态成员出现同名，处理方式—致</p>
<p>·访问子类同名成员直接访问即可</p>
<p>·访问父类同名成员需要加作用域</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">	static void func()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Base - static void func()&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static void func(int a)&#123;</span><br><span class="line">		cout &lt;&lt;&quot;Base - static void func( int a)&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	static int m_A;</span><br><span class="line">&#125;;</span><br><span class="line">int Base::m_A = 100;</span><br><span class="line">class Son : public Base&#123;</span><br><span class="line">public:</span><br><span class="line">	static void func()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Son - static void func()&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	static int m_A;</span><br><span class="line">&#125;;</span><br><span class="line">int Son::m_A = 200;</span><br><span class="line">//同名成员属性</span><br><span class="line">void test01()&#123;</span><br><span class="line">	//通过对象访问</span><br><span class="line">	cout &lt;&lt;“通过对象访问:&quot;&lt;&lt;endl;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; &quot;Son 下m_A =&quot; &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;Base 下m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line">	//通过类名访问</span><br><span class="line">	cout &lt;&lt;“通过类名访问:“ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;Son下m_A = &quot; &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">	cout&lt;&lt; &quot;Base 下m_A = &quot; &lt;&lt;Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//同名成员函数</span><br><span class="line">void test02()&#123;&#125;</span><br><span class="line">	//通过对象访问</span><br><span class="line">	cout &lt;&lt;“通过对象访问:“ &lt;&lt;endl;</span><br><span class="line">	Son s;</span><br><span class="line">	s.func();</span><br><span class="line">	s.Base::func( );</span><br><span class="line">	cout &lt;&lt;“通过类名访问:&quot; &lt;&lt; endl ;</span><br><span class="line">	Son::func();</span><br><span class="line">	son::Base::func();</span><br><span class="line">	//出现同名。子类会隐藏掉父类中所有同名成员函数，需要加作用域访问</span><br><span class="line">	Son::Base::func(100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式(通过对象和通过类名）</p>
<h3 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h3><p>C++允许一个类继承多个类</p>
<p>语法:	class	子类	∶	继承方式	父类1 ，继承方式	父类2…{};</p>
<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>
<p>C++实际开发中不建议用多继承</p>
<p>总结:多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p>
<h3 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line">//继承前加virtual关键字后，变为虚继承//此时公共的父类Animal称为虚基类</span><br><span class="line">class sheep : virtual public Animal&#123;&#125;;</span><br><span class="line">class Tuo: virtual public Animal &#123;&#125;;</span><br><span class="line">class SheepTuo : public Sheep，public Tuo &#123;&#125;;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	sheepTuo st;</span><br><span class="line">	st.Sheep::m_Age = 100;</span><br><span class="line">	st.Tuo::m_Age = 200;//指向的是一样的地址，第二个是后改变的，用后面的数据</span><br><span class="line">	cout &lt;&lt; &quot;st.Sheep::m_Age = &quot;&lt;&lt; st.sheep:: m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;st.Tuo : :m_Age = &quot;&lt;&lt;st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;st.m_Age =&quot; &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:<br>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</p>
<p>利用虚继承可以解决菱形继承问题</p>
<p>虚继承底层原理：</p>
<p><img src="C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20230402175305513.png" alt="image-20230402175305513"></p>
<p>vbptr相当于指针，指向一个虚基类表，表中记录了偏移量，指针加上偏移量，指向了唯一的数据。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/31/%E7%AC%AC%E4%B8%89%E5%A4%A9-c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/31/%E7%AC%AC%E4%B8%89%E5%A4%A9-c/" class="post-title-link" itemprop="url">第三天 c++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-31 09:53:22" itemprop="dateCreated datePublished" datetime="2023-03-31T09:53:22+08:00">2023-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-01 21:04:23" itemprop="dateModified" datetime="2023-04-01T21:04:23+08:00">2023-04-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="函数提高"><a href="#函数提高" class="headerlink" title="函数提高"></a>函数提高</h1><h2 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h2><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p>
<p>语法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">返回值类型	函数名	(参数=默认值)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//参数值传递会覆盖默认参数</span><br><span class="line">int func(int a,int b=20,int c=30)&#123;</span><br><span class="line">return a+b+c;</span><br><span class="line">&#125;</span><br><span class="line">//注意事项</span><br><span class="line">//1.错误，默认参数在前面则后面也必须默认值</span><br><span class="line">//int func2(int a=10,int b,int c)&#123;</span><br><span class="line">//return a+b+c;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//2.如果函数声明有默认值，函数实现的时候不能有默认参数，相反依此</span><br><span class="line">int func2(int a,intb);</span><br><span class="line">int func2(int a=10,int b=10)&#123;</span><br><span class="line">	return a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">func(10,30,30);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//函数重载的注意事项</span><br><span class="line">//1、引用作为重载的条件</span><br><span class="line">void func (int &amp;a)//int &amp;a = 10;不合法</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;func(int &amp;a)调用&quot;&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void func (const int &amp;a) // const int &amp;a = 10;合法代码</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt; &quot;func (const int &amp;a)调用&quot;&lt;&lt; end1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int a=10;</span><br><span class="line">	func(a);//输出第一个</span><br><span class="line">	func(10);//输出第二个</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类中的属性和行为我们统一称为成员</p>
<p>属性称为	成员属性	成员变量</p>
<p>行为称为	成员函数	成员方法</p>
<h2 id="封装意义"><a href="#封装意义" class="headerlink" title="封装意义:"></a>封装意义:</h2><p>类在设计时，可以把属性和行为放在不同的权限下，加以控制访问权限有三种:</p>
<p>1.public	公共权限</p>
<p>2.protected	保护权限</p>
<p>3.private	私有权限<br>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//三种权限</span><br><span class="line">//公共权限public	类内可以访问类外可以访问</span><br><span class="line">//保护权限protected	类内可以访问类外不可以访问</span><br><span class="line">//私有权限private	类内可以访问类外不可以访问</span><br></pre></td></tr></table></figure>

<h2 id="struct和class区别"><a href="#struct和class区别" class="headerlink" title="struct和class区别"></a>struct和class区别</h2><p>在C++中struct和class唯—的区别就在于默认的访问权限不同</p>
<p>区别:<br>struct默认权限为公共</p>
<p>class 默认权限为私有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class C1&#123;</span><br><span class="line">	int m_A;//默认是私有权限</span><br><span class="line">&#125;;</span><br><span class="line">struct C2&#123;</span><br><span class="line">	int m_A;//默认是公共权限</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结构体声明通常不包括public或private的访问修饰符。</p>
<p>struct是为了兼容c而存在的,在以后尽量使用class.</p>
<h2 id="成员属性设置为私有"><a href="#成员属性设置为私有" class="headerlink" title="成员属性设置为私有"></a>成员属性设置为私有</h2><p>优点1:将所有成员属性设置为私有，可以自己控制读写权限。</p>
<p>优点2:对于写权限，我们可以检测数据的有效性。</p>
<h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">	//1.构造函数</span><br><span class="line">	//没有返回值不用写void//函数名与类名相同</span><br><span class="line">	//构造函数可以有参数，可以发生重载</span><br><span class="line">	//创建对象的时候，构造函数会自动调用，而且只调用一次</span><br><span class="line">	Person()</span><br><span class="line">	&#123;</span><br><span class="line">	cout &lt;&lt;&quot;Person构造函数的调用&quot;&lt;&lt; end1;</span><br><span class="line">	&#125;</span><br><span class="line">	Person(int age)</span><br><span class="line">	&#123;</span><br><span class="line">	cout &lt;&lt;&quot;Person有参构造函数的调用&quot;&lt;&lt; end1;</span><br><span class="line">	&#125;</span><br><span class="line">	//1.2拷贝构造函数</span><br><span class="line">	Person( const Person &amp;p )&#123;</span><br><span class="line">	//将传入的人身上的所有属性，拷贝到我身上</span><br><span class="line">	age = p.age;</span><br><span class="line">	&#125;</span><br><span class="line">	//2.析构函数进行清理的操作</span><br><span class="line">	//没有返回值不写void</span><br><span class="line">	//函数名和类名相同在名称前加~</span><br><span class="line">	//析构函数不可以有参数的，不可以发生重载</span><br><span class="line">	//对象在销毁前会自动调用析构函数，而且只会调用一次</span><br><span class="line">	~Person()</span><br><span class="line">	&#123;</span><br><span class="line">	cout &lt;&lt;&quot;Person析构函数的调用&quot;&lt;&lt; end1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">	Person p2=Person(10);//有参构造，也可写成Person p2(10);</span><br><span class="line">	Person p3=Person(p2);//拷贝构造,也可写成Person p3(p2);</span><br><span class="line">	//注意:调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明(void fuc();)</span><br><span class="line">	Person p2();</span><br><span class="line">	Person(10);//匿名对象﹑特点:当前行执行结束后，系统会立即回收掉匿名对象</span><br><span class="line">	//不要利用拷贝构造函数初始化匿名对象瞭编译器会认为Person (p3) === Person p3;</span><br><span class="line">	//Person(p3);//错误的</span><br><span class="line">	//3、隐式转换法</span><br><span class="line">	Person p4 = 10; //相当于写了Person p4 = Person(10) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造和析构都是必须有的实现，如果我们自己不提供，编译器会提供一个空实现的构造和析构</p>
<h2 id="拷贝构造函数调用时机"><a href="#拷贝构造函数调用时机" class="headerlink" title="拷贝构造函数调用时机"></a>拷贝构造函数调用时机</h2><p>C++中拷贝构造函数调用时机通常有三种情况：</p>
<p>使用一个已经创建完毕的对象来初始化一个新对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p2=Person(10);//有参构造，也可写成Person p2(10);</span><br><span class="line">Person p3=Person(p2);//拷贝构造,也可写成Person p3(p2);</span><br></pre></td></tr></table></figure>



<p>值传递的方式给函数参数传值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void doWork ( Person p)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void test02()&#123;</span><br><span class="line">	Person p;//相当于值传递，调用了拷贝函数</span><br><span class="line">	doWork(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以值方式返回局部对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person doWork2()&#123;</span><br><span class="line">	Person pl;</span><br><span class="line">	return p1;//p1是局部对象，会拷贝一个新的person类型返回</span><br><span class="line">&#125;</span><br><span class="line">void test03 ()&#123;</span><br><span class="line">	Person p = doWork2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造函数调用规则"><a href="#构造函数调用规则" class="headerlink" title="构造函数调用规则"></a>构造函数调用规则</h2><p>默认情况下，c++编译器至少给一个类添加3个函数</p>
<p>1．默认构造函数(无参，函数体为空)</p>
<p>2．默认析构函数(无参，函数体为空)</p>
<p>3．默认拷贝构造函数，对属性进行值拷贝</p>
<p>构造函数调用规则如下:</p>
<ul>
<li>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造。</li>
<li>如果用户定义拷贝构造函数，C++不会再提供其他构造函数。（拷贝构造函数也是有参数的，所以编译器不会提供无参构造函数了）</li>
</ul>
<h2 id="4-2-5深拷贝与浅拷贝"><a href="#4-2-5深拷贝与浅拷贝" class="headerlink" title="4.2.5深拷贝与浅拷贝"></a>4.2.5深拷贝与浅拷贝</h2><p>深浅拷贝是面试经典问题，也是常见的一个坑</p>
<p>浅拷贝:简单的赋值拷贝操作</p>
<p>深拷贝:在堆区重新申请空间，进行拷贝操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Person (int age , int height)</span><br><span class="line">&#123;</span><br><span class="line">	m_Age = age;</span><br><span class="line">	m_Height =new int(height) ;//创建堆区</span><br><span class="line">	cout &lt;&lt; &quot;Person的有参构造函数调用&quot;&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">/*自己实现拷贝构造函数解决浅拷贝带来的问题</span><br><span class="line">若不自己实现，则有问题，浅拷贝是对成员变量的简单赋值,拷贝时会直接拷贝堆的地址,所以p2的height指针=p1的height指针,即两个height指针指向堆区的同一个地址</span><br><span class="line">p2在进行拷贝初婚化时使用的是编译器提供的浅拷贝</span><br><span class="line">函数test01结束后，p1和p2把同一个空间释放了两次。所以程序崩了</span><br><span class="line">*/</span><br><span class="line">Person(const Person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;Person拷贝构造函数调用&quot;&lt;&lt; endl;</span><br><span class="line">	m_Age = p.m_Age;</span><br><span class="line">	//m_Height = p.m_Height;编译器默认实现就是这行代码</span><br><span class="line">	//深拷贝操作</span><br><span class="line">	m_Height = new int(*p.m_Height) ;</span><br><span class="line">&#125;</span><br><span class="line">~Person()</span><br><span class="line">&#123;</span><br><span class="line">//析构代码，将堆区开辟数据做释放操作</span><br><span class="line">	if (m_Height != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		delete m_Height;</span><br><span class="line">		m_Height = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt;&quot;Person的析构函数调用&quot;&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">	int m_Age;</span><br><span class="line">	int *m_Height;</span><br></pre></td></tr></table></figure>

<p>总结:如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p>
<h2 id="4-2-6初始化列表"><a href="#4-2-6初始化列表" class="headerlink" title="4.2.6初始化列表"></a>4.2.6初始化列表</h2><p>作用:</p>
<p>C++提供了初始化列表语法，用来初始化属性</p>
<p>语法:构造函数()∶属性1(值1) ,属性2(值2) … {}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">	//初始化列表初始化属性</span><br><span class="line">    Person(int a, int , int c) :m_A(a), m_B(b), m_c(c)</span><br><span class="line">    &#123;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &#125;</span><br><span class="line">    int m_A;</span><br><span class="line">    int m_B;</span><br><span class="line">    int m_C;</span><br></pre></td></tr></table></figure>

<h2 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h2><p>C++类中的成员可以是另一个类的对象，我们称该成员为对象成员<br>例如∶</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;&#125;</span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">	A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>B类中有对象A作为成员，A为对象成员</p>
<p>当其他类对象作为本类成员，构造时候先构造类对象(A)，再构造自身(B ),析构的顺序与构造相反，取木块同理。不可能直接取前面的那个，只有将后面的先取出来才能取到前面的那个。<br>而创建对象也是。我需要用phone对象补全person就需要先创建phone而person因为在后面，所以取的时候先取它。</p>
<h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p>
<p>静态成员分为:</p>
<ul>
<li>静态成员变量</li>
</ul>
<p>所有对象共享同一份数据。</p>
<p>在编译阶段分配内存。编译阶段就分配内存─代码还未开始前(即程序还未运行前),在全局区优先分配好内存</p>
<p>类内声明，类外初始化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	//1所有对象都共享同一份数据</span><br><span class="line">	//2编译阶段就分配内存</span><br><span class="line">	//3类内声明，类外初始化操作</span><br><span class="line">	static int m_A;</span><br><span class="line">private:</span><br><span class="line">	static int m_B;//静态成员变量也是有访问权限的，私有的类外访问不到</span><br><span class="line">&#125;;</span><br><span class="line">int Person::m_A = 100;//这里强调一下，是必须在类外写一下，否则报错，可以不付初值，默认初值是0,加Person是为了说明他是Person类的static </span><br><span class="line">int Person::m_B = 100;</span><br><span class="line">void test()&#123;</span><br><span class="line">	//静态成员变量不属于某个对象上，所有对象都共享同一份数据</span><br><span class="line">	//因此静态成员变量有两种访问方式</span><br><span class="line">	//1、通过对象进行访问</span><br><span class="line">	Person p;</span><br><span class="line">	cout &lt;&lt; p.m_A &lt;&lt; endl;</span><br><span class="line">	//2、通过类名进行访问</span><br><span class="line">	cout &lt;&lt;Person::m_A &lt;&lt; end1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>静态成员函数</li>
</ul>
<p>所有对象共享同一个函数</p>
<p>静态成员函数只能访问静态成员变量，因为如果静态成员函数里有非静态成员变量，class会判断不出非静态成员变量是在什么地方定义的,所以无法确定是否是类成员</p>
<p>静态成员函数也是有访问权限的，私有的类外访问不到静态成员函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//因此静态函数有两种访问方式</span><br><span class="line">	//1、通过对象进行访问</span><br><span class="line">	Person p;</span><br><span class="line">	p.func();</span><br><span class="line">	//2、通过类名进行访问</span><br><span class="line">	Person::func();</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/30/%E7%AC%AC%E4%BA%8C%E5%A4%A9-c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/30/%E7%AC%AC%E4%BA%8C%E5%A4%A9-c/" class="post-title-link" itemprop="url">第二天 c++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-30 16:01:35 / 修改时间：22:02:12" itemprop="dateCreated datePublished" datetime="2023-03-30T16:01:35+08:00">2023-03-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h1><p>指针变量指向内存中编号为0的空间</p>
<p>用途:初始化指针变量</p>
<p>注意:空指针指向的内存（0-255）是不可以访问的，因为这些初始化的内存往往是系统的一些中断，若想赋值，只能定义其它数值，再把地址赋予指针变量，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">int b = 20;</span><br><span class="line">int *p=nullptr;</span><br><span class="line">p=&amp;a;</span><br><span class="line">cout &lt;&lt;*p &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h1 id="const修饰指针"><a href="#const修饰指针" class="headerlink" title="const修饰指针"></a>const修饰指针</h1><p>理解一个<strong>指针常量</strong>的地址是固定的不能更改（int * const p;），但是该地址里面的值是可以更改的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int * const p=&amp;a;</span><br><span class="line">*p=100;//正确的</span><br><span class="line">p=&amp;b;//错误的</span><br></pre></td></tr></table></figure>

<p><strong>常量指针</strong>的地址可变（const int *p;），但是值不能变。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const int *p=&amp;a;</span><br><span class="line">*p=100;//错误的</span><br><span class="line">p=&amp;b;//正确的，可以改变指向来改变值</span><br></pre></td></tr></table></figure>

<p>const即修饰指针,又修饰常量，指针指向和指向的值都不能变(const int * const p;)。</p>
<p>connst是一个c语言的关键字，具有着举足轻重的地位。它限定一个变量不允许被改变，产生静态作用。使用const在一定程度上可以提高程序的安全性和可靠性。</p>
<p>const修饰规律:修饰的是什么，什么不能（通过此变量)改变。</p>
<p>const修饰结构体（如const student *stu）,可以防止误操作修改stu的值。</p>
<p>其实本质上const关键字只是告诉编译器该修饰的变量不可以被修改，并不能改变它修饰的变量在内存中所存放的区域。即const修饰的全局变量还是在全局区，但是修饰局部变量则在局部区。</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">system(&quot;pause&quot;);//按任意键继续</span><br><span class="line">system(&quot;cls&quot;);//清屏</span><br></pre></td></tr></table></figure>

<h1 id="内存分区模型"><a href="#内存分区模型" class="headerlink" title="内存分区模型"></a>内存分区模型</h1><p>代码区:存放函数体的二进制代码，由操作系统进行管理的·全局区:存放全局变量和静态变量以及常量。</p>
<p>栈区:由编译器自动分配释放,存放函数的参数值,局部变量等。</p>
<p>堆区:由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收。</p>
<p>内存四区意义:</p>
<p>不同区域存放的数据，赋予不同的生命周期,给我们更大的灵活编程。</p>
<h2 id="程序运行前"><a href="#程序运行前" class="headerlink" title="程序运行前"></a>程序运行前</h2><p>在程序<strong>编译</strong>后，生成了exe可执行程序，<strong>未执行</strong>该程序前分为两个区域</p>
<p><strong>代码区</strong>:</p>
<p>存放CPU执行的机器指令</p>
<p>代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可代码区是只读的，使其</p>
<p>只读的原因是防止程序意外地修改了它的指令</p>
<p><strong>全局区</strong>:</p>
<p>全局变量和静态变量存放在此.全局区还包含了常量区,字符串常量和其他常量也存放在此.该区域的数据在程序结</p>
<p>后由操作系统释放.</p>
<h2 id="程序运行后"><a href="#程序运行后" class="headerlink" title="程序运行后"></a>程序运行后</h2><p><strong>栈区</strong>：</p>
<p>由编译器自动分配释放,存放函数的参数值,局部变量等。</p>
<p>注意事项:不要返回局部变量的地址，栈区开辟的数据由编译器自动释放。</p>
<p><strong>堆区：</strong></p>
<p>由程序员分配释放,若程序员不释放,程序结束时由操作系统回收。在C++中主要利用new在堆区开辟内存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//利用new关键字，可以将数据开辟到堆区,new返回的该数据类型的指针。</span><br><span class="line">//指针本质也是局部变量，放在栈上，指针保存的数据是放在堆区。</span><br><span class="line">int *p=new int(10);//堆区存放10，p是地址</span><br><span class="line">int *arr=new int[10];//创建数组，10个连续的地址</span><br><span class="line">delete[] arr;//释放数组要加[]</span><br><span class="line">delete p;//释放内存</span><br></pre></td></tr></table></figure>

<p>不释放动态内存有个专有名词，叫内存泄漏，内存泄漏就是这块数据已经不需要了，但是没有将这块数据清除，</p>
<p>会一直占用内存，这就是内存泄漏。内存数据放硬盘上的操作叫进程的挂起。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//引用基本语法</span><br><span class="line">//数据类型 &amp;别名=原名</span><br><span class="line">int a = 10;</span><br><span class="line">//创建引用</span><br><span class="line">int &amp;b = a;</span><br><span class="line">cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; end1;</span><br><span class="line">cout &lt;&lt; &quot;b = &quot; &lt;&lt; b&lt;&lt; endl;//两个输出一样,即两个指向同一个地址</span><br></pre></td></tr></table></figure>

<h2 id="引用注意事项"><a href="#引用注意事项" class="headerlink" title="引用注意事项"></a>引用注意事项</h2><p>引用必须初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int &amp;b;//错误的</span><br></pre></td></tr></table></figure>

<p>引用在初始化后，不可以改变。即b已经是a的别名，则不能是c的别名。</p>
<h2 id="引用做函数参数"><a href="#引用做函数参数" class="headerlink" title="引用做函数参数"></a>引用做函数参数</h2><p><strong>作用</strong>:函数传参时，可以利用引用的技术让形参修饰实参。</p>
<p><strong>优点</strong>:可以简化指针修改实参</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void swap(&amp;a,&amp;b)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">swap(a,b);//引用传递，形参会修饰实参的,在传递时就已经初始化了，即&amp;a=a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单。</p>
<h2 id="引用做函数的返回值"><a href="#引用做函数的返回值" class="headerlink" title="引用做函数的返回值"></a>引用做函数的返回值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//1、不要返回局部变量的引用</span><br><span class="line">int&amp; test01()</span><br><span class="line">&#123;</span><br><span class="line">int a = 10;//局部变量存放在四区中的栈区</span><br><span class="line">return a;//返回的是int&amp;类型</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//2、函数的调用可以作为左值,即在main函数可以这样写test02()=1000；则ref输出也会变1000</span><br><span class="line">//返回静态变量引用</span><br><span class="line">int&amp; test02()</span><br><span class="line">&#123;</span><br><span class="line">static int a = 20;//此时可以输出正确，因为static</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int &amp;ref = test01();//接受的也需要int&amp;类型,&amp;ref是a的别名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;&quot;ref=&quot;&lt;&lt;ref&lt;&lt;endl;//第一次结果正确，是因为编译器做了保留，局部变量的返回也是如此</span><br><span class="line">Cout&lt;&lt;“ref=“&lt;&lt;ref&lt;&lt;endl;//第二次结果错误，因为a的内存已经释放</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h2><p>引用相当于指针常量，指向的值能改但指向不能改（即指向地址不变）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int&amp; ref=a;//自动转换为int * const ref=&amp;a;</span><br><span class="line">ref=20;//内部发现ref是引用，自动转换为：*ref =20;</span><br></pre></td></tr></table></figure>

<p>指针常量是不能拿函数当左值的,所以引用不仅仅是懒人版指针。</p>
<p>引用的地址和原变量是一样的，指针和原变量的地址不一样。所以引用更省空间。</p>
<p>结论:C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了。 </p>
<h2 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//引用通常修饰形参（val）</span><br><span class="line">void showValue(const int &amp;val)&#123;</span><br><span class="line">	//val=1000;//const防止误操作，相当于这个函教是传入了一个常量指针常量。既不能修改值，又不能修改指向，如果没有const，val修改则main函数的a值也会改变,相当于前面地址传递。</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	//int&amp; ref = 10;引用本身需要一个合法的内存空间，因此这行错误</span><br><span class="line">	const int&amp; ref - 10;//加入const就可以了，编译器会优化这行代码为int temp = 10; const int&amp; ref = temp;temp是临时变量</span><br><span class="line">	int a=100;</span><br><span class="line">	showValue(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/29/%E7%AC%AC%E4%B8%80%E5%A4%A9-c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/29/%E7%AC%AC%E4%B8%80%E5%A4%A9-c/" class="post-title-link" itemprop="url">第一天 c++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-29 11:21:09" itemprop="dateCreated datePublished" datetime="2023-03-29T11:21:09+08:00">2023-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-30 16:14:57" itemprop="dateModified" datetime="2023-03-30T16:14:57+08:00">2023-03-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="函数的分文件编写"><a href="#函数的分文件编写" class="headerlink" title="函数的分文件编写"></a>函数的分文件编写</h1><p>1、创建后缀名为.h的头文件<br>2、创建后缀名为.cpp的源文件<br>3、在头文件中写函数声明<br>4、在源文件中写函数的定义</p>
<p>示例：（求最大值）<br>1、创建后缀名为.h的头文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//max.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//3、函数声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br></pre></td></tr></table></figure>

<p>2、创建后缀名为.cpp的源文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//max.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;max.h&quot;</span><span class="comment">//&quot; &quot;表示是我们自己定义的头文件</span></span></span><br><span class="line"><span class="comment">//4、函数的定义</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;<span class="comment">//三目运算符，返回最大值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>max.cpp</code>中包含我们自己定义的头文件<code>&quot;max.h&quot;</code>说明其与<code>&quot;max.h&quot;</code>是配套的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;max.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	max(a, b);</span><br><span class="line"> 	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>main函数中也只需要引用我们自己定义的<code>&quot;max.h&quot;</code>即可<br>就不用再写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>

<p>因为其已在<code>&quot;max.h&quot;</code>头文件中包含了</p>
<p>最后在注意一点，一个项目中只能有一个main函数！！！</p>
<hr>
<p>总结：</p>
<ol>
<li>创建后缀名为.h的头文件，在头文件中写函数的声明，也就是我们自己封装好的函数的各个函数名。</li>
<li>创建后缀名为.cpp的源文件，在源文件中写函数的定义，也就是在源文件中封装代表各个功能的函数，方便调用。</li>
<li>创建主函数（main)文件，调用我们想用的各个封装函数，实现功能。</li>
</ol>
<p>在终端运行mingw(按tab补全)，得到结果，注意，千万不要用右上角的run code执行！</p>
<p>再用<img src="C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20230329213057548.png" alt="image-20230329213057548"></p>
<p>如果运行后显示中文乱码可以试试下面的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span><span class="comment">//用于函数SetConsoleOutputCP(65001);更改cmd编码为utf8</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">SetConsoleOutputCP</span>(<span class="number">65001</span>);</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;中文正常显示&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次如此运行后需要更改代码需要重新此步骤</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">肖汇林</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">肖汇林</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
