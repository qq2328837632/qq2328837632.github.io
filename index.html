<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="选择有时候比努力更重要">
<meta property="og:type" content="website">
<meta property="og:title" content="肖汇林的博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="肖汇林的博客">
<meta property="og:description" content="选择有时候比努力更重要">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="肖汇林">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>肖汇林的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖汇林的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">深入理解计算机系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-05 16:12:22" itemprop="dateCreated datePublished" datetime="2023-05-05T16:12:22+08:00">2023-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-11 17:40:00" itemprop="dateModified" datetime="2023-05-11T17:40:00+08:00">2023-05-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第2章-信息的表示和处理"><a href="#第2章-信息的表示和处理" class="headerlink" title="第2章 信息的表示和处理"></a>第2章 信息的表示和处理</h1><h4 id="文字编码的Unicode标准"><a href="#文字编码的Unicode标准" class="headerlink" title="文字编码的Unicode标准"></a>文字编码的Unicode标准</h4><p>基本编码，称为Unicode的“统一字符集”，使用32位来表示字符。这好像要求文本串中每个字符要占用4个字节。不过，可以有一些替代编码，常见的字符只需要1个或2个字节，而不太常用的字符需要多一些的字节数。特别地，UTF-8表示将每个字符编码为一个字节序列，<strong>这样标准ASCII字符还是使用和它们在ASCII 中一样的单字节编码</strong>，这也就意味着所有的ASCII字节序列用ASCII码表示和用UTF-8表示是一样的。</p>
<p>Java编程语言使用Unicode来表示字符串。对于C语言也有支持 Unicode的程序库。</p>
<p>在使用ASCII码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关。因而，<strong>文本数据比二进制数据具有更强的平台独立性</strong>。</p>
<p>不同的机器类型使用不同的且不兼容的指令和编码方式。即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。</p>
<h2 id="c语言的移位运算"><a href="#c语言的移位运算" class="headerlink" title="c语言的移位运算"></a>c语言的移位运算</h2><p>C语言标准并没有明确定义对于有符号数应该使用哪种类型的右移–算术右移或者<strong>逻辑右移</strong>（不管符号均补0）都可以。不幸地，这就意味着任何假设一种或者另一种右移形式的代码都可能会遇到可移植性问题。然而，实际上，几乎所有的编译器&#x2F;机器组合都对有符号数使用<strong>算术右移</strong>（有符号时最高位是1补1），且许多程序员也都假设机器会使用这种右移。另一方面，对于无符号数，右移必须是逻辑的。<br>与C相比，Java对于如何进行右移有明确的定义。表达是x&gt;&gt;k会将x算术右移k个位置，而x&gt;&gt;&gt;k会对x做逻辑右移。</p>
<h3 id="移动k-位，这里k-很大"><a href="#移动k-位，这里k-很大" class="headerlink" title="移动k 位，这里k 很大"></a>移动k 位，这里k 很大</h3><p>对于一个由w位组成的数据类型，如果要移动k≥w位会得到什么结果呢?例如，计算下面的表达式会得到什么结果，假设数据类型int为w&#x3D;32:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">intlval =OxFEDCBA98&lt;&lt; 32;</span><br><span class="line">intaval =OxFEDCBA98&gt;&gt;36;</span><br><span class="line">unsigned uval =OxFEDCBA98u &gt;&gt;40;</span><br></pre></td></tr></table></figure>

<p>C语言标准很小心地规避了说明在这种情况下该如何做。在许多机器上，当移动一个w位的值时，移位指令只考虑位移量的低 log2 w位，因此实际上位移量就是通过计算k mod w得到的。例如，当w&#x3D;32时，上面三个移位运算分别是移动0、4和8位，得到结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lval 0xFEDCBA98</span><br><span class="line">aval 0xFFEDCBA9</span><br><span class="line">uval 0x00FEDCBA</span><br></pre></td></tr></table></figure>

<p>不过这种行为对于C程序来说是没有保证的，所以应该保持位移量小于待移位值的位数。另一方面，Java 特别要求位移数量应该按照我们前面所讲的求模的方法来计算。</p>
<h2 id="补码编码"><a href="#补码编码" class="headerlink" title="补码编码"></a>补码编码</h2><p>采用补码表示的32位大端法机器（符合习惯，先输出低地址的高位）上输出打印16进制时：是看补码来转换。</p>
<p>原理:补码编码的定义<br><img src="C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20230507151108343.png" alt="image-20230507151108343"></p>
<p>例如1001（-1）的补码是1111可以根据上面计算-8+7&#x3D;-1</p>
<p><strong>负数的补码，是能够和其相反数相加通过溢出从而使计算机内计算结果变为0的二进制码</strong>。这是补码设计的初衷，具体目标就是让1+（-1）&#x3D;0，这利用原码是无法得到的</p>
<p>对于大多数C语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是:数值可能会改变，但是<strong>位模式不变</strong>。</p>
<p>无符号表示中的UMax竟有着和补码表示的-1相同的位模式。我们在这两个数之间也能看到这种关系<br>$$<br>:1+UMax_w&#x3D;2^w<br>$$<br>原理:补码转换为无符号数<br>对满足TMin_x≤x≤TMax_w的x有:<br>$$<br>T2U_w(x)&#x3D;\begin{cases} x+2^w,x&lt;0\ x,x&gt;&#x3D;0\end{cases}<br>$$<br>一个无符号数u和与之对应的有符号数U2T_w(u)之间的关系:</p>
<p>原理:无符号数转换为补码</p>
<p>对满足0≤u≤UMax _w的u有:<br>$$<br>U2T_w(u)&#x3D;\begin{cases} u-2^w,u&gt;TMax_w\ u,x&lt;&#x3D;TMax_w\end{cases}<br>$$<br>总结一下，我们考虑无符号与补码表示之间互相转换的结果。对于在范围0≤T&lt;TMax_w之内的值x而言，我们得到T2U_w(x)&#x3D;x和U2T_w(x)&#x3D;x。也就是说，在这个范围内的数字有相同的无符号和补码表示。对于这个范围以外的数值，转换需要加上或者减去2^w。例如，我们有<br>$$<br>T2U_w(-1)&#x3D;-1+2^w&#x3D;UMax_w<br>$$<br>—-最靠近0的负数映射为最大的无符号数</p>
<h2 id="c语言里面TMin不能写成-2147483648的原因"><a href="#c语言里面TMin不能写成-2147483648的原因" class="headerlink" title="c语言里面TMin不能写成-2147483648的原因"></a>c语言里面TMin不能写成-2147483648的原因</h2><p>C语言中，将TMin（32位有符号整数的最小值）写成 <strong>-2147483647-1</strong>，而不是简单地写成 -2147483648 或 0x80000000 。</p>
<p>可见如果不发生溢出，整型常量的值总是非负数。如果前面<strong>出现符号</strong>，则是对整型常量使用的一元运算符，而不是整型常量的一部分。</p>
<p>如果将TMin32写成-2147483648并且将代码在一个32位的机器上面编译，当编译器遇到**-X<strong>形式的数值，它首先会确定</strong>X<strong>的数据类型和值，然后取</strong>X**的。</p>
<p>由于-2147483648超过了int所能够表示的范围，编译器就会再次选择一种可以正确的表示此值的类型。然后它就会按照第一个表格（十进制）的顺序往下继续尝试类型，再假设编译器采用的标准是ISO C90，int-&gt;long-&gt;unsigned，然后就发现unsigned是第一个合适的数据类型。正如我们知道的，2147483648和-2147483648在32位数值上拥有同样的位表示，使得此常量的最终数据类型是unsigned且值为2147483648。这对于16进制的0x80000000也是相同的结果。</p>
<p>用一句话来解释C语言中TMin32的古怪写法的原因：虽然-2147483648 这个数值能够用int类型(4字节)来表示，但在C语言中却没法写出对应这个数值的int类型常量。</p>
<h2 id="补码的非"><a href="#补码的非" class="headerlink" title="补码的非"></a>补码的非</h2><p>原理:补码的非<br>对满足TMin_w≤x≤TMax_w 的x，其补码的非-^t_wx由下式给出<br>$$<br>-^t_wx&#x3D;\begin{cases}TMin_w,x&#x3D;TMin_w\-x,x&gt;TMin_w\end{cases}<br>$$<br>此处设w&#x3D;4，用补码可表示的范围就是[-8,7]，对于-8，它的“补码的非”还是-8,而[-7,7]补码的非就是原数的负数，比如说-4的“补码的非”是-4取负，即：4，而3的“补码的非”是3取负，即：-3。这是“补码的非”的定义；注意：“补码的非”并不是把“一个数的补码按位取非”</p>
<p>TMin_w&#x3D;-2^w-1</p>
<p>执行位级补码非的第一种方法是对每一位求反，再对结果加1。在C语言中，我们可以说，对于任意整数值x，计算表达式-x和~x+1得到的结果完全一样。</p>
<h2 id="对TMin-w-x3D-2-w-1的解释"><a href="#对TMin-w-x3D-2-w-1的解释" class="headerlink" title="对TMin_w&#x3D;-2^w-1的解释"></a>对TMin_w&#x3D;-2^w-1的解释</h2><p>如w&#x3D;4的-8&#x3D;1000，可以参考-2为例</p>
<p>[-2]原 &#x3D; 1 0010    [-2]补 &#x3D; 11110</p>
<p>如我所说，没有符号位，那么11110就是30，也就是说 -2的补码是30（%2^5）</p>
<h2 id="补码移位"><a href="#补码移位" class="headerlink" title="补码移位"></a>补码移位</h2><p>移位也是运算，需要将负数的原码变成补码移位</p>
<p>对无符号运算使用移位是非常简单的，部分原因是由于无符号数的右移一定是逻辑右移（不管最高位符号）。对于x大于等于0的有符号一样逻辑右移。</p>
<p>负数在执行算术右移之前加上一个适当的偏置量是可以导致结果正确舍入的。</p>
<p>补码除以2的幂(<strong>右移之前加上一个偏量</strong>，结果就向零舍入了).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int optarith(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    int t = x;</span><br><span class="line">    x &lt;&lt;= 5;</span><br><span class="line">    x -= t;</span><br><span class="line">    if (y &lt; 0)</span><br><span class="line">        y += 7;//加上一个适当的偏置量111,是为了正确右移3位，若右移4位，则加15（1111）</span><br><span class="line">    y &gt;&gt;= 3; /* Arithmetic shift */</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IEEE浮点标准"><a href="#IEEE浮点标准" class="headerlink" title="IEEE浮点标准"></a>IEEE浮点标准</h2><p>IEEE浮点标准用<br>$$<br>V&#x3D;（-1）^s<em>M</em>2^E<br>$$<br> 的形式来表示一个数，符号s，尾数M，阶码E</p>
<p>C语言中，单精度（float）的s为1b，E为8b，M为23b，双精度（double）的s为1b，E为11b，M为52b。</p>
<p>阶码的值<strong>E&#x3D;e-Bias</strong>，e是无符号数，Bias为偏置值，等于 2^(k-1)−1 (float为127，double为1023)</p>
<h3 id="计算-IEEE-754-标准浮点数的真值"><a href="#计算-IEEE-754-标准浮点数的真值" class="headerlink" title="计算 IEEE 754 标准浮点数的真值"></a>计算 IEEE 754 标准浮点数的真值</h3><p>在上述内容的分析之后，再通过观察分析以下这个 IEEE 754 单精度浮点数格式表示的数，系统性了解如何计算出 IEEE 754 标准浮点数的真值：</p>
<p>1 100 0000 1010 0000 0000 0000 0000 0000<br>上数分别对应图1-1的中 S（符号码，0 正，1 负），E (阶码) ，M (尾数数值)为：</p>
<p>S (红色部分) ：1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1，表示这个浮点数是个负数；</span><br></pre></td></tr></table></figure>

<p>E (蓝色部分) ：100 0000 1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100 0000 1，阶码，其真值为 ：移码 - 偏置值 =&gt; 1000 0001 - 0111 1111 = 0000 0010 = 2D；（对应下面的2^2D）</span><br></pre></td></tr></table></figure>

<p>M (黑色部分) ：010 0000 0000 0000 0000 0000</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">010 0000 0000 0000 0000 0000 表示这个浮点数的尾数部分，其真值为：被隐含的最高位1 + 0.尾数部分 =&gt; 1 + 0.01 = 1.01B;</span><br></pre></td></tr></table></figure>

<p>通过对 S，E，M 的分析，我们可以计算出该浮点数的真值，即：</p>
<p>-1.01B * 2^10B &#x3D; 1.25D （-1.01B）* 2^2D &#x3D; -5.0D</p>
<hr>
<p>十进制数12345具有二进制[0011 0000 0011 1001]（0x3039），通过将二进制小数点左移13位，得到这个数的一个规格化表示 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12345=1.1000000111001_2×2^13 </span><br></pre></td></tr></table></figure>

<p>，为了使用IEEE单精度（float）形式来编码，我们丢弃开头的1，并且在末尾增加10个0（单精度的尾数位23位，13+10&#x3D;23），来构造小数字段，得到二进制[1000000111001<em>0000000000</em>]，为了得到阶码字段，将13加上偏置量127，得到140，二进制表示为[10001100]，加上符号位0，得到12345.0的二进制浮点数[0100 0110 0100 0000 1110 0100 0000 0000]（0x4640E400），比较整数12345（0x3039）和浮点数12345.0（0x4640E400）的位级表示：</p>
<p>（0x00003039）0000000000000000001<em><strong>1000000111001</strong></em></p>
<p>（0x4640E400）010001100<em><strong>1000000111001</strong></em>0000000000</p>
<p>阶码的值E&#x3D;e-Bias,产生指数的取值范围，对于单精度是一126～＋127，而对于双精度是一1022~+1023。</p>
<h3 id="十进制数转为-IEEE-754-浮点数格式"><a href="#十进制数转为-IEEE-754-浮点数格式" class="headerlink" title="十进制数转为 IEEE 754 浮点数格式"></a>十进制数转为 IEEE 754 浮点数格式</h3><p>同样地再用一个例子 十进制数转为 IEEE 754 浮点数的例子，加深对 十进制数 与 IEEE 754 浮点数之间的转换的理解。</p>
<p> 例如：将十进制数 -0.75 转为 IEEE 754 的单精度浮点数格式表示，分析过程如下：</p>
<p>过程A： -0.75D &#x3D; -0.11B &#x3D; -1.1B * 2^(-1B)<br>S：1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-0.75 为负数，故 S 符号码为 1</span><br></pre></td></tr></table></figure>

<p>E：0111 1110</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由 过程A 得，阶码的真值为 -0000 0001(因为是2^(-1B)，与上面例子一致) ，其移码为：-0000 0001 + 0111 1111 = 0111 1110</span><br></pre></td></tr></table></figure>

<p>M：100 0000 0000 0000 0000 0000</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由 过程A 得，尾数码真值为：-1.1，隐含最高位 1 ，取小数部分，得100 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>

<p>最终结果为：</p>
<p>1 011 1111 0100 0000 0000 0000 0000 0000</p>
<h2 id="向偶数舍人在大多数现实情况中避免了这种统计偏差。"><a href="#向偶数舍人在大多数现实情况中避免了这种统计偏差。" class="headerlink" title="向偶数舍人在大多数现实情况中避免了这种统计偏差。"></a><strong>向偶数舍人在大多数现实情况中避免了这种统计偏差</strong>。</h2><p>在50%的时间里，它将向上舍人，而在50%的时间里，它将向下舍入。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/24/c-%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/24/c-%E7%B1%BB/" class="post-title-link" itemprop="url">c++类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-24 09:39:59 / 修改时间：15:12:34" itemprop="dateCreated datePublished" datetime="2023-04-24T09:39:59+08:00">2023-04-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>C++要求对一般的内置函数要用关键字inline声明，但对类内定义的成员函数，可以省略inline，因为<strong>这些成员函数已经被隐含地指定为内置函数了</strong>。</p>
<p>类的隐式内联和显式内联：</p>
<ul>
<li>类内部的内联函数：类内部只要定义在函数其实都是默认inline的（即通常我们说的尽量不要往.h中类定义的地方直接定义函数，最好只是做一个申明，这个说法其实不太好，因为这会破坏隐藏内联的功能）。</li>
<li>虽然说即便是隐藏的内联，也不一定是内联的，最后还是编译器决定，但是定义在.cpp中的内容，等于是放弃了内联功能，这种可能性降低的写法其实是不推荐的。</li>
<li>另外，也可以用inline放在开头，进行显式的内联，但是仍然需要注意：类内部成员函数的申明和最终的成员函数的定义（可以放在类定义的外部，但是还是要在同一个.h中，否则inline不会生效）。所以，从这个角度看，基本上可以引出一条规定：一些简单的函数、构造函数、析构函数，推荐在类内部进行直接定义，这样能够用到inline功能，对于性能来说更加有利的。至于可读性方面的考虑，完全可以加一些范围的注释、分类，将需要inline的定义在一撮，另外需要在cpp中实现的“复杂”函数，申明在另外一撮。</li>
</ul>
<h2 id="C-中常量成员函数"><a href="#C-中常量成员函数" class="headerlink" title="C++中常量成员函数"></a>C++中常量成员函数</h2><p>可以将C++中类的成员函数声明为常量，这种成员函数叫做常量成员函数（const member function）。</p>
<h3 id="1-声明"><a href="#1-声明" class="headerlink" title="1 声明"></a>1 声明</h3><p>将const关键字放在类成员函数的参数列表之后，表示该函数为常量成员函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class MyClass</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">int consFunc() const;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">int m_MyNum;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-定义"><a href="#2-定义" class="headerlink" title="2 定义"></a>2 定义</h3><p>可以在类内定义consFunc()函数，也可以在类外定义。不管是在类内还是类外定义该函数，都要使用关键字const。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int MyClass::consFunc() const</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">return this-&gt;m_MyNum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-含义"><a href="#3-含义" class="headerlink" title="3 含义"></a>3 含义</h3><p>在“2定义”中定义的consFunc()函数中，如果不添加const关键字，此时constFunc()是普通的成员函数，此时this的类型是MyClass* const，即this本身是常量，但是其指向的类型是非常量。这就意味着我们不能把this绑定到一个常量对象上。如果要把this绑定到一个常量对象上，必须要把this定义成const MyClass* const，即指向常量的常量。在类成员函数的参数列表之后添加const关键字，就相当于把this定义成const MyClass* const。</p>
<h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4 注意事项"></a>4 注意事项</h3><h4 id="4-1-常量对象必须调用常量成员函数"><a href="#4-1-常量对象必须调用常量成员函数" class="headerlink" title="4.1 常量对象必须调用常量成员函数"></a>4.1 常量对象必须调用常量成员函数</h4><p>正如“3 含义”中提到的，如果通过常量对象调用类的成员函数，该成员函数必须是常量成员函数。</p>
<h4 id="4-2-非常量对象可以调用常量成员函数"><a href="#4-2-非常量对象可以调用常量成员函数" class="headerlink" title="4.2 非常量对象可以调用常量成员函数"></a>4.2 非常量对象可以调用常量成员函数</h4><p>因为可以将一个非常量赋值给常量，所以非常量对象可以调用常量成员函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass myclass;</span><br><span class="line"></span><br><span class="line">myclass.consFunc();</span><br></pre></td></tr></table></figure>



<h4 id="4-3-常量成员函数中不能修改成员变量"><a href="#4-3-常量成员函数中不能修改成员变量" class="headerlink" title="4.3 常量成员函数中不能修改成员变量"></a>4.3 常量成员函数中不能修改成员变量</h4><p>因为常量成员函数中的this类型是const MyClass* const，所以不能通过this来修改成员变量。</p>
<p>如果consFunc()函数的定义改为如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int MyClass::consFunc() const</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">return this-&gt;m_MyNum++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则此时程序会报错，error C3490: 由于正在通过常量对象访问“m_MyNum”，因此无法对其进行修改。</p>
<hr>
<p>编译器分两步处理类:首先编译成员的声明，然后才轮到成员函数体（如果有的话)。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/23/linux%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/23/linux%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">linux基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-23 14:32:54" itemprop="dateCreated datePublished" datetime="2023-04-23T14:32:54+08:00">2023-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-09 22:02:23" itemprop="dateModified" datetime="2023-05-09T22:02:23+08:00">2023-05-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Linux的目录结构"><a href="#Linux的目录结构" class="headerlink" title="Linux的目录结构"></a>Linux的目录结构</h1><p>是一个树型结构<br>Windows系统可以拥有多个盘符,如C盘、D盘、E盘<br>Linux没有盘符这个概念,只有一个根目录&#x2F;，所有文件都在它下面</p>
<p>在Linux系统中，路径之间的层级关系，使用:&#x2F;来表示</p>
<p>在Windows系统中，路径之间的层级关系，使用:\来表示</p>
<p>D:\data\work\hello.txt<br>注意:<br>D:表示D盘 ,\表示层级关系</p>
<p>&#x2F;usr&#x2F;local&#x2F;hello.txt<br>注意:<br>开头的&#x2F;表示根目录,后面的&#x2F;表示层级关系</p>
<h2 id="ctrl-l清屏"><a href="#ctrl-l清屏" class="headerlink" title="ctrl+l清屏"></a>ctrl+l清屏</h2><h2 id="crtl-c中断"><a href="#crtl-c中断" class="headerlink" title="crtl+c中断"></a>crtl+c中断</h2><h2 id="crtl-d退出或登出"><a href="#crtl-d退出或登出" class="headerlink" title="crtl+d退出或登出"></a>crtl+d退出或登出</h2><ul>
<li>可以通过快捷键:ctrl + d,退出账户的登录</li>
<li>或者退出某些特定程序的专属页面，比如python</li>
</ul>
<h1 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h1><h2 id="Linux命令基础格式"><a href="#Linux命令基础格式" class="headerlink" title="Linux命令基础格式"></a>Linux命令基础格式</h2><p>无论是什么命令，用于什么用途，在Linux中，命令有其通用的格式:</p>
<p>command [-options] [parameter]</p>
<ul>
<li>command:命令本身</li>
<li>-options:[可选,非必填]命令的一些<strong>选项</strong>,可以通过选项控制命令的行为细节 </li>
<li>parameter: [可选，非必填]命令的<strong>参数</strong>，多数用于命令的指向目标等</li>
</ul>
<p>语法中的[]表示可选的意思</p>
<h3 id="ls命令的参数的作用"><a href="#ls命令的参数的作用" class="headerlink" title="ls命令的参数的作用"></a>ls命令的参数的作用</h3><ul>
<li>可以指定要查看的文件夹(目录)的内容,如果不给定参数,就查看当前工作目录的内容</li>
</ul>
<h4 id="ls命令的选项"><a href="#ls命令的选项" class="headerlink" title="ls命令的选项:"></a>ls命令的选项:</h4><ul>
<li>-a选项,可以展示出隐藏的内容</li>
<li>以.开头的文件或文件夹默认被隐藏，需要-a才能显示出来</li>
<li>-l选项,以列表的形式展示内容，并展示更多细节</li>
<li>-h选项,需要和-l选项搭配使用，以更加人性化的方式显示文件的大小单位</li>
</ul>
<h4 id="命令的选项组合使用"><a href="#命令的选项组合使用" class="headerlink" title="命令的选项组合使用"></a>命令的选项组合使用</h4><ul>
<li>命令的选项是可以组合使用的,比如: ls -lah,等同于ls -a -l -h</li>
</ul>
<h3 id="cd切换工作目录"><a href="#cd切换工作目录" class="headerlink" title="cd切换工作目录"></a>cd切换工作目录</h3><p>当Linux终端（命令行）打开的时候，会默认以用户的HOME目录作为当前的工作目录我们可以通过cd命令，更改当前所在的工作目录。<br>cd命令来自英文:Change Directory<br>语法: <code>cd [Linux路径]</code></p>
<ul>
<li>cd命令无需选项，只有参数，表示要切换到哪个目录下</li>
<li>cd命令直接执行，不写参数，表示回到用户的HOME目录</li>
</ul>
<h3 id="pwd查看当前工作目录"><a href="#pwd查看当前工作目录" class="headerlink" title="pwd查看当前工作目录"></a>pwd查看当前工作目录</h3><p>通过ls来验证当前的工作目录，其实是不恰当的。</p>
<p>我们可以通过pwd命令，来查看当前所在的工作目录。</p>
<p>pwd命令来自:Print Work Directory</p>
<p>语法:pwd</p>
<ul>
<li>pwd命令，无选项，无参数，直接输入pwd即可</li>
</ul>
<h3 id="特殊路径符"><a href="#特殊路径符" class="headerlink" title="特殊路径符:"></a>特殊路径符:</h3><ul>
<li>. 表示当前目录，比如cd .&#x2F;Desktop表示切换到当前目录下的Desktop目录内，和cd Desktop效果一致</li>
<li>.. 表示上一级目录，比如: cd .. 即可切换到上一级目录，cd ..&#x2F; ..切换到上二级的目录</li>
<li>~ 表示HOME目录，比如:cd~ 即可切换到HOME目录或cd ~&#x2F;Desktop,切换到HOME内的Desktop目录</li>
</ul>
<h3 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h3><p>通过mkdir命令可以创建新的目录（文件夹)</p>
<p>mkdir来自英文:Make Directory<br>语法:<code>mkdir [-p] Linux路径</code></p>
<ul>
<li>参数必填，表示Linux路径，即要创建的文件夹路径，相对路径或绝对路径均可</li>
<li>-p选项可选，表示自动创建不存在的父目录，适用于创建连续多层级的目录</li>
</ul>
<p>注意︰创建文件夹需要修改权限，请确保操作均在HOME目录内，不要在HOME外操作涉及到权限问题，HOME外无法成功</p>
<h3 id="touch创建文件"><a href="#touch创建文件" class="headerlink" title="touch创建文件"></a>touch创建文件</h3><p>可以通过touch命令创建文件</p>
<p>语法: <code>touch Linux路径</code></p>
<ul>
<li>touch命令无选项，参数必填，表示要创建的文件路径，相对、绝对、特殊路径符均可以使用</li>
</ul>
<h3 id="cat命令查看文件内容"><a href="#cat命令查看文件内容" class="headerlink" title="cat命令查看文件内容"></a>cat命令查看文件内容</h3><p>准备好文件内容后，可以通过cat查看内容。</p>
<p>语法:<code>cat Linux路径</code></p>
<ul>
<li><p>cat同样没有选项，只有必填参数，参数表示:被查看的文件路径，相对、绝对,</p>
<p>特殊路径符都可以使用</p>
</li>
</ul>
<h3 id="more命令查看文件内容"><a href="#more命令查看文件内容" class="headerlink" title="more命令查看文件内容"></a>more命令查看文件内容</h3><p>more命令同样可以查看文件内容，同cat不同的是:. </p>
<ul>
<li>cat是直接将内容全部显示出来</li>
<li>more支持翻页，如果文件内容过多，可以一页页的展示</li>
</ul>
<p>语法:<code>more Linux路径</code></p>
<ul>
<li>同样没有选项，只有必填参数，参数表示:被查看的文件路径，相对、绝对、特殊路径符都可以使用</li>
</ul>
<p>Linux系统内置有一个文件，路径为:&#x2F;etc&#x2F;services，可以使用more命令查看<br>more &#x2F;etc&#x2F;services</p>
<ul>
<li>在查看的过程中，通过空格翻页。</li>
<li>通过q退出查看</li>
</ul>
<h3 id="cp命令复制文件文件夹"><a href="#cp命令复制文件文件夹" class="headerlink" title="cp命令复制文件文件夹"></a>cp命令复制文件文件夹</h3><p>cp命令可以用于复制文件&#x2F;文件夹，cp命令来自英文单词: copy</p>
<p>语法: cp [-r] 参数1参数2</p>
<ul>
<li>-r选项，可选，用于复制文件夹使用，表示递归。</li>
<li>参数1,Linux路径，表示被复制的文件或文件夹。</li>
<li>参数2，Linux路径，表示要复制去的地方</li>
</ul>
<h3 id="mv移动文件或文件夹"><a href="#mv移动文件或文件夹" class="headerlink" title="mv移动文件或文件夹"></a>mv移动文件或文件夹</h3><p>mv命令可以用于移动文件\文件夹，mv命令来自英文单词:move</p>
<p>语法:<code>mv参数1参数2</code></p>
<ul>
<li>参数1,Linux路径，表示被移动的文件或文件夹</li>
<li>参数2，Linux路径，表示要移动去的地方，如果目标不存在，则进行改名，确保目标存在</li>
</ul>
<h3 id="rm删除文件、文件夹"><a href="#rm删除文件、文件夹" class="headerlink" title="rm删除文件、文件夹"></a>rm删除文件、文件夹</h3><p>rm命令可用于删除文件、文件夹</p>
<p>rm命令来自英文单词:remove</p>
<p>语法: <code>rm [-r -f] 参数1参数2 ......参数N</code></p>
<ul>
<li>同cp命令一样，-r选项用于删除文件夹</li>
<li>-f表示force，强制删除（不会弹出提示确认信息)<ul>
<li>普通用户删除内容不会弹出提示，只有root管理员用户删除内容会有提示</li>
<li>所以一般普通用户用不到-f选项</li>
</ul>
</li>
<li>参数1、参数2、…….、参数N表示要删除的文件或文件夹路径，按照空格隔开</li>
</ul>
<p>rm命令支持通配符 * ，用来做模糊匹配</p>
<ul>
<li><p>符号 * 表示通配符，即匹配任意内容（包含空)，示例:.</p>
</li>
<li><p>test*，表示匹配任何以test开头的内容</p>
</li>
<li><p>*test，表示匹配任何以test结尾的内容 </p>
</li>
<li><p>*test *，表示匹配任何包含test的内容</p>
</li>
<li><p>演示强制删除，-f选项</p>
</li>
<li><p>可以通过 su - root，并输入密码123456（和普通用户默认一样）临时切换到root用户体验</p>
</li>
<li><p>通过输入exit命令，退回普通用户,也可以回退到root用户。也可以使用ctrl+d</p>
</li>
</ul>
<h3 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h3><p>我们在前面学习的Linux命令，其实它们的本体就是一个个的二进制可执行程序。和Windows系统中的.exe文件，是一个意思。</p>
<p>我们可以通过which命令，查看所使用的一系列<strong>命令</strong>的程序文件存放在哪里</p>
<p>语法: <code>which 要查找的命令</code></p>
<h3 id="find命令–按文件名查找文件"><a href="#find命令–按文件名查找文件" class="headerlink" title="find命令–按文件名查找文件"></a>find命令–按文件名查找文件</h3><p>同样，在Linux系统中，我们可以通过find命令去搜索指定的文件。</p>
<p>语法:<code>find 起始路径 -name  &quot;被查找文件名&quot;</code></p>
<p>被查找文件名，支持使用通配符*来做模糊查询。</p>
<h3 id="find命令-按文件大小查找文件"><a href="#find命令-按文件大小查找文件" class="headerlink" title="find命令-按文件大小查找文件"></a>find命令-按文件大小查找文件</h3><p>语法: <code>find 起始路径 -size  +/-n[kMG]</code></p>
<ul>
<li>+、-表示大于和小于</li>
<li>n表示大小数字</li>
<li>kMG表示大小单位，k(小写字母)表示kb，M表示MB，G表示GB</li>
</ul>
<p>示例:</p>
<ul>
<li>查找小于10KB的文件: find  &#x2F; -size  -10k</li>
<li>查找大于100MB的文件: find &#x2F; -size +100M</li>
<li>查找大于1GB的文件: find &#x2F; -size +1G</li>
</ul>
<h3 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h3><p>可以通过grep命令，从文件中通过关键字过滤<strong>文件行</strong>。</p>
<p>语法: <code>grep [-n] 关键字文件路径</code></p>
<ul>
<li>选项-n，可选，表示在结果中显示匹配的行的行号。</li>
<li>参数，关键字，必填，表示过滤的关键字，带有空格或其它特殊符号，建议使用” ”将关键字包围起来。</li>
<li>参数，文件路径，必填，表示要过滤内容的文件路径，可作为内容输入端口</li>
</ul>
<h3 id="wc命令做数量统计"><a href="#wc命令做数量统计" class="headerlink" title="wc命令做数量统计"></a>wc命令做数量统计</h3><p>可以通过wc命令统计文件的行数、单词数量等</p>
<p>语法: <code>wc [-c -m -l -w] 文件路径</code></p>
<ul>
<li>选项，-c，统计bytes数量。</li>
<li>选项，-m，统计字符数量</li>
<li>选项，-l，统计行数</li>
<li>选项，-w，统计单词数量</li>
<li>参数，文件路径，被统计的文件，可作为内容输入端口</li>
</ul>
<h3 id="管道符"><a href="#管道符" class="headerlink" title="管道符"></a>管道符</h3><p>管道符:l<br>管道符的含义是:将管道符左边命令的结果，作为右边命令的输入</p>
<ul>
<li>cat itheima.txt的输出结果（文件内容)。</li>
<li>作为右边grep命令的输入（被过滤文件)</li>
</ul>
<p><code>cat itheima.txt | grep itheima</code>还可以嵌套</p>
<h3 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h3><p>可以使用echo命令在命令行内输出指定内容</p>
<p>语法:<code>echo 输出的内容</code></p>
<ul>
<li><p>无需选项，只有一个参数，表示要输出的内容，复杂内容可以用” ”包围</p>
</li>
<li><p>带有空格或\等特殊符号，建议使用双引号包围</p>
</li>
<li><p>因为不包围的话，空格后很容易被识别为参数2，尽管echo不受影响，但是要养成习惯哦</p>
</li>
</ul>
<h3 id="反引号-96"><a href="#反引号-96" class="headerlink" title="反引号&#96;"></a>反引号&#96;</h3><p>本意是想，输出当前的工作路径，但是pwd被作为普通字符输出了。<br>我们可以通过将命令用反引号（通常也称之为飘号) &#96; 将其包围<br>被   飘号包围的内容，会被作为命令执行，而非普通字符</p>
<h3 id="重定向符"><a href="#重定向符" class="headerlink" title="重定向符"></a>重定向符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;,将左侧命令的结果，覆盖写入到符号右侧指定的文件中</span><br><span class="line">&gt;&gt;,将左侧命令的结果，追加写入到符号右侧指定的文件中</span><br></pre></td></tr></table></figure>

<h3 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h3><p>使用tail命令，可以查看文件尾部内容，跟踪文件的最新更改，</p>
<p>语法如下:<code>tail [-f -num ] Linux路径</code></p>
<ul>
<li>参数，Linux路径，表示被跟踪的文件路径。</li>
<li>选项，-f，表示持续跟踪</li>
<li>选项，-num，表示，查看尾部多少行，不填默认10行</li>
</ul>
<h3 id="vi-vim编辑器介绍"><a href="#vi-vim编辑器介绍" class="headerlink" title="vi\vim编辑器介绍"></a>vi\vim编辑器介绍</h3><p>vi\vim是visual interface的简称，是Linux中最经典的文本编辑器</p>
<p>同图形化界面中的文本编辑器一样，vi是命令行下对文本文件进行编辑的绝佳选择</p>
<p>vim是vi的加强版本，兼容vi的所有指令，不仅能编辑文本，而且还具有shell程序编辑的功能，可以不同颜色的字体来辨别语法的正确性，极大方便了程序的设计和编辑性。</p>
<h4 id="vi-vim编辑器的三种工作模式"><a href="#vi-vim编辑器的三种工作模式" class="headerlink" title="vi\vim编辑器的三种工作模式"></a>vi\vim编辑器的三种工作模式</h4><p>命令模式(Command mode)，最开始状态</p>
<ul>
<li>命令模式下，所敲的按键编辑器都理解为命令，以命令驱动执行不同的功能，此模型下，不能自由进行文本编辑。输入i o a进入输入模式，退出输入<strong>：wq</strong></li>
</ul>
<p>输入模式(lnsert mode)</p>
<ul>
<li>也就是所谓的编辑模式、插入模式。此模式下，可以对文件内容进行自由编辑。ESC键进入命令模式</li>
</ul>
<p>底线命令模式(Last line mode)</p>
<ul>
<li>以**:**开始，通常用于文件的保存、退出。命令以回车结束运行</li>
</ul>
<ol>
<li>如果文件路径表示的文件不存在，那么此命令会用于编辑新文件</li>
<li>如果文件路径表示的文件存在，那么此命令用于编辑已有文件</li>
</ol>
<table>
<thead>
<tr>
<th>模式</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>命令模式</td>
<td>i</td>
<td>在当前光标位置进入输入模式</td>
</tr>
<tr>
<td>命令模式</td>
<td>a</td>
<td>在当前光标位置之后进入输入模式</td>
</tr>
<tr>
<td>命令模式</td>
<td>I</td>
<td>在当前行的开头，进入输入模式</td>
</tr>
<tr>
<td>命令模式</td>
<td>A</td>
<td>在当前行的结尾，进入输入模式</td>
</tr>
<tr>
<td>命令模式</td>
<td>o</td>
<td>在当前光标下一行进入输入模式</td>
</tr>
<tr>
<td>命令模式</td>
<td>O</td>
<td>在当前光标上一行进入输入模式</td>
</tr>
<tr>
<td>输入模式</td>
<td>esc</td>
<td>任何情况下输入esc都能回到命令模式</td>
</tr>
<tr>
<td>命令模式</td>
<td>0</td>
<td>移动光标到当前行的开头</td>
</tr>
<tr>
<td>命令模式</td>
<td>$</td>
<td>移动光标到当前行的结尾</td>
</tr>
<tr>
<td>命令模式</td>
<td>pageup( Pgup)</td>
<td>向上翻页</td>
</tr>
<tr>
<td>命令模式</td>
<td>pangdown( PgDn)</td>
<td>向下翻页</td>
</tr>
<tr>
<td>命令模式</td>
<td>&#x2F;</td>
<td>进入搜索模式</td>
</tr>
<tr>
<td>命令模式</td>
<td>n</td>
<td>向下继续搜索</td>
</tr>
<tr>
<td>命令模式</td>
<td>N</td>
<td>向上继续搜索</td>
</tr>
<tr>
<td>命令模式</td>
<td>dd</td>
<td>删除光标所在行的内容</td>
</tr>
<tr>
<td>命令模式</td>
<td>ndd</td>
<td>n是数字，表示删除当前光标向下n行</td>
</tr>
<tr>
<td>命令模式</td>
<td>yy</td>
<td>复制当前行</td>
</tr>
<tr>
<td>命令模式</td>
<td>nyy</td>
<td>n是数字，复制当前行和下面的n行</td>
</tr>
<tr>
<td>命令模式</td>
<td>p</td>
<td>粘贴复制的内容</td>
</tr>
<tr>
<td>命令模式</td>
<td>u</td>
<td>撤销修改</td>
</tr>
<tr>
<td>命令模式</td>
<td>crtl+r</td>
<td>反向撤销修改</td>
</tr>
<tr>
<td>命令模式</td>
<td>gg</td>
<td>跳到首行</td>
</tr>
<tr>
<td>命令模式</td>
<td>G</td>
<td>跳到行尾</td>
</tr>
<tr>
<td>命令模式</td>
<td>dG</td>
<td>从当前行开始，向下全部删除</td>
</tr>
<tr>
<td>命令模式</td>
<td>dgg</td>
<td>从当前行开始，向上全部删除</td>
</tr>
<tr>
<td>命令模式</td>
<td>d$</td>
<td>从当前光标开始，删除到本行的结尾</td>
</tr>
<tr>
<td>命令模式</td>
<td>d0</td>
<td>从当前光标开始，删除到本行的开头</td>
</tr>
<tr>
<td>底线命令模式</td>
<td>:wq</td>
<td>保存并退出</td>
</tr>
<tr>
<td>底线命令模式</td>
<td>:q</td>
<td>仅退出</td>
</tr>
<tr>
<td>底线命令模式</td>
<td>:q!</td>
<td>强制退出</td>
</tr>
<tr>
<td>底线命令模式</td>
<td>:w</td>
<td>仅保存</td>
</tr>
<tr>
<td>底线命令模式</td>
<td>:set nu</td>
<td>显示行号</td>
</tr>
<tr>
<td>底线命令模式</td>
<td>:set paste</td>
<td>设置粘贴模式,主要是为了保证外部复制不会格式错乱</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="sudo命令"><a href="#sudo命令" class="headerlink" title="sudo命令"></a>sudo命令</h3><p>Su命令</p>
<ul>
<li>可以切换用户，语法:<code>su [-] [用户名]</code></li>
<li>-表示切换后加载环境变量,建议带上</li>
<li>用户可以省略,省略默认切换到root</li>
</ul>
<p>在我们得知root密码的时候，可以通过su命令切换到root得到最大权限。但是我们不建议长期使用root用户，避免带来系统损坏。</p>
<p>我们可以使用sudo命令，为普通的命令授权,临时以root身份执行。</p>
<p>语法:<code>sudo 其它命令</code></p>
<ul>
<li>在其它命令之前，带上sudo,即可为这一条命令临时赋予root授权</li>
<li>但是并不是所有的用户，都有权利使用sudo，我们需要为普通用户配置sudo认证</li>
</ul>
<h4 id="为普通用户配置sudo认证"><a href="#为普通用户配置sudo认证" class="headerlink" title="为普通用户配置sudo认证"></a>为普通用户配置sudo认证</h4><ul>
<li>切换到root用户,执行visudo命令，会自动通过vi编辑器打开:&#x2F;etc&#x2F;sudoers。</li>
<li>在文件的最后添加:<br><code>itheima ALL=(ALL)		NOPASSWD: ALL</code><br>其中最后的NOPASSWD:ALL表示使用sudo命令，无需输入密码，itheima是用户名</li>
<li>最后通过wq保存</li>
<li>切换回普通用户<br><code>[itheima@localhost ~]$ sudo ls /root</code></li>
<li><code>anaconda-ks.cfg	original-ks.cfg</code></li>
<li><code>[itheima@localhost ~]$ sudo mkdir /test</code></li>
<li><code>[itheima@localhost ~]$</code></li>
<li>执行的命令，均以root运行</li>
</ul>
<h2 id="用户、用户组"><a href="#用户、用户组" class="headerlink" title="用户、用户组"></a>用户、用户组</h2><p>Linux系统中可以:</p>
<ul>
<li>配置多个用户</li>
<li>配置多个用户组</li>
<li>用户可以加入多个用户组中</li>
</ul>
<h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>以下命令需root用户执行。</p>
<ul>
<li><p>创建用户</p>
<p>​	useradd [-g -d]用户名<br>​		选项: -g指定用户的组，不指定-g，会创建同名组并自动加入，指定-g需要组已经存在，如已存在同名组，必须使用-g</p>
<p>​		选项:-d指定用户HOME路径，不指定，HOME目录默认在:&#x2F;home&#x2F;用户名</p>
</li>
<li><p>删除用户</p>
<ul>
<li>​	userdel [-r]用户名<br>​		选项:-r，删除用户的HOME目录，不使用-r，删除用户时，HOME目录保留</li>
</ul>
</li>
<li><p>查看用户所属组</p>
<ul>
<li><p>id[用户名]</p>
<p>​	参数:用户名，被查看的用户，如果不提供则查看自身。</p>
</li>
</ul>
</li>
<li><p>修改用户所属组</p>
<ul>
<li>usermod -aG 用户组 用户名，将指定用户加入指定用户组，一个用户可以在多个用户组。</li>
</ul>
</li>
</ul>
<h3 id="getent"><a href="#getent" class="headerlink" title="getent"></a>getent</h3><p>使用getent命令，可以查看当前系统中有哪些用户</p>
<p>语法: getent passwd</p>
<p>共有7份信息，分别是:<br>用户名:密码(x):用户ID:组ID:描述信息(无用):HOME目录:执行终端(默认bash)</p>
<p>使用getent命令,同样可以查看当前系统中有哪些用户组</p>
<p>语法:getent group</p>
<p>包含3份信息,组名称:组认证(显示为x):组ID</p>
<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>ls -l后</p>
<p>drwxr-xr-x 2 xiaohuilin xiaohuilin 4096 9月  12  2021 公共的</p>
<p>举例: d rwx r-x r-x，表示:</p>
<ul>
<li>这是一个文件夹，首字母d表示( -表示文件 d表示文件夹 I表示软链接)</li>
<li>所属用户（第一个xiaohuilin）对d的权限是:有r有w有x, rwx</li>
<li>所属用户组（第二个xiaohuilin）的权限是:有r无w有x, r-x( -表示无此权限)</li>
<li>其它用户的权限是：有r无w有x,r-x</li>
</ul>
<p>rwx代表什么</p>
<p>r表示读权限</p>
<p>w表示写权限</p>
<p>x表示执行权限</p>
<p>针对文件、文件夹的不同，rwx的含义有细微差别</p>
<ul>
<li>r ,针对文件可以查看文件内容<ul>
<li>针对文件夹，可以查看文件夹内容，如ls命令</li>
</ul>
</li>
<li>w，针对文件表示可以修改此文件<ul>
<li>针对文件夹，可以在文件夹内:创建、删除、改名等操作</li>
</ul>
</li>
<li>x,针对文件表示可以将文件作为程序执行<ul>
<li>针对文件夹，表示可以更改工作目录到此文件夹，即cd进入</li>
</ul>
</li>
</ul>
<h2 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h2><p>我们可以使用chmod命令，修改文件、文件夹的权限信息。</p>
<p>注意，只有文件、文件夹的所属用户或root用户可以修改。</p>
<p>语法: <code>chmod [-R] 权限 文件或文件夹</code></p>
<ul>
<li>选项:-R，对文件夹内的全部内容应用同样的操作</li>
</ul>
<p>示例:</p>
<ul>
<li>chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;x hello.txt，将文件权限修改为:rwxr-x–x<ul>
<li>其中:u表示user所属用户权限, g表示group组权限,o表示other其它用户权限</li>
</ul>
</li>
<li>chmod -R u&#x3D;rwx,g&#x3D;rx,0&#x3D;x test,将文件夹test以及文件夹内全部内容权限设置为:rwxr-x–x</li>
</ul>
<p>除此之外，还有快捷写法: chmod 751 hello.txt<br>将hello.txt的权限修改为751,r记为4, w记为2,x记为1</p>
<h2 id="chown命令"><a href="#chown命令" class="headerlink" title="chown命令"></a>chown命令</h2><p>使用chown命令，可以修改文件、文件夹的所属用户和用户组<br>普通用户无法修改所属为其它用户或组，所以此命令只适用于root用户执行</p>
<p>语法: <code>chown[-R] [用户][:][用户组] 文件或文件夹</code></p>
<ul>
<li>选项，-R，同chmod,对文件夹内全部内容应用相同规则</li>
<li>选项，用户，修改所属用户</li>
<li>选项，用户组,修改所属用户组</li>
<li>:用于分隔用户和用户组</li>
</ul>
<p>示例:</p>
<ul>
<li>chown root hello.txt,将hello.txt所属用户修改为root</li>
<li>chown :root hello.txt,将hello.txt所属用户组修改为root</li>
<li>chown root:itheima hello.txt,将hello.txt所属用户修改为root,用户组修改为itheima</li>
<li>chown -R root test,将文件夹test的所属用户修改为root并对文件夹内全部内容应用同样规则</li>
</ul>
<h2 id="历史命令搜索"><a href="#历史命令搜索" class="headerlink" title="历史命令搜索"></a>历史命令搜索</h2><p><code>history</code></p>
<ul>
<li>可以通过:!命令前缀，自动执行上次匹配前缀的命令</li>
<li>可以通过快捷键:ctrl + r,输入内容去匹配历史命令</li>
</ul>
<p>如果搜索到的内容是你需要的，那么∶</p>
<ul>
<li>回车键可以直接执行</li>
<li>键盘左右键，可以得到此命令（不执行)</li>
</ul>
<h2 id="光标移动快捷键"><a href="#光标移动快捷键" class="headerlink" title="光标移动快捷键"></a>光标移动快捷键</h2><ul>
<li>ctrl+ a,跳到命令开头</li>
<li>ctrl+e,跳到命令结尾</li>
<li>ctrl＋键盘左键,向左跳一个单词</li>
<li>ctrl＋键盘右键,向右跳一个单词</li>
</ul>
<h2 id="清屏"><a href="#清屏" class="headerlink" title="清屏"></a>清屏</h2><ul>
<li><p>通过快捷键ctrl+l，可以清空终端内容</p>
</li>
<li><p>或通过命令clear得到同样效果</p>
</li>
</ul>
<h2 id="systemctl命令"><a href="#systemctl命令" class="headerlink" title="systemctl命令"></a>systemctl命令</h2><p>Linux系统很多软件(内置或第三方)均支持使用systemctl命令控制:启动、停止、开机自启</p>
<p>能够被systemctl管理的软件，一般也称之为:服务</p>
<p>语法: <code>systemctl start | stop | status | enable | disable 服务名</code></p>
<ul>
<li><p>start启动</p>
</li>
<li><p>stop关闭</p>
</li>
<li><p>status查看状态</p>
</li>
<li><p>enable开启开机自启</p>
</li>
<li><p>disable关闭开机自启</p>
</li>
</ul>
<p>系统内置的服务比较多，比如:</p>
<ul>
<li><p>NetworkManager,主网络服务</p>
</li>
<li><p>network,副网络服务</p>
</li>
<li><p>firewalld，防火墙服务</p>
</li>
<li><p>sshd, ssh服务(FinalShell远程登录Linux使用的就是这个服务)</p>
</li>
</ul>
<h2 id="ln命令创建软连接"><a href="#ln命令创建软连接" class="headerlink" title="ln命令创建软连接"></a>ln命令创建软连接</h2><p>在系统中创建软链接,可以将文件、文件夹链接到其它位置。</p>
<p>类似windows系统中的《快捷方式》</p>
<p>语法: <code>ln -s 参数1参数2</code></p>
<ul>
<li>-s选项,创建软连接</li>
<li>参数1:被链接的文件或文件夹</li>
<li>参数2:要链接去的目的地</li>
</ul>
<p>实例:</p>
<ul>
<li>ln -s &#x2F;etc&#x2F;yum.conf ~&#x2F;yum.conf</li>
<li>ln -s &#x2F;etc&#x2F;yum ~&#x2F;yum</li>
</ul>
<h2 id="date命令"><a href="#date命令" class="headerlink" title="date命令"></a>date命令</h2><p>通过date命令可以在命令行中查看系统的时间</p>
<p>语法: <code>date [-d][+格式化字符串]</code></p>
<ul>
<li><p>-d按照给定的字符串显示日期，一般用于日期计算</p>
</li>
<li><p>格式化字符串:通过特定的字符串标记,来控制显示的日期格式</p>
<ul>
<li><p>%Y	年</p>
</li>
<li><p>%y	年份后两位数字(00..99)</p>
</li>
<li><p>%m	月份(01..12)</p>
</li>
<li><p>%d	日(01..31)</p>
</li>
<li><p>%H	小时(00..23)</p>
</li>
<li><p>%M	分钟(00..59)</p>
</li>
<li><p>%S	秒(00..60)</p>
</li>
<li><p>%s	自1970-01-01	00::00::00 UTC到现在的秒数</p>
</li>
</ul>
</li>
</ul>
<h2 id="特殊IP地址"><a href="#特殊IP地址" class="headerlink" title="特殊IP地址"></a>特殊IP地址</h2><ul>
<li>127.0.0.1，这个IP地址用于指代本机</li>
<li>0.0.0.0,特殊lP地址<ul>
<li>可以用于指代本机</li>
<li>可以在端口绑定中用来确定绑定关系（后续讲解)</li>
<li>在一些IP地址限制中，表示所有IP的意思,如放行规则设置为0.0.0.0,表示允许任意IP访问</li>
</ul>
</li>
</ul>
<h2 id="在Linux中修改主机名"><a href="#在Linux中修改主机名" class="headerlink" title="在Linux中修改主机名"></a>在Linux中修改主机名</h2><ul>
<li>可以使用命令:hostname查看主机名</li>
<li>可以使用命令: hostnamectl set-hostname主机名,修改主机名（需root)</li>
</ul>
<p>什么是域名解析（主机名映射)</p>
<ul>
<li>可以通过主机名找到对应计算机的IP地址,这就是主机名映射（域名解析)</li>
<li>先通过系统本地的记录去查找，如果找不到就联网去公开DNS服务器去查找</li>
</ul>
<h2 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h2><p>可以通过ping命令,检查指定的网络服务器是否是可联通状态</p>
<p>语法: <code>ping [-c num] ip或主机名</code></p>
<ul>
<li>选项:-c，检查的次数，不使用-c选项,将无限次数持续检查</li>
<li>参数: ip或主机名，被检查的服务器的ip地址或主机名地址</li>
</ul>
<h2 id="wget命令"><a href="#wget命令" class="headerlink" title="wget命令"></a>wget命令</h2><p>wget是非交互式的文件下载器,可以在命令行内下载网络文件</p>
<p>语法: <code>wget [-b] url</code></p>
<ul>
<li>选项: -b，可选，后台下载,会将日志写入到当前工作目录的wget-log文件</li>
<li>参数: url，下载链接</li>
</ul>
<h2 id="curl命令"><a href="#curl命令" class="headerlink" title="curl命令"></a>curl命令</h2><p>curl可以发送http网络请求,可用于:下载文件、获取信息等</p>
<p>语法: <code>curl [-O] url</code></p>
<ul>
<li>选项:-O，用于下载文件，当url是下载链接时,可以使用此选项保存文件</li>
<li>参数: url，要发起请求的网络地址</li>
</ul>
<h2 id="使用top命令可以"><a href="#使用top命令可以" class="headerlink" title="使用top命令可以:"></a>使用top命令可以:</h2><p>类似Windows任务售理器·查看CPU、内存、进程的信息</p>
<h2 id="使用df命令可以"><a href="#使用df命令可以" class="headerlink" title="使用df命令可以:"></a>使用df命令可以:</h2><p>查看磁盘使用率</p>
<h2 id="使用iostat可以"><a href="#使用iostat可以" class="headerlink" title="使用iostat可以:"></a>使用iostat可以:</h2><p>查看磁盘速率等信息</p>
<h2 id="使用sar-n-DEV命令可以"><a href="#使用sar-n-DEV命令可以" class="headerlink" title="使用sar -n DEV命令可以:"></a>使用sar -n DEV命令可以:</h2><p>查看网络情况</p>
<h2 id="什么是环境变量"><a href="#什么是环境变量" class="headerlink" title="什么是环境变量"></a>什么是环境变量</h2><p>环境变量是一组信息记录,类型是KeyValue型(名称&#x3D;值)，用于操作系统运行的时候记录关键信息</p>
<h2 id="通过env命令可以查看当前系统配置的环境变量信息"><a href="#通过env命令可以查看当前系统配置的环境变量信息" class="headerlink" title="通过env命令可以查看当前系统配置的环境变量信息"></a>通过env命令可以查看当前系统配置的环境变量信息</h2><h2 id="通过-符号，可以取出环境变量的值"><a href="#通过-符号，可以取出环境变量的值" class="headerlink" title="通过$符号，可以取出环境变量的值"></a>通过$符号，可以取出环境变量的值</h2><h2 id="什么是PATH，作用是"><a href="#什么是PATH，作用是" class="headerlink" title="什么是PATH，作用是"></a>什么是PATH，作用是</h2><p>环境变量PATH会记录一组目录，目录之间用**:**隔开。这里记录的是命令的搜索路径，当执行命令会从记录中记录的目录中挨个搜索要执行的命令并执行。<br>可以通过修改这个项目的值,加入自定义的命令搜索路径<br>如<code>export PATH=$PATH:自定义路径</code></p>
<h2 id="如何修改环境变量"><a href="#如何修改环境变量" class="headerlink" title="如何修改环境变量"></a>如何修改环境变量</h2><ul>
<li>临时生效: export名称&#x3D;值</li>
<li>永久生效:<ul>
<li>针对用户:~&#x2F;bashrc文件中配置</li>
<li>针对全部用户:&#x2F;etc&#x2F;profile文件中配置。</li>
<li>配置完成，可以通过source命令立刻生效</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/16/c%E5%92%8Cc++/%E5%85%B3%E4%BA%8Evscode%E5%A6%82%E4%BD%95%E5%AF%B9%E5%A4%9A%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/16/c%E5%92%8Cc++/%E5%85%B3%E4%BA%8Evscode%E5%A6%82%E4%BD%95%E5%AF%B9%E5%A4%9A%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/" class="post-title-link" itemprop="url">关于vscode如何对多文件进行调试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-16 16:48:07 / 修改时间：16:56:34" itemprop="dateCreated datePublished" datetime="2023-04-16T16:48:07+08:00">2023-04-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Vscode默认配置文件只能编译单cpp文件。若是需要多文件编译或者需要分别设置Include头文件夹、Source资源文件夹，则需要修改配置三个.json文件(tasks.json、launch.json、c_cpp_properties.json )</p>
<p>注：个人习惯将.h头文件放到Include目录、.c.cpp源文件放到Source文件夹下面，输出文件.exe文件放到out文件夹下面</p>
<ul>
<li>.vscode文件夹存放.json文件夹，实际使用中可以直接拷贝过来使用，而没必要每次都新建修改一遍</li>
<li>c_cpp_properties.json配置文件默认是不会产生的，快捷键ctrl+shift+p 再输入configuration便会出现</li>
<li>默认工作空间只有.vscode文件夹，.cpp文件直接放在工作空间根目录的。示例中include、source以及out文件夹可以利用Create C++ project创建工程模板才能在.json中修改配置</li>
</ul>
<h2 id="tasks-json文件"><a href="#tasks-json文件" class="headerlink" title="tasks.json文件"></a>tasks.json文件</h2><p>需要修改的地方主要有三处，可直接复制使用</p>
<ul>
<li>修改 -g后面的目录</li>
<li>修改-o后面的目录</li>
<li>添加 -I 及后面的目录</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;tasks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;,        //任务执行的是shell命令</span><br><span class="line">            &quot;label&quot;: &quot;C/C++: g++.exe build active file&quot;,   	//和launch.josn 中的 preLaunchTask 必须一样</span><br><span class="line">            &quot;command&quot;: &quot;C:\\c\\software\\mingw64\\bin\\g++.exe&quot;,  //命令是g++，也可以直接写g++</span><br><span class="line">            &quot;args&quot;: [  </span><br><span class="line">                &quot;-g&quot;,    //生成和调试有关的信息</span><br><span class="line">                &quot;-Wall&quot;, // 开启额外警告 </span><br><span class="line">				&quot;$&#123;workspaceFolder&#125;\\src\\*.cpp&quot;,  //当前工作空间下文件夹source目录名下的所有cpp文件。 source对应工程目录下的source文件夹名字，可自行修改   </span><br><span class="line">                &quot;-I&quot;,&quot;$&#123;workspaceFolder&#125;\\include&quot;,      // 参数-I 和工程路径 指明了项目中要引用的非标准头文件的位置。 include对应工程目录下的include文件夹名字，可自行修改                   </span><br><span class="line">                &quot;-o&quot;,                      </span><br><span class="line">                &quot;$&#123;workspaceFolder&#125;\\bulid\\$&#123;fileBasenameNoExtension&#125;.exe&quot;, //指定输出的文件名为out，默认a.exe。out对应工程目录下的out文件夹名字，可自行修改 </span><br><span class="line">                &quot;-std=c++17&quot;,                                      //使用c++17标准编译</span><br><span class="line">                &quot;-finput-charset=UTF-8&quot;,                           //输入编译器默认文本编码 默认为utf-8</span><br><span class="line">                &quot;-fexec-charset=GB18030&quot;,                          //输出exe文件编码 </span><br><span class="line">            ],</span><br><span class="line">            &quot;options&quot;: &#123;</span><br><span class="line">                &quot;cwd&quot;: &quot;C:\\c\\software\\mingw64\\bin&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;problemMatcher&quot;: [</span><br><span class="line">                &quot;$gcc&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;group&quot;: &#123;</span><br><span class="line">                &quot;kind&quot;: &quot;build&quot;,</span><br><span class="line">                &quot;isDefault&quot;: true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;version&quot;: &quot;2.0.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="launch-json文件"><a href="#launch-json文件" class="headerlink" title="launch.json文件"></a>launch.json文件</h2><p>需要修改的地方有以下：</p>
<ol>
<li>“program”目录</li>
<li>“cwd”</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;g++.exe &quot;,  // 该调试任务的名字，启动调试时会在待选列表中显示</span><br><span class="line">            &quot;type&quot;: &quot;cppdbg&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;\\build\\$&#123;fileBasenameNoExtension&#125;.exe&quot;,  //需要运行/调试的是当前打开文件的目录中，名字和当前文件相同，但扩展名为exe的程序。和tasks.json中-o后面的目录一样的</span><br><span class="line">            &quot;args&quot;: [],</span><br><span class="line">            &quot;stopAtEntry&quot;: false,  // 这一项控制是否在入口处暂停，默认false不暂停，改为true暂停</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;\\build&quot;, //调试程序时的工作目录 。out对应工程目录下的out文件夹</span><br><span class="line">            &quot;environment&quot;: [],</span><br><span class="line">            &quot;externalConsole&quot;: false,  // 这一项控制是否启动外部控制台（独立的黑框）运行程序，默认false表示在集成终端中运行</span><br><span class="line">            &quot;MIMode&quot;: &quot;gdb&quot;,</span><br><span class="line">            &quot;miDebuggerPath&quot;: &quot;C:\\c\\software\\mingw64\\bin\\gdb.exe&quot;,  // 调试器路径，必须与你自己的电脑相符</span><br><span class="line">            &quot;setupCommands&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;,</span><br><span class="line">                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,</span><br><span class="line">                    &quot;ignoreFailures&quot;: true</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;preLaunchTask&quot;: &quot;g++.exe build active file&quot;  // 调试会话开始前执行的任务，一般为编译程序，c++为g++, c为gcc 这个名字一定要跟tasks.json中的任务名字大小写一致</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="c-cpp-properties-json"><a href="#c-cpp-properties-json" class="headerlink" title="c_cpp_properties.json"></a>c_cpp_properties.json</h2><p>默认不会产生。快捷键ctrl+shift+p 再输入configuration便会出现。<br>修改的地方只有一处：</p>
<p>“includePath” 将include文件夹添加进去即可，注意格式！！<br>注：“compilerPath” 同launch.json。为编译器文件目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Win32&quot;,</span><br><span class="line">            &quot;includePath&quot;: [</span><br><span class="line">                &quot;$&#123;workspaceFolder&#125;/**&quot;,</span><br><span class="line">                &quot;$&#123;workspaceFolder&#125;\\include\\**&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;defines&quot;: [</span><br><span class="line">                &quot;_DEBUG&quot;,</span><br><span class="line">                &quot;UNICODE&quot;,</span><br><span class="line">                &quot;_UNICODE&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;cStandard&quot;: &quot;c17&quot;,</span><br><span class="line">            &quot;cppStandard&quot;: &quot;c++17&quot;,</span><br><span class="line">            &quot;compilerPath&quot;: &quot;C:\\c\\software\\mingw64\\bin\\gdb.exe&quot;,</span><br><span class="line">            &quot;intelliSenseMode&quot;: &quot;windows-gcc-x64&quot;,</span><br><span class="line">            &quot;configurationProvider&quot;: &quot;ms-vscode.makefile-tools&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;version&quot;: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结</p>
<ul>
<li>这三个配置文件可以各拷贝一份，新建工程时，直接放.vscode下面。软件在打开时会直接读取.json文件。</li>
<li>.vscode通常就是放配置文件的，除这三个常用的之外还有settings.json，用来配置编辑器等外观性质的东西。</li>
<li>VSCode下c++多文件夹项目编译调试还可以用makefile、cmake等工具实现，适用于大型项目文件时使用</li>
</ul>
<p><img src="C:\Users\86191\OneDrive\图片\屏幕快照\2023-04-16.png" alt="2023-04-16"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/13/c%E5%92%8Cc++/c-%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/13/c%E5%92%8Cc++/c-%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">c++ 函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-13 16:38:09" itemprop="dateCreated datePublished" datetime="2023-04-13T16:38:09+08:00">2023-04-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-16 20:03:00" itemprop="dateModified" datetime="2023-04-16T20:03:00+08:00">2023-04-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><h3 id="指针或引用形参与const"><a href="#指针或引用形参与const" class="headerlink" title="指针或引用形参与const"></a>指针或引用形参与const</h3><p>形参的初始化方式和变量的初始化方式是一样的,所以回顾通用的初始化规则有助于理解本节知识。我们可以使用非常量初始化一个底层const对象，但是反过来不行;同时一个普通的引用必须用同类型的对象初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int i = 42;</span><br><span class="line">const int *cp = &amp;i;//正确:但是cp不能改变i</span><br><span class="line">const int &amp;r = i;//正确:但是r不能改变i</span><br><span class="line">const int &amp;r2 = 42;//正确:</span><br><span class="line">int *p=cp;//错误:p的类型和cp的类型不匹配</span><br><span class="line">int &amp;r3 = r;//错误:r3的类型和r的类型不匹配</span><br><span class="line">int &amp;r4=42;//错误:不能用字面值初始化一个非常量引用</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;arr两端的括号必不可少</span><br><span class="line">	f(int &amp;arr[10])//错误:将arr声明成了引用的数组</span><br><span class="line">	f(int (&amp;arr)[10])//正确:arr是具有10个整数的整型数组的引用</span><br></pre></td></tr></table></figure>

<h3 id="main-处理命令行选项"><a href="#main-处理命令行选项" class="headerlink" title="main:处理命令行选项"></a>main:处理命令行选项</h3><p>main函数是演示C++程序如何向函数传递数组的好例子。到目前为止，我们定义的main函数都只有空形参列表:<br>int main()[ …}</p>
<p>然而，有时我们确实需要给main传递实参，一种常见的情况是用户通过设置一组选项来确定函数所要执行的操作。例如，假定 main函数位于可执行文件prog之内，我们可以向程序传递下面的选项:<br><code>prog -d -o ofile data0</code><br>这些命令行选项通过两个（可选的）形参传递给main函数:</p>
<p>int main(int argc,char  * argv[]){…}<br>第二个形参argv是一个数组，它的元素是指向C风格字符串的指针:第一个形参arge表示数组中字符串的数量。因为第二个形参是数组，所以main函数也可以定义成:<br>int main(int arge,char  * * argv) { …}<br>其中argv指向char*。</p>
<p>当实参传给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。<br>以上面提供的<strong>命令行</strong>为例，argc应该等于5，argv应该包含如下的C风格字符串:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">argv[0] = &quot;prog&quot; ;//或者argv [0]也可以指向一个空字符串</span><br><span class="line">argv[1] = &quot;-d&quot;;</span><br><span class="line">argv[2] = &quot;-o&quot; ;</span><br><span class="line">argv[3] = &quot;ofile&quot; ;</span><br><span class="line">argv[4]= &quot;data0&quot;;</span><br><span class="line">argv [5] = 0;</span><br></pre></td></tr></table></figure>

<p>当使用argv中的实参时,一定要记得可选的实参从argv[1]开始; </p>
<p>argv[0]保存程序的名字，而非用户输入。</p>
<h3 id="含有可变形参的函数"><a href="#含有可变形参的函数" class="headerlink" title="含有可变形参的函数"></a>含有可变形参的函数</h3><p>为了编写能处理不同数量实参的函数，C++11新标准提供了两种主要的方法:如果所有的实参类型相同,可以传递一个名为initializer_list的标准库类型;如果实参的类型不同，我们可以编写一种特殊的函数，也就是所谓的可变参数模板</p>
<p>和vector一样，initializer_list也是一种模板类型(参见3.3节,第86页)。定义initializer_list对象时，必须说明列表中所含元素的类型:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">initializer_list&lt;string&gt; ls;// initializer_list的元素类型是stringinitializer_list&lt;int&gt; li;// initializer_list的元素类型是int</span><br></pre></td></tr></table></figure>

<p>和 vector不一样的是，initializer_list对象中的元素永远是常量值，我们无法改变initializer_list对象中元素的值。</p>
<p>编写一个函数，它的参数是initializer_list类型的对象，函数的功能是计算列表中所有元素的和。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;initializer_list&gt;</span><br><span class="line"></span><br><span class="line">int counter_int(std::initializer_list&lt;int&gt; il)</span><br><span class="line">&#123;</span><br><span class="line">	int cnt_i = 0;</span><br><span class="line">	for(auto e : il)</span><br><span class="line">		cnt_i += e;</span><br><span class="line">	return cnt_i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; counter_int(&#123;1,2,3,4,5&#125;) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="省略符形参"><a href="#省略符形参" class="headerlink" title="省略符形参"></a>省略符形参</h3><p>省略符形参是为了便于C++程序访问某些特殊的C代码而设置的,这些代码使用了名为varargs的C标准库功能。通常，省略符形参不应用于其他目的。你的C编译器文档会描述如何使用varargs。</p>
<p>省略符形参应该仅仅用于C和C++通用的类型。特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。</p>
<p>省略符形参只能出现在形参列表的最后一个位置，它的形式无外乎以下两种:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void foo (parm_list, ...);</span><br><span class="line">void foo(.. .);</span><br></pre></td></tr></table></figure>

<p>第一种形式指定了 foo函数的部分形参的类型，对应于这些形参的实参将会执行正常的类型检查。<strong>省略符形参所对应的实参无须类型检查</strong>。在第一种形式中，形参声明后面的逗号是可选的。</p>
<h3 id="引用返回左值"><a href="#引用返回左值" class="headerlink" title="引用返回左值"></a>引用返回左值</h3><p>函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值，其他返回类型得到右值。可以像使用其他左值那样来使用返回引用的函数的调用，特别是，我们能为返回类型是非常量引用的函数的结果赋值:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">char &amp;get_val(string &amp;str, string::size_type ix)</span><br><span class="line">&#123;</span><br><span class="line">	return str[ix];//get_val假定索引值是有效的</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	string s( &quot;a value&quot;);</span><br><span class="line">	cout &lt;&lt;s&lt; endl;//输出a value</span><br><span class="line">	get_val(s,0）=&#x27;A&#x27;;//将s[0]的值改为A</span><br><span class="line">	cout c&lt;s&lt;c endl ;//输出A value</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把函数调用放在赋值语句的左侧可能看起来有点奇怪，但其实这没什么特别的。返回值是引用，因此调用是个左值，和其他左值一样它也能出现在赋值运算符的左侧。</p>
<p>如果返回类型是常量引用，我们不能给调用的结果赋值，这一点和我们熟悉的情况是一样的。</p>
<h3 id="列表初始化返回值"><a href="#列表初始化返回值" class="headerlink" title="列表初始化返回值"></a>列表初始化返回值</h3><p>C++11新标准规定，函数可以返回花括号包围的值的列表。类似于其他返回结果，此处的列表也用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化；否则，返回的值由函数的返回类型决定。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;strings process()</span><br><span class="line">&#123;</span><br><span class="line">	// ...</span><br><span class="line">	//expected和actual是string对象</span><br><span class="line">	if (expected.empty())</span><br><span class="line">		return &#123;&#125;;//返回一个空vector对象</span><br><span class="line">	else if (expected -= actual)</span><br><span class="line">		return &#123;&quot;functionx&quot;，&quot;okay&quot;&#125;;//返回列表初始化的vector对象</span><br><span class="line">	else</span><br><span class="line">		return &#123; &quot;functionx&quot;,expected,actual&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="主函数main的返回值"><a href="#主函数main的返回值" class="headerlink" title="主函数main的返回值"></a>主函数main的返回值</h3><p>任何返回类型不是void的函数都必须返回一个值，但此规则的一个例外情况：允许main没有返回值就可结束。如果程序控制执行到主函数main的最后一个语句都还没有返回，那么编译器会隐式地插入返回0的语句。<br>关于main返回的另一个特别之处在于如何处理它的返回值。可将main返回值视为状态指示器。返回0表示程序运行成功，其他大部分返回值则失败。非0返回值的意义因机器不同而不同，为使返回值独立于机器，头文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define EXIT_SUCCESS    0</span><br><span class="line">#define EXIT_FAILURE    1</span><br></pre></td></tr></table></figure>

<h2 id="返回数组指针"><a href="#返回数组指针" class="headerlink" title="返回数组指针"></a>返回数组指针</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int( *func (int i))[10];</span><br></pre></td></tr></table></figure>

<p>可以按照以下的顺序来逐层理解该声明的含义:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func(int i)表示调用func函数时需要一个int类型的实参。</span><br><span class="line">(*func(int i))意味着我们可以对函数调用的结果执行解引用操作。</span><br><span class="line">(*func(int i))[10]表示解引用func 的调用将得到一个大小是10的数组。</span><br><span class="line">int (*func(int i))[10]表示数组中的元素是int类型。</span><br></pre></td></tr></table></figure>

<h3 id="使用尾置返回类型"><a href="#使用尾置返回类型" class="headerlink" title="使用尾置返回类型"></a>使用尾置返回类型</h3><p>在C++11新标准中还有一种可以<strong>简化上述func声明</strong>的方法,就是使用尾置返回类型(trailing return type)。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。尾置返回类型跟在形参列表后面并以一个-&gt;符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组</span><br><span class="line">auto func(int i)-&gt; int(*)[10];</span><br></pre></td></tr></table></figure>

<p>因为我们把函数的返回类型放在了形参列表之后，所以可以清楚地看到 func函数返回的是一个指针,并且该指针指向了含有10个整数的数组。</p>
<h3 id="使用decltype"><a href="#使用decltype" class="headerlink" title="使用decltype"></a>使用decltype</h3><p>还有一种情况，如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。例如，下面的函数返回一个指针，该指针根据参数i的不同指向两个已知数组中的某一个:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int odd[] =&#123; 1,3,5, 7,9&#125;;</span><br><span class="line">int even[] =&#123;0,2,4,6,8&#125;;</span><br><span class="line">//返回一个指针,该指针指向含有5个整数的数组</span><br><span class="line">decltype(odd) *arrPtr(int i)</span><br><span class="line">&#123;</span><br><span class="line">	return (i%2) ? &amp;odd : &amp;even;//返回一个指向数组的指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一个地方需要注意:decltype并不负责把数组类型转换成对应的指针，所以decltype 的结果是个数组，要想表示 arrPtr返回指针还必须在函数声明时加一个*符号。</p>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><h3 id="重载和const形参"><a href="#重载和const形参" class="headerlink" title="重载和const形参"></a>重载和const形参</h3><p>顶层const不影响传入函数的对象。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Record lookup (Phone) ;</span><br><span class="line">Record lookup (const Phone);//重复声明了Record lookup (Phone)</span><br><span class="line">Record lookup (Phone*);</span><br><span class="line">Record lookup (Phone* const);//重复声明了Record lookup(Phone* )</span><br></pre></td></tr></table></figure>

<p>在这两组函数声明中，每一组的第二个声明和第一个声明是等价的。</p>
<p>另一方面，如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//对于接受引用或指针的函数来说，对象是常量还是非常量对应的形参不同</span><br><span class="line">//定义了4个独立的重载函数</span><br><span class="line">Record lookup(Account&amp;) ;//函数作用于Account的引用</span><br><span class="line">Record lookup(const Account&amp;);//新函数，作用于常量引用</span><br><span class="line">Record lookup(Account*);//新函数，作用于指向Account的指针</span><br><span class="line">Record lookup(const Account*);//新函数，作用于指向常量的指针</span><br></pre></td></tr></table></figure>

<h3 id="const-cast和重载"><a href="#const-cast和重载" class="headerlink" title="const_cast和重载"></a>const_cast和重载</h3><p>const_cast在重载函数的情景中最有用。举个例子，shorterString函数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//比较两个string对象的长度，返回较短的那个引用</span><br><span class="line">const string &amp;shorterString(const string &amp;sl,const string &amp;s2)&#123;</span><br><span class="line">	return sl.size(&lt;=s2.size() ? s1: s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的参数和返回类型都是 const string的引用。我们可以对两个非常量的string 实参调用这个函数，但返回的结果仍然是const string的引用。因此我们需要一种新的shorterstring函数，当它的实参不是常量时，得到的结果是一个普通的引用，使用const_cast可以做到这一点:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string &amp;shorterString(string &amp;sl,string &amp;s2)</span><br><span class="line">&#123;</span><br><span class="line">	auto &amp;r = shorterString(const_cast&lt;const string6&gt;(s1)，</span><br><span class="line">						const cast&lt;const string &amp;&gt;(s2));</span><br><span class="line">	return constcast&lt;string&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个版本的函数中，首先将它的实参强制转换成对const的引用，然后调用了shorterString函数的const版本。const版本返回对const string 的引用，这个引用事实上绑定在了某个初始的非常量实参上。因此，我们可以再将其转换回一个普通的string&amp;，这显然是安全的。</p>
<h2 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h2><h3 id="内联函数和-constexpr函数"><a href="#内联函数和-constexpr函数" class="headerlink" title="内联函数和 constexpr函数"></a>内联函数和 constexpr函数</h3><p>使用shorterstring 函数也存在一个潜在的缺点:调用函数一般比求等价表达式的值要慢一些。在大多数机器上，一次函数调用其实包含着一系列工作:调用前要先保存寄存器，并在返回时恢复:可能需要拷贝实参;程序转向一个新的位置继续执行。</p>
<h4 id="内联函数可避免函数调用的开销"><a href="#内联函数可避免函数调用的开销" class="headerlink" title="内联函数可避免函数调用的开销"></a>内联函数可避免函数调用的开销</h4><p>将函数指定为内联函数（inline)，通常就是将它在每个调用点上“内联地”展开。假设我们把shorterString函数定义成内联函数，则如下调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; shorterstring (s1, s2)&lt;&lt;endl;</span><br><span class="line">//将在编译过程中展开成类似于下面的形式</span><br><span class="line">cout&lt;&lt;(s1.size()&lt; s2.size()?sl : s2)&lt;&lt; endl;</span><br><span class="line">//从而消除了shorterString函数的运行时开销。</span><br></pre></td></tr></table></figure>

<p>在shorterstring函数的返回类型前面加上关键字inline,这样就可以将它声明成内联函数了:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//内联版本:寻找两个string对象中较短的那个</span><br><span class="line">inline const string &amp;</span><br><span class="line">shorterString(const string &amp;s1,const string &amp;s2)</span><br><span class="line">&#123;</span><br><span class="line">	return s1.size() &lt;= s2.size() ?sl: s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。很多编译器都不支持内联递归函数，而且一个75行的函数也不大可能在调用点内联地展开。</p>
<h4 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h4><p>constexpr函数(constexpr function)是指能用于常量表达式(的函数。定义constexpr函数的方法与其他函数类似，不过要遵循几项约定:**函数的返回类型及所有形参的类型都得是字面值类型(**到目前为止接触过的数据类型中，算术类型、引用和指针都属于字面值类型。自定义类sales item、IO库、string 类型则不属于字面值类型，也就不能被定义成constexpr。其他一些字面值类型将在后面介绍)，而且函数体中必须有且只有一条return语句（constexpr函数不一定返回常量表达式）:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">constexpr int new sz() &#123; return 42;&#125;</span><br><span class="line">constexpr int foo = new_sz();//正确:foo是一个常量表达式</span><br></pre></td></tr></table></figure>

<p>我们把new _sz定义成无参数的 constexpr函数。因为编译器能在程序编译时验证new_sz 函数返回的是常量表达式，所以可以用new_sz函数初始化constexpr类型的变量foo.</p>
<p>执行该初始化任务时，编译器把对constexpr函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr函数被隐式地指定为内联函数。</p>
<p>constexpr函数体内也可以包含其他语句，只要这些语句在运行时不执行任何操作就行。例如，constexpr函数中可以有空语句、类型别名以及using声明。</p>
<h3 id="把内联函数和constexpr函数放在头文件内"><a href="#把内联函数和constexpr函数放在头文件内" class="headerlink" title="把内联函数和constexpr函数放在头文件内"></a>把内联函数和constexpr函数放在头文件内</h3><p>和其他函数不一样，内联函数和 constexpr函数可以在程序中<strong>多次定义</strong>。毕竟，编译器要想展开函数仅有函数声明是不够的，还需要函数的定义。不过，对于某个给定的内联函数或者constexpr函数来说，它的多个定义必须完全一致。基于这个原因，内联函数和 constexpr函数通常定义在头文件中。</p>
<h2 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h2><p>C+程序员有时会用到一种类似于头文件保护的技术，以便有选择地执行调试代码。基本思想是，程序可以包含一些用于调试的代码，但是这些代码只在开发程序时使用。当应用程序编写完成准备发布时，要先屏蔽掉调试代码。这种方法用到两项预处理功能:assert和 NDEBUG。</p>
<h3 id="assert预处理宏"><a href="#assert预处理宏" class="headerlink" title="assert预处理宏"></a>assert预处理宏</h3><p>assert是一种预处理宏( preprocessor marco)。所谓预处理宏其实是一个预处理变量,它的行为有点类似于内联函数。assert宏使用一个表达式作为它的条件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert (expr) ;</span><br></pre></td></tr></table></figure>

<p>首先对expr求值，如果表达式为假(即0)，assert输出信息并终止程序的执行。如果表达式为真（即非0)，assert什么也不做。</p>
<p>assert宏定义在cassert头文件中。如我们所知，预处理名字由预处理器而非编译器管理,因此我们可以直接使用预处理名字而无须提供using声明。也就是说，我们应该使用assert而不是std::assert，也不需要为assert提供using声明。</p>
<p>assert宏常用于检查“不能发生”的条件。例如，一个对输入文本进行操作的程序可能要求所有给定单词的长度都大于某个阈值。此时,程序可以包含一条如下所示的语句:<br><code>assert(word.size(&gt;threshold);</code></p>
<h3 id="NDEBUG-预处理变量"><a href="#NDEBUG-预处理变量" class="headerlink" title="NDEBUG 预处理变量"></a>NDEBUG 预处理变量</h3><p>assert 的行为依赖于一个名为NDEBUG 的预处理变量的状态。如果定义了NDEBUG,则assert什么也不做。默认状态下没有定义NDEBUG,此时assert将执行运行时检查。</p>
<p>我们可以使用一个#define语句定义 NDEBUG，从而关闭调试状态。同时，很多编译器都提供了一个命令行选项使我们可以定义预处理变量:<br><code>$ cc-D NDEBUG main.C # use/D with the Microsoft compiler</code></p>
<p>这条命令的作用等价于在main.c文件的一开始写#define NDEBUG。</p>
<p>定义NDEBUG能避免检查各种条件所需的运行时开销,当然此时根本就不会执行运行时检查。因此，assert应该仅用于验证那些确实不可能发生的事情。我们可以把assert当成调试程序的一种辅助手段，但是不能用它替代真正的运行时逻辑检查，也不能替代程序本身应该包含的错误检查。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_ _ func _ _是编译器定义的一个局部静态变量，用于存放函数的名字</span><br><span class="line"></span><br><span class="line">_ _ FILE  _ _ 存放文件名的字符串字面值。</span><br><span class="line"></span><br><span class="line">_ _ LINE _ _ 存放当前行号的整型字面值。</span><br><span class="line"></span><br><span class="line">_ _ TIME _ _ 存放文件编译时间的字符串字面值。</span><br><span class="line"></span><br><span class="line">_ _ DATE_ _ 存放文件编译日期的字符串字面值。</span><br></pre></td></tr></table></figure>

<p>可以使用这些常量在错误消息中提供更多信息</p>
<p>练习6.48:说明下面这个循环的含义，它对assert的使用合理吗?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">while (cin &gt;&gt;S&amp;&amp;S!=sought)&#123;]//空函数体</span><br><span class="line">assert (cin);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">这不是一个好的assert用法。assert宏通常用于检查“不能发生”的条件。但是assert总是在用户直接输入EOF时发生，所以检查是没有意义的。使用assert(!cin || s == sought)更好</span><br><span class="line">【出题思路】</span><br><span class="line">assert是一种预处理宏，当assert的条件为真时什么也不做，当它的条件为假时输出信息并终止程序。</span><br><span class="line">【解答】</span><br><span class="line">该程序对assert 的使用有不合理之处。在调试器打开的情况下，当用户输入字符串 s并且s 的内容与 sought不相等时，执行循环体，否则继续执行assert(cin);语句。换句话说，程序执行到assert的原因可能有两个，一是用户终止了输入，二是用户输入的内容正好与sought 的内容一样。如果用户尝试终止输入（事实上用户总有停止输入结束程序的时候)，则assert的条件为假，输出错误信息，这与程序的原意是不相符的。</span><br><span class="line">当调试器关闭时，assert 什么也不做。</span><br></pre></td></tr></table></figure>

<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//比较两个string对象的长度</span><br><span class="line">bool lengthCompare(const string &amp;,const string &amp;);</span><br></pre></td></tr></table></figure>

<p>该函数的类型是bool(const string&amp;,const string&amp;)。要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// pf指向一个函数，该函数的参数是两个const string的引用，返回值是bool类型</span><br><span class="line">bool (*pf) (const string &amp;,const string &amp;);//未初始化</span><br></pre></td></tr></table></figure>

<p>从我们声明的名字开始观察，pf前面有个*，因此pf是指针;右侧是形参列表，表示pf指向的是函数;再观察左侧，发现函数的返回类型是布尔值。因此，pf 就是一个指向函数的指针，其中该函数的参数是两个const string 的引用，返回值是bool类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*pf两端的括号必不可少。如果不写这对括号，则pf是一个返回值为bool指针的函数:</span><br><span class="line">//声明一个名为pf的函数，该函数返回bool*</span><br><span class="line">bool *pf(const string &amp;, const string &amp;);</span><br></pre></td></tr></table></figure>

<h3 id="使用函数指针"><a href="#使用函数指针" class="headerlink" title="使用函数指针"></a>使用函数指针</h3><p>当我们把函数名作为一个值使用时，该函数自动地转换成指针。例如，按照如下形式我们可以将lengthCompare的地址赋给pf:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pf = lengthCompare;//pf指向名为lengthCompare的函数</span><br><span class="line">pf=&amp;lengthCompare;//等价的赋值语句:取地址符是可选的</span><br></pre></td></tr></table></figure>

<p>此外，我们还能直接使用指向函数的指针调用该函数，无须提前解引用指针(*..):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool bl = pf( &quot;hello&quot;, &quot;goodbye&quot; );//调用lengthCompare函数</span><br><span class="line">bool b2= (*pf) ( &quot;hello&quot;, &quot;goodbye&quot; );//一个等价的调用</span><br><span class="line">bool b3= lengthCompare (&quot;hello&quot;,&quot;goodbye&quot;);//另一个等价的调用</span><br></pre></td></tr></table></figure>

<h3 id="函数指针形参"><a href="#函数指针形参" class="headerlink" title="函数指针形参"></a>函数指针形参</h3><p>和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上却是当成指针使用:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//第三个形参是函数类型，它会自动地转换成指向函数的指针</span><br><span class="line">void useBigger(const string &amp;s1,const string &amp;s2,</span><br><span class="line">	bool pf(const string &amp;,const string &amp;));</span><br><span class="line">//等价的声明;显式地将形参定义成指向函数的指针</span><br><span class="line">void useBigger(const string &amp;s1,const string &amp;s2，</span><br><span class="line">	bool (*pf) (const string &amp;,const string &amp;));</span><br></pre></td></tr></table></figure>

<p>我们可以直接把函数作为实参使用，此时它会<strong>自动转换成指针</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//自动将函数lengthCompare转换成指向该函数的指针</span><br><span class="line">useBigger(sl, s2, lengthCompare) ;</span><br></pre></td></tr></table></figure>

<p>正如 useBigger的声明语句所示，直接使用函数指针类型显得冗长而烦琐。类型别名和decltype能让我们简化使用了函数指针的代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//Func和Func2是函数类型</span><br><span class="line">typedef bool Func(const string&amp;,const string&amp;) ;</span><br><span class="line">typedef decltype(lengthcompare) Func2;//等价的类型</span><br><span class="line">// FuncP和FuncP2是指向函数的指针</span><br><span class="line">typedef bool(*FuncP) (const string&amp;,const string&amp;);</span><br><span class="line">typedef decltype(lengthCompare) *FuncP2;</span><br><span class="line">//等价的类型</span><br></pre></td></tr></table></figure>

<p>我们使用typedef定义自己的类型。Func和 Func2是函数类型，而FuncP和 FuncP2是指针类型。需要注意的是，decltype返回函数类型，此时不会将函数类型自动转换成指针类型。因为decltype的结果是函数类型,所以只有在结果前面加上*才能得到指针。</p>
<h3 id="返回指向函数的指针"><a href="#返回指向函数的指针" class="headerlink" title="返回指向函数的指针"></a>返回指向函数的指针</h3><p>和数组类似，虽然不能返回一个函数，但是能返回指向函数类型的指针。然而，我们必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。与往常一样，要想声明一个返回函数指针的函数，最简单的办法是使用类型别名:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">using F= int(int*,int);//F是函数类型，不是指针</span><br><span class="line">using PF = int(*)(int*, int);//PF是指针类型</span><br><span class="line">其中我们使用类型别名将F定义成函数类型，将PF定义成指向函数类型的指针。必须时刻注意的是，和函数类型的形参不一样，返回类型不会自动地转换成指针。我们必须显式地将返回类型指定为指针:</span><br><span class="line">PF f1 (int);//正确:PF是指向函数的指针,f1返回指向函数的指针</span><br><span class="line">F f1(int);//错误:F是函数类型，f1不能返回一个函数</span><br><span class="line">F*f1(int) ;//正确:显式地指定返回类型是指向函数的指针</span><br><span class="line">当然，我们也能用下面的形式直接声明f1:</span><br><span class="line">int(*f1 (int))(int*, int);</span><br></pre></td></tr></table></figure>

<p>按照由内向外的顺序阅读这条声明语句:我们看到f1有形参列表，所以f1是个函数;f1前面有*，所以f1返回一个指针;进一步观察发现，指针的类型本身也包含形参列表,因此指针指向函数，该函数的返回类型是int。</p>
<p>出于完整性的考虑,有必要提醒读者我们还可以使用尾置返回类型的方式声明一个返回函数指针的函数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto f1(int) -&gt; int (*)(int*,int);</span><br></pre></td></tr></table></figure>

<h3 id="将auto和decltype用于函数指针类型"><a href="#将auto和decltype用于函数指针类型" class="headerlink" title="将auto和decltype用于函数指针类型"></a>将auto和decltype用于函数指针类型</h3><p>如果我们明确知道返回的函数是哪一个，就能使用decltype简化书写函数指针返回类型的过程。例如假定有两个函数，它们的返回类型都是 string ::size_type，并且各有两个 const strings类型的形参，此时我们可以编写第三个函数，它接受一个string类型的参数，返回一个指针，该指针指向<strong>前两个函数中的一个</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string::size_type sumLength(const string&amp;,const string&amp;);</span><br><span class="line">string::size_type largerLength (const string&amp;,const string&amp;);</span><br><span class="line">//根据其形参的取值，getFcn函数返回指向sumLength或者largerLength 的指针decltype (sumLength) *getFcn(const string &amp;);</span><br><span class="line">//getFcn有形参列表，所以getFcn是个函数</span><br><span class="line"></span><br><span class="line">//声明 getFcn 唯一需要注意的地方是，牢记当我们将decltype作用于某个函数时，它返回函数类型而非指针类型。因此，我们显式地加上*以表明我们需要返回指针，而非函数本身。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decltype(*p)`得到的类型是`int &amp;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/12/c%E5%92%8Cc++/%E7%AC%AC%E5%8D%81%E5%A4%A9-c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/12/c%E5%92%8Cc++/%E7%AC%AC%E5%8D%81%E5%A4%A9-c/" class="post-title-link" itemprop="url">第十天 c++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-12 14:36:10" itemprop="dateCreated datePublished" datetime="2023-04-12T14:36:10+08:00">2023-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-14 20:24:17" itemprop="dateModified" datetime="2023-04-14T20:24:17+08:00">2023-04-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="find-if"><a href="#find-if" class="headerlink" title="find_if"></a>find_if</h3><p>函数原型:<br>find_if(iterator beg，iterator end，_Pred);</p>
<ul>
<li>&#x2F;&#x2F;按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</li>
<li>&#x2F;&#x2F; beg 开始迭代器</li>
<li>&#x2F;&#x2F; end结束迭代器</li>
<li>&#x2F;&#x2F;_Pred 函数或者谓词(返回bool类型的仿函数)</li>
</ul>
<h3 id="adjacent-find"><a href="#adjacent-find" class="headerlink" title="adjacent_find"></a>adjacent_find</h3><p>功能描述:</p>
<ul>
<li>查找相邻重复元素</li>
</ul>
<p>函数原型:<br>adjacent_find(iterator beg， iterator end) ;</p>
<ul>
<li>&#x2F;&#x2F;查找相邻重复元素,返回相邻元素的第一个位置的迭代器</li>
<li>&#x2F;&#x2F; beg开始迭代器</li>
<li>&#x2F;&#x2F; end结束迭代器</li>
</ul>
<p>总结:面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法</p>
<h3 id="binary-search"><a href="#binary-search" class="headerlink" title="binary_search"></a>binary_search</h3><p>功能描述:</p>
<ul>
<li>查找指定元素是否存在,二分法</li>
</ul>
<p>函数原型:<br>bool binary_search(iterator beg, iterator end，value);</p>
<ul>
<li>&#x2F;&#x2F;查找指定的元素，查到返回true否则false</li>
<li>&#x2F;&#x2F;注意:在无序序列中不可用</li>
<li>&#x2F;&#x2F; beg开始迭代器</li>
<li>&#x2F;&#x2F; end结束迭代器</li>
<li>&#x2F;&#x2F; value查找的元素</li>
</ul>
<h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p>功能描述:</p>
<ul>
<li>统计元素个数</li>
</ul>
<p>函数原型:<br>count(iterator beg, iterator end，value) ;</p>
<ul>
<li>&#x2F;&#x2F;统计元素出现次数</li>
<li>&#x2F;&#x2F;beg 开始迭代器</li>
<li>&#x2F;&#x2F;end结束迭代器</li>
<li>&#x2F;&#x2F;value统计的元素</li>
</ul>
<p>自定义数据类型与find方法一致</p>
<h3 id="count-if"><a href="#count-if" class="headerlink" title="count_if"></a>count_if</h3><p>函数原型:<br>count_if(iterator beg, iterator end，_Pred ) ;</p>
<ul>
<li>&#x2F;&#x2F;按条件统计元素出现次数</li>
<li>&#x2F;&#x2F; beg开始迭代器</li>
<li>&#x2F;&#x2F;end结束迭代器</li>
<li>&#x2F;&#x2F; _Pred谓词</li>
</ul>
<h2 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h2><ul>
<li>sort	&#x2F;&#x2F;对容器内元素进行排序</li>
<li>random_shuffle	&#x2F;&#x2F;洗牌指定范围内的元素随机调整次序</li>
<li>merge	&#x2F;&#x2F;容器元素合并，并存储到另一容器中</li>
<li>reverse	&#x2F;&#x2F;反转指定范围的元素</li>
</ul>
<p>函数原型:<br>sort(iterator beg, iterator end，_Pred) ;</p>
<ul>
<li>&#x2F;&#x2F;按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</li>
<li>&#x2F;&#x2F;beg开始迭代器</li>
<li>&#x2F;&#x2F; end结束迭代器</li>
<li>&#x2F;&#x2F; _Pred 谓词</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//从大到小排序,没有pred默认是从小到大</span><br><span class="line">sort(v.begin(), v.end (), greater&lt;int&gt;());// greater&lt;int&gt;()头文件在functional</span><br></pre></td></tr></table></figure>

<p>函数原型:</p>
<p>random_shuffle(iterator beg, iterator end) ;</p>
<ul>
<li>&#x2F;&#x2F;指定范围内的元素随机调整次序</li>
<li>&#x2F;&#x2F; beg 开始迭代器</li>
<li>&#x2F;&#x2F; end结束迭代器</li>
</ul>
<p>总结:random_shuffle洗牌算法比较实用，使用时记得加随机数种子（srand((unsigned int)time(NULL)) ;）</p>
<ul>
<li>函数原型:<br>merge(iterator beg1，iterator end1， iterator beg2，iterator end2， iterator dest);</li>
<li><ul>
<li>&#x2F;&#x2F;容器元素合并，并存储到另一容器中</li>
<li>&#x2F;&#x2F; 注意:两个容器必须是有序的</li>
<li>&#x2F;&#x2F; beg1容器1开始迭代器</li>
<li>&#x2F;&#x2F; end1容器1结束迭代器</li>
<li>&#x2F;&#x2F; beg2容器2开始迭代器</li>
<li>&#x2F;&#x2F; end2容器2结束迭代器</li>
<li>&#x2F;&#x2F; dest目标容器开始迭代器</li>
</ul>
</li>
</ul>
<p>函数原型:<br>reverse(iterator beg, iterator end );</p>
<ul>
<li>&#x2F;&#x2F;反转指定范围的元素</li>
<li>&#x2F;&#x2F; beg开始迭代器</li>
<li>&#x2F;&#x2F; end结束迭代器</li>
</ul>
<h2 id="常用拷贝和替换算法"><a href="#常用拷贝和替换算法" class="headerlink" title="常用拷贝和替换算法"></a>常用拷贝和替换算法</h2><p>算法简介:</p>
<ul>
<li>copy	&#x2F;&#x2F;容器内指定范围的元素拷贝到另—容器中</li>
<li>replace	&#x2F;&#x2F;将容器内指定范围的旧元素修改为新元素</li>
<li>replace_if	&#x2F;&#x2F;容器内指定范围满足条件的元素替换为新元素</li>
<li>swap	&#x2F;&#x2F;互换两个容器的元素</li>
</ul>
<p>函数原型:<br>copy(iterator beg, iterator end，iterator dest) ;</p>
<ul>
<li>&#x2F;&#x2F;按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</li>
<li>&#x2F;&#x2F;beg开始迭代器</li>
<li>&#x2F;&#x2F; end结束迭代器</li>
<li>&#x2F;&#x2F;dest目标容器开始迭代器</li>
</ul>
<p>函数原型:<br>replace(iterator beg, iterator end，oldvalue,newvalue) ;</p>
<ul>
<li>&#x2F;&#x2F;将区间内旧元素替换成新元素</li>
<li>&#x2F;&#x2F;beg开始迭代器</li>
<li>&#x2F;&#x2F; end结束迭代器</li>
<li>&#x2F;&#x2F;oldvalue旧元素</li>
<li>&#x2F;&#x2F;newvalue新元素</li>
</ul>
<p>函数原型:<br>replace_if(iterator beg, iterator end，_pred,newvalue) ;</p>
<ul>
<li>&#x2F;&#x2F;按条件替换元素，满足条件的替换成指定元素</li>
<li>&#x2F;&#x2F;beg开始迭代器</li>
<li>&#x2F;&#x2F; end结束迭代器</li>
<li>&#x2F;&#x2F;_pred谓词</li>
<li>&#x2F;&#x2F;newvalue替换的新元素</li>
</ul>
<p>函数原型:<br>swap(container c1, container c2);</p>
<p>&#x2F;&#x2F;互换两个相同类型容器的元素<br>&#x2F;&#x2F; c1容器1<br>&#x2F;&#x2F; c2容器2</p>
<h2 id="常用算术生成算法"><a href="#常用算术生成算法" class="headerlink" title="常用算术生成算法"></a>常用算术生成算法</h2><p>注意:<br>算术生成算法属于小型算法，使用时包含的头文件为#include <numeric></p>
<p>算法简介:</p>
<ul>
<li>accumplate	&#x2F;&#x2F;计算容器元素累计总和</li>
<li>fill	&#x2F;&#x2F;向容器中添加元素</li>
</ul>
<p>函数原型:<br>accumplate(iterator beg, iterator end，value) ;</p>
<ul>
<li>&#x2F;&#x2F;计算容器元素累计总和</li>
<li>&#x2F;&#x2F;beg开始迭代器</li>
<li>&#x2F;&#x2F;end结束迭代器</li>
<li>&#x2F;&#x2F;value起始值</li>
</ul>
<p>函数原型:<br>fill(iterator beg, iterator end，value) ;</p>
<ul>
<li>&#x2F;&#x2F;向容器中填充元素</li>
<li>&#x2F;&#x2F;beg开始迭代器</li>
<li>&#x2F;&#x2F;end结束迭代器</li>
<li>&#x2F;&#x2F;value填充的值</li>
</ul>
<h2 id="常用集合算法"><a href="#常用集合算法" class="headerlink" title="常用集合算法"></a>常用集合算法</h2><p>算法简介:</p>
<ul>
<li>set_intersection	&#x2F;&#x2F;求两个容器的交集</li>
<li>set_union	&#x2F;&#x2F;求两个容器的并集</li>
<li>set_difference	&#x2F;&#x2F;求两个容器的差集</li>
</ul>
<p>函数原型:<br>set_intersection(iterator beg1，iterator end1， iterator beg2，iterator end2， iterator dest);</p>
<ul>
<li>&#x2F;&#x2F;求两个集合的交集</li>
<li>&#x2F;&#x2F; 注意:两个容器必须是有序的</li>
<li>&#x2F;&#x2F; beg1容器1开始迭代器</li>
<li>&#x2F;&#x2F; end1容器1结束迭代器</li>
<li>&#x2F;&#x2F; beg2容器2开始迭代器</li>
<li>&#x2F;&#x2F; end2容器2结束迭代器</li>
<li>&#x2F;&#x2F; dest目标容器开始迭代器</li>
<li>&#x2F;&#x2F;set_intersection返回值既是交集中最后一个元素的位置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//最特殊情况大容器包含小容器开辟空间取小容器的size即可vTarget.resize(mih(v1.size(), v2.size())) ;</span><br></pre></td></tr></table></figure>

<p>函数原型:<br>set_union(iterator beg1，iterator end1， iterator beg2，iterator end2， iterator dest);</p>
<ul>
<li>&#x2F;&#x2F;求两个集合的并集</li>
<li>&#x2F;&#x2F; 注意:两个容器必须是有序的</li>
<li>&#x2F;&#x2F; beg1容器1开始迭代器</li>
<li>&#x2F;&#x2F; end1容器1结束迭代器</li>
<li>&#x2F;&#x2F; beg2容器2开始迭代器</li>
<li>&#x2F;&#x2F; end2容器2结束迭代器</li>
<li>&#x2F;&#x2F; dest目标容器开始迭代器</li>
</ul>
<p>函数原型:<br>set_difference(iterator beg1，iterator end1， iterator beg2，iterator end2， iterator dest);</p>
<ul>
<li>&#x2F;&#x2F;求两个集合的差集</li>
<li>&#x2F;&#x2F; 注意:两个容器必须是有序的</li>
<li>&#x2F;&#x2F; beg1容器1开始迭代器</li>
<li>&#x2F;&#x2F; end1容器1结束迭代器</li>
<li>&#x2F;&#x2F; beg2容器2开始迭代器</li>
<li>&#x2F;&#x2F; end2容器2结束迭代器</li>
<li>&#x2F;&#x2F; dest目标容器开始迭代器</li>
</ul>
<p>总结:</p>
<ul>
<li>求差集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要从两个容器取较大值</li>
<li>set_difference返回值既是差集中最后一个元素的位置</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/11/c%E5%92%8Cc++/%E7%AC%AC%E4%B9%9D%E5%A4%A9-c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/11/c%E5%92%8Cc++/%E7%AC%AC%E4%B9%9D%E5%A4%A9-c/" class="post-title-link" itemprop="url">第九天 c++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-11 16:39:12" itemprop="dateCreated datePublished" datetime="2023-04-11T16:39:12+08:00">2023-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-12 15:05:48" itemprop="dateModified" datetime="2023-04-12T15:05:48+08:00">2023-04-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="STL-函数对象"><a href="#STL-函数对象" class="headerlink" title="STL-函数对象"></a>STL-函数对象</h1><h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><h3 id="函数对象概念"><a href="#函数对象概念" class="headerlink" title="函数对象概念"></a>函数对象概念</h3><p>概念:</p>
<ul>
<li>重载函数调用操作符的类，其对象常称为函数对象</li>
<li>函数对象使用重载的()时，行为类似函数调用，也叫仿函数</li>
</ul>
<p>本质:</p>
<ul>
<li>函数对象(仿函数)是一个类，不是一个函数</li>
</ul>
<h3 id="函数对象使用"><a href="#函数对象使用" class="headerlink" title="函数对象使用"></a>函数对象使用</h3><p>特点:</p>
<ul>
<li>函数对象在使用时，可以像普通函数那样调用,可以有参数，可以有返回值</li>
<li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li>
<li>函数对象可以作为参数传递</li>
</ul>
<h2 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h2><h3 id="谓词概念"><a href="#谓词概念" class="headerlink" title="谓词概念"></a>谓词概念</h3><p>概念:</p>
<ul>
<li>返回bool类型的仿函数称为谓词</li>
<li>如果operator()接受一个参数，那么叫做一元谓词</li>
<li>如果operator()接受两个参数，那么叫做二元谓词</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">//1.一元谓词</span><br><span class="line">class GreaterFive&#123;</span><br><span class="line">public:</span><br><span class="line">	bool operator()(int val) &#123;</span><br><span class="line">		return val &gt; 5;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test01() &#123;</span><br><span class="line">	vector&lt;int&gt; v;</span><br><span class="line">	for (int i =0; i &lt; 10; i++)&#123;</span><br><span class="line">		v.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;int&gt; : :iterator it = find_if(v.begin(), v.end()，GreaterFive());//匿名形式</span><br><span class="line">	//GreaterFive如果括号里有常量，则这个与仿函数内部定义的量相对应，而重载的val与容器值对应，无需传入</span><br><span class="line">	if (it == v.end()) &#123;</span><br><span class="line">		cout &lt;&lt;&quot;没找到!”&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		cout &lt;&lt;“找到:” &lt;&lt;*it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">//二元谓词</span><br><span class="line">class MyCompare&#123;</span><br><span class="line">public:</span><br><span class="line">	bool operator( )(int num1,int num2)&#123;</span><br><span class="line">		return num1 &gt; num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()&#123;</span><br><span class="line">	vector&lt;int&gt; v;</span><br><span class="line">	v.push_back(10);</span><br><span class="line">	v.push_back(40);</span><br><span class="line">	v.push_back(20);</span><br><span class="line">	v.push_back(30);</span><br><span class="line">	v.push_back(50) ;</span><br><span class="line">	//默认从小到大</span><br><span class="line">	sort(v.begin(), v.end() );</span><br><span class="line">	for (vector&lt;int&gt; : :iterator it = v.begin(); it != v.end(); it++)&#123;</span><br><span class="line">		cout &lt;&lt;*it &lt;&lt;” &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;------------&quot; &lt;&lt;endl;</span><br><span class="line">	//使用函数对象改变算法策略，排序从大到小</span><br><span class="line">	sort(v.begin(), v.end( ), MyCompare( ) );</span><br><span class="line">	for (vector&lt;int&gt; ::iterator it = v.begin(); it != v.end(); it++)&#123;</span><br><span class="line">		cout &lt;&lt;*it &lt;&lt;&quot;&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:参数只有两个的谓词，称为二元谓词</p>
<h1 id="内建函数对象"><a href="#内建函数对象" class="headerlink" title="内建函数对象"></a>内建函数对象</h1><h2 id="内建函数对象意义"><a href="#内建函数对象意义" class="headerlink" title="内建函数对象意义"></a>内建函数对象意义</h2><p>概念:</p>
<ul>
<li>STL内建了一些函数对象</li>
</ul>
<p>分类:</p>
<ul>
<li>算术仿函数</li>
<li>关系仿函数</li>
<li>逻辑仿函数</li>
</ul>
<p>用法:</p>
<ul>
<li>这些仿函数所产生的对象，用法和一般函数完全相同</li>
<li>使用内建函数对象，需要引入头文件#include<functional></li>
</ul>
<h2 id="算术仿函数"><a href="#算术仿函数" class="headerlink" title="算术仿函数"></a>算术仿函数</h2><p>功能描述:</p>
<ul>
<li>实现四则运算</li>
</ul>
<p>其中negate是一元运算，其他都是二元运算仿函数原型:</p>
<ul>
<li><p>template<class T> T plus<T>&#x2F;&#x2F;加法仿函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plus&lt;int&gt; p;</span><br><span class="line">cout &lt;&lt; p( 10，20) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>


</li>
<li><p>template<class T> T minus<T>&#x2F;&#x2F;减法仿函数</p>
</li>
<li><p>template<class T> T multiplies<T>&#x2F;&#x2F;乘法仿函数</p>
</li>
<li><p>template<class T> T divides<T>&#x2F;&#x2F;除法仿函数</p>
</li>
<li><p>template<class T> T modulus<T>&#x2F;&#x2F;取模仿函数</p>
</li>
<li><p>template<class T> T negate<T>&#x2F;&#x2F;取反仿函数</p>
</li>
</ul>
<h2 id="关系仿函数"><a href="#关系仿函数" class="headerlink" title="关系仿函数"></a>关系仿函数</h2><p>功能描述:</p>
<ul>
<li>实现关系对比</li>
</ul>
<p>仿函数原型:</p>
<ul>
<li><p>template<class T> bool equal_to<T>&#x2F;&#x2F;等于</p>
</li>
<li><p>template<class T> bool not_equal_to<T>&#x2F;&#x2F;不等于</p>
</li>
<li><p>template<class T> bool greater<T>&#x2F;&#x2F;大于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//降序</span><br><span class="line">// sort(v.begin(), v.end()，MyCompare() ) ;</span><br><span class="line">sort(v.begin()， v.end(),greater&lt;int&gt;());</span><br></pre></td></tr></table></figure>


</li>
<li><p>template<class T> bool greater_equal<T>&#x2F;&#x2F;大于等于</p>
</li>
<li><p>template<class T> bool less<T>&#x2F;&#x2F;小于</p>
</li>
<li><p>template<class T> bool less_equal<T>&#x2F;&#x2F;小于等于</p>
</li>
</ul>
<p>总结:关系仿函数中最常用的就是greater&lt;&gt;大于,因为默认是less小于</p>
<h2 id="逻辑仿函数"><a href="#逻辑仿函数" class="headerlink" title="逻辑仿函数"></a>逻辑仿函数</h2><p>功能描述:</p>
<ul>
<li>实现逻辑运算</li>
</ul>
<p>函数原型:</p>
<ul>
<li>template<class T> bool logical_and<T>&#x2F;&#x2F;逻辑与</li>
<li>template<class T> bool logical_or<T>&#x2F;&#x2F;逻辑或</li>
<li>template<class T> bool logical_not<T>&#x2F;&#x2F;逻辑非</li>
</ul>
<h1 id="STL-常用算法"><a href="#STL-常用算法" class="headerlink" title="STL-常用算法"></a>STL-常用算法</h1><p>概述:</p>
<ul>
<li>算法主要是由头文件<algorithm><functional><numeric>组成。</li>
<li><algorithm>是所有STL头文件中最大的一个，范围涉及到比较、交换、查找、遍历操作、复制、修改等等<numeric>体积很小，只包括几个在序列上面进行简单数学运算的模板函数</li>
<li><functional>定义了一些模板类,用以声明函数对象。</li>
</ul>
<h2 id="常用遍历算法"><a href="#常用遍历算法" class="headerlink" title="常用遍历算法"></a>常用遍历算法</h2><p>算法简介:</p>
<ul>
<li>for_each&#x2F;&#x2F;遍历容器</li>
<li>transform&#x2F;&#x2F;搬运容器到另一个容器中</li>
</ul>
<h2 id="for-each"><a href="#for-each" class="headerlink" title="for_each"></a>for_each</h2><p>函数原型:</p>
<ul>
<li>for_each(iterator beg, iterator end，_func);</li>
</ul>
<p>​	&#x2F;&#x2F;遍历算法遍历容器元素<br>​	&#x2F;&#x2F;beg开始迭代器<br>​	&#x2F;&#x2F;end结束迭代器<br>​	&#x2F;&#x2F; _func函数或者函数对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">//普通函数</span><br><span class="line">void print01(int val)&#123;</span><br><span class="line">	cout &lt;&lt;val &lt;&lt; &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">//函数对象</span><br><span class="line">class print02&#123;</span><br><span class="line">public :</span><br><span class="line">	void operator()(int val)&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt;&quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//for_each算法基本用法</span><br><span class="line">void test01()&#123;</span><br><span class="line">	vector&lt;int&gt; v;</span><br><span class="line">	for (int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">		v.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	//遍历算法</span><br><span class="line">	for_each(v.begin(), v.end( ), print01);//相当于传入了一个函数指针</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	for_each(v.begin(), v.end(), print02());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h2><p>函数原型:</p>
<ul>
<li>transform(iterator beg1, iterator end1， iterator beg2，_func);</li>
</ul>
<p>​	&#x2F;&#x2F;beg1源容器开始迭代器</p>
<p>​	&#x2F;&#x2F;end1源容器结束迭代器</p>
<p>​	&#x2F;&#x2F;beg2目标容器开始迭代器</p>
<p>​	&#x2F;&#x2F;_func函数或者函数对象</p>
<p>总结:搬运的目标容器必须要提前开辟空间，否则无法正常搬运</p>
<h2 id="常用查找算法"><a href="#常用查找算法" class="headerlink" title="常用查找算法"></a>常用查找算法</h2><p>算法简介:</p>
<ul>
<li>find&#x2F;&#x2F;查找元素</li>
<li>find_if&#x2F;&#x2F;按条件查找元素</li>
<li>adjacent_find&#x2F;&#x2F;查找相邻重复元素</li>
<li>binary_search&#x2F;&#x2F;二分查找法</li>
<li>count&#x2F;&#x2F;统计元素个数</li>
<li>count_if&#x2F;&#x2F;按条件统计元素个数</li>
</ul>
<p>函数原型:<br>find(iterator beg, iterator end,value ) ;</p>
<ul>
<li>&#x2F;&#x2F;按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</li>
<li>&#x2F;&#x2F;beg开始迭代器</li>
<li>&#x2F;&#x2F;end结束迭代器</li>
<li>&#x2F;&#x2F;value查找的元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">void test01() &#123;</span><br><span class="line">	vector&lt;int&gt; v;</span><br><span class="line">	for (int i =0; i &lt; 10; i++)&#123;</span><br><span class="line">		v.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;int&gt; : :iterator it = find(v.begin(), v.end()，5);//查找容器中是否有5这个元素</span><br><span class="line">	if (it == v.end()) &#123;</span><br><span class="line">		cout &lt;&lt;&quot;没找到!”&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		cout &lt;&lt;“找到:” &lt;&lt;*it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">	Person( string name，int age)&#123;</span><br><span class="line">		this-&gt;m_Name = name;</span><br><span class="line">		this-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	//重载==,是find底层的==</span><br><span class="line">	bool operato==(const Person&amp; p)&#123;</span><br><span class="line">		if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)&#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	string m_Name ;</span><br><span class="line">	int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line">void test02()&#123;</span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line">	//创建数据</span><br><span class="line">	Person p1( &quot;aaa&quot;, 10);</span><br><span class="line">	Person p2(&quot;bbb&quot;,20);</span><br><span class="line">	Person p3(&quot;cce&quot;, 30);</span><br><span class="line">	Person p4( &quot;ddd&quot;,40);</span><br><span class="line">	v.push_back(p1);</span><br><span class="line">	v.push_back(p2);</span><br><span class="line">	v.push_back(p3);</span><br><span class="line">	v.push_back(p4);</span><br><span class="line">	Person pp=(&quot;ads&quot;,11);</span><br><span class="line">	vector&lt;Person&gt; : :iterator it = find(v.begin(), v.end(), pp);</span><br><span class="line">	if (it == v.end())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt;&quot;没有找到!&quot;&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		cout &lt;&lt;&quot;找到姓名:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt;”年龄: &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:利用find可以在容器中找指定的元素，返回值是迭代器</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/10/c%E5%92%8Cc++/%E7%AC%AC%E5%85%AB%E5%A4%A9-c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/10/c%E5%92%8Cc++/%E7%AC%AC%E5%85%AB%E5%A4%A9-c/" class="post-title-link" itemprop="url">第八天 c++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-10 16:38:50" itemprop="dateCreated datePublished" datetime="2023-04-10T16:38:50+08:00">2023-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-16 13:41:42" itemprop="dateModified" datetime="2023-04-16T13:41:42+08:00">2023-04-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="stack容器"><a href="#stack容器" class="headerlink" title="stack容器"></a>stack容器</h2><h3 id="stack基本概念"><a href="#stack基本概念" class="headerlink" title="stack基本概念"></a>stack基本概念</h3><p>概念: stack是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口</p>
<p>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p>
<h3 id="stack常用接口"><a href="#stack常用接口" class="headerlink" title="stack常用接口"></a>stack常用接口</h3><p>功能描述:栈容器常用的对外接口</p>
<p>构造函数:</p>
<ul>
<li>stack<T> stk;&#x2F;&#x2F;stack采用模板类实现, stack对象的默认构造形式</li>
<li>stack( const stack &amp;stk);&#x2F;&#x2F;拷贝构造函数</li>
</ul>
<p>赋值操作:</p>
<ul>
<li>stack&amp; operator&#x3D;(const stack &amp;stk);&#x2F;&#x2F;重载等号操作符</li>
</ul>
<p>数据存取:</p>
<ul>
<li>push(elem);&#x2F;&#x2F;向栈顶添加元素</li>
<li>pop();&#x2F;&#x2F;从栈顶移除第一个元素</li>
<li>top();&#x2F;&#x2F;返回栈顶元素</li>
</ul>
<p>大小操作:</p>
<ul>
<li>empty();&#x2F;&#x2F;判断堆栈是否为空</li>
<li>size();&#x2F;&#x2F;返回栈的大小</li>
</ul>
<h2 id="queue容器"><a href="#queue容器" class="headerlink" title="queue容器"></a>queue容器</h2><h3 id="queue基本概念"><a href="#queue基本概念" class="headerlink" title="queue基本概念"></a>queue基本概念</h3><p>概念:Queud是一种先进先出(First ln First Out,FIFO)的数据结构，它有两个出口</p>
<ul>
<li>队列容器允许从一端新增元素，从另一端移除元素</li>
<li>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</li>
<li>队列中进数据称为—入队push</li>
<li>队列中出数据称为—出队pop</li>
</ul>
<h3 id="queue-常用接口"><a href="#queue-常用接口" class="headerlink" title="queue 常用接口"></a>queue 常用接口</h3><p>功能描述:栈容器常用的对外接口</p>
<p>构造函数:</p>
<ul>
<li>queue<T> que;&#x2F;&#x2F;queue采用模板类实现，queue对象的默认构造形式</li>
<li>queue(const queue &amp;que) ;&#x2F;&#x2F;拷贝构造函数</li>
</ul>
<p>赋值操作:</p>
<ul>
<li>queue&amp; operator&#x3D;(const queue &amp;que) ;&#x2F;&#x2F;重载等号操作符</li>
</ul>
<p>数据存取:</p>
<ul>
<li>push(elem) ;&#x2F;&#x2F;往队尾添加元素</li>
<li>pop();&#x2F;&#x2F;从队头移除第一个元素</li>
<li>back();&#x2F;&#x2F;返回最后一个元素</li>
<li>front();&#x2F;&#x2F;返回第一个元素</li>
</ul>
<p>大小操作:</p>
<ul>
<li>empty();&#x2F;&#x2F;判断堆栈是否为空</li>
<li>size();&#x2F;&#x2F;返回栈的大小</li>
</ul>
<h2 id="list容器"><a href="#list容器" class="headerlink" title="list容器"></a>list容器</h2><h3 id="list基本概念"><a href="#list基本概念" class="headerlink" title="list基本概念"></a>list基本概念</h3><p>功能:将数据进行链式存储</p>
<p>链表(list)是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p>
<p>链表的组成:链表由一系列结点组成</p>
<p>结点的组成:一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域</p>
<p>STL中的链表是一个双向循环链表</p>
<p>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器</p>
<p>list的优点:</p>
<ul>
<li>采用动态存储分配，不会造成内存浪费和溢出</li>
<li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li>
</ul>
<p>list的缺点:</p>
<ul>
<li>链表灵活，但是空间(指针域)和时间(遍历额外耗费较大</li>
</ul>
<p>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</p>
<p>总结:STL中List和vector是两个最常被使用的容器，各有优缺点</p>
<h3 id="list构造函数"><a href="#list构造函数" class="headerlink" title="list构造函数"></a>list构造函数</h3><p>函数原型:</p>
<ul>
<li>list<T> lst;&#x2F;&#x2F;list采用采用模板类实现,对象的默认构造形式:</li>
<li>list(beg,end) ;&#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。</li>
<li>list(n,elem) ;&#x2F;&#x2F;构造函数将n个elem拷贝给本身。</li>
<li>list(const list &amp;lst);&#x2F;&#x2F;拷贝构造函数。</li>
</ul>
<p>总结:list构造方式同其他几个STL常用容器，熟练掌握即可</p>
<h3 id="list赋值和交换"><a href="#list赋值和交换" class="headerlink" title="list赋值和交换"></a>list赋值和交换</h3><p>函数原型:</p>
<ul>
<li>assign(beg,_end) ;&#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li>assign(n, eiem) ;&#x2F;&#x2F;将n个elem拷贝赋值给本身。</li>
<li>list&amp; operator&#x3D;(const list &amp;lst);&#x2F;&#x2F;重载等号操作符</li>
<li>swap(lst);&#x2F;&#x2F;将lst与本身的元素互换。</li>
</ul>
<h3 id="list大小操作"><a href="#list大小操作" class="headerlink" title="list大小操作"></a>list大小操作</h3><p>函数原型:</p>
<ul>
<li>size();&#x2F;&#x2F;返回容器中元素的个数</li>
<li>empty();&#x2F;&#x2F;判断容器是否为空</li>
<li>resize(num ) ;&#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。&#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</li>
<li>resize(num，elem);&#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。&#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</li>
</ul>
<h3 id="list插入和删除"><a href="#list插入和删除" class="headerlink" title="list插入和删除"></a>list插入和删除</h3><p>函数原型:</p>
<ul>
<li>push_back(elem);&#x2F;&#x2F;在容器尾部加入一个元素.</li>
<li>pop_back();&#x2F;&#x2F;删除容器中最后一个元素</li>
<li>push_front(elem);&#x2F;&#x2F;在容器开头插入一个元素.</li>
<li>pop_front();&#x2F;&#x2F;从容器开头移除第一个元素</li>
<li>insert(pos,elem);&#x2F;&#x2F;在pos位置插elem元素的拷贝，返回新数据的位置。</li>
<li>insert(pos,n,elem);&#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。</li>
<li>insert(pos,beg,end);&#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。</li>
<li>clear();&#x2F;&#x2F;移除容器的所有数据</li>
<li>erase(beg,end);&#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。</li>
<li>erase(pos);&#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。</li>
<li>remove(elem);&#x2F;&#x2F;删除容器中所有与elem值匹配的元素。</li>
</ul>
<h3 id="list数据存取"><a href="#list数据存取" class="headerlink" title="list数据存取"></a>list数据存取</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//L1[0]不可以用[]访问list容器中的元素</span><br><span class="line">//L1.at(O)不可以用at方式访问list容器中的元素</span><br><span class="line">//原因是list本质链表，不是用连续线性空间存储数据，迭代器也是不支持随机访问的</span><br><span class="line">cout &lt;&lt;&quot;第一个元素为:&quot;&lt;&lt; L1.front() &lt;&lt; endl;</span><br><span class="line">cout&lt;&lt;&quot;最后一个元素为:&quot;&lt;&lt; L1. back() &lt;&lt; endl ;</span><br><span class="line">//验证迭代器是不支持随机访问的</span><br><span class="line">list&lt;int&gt; : :iterator it = L1. begin();</span><br><span class="line">it++;//支持双向,可以用来判断其它容器是否支持双向访问，随机访问也一样</span><br><span class="line">it--;</span><br><span class="line">//it = it + 1;//不支持随机访问</span><br></pre></td></tr></table></figure>

<p>总结:</p>
<ul>
<li>list容器中不可以通过[]或者at方式访问数据</li>
<li>返回第一个元素— front</li>
<li>返回最后一个元素— back</li>
</ul>
<h3 id="list反转和排序"><a href="#list反转和排序" class="headerlink" title="list反转和排序"></a>list反转和排序</h3><p>函数原型:</p>
<ul>
<li>reverse();&#x2F;&#x2F;反转链表</li>
<li>sort(); &#x2F;&#x2F;链表排序</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//指定排序规则</span><br><span class="line">bool mycompare( int val1 , int val2)&#123;</span><br><span class="line">	return val1 &gt; val2;</span><br><span class="line">&#125;</span><br><span class="line">//所有不支持随机访问迭代器的容器，不可以用标准算法</span><br><span class="line">//不支持随机访问迭代器的容器，内部会提供对应一些算法</span><br><span class="line">//sort(L1.begin()，L1.end() ) ;</span><br><span class="line">L1.sort();//默认排序规则从小到大升序</span><br><span class="line">L.sort( myCompare); //指定规则，从大到小</span><br></pre></td></tr></table></figure>

<p>总结:</p>
<ul>
<li><p>对于自定义数据类型，必须要指定排序规则(</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool mycompare( int val1 , int val2)&#123;</span><br><span class="line">	return val1 &gt; val2;</span><br><span class="line">&#125;//val可以是任何类型，注意引用</span><br></pre></td></tr></table></figure>

<p>)，否则编译器不知道如何进行排序</p>
</li>
<li><p>高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂</p>
</li>
</ul>
<h2 id="set-x2F-multiset容器"><a href="#set-x2F-multiset容器" class="headerlink" title="set&#x2F; multiset容器"></a>set&#x2F; multiset容器</h2><h3 id="set基本概念"><a href="#set基本概念" class="headerlink" title="set基本概念"></a>set基本概念</h3><p>简介:</p>
<ul>
<li>所有元素都会在插入时自动被排序</li>
</ul>
<p>本质:</p>
<ul>
<li>set&#x2F;multiset属于关联式容器，底层结构是用二叉树实现。</li>
</ul>
<p>set和multiset区别:</p>
<ul>
<li>set不允许容器中有重复的元素（无resize）</li>
<li>multiset允许容器中有重复的元素</li>
</ul>
<p>总结:</p>
<ul>
<li>set容器插入数据时用insert</li>
<li>set容器插入数据的数据会自动排序</li>
</ul>
<p>总结:</p>
<ul>
<li>统计大小— size</li>
<li>判断是否为空— empty</li>
<li>交换容器— swap</li>
</ul>
<p>函数原型:</p>
<ul>
<li><p>insert(elem);&#x2F;&#x2F;在容器中插入元素。</p>
</li>
<li><p>clear();&#x2F;&#x2F;清除所有元素</p>
</li>
<li><p>erase(pos);&#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。</p>
</li>
<li><p>erase(beg, end);&#x2F;&#x2F;删除区间[beg,end)的所有元素，返回下一个元素的迭代器。</p>
</li>
<li><p>erase(elem);&#x2F;&#x2F;删除容器中值为elem的元素。</p>
</li>
<li><p>find(key ) ;&#x2F;&#x2F;查找key是否存在,若存在，返回该键的元素的迭代器;若不存在，返回set.end();</p>
</li>
<li><p>count(key);&#x2F;&#x2F;统计key的元素个数,对于set而言统计结果要么是0要么是1</p>
</li>
</ul>
<h3 id="set和multiset区别"><a href="#set和multiset区别" class="headerlink" title="set和multiset区别"></a>set和multiset区别</h3><p>区别:</p>
<ul>
<li>set不可以插入重复数据，而multiset可以</li>
<li>set插入数据的同时会返回插入结果，表示插入是否成功. multiset不会检测数据，因此可以插入重复数据</li>
</ul>
<p>总结:</p>
<ul>
<li>如果不允许插入重复数据可以利用set</li>
<li>如果需要插入重复数据利用multiset</li>
</ul>
<h3 id="pair对组创建"><a href="#pair对组创建" class="headerlink" title="pair对组创建"></a>pair对组创建</h3><p>功能描述:</p>
<ul>
<li>成对出现的数据，利用对组可以返回两个数据</li>
</ul>
<p>两种创建方式:</p>
<ul>
<li>pair&lt;type, tyie&gt; p ( value1, value2 );</li>
<li>pair&lt;type, type&gt; p &#x3D; make_pair( value1，value2 );</li>
</ul>
<h3 id="set容器排序"><a href="#set容器排序" class="headerlink" title="set容器排序"></a>set容器排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class MyCompare&#123;</span><br><span class="line">public:</span><br><span class="line">	bool operator()(int v1,int v2)//重载（），//自定义数据类型都会指定排序规则</span><br><span class="line">	&#123;</span><br><span class="line">		return v1 &gt; v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test()&#123;</span><br><span class="line">	set&lt;int，MyCompare&gt;s2;//要放在插入之前，int与上面传入的数据类型一致,MyCompare是仿函数</span><br><span class="line">	s2.insert(10) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:利用仿函数可以指定set容器的排序规则</p>
<p>总结:<br>对于自定义数据类型，set必须指定排序规则才可以插入数据</p>
<h2 id="map-x2F-multimap容器"><a href="#map-x2F-multimap容器" class="headerlink" title="map&#x2F;multimap容器"></a>map&#x2F;multimap容器</h2><h3 id="map基本概念"><a href="#map基本概念" class="headerlink" title="map基本概念"></a>map基本概念</h3><p>简介:</p>
<ul>
<li>map中所有元素都是pair</li>
<li>pair中第一个元素为key(键值)，起到索引作期，第二个元素为value(实值)·所有元素都会</li>
</ul>
<p>本质:</p>
<ul>
<li>map&#x2F;multimap属于关联式容器，底层结构是用二叉树实现。</li>
</ul>
<p>优点:</p>
<ul>
<li>可以根据key值快速找到value值</li>
</ul>
<p>map和multimap区别:</p>
<ul>
<li>map不允许容器中有重复key值元素</li>
<li>multimap允许容器中有重复key值元素</li>
</ul>
<h3 id="map构造和赋值"><a href="#map构造和赋值" class="headerlink" title="map构造和赋值"></a>map构造和赋值</h3><p>构造:</p>
<ul>
<li>map&lt;T1，T2&gt; mp;&#x2F;&#x2F;map默认构造函数:</li>
<li>map(const ma &amp;mp );&#x2F;&#x2F;拷贝构造函数</li>
</ul>
<p>赋值:</p>
<ul>
<li>map&amp; operator&#x3D;(const map &amp;mp);&#x2F;&#x2F;重载等号操作符</li>
</ul>
<p>总结: map中所有元素都是成对出现，插入数据时候要使用对组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map&lt;int,int&gt;m;//默认构造</span><br><span class="line">m.insert(pair&lt;int, int&gt;(1，10));</span><br></pre></td></tr></table></figure>

<ul>
<li><p>统计大小— size</p>
</li>
<li><p>判断是否为空— empty</p>
</li>
<li><p>交换容器— swap</p>
</li>
<li><p>insert(elem);&#x2F;&#x2F;在容器中插入元素。</p>
</li>
<li><p>clear();&#x2F;&#x2F;清除所有元素</p>
</li>
<li><p>erase(pos);&#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。</p>
</li>
<li><p>erase(beg, end);&#x2F;&#x2F;删除区间[beg,end)的所有元素，返回下一个元素的迭代器。</p>
</li>
<li><p>erase(key);&#x2F;&#x2F;删除容器中值为elem的元素。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m[4] = 40;</span><br><span class="line">//[]不建议插入，用途	可以利用key访问到value</span><br><span class="line">cout &lt;&lt; m[4]&lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<ul>
<li>find(key ) ;&#x2F;&#x2F;查找key是否存在,若存在，返回该键的元素的迭代器;若不存在，返回set.end();返回迭代器，需要迭代器接受map&lt;int,int&gt;: :iterator pos &#x3D; m. find(3) ;</li>
<li>count(key);&#x2F;&#x2F;统计key的元素个数,对于set而言统计结果要么是0要么是1</li>
</ul>
<p>map不允许插入重复key元素，count统计而言结果要么是0要么是1</p>
<p>multimap的count统计可能大于1</p>
<h3 id="map容器排序"><a href="#map容器排序" class="headerlink" title="map容器排序"></a>map容器排序</h3><p>学习目标:</p>
<ul>
<li>map容器默认排序规则为按照key值进行从小到大排序，掌握如何改变排序规则</li>
</ul>
<p>主要技术点:</p>
<ul>
<li>利用仿函数，可以改变排序规则</li>
</ul>
<p>总结:</p>
<ul>
<li>利用仿函数可以指定map容器的排序规则</li>
<li>对于自定义数据类型，map必须要指定排序规则，同set容器</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/08/c%E5%92%8Cc++/%E7%AC%AC%E4%B8%83%E5%A4%A9-c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/08/c%E5%92%8Cc++/%E7%AC%AC%E4%B8%83%E5%A4%A9-c/" class="post-title-link" itemprop="url">第七天 c++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-08 20:26:50" itemprop="dateCreated datePublished" datetime="2023-04-08T20:26:50+08:00">2023-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-28 14:32:11" itemprop="dateModified" datetime="2023-04-28T14:32:11+08:00">2023-04-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="容器算法迭代器初识"><a href="#容器算法迭代器初识" class="headerlink" title="容器算法迭代器初识"></a>容器算法迭代器初识</h1><h2 id="vector存放内置数据类型"><a href="#vector存放内置数据类型" class="headerlink" title="vector存放内置数据类型"></a>vector存放内置数据类型</h2><p>容器:<code>vector</code></p>
<p>算法:<code>for_each</code></p>
<p>迭代器:<code>vector&lt;int&gt;::iterator</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorilhm&gt;</span><br><span class="line">void MyPrint(int val)&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test01() &#123;</span><br><span class="line">	//创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型</span><br><span class="line">	vector&lt;int&gt; v;</span><br><span class="line">	//向容器中放数据</span><br><span class="line">	v.push_back(10);</span><br><span class="line">	v.push_back(20);</span><br><span class="line">	v.push_back(30);</span><br><span class="line">	v.push_back(40);</span><br><span class="line">	//每一个容器都有自己的迭代器,迭代器是用来遍历容器中的元素</span><br><span class="line">	//v.begin()返回迭代器，这个迭代器指向容器中第一个数据</span><br><span class="line">	//v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置</span><br><span class="line">	//vector&lt;int&gt;::iterator拿到vector&lt;int&gt;这种容器的迭代器类型</span><br><span class="line">	vector&lt;int&gt; ::iterator pBegin = v.begin();</span><br><span class="line">	vector&lt;int&gt; ::iterator pEnd = v.end();</span><br><span class="line">	//第—种遍历方式:</span><br><span class="line">	while (pBegin ! = pEnd)&#123;</span><br><span class="line">		cout &lt;&lt;*pBegin &lt;&lt; endl;</span><br><span class="line">		pBegin++;</span><br><span class="line">	&#125;</span><br><span class="line">	//第二种遍历方式:</span><br><span class="line">	for (vector&lt;int&gt; : :iterator it = v.begin(); it != v.end( ); it++) &#123;</span><br><span class="line">		cout &lt;&lt;*it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt;endl;</span><br><span class="line">	//第三种遍历方式:</span><br><span class="line">	//使用STL提供标准遍历算法头文件algorithm</span><br><span class="line">	for_each(v.begin(), v.end( ), MyPrint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Vector容器嵌套容器"><a href="#Vector容器嵌套容器" class="headerlink" title="Vector容器嵌套容器"></a>Vector容器嵌套容器</h2><p>学习目标:</p>
<p>容器中嵌套容器，我们将所有数据进行遍历输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//容器嵌套容器</span><br><span class="line">void test01() &#123;</span><br><span class="line">	vector&lt; vector&lt;int&gt; &gt;v ;</span><br><span class="line">	vector&lt;int&gt; v1;</span><br><span class="line">	vector&lt;int&gt; v2;</span><br><span class="line">	vector&lt;int&gt; v3;</span><br><span class="line">	vector&lt;int&gt; v4;</span><br><span class="line">	for (int i = ; i &lt; 4; i++) &#123;</span><br><span class="line">		v1.push_back(i + 1);</span><br><span class="line">		v2.push_back(i + 2);</span><br><span class="line">		v3.push_back(i + 3);</span><br><span class="line">		v4.push_back(i + 4);</span><br><span class="line">	&#125;</span><br><span class="line">	//将容器元素插入到vector v中</span><br><span class="line">	v.push_back(v1);</span><br><span class="line">	v.push_back(v2);</span><br><span class="line">	v.push_back(v3);</span><br><span class="line">	v.push_back(v4);</span><br><span class="line">	for (vector&lt;vector&lt;int&gt;&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		for (vector&lt;int&gt;: :iterator vit = (*it).begin(); vit != (*it).end(); vit++) </span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt;*vit &lt;&lt; &quot; &quot;;</span><br><span class="line">		&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="string容器"><a href="#string容器" class="headerlink" title="string容器"></a>string容器</h2><h3 id="string赋值操作"><a href="#string赋值操作" class="headerlink" title="string赋值操作"></a>string赋值操作</h3><p>功能描述:</p>
<ul>
<li>给string字符串进行赋值</li>
</ul>
<p>赋值的函数原型:</p>
<ul>
<li>string&amp; operator&#x3D;(const char* s );&#x2F;&#x2F;char*类型字符串赋值给当前的字符串</li>
<li>string&amp; operator&#x3D;(const string &amp;s );&#x2F;&#x2F;把字符串s赋给当前的字符串</li>
<li>string&amp; operator&#x3D;( char c);&#x2F;&#x2F;字符赋值给当前的字符串</li>
<li>string&amp; assign(const char *s ) ;&#x2F;&#x2F;把字符串s赋给当前的字符串</li>
<li>string&amp; assign(const char *s, int n);&#x2F;&#x2F;把字符串s的前n个字符赋给当前的字符串</li>
<li>string&amp; assign( const sting &amp;s );&#x2F;&#x2F;把字符串s赋给当前字符串</li>
<li>string&amp; assign(int n, char c);&#x2F;&#x2F;用n个字符c赋给当前字符串</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void test01()&#123;</span><br><span class="line">	str1 = &quot;hello vorld&quot;;</span><br><span class="line">	cout &lt;&lt; &quot;str1 - &quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">	string str2;</span><br><span class="line">	str2 = str1;</span><br><span class="line">	cout &lt;&lt; &quot;str2 = &quot; &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">	string str3;</span><br><span class="line">	str3 = &#x27;a &#x27;;</span><br><span class="line">	cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">	string str4;</span><br><span class="line">	str4.assign( &quot;hello c++&quot;);</span><br><span class="line">	cout &lt;&lt; &quot;str4 = &quot; &lt;&lt;str4 &lt;&lt; endl;</span><br><span class="line">	string str5;</span><br><span class="line">	str5.assign(&quot;hello c++&quot;,5);</span><br><span class="line">	cout &lt;&lt; &quot;str5 =&lt;&lt; str5 &lt;&lt; endl;</span><br><span class="line">	string str6;</span><br><span class="line">	str6.assign(str5);</span><br><span class="line">	cout &lt;&lt; &quot;str6 = &quot; &lt;&lt; str6 &lt;&lt; endl;</span><br><span class="line">	string str7;</span><br><span class="line">	str7 .assign(5，&#x27;x&#x27;);</span><br><span class="line">	cout &lt;&lt; &quot;str7 = &quot; &lt;&lt; str7 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:<br>string的赋值方式很多,operator&#x3D;这种方式是比较实用的</p>
<h3 id="string字符串拼接"><a href="#string字符串拼接" class="headerlink" title="string字符串拼接"></a>string字符串拼接</h3><p>功能描述:</p>
<ul>
<li>实现在字符串末尾拼接字符串</li>
</ul>
<p>函数原型:</p>
<ul>
<li>string&amp; operator+&#x3D;(const char* str);&#x2F;&#x2F;重载+&#x3D;操作符</li>
<li>string&amp; operator+&#x3D;( const char c);&#x2F;&#x2F;重载+&#x3D;操作符</li>
<li>string&amp; operator+&#x3D;( const string&amp; str);&#x2F;&#x2F;重载+&#x3D;操作符</li>
<li>string&amp; append(const char *s );&#x2F;&#x2F;把字符串s连接到当前字符串结尾</li>
<li>string&amp; append(const char *s, int n);&#x2F;&#x2F;把字符串s的前n个字符连接到当前字符串结尾</li>
<li>string&amp; append(const string &amp;s );&#x2F;&#x2F;同operator+&#x3D;(const string&amp; str)</li>
<li>string&amp; append(const string &amp;s，int pos，int n);&#x2F;&#x2F;字符串s中从pos开始的n个字符连接到字符串结尾</li>
</ul>
<h3 id="string查找和替换"><a href="#string查找和替换" class="headerlink" title="string查找和替换"></a>string查找和替换</h3><p>函数原型:</p>
<ul>
<li>int find(const string&amp; str, int pos &#x3D; 0) const;&#x2F;&#x2F;查找str第一次出现位置,从pos开始查找</li>
<li>int find( cqhst char* s , int pos &#x3D;0) const;&#x2F;&#x2F;查找s第一次出现位置,从pos开始查找</li>
<li>int find(const char* s, int pos， int n) const;&#x2F;&#x2F;从pos位置查找s的前n个字符第一次位置</li>
<li>int find(const char c, int pos &#x3D;0) const;&#x2F;&#x2F;查找字符c第一次出现位置</li>
<li>int rfind(const string&amp; str, int pos &#x3D; npos) const;&#x2F;&#x2F;查找str最后一次位置,从pos开始查找</li>
<li>int rfind(const char* s, int pos &#x3D; npos) const;&#x2F;&#x2F;查找s最后一次出现位置,从pos开始查找</li>
<li>int rfind(const char* s, int pos, int n) const;&#x2F;&#x2F;从pos查找s的前n个字符最后一次位置</li>
<li>int rfind(const char c, int pos &#x3D; npos) const;&#x2F;&#x2F;查找字符c最后一次出现位置</li>
<li>string&amp; replace(int pos, int n, const string&amp; str);&#x2F;&#x2F;替换从pos开始n个字符为字符串str</li>
<li>string&amp; replace(int pos, int n,const char*s );&#x2F;&#x2F;替换从pos开始的n个字符为字符串s</li>
</ul>
<p>总结:</p>
<ul>
<li><p>. find查找是从左往后，rfind从右往左</p>
</li>
<li><p>. find找到字符串后返回查找的第一个字符位置，找不到返回-1</p>
</li>
<li><p>. replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</p>
<hr>
</li>
</ul>
<p>总结:字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大</p>
<hr>
<p>string中单个字符存取方式有两种</p>
<ul>
<li><p>char&amp; operator[](int n);&#x2F;&#x2F;通过[]方式取字符</p>
</li>
<li><p>char&amp; at(int n);&#x2F;&#x2F;通过at方法获取字符</p>
<hr>
</li>
</ul>
<p>函数原型:</p>
<ul>
<li><p>string&amp; insert(int pos, const char* s );&#x2F;&#x2F;插入字符串</p>
</li>
<li><p>string&amp; insert(int pos, const string&amp; str);&#x2F;&#x2F;插入字符串</p>
</li>
<li><p>string&amp; insert(int pos, int n, char c);&#x2F;&#x2F;在指定位置插入n个字符c</p>
</li>
<li><p>string&amp; erase(int pos, int n &#x3D; npos);&#x2F;&#x2F;删除从Pos开始的n个字符</p>
<hr>
</li>
</ul>
<p>函数原型:</p>
<ul>
<li>string substr(int pos &#x3D; 0,int n &#x3D; npos) const;&#x2F;&#x2F;返回由pos开始的n个字符组成的字符串</li>
</ul>
<h2 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h2><h3 id="vector构造函数"><a href="#vector构造函数" class="headerlink" title="vector构造函数"></a>vector构造函数</h3><p>功能描述:</p>
<ul>
<li>创建vector容器</li>
</ul>
<p>函数原型:</p>
<ul>
<li>vector<T> v;&#x2F;&#x2F;采用模板实现类实现，默认构造函数</li>
<li>vector(v.begin(), v.end());&#x2F;&#x2F;将v[begin(), end())区间中的元素拷贝给本身。</li>
<li>vector(n, elem );&#x2F;&#x2F;构造函数将n个elem拷贝给本身。</li>
<li>vector( const vector &amp;vec);&#x2F;&#x2F;拷贝构造函数。</li>
</ul>
<h3 id="vector赋值操作"><a href="#vector赋值操作" class="headerlink" title="vector赋值操作"></a>vector赋值操作</h3><p>函数原型:</p>
<ul>
<li>vector&amp; operator&#x3D;(const vector &amp;vec);&#x2F;&#x2F;重载等号操作符</li>
<li>assign(beg, end);&#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li>assign(n, elem);&#x2F;&#x2F;将n个elem拷贝赋值给本身。</li>
</ul>
<h3 id="vector容量和大小"><a href="#vector容量和大小" class="headerlink" title="vector容量和大小"></a>vector容量和大小</h3><p>函数原型:</p>
<ul>
<li>empty();&#x2F;&#x2F;判断容器是否为空</li>
<li>capacity();&#x2F;&#x2F;容器的容量</li>
<li>size();&#x2F;&#x2F;返回容器中元素的个数</li>
<li>resize(int num);&#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。&#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</li>
<li>resize(int num，elem);&#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。<br>&#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除</li>
</ul>
<h3 id="vector插入和删除"><a href="#vector插入和删除" class="headerlink" title="vector插入和删除"></a>vector插入和删除</h3><p>函数原型:</p>
<ul>
<li>push_back(ele);&#x2F;&#x2F;尾部插入元素ele</li>
<li>pop_back();&#x2F;&#x2F;删除最后一个元素</li>
<li>insert(const_iterator pos,ele);&#x2F;&#x2F;迭代器指向位置pos插入元素ele</li>
<li>insert(const_iterator pos, int cunt,ele);&#x2F;&#x2F;迭代器指向位置pos插入count个元素ele</li>
<li>erase(const_iterator pos);&#x2F;&#x2F;删除迭代器指向的元素</li>
<li>erase(const_iterator start， const_iterator end);&#x2F;&#x2F;删除迭代器从start到end之间的元素</li>
<li>clear();&#x2F;&#x2F;删除容器中所有元素</li>
</ul>
<h3 id="vector互换容器"><a href="#vector互换容器" class="headerlink" title="vector互换容器"></a>vector互换容器</h3><p>函数原型;</p>
<ul>
<li>swap(vec);&#x2F;&#x2F;将vec与本身的元素互换</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void teste2()</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;int&gt; v;</span><br><span class="line">	for (int i - e; i &lt;100000; i++) &#123;</span><br><span class="line">		v.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt;&quot;v的容量为:&quot;&lt;&lt; v.capacity() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt;&quot;v的大小为:&quot;&lt;&lt; v.size() &lt;&lt; endl;</span><br><span class="line">	v.resize(3);</span><br><span class="line">	cout &lt;&lt;“v的容量为:&quot;&lt;&lt; v.capacity() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt;“v的大小为: &quot; &lt;&lt; v.size()&lt;&lt; endl;</span><br><span class="line">	//收缩内存</span><br><span class="line">	vector&lt;int&gt;(v).swap(v); //匿名对象vector&lt;int&gt;(v),读完这行自动被系统删除，匿名对象创建与v.size相同大小的cap和size</span><br><span class="line">	cout &lt;&lt;“v的容量为:&quot;&lt;&lt; v.capacity() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;v的大小为:&quot; &lt;&lt; v.size() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结: swap可以使两个容器互换，可以达到实用的收缩内存效果.</p>
<h3 id="vector预留空间"><a href="#vector预留空间" class="headerlink" title="vector预留空间"></a>vector预留空间</h3><p>功能描述:</p>
<ul>
<li>减少vector在动态扩展容量时的扩展次数</li>
</ul>
<p>函数原型:</p>
<ul>
<li>reserve(int len);&#x2F;&#x2F;容器预留len个元素长度，预留位置不初始化，元素不可访问。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void teste1()</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;int&gt; v;</span><br><span class="line">	//预留空间</span><br><span class="line">	v.reserve ( 100000);</span><br><span class="line">	int num = 0;</span><br><span class="line">	int* p = NULL;</span><br><span class="line">	for (int i = 0; i &lt; 100080; i++) &#123;</span><br><span class="line">		v.push_back(i);</span><br><span class="line">	if (p != &amp;v[0])&#123;</span><br><span class="line">		p = &amp;v[0];//用来计算开辟了多少次内存,如果没有预留内存，则每次vector容量不够会重新分配，即&amp;v[0]会改变</span><br><span class="line">		num++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;&quot;num=&quot;&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:如果数据量较大，可以一开始利用reserve预留空间</p>
<h2 id="C-中resize和reserve的区别"><a href="#C-中resize和reserve的区别" class="headerlink" title="C++中resize和reserve的区别"></a>C++中resize和reserve的区别</h2><p>reserve是设置了capacity的值，比如reserve(20)，表示该容器最大容量为20，但此时容器内还没有任何对象，也<strong>不能通过下标访问</strong>。会发生问题。<br>resize既分配了空间，也创建了对象，可以通过下标访问。<br>reserve只修改capacity大小，不修改size大小，resize既修改capacity大小，也修改size大小。</p>
<p>所以以后访问string容器的值不够用什么方法都需要resize来初始化默认值防止出现错误。</p>
<h2 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h2><h3 id="deque容器基本概念"><a href="#deque容器基本概念" class="headerlink" title="deque容器基本概念"></a>deque容器基本概念</h3><p>功能:</p>
<ul>
<li>双端数组，可以对头端进行插入删除操作</li>
</ul>
<p>deque与vector区别:</p>
<ul>
<li>vector对于头部的插入删除效率低，数据量越大，效率越低.</li>
<li>deque相对而言，对头部的插入删除速度比vector快</li>
<li>vector访问元素时的速度会比deque快,这和两者内部实现有关</li>
</ul>
<p>deque内部工作原理:</p>
<p>deque内部有个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据</p>
<p>中控器维护的是每个缓冲区的地址，使得使用deque时像—片连续的内存空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void printDeque(const deque&lt;int&gt;&amp; d)&#123;//限制不允许修改，只读，则 const_iterator</span><br><span class="line">	for (deque&lt;int&gt; :: const_iterator it = d.begin(); it != d.end(); it++)&#123;</span><br><span class="line">		cout &lt;&lt;*it&lt;&lt;&quot;&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">// deque构造</span><br><span class="line">void teste1()&#123;</span><br><span class="line">	deque&lt;int&gt; d1;//无参构造函数</span><br><span class="line">	for (int i = e; i &lt; 10; i++)&#123;</span><br><span class="line">		d1.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	printDeque(d1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结: deque容器和vector容器的构造方式几乎一致，灵活使用即可</p>
<h3 id="deque赋值操作"><a href="#deque赋值操作" class="headerlink" title="deque赋值操作"></a>deque赋值操作</h3><p>函数原型:</p>
<ul>
<li>deque&amp; operator&#x3D;(const deque &amp;deq);&#x2F;&#x2F;重载等号操作符</li>
<li>assign(beg, end) ;&#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li>assign(n, elem);&#x2F;&#x2F;将n个elem拷贝赋值给本身。</li>
</ul>
<p>函数原型:</p>
<ul>
<li><p>deque.empty();&#x2F;&#x2F;判断容器是否为空</p>
</li>
<li><p>deque.size();&#x2F;&#x2F;返回容器中元素的个数,deque没有容量概念（cap）</p>
</li>
<li><p>deque.resize(num );&#x2F;&#x2F;重新指定容器的长度为num,若容器变长，则以默认值0填充新位置。&#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
<li><p>deque.resize(num，elem);&#x2F;&#x2F;重新指定容器的长度为num,若容器变长，则以elem值填充新位置</p>
<p>&#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
</ul>
<p>总结:</p>
<ul>
<li>deque没有容量的概念</li>
<li>判断是否为空— empty</li>
<li>返回元素个数— size</li>
<li>重新指定个数— resize</li>
</ul>
<h3 id="3-3-5-deque插入和删除"><a href="#3-3-5-deque插入和删除" class="headerlink" title="3.3.5 deque插入和删除"></a>3.3.5 deque插入和删除</h3><p>功能描述:</p>
<ul>
<li>向deque容器中插入和删除数据</li>
</ul>
<p>函数原型:</p>
<p>​	两端插入操作:</p>
<ul>
<li>push_back(elem);&#x2F;&#x2F;在容器尾部添加一个数据</li>
<li>push_front(elem);&#x2F;&#x2F;在容器头部插入一个数据</li>
<li>pop_back();&#x2F;&#x2F;删除容器最后一个数据</li>
<li>pop_front( );&#x2F;&#x2F;删除容器第一个数据</li>
</ul>
<p>指定位置操作:</p>
<ul>
<li>insert(pos,elem) ;&#x2F;&#x2F;在pos位置插入一个elem元素的拷贝，返回新数据的位置。</li>
<li>insert( pos,n,elem);&#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。</li>
<li>insert(pos ,beg,end);&#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。</li>
<li>clear();清空容器的所有数据</li>
<li>erase(beg,end);&#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。</li>
<li>erase(pos);&#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。</li>
</ul>
<p>总结:</p>
<p>插入和删除提供的位置是迭代器!(如d.begin()),还可以</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;int&gt;::iterator it = d1.begin() ;</span><br><span class="line">it++;</span><br><span class="line">d1.erase(it);</span><br></pre></td></tr></table></figure>

<p>尾插— push_back</p>
<p>尾删— pop_back</p>
<p>头插— push_front</p>
<p>头删— pop_front</p>
<hr>
<p>函数原型:</p>
<ul>
<li>at(int idx);&#x2F;&#x2F;返回索引idx所指的数据</li>
<li>operator[]; &#x2F;&#x2F;返回索引idx所指的数据</li>
<li>front( );&#x2F;&#x2F;返回容器中第一个数据元素</li>
<li>back();&#x2F;&#x2F;返回容器中最后一个数据元素</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/08/c%E5%92%8Cc++/c-%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/08/c%E5%92%8Cc++/c-%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">c++ 基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-08 13:49:29" itemprop="dateCreated datePublished" datetime="2023-04-08T13:49:29+08:00">2023-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-28 12:09:19" itemprop="dateModified" datetime="2023-04-28T12:09:19+08:00">2023-04-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h1><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>有两种方法可用于定义类型别名。传统的方法是使用关键字typedef:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef double wages;//wages是 double的同义词</span><br><span class="line"></span><br><span class="line">typedef wages base,*p;//base是double的同义词,p是double*的同义词</span><br></pre></td></tr></table></figure>

<p>新标准规定了一种新的方法，使用别名声明(alias declaration)来定义类型的别名:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using SI = Sales_item;/ /SI是sales_item的同义词</span><br></pre></td></tr></table></figure>

<p>这种方法用关键字using 作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。</p>
<p>例如以下声明中的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef long double DBL;</span><br><span class="line"></span><br><span class="line">我们引入了一个新的类型名称DBL，它是long double的别名，并且具有：</span><br><span class="line"></span><br><span class="line">typedef：存储类说明符</span><br><span class="line"></span><br><span class="line">long double：类型说明符</span><br><span class="line"></span><br><span class="line">DBL：声明符</span><br></pre></td></tr></table></figure>



<h3 id="指针、常量和类型别名"><a href="#指针、常量和类型别名" class="headerlink" title="指针、常量和类型别名"></a>指针、常量和类型别名</h3><p>如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。</p>
<p>例如下面的声明语句用到了类型pstring,它实际上是类型char*的别名:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef char *pstring;</span><br><span class="line">const pstring cstr = 0;// cstr是指向char的常量指针</span><br><span class="line">const pstring *ps;// ps是一个指针，它的对象是指向char的常量指针</span><br></pre></td></tr></table></figure>

<p>上述两条声明语句的基本数据类型都是const pstring，和过去一样，const是对给定类型的修饰。pstring 实际上是指向char的指针，因此，const pstring 就是指向char的常量指针，而非指向常量字符的指针。</p>
<p>遇到一条使用了类型别名的声明语句时，人们往往会错误地尝试把类型别名替换成它本来的样子，以理解该语句的含义:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const char *cstr =0;</span><br><span class="line">//是对const pstring cstr的错误理解</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再强调一遍:这种理解是错误的。声明语句中用到pstring时，其基本数据类型是指针。可是用 char重写了声明语句后，数据类型就变成了char，* 成为了声明符的一部分。这样改写的结果是，const char成了基本数据类型。前后两种声明含义截然不同，前者声明了一个指向char的常量指针,改写后的形式则声明了一个指向const char的指针。主要是看  * 具体跟谁。这里的区别在于，typedef出来的类型是看做一个单独的类型，而char* 这种直接的写法中，char* 才是单独的类型，*需要看做是和p结合在一起，含义不同。</p>
<h2 id="类型说明符"><a href="#类型说明符" class="headerlink" title="类型说明符"></a>类型说明符</h2><p>编程时常常需要把表达式的值赋给变量，这就要求在声明变量的时候清楚地知道表达式的类型。然而要做到这一点并非那么容易，有时甚至根本做不到。为了解决这个问题，C++11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符（比如double）不同，auto让编译器通过初始值来推算变量的类型。显然，auto定义的变量必须有初始值:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//由val1和val2相加的结果可以推断出item的类型</span><br><span class="line">auto item = val1 + val2;// item初始化为vall和val2相加的结果</span><br></pre></td></tr></table></figure>

<p>此处编译器将根据vall和val2相加的结果来推断item的类型。如果val1和val2是类sales item的对象，则item的类型就是Sales_item;如果这两个变量的类型是double，则item的类型就是double，以此类推。</p>
<p>使用auto也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto i = 0, *p=&amp;i;//正确:i是整数、p是整型指针,auto代表int型</span><br><span class="line">auto sz = 0,pi = 3.14;//错误:sz和pi的类型不一致</span><br></pre></td></tr></table></figure>

<p>还可以将引用的类型设为auto，此时原来的初始化规则仍然适用:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto  &amp;g=ci;//g是一个整型常量引用，绑定到ci</span><br><span class="line">auto &amp;h=42;//错误:不能为非常量引用绑定字面值</span><br><span class="line">const auto &amp;j=42; //正确:可以为常量引用绑定字面值</span><br></pre></td></tr></table></figure>

<p>要在一条语句中定义多个变量，切记，符号&amp;和*只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto k=ci, &amp;l= i;//k是整数，1是整型引用</span><br><span class="line">auto &amp;m= ci, *p= &amp;ci;// m是对整型常量(const int)的引用，p是指向整型常量(const int)的指针</span><br><span class="line">//错误:i的类型是int而&amp;ci的类型是const int</span><br><span class="line">auto &amp;n= i, *p2= &amp;ci;//使用引用作为初始类型，初始值中的顶层const属性仍然保存,底层 const 的限制却不能被忽视。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层 const 资格，或者两个对象的数据类型必须能够转换，一般来说，非常量可以转化为常量，反之不行。</span><br></pre></td></tr></table></figure>



<h2 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h2><p>有时会遇到这种情况:希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。为了满足这一要求，C++11新标准引入了第二种类型说明符dec1type，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decltype(f()) sum = x; // sum的类型就是函数f的返回类型</span><br></pre></td></tr></table></figure>

<p>编译器并不实际调用函数f，而是使用当调用发生时f的返回值类型作为sum 的类型。换句话说，编译器为sum 指定的类型是什么呢?就是假如f被调用的话将会返回的那个类型。<br>decltype处理顶层const和引用的方式与auto有些许不同。如果 decltype使用的表达式是一个变量,则decltype返回该变量的类型(包括顶层const和引用在内):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const int ci= 0,&amp;cj=ci;</span><br><span class="line">decltype(ci) x= 0;//x的类型是const int</span><br><span class="line">decltype(cj) y= x;//y的类型是const int&amp;， y绑定到变量x</span><br><span class="line">decltype(cj） z;//错误:z是一个引用，必须初始化</span><br></pre></td></tr></table></figure>

<p>因为cj是一个引用，decltype(cj)的结果就是引用类型，因此作为引用的z必须被初始化。</p>
<p>需要指出的是，引用从来都作为其所指对象的同义词出现，只有用在decltype处是一个例外,作为返回值类型。</p>
<h3 id="decltype-和引用"><a href="#decltype-和引用" class="headerlink" title="decltype 和引用"></a>decltype 和引用</h3><p>如果 decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。如4.1.1节（第120页）将要介绍的，有些表达式将向decltype返回一个引用类型。一般来说当这种情况发生时,意味着该表达式的结果对象能作为一条赋值语句的左值:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// decltype的结果可以是引用类型</span><br><span class="line">int i = 42,*p= &amp;i, &amp;r=i;</span><br><span class="line">decltype(r + 0) b;//正确:加法的结果是int，因此b是一个(未初始化的)int</span><br><span class="line">decltype(*p) c;//错误:c是int&amp;，必须初始化</span><br></pre></td></tr></table></figure>

<p>因为r是一个引用，因此 decltype (r)的结果是引用类型。如果想让结果类型是r所指的类型，可以把r作为表达式的一部分，如r+0，显然这个表达式的结果将是一个具体值而非一个引用。</p>
<p>另一方面，如果表达式的内容是解引用操作，则 decltype 将得到引用类型。正如我们所熟悉的那样，解引用指针可以得到指针所指的对象，而且还能给这个对象赋值。因此，decltype(*p)的结果类型就是int&amp;，而非int。</p>
<p>如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型，切记:decltype ((variable))（注意是双层括号)的结果永远是引用，而decltype(variable)结果只有当variable本身就是一个引用时才是引用。</p>
<blockquote>
<p>赋值是会产生引用的一类典型表达式，<strong>引用的类型就是左值的类型</strong>。也就是说，如果 i 是 int，则表达式 i&#x3D;x 的类型是 int&amp;。根据这一特点，请指出下面的代码中每一个变量的类型和值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) c = a;</span><br><span class="line"><span class="keyword">decltype</span>(a = b) d = a;</span><br><span class="line">a <span class="type">int</span> <span class="number">3</span>；</span><br><span class="line">b <span class="type">int</span> <span class="number">4</span>；</span><br><span class="line">c <span class="type">int</span> <span class="number">3</span>；</span><br><span class="line">d <span class="type">int</span> &amp; <span class="number">3</span>。</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="自定义数据结构"><a href="#自定义数据结构" class="headerlink" title="自定义数据结构"></a>自定义数据结构</h1><h2 id="编写自己的头文件"><a href="#编写自己的头文件" class="headerlink" title="编写自己的头文件"></a>编写自己的头文件</h2><p>为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在头文件的名字应与类的名字一样。例如，库类型string在名为string的头文件中定义。又如,我们应该把Sales_data类定义在名为Sales_data.h的头文件中。</p>
<p>注意：头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明。</p>
<h3 id="预处理器概述"><a href="#预处理器概述" class="headerlink" title="预处理器概述"></a>预处理器概述</h3><p>C++程序还会用到的一项预处理功能是头文件保护符（header guard)，头文件保护符依赖于预处理变量。预处理变量有两种状态:已定义和未定义。#define指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义:#ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到#endif指令为止。<br>使用这些功能就能有效地防止重复包含的发生:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#ifndef SALES_DATA_H</span><br><span class="line">#define SALES_DATA_H</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">struct Sales_data &#123;</span><br><span class="line">	std::string bookNo;</span><br><span class="line">	unsigned units_sold = 0;</span><br><span class="line">	double revenue = 0.0;</span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h1 id="字符串、向量和数组"><a href="#字符串、向量和数组" class="headerlink" title="字符串、向量和数组"></a>字符串、向量和数组</h1><h2 id="命名空间的using声明"><a href="#命名空间的using声明" class="headerlink" title="命名空间的using声明"></a>命名空间的using声明</h2><p>头文件不应包含using声明</p>
<p>位于头文件的代码一般来说不应该使用using声明。这是因为头文件的内容会铂贝到所有引用它的文件中去，如果头文件里有某个using 声明,那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字,反而可能产生始料未及的名字冲突。</p>
<h3 id="使用getline读取一整行"><a href="#使用getline读取一整行" class="headerlink" title="使用getline读取一整行"></a>使用getline读取一整行</h3><p>有时我们希望能在最终得到的字符串中保留输入时的空白符，这时应该用getline函数代替原来的&gt;&gt;运算符。getline函数的参数是一个输入流和一个string对象，函数从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了)，然后把所读的内容存入到那个string对象中去(注意不存换行符)。getline只要一遇到换行符就结束读取操作并返回结果，哪怕输入的一开始就是换行符也是如此。如果输入真的一开始就是换行符，那么所得的结果是个空string。</p>
<p>和输入运算符一样，getline也会返回它的流参数。因此既然输入运算符能作为判断的条件，我们也能用getline的结果作为条件。例如，可以通过改写之前的程序让它一次输出一整行，而不再是每行输出一个词了:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while (getline(cin,line))</span><br><span class="line">	cout&lt;&lt; line &lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>注意：触发getline函数返回的那个换行符实际上被丢弃掉了,得到的string对象中并不包含该换行符。</p>
<h3 id="string-size-type类型"><a href="#string-size-type类型" class="headerlink" title="string:size_type类型"></a>string:size_type类型</h3><p>对于size函数来说，返回一个int或者返回一个 unsigned 似乎都是合情合理的。但其实size函数返回的是一个string: :size type类型的值，下面就对这种新的类型稍作解释。</p>
<p>尽管我们不太清楚string::size_type类型的细节，但有一点是肯定的:它是个<strong>无符号类型</strong>的值,而且能足够存放下任何string对象的大小所有用于存放string类的size函数返回值的变量，都应该是 string::size_type类型的。</p>
<p>在c++11标准中，允许编译器通过auto或者decltype来推断变量的类型:<br>auto len &#x3D; line.size();&#x2F;&#x2F; len的类型是string: :size_type</p>
<p>由于size函数返回的是一个无符号整型数，因此切记，如果在表达式中混用了带符号数和无符号数将可能产生意想不到的结果。例如，假设n是一个具有负值的int,则表达式s.size ()&lt;n的判断结果几乎肯定是true。这是因为负值n会自动地转换成一个比较大的无符号值。</p>
<p>注意：如果一条表达式中已经有了size()函数就不要再使用int了,这样可以避免混用int和unsigned可能带来的问题。</p>
<p>因为某些历史原因，也为了与C兼容,所以C++语言中的字符串字面值（如“hello”）并不是标准库类型string 的对象。切记，字符串字面值与string是不同的类型。</p>
<h4 id="建议-使用C-版本的C标准库头文件"><a href="#建议-使用C-版本的C标准库头文件" class="headerlink" title="建议:使用C++版本的C标准库头文件"></a>建议:使用C++版本的C标准库头文件</h4><p>C++标准库中除了定义C++语言特有的功能外，也兼容了C语言的标准库。C语言的头文件形如name.h,C+则将这些文件命名为cname。也就是去掉了.h后缀，而在文件名 name之前添加了字母c，这里的c表示这是一个属于C语言标准库的头文件。</p>
<p>因此，cctype头文件和ctype.h头文件的内容是一样的，只不过从命名规范上来讲更符合C++语言的要求。特别的,在名为cname的头文件中定义的名字从属于命名空间std，而定义在名为.h的头文件中的则不然。</p>
<p>一般来说，C++程序应该使用名为cname的头文件而不使用name.h的形式，标准库中的名字总能在命名空间std中找到。如果使用.h形式的头文件，程序员就不得不时刻牢记哪些是从C语言那儿继承过来的，哪些又是C++语言所独有的。</p>
<hr>
<p>新的例子不再是统计标点符号的个数了，假设我们想要把字符串改写为大写字母的形式。为了做到这一点可以使用标准库函数 toupper，该函数接收一个字符，然后输出其对应的大写形式。这样，为了把整个string对象转换成大写，只要对其中的每个字符调用toupper函数并将结果再赋给原字符就可以了:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s(&quot;Hello World!!!&quot;);</span><br><span class="line">//转换成大写形式。</span><br><span class="line">for (auto &amp;c :s)//对于s中的每个字符（注意:c是引用)</span><br><span class="line">	c= toupper(c);//c是一个引用，因此赋值语句将改变s中字符的值</span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>每次迭代时，变量c引用string对象s的下一个字符，赋值给c也就是在改变s中对应字符的值。因此当执行下面的语句时，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c= toupper(c);//c是一个引用，因此赋值语句将改变s中字符的值</span><br></pre></td></tr></table></figure>

<p>实际上改变了c绑定的字符的值。整个循环结束后, str 中的所有字符都变成了大写形式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">另一个例子是把s的第一个词改成大写形式:</span><br><span class="line">//依次处理s中的字符直至我们处理完全部字符或者遇到一个空白</span><br><span class="line">for (decltype(s.size()） index = 0;</span><br><span class="line">index != s.size () &amp;&amp; !isspace(s[index]); ++index)</span><br><span class="line">	s [index] = toupper (s[index]);//将当前字符改成大写形式</span><br></pre></td></tr></table></figure>

<p>使用下标时必须确保其在合理范围之内，也就是说，下标必须大于等于0而小于字符串的 size()的值。一种简便易行的方法是，总是设下标的类型为string::size_type，因为此类型是<strong>无符号数，可以确保下标不会小于0</strong>。此时，代码只需保证下标小于size()的值就可以了。</p>
<h2 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h2><p>vector能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，所以不存在包含引用的vector。除此之外，其他大多数（非引用）内置类型和类类型都可以构成vector对象，甚至组成vector的元素也可以是vector.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; V1 (10);//v1有10个元素，每个的值都是0</span><br><span class="line">vector&lt;int&gt; V2&#123;10&#125;;//v2有1个元素，该元素的值是10</span><br><span class="line">vector&lt;int&gt; V3(10,1); // v3有10个元素，每个的值都是1</span><br><span class="line">vector&lt;int&gt; v4&#123;10，1&#125;; // v4有2个元素，值分别是10和1</span><br></pre></td></tr></table></figure>

<p>另一方面，如果初始化时使用了花括号的形式但是提供的值又不能用来列表初始化，就要考虑用这样的值来构造vector对象了。例如，要想列表初始化一个含有string对象的vector对象，应该提供能赋给string对象的初值。此时不难区分到底是要列表初始化 vector对象的元素还是用给定的容量值来构造vector对象:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; v5&#123; &quot;hi&quot;&#125;;//列表初始化:v5有一个元素</span><br><span class="line">vector&lt;string&gt; v6(&quot;hi&quot;);//错误:不能使用字符串字面值构建vector对象</span><br><span class="line">vector&lt;string&gt; v7 &#123;10&#125;;//v7有10个默认初始化的元素</span><br><span class="line">vector&lt;string&gt; v8&#123;10,&quot;hi&quot;&#125;;// v8有10个值为&quot;hi&quot;的元素</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">提示:只能对确知已存在的元素执行下标操作!</span><br><span class="line">关于下标必须明确的一点是:只能对确知已存在的元素执行下标操作。例如，</span><br><span class="line">vector&lt;int&gt; ivec;//空vector对象</span><br><span class="line">cout &lt;&lt; ivec[0];//错误:ivec不包含任何元素</span><br><span class="line">vector&lt;int&gt; ivec2 (10);//含有10个元素的vector对象</span><br><span class="line">cout &lt;&lt; ivec2[10];//错误:ivec2元素的合法索引是从0到9</span><br><span class="line">试图用下标的形式去访问一个不存在的元素将引发错误,不过这种错误不会被编译器发现，而是在运行时产生一个不可预知的值。</span><br><span class="line">不幸的是，这种通过下标访问不存在的元素的行为非常常见，而且会产生很严重的后果。所谓的缓冲区溢出(buffer overflow)指的就是这类错误，这也是导致PC及其他设备上应用程序出现安全问题的一个重要原因。</span><br></pre></td></tr></table></figure>

<h3 id="关键概念-泛型编程"><a href="#关键概念-泛型编程" class="headerlink" title="关键概念:泛型编程"></a>关键概念:泛型编程</h3><p>原来使用C或Java的程序员在转而使用C++语言之后,会对for循环中使用!&#x3D;而非&lt;进行判断有点儿奇怪，C++程序员习惯性地使用!&#x3D;,其原因和他们更愿意使用迭代器而非下标的原因一样:因为这种编程风格在标准库提供的所有容器上都有效。</p>
<p>之前已经说过,只有string和 vector等一些标准库类型有下标运算符,而并非全都如此。与之类似,所有标准库容器的迭代器都定义了&#x3D;&#x3D;和!&#x3D;，但是它们中的大多数都没有定义&lt;运算符。因此,只要我们养成使用迭代器和!-的习惯,就不用太在意用的到底是哪种容器类型。</p>
<h3 id="迭代器类型"><a href="#迭代器类型" class="headerlink" title="迭代器类型"></a>迭代器类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; : :iterator it;	// it能读写vector&lt;int&gt;的元素</span><br><span class="line">string::iterator it2;//it2能读写string对象中的字符</span><br><span class="line">vector&lt;int&gt;: :const_iterator it3;// it3只能读元素，不能写元素</span><br><span class="line">string : :const_iterator it4;// it4只能读字符,不能写字符</span><br></pre></td></tr></table></figure>

<p>const_iterator和常量指针（参见2.4.2节，第56页)差不多，能读取但不能修改它所指的元素值。相反，iterator的对象可读可写。如果vector对象或string对象是一个常量，只能使用const_iterator;如果vector对象或string对象不是常量,那么既能使用iterator也能使用const_iterator。</p>
<h3 id="术语-迭代器和迭代器类型"><a href="#术语-迭代器和迭代器类型" class="headerlink" title="术语:迭代器和迭代器类型"></a>术语:迭代器和迭代器类型</h3><p>迭代器这个名词有三种不同的含义:可能是迭代器概念本身，也可能是指容器定义的迭代器类型,还可能是指某个迭代器对象。</p>
<p>重点是理解存在一组概念上相关的类型，我们认定某个类型是迭代器<strong>当且仅当它支持一套操作</strong>，这套操作使得我们能访问容器的元素或者从某个元素移动到另外一个元素。</p>
<p>每个容器类定义了一个名为 iterator 的类型,该类型支持迭代器概念所规定的一套操作。</p>
<h3 id="结合解引用和成员访问操作"><a href="#结合解引用和成员访问操作" class="headerlink" title="结合解引用和成员访问操作"></a>结合解引用和成员访问操作</h3><p>注意，（*it). empty()中的圆括号必不可少，该表达式的含义是先对it解引用，然后解引用的结果再执行点运算符。如果不加圆括号，点运算符将由it来执行，而非it解引用的结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(*it).empty()//解引用it，然后调用结果对象的empty成员</span><br><span class="line">*it.empty ()//错误:试图访问it的名为empty的成员，但it是个迭代器,</span><br><span class="line">			//没有empty成员</span><br></pre></td></tr></table></figure>

<p>为了简化上述表达式，C++语言定义了箭头运算符(-&gt;)。箭头运算符把解引用和成员访问两个操作结合在一起，也就是说，it-&gt;mem和(*it).mem表达的意思相同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//依次输出text的每一行直至遇到第一个空白行为止</span><br><span class="line">for (auto it = text.cbegin();</span><br><span class="line">	it != text.cend() &amp; &amp; !it-&gt;empty;++it)</span><br><span class="line">	cout&lt;&lt;*it&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>我们首先初始化it令其指向text的第一个元素，循环重复执行直至处理完了text的所有元素或者发现某个元素为空。每次迭代时只要发现还有元素并且尚未遇到空元素，就输出当前正在处理的元素。值得注意的是，因为循环从头到尾只是读取text的元素而未向其中写值，所以使用了<strong>cbegin和 cend</strong>来控制整个迭代过程。</p>
<p>如果对象只需读操作而无须写操作的话最好使用常量类型(比如const_iterator)。为了便于专门得到const iterator类型的返回值,C++11新标准引入了两个新函数,分别是cbegin和 cend:</p>
<p><strong>注意</strong>：<strong>谨记，但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。</strong>（因为每次容量不够时都需要重新创建一个容器，此时迭代器就变了）</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="定义和初始化内置数组"><a href="#定义和初始化内置数组" class="headerlink" title="定义和初始化内置数组"></a>定义和初始化内置数组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">unsigned cnt =42;//不是常量表达式</span><br><span class="line">constexpr unsigned sz = 42;//常量表达式</span><br><span class="line">int arr[10];//含有10个整数的数组</span><br><span class="line">int *parr[sz];//含有42个整型指针的数组</span><br><span class="line">string bad [cnt];//错误:cnt不是常量表达式</span><br><span class="line">string strs[get_size()];//当get_size是constexpr时正确;否则错误</span><br><span class="line">默认情况下，数组的元素被默认初始化</span><br></pre></td></tr></table></figure>

<p>定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。另外和 vector一样，数组的元素应为对象，因此不存在引用的数组。</p>
<h3 id="字符数组的特殊性"><a href="#字符数组的特殊性" class="headerlink" title="字符数组的特殊性"></a>字符数组的特殊性</h3><p>字符数组有一种额外的初始化形式，我们可以用字符串字面值（参见2.1.3节，第36页）对此类数组初始化。当使用这种方式时，一定要注意<strong>字符串字面值的结尾处还有一个空字符</strong>，这个空字符也会像字符串的其他字符一样被拷贝到字符数组中去:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char al[]=[&#x27;C&#x27;, &#x27;+&#x27;,&#x27;+&#x27;&#125;;//列表初始化,没有空字符</span><br><span class="line">char a2[]=&#123;&#x27;C&#x27; + &#x27;+&#x27;，&#x27;+&#x27; + &#x27;\0&#x27;&#125;;//列表初始化，含有显式的空字符</span><br><span class="line">char a3[]=&quot;C++&quot;;//自动添加表示字符串结束的空字符</span><br><span class="line">const char a4[6]=&quot;Daniel&quot;;//错误:没有空间可存放空字符!</span><br></pre></td></tr></table></figure>

<p>al的维度是3,a2和a3的维度都是4,a4的定义是错误的。尽管字符串字面值”Daniel看起来只有6个字符，但是数组的大小必须至少是7，其中6个位置存放字面值的内容，另外1个存放结尾处的空字符。</p>
<h3 id="不允许拷贝和赋值"><a href="#不允许拷贝和赋值" class="headerlink" title="不允许拷贝和赋值"></a>不允许拷贝和赋值</h3><p>不能将数组的内容铂贝给其他数组作为其初始值，也不能用数组为其他数组赋值:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a[]= &#123;0，1，2&#125;;//含有3个整数的数组</span><br><span class="line">int a2[]= a;//错误:不允许使用一个数组初始化另一个数组</span><br><span class="line">a2= a;//错误:不能把一个数组直接赋值给另一个数组</span><br></pre></td></tr></table></figure>

<p>一些编译器支持数组的赋值，这就是所谓的编译器扩展(compiler extension)。但一般来说，最好避免使用非标准特性，因为含有非标准特性的程序很可能在其他编译器上无法正常工作。</p>
<h3 id="理解复杂的数组声明"><a href="#理解复杂的数组声明" class="headerlink" title="理解复杂的数组声明"></a>理解复杂的数组声明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int *ptrs [10];// ptrs是含有10个整型指针的数组</span><br><span class="line">int &amp;refs[10]=/* ?*/;//错误:不存在引用的数组</span><br><span class="line">int (*Parray)[10] =&amp;arr;// Parray指向一个含有10个整数的数组</span><br><span class="line">int (&amp;arrRef)[10]= arr;// arrRef引用一个含有10个整数的数组</span><br></pre></td></tr></table></figure>

<p>默认情况下，类型修饰符从右向左依次绑定。对于ptrs来说，从右向左理解其含义比较简单:首先知道我们定义的是一个大小为10的数组，它的名字是ptrs，然后知道数组中存放的是指向int的指针。</p>
<p>但是对于Parray来说，从右向左理解就不太合理了。因为数组的维度是紧跟着被声明的名字的，所以就数组而言，由内向外阅读要比从右向左好多了。由内向外的顺序可帮助我们更好地理解Parray的含义:首先是圆括号括起来的部分，*Parray意味着Parray是个指针，接下来观察右边，可知道Parray是个指向大小为10的数组的指针,最后观察左边，知道数组中的元素是int。这样最终的含义就明白无误了，Parray是一个指针，它指向一个int 数组，数组中包含10个元素。同理，(&amp;arrRef)表示 arrRef是一个引用，它引用的对象是一个大小为10的数组，数组中元素的类型是int。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int * (&amp;arry)[10] = ptrs;// arry是数组的引用，该数组含有10个指针</span><br></pre></td></tr></table></figure>

<p>按照由内向外的顺序阅读上述语句,首先知道arry是一个引用,然后观察右边知道,arry引用的对象是一个大小为10的数组，最后观察左边知道，数组的元素类型是指向int的指针。这样，arry就是一个含有10个int型指针的数组的引用。</p>
<h2 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h2><p>在使用数组下标的时候，通常将其定义为size_t类型。size_t是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小。在cstddef头文件中定义了size_t类型，这个文件是C标准库stddef.h头文件的C++语言版本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 以10分为一个分数段统计成绩的数量:0~9,10~19,....90~99,100</span><br><span class="line">unsigned scores[11] = &#123;&#125;; //11个分数段，全部初始化为0</span><br><span class="line">unsigned grade;</span><br><span class="line">while (cin &gt;&gt; grade)&#123;</span><br><span class="line">	if (grade &lt;=100)</span><br><span class="line">		++scores [grade/10]; //将当前分数段的计数值加1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与vector和string一样，当需要遍历数组的所有元素时，最好的办法也是使用范围for语句。例如，下面的程序输出所有的scores:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (auto i: scores)//对于scores中的每个计数值</span><br><span class="line">	cout &lt;&lt; i&lt;&lt;&quot;&quot;;//输出当前的计数值</span><br><span class="line">cout&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>因为维度是数组类型的一部分，所以系统知道数组 scores中有多少个元素，使用范围for语句可以减轻人为控制遍历过程的负担。</p>
<h2 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h2><p>在一些情况下数组的操作实际上是指针的操作，这一结论有很多隐含的意思。其中一层意思是当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int ia[] =&#123;0,1,2,3,4,5,6,7,8,9&#125;;// ia是一个含有10个整数的数组</span><br><span class="line">auto ia2(ia);// ia2是一个整型指针，指向ia的第一个元素</span><br><span class="line">ia2 =42;//错误: ia2是一个指针，不能用int值给指针赋值</span><br></pre></td></tr></table></figure>

<p>尽管ia是由10个整数构成的数组，但当使用ia作为初始值时，编译器实际执行的初始化过程类似于下面的形式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto ia2(&amp;ia[0]);//显然ia2的类型是int*</span><br></pre></td></tr></table></figure>

<p>必须指出的是，当使用decltype关键字时上述转换不会发生，decltype(ia)返回的类型是由10个整数构成的数组:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// ia3是一个含有10个整数的数组</span><br><span class="line">decltype(ia) ia3 =&#123;0,1,2,3,4,5,6,7,8,91;</span><br><span class="line">ia3 = p; //错误:不能用整型指针给数组赋值</span><br><span class="line">ia3[4] =i;//正确:把i的值赋给ia3的一个元素</span><br></pre></td></tr></table></figure>

<p>内置的下标运算符可以处理负值，当然，结果地址必须指向原来的指针所指同一数组中的元素(或是同一数组尾元素的下一位置)。</p>
<p>内置的下标运算符所用的索引值不是无符号类型，这一点与vector和string不一样。</p>
<hr>
<p>比较两个C风格字符串的方法和之前学习过的比较标准库string对象的方法大相径庭。比较标准库string对象的时候，用的是普通的关系运算符和相等性运算符;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string sl = &quot;A string example&quot;;</span><br><span class="line">string s2 =&quot;Adifferent string&quot; ;</span><br><span class="line">if (s1 &lt; s2） // false: s2小于s1</span><br></pre></td></tr></table></figure>

<p>如果把这些运算符用在两个C风格字符串上，实际比较的将是指针而非字符串本身:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const char cal[]=&quot;A string example&quot;;</span><br><span class="line">const char ca2[]=&quot;A different string&quot;;</span><br><span class="line">if (cal &lt; ca2)//未定义的:试图比较两个无关地址</span><br></pre></td></tr></table></figure>

<p><strong>注意：对大多数应用来说,使用标准库string要比使用C风格字符串更安全、更高效。</strong></p>
<h2 id="与旧代码的接口"><a href="#与旧代码的接口" class="headerlink" title="与旧代码的接口"></a>与旧代码的接口</h2><p>很多C++程序在标准库出现之前就已经写成了，它们肯定没用到string和 vector类型。而且，有一些C++程序实际上是与C语言或其他语言的接口程序，当然也无法使用C++标准库。因此,现代的C++程序不得不与那些充满了数组和&#x2F;或C风格字符串的代码衔接，为了使这一工作简单易行，C++专门提供了一组功能。</p>
<p>更一般的情况是，任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代:</p>
<ul>
<li>允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值。</li>
<li>在 string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象(不能两个运算对象都是);在 string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。</li>
</ul>
<p>上述性质反过来就不成立了:如果程序的某处需要一个C风格字符串，无法直接用string对象来代替它。例如，不能用string对象直接初始化指向字符的指针。为了完成该功能，string专门提供了一个名为c_str的成员函数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char *str = s;//错误:不能用string对象初始化char*</span><br><span class="line">const char *str = s.c_str();//正确</span><br></pre></td></tr></table></figure>

<p>顾名思义，c_ str函数的返回值是一个C风格的字符串。也就是说，函数的返回结果是一个指针，该指针指向一个以<strong>空字符结束的字符数组</strong>，而这个数组所存的数据恰好与那个string对象的一样。结果指针的类型是const char，从而确保我们不会改变字符数组的内容。</p>
<h3 id="使用数组初始化-vector对象"><a href="#使用数组初始化-vector对象" class="headerlink" title="使用数组初始化 vector对象"></a>使用数组初始化 vector对象</h3><p>介绍过不允许使用一个数组为另一个内置类型的数组赋初值，也不允许使用vector对象初始化数组。相反的，允许使用数组来初始化vector对象。要实现这一目的，只需指明要拷贝区域的首元素地址和尾后地址就可以了:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int int arr[] =&#123;0,1,2,3,4,5);//ivec有6个元素，分别是int_arr中对应元素的副本vector&lt;int&gt; ivec(begin(int_arr) ,end(int_arr));</span><br></pre></td></tr></table></figure>

<h2 id="建议-尽量使用标准库类型而非数组"><a href="#建议-尽量使用标准库类型而非数组" class="headerlink" title="建议:尽量使用标准库类型而非数组"></a>建议:尽量使用标准库类型而非数组</h2><p>使用指针和数组很容易出错。一部分原因是概念上的问题:指针常用于底层操作，因此容易引发一些与烦琐细节有关的错误。其他问题则源于语法错误,特别是声明指针时的语法错误。</p>
<p>现代的C++程序应当尽量使用vector和迭代器，避免使用内置数组和指针;应该尽量使用string,避免使用C风格的基于数组的字符串。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>string和 vector是两种最重要的标准库类型。string对象是一个可变长的字符序列，vector对象是一组同类型对象的容器。</p>
<p>迭代器允许对容器中的对象进行间接访问，对于string对象和vector对象来说，可以通过迭代器访问元素或者在元素间移动。</p>
<p>数组和指向数组元素的指针在一个较低的层次上实现了与标准库类型 string和vector类似的功能。一般来说，应该优先选用标准库提供的类型,之后再考虑C++语言内置的低层的替代品数组或指针。</p>
<p><strong>缓冲区溢出</strong>（buffer overflow)一种严重的程序故障,主要的原因是试图通过一个越界的索引访问容器内容,容器类型包括string、 vector和数组等。</p>
<p><strong>C风格字符串</strong>（C-style string)以空字符结束的字符数组。字符串字面值是C风格字符串，C风格字符串容易出错。</p>
<h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><p>归纳:当一个对象被用作右值的时候，用的是对象的值（内容);当对象被用作左值的时候，用的是对象的身份（在内存中的位置)。</p>
<p>使用关键字decltype的时候，左值和右值也有所不同。如果表达式的求值结果是左值，decltype作用于该表达式(不是变量)得到一个引用类型。举个例子,假定p的类型是 int* ，因为解引用运算符生成左值,所以decltype(*p)的结果是int&amp;。另一方面，因为取地址运算符生成右值，所以decltype (&amp;p)的结果是int**，也就是说，结果是一个指向整型指针的指针。</p>
<p>有4种运算符明确规定了运算对象的求值顺序。第一种是逻辑与（&amp;&amp;）运算符，它规定先求左侧运算对象的值，只有当左侧运算对象的值为真时才继续求右侧运算对象的值。另外三种分别是逻辑或()运算符、条件（?:）运算符和逗号(，)运算符。</p>
<p>求值顺序、优先级、结合律<br>运算对象的求值顺序与优先级和结合律无关,在一条形如f()+g()*h()+j（)的表达式中:如果f、g、h和j是无关函数，它们既不会改变同一对象的状态也不执行IO任务，那么函数的调用顺序不受限制。反之，如果其中某几个函数影响同一对象，则它是一条错误的表达式，将产生未定义的行为。</p>
<p><strong>建议:处理复合表达式</strong></p>
<p>以下两条经验准则对书写复合表达式有益:</p>
<ul>
<li>拿不准的时候最好用括号来强制让表达式的组合关系符合程序逻辑的要求。</li>
<li>如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。第2条规则有一个重要例外,当改变运算对象的子表达式本身就是另外一个子表达式的运算对象时该规则无效。例如，在表达式*++iter中，递增运算符改变iter的值，iter(已经改变）的值又是解引用运算符的运算对象。此时(或类似的情况下),求值的顺序不会成为问题，因为递增运算(即改变运算对象的子表达式)必须先求值,然后才轮到解引用运算。显然，这是一种很常见的用法、不会造成什么问题。</li>
</ul>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool b= true;</span><br><span class="line">bool b2 =-b;</span><br><span class="line">// b2是true!</span><br></pre></td></tr></table></figure>

<p>对大多数运算符来说，布尔类型的运算对象将被提升为 int类型。如上所示，布尔变量b的值为真，参与运算时将被提升成整数值1，对它求负后的结果是-1.将-1再转换回布尔值并将其作为b2的初始值,显然这个初始值不等于0，转换成布尔值后应该为1。所以，b2的值是真!</p>
<p>在除法运算中，如果两个运算对象的符号相同则商为正(如果不为0的话)，否则商为负。C++语言的早期版本允许结果为负值的商向上或向下取整，<strong>C++11</strong>新标准则规定商一律向0取整(即直接切除小数部分)。</p>
<p><strong>建议:除非必须，否则不用递增递减运算符的后置版本</strong></p>
<p>有C语言背景的读者可能对优先使用前置版本递增运算符有所疑问,其实原因非常简单:前置版本的递增运算符避免了不必要的工作，它把值加1后直接返回改变了的运算对象。与之相比，后置版本需要将原始值存储下来以便于返回这个未修改的内容。如果我们不需要修改前的值,那么后置版本的操作就是一种浪费。<br>对于整数和指针类型来说，编译器可能对这种额外的工作进行一定的优化;但是对于相对复杂的迭代器类型，这种额外的工作就消耗巨大了。建议养成使用前置版本的习惯，这样不仅不需要担心性能的问题,而且更重要的是写出的代码会更符合编程的初衷。</p>
<p><strong>建议:简洁可以成为一种美德</strong><br>形如*pbeg++的表达式一开始可能不太容易理解，但其实这是一种被广泛使用的、有效的写法。当对这种形式熟悉之后,书写<br>cout&lt;&lt;  *iter++ &lt;endl;<br>要比书写下面的等价语句更简洁、也更少出错<br>cout &lt;&lt; *iter &lt;&lt;endl;<br>++iter;<br>不断研究这样的例子直到对它们的含义一目了然。大多数C+程序追求简洁、摒弃冗长，因此C++程序员应该习惯于这种写法。而且，一旦熟练掌握了这种写法后，程序出错的可能性也会降低。</p>
<h1 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h1><ul>
<li>sizeof运算符的结果部分地依赖于其作用的类型:</li>
<li>对char或者类型为char的表达式执行sizeof运算，结果得1。</li>
<li>对引用类型执行sizeof运算得到被引用对象所占空间的大小。对指针执行sizeof运算得到指针本身所占空间的大小。</li>
<li>对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小,指针不需有效。</li>
<li>对数组执行sizeof运算得到整个数组所占空间的大小,等价于对数组中所有的元素各执行一次sizeof运算并将所得结果求和。注意，sizeof运算不会把数组转换成指针来处理。</li>
<li>对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。</li>
</ul>
<p>因为执行sizeof运算能得到整个数组的大小，所以可以用数组的大小除以单个元素的大小得到数组中元素的个数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//sizeof(ia)/sizeof(*ia)返回ia的元素数量</span><br><span class="line">constexpr size_t sz =sizeof (ia)/sizeof(*ia);</span><br><span class="line">int arr2[sz];//正确:sizeof返回一个常量表达式</span><br></pre></td></tr></table></figure>

<p>因为sizeof的返回值是一个常量表达式,所以我们可以用sizeof的结果声明数组的维度。</p>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p><strong>何时发生隐式类型转换</strong><br>    在下面这些情况下，编译器会自动地转换运算对象的类型:</p>
<ul>
<li>在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型。</li>
<li>在条件中，非布尔值转换成布尔类型。</li>
<li>初始化过程中，初始值转换成变量的类型;在赋值语句中，右侧运算对象转换成左侧运算对象的类型。</li>
<li>如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型。</li>
<li>函数调用时也会发生类型转换。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s, t= &quot;a value&quot; ;//字符串字面值转换成string类型</span><br><span class="line">while (cin &gt;&gt;S)// while的条件部分把cin转换成布尔值</span><br></pre></td></tr></table></figure>

<p>条件(cin&gt;&gt;s）读入cin的内容并将cin作为其求值结果。条件部分本来需要一个布尔类型的值，但是这里实际检查的是istream类型的值。幸好，IO库定义了从istream向布尔值转换的规则，根据这一规则，cin自动地转换成布尔值。所得的布尔值到底是什么由输入流的状态决定，如果最后一次读入成功，转换得到的布尔值是true:相反，如果最后一次读入不成功，转换得到的布尔值是false。</p>
<h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><p>任何具有明确定义的类型转换，只要不包含底层const（见最下注释），都可以使用static_cast.</p>
<p>基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 typename value = static_cast&lt;typename&gt;(expression);</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 double x = static_cast&lt;double&gt; (y);//y可以是多种类型</span><br></pre></td></tr></table></figure>

<p>实际上，将大型算术类型转换给小型算术类型时很有用(如double转换为int),使用static_cast告诉编译器，我知道会损失精度但是并不在乎，这样编译器就不会发出警告。</p>
<p>更让人高兴的是，static_cast对于编译器无法自动执行的类型转换提供了很好的支持。</p>
<p>static_cast对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用static_cast 找回存在于 void*指针中的值。</p>
<p>当我们把指针存放在void*  中，并且使用static_cast将其强制转换回原来的类型时，应该确保指针的值保持不变。也就是说，强制转换的结果将与原始的地址值相等，因此我们必须确保转换后所得的类型就是指针所指的类型。类型一旦不符，将产生未定义的后果。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 double somevalue = 3.14;</span><br><span class="line">2 void *p = &amp;somevalue;//正确:任何非const对象的地址都能存入void*,但是不能通过p修改somevalue,即不包含底层const</span><br><span class="line">3 double *pd = static_cast&lt;double*&gt;(p);//正确</span><br></pre></td></tr></table></figure>

<p>经过测试，*p和 *pd都是指向somevalue的。</p>
<h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><p>const_cast只能改变运算对象的底层const.<br>语法规则如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 type something = const_cast&lt;type&gt;(expression);</span><br><span class="line">1 const char* pc;</span><br><span class="line">2 char *p = const_cast&lt;char*&gt;(pc);//正确:但是通过p写值是未定义的行为</span><br></pre></td></tr></table></figure>

<p>要注意的是，这种转换只能更改引用或者指针，也就是说下面这种写法是报错的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 const int a = 100;</span><br><span class="line">2 int b = const_cast&lt;int&gt;(a);//error: invalid use of const_cast with type &#x27;int&#x27;, which is not a pointer, reference, nor a pointer-to-data-member type</span><br></pre></td></tr></table></figure>

<p> 对于将常量对象转换成非常量对象的行为，我们称其为“去掉const性质”(cast away the const)，一旦失去了某个对象的const性质，编译器将不再阻止我们对该对象进行修改但是一定要注意的是：如果对象本身是一个常量，将常量转换为非常量后，使用转换后的非常量修改值是未定义行为（undefined behavior），虽然编译器不会报错也不会waring，但是不同的编译器对这种行为有不同的判断，因此这是一种非常危险的行为。但如果对象本身不是一个常量，在cast away the const 后，修改其内容是合法的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void f(int* p) &#123;</span><br><span class="line">  cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">  const int a = 10;</span><br><span class="line">  const int* b = &amp;a;</span><br><span class="line"></span><br><span class="line">  // Function f() expects int*, not const int*</span><br><span class="line">  //   f(b);</span><br><span class="line">  //编译器不允许调用f(b)因为f()的参数为int*不是const int*,此时用const_cast可以去掉const后传递进去</span><br><span class="line">  int* c = const_cast&lt;int*&gt;(b);</span><br><span class="line">  f(c);//c是转换类型得到的，可以调用f(int*)</span><br><span class="line"></span><br><span class="line">  // Lvalue is const</span><br><span class="line">  //  *b = 20;</span><br><span class="line">//不允许*b = 20，这是const_cast规定的，但是实际上不会报错，这是一种未定义行为，不同的编译器有不同的处理结果</span><br><span class="line">  // Undefined behavior</span><br><span class="line">  //  *c = 30;</span><br><span class="line"></span><br><span class="line">  int a1 = 40;</span><br><span class="line">  const int* b1 = &amp;a1;</span><br><span class="line">  int* c1 = const_cast&lt;int*&gt;(b1);//a1 is not a const,so we can use c1 to change the value of al</span><br><span class="line"></span><br><span class="line">  // Integer a1, the object referred to by c1, has</span><br><span class="line">  // not been declared const</span><br><span class="line">  *c1 = 50;</span><br><span class="line">//不过如果原对象本身是非const的，通过c1修改a1是完全安全的</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在早期版本的CH+语言中，显式地进行强制类型转换包含两种形式:</p>
<p>type (expr);&#x2F;&#x2F;函数形式的强制类型转换<br>(type) expr;&#x2F;&#x2F;C语言风格的强制类型转换</p>
<p>与命名的强制类型转换相比,旧式的强制类型转换从表现形式上来说不那么清晰明了，容易被看漏，所以一旦转换过程出现问题,追踪起来也更加困难。</p>
<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">如果需要为某个 case分支定义并初始化一个变量，我们应该把变量定义在块内，从而确保后面的所有case标签都在变量的作用域之外。</span><br><span class="line">case true:</span><br><span class="line">	&#123;</span><br><span class="line">		//正确:声明语句位于语句块内部</span><br><span class="line">		string file_name = get_file_name ();</span><br><span class="line">		// ...</span><br><span class="line">	&#125;</span><br><span class="line">	break;</span><br><span class="line">case false:</span><br><span class="line">	if (file_name. empty())//错误:file _name不在作用域之内,&#123;&#125;内一个作用域</span><br></pre></td></tr></table></figure>

<h2 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h2><p>continue语句（continue statement）终止最近的循环中的当前迭代并立即开始下一次迭代。continue语句只能出现在for、while和 do while循环的内部，或者嵌套在此类循环里的语句或块的内部。和 break语句类似的是，出现在嵌套循环中的continue 语句也仅作用于离它最近的循环。和 break语句不同的是，只有当switch语句嵌套在迭代语句内部时，才能在switch里使用continue。</p>
<h2 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h2><p>和switch 语句类似，goto语句也不能将程序的控制权从变量的作用域之外转移到作用域之内:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	// ...</span><br><span class="line">	goto end;</span><br><span class="line">	int ix = 10;//错误:goto语句绕过了一个带初始化的变量定义</span><br><span class="line">end:</span><br><span class="line">	//错误:此处的代码需要使用ix，但是goto语句绕过了它的声明</span><br><span class="line">	ix=42;</span><br></pre></td></tr></table></figure>

<p>向后跳过一个已经执行的定义是合法的。跳回到变量定义之前意味着系统将销毁该变量，然后重新创建它:	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//向后跳过一个带初始化的变量定义是合法的</span><br><span class="line">begin:</span><br><span class="line">	int sz = get_size() ;</span><br><span class="line">	if(sz &lt;=0） &#123;</span><br><span class="line">		goto begin;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，goto语句执行后将销毁sz。因为跳回到 begin的动作跨过了sz的定义语句，所以sz将重新定义并初始化。</p>
<h2 id="try-语句块和异常处理"><a href="#try-语句块和异常处理" class="headerlink" title="try 语句块和异常处理"></a>try 语句块和异常处理</h2><p>异常是指存在于运行时的反常行为，这些行为超出了函数正常功能的范围。典型的异常包括失去数据库连接以及遇到意外输入等。处理反常行为可能是设计所有系统最难的部分。</p>
<p>异常处理机制为程序中异常检测和异常处理这两部分的协作提供支持。在C++语言中，异常处理包括:</p>
<ul>
<li>throw表达式(throw expression)，异常检测部分使用throw表达式来表示它遇到了无法处理的问题。我们说throw引发（raise）了异常。</li>
<li>try语句块（try block)，异常处理部分使用try语句块处理异常。try语句块以关键字try开始，并以一个或多个catch子句（catch clause）结束。try语句块中代码抛出的异常通常会被某个catch子句处理。因为catch子句“处理”异常，所以它们也被称作异常处理代码（exception handler)。</li>
<li>一套异常类（exception class)，用于在throw表达式和相关的catch子句之间传递异常的具体信息。</li>
</ul>
<h3 id="函数在寻找处理代码的过程中退出"><a href="#函数在寻找处理代码的过程中退出" class="headerlink" title="函数在寻找处理代码的过程中退出"></a>函数在寻找处理代码的过程中退出</h3><p>在复杂系统中，程序在遇到抛出异常的代码前，其执行路径可能已经经过了多个try语句块。例如，一个try语句块可能调用了包含另一个try语句块的函数，新的try语句块可能调用了包含又一个try语句块的新函数，以此类推。</p>
<p>寻找处理代码的过程与函数调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没找到匹配的 catch子句，终止该函数，并在调用该函数的函数中继续寻找。如果还是没有找到匹配的catch子句，这个新的函数也被终止，继续搜索调用它的函数。以此类推，沿着程序的执行路径逐层回退，直到找到适当类型的catch子句为止。</p>
<p>如果最终还是没能找到任何匹配的 catch子句，程序转到名为terminate的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。</p>
<p>对于那些没有任何try语句块定义的异常，也按照类似的方式处理:毕竟,没有try语句块也就意味着没有匹配的catch子句。如果一段程序没有try语句块且发生了异常，系统会调用terminate函数并终止当前程序的执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int i1,i2;</span><br><span class="line">while( std ::cin &gt;&gt; i1 &gt;&gt;i2)&#123;</span><br><span class="line">	try&#123;</span><br><span class="line">		if(i2==0)&#123;</span><br><span class="line">			throw std : : runtime_error ( &quot;divisor can &#x27;t be 0&quot; );</span><br><span class="line">			//将控制权转移到相关的catch子句</span><br><span class="line">		&#125;</span><br><span class="line">		std: : cout &lt;&lt; i1/i2 &lt;&lt; std : : endl;</span><br><span class="line">	&#125;catch(std :: runtime_error err)</span><br><span class="line">	&#123;</span><br><span class="line">		std : : cout &lt;&lt; err.what()</span><br><span class="line">			&lt;&lt;&quot;\ntry again? enter y or n&quot; c&lt; std : :endl;</span><br><span class="line">			char c;</span><br><span class="line">			std: :cin &gt;&gt; c;</span><br><span class="line">		if( !std ::cin ||c == &#x27;n &#x27; ) break;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>try 和 catch,将一段可能抛出异常的语句序列括在花括号里构成try语句块。catch子句负责处理代码抛出的异常。</li>
<li>throw表达式语句,存在于代码块中,将控制权转移到相关的catch子句。</li>
</ul>
<p>异常安全(exception safe）是一个术语，表示的含义是当抛出异常后,程序能执行正确的行为。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">肖汇林</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">肖汇林</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
