<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="选择有时候比努力更重要">
<meta property="og:type" content="website">
<meta property="og:title" content="肖汇林的博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="肖汇林的博客">
<meta property="og:description" content="选择有时候比努力更重要">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="肖汇林">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>肖汇林的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖汇林的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/03/c-%E8%A1%A5%E5%85%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/03/c-%E8%A1%A5%E5%85%85/" class="post-title-link" itemprop="url">c++补充</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-03 16:59:54 / 修改时间：21:49:05" itemprop="dateCreated datePublished" datetime="2023-04-03T16:59:54+08:00">2023-04-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>如果以前使用过C语言，您可能觉得前面讨论的#define语句已经足够完成这样的工作了。但const比#defien好。首先，它能够明确指定类型。其次，可以使用C++的作用域规则将定义限制在特定的函数或文件中（作用域规则描述了名称在各种模块中的可知程度，将在第9章讨论)。第三，可以将const用于更复杂的类型，如第4章将介绍的数组和结构。</p>
<p>提示:如果读者在学习C++之前学习过C语言，并打算使用#define来定义符号常量，请不要这样做，而应使用const。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/03/%E7%AC%AC%E4%BA%94%E5%A4%A9-c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/03/%E7%AC%AC%E4%BA%94%E5%A4%A9-c/" class="post-title-link" itemprop="url">第五天 c++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-03 09:24:35 / 修改时间：16:59:18" itemprop="dateCreated datePublished" datetime="2023-04-03T09:24:35+08:00">2023-04-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="多态的基本概念"><a href="#多态的基本概念" class="headerlink" title="多态的基本概念"></a>多态的基本概念</h3><p>多态是C++面向对象三大特性之一</p>
<p>多态分为两类:</p>
<ul>
<li>静态多态:函数重载和运算符重载属于静态多态，复用函数名</li>
<li>动态多态:派生类和虚函数实现运行时多态</li>
</ul>
<p>静态多态和动态多态区别:</p>
<ul>
<li>静态多态的函数地址早绑定–编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定–运行阶段确定函数地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	// Speak函数就是虚函数</span><br><span class="line">	//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span><br><span class="line">	//vfptr-虚函教（表）指针</span><br><span class="line">	//v- virtual</span><br><span class="line">	//f - function</span><br><span class="line">	//ptr - pointer</span><br><span class="line">	virtual void speak()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;动物在说话&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Cat :public Animal&#123;</span><br><span class="line">public:</span><br><span class="line">	void speak()&#123;</span><br><span class="line">		cout &lt;&lt;&quot;小猫在说话&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">class Dog :public Animal&#123;</span><br><span class="line">public:</span><br><span class="line">	void speak( )&#123;</span><br><span class="line">		cout &lt;&lt;&quot;小狗在说话&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//我们希望传入什么对象，那么就调用什么对象的函数</span><br><span class="line">//如果函数地址在编译阶段就能确定，那么静态联编</span><br><span class="line">//如果函数地址在运行阶段才能确定，就是动态联编</span><br><span class="line"></span><br><span class="line">void DoSpeak( Animal &amp; animal)&#123;//Animal &amp; animal=cat;引用指向子类对象,如果没有virtual，则编译阶段就确定函数调用Animal了，则不能实现动态调用了</span><br><span class="line">	animal.speak( );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//多态满足条件:</span><br><span class="line">//1、有继承关系</span><br><span class="line">//2、子类重写父类中的虚函数，这里就是speak函数</span><br><span class="line">//多态使用:</span><br><span class="line">//父类指针或引用指向子类对象</span><br><span class="line">void test01()&#123;</span><br><span class="line">	Cat cat;</span><br><span class="line">	DoSpeak(cat);//用引用也可以。引用不用手动释放内存。指针不用实例化对象。各有优劣,即引用时不能写成	//DoSpeak(new Cat);</span><br><span class="line">	Dog dog;</span><br><span class="line">	DoSpeak( dog);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    SetConsoleOutputCP(65001);</span><br><span class="line">	test01();</span><br><span class="line">	//test02();</span><br><span class="line">	system( &quot;pause&quot; );</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:</p>
<p>多态满足条件</p>
<ul>
<li>有继承关系</li>
<li>子类<strong>重写</strong>父类中的虚函数</li>
</ul>
<p>多态信用条件</p>
<ul>
<li>父类指针或引用指向子类对象</li>
</ul>
<p>重写:函数返回值类型	函数名	参数列表	完全—致称为重写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//重写	函数返回值类型	函数名参	数列表完全相同</span><br><span class="line">virtual void speak ()</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;”小猫在说话”&lt;&lt; endl:</span><br><span class="line">&#125;</span><br><span class="line">当子类重写父类的虚函数</span><br><span class="line">这里不是子类中的虚函数表内部会替换成子类的虚函数地址，而是添加，因为替换的话，子类的虚函数就会丢失父类的虚函数地址，但实际上子类的虚函数表中同时有父类的虚函数地址和它自己的虚函数地址，通过使用方式不同，如利用父类指针或引用指向子类这种方式，来区分到底是使用子类虚数表里两个虚数表中的哪一个</span><br></pre></td></tr></table></figure>

<h3 id="多态案例一-计算器类"><a href="#多态案例一-计算器类" class="headerlink" title="多态案例一-计算器类"></a>多态案例一-计算器类</h3><p>案例描述:</p>
<p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p>
<p>多态的优点:</p>
<ul>
<li>代码组织结构清晰。可读性强</li>
<li>利于前期和后期的扩展以及维护</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">//普通实现</span><br><span class="line">class calculator &#123;</span><br><span class="line">public:</span><br><span class="line">	int getResult( string oper)&#123;</span><br><span class="line">		if (oper == &quot;+&quot;) &#123;</span><br><span class="line">			return m_Num1 + m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (oper == &quot;-&quot;) &#123;</span><br><span class="line">			return m_Num1 - m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (oper ==“*&quot;)&#123;</span><br><span class="line">			return m_Num1 *m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">	//如果要提供新的运算，需要修改源码</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	int m_Num1;</span><br><span class="line">	int m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line">void teste1()&#123;</span><br><span class="line">	//普通实现测试</span><br><span class="line">	Calculator c;</span><br><span class="line">	c.m_Num1 = 10;</span><br><span class="line">	c.m_Num2 = 10;</span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; c.m_Num2&lt;&lt; &quot; - &quot; &lt;&lt; c.getResult(&quot;+&quot;) &lt;&lt; endl;</span><br><span class="line">	cout &lt; c.m_Num1 &lt;&lt; &quot; . &quot; &lt;&lt; c.m_Num2&lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;-&quot;) &lt;&lt; endl;</span><br><span class="line">	cout &lt; c.m_Num1 &lt;&lt;”*&quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;*&quot;) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//多态实现</span><br><span class="line">//抽象计算器类</span><br><span class="line">//多态优点:代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护</span><br><span class="line">class Abstractcalculator</span><br><span class="line">&#123;</span><br><span class="line">public :</span><br><span class="line">	virtual int getResult()&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">		int m_Num1;</span><br><span class="line">		int m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//加法计算器</span><br><span class="line">class Addcalculator :public Abstractcalculator&#123;</span><br><span class="line">public:</span><br><span class="line">	int getResult()&#123;</span><br><span class="line">		return m_Num1 + m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//减法计算器</span><br><span class="line">class Subcalculator :public Abstractcalculator&#123;</span><br><span class="line">public:</span><br><span class="line">	int getResult()&#123;</span><br><span class="line">		return m_Num1 - m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//乘法计算器</span><br><span class="line">class Mulcalculator :public Abstractcalculator&#123;</span><br><span class="line">public:</span><br><span class="line">	int getResult()&#123;</span><br><span class="line">		return m_Num1 * m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void teste2()&#123;</span><br><span class="line">	//创建加法计算器</span><br><span class="line">	Abstractcalculator *abc = new Addcalculator;//多态使用:</span><br><span class="line">	//父类指针或引用指向子类对象,这里是父类指针指向子类对象</span><br><span class="line">	abc-&gt;m_Num1 = 10;</span><br><span class="line">	abc-&gt;m_Num2 = 10;</span><br><span class="line">	cout &lt; abc-&gt;m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;</span><br><span class="line">	delete abc;//用完了记得销毁</span><br><span class="line">	//创建减法计算器</span><br><span class="line">	abc = new Subcalculator;</span><br><span class="line">	abc-&gt;m_Num1 = 10;</span><br><span class="line">	abc-&gt;m_Num2 = 10;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; -&quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;</span><br><span class="line">	delete abc;</span><br><span class="line">	//创建乘法计算器</span><br><span class="line">	abc = new MulCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = 10;</span><br><span class="line">	abc-&gt;m_Num2 = 10;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt;&quot; * &quot; &lt;&lt; abc-&gt;m_Num2 〈&lt; &quot; - &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;</span><br><span class="line">	delete abc;</span><br><span class="line">	&#125; </span><br></pre></td></tr></table></figure>

<p>总结:C++开发提倡利用多森设计程序架构，因为多态优点很多</p>
<h3 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h3><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p>
<p>因此可以将虚函数改为纯虚函数</p>
<p>纯虚函数语法:virtual 	返回值类型	函数名	(参数列表)&#x3D; 0;</p>
<p>当类中有了纯虚函数，这个类也称为<strong>抽象类</strong></p>
<p>抽象类特点:</p>
<ul>
<li>无法实例化对象</li>
<li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Base&#123;</span><br><span class="line">public:</span><br><span class="line">	//纯虚函数</span><br><span class="line">	//类中只要有一个纯虚函数就称为抽象类</span><br><span class="line">	//抽象类无法实例化对象,但是能定义一个指向该类的指针</span><br><span class="line">	//子类必须重写父类中的纯虚函数，否则也属于抽象类</span><br><span class="line">	virtual void func() = 0;</span><br><span class="line">&#125;;</span><br><span class="line">class Son :public Base&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void func()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;func调用&quot;&lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">void teste1()&#123;</span><br><span class="line">	Base * base = NULL;</span><br><span class="line">	// base = new Base; </span><br><span class="line">	//错误，抽象类无法实例化对象</span><br><span class="line">	base = new Son;</span><br><span class="line">	base-&gt;func( );</span><br><span class="line">	delete base; //记得销毁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h3><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>
<p>解决方式:将父类中的析构函数改为<strong>虚析构</strong>或者纯虚析构</p>
<p>虚析构和纯虚析构共性:</p>
<ul>
<li>可以解决父类指针释放子类对象</li>
<li>都需要有具体的函数实现</li>
</ul>
<p>虚析构和纯虚析构区别:</p>
<ul>
<li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li>
</ul>
<p>虚析构语法:</p>
<p><code>virtual 	~类名( )&#123;&#125;</code></p>
<p>纯虚析构语法:</p>
<p><code>virtual	~类名()= 0;</code></p>
<p><code>类名::~类名()&#123;&#125;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">public:</span><br><span class="line">	Animal()&#123;</span><br><span class="line">	cout &lt;&lt; &quot;Animal构造函数调用!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void Speak() = 0;</span><br><span class="line">	//析构函数加上virtual关键字，变成虚析构函数</span><br><span class="line">	//virtual ~Animal()</span><br><span class="line">	//&#123;</span><br><span class="line">	//cout &lt;&lt; &quot;Animal虚析构函数调用! &quot;&lt;&lt;endl;</span><br><span class="line">    //&#125;</span><br><span class="line">	virtual ~Animal() = 0;</span><br><span class="line">&#125;;</span><br><span class="line">Animal : :~Animal()&#123;</span><br><span class="line">	cout &lt;&lt;&quot;Animal纯虚析构函数调用!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span><br><span class="line">class Cat : public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">	Cat(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;cat构造函数调用!&quot; &lt;&lt;endl;</span><br><span class="line">		m_Name = new string( name);</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void Speak()&#123;</span><br><span class="line">		cout &lt;&lt; *m_Name &lt;&lt;&quot;小猫在说话!&quot;&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~Cat()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;cat析构函数调用!&quot;&lt;&lt; endl;</span><br><span class="line">		if (this-&gt;m_Name != NULL)&#123;</span><br><span class="line">		delete m_Name;</span><br><span class="line">		m_Name = NULL;//置空是为了防止出现野指针</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	string *m_Name;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	Animal *animal = new Cat( &quot;Tom&quot; ) ;</span><br><span class="line">	animal-&gt;Speak();</span><br><span class="line">	//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏</span><br><span class="line">	//怎么解决?给基类增加一个虚析构函数</span><br><span class="line">	//虚析构函数就是用来解决通过父类指针释放子类对象</span><br><span class="line">	delete animal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>1.虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p>
<p>2.如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p>
<p>3.拥有纯虚析构函数的类也属于抽象类</p>
<p>抽象类不能实例化,但是能定义一个指向该类的指针</p>
<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>程序运行时产生的数据都属于临时数据，程序—旦运行结束都会被释放通过文件可以将数据持久化</p>
<p>C++中对文件操作需要包含头文件&lt; fstream &gt;</p>
<p>文件类型分为两种:</p>
<p>1.文本文件-文件以文本的ASCII码形式存储在计算机中</p>
<p>2.二进制文件-文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们</p>
<p>操作文件的三大类:</p>
<ul>
<li>ofstream:写操作</li>
<li>ifstream:读操作</li>
<li>fstream :读写操作</li>
</ul>
<h3 id="写文件步骤如下"><a href="#写文件步骤如下" class="headerlink" title="写文件步骤如下:"></a>写文件步骤如下:</h3><p>1.包含头文件</p>
<p>#include <fstream></p>
<p>2.创建流对象<br>ofstream ofs;&#x2F;&#x2F;读文件则为ifstream ofs</p>
<p>3.打开文件<br>ofs.open(“文件路径”,打开方式);&#x2F;&#x2F;读文件则为ifs.open(“文件路径”,打开方式)</p>
<p>4.写数据</p>
<p>ofs &lt;&lt;”写入的数据”;</p>
<p>5.关闭文件</p>
<p>ofs.close();&#x2F;&#x2F;读文件则为ifs.close()</p>
<p>文件打开方式:</p>
<table>
<thead>
<tr>
<th>打开方式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>ios:inl</td>
<td>为读文件而打开文件</td>
</tr>
<tr>
<td>ios::out</td>
<td>为写文件而打开文件</td>
</tr>
<tr>
<td>ios:.ate</td>
<td>初始位置:文件尾</td>
</tr>
<tr>
<td>ios:.app</td>
<td>追加方式写文件</td>
</tr>
<tr>
<td>ios:trunc</td>
<td>如果文件存在先删除，再创建</td>
</tr>
<tr>
<td>ios:binary</td>
<td>二进制方式</td>
</tr>
</tbody></table>
<p>注意:文件打开方式可以配合使用，利用|操作符</p>
<p>例如:用二进制方式写文件<code>ios ::binary | ios:: out</code></p>
<h3 id="读文件步骤如下"><a href="#读文件步骤如下" class="headerlink" title="读文件步骤如下:"></a>读文件步骤如下:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ifstream ifs;</span><br><span class="line">ifs.open(&quot;test.txt&quot;, ios ::in);</span><br><span class="line">if ( !ifs.is_open())</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt;&quot;文件打开失败”&lt;&lt; endl;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">//第—种方式</span><br><span class="line">//char buf[1024] =&#123; 0 &#125;;</span><br><span class="line">// while (ifs &gt;&gt; buf)</span><br><span class="line">//&#123;</span><br><span class="line">	//cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">	//&#125;</span><br><span class="line">//第二种</span><br><span class="line">//char buf[ 1024] - &#123; 0 &#125;;</span><br><span class="line">// while (ifs.getline(buf,sizeof( buf) )); </span><br><span class="line">//&#123;</span><br><span class="line">	//cout &lt;&lt; buf &lt;&lt; endl;	</span><br><span class="line">//&#125;</span><br><span class="line">//第三种</span><br><span class="line">//string buf;</span><br><span class="line">// while (getline(ifs, buf )) </span><br><span class="line">//&#123;</span><br><span class="line">	//cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">// &#125;</span><br><span class="line">char c;</span><br><span class="line">while ((c = ifs.get()) !=EOF)&#123;//EOF end of file</span><br><span class="line">	cout &lt;&lt; c;</span><br><span class="line">&#125;</span><br><span class="line">ifs.close();</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/02/%E7%AC%AC%E5%9B%9B%E5%A4%A9-c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/02/%E7%AC%AC%E5%9B%9B%E5%A4%A9-c/" class="post-title-link" itemprop="url">第四天 c++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-02 10:18:27 / 修改时间：17:55:52" itemprop="dateCreated datePublished" datetime="2023-04-02T10:18:27+08:00">2023-04-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="C-对象模型和this指针"><a href="#C-对象模型和this指针" class="headerlink" title="C++对象模型和this指针"></a>C++对象模型和this指针</h2><h3 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a>成员变量和成员函数分开存储</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Class Person&#123;</span><br><span class="line">	int m_A; //非静态成员变量 属于类的对象上</span><br><span class="line">	static int m_B;//静态成员变量 不属于类对象上</span><br><span class="line">	void func()&#123;&#125;//非静态成员函数 不属于类对象上,即test02测试空间没有包含  不属于类对象上</span><br><span class="line">	static void func2()&#123;&#125;//静态成员函数 不属于类对象上</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">int Person: :m_B = o;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">Person p ;</span><br><span class="line">//空对象占用内存空间为:1</span><br><span class="line">//C++编译器会给每个空对象也分配一个字节空间，是为了区分空对象占内存的位置</span><br><span class="line">//每个空对象也应该有一个独一无二的内存地址</span><br><span class="line">cout &lt;&lt; &quot;size of p = &quot; &lt;&lt; sizeof(p) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test02()&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	cout &lt;&lt; &quot;size of p = &quot; &lt;&lt; sizeof(p) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码，如果有p1,p2,p3…</p>
<p>每一个调用都是调用同一块内存空间</p>
<h3 id="this指针概念"><a href="#this指针概念" class="headerlink" title="this指针概念"></a>this指针概念</h3><p>接上那么问题是:这—块代码是如何区分那个对象调用自己的呢?</p>
<p>C++通i过提供特殊的对象指针， this指针，解决上述问题。</p>
<p>this指针指向被调用的成员函数所属的对象。</p>
<p>this指针是隐含每一个非静态成员函数内的一种指针。</p>
<p>this指针不需要定义，直接使用即可。</p>
<p>静态函数没有this指针。因为静态函数不属于某个对象。</p>
<p>this指针指向的就是对象,通过*this解引用可以访问该对象本身</p>
<p><strong>this指针的用途</strong>:</p>
<p>当形参和成员变量同名时，可用this指针来区分。</p>
<p>在类的非静态成员函数中返回对象本身，可使用return *this。</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">	Person (int age)&#123;</span><br><span class="line">	this-&gt;age = age;//谁调用Person，this就指向谁，比如Person p1;则this指向p1</span><br><span class="line">	&#125;</span><br><span class="line">	Person&amp; PersonAddAge (Person &amp;p)&#123;//引用指向本身内存。不用引用就是拷贝了,而拷贝指向另一个内存</span><br><span class="line">	//不引用就会直接使用复制构造丽数。因为*this这个对象会在函数结束后销毁</span><br><span class="line">	//引用可以让p2使用同一个内存，而*this指向的就是内存地址，所以不加&amp;后面的</span><br><span class="line">	//p2.PersonAddAge(p1).PersonAddAge(p1).PersonAddAge(pl);就和第一个调用的p2无关了</span><br><span class="line">	this-&gt;age += p.age;</span><br><span class="line">	//this指向p2的指针，而*this指向的就是p2这个对象本体</span><br><span class="line">	return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	int age;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">void test02 ()&#123;</span><br><span class="line">	Person p1(10) ;</span><br><span class="line">	Person p2(10);</span><br><span class="line">	//链式编程思想</span><br><span class="line">	p2.PersonAddAge(p1).PersonAddAge(p1). PersonAddAge(pl);//上面如果不加引用，则后面每次创建都是一个新的对象，则输出总是20</span><br><span class="line">	cout &lt;&lt; &quot;p2的年龄为:&quot;&lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h3><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p>
<p>如果用到this指针，需要加以判断保证代码的健壮性</p>
<p>this指针的本质是指针常量,指针的指向是不可以修改的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">	void showPersonAge()&#123;</span><br><span class="line">	//报错原因是因为传入的指针是为NULL</span><br><span class="line">		if (this == NULL)//保证代码健壮性</span><br><span class="line">		&#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; &quot;age = &quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;//当为null时，this空对象，报错</span><br><span class="line">		&#125;</span><br><span class="line">int age;</span><br><span class="line">&#125; ;</span><br><span class="line">void test()&#123;</span><br><span class="line">	Person *p=NULL;</span><br><span class="line">	p-&gt;showPersonAge();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h3><p>常函数:</p>
<p>成员函数后加const后我们称为这个函数为常函数</p>
<p>常函数内不可以修改成员属性</p>
<p>成员属性声明时加关键字mutable后，在常函数中依然可以修改</p>
<p>常对象:</p>
<p>声明对象前加const称该对象为常对象</p>
<p>常对象只能调用常函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Class Person&#123;</span><br><span class="line">public:</span><br><span class="line">	//this指针的本质是指针常量指针的指向是不可以修改的</span><br><span class="line">	// const Person * const this;</span><br><span class="line">	//在成员函数后面加const，修饰的是this指向，让指针指向的值也不可以修改</span><br><span class="line">	void showPerson() const</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;m_B=100; </span><br><span class="line">		//this-&gt;m_A = 100;</span><br><span class="line">		//this = NULL; //this指针不可以修改指针的指向的</span><br><span class="line">	&#125;</span><br><span class="line">	int m_A;</span><br><span class="line">	mutable int m_B;//特殊变量，即使在常函数中，也可以修改这个值</span><br><span class="line">&#125;;</span><br><span class="line">//常对象</span><br><span class="line">void test02 ()</span><br><span class="line">&#123;</span><br><span class="line">	const Person p;//在对象前加const，变为常对象</span><br><span class="line">	//p.m_A = 100;</span><br><span class="line">	p.m_B = 100; //m_B是特殊值，在常对象下也可以修改</span><br><span class="line">	//常对象只能调用常函数</span><br><span class="line">	p.showPerson () ;</span><br><span class="line">	//P.func ();//如果能调用，则可能会出现m_A被修改，其实是不能修改的。常对象不可以调用普通成员函数，因为普通成员函数可以修改属性,常对象可以修改静态变量的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><h3 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h3><p>在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>
<p>友元的目的就是让—个函数或者类访问另一个类中私有成员</p>
<p>友元的关键字为friend </p>
<p>友元的三种实现</p>
<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Building&#123;</span><br><span class="line">	//goodGay全局函数是 Building好朋友，可以访问Building中私有成员</span><br><span class="line">	//告诉编译器goodGay全局函数是Building类的好朋友，可以访问类中的私有内容</span><br><span class="line">	friend void goodGay(Building *building);</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">//全局函数</span><br><span class="line">void goodGay(Building *building)</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;&quot;好基友全局函数正在访问:&quot;&lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout&lt;&lt;&quot;好基友全局函数正在访问: &quot;&lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	Building building;</span><br><span class="line">	goodGay(&amp;building);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Building;</span><br><span class="line">class goodGay&#123;</span><br><span class="line">public:</span><br><span class="line">	goodGay();</span><br><span class="line">	void visit();</span><br><span class="line">private:</span><br><span class="line">	Building *building;</span><br><span class="line">&#125;;</span><br><span class="line">class Building&#123;</span><br><span class="line">	//告诉编译器goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span><br><span class="line">	friend class goodGay;</span><br><span class="line">public :</span><br><span class="line">	Building();</span><br><span class="line">public:</span><br><span class="line">	string m_sittingRoom;//客厅</span><br><span class="line">private:</span><br><span class="line">	string m_BedRoom; //卧室</span><br><span class="line">&#125;;</span><br><span class="line">Building : : Building()&#123;//类的定义可以在类外进行，所以以后文件太大时，声明在头文件中，定义在源文件中</span><br><span class="line">	this-&gt;m_sittingRoom =&quot;客厅&quot;;</span><br><span class="line">	this-&gt;m_BedRoom =&quot;卧室&quot;;</span><br><span class="line">&#125;</span><br><span class="line">goodGay : : goodGay ()&#123;</span><br><span class="line">	building = new Buildng;//创建一个堆区 </span><br><span class="line">&#125;</span><br><span class="line">void goodGay : : visit()&#123;</span><br><span class="line">	cout &lt;&lt;“好基友正在访问”&lt;&lt; building-&gt;m_sittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt;“好基友正在访问”&lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void teste1()&#123;</span><br><span class="line">	goodGay gg;</span><br><span class="line">	gg.visit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Building;</span><br><span class="line">class goodGay&#123;</span><br><span class="line">public:</span><br><span class="line">	goodGay();</span><br><span class="line">	void visit();//只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span><br><span class="line">	void visit2();</span><br><span class="line">private:</span><br><span class="line">	Building *building;</span><br><span class="line">&#125;;</span><br><span class="line">class Building&#123;</span><br><span class="line">	//告诉编译器goodGay类中的visit成员函数是Building类的好朋友，可以访问到Building类中私有内容</span><br><span class="line">	friend void goodGay::visit();</span><br><span class="line">public :</span><br><span class="line">	Building();</span><br><span class="line">public:</span><br><span class="line">	string m_sittingRoom;//客厅</span><br><span class="line">private:</span><br><span class="line">	string m_BedRoom; //卧室</span><br><span class="line">&#125;;</span><br><span class="line">Building : : Building()&#123;//类的定义可以在类外进行，所以以后文件太大时，声明在头文件中，定义在源文件中</span><br><span class="line">	this-&gt;m_sittingRoom =&quot;客厅&quot;;</span><br><span class="line">	this-&gt;m_BedRoom =&quot;卧室&quot;;</span><br><span class="line">&#125;</span><br><span class="line">goodGay : : goodGay ()&#123;</span><br><span class="line">	building = new Buildng;//创建一个堆区 </span><br><span class="line">&#125;</span><br><span class="line">void goodGay : : visit()&#123;</span><br><span class="line">	cout &lt;&lt;“好基友正在访问”&lt;&lt; building-&gt;m_sittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt;“好基友正在访问”&lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void goodGay : : visit2()&#123;</span><br><span class="line">	cout &lt;&lt;“好基友正在访问”&lt;&lt; building-&gt;m_sittingRoom &lt;&lt; endl;</span><br><span class="line">	//cout &lt;&lt;“好基友正在访问”&lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void teste1()&#123;</span><br><span class="line">	goodGay gg;</span><br><span class="line">	gg.visit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>运算符重载概念:对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>
<h3 id="加号运算符重载"><a href="#加号运算符重载" class="headerlink" title="加号运算符重载"></a>加号运算符重载</h3><p>作用:实现两个自定义数据类型相加的运算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">	person()&#123;&#125;;</span><br><span class="line">	person(int a, int b)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;m_A = a;</span><br><span class="line">		this-&gt;m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line">	//成员函数实现＋号运算符重载</span><br><span class="line">	Person operator+( const Person&amp; p)&#123;</span><br><span class="line">		Person temp;</span><br><span class="line">		temp.m_A = this-&gt;m_A + p.m_A;</span><br><span class="line">		temp.m_B = this-&gt;m_B + p.m_B;</span><br><span class="line">		return temp;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	int m_A;</span><br><span class="line">	int m_B;</span><br><span class="line">&#125;</span><br><span class="line">//全局函数实现+号运算符重载 </span><br><span class="line">//Person operator+( const Person &amp;p1, const Person &amp;p2)&#123;</span><br><span class="line">//	Person temp(0，0);</span><br><span class="line">//	temp.m_A = p1.m_A + p2.m_A;</span><br><span class="line">//	temp.m_B = p1.m_B +p2.m_B;</span><br><span class="line">//&#125;</span><br><span class="line">//运算符重载可以发生函数重载</span><br><span class="line">Person operator+(const Person&amp; p2， int val)</span><br><span class="line">&#123;</span><br><span class="line">	Person temp;</span><br><span class="line">	temp.m_A = p2.m_A + val;</span><br><span class="line">	temp.m_B = p2.m_B + val;</span><br><span class="line">	return temp;</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">	Person p1(10，10);</span><br><span class="line">	Person p2(20，20);</span><br><span class="line">	//成员函数方式</span><br><span class="line">	Person p3 = p2 +p1;//相当于p2.operaor+(p1)</span><br><span class="line">	cout &lt;&lt; &quot;mA: &quot; &lt;&lt;p3.m_A &lt;&lt; &quot; mB: &quot; &lt;&lt; p3.m_B &lt;&lt; endl;</span><br><span class="line">	Person p4 = p3 +10;//相当于operator+(p3,10)</span><br><span class="line">	cout &lt;&lt;“mA: &quot; &lt;&lt;p4.m_A &lt;&lt; &quot; mB : &quot;&lt;&lt; p4.m_B &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结1:对于内置的数据类型的表达式的的运算符是不可能改变的</p>
<p>总结2:不要滥用运算符重载</p>
<h3 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h3><p>作用:可以输出自定义数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">	friend ostream&amp; operator&lt;&lt;(ostream&amp; out，Person&amp; p);</span><br><span class="line">public:</span><br><span class="line">	Person(int a, int b)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;m_A = a;this-&gt;m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line">	//成员函数实现不了p &lt;&lt;cout不是我们想要的效果 </span><br><span class="line">	//void operator&lt;&lt;(Person&amp; p)&#123;</span><br><span class="line">	//&#125;</span><br><span class="line">private :</span><br><span class="line">	int m_A;</span><br><span class="line">	int m_B;</span><br><span class="line">&#125;;</span><br><span class="line">//全局函数实现左移重载</span><br><span class="line">//ostream对象只能有一个</span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; cout，Person&amp; p)&#123;</span><br><span class="line">	out &lt;&lt; &quot;a: &quot; &lt;&lt; p.m_A &lt;&lt; &quot; b:&quot; &lt;&lt; p.m_B;</span><br><span class="line">	return cout;</span><br><span class="line">&#125;</span><br><span class="line">void test() &#123;</span><br><span class="line">	Person p1(10，20);</span><br><span class="line">	cout &lt;&lt;p1 &lt;&lt; &quot;hello world&quot; &lt;&lt;endl;//链式编程,需要返回ostream&amp;,才可以接着后面运算</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:重载左移运算符配合友元可以实现输出自定义数据类型</p>
<h3 id="递增运算符重载"><a href="#递增运算符重载" class="headerlink" title="递增运算符重载"></a>递增运算符重载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class MyInteger &#123;</span><br><span class="line">	friend ostream&amp; operator&lt;&lt;(ostream&amp; out,MyInteger myint);</span><br><span class="line">public:</span><br><span class="line">	MyInteger() &#123;</span><br><span class="line">		m_Num = 0;</span><br><span class="line">	&#125;</span><br><span class="line">	//前置++</span><br><span class="line">	MyInteger&amp; operator++()</span><br><span class="line">	&#123;</span><br><span class="line">		//先++</span><br><span class="line">		m_Num++;</span><br><span class="line">		//再返回自身</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	//后置++</span><br><span class="line">	MyInteger operator++(int) &#123;</span><br><span class="line">		//先返回</span><br><span class="line">		MyInteger temp = *this;//记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++;</span><br><span class="line">		m_Num++;</span><br><span class="line">		return temp;//temp是临时变量，完了会释放，所以不会返回引用</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	int m_Num;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; out,MyInteger myint) &#123;</span><br><span class="line">	out &lt;&lt; myint.m_Num;</span><br><span class="line">	return out;</span><br><span class="line">&#125;</span><br><span class="line">//前置++ 先++ 再返回</span><br><span class="line">void test01() &#123;</span><br><span class="line">	MyInteger myInt;</span><br><span class="line">	cout&lt;&lt;(++myInt)++ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt;myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//后置++ 先返回 再++</span><br><span class="line">void test02() &#123;</span><br><span class="line">	MyInteger myInt;</span><br><span class="line">	cout &lt;&lt; myInt++ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	test01();</span><br><span class="line">	//test02();</span><br><span class="line">	system( &quot;pause&quot; );</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:前置递增返回引用，后置递增返回值</p>
<h3 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h3><p>C++编译器至少给一个类添加4个函数</p>
<ul>
<li>1.默认构造函数(无参，函数体为空)</li>
<li>⒉.默认析构函数(无参，函数体为空)</li>
<li>3.默认拷贝构造函数，对属性进行值拷贝</li>
<li>4.赋值运算符operator&#x3D;,对属性进行值拷贝</li>
</ul>
<p><strong>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">	Person( int age)&#123;</span><br><span class="line">	//将年龄数据开辟到堆区</span><br><span class="line">	m_Age = new int(age);</span><br><span class="line">	&#125;</span><br><span class="line">	//重载赋值运算符</span><br><span class="line">	person&amp; operator=(Person &amp;p)&#123;</span><br><span class="line">		if (m_Age != NULL)&#123;</span><br><span class="line">			delete m_Age;</span><br><span class="line">			m_Age = NULL;</span><br><span class="line">		&#125;</span><br><span class="line">		//编译器提供的代码是浅拷贝</span><br><span class="line">		// m_Age = p.m_Age;</span><br><span class="line">		//提供深拷贝解决浅拷贝的问题</span><br><span class="line">		m_Age = new int(*p.m_Age);</span><br><span class="line">		//返回自身,保证了下面能连等</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	~Person()&#123;</span><br><span class="line">		if (m_Age != NULL)&#123;</span><br><span class="line">			delete m_Age;</span><br><span class="line">			m_Age = NULL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//年龄的指针</span><br><span class="line">	int *m_Age;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()&#123;</span><br><span class="line">	Person p1 (18);</span><br><span class="line">	Person p2(20);</span><br><span class="line">	Person p3( 30);</span><br><span class="line"> 	p3=p2= p1;//赋值操作</span><br><span class="line">	cout &lt;&lt;&quot;p1的年龄为:&quot;&lt;&lt;*p1.m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;p2的年龄为:&quot; &lt;&lt;*p2.m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;p3的年龄为:&quot; &lt;&lt;*p3.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h3><p>作用:重载关系运算符，可以让两个<strong>自定义类型对象</strong>进行对比操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">	Person( string name，int age)&#123;</span><br><span class="line">		this-&gt;m_Name = name;</span><br><span class="line">		this-&gt;m_Age = age;</span><br><span class="line">	&#125;;</span><br><span class="line">	bool operator==(Person &amp; p)&#123;</span><br><span class="line">		if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)&#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	bool operator ! =( Person &amp; p)&#123;</span><br><span class="line">		if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)&#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	string m_Name;</span><br><span class="line">	int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	Person a(&quot;孙悟空&quot;，18);</span><br><span class="line">	Person b(&quot;孙悟空&quot;，18);</span><br><span class="line">	if ( a == b)</span><br><span class="line">	&#123;</span><br><span class="line">    	cout &lt;&lt; &quot;a和b相等”&quot;&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">    cout &lt;&lt; &quot;a和b不等”&quot;&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    if (a !=b)&#123;</span><br><span class="line">		cout &lt;&lt;&quot;a和b不相等&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		cout &lt;&lt; &quot;a和b相等”&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a>函数调用运算符重载</h3><p>函数调用运算符()也可以重载</p>
<p>由于重载后使用的方式非常像函数的调用，因此称为仿函数</p>
<p>仿函数没有固定写法，非常灵活</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class MyPrint&#123;</span><br><span class="line">public:</span><br><span class="line">	void operator()(string text)&#123;</span><br><span class="line">		cout &lt;&lt; text &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()&#123;</span><br><span class="line">	//重载的()操作符也称为仿函数</span><br><span class="line">	MyPrint myFunc;</span><br><span class="line">	myFunc( &quot;hello world&quot; ) ;</span><br><span class="line">&#125;</span><br><span class="line">class MyAdd&#123;</span><br><span class="line">public:</span><br><span class="line">	int operator()(int v1,int v2)&#123;</span><br><span class="line">		return v1 +v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test02()&#123;</span><br><span class="line">	MyAdd add;</span><br><span class="line">	int ret = add(10，10);</span><br><span class="line">	cout &lt;&lt; &quot;ret - &quot; &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">	//匿名对象调用</span><br><span class="line">	cout &lt;&lt;&quot;MyAdd()(100,100) = &quot; &lt;&lt; MyAdd() (100，100) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="继承的基本语法"><a href="#继承的基本语法" class="headerlink" title="继承的基本语法"></a>继承的基本语法</h3><p>继承的好处:减少重复代码</p>
<p>语法:class 	子类:	继承方式	父类</p>
<p>子类也称为派生类</p>
<p>父类也称为基类</p>
<h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p>继承的语法:class子类∶继承方式父类</p>
<p>继承方式一共有三种:</p>
<ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承</li>
</ul>
<p><img src="C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20230402164555514.png" alt="image-20230402164555514"></p>
<p>保护权限和私有权限类外都访问不到。</p>
<h3 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Base&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_A;</span><br><span class="line">protected:</span><br><span class="line">	int m_B;</span><br><span class="line">private:</span><br><span class="line">	int m_c; //私有成员只是被隐藏了，但是还是会继承下去</span><br><span class="line">&#125;;</span><br><span class="line">//公共继承</span><br><span class="line">class Son :public Base&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_D;</span><br><span class="line">&#125;;</span><br><span class="line">void teste1()&#123;</span><br><span class="line">	cout &lt;&lt; &quot;sizeof Son = &quot; &lt;&lt; sizeof(Son)&lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论:父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p>
<h3 id="继承中构造和析构顺序"><a href="#继承中构造和析构顺序" class="headerlink" title="继承中构造和析构顺序"></a>继承中构造和析构顺序</h3><p>子拳继承父类后，当创建子类对象，也会调用父类的构造函数</p>
<p>问题:父类和子类的构造和析构顺序是谁先谁后?</p>
<p>总结:继承中先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p>
<h3 id="4-6-5继承同名成员处理方式"><a href="#4-6-5继承同名成员处理方式" class="headerlink" title="4.6.5继承同名成员处理方式"></a>4.6.5继承同名成员处理方式</h3><p>问题:当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢?</p>
<p>访问子类同名成员直接访问即可</p>
<p>访问父类同名成员需要加作用域</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">	Base()&#123;</span><br><span class="line">		m_A = 100;</span><br><span class="line">	&#125;</span><br><span class="line">	void func()&#123;</span><br><span class="line">		cout &lt;&lt;&quot;Base - func()调用”&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	void func(int a)&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Base - func ( int a)调用&quot;&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	int m_A;</span><br><span class="line">&#125;;</span><br><span class="line">class son : public Base &#123;</span><br><span class="line">public:</span><br><span class="line">	son()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A= 200;</span><br><span class="line">	&#125;</span><br><span class="line">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span><br><span class="line">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span><br><span class="line">	void func()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Son - func()调用&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	int m_A;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()&#123;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; &quot;Son下的m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;Base下的m_A = &quot; &lt;&lt; s.Base::m_A&lt;&lt; endl;</span><br><span class="line">	s.func();</span><br><span class="line">	s.Base::func();</span><br><span class="line">	s.Base::func(10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:<br>1.子类对象可以直接访问到子类中同名成员</p>
<p>2.子类对象加作用域可以访问到父类同名成员</p>
<p>3.当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</p>
<h3 id="继承同名静态成员处理方式"><a href="#继承同名静态成员处理方式" class="headerlink" title="继承同名静态成员处理方式"></a>继承同名静态成员处理方式</h3><p>问题:继承中同名的静态成员在子类对象上如何进行访问?</p>
<p>静态成员和非静态成员出现同名，处理方式—致</p>
<p>·访问子类同名成员直接访问即可</p>
<p>·访问父类同名成员需要加作用域</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">	static void func()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Base - static void func()&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static void func(int a)&#123;</span><br><span class="line">		cout &lt;&lt;&quot;Base - static void func( int a)&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	static int m_A;</span><br><span class="line">&#125;;</span><br><span class="line">int Base::m_A = 100;</span><br><span class="line">class Son : public Base&#123;</span><br><span class="line">public:</span><br><span class="line">	static void func()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Son - static void func()&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	static int m_A;</span><br><span class="line">&#125;;</span><br><span class="line">int Son::m_A = 200;</span><br><span class="line">//同名成员属性</span><br><span class="line">void test01()&#123;</span><br><span class="line">	//通过对象访问</span><br><span class="line">	cout &lt;&lt;“通过对象访问:&quot;&lt;&lt;endl;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; &quot;Son 下m_A =&quot; &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;Base 下m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line">	//通过类名访问</span><br><span class="line">	cout &lt;&lt;“通过类名访问:“ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;Son下m_A = &quot; &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">	cout&lt;&lt; &quot;Base 下m_A = &quot; &lt;&lt;Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//同名成员函数</span><br><span class="line">void test02()&#123;&#125;</span><br><span class="line">	//通过对象访问</span><br><span class="line">	cout &lt;&lt;“通过对象访问:“ &lt;&lt;endl;</span><br><span class="line">	Son s;</span><br><span class="line">	s.func();</span><br><span class="line">	s.Base::func( );</span><br><span class="line">	cout &lt;&lt;“通过类名访问:&quot; &lt;&lt; endl ;</span><br><span class="line">	Son::func();</span><br><span class="line">	son::Base::func();</span><br><span class="line">	//出现同名。子类会隐藏掉父类中所有同名成员函数，需要加作用域访问</span><br><span class="line">	Son::Base::func(100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式(通过对象和通过类名）</p>
<h3 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h3><p>C++允许一个类继承多个类</p>
<p>语法:	class	子类	∶	继承方式	父类1 ，继承方式	父类2…{};</p>
<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>
<p>C++实际开发中不建议用多继承</p>
<p>总结:多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p>
<h3 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line">//继承前加virtual关键字后，变为虚继承//此时公共的父类Animal称为虚基类</span><br><span class="line">class sheep : virtual public Animal&#123;&#125;;</span><br><span class="line">class Tuo: virtual public Animal &#123;&#125;;</span><br><span class="line">class SheepTuo : public Sheep，public Tuo &#123;&#125;;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	sheepTuo st;</span><br><span class="line">	st.Sheep::m_Age = 100;</span><br><span class="line">	st.Tuo::m_Age = 200;//指向的是一样的地址，第二个是后改变的，用后面的数据</span><br><span class="line">	cout &lt;&lt; &quot;st.Sheep::m_Age = &quot;&lt;&lt; st.sheep:: m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;st.Tuo : :m_Age = &quot;&lt;&lt;st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;st.m_Age =&quot; &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:<br>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</p>
<p>利用虚继承可以解决菱形继承问题</p>
<p>虚继承底层原理：</p>
<p><img src="C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20230402175305513.png" alt="image-20230402175305513"></p>
<p>vbptr相当于指针，指向一个虚基类表，表中记录了偏移量，指针加上偏移量，指向了唯一的数据。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/31/%E7%AC%AC%E4%B8%89%E5%A4%A9-c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/31/%E7%AC%AC%E4%B8%89%E5%A4%A9-c/" class="post-title-link" itemprop="url">第三天 c++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-31 09:53:22" itemprop="dateCreated datePublished" datetime="2023-03-31T09:53:22+08:00">2023-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-01 21:04:23" itemprop="dateModified" datetime="2023-04-01T21:04:23+08:00">2023-04-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="函数提高"><a href="#函数提高" class="headerlink" title="函数提高"></a>函数提高</h1><h2 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h2><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p>
<p>语法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">返回值类型	函数名	(参数=默认值)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//参数值传递会覆盖默认参数</span><br><span class="line">int func(int a,int b=20,int c=30)&#123;</span><br><span class="line">return a+b+c;</span><br><span class="line">&#125;</span><br><span class="line">//注意事项</span><br><span class="line">//1.错误，默认参数在前面则后面也必须默认值</span><br><span class="line">//int func2(int a=10,int b,int c)&#123;</span><br><span class="line">//return a+b+c;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//2.如果函数声明有默认值，函数实现的时候不能有默认参数，相反依此</span><br><span class="line">int func2(int a,intb);</span><br><span class="line">int func2(int a=10,int b=10)&#123;</span><br><span class="line">	return a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">func(10,30,30);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//函数重载的注意事项</span><br><span class="line">//1、引用作为重载的条件</span><br><span class="line">void func (int &amp;a)//int &amp;a = 10;不合法</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;func(int &amp;a)调用&quot;&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void func (const int &amp;a) // const int &amp;a = 10;合法代码</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt; &quot;func (const int &amp;a)调用&quot;&lt;&lt; end1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int a=10;</span><br><span class="line">	func(a);//输出第一个</span><br><span class="line">	func(10);//输出第二个</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类中的属性和行为我们统一称为成员</p>
<p>属性称为	成员属性	成员变量</p>
<p>行为称为	成员函数	成员方法</p>
<h2 id="封装意义"><a href="#封装意义" class="headerlink" title="封装意义:"></a>封装意义:</h2><p>类在设计时，可以把属性和行为放在不同的权限下，加以控制访问权限有三种:</p>
<p>1.public	公共权限</p>
<p>2.protected	保护权限</p>
<p>3.private	私有权限<br>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//三种权限</span><br><span class="line">//公共权限public	类内可以访问类外可以访问</span><br><span class="line">//保护权限protected	类内可以访问类外不可以访问</span><br><span class="line">//私有权限private	类内可以访问类外不可以访问</span><br></pre></td></tr></table></figure>

<h2 id="struct和class区别"><a href="#struct和class区别" class="headerlink" title="struct和class区别"></a>struct和class区别</h2><p>在C++中struct和class唯—的区别就在于默认的访问权限不同</p>
<p>区别:<br>struct默认权限为公共</p>
<p>class 默认权限为私有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class C1&#123;</span><br><span class="line">	int m_A;//默认是私有权限</span><br><span class="line">&#125;;</span><br><span class="line">struct C2&#123;</span><br><span class="line">	int m_A;//默认是公共权限</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结构体声明通常不包括public或private的访问修饰符。</p>
<p>struct是为了兼容c而存在的,在以后尽量使用class.</p>
<h2 id="成员属性设置为私有"><a href="#成员属性设置为私有" class="headerlink" title="成员属性设置为私有"></a>成员属性设置为私有</h2><p>优点1:将所有成员属性设置为私有，可以自己控制读写权限。</p>
<p>优点2:对于写权限，我们可以检测数据的有效性。</p>
<h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">	//1.构造函数</span><br><span class="line">	//没有返回值不用写void//函数名与类名相同</span><br><span class="line">	//构造函数可以有参数，可以发生重载</span><br><span class="line">	//创建对象的时候，构造函数会自动调用，而且只调用一次</span><br><span class="line">	Person()</span><br><span class="line">	&#123;</span><br><span class="line">	cout &lt;&lt;&quot;Person构造函数的调用&quot;&lt;&lt; end1;</span><br><span class="line">	&#125;</span><br><span class="line">	Person(int age)</span><br><span class="line">	&#123;</span><br><span class="line">	cout &lt;&lt;&quot;Person有参构造函数的调用&quot;&lt;&lt; end1;</span><br><span class="line">	&#125;</span><br><span class="line">	//1.2拷贝构造函数</span><br><span class="line">	Person( const Person &amp;p )&#123;</span><br><span class="line">	//将传入的人身上的所有属性，拷贝到我身上</span><br><span class="line">	age = p.age;</span><br><span class="line">	&#125;</span><br><span class="line">	//2.析构函数进行清理的操作</span><br><span class="line">	//没有返回值不写void</span><br><span class="line">	//函数名和类名相同在名称前加~</span><br><span class="line">	//析构函数不可以有参数的，不可以发生重载</span><br><span class="line">	//对象在销毁前会自动调用析构函数，而且只会调用一次</span><br><span class="line">	~Person()</span><br><span class="line">	&#123;</span><br><span class="line">	cout &lt;&lt;&quot;Person析构函数的调用&quot;&lt;&lt; end1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">	Person p2=Person(10);//有参构造，也可写成Person p2(10);</span><br><span class="line">	Person p3=Person(p2);//拷贝构造,也可写成Person p3(p2);</span><br><span class="line">	//注意:调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明(void fuc();)</span><br><span class="line">	Person p2();</span><br><span class="line">	Person(10);//匿名对象﹑特点:当前行执行结束后，系统会立即回收掉匿名对象</span><br><span class="line">	//不要利用拷贝构造函数初始化匿名对象瞭编译器会认为Person (p3) === Person p3;</span><br><span class="line">	//Person(p3);//错误的</span><br><span class="line">	//3、隐式转换法</span><br><span class="line">	Person p4 = 10; //相当于写了Person p4 = Person(10) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造和析构都是必须有的实现，如果我们自己不提供，编译器会提供一个空实现的构造和析构</p>
<h2 id="拷贝构造函数调用时机"><a href="#拷贝构造函数调用时机" class="headerlink" title="拷贝构造函数调用时机"></a>拷贝构造函数调用时机</h2><p>C++中拷贝构造函数调用时机通常有三种情况：</p>
<p>使用一个已经创建完毕的对象来初始化一个新对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p2=Person(10);//有参构造，也可写成Person p2(10);</span><br><span class="line">Person p3=Person(p2);//拷贝构造,也可写成Person p3(p2);</span><br></pre></td></tr></table></figure>



<p>值传递的方式给函数参数传值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void doWork ( Person p)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void test02()&#123;</span><br><span class="line">	Person p;//相当于值传递，调用了拷贝函数</span><br><span class="line">	doWork(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以值方式返回局部对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person doWork2()&#123;</span><br><span class="line">	Person pl;</span><br><span class="line">	return p1;//p1是局部对象，会拷贝一个新的person类型返回</span><br><span class="line">&#125;</span><br><span class="line">void test03 ()&#123;</span><br><span class="line">	Person p = doWork2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造函数调用规则"><a href="#构造函数调用规则" class="headerlink" title="构造函数调用规则"></a>构造函数调用规则</h2><p>默认情况下，c++编译器至少给一个类添加3个函数</p>
<p>1．默认构造函数(无参，函数体为空)</p>
<p>2．默认析构函数(无参，函数体为空)</p>
<p>3．默认拷贝构造函数，对属性进行值拷贝</p>
<p>构造函数调用规则如下:</p>
<ul>
<li>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造。</li>
<li>如果用户定义拷贝构造函数，C++不会再提供其他构造函数。（拷贝构造函数也是有参数的，所以编译器不会提供无参构造函数了）</li>
</ul>
<h2 id="4-2-5深拷贝与浅拷贝"><a href="#4-2-5深拷贝与浅拷贝" class="headerlink" title="4.2.5深拷贝与浅拷贝"></a>4.2.5深拷贝与浅拷贝</h2><p>深浅拷贝是面试经典问题，也是常见的一个坑</p>
<p>浅拷贝:简单的赋值拷贝操作</p>
<p>深拷贝:在堆区重新申请空间，进行拷贝操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Person (int age , int height)</span><br><span class="line">&#123;</span><br><span class="line">	m_Age = age;</span><br><span class="line">	m_Height =new int(height) ;//创建堆区</span><br><span class="line">	cout &lt;&lt; &quot;Person的有参构造函数调用&quot;&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">/*自己实现拷贝构造函数解决浅拷贝带来的问题</span><br><span class="line">若不自己实现，则有问题，浅拷贝是对成员变量的简单赋值,拷贝时会直接拷贝堆的地址,所以p2的height指针=p1的height指针,即两个height指针指向堆区的同一个地址</span><br><span class="line">p2在进行拷贝初婚化时使用的是编译器提供的浅拷贝</span><br><span class="line">函数test01结束后，p1和p2把同一个空间释放了两次。所以程序崩了</span><br><span class="line">*/</span><br><span class="line">Person(const Person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;Person拷贝构造函数调用&quot;&lt;&lt; endl;</span><br><span class="line">	m_Age = p.m_Age;</span><br><span class="line">	//m_Height = p.m_Height;编译器默认实现就是这行代码</span><br><span class="line">	//深拷贝操作</span><br><span class="line">	m_Height = new int(*p.m_Height) ;</span><br><span class="line">&#125;</span><br><span class="line">~Person()</span><br><span class="line">&#123;</span><br><span class="line">//析构代码，将堆区开辟数据做释放操作</span><br><span class="line">	if (m_Height != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		delete m_Height;</span><br><span class="line">		m_Height = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt;&quot;Person的析构函数调用&quot;&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">	int m_Age;</span><br><span class="line">	int *m_Height;</span><br></pre></td></tr></table></figure>

<p>总结:如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p>
<h2 id="4-2-6初始化列表"><a href="#4-2-6初始化列表" class="headerlink" title="4.2.6初始化列表"></a>4.2.6初始化列表</h2><p>作用:</p>
<p>C++提供了初始化列表语法，用来初始化属性</p>
<p>语法:构造函数()∶属性1(值1) ,属性2(值2) … {}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">	//初始化列表初始化属性</span><br><span class="line">    Person(int a, int , int c) :m_A(a), m_B(b), m_c(c)</span><br><span class="line">    &#123;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &#125;</span><br><span class="line">    int m_A;</span><br><span class="line">    int m_B;</span><br><span class="line">    int m_C;</span><br></pre></td></tr></table></figure>

<h2 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h2><p>C++类中的成员可以是另一个类的对象，我们称该成员为对象成员<br>例如∶</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;&#125;</span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">	A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>B类中有对象A作为成员，A为对象成员</p>
<p>当其他类对象作为本类成员，构造时候先构造类对象(A)，再构造自身(B ),析构的顺序与构造相反，取木块同理。不可能直接取前面的那个，只有将后面的先取出来才能取到前面的那个。<br>而创建对象也是。我需要用phone对象补全person就需要先创建phone而person因为在后面，所以取的时候先取它。</p>
<h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p>
<p>静态成员分为:</p>
<ul>
<li>静态成员变量</li>
</ul>
<p>所有对象共享同一份数据。</p>
<p>在编译阶段分配内存。编译阶段就分配内存─代码还未开始前(即程序还未运行前),在全局区优先分配好内存</p>
<p>类内声明，类外初始化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	//1所有对象都共享同一份数据</span><br><span class="line">	//2编译阶段就分配内存</span><br><span class="line">	//3类内声明，类外初始化操作</span><br><span class="line">	static int m_A;</span><br><span class="line">private:</span><br><span class="line">	static int m_B;//静态成员变量也是有访问权限的，私有的类外访问不到</span><br><span class="line">&#125;;</span><br><span class="line">int Person::m_A = 100;//这里强调一下，是必须在类外写一下，否则报错，可以不付初值，默认初值是0,加Person是为了说明他是Person类的static </span><br><span class="line">int Person::m_B = 100;</span><br><span class="line">void test()&#123;</span><br><span class="line">	//静态成员变量不属于某个对象上，所有对象都共享同一份数据</span><br><span class="line">	//因此静态成员变量有两种访问方式</span><br><span class="line">	//1、通过对象进行访问</span><br><span class="line">	Person p;</span><br><span class="line">	cout &lt;&lt; p.m_A &lt;&lt; endl;</span><br><span class="line">	//2、通过类名进行访问</span><br><span class="line">	cout &lt;&lt;Person::m_A &lt;&lt; end1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>静态成员函数</li>
</ul>
<p>所有对象共享同一个函数</p>
<p>静态成员函数只能访问静态成员变量，因为如果静态成员函数里有非静态成员变量，class会判断不出非静态成员变量是在什么地方定义的,所以无法确定是否是类成员</p>
<p>静态成员函数也是有访问权限的，私有的类外访问不到静态成员函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//因此静态函数有两种访问方式</span><br><span class="line">	//1、通过对象进行访问</span><br><span class="line">	Person p;</span><br><span class="line">	p.func();</span><br><span class="line">	//2、通过类名进行访问</span><br><span class="line">	Person::func();</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/30/%E7%AC%AC%E4%BA%8C%E5%A4%A9-c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/30/%E7%AC%AC%E4%BA%8C%E5%A4%A9-c/" class="post-title-link" itemprop="url">第二天 c++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-30 16:01:35 / 修改时间：22:02:12" itemprop="dateCreated datePublished" datetime="2023-03-30T16:01:35+08:00">2023-03-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h1><p>指针变量指向内存中编号为0的空间</p>
<p>用途:初始化指针变量</p>
<p>注意:空指针指向的内存（0-255）是不可以访问的，因为这些初始化的内存往往是系统的一些中断，若想赋值，只能定义其它数值，再把地址赋予指针变量，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">int b = 20;</span><br><span class="line">int *p=nullptr;</span><br><span class="line">p=&amp;a;</span><br><span class="line">cout &lt;&lt;*p &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h1 id="const修饰指针"><a href="#const修饰指针" class="headerlink" title="const修饰指针"></a>const修饰指针</h1><p>理解一个<strong>指针常量</strong>的地址是固定的不能更改（int * const p;），但是该地址里面的值是可以更改的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int * const p=&amp;a;</span><br><span class="line">*p=100;//正确的</span><br><span class="line">p=&amp;b;//错误的</span><br></pre></td></tr></table></figure>

<p><strong>常量指针</strong>的地址可变（const int *p;），但是值不能变。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const int *p=&amp;a;</span><br><span class="line">*p=100;//错误的</span><br><span class="line">p=&amp;b;//正确的，可以改变指向来改变值</span><br></pre></td></tr></table></figure>

<p>const即修饰指针,又修饰常量，指针指向和指向的值都不能变(const int * const p;)。</p>
<p>connst是一个c语言的关键字，具有着举足轻重的地位。它限定一个变量不允许被改变，产生静态作用。使用const在一定程度上可以提高程序的安全性和可靠性。</p>
<p>const修饰规律:修饰的是什么，什么不能（通过此变量)改变。</p>
<p>const修饰结构体（如const student *stu）,可以防止误操作修改stu的值。</p>
<p>其实本质上const关键字只是告诉编译器该修饰的变量不可以被修改，并不能改变它修饰的变量在内存中所存放的区域。即const修饰的全局变量还是在全局区，但是修饰局部变量则在局部区。</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">system(&quot;pause&quot;);//按任意键继续</span><br><span class="line">system(&quot;cls&quot;);//清屏</span><br></pre></td></tr></table></figure>

<h1 id="内存分区模型"><a href="#内存分区模型" class="headerlink" title="内存分区模型"></a>内存分区模型</h1><p>代码区:存放函数体的二进制代码，由操作系统进行管理的·全局区:存放全局变量和静态变量以及常量。</p>
<p>栈区:由编译器自动分配释放,存放函数的参数值,局部变量等。</p>
<p>堆区:由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收。</p>
<p>内存四区意义:</p>
<p>不同区域存放的数据，赋予不同的生命周期,给我们更大的灵活编程。</p>
<h2 id="程序运行前"><a href="#程序运行前" class="headerlink" title="程序运行前"></a>程序运行前</h2><p>在程序<strong>编译</strong>后，生成了exe可执行程序，<strong>未执行</strong>该程序前分为两个区域</p>
<p><strong>代码区</strong>:</p>
<p>存放CPU执行的机器指令</p>
<p>代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可代码区是只读的，使其</p>
<p>只读的原因是防止程序意外地修改了它的指令</p>
<p><strong>全局区</strong>:</p>
<p>全局变量和静态变量存放在此.全局区还包含了常量区,字符串常量和其他常量也存放在此.该区域的数据在程序结</p>
<p>后由操作系统释放.</p>
<h2 id="程序运行后"><a href="#程序运行后" class="headerlink" title="程序运行后"></a>程序运行后</h2><p><strong>栈区</strong>：</p>
<p>由编译器自动分配释放,存放函数的参数值,局部变量等。</p>
<p>注意事项:不要返回局部变量的地址，栈区开辟的数据由编译器自动释放。</p>
<p><strong>堆区：</strong></p>
<p>由程序员分配释放,若程序员不释放,程序结束时由操作系统回收。在C++中主要利用new在堆区开辟内存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//利用new关键字，可以将数据开辟到堆区,new返回的该数据类型的指针。</span><br><span class="line">//指针本质也是局部变量，放在栈上，指针保存的数据是放在堆区。</span><br><span class="line">int *p=new int(10);//堆区存放10，p是地址</span><br><span class="line">int *arr=new int[10];//创建数组，10个连续的地址</span><br><span class="line">delete[] arr;//释放数组要加[]</span><br><span class="line">delete p;//释放内存</span><br></pre></td></tr></table></figure>

<p>不释放动态内存有个专有名词，叫内存泄漏，内存泄漏就是这块数据已经不需要了，但是没有将这块数据清除，</p>
<p>会一直占用内存，这就是内存泄漏。内存数据放硬盘上的操作叫进程的挂起。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//引用基本语法</span><br><span class="line">//数据类型 &amp;别名=原名</span><br><span class="line">int a = 10;</span><br><span class="line">//创建引用</span><br><span class="line">int &amp;b = a;</span><br><span class="line">cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; end1;</span><br><span class="line">cout &lt;&lt; &quot;b = &quot; &lt;&lt; b&lt;&lt; endl;//两个输出一样,即两个指向同一个地址</span><br></pre></td></tr></table></figure>

<h2 id="引用注意事项"><a href="#引用注意事项" class="headerlink" title="引用注意事项"></a>引用注意事项</h2><p>引用必须初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int &amp;b;//错误的</span><br></pre></td></tr></table></figure>

<p>引用在初始化后，不可以改变。即b已经是a的别名，则不能是c的别名。</p>
<h2 id="引用做函数参数"><a href="#引用做函数参数" class="headerlink" title="引用做函数参数"></a>引用做函数参数</h2><p><strong>作用</strong>:函数传参时，可以利用引用的技术让形参修饰实参。</p>
<p><strong>优点</strong>:可以简化指针修改实参</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void swap(&amp;a,&amp;b)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">swap(a,b);//引用传递，形参会修饰实参的,在传递时就已经初始化了，即&amp;a=a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单。</p>
<h2 id="引用做函数的返回值"><a href="#引用做函数的返回值" class="headerlink" title="引用做函数的返回值"></a>引用做函数的返回值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//1、不要返回局部变量的引用</span><br><span class="line">int&amp; test01()</span><br><span class="line">&#123;</span><br><span class="line">int a = 10;//局部变量存放在四区中的栈区</span><br><span class="line">return a;//返回的是int&amp;类型</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//2、函数的调用可以作为左值,即在main函数可以这样写test02()=1000；则ref输出也会变1000</span><br><span class="line">//返回静态变量引用</span><br><span class="line">int&amp; test02()</span><br><span class="line">&#123;</span><br><span class="line">static int a = 20;//此时可以输出正确，因为static</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int &amp;ref = test01();//接受的也需要int&amp;类型,&amp;ref是a的别名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;&quot;ref=&quot;&lt;&lt;ref&lt;&lt;endl;//第一次结果正确，是因为编译器做了保留，局部变量的返回也是如此</span><br><span class="line">Cout&lt;&lt;“ref=“&lt;&lt;ref&lt;&lt;endl;//第二次结果错误，因为a的内存已经释放</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h2><p>引用相当于指针常量，指向的值能改但指向不能改（即指向地址不变）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int&amp; ref=a;//自动转换为int * const ref=&amp;a;</span><br><span class="line">ref=20;//内部发现ref是引用，自动转换为：*ref =20;</span><br></pre></td></tr></table></figure>

<p>指针常量是不能拿函数当左值的,所以引用不仅仅是懒人版指针。</p>
<p>引用的地址和原变量是一样的，指针和原变量的地址不一样。所以引用更省空间。</p>
<p>结论:C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了。 </p>
<h2 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//引用通常修饰形参（val）</span><br><span class="line">void showValue(const int &amp;val)&#123;</span><br><span class="line">	//val=1000;//const防止误操作，相当于这个函教是传入了一个常量指针常量。既不能修改值，又不能修改指向，如果没有const，val修改则main函数的a值也会改变,相当于前面地址传递。</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	//int&amp; ref = 10;引用本身需要一个合法的内存空间，因此这行错误</span><br><span class="line">	const int&amp; ref - 10;//加入const就可以了，编译器会优化这行代码为int temp = 10; const int&amp; ref = temp;temp是临时变量</span><br><span class="line">	int a=100;</span><br><span class="line">	showValue(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/29/%E7%AC%AC%E4%B8%80%E5%A4%A9-c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/29/%E7%AC%AC%E4%B8%80%E5%A4%A9-c/" class="post-title-link" itemprop="url">第一天 c++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-29 11:21:09" itemprop="dateCreated datePublished" datetime="2023-03-29T11:21:09+08:00">2023-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-30 16:14:57" itemprop="dateModified" datetime="2023-03-30T16:14:57+08:00">2023-03-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="函数的分文件编写"><a href="#函数的分文件编写" class="headerlink" title="函数的分文件编写"></a>函数的分文件编写</h1><p>1、创建后缀名为.h的头文件<br>2、创建后缀名为.cpp的源文件<br>3、在头文件中写函数声明<br>4、在源文件中写函数的定义</p>
<p>示例：（求最大值）<br>1、创建后缀名为.h的头文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//max.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//3、函数声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br></pre></td></tr></table></figure>

<p>2、创建后缀名为.cpp的源文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//max.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;max.h&quot;</span><span class="comment">//&quot; &quot;表示是我们自己定义的头文件</span></span></span><br><span class="line"><span class="comment">//4、函数的定义</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;<span class="comment">//三目运算符，返回最大值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>max.cpp</code>中包含我们自己定义的头文件<code>&quot;max.h&quot;</code>说明其与<code>&quot;max.h&quot;</code>是配套的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;max.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	max(a, b);</span><br><span class="line"> 	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>main函数中也只需要引用我们自己定义的<code>&quot;max.h&quot;</code>即可<br>就不用再写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>

<p>因为其已在<code>&quot;max.h&quot;</code>头文件中包含了</p>
<p>最后在注意一点，一个项目中只能有一个main函数！！！</p>
<hr>
<p>总结：</p>
<ol>
<li>创建后缀名为.h的头文件，在头文件中写函数的声明，也就是我们自己封装好的函数的各个函数名。</li>
<li>创建后缀名为.cpp的源文件，在源文件中写函数的定义，也就是在源文件中封装代表各个功能的函数，方便调用。</li>
<li>创建主函数（main)文件，调用我们想用的各个封装函数，实现功能。</li>
</ol>
<p>在终端运行mingw(按tab补全)，得到结果，注意，千万不要用右上角的run code执行！</p>
<p>再用<img src="C:\Users\86191\AppData\Roaming\Typora\typora-user-images\image-20230329213057548.png" alt="image-20230329213057548"></p>
<p>如果运行后显示中文乱码可以试试下面的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span><span class="comment">//用于函数SetConsoleOutputCP(65001);更改cmd编码为utf8</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">SetConsoleOutputCP</span>(<span class="number">65001</span>);</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;中文正常显示&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次如此运行后需要更改代码需要重新此步骤</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/25/%E7%AC%AC%E5%8D%81%E5%A4%A9-c%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/25/%E7%AC%AC%E5%8D%81%E5%A4%A9-c%E8%AF%AD%E8%A8%80/" class="post-title-link" itemprop="url">第十天 c语言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-25 14:53:39" itemprop="dateCreated datePublished" datetime="2023-03-25T14:53:39+08:00">2023-03-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-27 20:30:19" itemprop="dateModified" datetime="2023-03-27T20:30:19+08:00">2023-03-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C-命令行参数"><a href="#C-命令行参数" class="headerlink" title="C 命令行参数"></a>C 命令行参数</h1><p>执行程序时，可以从命令行传值给 C 程序。这些值被称为<strong>命令行参数</strong>，它们对程序很重要，特别是当您想从外部控制程序，而不是在代码内对这些值进行硬编码时，就显得尤为重要了。</p>
<p>命令行参数是使用 main() 函数参数来处理的，其中，<strong>argc</strong> 是指传入参数的个数，<strong>argv[]</strong> 是一个指针数组，指向传递给程序的每个参数。下面是一个简单的实例，检查命令行是否有提供参数，并根据参数执行相应的动作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main( int argc, char *argv[] )  </span><br><span class="line">&#123;</span><br><span class="line">//应当指出的是，argv[0] 存储程序的名称(编译文件的名称)，argv[1] 是一个指向第一个命令行参数的指针，*argv[n] 是最后一个参数。如果没有提供任何参数，argc 将为 1，否则，如果传递了一个参数，argc 将被设置为 2。</span><br><span class="line"></span><br><span class="line">//多个命令行参数之间用空格分隔，但是如果参数本身带有空格，那么传递参数的时候应把参数放置在双引号 &quot;&quot; 或单引号 &#x27;&#x27; 内部(&quot;&quot;里面表示一个参数)。让我们重新编写上面的实例，有一个空间，那么你可以通过这样的观点，把它们放在双引号或单引号&quot;&quot;&quot;&quot;。让我们重新编写上面的实例，向程序传递一个放置在双引号内部的命令行参数：</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main 的两个参数的参数名如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int main( int argc, char *argv[] )</span><br></pre></td></tr></table></figure>

<p>并不一定这样写，只是约定俗成罢了。但是亦可以写成下面这样:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int main( int test_argc, char *test_argv[] )  </span><br></pre></td></tr></table></figure>

<hr>
<p><strong>冒泡排序</strong>是一种<strong>稳定</strong>的排序方式！</p>
<p><strong>选择排序</strong>是一种<strong>不稳定</strong>的排序方式！</p>
<p>所谓<strong>稳定</strong>，就是指排完序后序列的各个元素的下标不会改变，如：冒泡排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1;i &lt;= n - 1;i ++)</span><br><span class="line"> for (int j = 1;j &lt;= n - i;j ++)</span><br><span class="line">  if (a[j] &gt; a[j + 1]) swap(a[j],a[j + 1]);</span><br></pre></td></tr></table></figure>

<p>第零趟：<strong>2</strong>,3,2,1</p>
<p>第一趟：<strong>2</strong> 2 1 3 </p>
<p>2： <strong>2</strong> 1 2 3</p>
<p>3:    1 <strong>2</strong> 2 3</p>
<p>排完之后，加粗的2还在前面。</p>
<p>所谓<strong>不稳定</strong>，恰恰相反，如：选择排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1;i &lt;= n - 1;i ++)</span><br><span class="line"> for (int j = i + 1;j &lt;= n;j ++)</span><br><span class="line">  if (a[i] &gt; a[j]) swap(a[i],a[j]);</span><br></pre></td></tr></table></figure>

<p>第零趟：<strong>2</strong> 3 2 1</p>
<p>第一趟：1 3 2 <strong>2</strong></p>
<p>第二趟：1 2 3 <strong>2</strong></p>
<p>3:1 2 <strong>2</strong> 3</p>
<p>排完之后，加粗的2到后面去了。</p>
<p><strong>稳定性</strong>非常重要！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/23/%E7%AC%AC%E4%B9%9D%E5%A4%A9-c%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/23/%E7%AC%AC%E4%B9%9D%E5%A4%A9-c%E8%AF%AD%E8%A8%80/" class="post-title-link" itemprop="url">第九天 c语言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-23 14:43:06 / 修改时间：21:07:01" itemprop="dateCreated datePublished" datetime="2023-03-23T14:43:06+08:00">2023-03-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C 内存管理"></a>C 内存管理</h1><p>C 语言为内存的分配和管理提供了几个函数。这些函数可以在 <strong>&lt;stdlib.h&gt;</strong> 头文件中找到。</p>
<p>1.stdlib.h中的几个函数操作内存；calloc(）分配指定个数指定大小的连续内存块，返回值是这些连续内存块组成的大内存块地址；malloc()分配指定大小的一块内存，返回值是内存的地址；realloc()通过已分配的内存块的地址扩展或者减小内存的大小；free()释放指定地址对应的内存块，无返回值；alloc是allocate 分配的缩写；malloc mess+allocate 整块的分配</p>
<p>2.stdlib中几个内存管理的函数返回值是 void *,表示任意类型的指针，或者说它可以转化成任意类型；</p>
<p>3.内存管理的意义：数组、基本数据类型、结构体、共用体都是固定的为数据分配内存空间，而内存管理却可以直接申请一块内存，然后给其指定存储的数据类型，之后就可以存储数据了，且还可以根据数据的大小来扩展内存空间；</p>
<hr>
<p>malloc与calloc没有本质区别，malloc之后的未初始化内存可以使用memset进行初始化。</p>
<p>主要的不同是malloc不初始化分配的内存，calloc初始化已分配的内存为0。</p>
<p>次要的不同是calloc返回的是一个数组，而malloc返回的是一个对象。</p>
<p>calloc等于malloc后再memset，所以malloc比calloc更高效。</p>
<p>分配内存空间函数malloc 调用形式: (类型说明符*) malloc (size) 。</p>
<p>分配内存空间函数 calloc calloc 也用于分配内存空间。</p>
<p>为什么多用malloc而很少用calloc？</p>
<p>因为calloc虽然对内存进行了初始化（全部初始化为0），</p>
<p>calloc相当于</p>
<p>p &#x3D; malloc();</p>
<p>memset(p, 0,size);(C 库函数 <strong>void *memset(void *str, int c, size_t n)</strong> 复制字符 <strong>c</strong>（一个无符号字符）到参数 <strong>str</strong> 所指向的字符串的前 <strong>n</strong> 个字符。)</p>
<p>相对于malloc多了对内存的写零操作，而写零这个操作我们有时候需要，而大部分时间不需要。</p>
<hr>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数和描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>void *calloc(int num, int size);</strong> 在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是 0。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>void free(void *address);</strong> 该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>void *malloc(int num);</strong> 在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>void *realloc(void *address, int newsize);</strong> 该函数重新分配内存，把内存扩展到 <strong>newsize</strong>。</td>
</tr>
</tbody></table>
<p>直接使用原来的指针变量接收 <strong>realloc</strong> 的返回值是可能存在内存泄漏的。例如以下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">description = (char *) realloc( description, 100 * sizeof(char) );</span><br></pre></td></tr></table></figure>

<p>若 realloc 函数执行失败，description 原先所指向的空间不变，realloc 函数返回 NULL。</p>
<p>此时 description 的值被赋为 NULL, 但原先指向的空间未被释放，造成了内存泄漏。（内存泄漏 （Memory leak）是在计算机科学中，由于疏忽或错误造成程序未能释放已经不再使用的内存 。 内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。 内存泄漏通常情况下只能由获得程序源代码的程序员才能分析出来。）</p>
<hr>
<p><strong>注意：</strong>void * 类型表示未确定类型的指针。C、C++ 规定 void * 类型可以通过类型转换强制转换为任何其它类型的指针。</p>
<p><strong>注：</strong>void 指针可以任意类型的数据，可以在程序中给我们带来一些好处，函数中形为指针类型时，我们可以将其定义为 void 指针，这样函数就可以接受任意类型的指针。</p>
<p>void 指针可以指向任意类型的数据，就是说可以用任意类型的指针对 void 指针对 void 指针赋值。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int *a；</span><br><span class="line">void *p；</span><br><span class="line">p=a；</span><br></pre></td></tr></table></figure>

<p>如果要将 void 指针 p 赋给其他类型的指针，则需要强制类型转换，就本例而言：<strong>a&#x3D;（int *）p</strong>。</p>
<p>对于 void 指针，GNU 认为 <strong>void *</strong> 和 <strong>char *</strong> 一样，所以以下写法是正确的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">description = malloc( 200 * sizeof(char) );</span><br></pre></td></tr></table></figure>

<p>但按照 ANSI(American National Standards Institute) 标准，需要对 void 指针进行强制转换，如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">description = (char *)malloc( 200 * sizeof(char) );</span><br></pre></td></tr></table></figure>

<p>同时，按照 ANSI(American National Standards Institute) 标准，不能对 void 指针进行算法操作:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void * pvoid;</span><br><span class="line">pvoid++; //ANSI：错误</span><br><span class="line">pvoid += 1; //ANSI：错误</span><br><span class="line">// ANSI标准之所以这样认定，是因为它坚持：进行算法操作的指针必须是确定知道其指向数据类型大小的。</span><br><span class="line"></span><br><span class="line">int *pint;</span><br><span class="line">pint++; //ANSI：正确</span><br></pre></td></tr></table></figure>

<p>在实际的程序设计中，为迎合 ANSI 标准，并提高程序的可移植性，我们可以这样编写实现同样功能的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void * pvoid;</span><br><span class="line">((char *)pvoid)++; //ANSI：错误；GNU：正确</span><br><span class="line">(char *)pvoid += 1; //ANSI：错误；GNU：正确</span><br></pre></td></tr></table></figure>

<h2 id="动态分配内存"><a href="#动态分配内存" class="headerlink" title="动态分配内存"></a>动态分配内存</h2><p>预先不知道需要存储的文本长度，例如您想存储有关一个主题的详细描述。在这里，我们需要定义一个指针，该指针指向未定义所需内存大小的字符，后续再根据需求来分配内存，如下所示：</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   char name[100];</span><br><span class="line">   char *description;</span><br><span class="line"> </span><br><span class="line">   strcpy(name, &quot;Zara Ali&quot;);</span><br><span class="line"> </span><br><span class="line">   /* 动态分配内存 */</span><br><span class="line">   description = (char *)malloc( 200 * sizeof(char) );</span><br><span class="line">   if( description == NULL )</span><br><span class="line">   &#123;</span><br><span class="line">      fprintf(stderr, &quot;Error - unable to allocate required memory\n&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">      strcpy( description, &quot;Zara ali a DPS student in class 10th&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   printf(&quot;Name = %s\n&quot;, name );</span><br><span class="line">   printf(&quot;Description: %s\n&quot;, description );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序也可以使用 <strong>calloc()</strong> 来编写，只需要把 malloc 替换为 calloc 即可，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">calloc(200, sizeof(char));</span><br></pre></td></tr></table></figure>

<p>当动态分配内存时，您有完全控制权，可以传递任何大小的值。而那些预先定义了大小的数组，一旦定义则无法改变大小。</p>
<h2 id="重新调整内存的大小和释放内存"><a href="#重新调整内存的大小和释放内存" class="headerlink" title="重新调整内存的大小和释放内存"></a>重新调整内存的大小和释放内存</h2><p>当程序退出时，操作系统会自动释放所有分配给程序的内存，但是，建议您在不需要内存时，都应该调用函数 <strong>free()</strong> 来释放内存。</p>
<p>或者，您可以通过调用函数 <strong>realloc()</strong> 来增加或减少已分配的内存块的大小。让我们使用 realloc() 和 free() 函数，再次查看上面的实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   char name[100];</span><br><span class="line">   char *description;</span><br><span class="line"> </span><br><span class="line">   strcpy(name, &quot;Zara Ali&quot;);</span><br><span class="line"> </span><br><span class="line">   /* 动态分配内存 */</span><br><span class="line">   description = (char *)malloc( 30 * sizeof(char) );</span><br><span class="line">   if( description == NULL )</span><br><span class="line">   &#123;</span><br><span class="line">      fprintf(stderr, &quot;Error - unable to allocate required memory\n&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">      strcpy( description, &quot;Zara ali a DPS student.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   /* 假设您想要存储更大的描述信息 */</span><br><span class="line">   description = (char *) realloc( description, 100 * sizeof(char) );</span><br><span class="line">   if( description == NULL )</span><br><span class="line">   &#123;</span><br><span class="line">      fprintf(stderr, &quot;Error - unable to allocate required memory\n&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">      strcat( description, &quot;She is in class 10th&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   printf(&quot;Name = %s\n&quot;, name );</span><br><span class="line">   printf(&quot;Description: %s\n&quot;, description );</span><br><span class="line"> </span><br><span class="line">   /* 使用 free() 函数释放内存 */</span><br><span class="line">   free(description);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尝试一下不重新分配额外的内存，strcat() 函数会生成一个错误，因为存储 description 时可用的内存不足。</p>
<hr>
<p>动态可变长的结构体：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  int id;</span><br><span class="line">  char name[0];</span><br><span class="line">&#125;stu_t;</span><br></pre></td></tr></table></figure>

<p>定义该结构体，只占用4字节的内存，name不占用内存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stu_t *s = NULL;    //定义一个结构体指针</span><br><span class="line">s = malloc(sizeof(*s) + 100);//sizeof(*s)获取的是4，但加上了100，4字节给id成员使用，100字节是属于name成员的</span><br><span class="line">s-&gt;id = 1010;</span><br><span class="line">strcpy(s-&gt;name,&quot;hello&quot;);</span><br></pre></td></tr></table></figure>

<p>注意：一个结构体中只能有一个可变长的成员，并且该成员必须是最后一个成员。</p>
<h3 id="C-语言中常用的内存管理函数和运算符"><a href="#C-语言中常用的内存管理函数和运算符" class="headerlink" title="C 语言中常用的内存管理函数和运算符"></a>C 语言中常用的内存管理函数和运算符</h3><ul>
<li>malloc() 函数：用于动态分配内存。它接受一个参数，即需要分配的内存大小（以字节为单位），并返回一个指向分配内存的指针。</li>
<li>free() 函数：用于释放先前分配的内存。它接受一个指向要释放内存的指针作为参数，并将该内存标记为未使用状态。</li>
<li>calloc() 函数：用于动态分配内存，并将其初始化为零。它接受两个参数，即需要分配的内存块数和每个内存块的大小（以字节为单位），并返回一个指向分配内存的指针。</li>
<li>realloc() 函数：用于重新分配内存。它接受两个参数，即一个先前分配的指针和一个新的内存大小，然后尝试重新调整先前分配的内存块的大小。如果调整成功，它将返回一个指向重新分配内存的指针，否则返回一个空指针。</li>
<li>sizeof 运算符：用于获取数据类型或变量的大小（以字节为单位）。</li>
<li>指针运算符：用于获取指针所指向的内存地址或变量的值。</li>
<li>&amp; 运算符：用于获取变量的内存地址。</li>
<li>***** 运算符：用于获取指针所指向的变量的值。</li>
<li><strong>-&gt;</strong> 运算符：用于指针访问结构体成员，语法为 <strong>pointer-&gt;member</strong>，等价于 <strong>(*pointer).member</strong>。</li>
<li>memcpy() 函数：用于从源内存区域复制数据到目标内存区域。它接受三个参数，即目标内存区域的指针、源内存区域的指针和要复制的数据大小（以字节为单位）。<strong>void *memcpy(void *str1, const void *str2, size_t n)</strong> 从存储区 <strong>str2</strong> 复制 <strong>n</strong> 个字节到存储区 <strong>str1</strong>。该函数返回一个指向目标存储区 str1 的指针。</li>
<li>memmove() 函数：类似于 memcpy() 函数，但它可以处理重叠的内存区域。它接受三个参数，即目标内存区域的指针、源内存区域的指针和要复制的数据大小（以字节为单位）。<strong>void *memmove(void *str1, const void *str2, size_t n)</strong> 从 <strong>str2</strong> 复制 <strong>n</strong> 个字符到 <strong>str1</strong>，但是在重叠内存块这方面，memmove() 是比 memcpy() 更安全的方法。如果目标区域和源区域有重叠的话，memmove() 能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中，复制后源区域的内容会被更改。如果目标区域与源区域没有重叠，则和 memcpy() 函数功能相同。</li>
</ul>
<p>任何类型的指针都可以传入 memcpy 和 memset 中</p>
<hr>
<p>对于我们手动分配的内存，在 C 语言中是不用强制转换类型的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">description = malloc( 200 * sizeof(char) ); // C 语言正确。</span><br><span class="line">description = malloc( 200 * sizeof(char) ); // C++ 错误</span><br></pre></td></tr></table></figure>

<p>但是 C++ 是强制要求的，不然会报错。</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/22/%E7%AC%AC%E5%85%AB%E5%A4%A9-c%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/22/%E7%AC%AC%E5%85%AB%E5%A4%A9-c%E8%AF%AD%E8%A8%80/" class="post-title-link" itemprop="url">第八天 c语言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-22 16:14:02" itemprop="dateCreated datePublished" datetime="2023-03-22T16:14:02+08:00">2023-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-23 14:43:19" itemprop="dateModified" datetime="2023-03-23T14:43:19+08:00">2023-03-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C递归"><a href="#C递归" class="headerlink" title="C递归"></a>C递归</h1><p>递归是一个简洁的概念，同时也是一种很有用的手段。但是，使用递归是要付出代价的。与直接的语句(如while循环)相比，递归函数会<strong>耗费更多的运行时间，并且要占用大量的栈空间</strong>。递归函数每次调用自身时，都需要把它的状态存到栈中，以便在它调用完自身后，程序可以返回到它原来的状态。未经精心设计的递归函数总是会带来麻烦。</p>
<p>电脑空间大致分<strong>Heap（堆）</strong>和<strong>Stack（栈）</strong>两种。</p>
<p><strong>栈</strong>是用于<strong>函数</strong>的空间。</p>
<p>电脑调用一个函数，就会使用一层栈；</p>
<p>相反，电脑中一个函数结束（return），就会释放这一层栈，<strong>连同在这层栈（这个函数）中定义的所有东西</strong>。</p>
<p>不在栈中的，应该就在堆中。<strong>（这就是定义全区变量与局部变量的用处）</strong></p>
<p>如果调用太多层栈（太多个函数），电脑就会暴空间！</p>
<p>所以说，调用递归函数，就会<strong>一层一层地压栈</strong>，<strong>电脑就会暴空间！</strong>（<strong>并不代表不建议用递归，只是作提示而已</strong>）</p>
<p><strong>栈：</strong></p>
<p>在函数中定义的变量存放的内存区域。常见的int、float、char等变量均存放于栈区中，它的特点是由系统自动分配与释放，不需要程序员考虑资源回收的问题，方便简洁。ps：栈区的地址分配是从内存的高地址开始向地地址分配；</p>
<p><strong>堆：</strong></p>
<p>通过指令自主向系统申请的内存区域，大小由自己决定，它在使用完后同样需要自己通过指令去释放该区域内存，否则将有可能出现内存的浪费与溢出。</p>
<p>C语言中申请堆区指令为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = (<span class="type">int</span> *) <span class="built_in">malloc</span>( N * <span class="keyword">sizeof</span>(<span class="type">int</span>) );  <span class="comment">//分配N个int型(4字节)的内存，即 4 * N 个字节</span></span><br></pre></td></tr></table></figure>

<p>ps：<strong>但指针p存放于栈区，指向堆</strong>。</p>
<p>C语言中释放堆区指令为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>( p ); <span class="comment">//注意此处参数为指针</span></span><br></pre></td></tr></table></figure>

<p>使用中应该注意，尽量不要去修改p指针对应的地址值，否则在内存释放时将出现错误。(编译可通过，运行出现问题)</p>
<p><strong>bss区：</strong></p>
<p>通常是指用来存放程序中未初始化的全局变量的一块内存区域，由static修饰，BSS是英文Block Started by Symbol的简称，BSS段属于静态内存分配。ps：静态变量仅在第一次创建时初始化一次，之后自动跳过初始化语句。全局变量与静态变量均由系统分配和释放内存，若未对它们进行初始化操作，系统将自动将其值设置为0。(堆区与栈区则不会)</p>
<p><strong>代码段：</strong></p>
<p>代码段(code segment&#x2F;text segment)通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。常见的使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *s = <span class="string">&quot;HelloWorld&quot;</span>;<span class="comment">//该字符串 HelloWorld 即存放于文字常量区，不可修改。</span></span><br></pre></td></tr></table></figure>

<p>ps：但指针s存放于栈区。</p>
<p>pps：若在程序中尝试对其修改（例如尝试修改第一个字符 *s &#x3D; ‘h’;），将出现编译可通过，运行报错的情况。</p>
<p>同时因注意它与const修饰的变量之间的区别：char aa &#x3D; ‘A’;&#x2F;&#x2F;aa存放于栈区；const char bb &#x3D; ‘B’; &#x2F;&#x2F;bb同样存放于栈区，const修饰的变量仅仅用于告诉编译器bb是一个常量，如果后续的程序中有出现尝试修改bb的操作时，编译将报错。这种写法主要是为了防止程序员在后续的代码中误操作bb变量而添加的一个约束条件，并不会影响它存放的位置。</p>
<h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> val1 = <span class="number">1</span>;        <span class="comment">//val1存放在.data段</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> val2 = <span class="number">1</span>;               <span class="comment">//初始化的全局变量存放在.data段</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> val3 ;                  <span class="comment">//未初始化的全局变量存放在.bss段</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> val4 = <span class="number">1</span>;         <span class="comment">//val4存放在.rodata（只读数据段）</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Demo</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num)</span> <span class="comment">//num 存放在栈区</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> var = <span class="string">&quot;123456&quot;</span>;               <span class="comment">//var存放在栈区，&quot;123456&quot;存放在常量区</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> num1 = <span class="number">1</span> ;            <span class="comment">//num1存放在栈区</span></span><br><span class="line">  <span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> num2 = <span class="number">0</span>;      <span class="comment">//num2存放在.data段</span></span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> num3 = <span class="number">7</span>;       <span class="comment">//num3存放在栈区</span></span><br><span class="line">  <span class="type">void</span> *p;</span><br><span class="line">  p = <span class="built_in">malloc</span>(<span class="number">8</span>);                     <span class="comment">//p存放在堆区，但指针p存放于栈区，指向堆</span></span><br><span class="line">  <span class="built_in">free</span>(p);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> num = <span class="number">0</span> ;</span><br><span class="line">  num = Demo(num);                   <span class="comment">//Demo()函数的返回值存放在栈区。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DATA 段（全局初始化区）存放初始化的全局变量和静态变量；BSS 段（全局未初始化区）存放未初始化的全局变量和静态变量。</p>
<p>静态局部变量时在编译时被赋值的，即自始至终<strong>只赋值一次</strong>，在程序运行时它已经有初值。以后每次调用函数时不再重新赋初值而只是保留上次函数调用结束时的值。而自动变量赋初值，不是在编译时进行的，而是在<strong>运行时进行</strong>，所以<strong>每调用一次函数就赋一次初值</strong>。</p>
<h1 id="C-可变参数"><a href="#C-可变参数" class="headerlink" title="C 可变参数"></a>C 可变参数</h1><p>有时，您可能会碰到这样的情况，您希望函数带有可变数量的参数，而不是预定义数量的参数。</p>
<p>C 语言为这种情况提供了一个解决方案，它允许您定义一个函数，能根据具体的需求接受可变数量的参数。</p>
<p>声明方式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int func_name(int arg1, ...);</span><br></pre></td></tr></table></figure>

<p>其中，省略号 <strong>…</strong> 表示可变参数列表。</p>
<p>下面的实例演示了这种函数的使用：</p>
<p>int func(int, … )  {   .   .   . }  int main() {   func(2, 2, 3);   func(3, 2, 3, 4); }</p>
<p>请注意，函数 <strong>func()</strong> 最后一个参数写成省略号，即三个点号（**…**），省略号之前的那个参数是 <strong>int</strong>，代表了要传递的可变参数的总数。为了使用这个功能，您需要使用 <strong>stdarg.h</strong> 头文件，该文件提供了实现可变参数功能的函数和宏。具体步骤如下：</p>
<ul>
<li>定义一个函数，最后一个参数为省略号，省略号前面可以设置自定义参数。</li>
<li>在函数定义中创建一个 <strong>va_list</strong> 类型变量，该类型是在 stdarg.h 头文件中定义的。</li>
<li>使用 <strong>int</strong> 参数和 <strong>va_start()</strong> 宏来初始化 <strong>va_list</strong> 变量为一个参数列表。宏 <strong>va_start()</strong> 是在 stdarg.h 头文件中定义的。</li>
<li>使用 <strong>va_arg()</strong> 宏和 <strong>va_list</strong> 变量来访问参数列表中的每个项。</li>
<li>使用宏 <strong>va_end()</strong> 来清理赋予 <strong>va_list</strong> 变量的内存。</li>
</ul>
<p>常用的宏有：</p>
<ul>
<li><code>**va_start(ap, last_arg)**</code>：初始化可变参数列表。<code>ap</code> 是一个 <code>va_list</code> 类型的变量，<code>last_arg</code> 是最后一个固定参数的名称（也就是可变参数列表之前的参数）。该宏将 <code>ap</code> 指向可变参数列表中的第一个参数。</li>
<li><code>**va_arg(ap, type)**</code>：获取可变参数列表中的下一个参数。<code>ap</code> 是一个 <code>va_list</code> 类型的变量，<code>type</code> 是下一个参数的类型。该宏返回类型为 <code>type</code> 的值，并将 <code>ap</code> 指向下一个参数。</li>
<li>va_copy(va_list dest, va_list src) 宏：用于将src指向的参数复制到dest中。</li>
<li><code>**va_end(ap)**</code>：结束可变参数列表的访问。<code>ap</code> 是一个 <code>va_list</code> 类型的变量。该宏将 <code>ap</code> 置为 <code>NULL</code>。</li>
</ul>
<p>现在让我们按照上面的步骤，来编写一个带有可变数量参数的函数，并返回它们的平均值：</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdarg.h&gt;</span><br><span class="line"> </span><br><span class="line">double average(int num,...)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    va_list valist;</span><br><span class="line">    double sum = 0.0;</span><br><span class="line">    int i;</span><br><span class="line"> </span><br><span class="line">    /* 为 num 个参数初始化 valist */</span><br><span class="line">    va_start(valist, num);</span><br><span class="line"> </span><br><span class="line">    /* 访问所有赋给 valist 的参数 */</span><br><span class="line">    for (i = 0; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       sum += va_arg(valist, int); // 获取当前参数，并将指针移动到下一个参数</span><br><span class="line">    &#125;</span><br><span class="line">    /* 清理为 valist 保留的内存 */</span><br><span class="line">    va_end(valist);</span><br><span class="line"> </span><br><span class="line">    return sum/num;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;Average of 2, 3, 4, 5 = %f\n&quot;, average(4,2,3,4,5));</span><br><span class="line">   printf(&quot;Average of 5, 10, 15 = %f\n&quot;, average(3,5,10,15));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，average() 函数接受一个整数 num 和任意数量的整数参数。函数内部使用 va_list 类型的变量 va_list 来访问可变参数列表。在循环中，每次使用 va_arg() 宏获取下一个整数参数，并输出。最后，在函数结束时使用 va_end() 宏结束可变参数列表的访问。</p>
<p>当上面的代码被编译和执行时，它会产生下列结果。应该指出的是，函数 <strong>average()</strong> 被调用两次，每次第一个参数都是表示被传的可变参数的总数。省略号被用来传递可变数量的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Average of 2, 3, 4, 5 = 3.500000</span><br><span class="line">Average of 5, 10, 15 = 10.000000</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 本质上，va_list 类型，就是「char指针」类型，指向 1B 大小的内存地址</span><br><span class="line">typedef char* va_list;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/21/%E7%AC%AC%E4%B8%83%E5%A4%A9-c%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/21/%E7%AC%AC%E4%B8%83%E5%A4%A9-c%E8%AF%AD%E8%A8%80/" class="post-title-link" itemprop="url">第七天 c语言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-21 16:25:11 / 修改时间：21:12:34" itemprop="dateCreated datePublished" datetime="2023-03-21T16:25:11+08:00">2023-03-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C-强制类型转换"><a href="#C-强制类型转换" class="headerlink" title="C 强制类型转换"></a>C 强制类型转换</h1><p>强制类型转换是把变量从一种类型转换为另一种数据类型。例如，如果您想存储一个 long 类型的值到一个简单的整型中，您需要把 long 类型强制转换为 int 类型。您可以使用<strong>强制类型转换运算符</strong>来把值显式地从一种类型转换为另一种类型，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(type_name) expression</span><br></pre></td></tr></table></figure>

<p>请看下面的实例，使用强制类型转换运算符把一个整数变量除以另一个整数变量，得到一个浮点数：</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int sum = 17, count = 5;</span><br><span class="line">   double mean;</span><br><span class="line"> </span><br><span class="line">   mean = (double) sum / count;</span><br><span class="line">   printf(&quot;Value of mean : %f\n&quot;, mean );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Value of mean : 3.400000</span><br></pre></td></tr></table></figure>

<p>这里要注意的是强制类型转换运算符的<strong>优先级大于除法</strong>，因此 <strong>sum</strong> 的值首先被转换为 <strong>double</strong> 型，然后除以 count，得到一个类型为 double 的值。</p>
<h2 id="整数提升"><a href="#整数提升" class="headerlink" title="整数提升"></a>整数提升</h2><p>整数提升是指把小于 <strong>int</strong> 或 <strong>unsigned int</strong> 的整数类型转换为 <strong>int</strong> 或 <strong>unsigned int</strong> 的过程：比如将char类型的字符转化成ascii码再与int型计算得到int型。</p>
<h2 id="常用的算术转换"><a href="#常用的算术转换" class="headerlink" title="常用的算术转换"></a>常用的算术转换</h2><p><strong>常用的算术转换</strong>是<strong>隐式地</strong>把值强制转换为相同的类型。编译器首先执行<strong>整数提升</strong>，如果操作数类型不同，则它们会被转换为下列层次中出现的最高层次的类型：</p>
<p>char,short–&gt;int–&gt;unsigned int–&gt;long–&gt;unsigned long–&gt;long long–&gt;unsigned long long–&gt;float–&gt;double–&gt;long double</p>
<p>float、double、long double 类型赋值给整数类型：直接截断小数.</p>
<hr>
<p>为了提高效率，C 语言对于不同的两个类型将直接转换成较高类型计算。</p>
<p>举个例子：对于已经分别被定义且被赋值，类型为 <strong>double</strong> 和 <strong>int</strong> 的 <strong>a</strong> 和 <strong>b</strong>：</p>
<p>假设如果进行 <strong>a + b</strong> 运算，那么b将直接被隐式转换为 <strong>double</strong> 类型，然后再进行运算，不能理解为逐层转换（即不能理解为b先转换为unsigned int类型，再转换为 <strong>long &#x3D;&gt; unsigned long &#x3D;&gt; long long &#x3D;&gt; unsigned long long &#x3D;&gt; float &#x3D;&gt; double</strong>类型，最后再进行运算）。</p>
<p><strong>p.s:</strong> 说到运算，对于 <strong>char</strong> 和 <strong>short</strong> 类型，进行运算时将会被隐式转换为 <strong>int</strong></p>
<hr>
<p>常用的算术转换不适用于赋值运算符、逻辑运算符 &amp;&amp; 和 ||。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>C 语言中 printf 输出 double 和 float 都可以用 <strong>%f</strong> 占位符 可以混用，而 double 可以额外用 <strong>%lf</strong>。</p>
<p>而 scanf 输入情况下 double 必须用 <strong>%lf</strong>，float 必须用 <strong>%f</strong> 不能混用。</p>
<hr>
<p><strong>强制类型转换只是临时类型转换，并不影响变量本身储存的值</strong>，看如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">  float a = 6.9;</span><br><span class="line">  printf(&quot;%.3f&quot;, a);</span><br><span class="line">  putchar(&#x27;\n&#x27;);</span><br><span class="line">  ((int)a);</span><br><span class="line">  printf(&quot;%.3f&quot;, a);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6.900</span><br><span class="line">6.900</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="存储长度较短的类型赋值给存储长度较长的类型：补足有效位，其它位补-0"><a href="#存储长度较短的类型赋值给存储长度较长的类型：补足有效位，其它位补-0" class="headerlink" title="存储长度较短的类型赋值给存储长度较长的类型：补足有效位，其它位补 0"></a>存储长度较短的类型赋值给存储长度较长的类型：补足有效位，其它位补 0</h3><p>假设有如下定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char c = 56;//1个字节,8位二进制</span><br><span class="line">short num = 67;//2个字节,16位二进制</span><br><span class="line">int m;//4个字节,32位二进制</span><br><span class="line">long long int n;//8个字节,64位二进制</span><br></pre></td></tr></table></figure>

<p>如果执行以下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m = ((int)c);</span><br><span class="line">n = ((long long)num);</span><br></pre></td></tr></table></figure>

<p>那么它们在内存以 2 进制格式分别存储为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">                                                               00111000  //Binary of &#x27;c&#x27;</span><br><span class="line">                                                      00000000 01000011  //Binary of&#x27;num&#x27;</span><br><span class="line">                                    00000000 00000000 00000000 00111000  //Binary of &#x27;m&#x27;</span><br><span class="line">00000000 00000000 00000000 00000000 00000000 00000000 00000000 01000011  //Binary of &#x27;n&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="存储长度较长的类型赋值给存储长度较短的类型：舍弃高位（但保留符号），截断低字节给存储长度较短的类型"><a href="#存储长度较长的类型赋值给存储长度较短的类型：舍弃高位（但保留符号），截断低字节给存储长度较短的类型" class="headerlink" title="存储长度较长的类型赋值给存储长度较短的类型：舍弃高位（但保留符号），截断低字节给存储长度较短的类型"></a>存储长度较长的类型赋值给存储长度较短的类型：舍弃高位（但保留符号），截断低字节给存储长度较短的类型</h3><p>假设定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long long int l = 223372036854775807;</span><br></pre></td></tr></table></figure>

<p>进行赋值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int i = (int)l;</span><br></pre></td></tr></table></figure>

<p>它们在内存以2进制格式分别存储为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00000011 00011001 10010011 10101111 00011101 01111011 11111111 11111111  //Binary of &#x27;l&#x27;</span><br><span class="line">                                    00011101 01111011 11111111 11111111  //Binary of &#x27;v&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>p.s:</strong> 此时的 v&#x3D;494665727。</p>
<p>顺带说明一下，如果变量 “l” 的后 32 个字节都为 1，那么 v 将等于 -1。因为负数在计算机都以补码形式存在，即</p>
<p>后 32 个字节都为 1的是补码变为原码就为-1.</p>
<h3 id="unsigned类型赋值给非unsigned类型：直接传递数值"><a href="#unsigned类型赋值给非unsigned类型：直接传递数值" class="headerlink" title="unsigned类型赋值给非unsigned类型：直接传递数值"></a>unsigned类型赋值给非unsigned类型：直接传递数值</h3><p><strong>注意：</strong>如果 unsigned 类型储存的量太大，强制类型转换后可能会出现非 unsigned 类型的值的绝对值不等于 unsigned 类型的值的绝对值的情况。</p>
<p>说到 “unsigned 类型储存的量太大”，顺带说一下，虽然 printf 输出 int 和 unsigned int 时可以混用 %d（或%i）和 %u（或%ui），但还是建议输出 int 类型的时候用 %d（或%i），输出 unsigned int 类型时用 %u（或%ui）（其它类型同理&lt;如%ul等&gt;）</p>
<h3 id="非-unsigned-类型赋值给-unsigned-类型：直接传递数值"><a href="#非-unsigned-类型赋值给-unsigned-类型：直接传递数值" class="headerlink" title="非 unsigned 类型赋值给 unsigned 类型：直接传递数值"></a>非 unsigned 类型赋值给 unsigned 类型：直接传递数值</h3><p>给个小技巧：如果你想“临时”给一个不知道正负的非 unsigned 类型的变量加上绝对值，可以使用abs函数，但利用(unsigned)(非unsigned类型变量名)可以节省一点内存开销</p>
<p>但是也有弊端：可能会出现 unsigned-unsigned 永远大于 0 的情况（不确定）</p>
<h1 id="C-错误处理"><a href="#C-错误处理" class="headerlink" title="C 错误处理"></a>C 错误处理</h1><p>C 语言不提供对错误处理的直接支持，但是作为一种系统编程语言，它以返回值的形式允许您访问底层数据。在发生错误时，大多数的 C 或 UNIX 函数调用返回 1 或 NULL，同时会设置一个错误代码 <strong>errno</strong>，该错误代码是全局变量，表示在函数调用期间发生了错误。您可以在 errno.h 头文件中找到各种各样的错误代码。</p>
<p>所以，C 程序员可以通过检查返回值，然后根据返回值决定采取哪种适当的动作。开发人员应该在程序初始化时，把 errno 设置为 0，这是一种良好的编程习惯。0 值表示程序中没有错误。</p>
<h2 id="errno、perror-和-strerror"><a href="#errno、perror-和-strerror" class="headerlink" title="errno、perror() 和 strerror()"></a>errno、perror() 和 strerror()</h2><p>C 语言提供了 <strong>perror()</strong> 和 <strong>strerror()</strong> 函数来显示与 <strong>errno</strong> 相关的文本消息。</p>
<ul>
<li><strong>perror()</strong> 函数显示您传给它的字符串，后跟一个冒号、一个空格和当前 errno 值的文本表示形式。</li>
<li><strong>strerror()</strong> 函数，返回一个指针，指针指向当前 errno 值的文本表示形式。</li>
</ul>
<p>让我们来模拟一种错误情况，尝试打开一个不存在的文件。您可以使用多种方式来输出错误消息，在这里我们使用函数来演示用法。另外有一点需要注意，您应该使用 <strong>stderr 文件流</strong>来输出所有的错误。</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">extern int errno ;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   FILE * pf;</span><br><span class="line">   int errnum;</span><br><span class="line">   pf = fopen (&quot;unexist.txt&quot;, &quot;rb&quot;);</span><br><span class="line">   if (pf == NULL)</span><br><span class="line">   &#123;</span><br><span class="line">      errnum = errno;</span><br><span class="line">      fprintf(stderr, &quot;错误号: %d\n&quot;, errno);</span><br><span class="line">      perror(&quot;通过 perror 输出错误&quot;);</span><br><span class="line">      fprintf(stderr, &quot;打开文件错误: %s\n&quot;, strerror( errnum ));</span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">      fclose (pf);</span><br><span class="line">   &#125;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fprintf是C&#x2F;C++中的一个格式化库函数，位于头文件中，其作用是格式化输出到一个流文件中；</p>
<p>函数原型为int fprintf( FILE <em>stream, const char <em>format, [ argument ]…)，fprintf()函数根据指定的格式(format)，向输出流(stream)写入数据(argument)。将内容输出到指定.txt中FILE</em> fp &#x3D; NULL;<br>fp &#x3D; fopen(“e:\gz.txt”,”w+”);fprintf(fp,”%d,%x,%o”,10,10,10);将内容输出到屏幕,使用stdout或者stderr:fprintf(stdout,”%d,%x,%o”,10,10,10);stdout和stderr，stdout是标准的输出流，而stderr是标准的错误输出流。stdout和stderr的类型都是FILE</em>，在stdio.h中定义。默认情况下，stdout和stderr中的数据都会被打印到屏幕上。</p>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误号: 2</span><br><span class="line">通过 perror 输出错误: No such file or directory</span><br><span class="line">打开文件错误: No such file or directory</span><br></pre></td></tr></table></figure>

<p>windows上述代码里 errno 的值从而得出不同的错误类型，从 43 之后就一直是 Unknown error 错误类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">Value of errno: 0</span><br><span class="line">Error opening file: No error</span><br><span class="line"></span><br><span class="line">Value of errno: 1</span><br><span class="line">Error opening file: Operation not permitted</span><br><span class="line"></span><br><span class="line">Value of errno: 2</span><br><span class="line">Error opening file: No such file or directory</span><br><span class="line"></span><br><span class="line">Value of errno: 3</span><br><span class="line">Error opening file: No such process</span><br><span class="line"></span><br><span class="line">Value of errno: 4</span><br><span class="line">Error opening file: Interrupted function call</span><br><span class="line"></span><br><span class="line">Value of errno: 5</span><br><span class="line">Error opening file: Input/output error</span><br><span class="line"></span><br><span class="line">Value of errno: 6</span><br><span class="line">Error opening file: No such device or address</span><br><span class="line"></span><br><span class="line">Value of errno: 7</span><br><span class="line">Error opening file: Arg list too long</span><br><span class="line"></span><br><span class="line">Value of errno: 8</span><br><span class="line">Error opening file: Exec format error</span><br><span class="line"></span><br><span class="line">Value of errno: 9</span><br><span class="line">Error opening file: Bad file descriptor</span><br><span class="line"></span><br><span class="line">Value of errno: 10</span><br><span class="line">Error opening file: No child processes</span><br><span class="line"></span><br><span class="line">Value of errno: 11</span><br><span class="line">Error opening file: Resource temporarily unavailable</span><br><span class="line"></span><br><span class="line">Value of errno: 12</span><br><span class="line">Error opening file: Not enough space</span><br><span class="line"></span><br><span class="line">Value of errno: 13</span><br><span class="line">Error opening file: Permission denied</span><br><span class="line"></span><br><span class="line">Value of errno: 14</span><br><span class="line">Error opening file: Bad address</span><br><span class="line"></span><br><span class="line">Value of errno: 15</span><br><span class="line">Error opening file: Unknown error</span><br><span class="line"></span><br><span class="line">Value of errno: 16</span><br><span class="line">Error opening file: Resource device</span><br><span class="line"></span><br><span class="line">Value of errno: 17</span><br><span class="line">Error opening file: File exists</span><br><span class="line"></span><br><span class="line">Value of errno: 18</span><br><span class="line">Error opening file: Improper link</span><br><span class="line"></span><br><span class="line">Value of errno: 19</span><br><span class="line">Error opening file: No such device</span><br><span class="line"></span><br><span class="line">Value of errno: 20</span><br><span class="line">Error opening file: Not a directory</span><br><span class="line"></span><br><span class="line">Value of errno: 21</span><br><span class="line">Error opening file: Is a directory</span><br><span class="line"></span><br><span class="line">Value of errno: 22</span><br><span class="line">Error opening file: Invalid argument</span><br><span class="line"></span><br><span class="line">Value of errno: 23</span><br><span class="line">Error opening file: Too many open files in system</span><br><span class="line"></span><br><span class="line">Value of errno: 24</span><br><span class="line">Error opening file: Too many open files</span><br><span class="line"></span><br><span class="line">Value of errno: 25</span><br><span class="line">Error opening file: Inappropriate I/O control operation</span><br><span class="line"></span><br><span class="line">Value of errno: 26</span><br><span class="line">Error opening file: Unknown error</span><br><span class="line"></span><br><span class="line">Value of errno: 27</span><br><span class="line">Error opening file: File too large</span><br><span class="line"></span><br><span class="line">Value of errno: 28</span><br><span class="line">Error opening file: No space left on device</span><br><span class="line"></span><br><span class="line">Value of errno: 29</span><br><span class="line">Error opening file: Invalid seek</span><br><span class="line"></span><br><span class="line">Value of errno: 30</span><br><span class="line">Error opening file: Read-only file system</span><br><span class="line"></span><br><span class="line">Value of errno: 31</span><br><span class="line">Error opening file: Too many links</span><br><span class="line"></span><br><span class="line">Value of errno: 32</span><br><span class="line">Error opening file: Broken pipe</span><br><span class="line"></span><br><span class="line">Value of errno: 33</span><br><span class="line">Error opening file: Domain error</span><br><span class="line"></span><br><span class="line">Value of errno: 34</span><br><span class="line">Error opening file: Result too large</span><br><span class="line"></span><br><span class="line">Value of errno: 35</span><br><span class="line">Error opening file: Unknown error</span><br><span class="line"></span><br><span class="line">Value of errno: 36</span><br><span class="line">Error opening file: Resource deadlock avoided</span><br><span class="line"></span><br><span class="line">Value of errno: 37</span><br><span class="line">Error opening file: Unknown error</span><br><span class="line"></span><br><span class="line">Value of errno: 38</span><br><span class="line">Error opening file: Filename too long</span><br><span class="line"></span><br><span class="line">Value of errno: 39</span><br><span class="line">Error opening file: No locks available</span><br><span class="line"></span><br><span class="line">Value of errno: 40</span><br><span class="line">Error opening file: Function not implemented</span><br><span class="line"></span><br><span class="line">Value of errno: 41</span><br><span class="line">Error opening file: Directory not empty</span><br><span class="line"></span><br><span class="line">Value of errno: 42</span><br><span class="line">Error opening file: Illegal byte sequence</span><br><span class="line"></span><br><span class="line">Value of errno: 43</span><br><span class="line">Error opening file: Unknown error</span><br><span class="line"></span><br><span class="line">Value of errno: 44</span><br><span class="line">Error opening file: Unknown error</span><br><span class="line"></span><br><span class="line">Value of errno: 45</span><br><span class="line">Error opening file: Unknown error</span><br><span class="line"></span><br><span class="line">Value of errno: 46</span><br><span class="line">Error opening file: Unknown error</span><br></pre></td></tr></table></figure>

<h2 id="程序退出状态"><a href="#程序退出状态" class="headerlink" title="程序退出状态"></a>程序退出状态</h2><p>通常情况下，程序成功执行完一个操作正常退出的时候会带有值 EXIT_SUCCESS。在这里，EXIT_SUCCESS 是宏，它被定义为 0。</p>
<p>如果程序中存在一种错误情况，当您退出程序时，会带有状态值 EXIT_FAILURE，被定义为 -1。</p>
<p>exit（）函数关闭了所有打开的文件并终止程序，exit()函数的参数会被传递给一些操作系统，通常的约定是正常终止的程序传递值0,非正常终止的程序传递非0值。</p>
<p>exit（!0）； &#x2F;&#x2F;表示异常退出<br>exit（0）； &#x2F;&#x2F;表示正常退出</p>
<p>return 0；<br>exit（0）；<br>这两者之间表达的效果是相同的。<br>但是：不同的是，main（） 函数在一个递归程序中，exit（）会终止程序，但是return将控制权交给递归上一级直至到最初的一级。</p>
<p>exit() 的参数，是给自己的父进程使用的。通常一个程序的父进程可能是任何进程，因此我们无法预期我们的父进程是否规定必须要有这个<strong>返回值</strong>，那么我们应当提供这个返回值，以保证不同的父进程的需求得到满足。</p>
<p>虽然现在大多数平台下，直接在 main() 函数里面 return 可以退出程序。但是在某些平台下，在 main() 函数里面 return 会导致程序永远不退出（因为代码已经执行完毕，程序却还没有收到要退出的指令）。换句话说，为了兼容性考虑，在特定的平台下，程序最后一行必须使用 exit() 才能正常退出，这是 exit() 存在的重要价值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">肖汇林</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">肖汇林</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
