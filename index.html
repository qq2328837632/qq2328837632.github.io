<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="选择有时候比努力更重要">
<meta property="og:type" content="website">
<meta property="og:title" content="肖汇林的博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="肖汇林的博客">
<meta property="og:description" content="选择有时候比努力更重要">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="肖汇林">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>肖汇林的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖汇林的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/25/ZLTool-%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/25/ZLTool-%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E6%B1%A0/" class="post-title-link" itemprop="url">ZLTool-工作线程池</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-12-25 16:46:40 / 修改时间：22:32:08" itemprop="dateCreated datePublished" datetime="2023-12-25T16:46:40+08:00">2023-12-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>WorkThreadPool管理一组EventPoller事件轮询器线程，任务通过分配到不同的EventPoller来执行。</p>
<p><img src="/ZLTool-%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20231225165133846.png" alt="image-20231225165133846"></p>
<img src="/2023/12/25/ZLTool-%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20231225165133846.png" class title="This is an test image">

<p> 上图中可以大致看出WorkThreadPool的继承关系：</p>
<p>WorkThreadPool继承自TaskExecutorGettImp，而TaskExecutorGettImp管理了一组EventPoller(继承自TaskExecutor)，所以，工作线程池，实际上就是管理了一组EventPoller对象的类。</p>
<p>那为什么要叫线程池呢？我们可以看下EventPoller类的runLoop函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void EventPoller::runLoop(bool blocked,bool regist_self) &#123;</span><br><span class="line">    if (blocked) &#123;</span><br><span class="line">        /* epoll_wait或者select事件监听处理 */</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        _loop_thread = new thread(&amp;EventPoller::runLoop, this, true, regist_self);</span><br><span class="line">        _sem_run_started.wait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，runLoop函数中，开启了一个线程，所以，每一个EventPoller对象，实际上都持有一个线程。</p>
<hr>
<p><img src="/ZLTool-%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20231225171441235.png" alt="image-20231225171441235"></p>
<img src="/2023/12/25/ZLTool-%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20231225171441235.png" class title="This is an test image">

<h2 id="TaskExecutorGetterImp"><a href="#TaskExecutorGetterImp" class="headerlink" title="TaskExecutorGetterImp"></a>TaskExecutorGetterImp</h2><p>TaskExecutorGetterImp管理一组EventPoller对象，实现了简单的负载均衡，每次添加任务时，可以通过getExecutor接口选择一个负载最小的EventPoller来执行该任务。</p>
<h3 id="addPoller-创建一组EventPoller对象"><a href="#addPoller-创建一组EventPoller对象" class="headerlink" title="addPoller-创建一组EventPoller对象"></a>addPoller-创建一组EventPoller对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">size_t TaskExecutorGetterImp::addPoller(const string &amp;name, size_t size, int priority, bool register_thread, bool enable_cpu_affinity) &#123;</span><br><span class="line">    auto cpus = thread::hardware_concurrency();//静态成员函数，返回当前系统支持的并行线程数量,可以使用 cpus 变量来设置并行线程池中的工作线程数量，以便充分利用系统资源进行并行处理</span><br><span class="line">    //在具有多核处理器的系统上，hardware_concurrency() 函数通常返回硬件线程数，也就是可用于并行处理的最大线程数。如果硬件线程数未知，则返回一个不确定的正整数（通常为0或1）。</span><br><span class="line">    size = size &gt; 0 ? size : cpus;</span><br><span class="line">    for (size_t i = 0; i &lt; size; ++i) &#123;</span><br><span class="line">        auto full_name = name + &quot; &quot; + to_string(i);</span><br><span class="line">        auto cpu_index = i % cpus;</span><br><span class="line">        EventPoller::Ptr poller(new EventPoller(full_name));</span><br><span class="line">        poller-&gt;runLoop(false, register_thread);</span><br><span class="line">        poller-&gt;async([cpu_index, full_name, priority, enable_cpu_affinity]() &#123;</span><br><span class="line">            // 设置线程优先级</span><br><span class="line">            ThreadPool::setPriority((ThreadPool::Priority)priority);</span><br><span class="line">            // 设置线程名</span><br><span class="line">            setThreadName(full_name.data());</span><br><span class="line">            // 设置cpu亲和性</span><br><span class="line">            if (enable_cpu_affinity) &#123;</span><br><span class="line">                setThreadAffinity(cpu_index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        _threads.emplace_back(std::move(poller));</span><br><span class="line">    &#125;</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该接口主要是创建EventPoller对象，根据用户指定的数量来创建，或者根据系统CPU核心数来创建。runLoop接口中会开启线程并监听事件。</p>
<p>当 <code>runLoop</code> 的第一个参数 <code>blocked</code> 为 <code>true</code> 时，会在当前线程中监听事件；当 <code>blocked</code> 为 <code>false</code> 时，会创建一个新线程并在新线程中监听事件</p>
<h3 id="getExecutorDelay-获取所有线程任务执行延时"><a href="#getExecutorDelay-获取所有线程任务执行延时" class="headerlink" title="getExecutorDelay-获取所有线程任务执行延时"></a>getExecutorDelay-获取所有线程任务执行延时</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void TaskExecutorGetterImp::getExecutorDelay(const function&lt;void(const vector&lt;int&gt; &amp;)&gt; &amp;callback) &#123;</span><br><span class="line">    std::shared_ptr&lt;vector&lt;int&gt; &gt; delay_vec = std::make_shared&lt;vector&lt;int&gt;&gt;(_threads.size());</span><br><span class="line">    shared_ptr&lt;void&gt; finished(nullptr, [callback, delay_vec](void *) &#123;</span><br><span class="line">        //此析构回调触发时，说明已执行完毕所有async任务</span><br><span class="line">        callback((*delay_vec));</span><br><span class="line">    &#125;);</span><br><span class="line">    int index = 0;</span><br><span class="line">    for (auto &amp;th : _threads) &#123;</span><br><span class="line">        std::shared_ptr&lt;Ticker&gt; delay_ticker = std::make_shared&lt;Ticker&gt;();</span><br><span class="line">        th-&gt;async([finished, delay_vec, index, delay_ticker]() &#123;</span><br><span class="line">            (*delay_vec)[index] = (int) delay_ticker-&gt;elapsedTime();</span><br><span class="line">        &#125;, false);</span><br><span class="line">        ++index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过async插入一个用来计时的任务，获取当执行到该任务时所等待的时间。每一个线程添加的任务都捕获了finished智能指针对象，引用计数增加，当所有任务执行完成后，finished引用计数减为0，执行其自定义的删除器，通过回调将所有线程的任务执行延时返回。</p>
<h3 id="getExecutor-获取负载最轻的任务执行器"><a href="#getExecutor-获取负载最轻的任务执行器" class="headerlink" title="getExecutor-获取负载最轻的任务执行器"></a>getExecutor-获取负载最轻的任务执行器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">TaskExecutor::Ptr TaskExecutorGetterImp::getExecutor() &#123;</span><br><span class="line">    auto thread_pos = _thread_pos;</span><br><span class="line">    if (thread_pos &gt;= _threads.size()) &#123;</span><br><span class="line">        thread_pos = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TaskExecutor::Ptr executor_min_load = _threads[thread_pos];</span><br><span class="line">    auto min_load = executor_min_load-&gt;load();</span><br><span class="line"></span><br><span class="line">    for (size_t i = 0; i &lt; _threads.size(); ++i, ++thread_pos) &#123;</span><br><span class="line">        if (thread_pos &gt;= _threads.size()) &#123;</span><br><span class="line">            thread_pos = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        auto th = _threads[thread_pos];</span><br><span class="line">        auto load = th-&gt;load();</span><br><span class="line"></span><br><span class="line">        if (load &lt; min_load) &#123;</span><br><span class="line">            min_load = load;</span><br><span class="line">            executor_min_load = th;</span><br><span class="line">        &#125;</span><br><span class="line">        if (min_load == 0) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    _thread_pos = thread_pos;</span><br><span class="line">    return executor_min_load;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历所有任务执行器，并找到负载最轻的将其返回。</p>
<h2 id="WorkThreadPool"><a href="#WorkThreadPool" class="headerlink" title="WorkThreadPool"></a>WorkThreadPool</h2><p>WorkThreadPool基本上都是使用的其基类TaskExecutorGetterImp提供的方法，在构造函数中，调用基类的addPoller接口创建并启动了”工作线程池”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">EventPoller::Ptr WorkThreadPool::getFirstPoller() &#123;</span><br><span class="line">    return std::static_pointer_cast&lt;EventPoller&gt;(_threads.front());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventPoller::Ptr WorkThreadPool::getPoller() &#123;</span><br><span class="line">    return std::static_pointer_cast&lt;EventPoller&gt;(getExecutor());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WorkThreadPool::WorkThreadPool() &#123;</span><br><span class="line">    //最低优先级</span><br><span class="line">    addPoller(&quot;work poller&quot;, s_pool_size, ThreadPool::PRIORITY_LOWEST, false, s_enable_cpu_affinity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WorkThreadPool::setPoolSize(size_t size) &#123;</span><br><span class="line">    s_pool_size = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WorkThreadPool::enableCpuAffinity(bool enable) &#123;</span><br><span class="line">    s_enable_cpu_affinity = enable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::dynamic_pointer_cast</code> 在进行类型转换时更为安全，因为它会在运行时执行类型检查。它用于将 <code>std::shared_ptr</code> 对象进行动态类型转换，只有在源指针指向的对象类型可以安全地转换为目标类型时，转换才会成功。</p>
<p>与 <code>std::static_pointer_cast</code> 不同，<code>std::dynamic_pointer_cast</code> 在转换失败时不会引发异常，而是返回一个空的 <code>std::shared_ptr</code>。这允许我们在转换失败时进行适当的处理，而不会导致程序崩溃或出现未定义的行为。</p>
<hr>
<p><code>std::static_pointer_cast</code> 主要用于智能指针之间的类型转换，它可以进行向上转换和向下转换。</p>
<p>向上转换是指将派生类对象的指针转换为基类对象的指针，这是安全的操作，因为派生类对象可以被视为基类对象。</p>
<p>向下转换是指将基类对象的指针转换为派生类对象的指针，这是一种更具风险的操作。由于基类对象可能不是派生类对象，所以在进行向下转换时需要确保指针指向的实际对象类型与目标类型兼容。</p>
<p><code>std::static_pointer_cast</code> 可以执行向下转换，但它要求源指针必须指向目标类型或目标类型的派生类。如果源指针不满足这个条件，那么 <code>std::static_pointer_cast</code> 会在运行时引发 <code>std::bad_cast</code> 异常。</p>
<p>总结来说，<code>std::static_pointer_cast</code> 可以进行向上转换和向下转换，但在进行向下转换时需要确保类型兼容性，以避免出现异常或未定义的行为</p>
<h3 id="WorkThreadPool和ThreadPool的区别"><a href="#WorkThreadPool和ThreadPool的区别" class="headerlink" title="WorkThreadPool和ThreadPool的区别"></a>WorkThreadPool和ThreadPool的区别</h3><p> ThreadPool的“线程池”是一组std::Thread线程对象，池中所有线程共同工作在同一个任务队列上，通过信号量以及锁竟态的争抢任务来执行。</p>
<p>WorkThreadPool的“线程池“是一组EventPoller对象，每一个EventPoller对象内部都启动了一个std::Thread线程，EventPoller是一个事件处理器，在线程中监听指定事件，当事件到来时执行该事件对应的处理回调，默认的EventPoller监听了一个管道事件，对应在管道上有一个任务队列，当添加任务到队列时，触发管道事件，接着从队列中获取任务并执行。也就是说，每一个EventPoller线程都有一个自己的任务队列，多个线程之间不存在竞争关系。并且，还可以根据每一个线程的负载情况，均衡的将任务添加到多个线程中。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/21/ZLTool-%E7%BA%BF%E7%A8%8B%E8%B4%9F%E8%BD%BD%E8%AE%A1%E7%AE%97%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/21/ZLTool-%E7%BA%BF%E7%A8%8B%E8%B4%9F%E8%BD%BD%E8%AE%A1%E7%AE%97%E5%99%A8/" class="post-title-link" itemprop="url">ZLTool-线程负载计算器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-21 16:09:49" itemprop="dateCreated datePublished" datetime="2023-12-21T16:09:49+08:00">2023-12-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-22 17:10:46" itemprop="dateModified" datetime="2023-12-22T17:10:46+08:00">2023-12-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>线程负载计数器主要是统计一个线程处于休眠期与活跃期时间的占比。</p>
<h1 id="ThreadLoadCounter"><a href="#ThreadLoadCounter" class="headerlink" title="ThreadLoadCounter"></a>ThreadLoadCounter</h1><p>一个线程，要么处于活跃状态，在执行任务，此时占用CPU，要么处于休眠状态，等待任务的到来，此时不占用CPU，ThreadLoadCounter就是用于统计某一段时间内，线程处于活跃状态所占的比率。也可以说是该线程对CPU的使用率。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ThreadLoadCounter::ThreadLoadCounter(uint64_t max_size,uint64_t max_usec)&#123;</span><br><span class="line">    _last_sleep_time = _last_wake_time = getCurrentMicrosecond();</span><br><span class="line">    _max_size = max_size;</span><br><span class="line">    _max_usec = max_usec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指定了统计的样本数量以及时间范围。样本数量是统计休眠时间的次数与活跃时间的次数之和。比如max_size &#x3D; 1000，那就是500个休眠时间数据+500个活跃时间数据。</p>
<h2 id="startSleep"><a href="#startSleep" class="headerlink" title="startSleep"></a>startSleep</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void ThreadLoadCounter::startSleep() &#123;</span><br><span class="line">    lock_guard &lt;mutex&gt; lck(_mtx);</span><br><span class="line">    _sleeping = true;</span><br><span class="line">    auto current_time = getCurrentMicrosecond();</span><br><span class="line">    auto run_time = current_time - _last_wake_time;</span><br><span class="line">    _last_sleep_time = current_time;</span><br><span class="line">    _time_list.emplace_back(run_time, false);</span><br><span class="line">    if (_time_list.size() &gt; _max_size) &#123;</span><br><span class="line">        _time_list.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在阻塞的代码之前调用该接口，计算并记录本轮统计中，线程处于活跃状态的时间，即从线程被唤醒，执行完任务，到再次进入休眠状态的时间。</p>
<h2 id="sleepWakeUp"><a href="#sleepWakeUp" class="headerlink" title="sleepWakeUp"></a>sleepWakeUp</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void ThreadLoadCounter::sleepWakeUp() &#123;</span><br><span class="line">    lock_guard &lt;mutex&gt; lck(_mtx);</span><br><span class="line">    _sleeping = false;</span><br><span class="line">    auto current_time = getCurrentMicrosecond();</span><br><span class="line">    auto sleep_time = current_time - _last_sleep_time;</span><br><span class="line">    _last_wake_time = current_time;</span><br><span class="line">    _time_list.emplace_back(sleep_time, true);</span><br><span class="line">    if (_time_list.size() &gt; _max_size) &#123;</span><br><span class="line">        _time_list.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在阻塞的代码之后调用该接口，计算并记录本轮统计中，线程处于休眠状态的时间，即从线程开始休眠，到被唤醒的时间。</p>
<h2 id="load"><a href="#load" class="headerlink" title="load"></a>load</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">int ThreadLoadCounter::load() &#123;</span><br><span class="line">    lock_guard&lt;mutex&gt; lck(_mtx);</span><br><span class="line">    uint64_t totalSleepTime = 0;</span><br><span class="line">    uint64_t totalRunTime = 0;</span><br><span class="line">    _time_list.for_each([&amp;](const TimeRecord &amp;rcd) &#123;</span><br><span class="line">        if (rcd._sleep) &#123;</span><br><span class="line">            totalSleepTime += rcd._time;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            totalRunTime += rcd._time;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">if (_sleeping) &#123;</span><br><span class="line">    totalSleepTime += (getCurrentMicrosecond() - _last_sleep_time);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    totalRunTime += (getCurrentMicrosecond() - _last_wake_time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64_t totalTime = totalRunTime + totalSleepTime;</span><br><span class="line">while ((_time_list.size() != 0) &amp;&amp; (totalTime &gt; _max_usec || _time_list.size() &gt; _max_size)) &#123;</span><br><span class="line">    TimeRecord &amp;rcd = _time_list.front();</span><br><span class="line">    if (rcd._sleep) &#123;</span><br><span class="line">        totalSleepTime -= rcd._time;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        totalRunTime -= rcd._time;</span><br><span class="line">    &#125;</span><br><span class="line">    totalTime -= rcd._time;</span><br><span class="line">    _time_list.pop_front();</span><br><span class="line">&#125;</span><br><span class="line">if (totalTime == 0) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">return (int) (totalRunTime * 100 / totalTime);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要获取当前线程最近max_usec时间范围内的负载率时，调用该接口。</p>
<p>对统计的所有样本数据，计算总时间(运行时间总和+休眠时间总和)，总时间和样本数量应该在指定的范围内，如果超过则删除最早的记录。</p>
<hr>
<p> 使用ThreadLoadCounter统计：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void runLoop()&#123;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        startSleep();</span><br><span class="line">        epoll_wait();</span><br><span class="line">        sleepWakeUp();</span><br><span class="line">        /*事件处理*/</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="任务执行器"><a href="#任务执行器" class="headerlink" title="任务执行器"></a>任务执行器</h1><p>任务执行器是一个抽象接口类，定义了一套同步及异步执行任务的接口。</p>
<p><img src="/ZLTool-%E7%BA%BF%E7%A8%8B%E8%B4%9F%E8%BD%BD%E8%AE%A1%E7%AE%97%E5%99%A8/image-20231222165240112.png" alt="image-20231222165240112"></p>
<img src="/2023/12/21/ZLTool-%E7%BA%BF%E7%A8%8B%E8%B4%9F%E8%BD%BD%E8%AE%A1%E7%AE%97%E5%99%A8/image-20231222165240112.png" class title="This is an test image">

<p> TaskExecutor继承了ThreadLoadCounter和TaskExecutorInterface，其除了构造函数外，没有其他成员函数。因为TaskExecutorInterface是一个抽象类，所以TaskExecutor也是一个抽象类。目前继承任务执行器的类有两个，ThreadPool和EventPoller。</p>
<h3 id="异步执行任务"><a href="#异步执行任务" class="headerlink" title="异步执行任务"></a>异步执行任务</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">virtual Task::Ptr async(TaskIn task, bool may_sync = true) = 0;</span><br><span class="line"></span><br><span class="line">virtual Task::Ptr async_first(TaskIn task, bool may_sync = true);</span><br><span class="line">Task::Ptr TaskExecutorInterface::async_first(TaskIn task, bool may_sync) &#123;</span><br><span class="line">    return async(std::move(task),may_sync);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> async是一个纯虚函数，需要派生类来实现， async_first需要将任务插入到队列头部优先执行，虽然该类中默认直接调用了async，但实际使用时，用户需要重新定义该函数。因为针对特定的业务场景，用户可能需要对任务调度进行性能优化，例如根据任务类型或其他条件选择不同的调度策略，这就需要重新定义async_first函数</p>
<h3 id="同步执行任务"><a href="#同步执行任务" class="headerlink" title="同步执行任务"></a>同步执行任务</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void TaskExecutorInterface::sync(const TaskIn &amp;task) &#123;</span><br><span class="line">    semaphore sem;</span><br><span class="line">    auto ret = async([&amp;]() &#123;</span><br><span class="line">        onceToken token(nullptr, [&amp;]() &#123;</span><br><span class="line">            //通过RAII原理防止抛异常导致不执行这句代码</span><br><span class="line">             /*通过RAII（Resource Acquisition Is Initialization）原理可以防止抛出异常导致不执行sem.post()这句代码。RAII是一种C++编程范式，通过在对象的构造函数中获取资源，在对象的析构函数中释放资源，从而保证资源的正确定义和释放。</span><br><span class="line">在上述代码中，onceToken对象的构造函数中会执行匿名函数，而该匿名函数包含了sem.post()方法。如果在执行task()期间发生了异常，onceToken对象也会被正确地销毁，从而触发其析构函数，确保semaphore对象的post()方法会被调用以正常释放资源。因此，通过RAII原理可以保证即使在task()执行期间发生异常，也能够正确地执行sem.post()，避免资源泄漏。*/</span><br><span class="line">            sem.post();</span><br><span class="line">        &#125;);</span><br><span class="line">        task();</span><br><span class="line">    &#125;);</span><br><span class="line">    if (ret &amp;&amp; *ret) &#123;//只有当ret本身有效且指向的对象也有效时，整个条件表达式才会被视为真。如果ret为空指针或者指向的对象为空，整个条件表达式就会被视为假</span><br><span class="line">        sem.wait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TaskExecutorInterface::sync_first(const TaskIn &amp;task) &#123;</span><br><span class="line">    semaphore sem;</span><br><span class="line">    auto ret = async_first([&amp;]() &#123;</span><br><span class="line">        onceToken token(nullptr, [&amp;]() &#123;</span><br><span class="line">            //通过RAII原理防止抛异常导致不执行这句代码</span><br><span class="line">            sem.post();</span><br><span class="line">        &#125;);</span><br><span class="line">        task();</span><br><span class="line">    &#125;);</span><br><span class="line">    if (ret &amp;&amp; *ret) &#123;</span><br><span class="line">        sem.wait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步执行任务sync通过调用async接口实现，接口阻塞在sem条件变量上，直到任务被异步执行完成触发post后，wait被唤醒，接口才能返回。所以，任务的执行实际是异步的，但该接口是同步的。</p>
<p>类似的，同步优先执行任务sync_first是通过async_first接口实现。</p>
<h3 id="TaskExecutor"><a href="#TaskExecutor" class="headerlink" title="TaskExecutor"></a>TaskExecutor</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TaskExecutor(uint64_t max_size = 32, uint64_t max_usec = 2 * 1000 * 1000);</span><br><span class="line">TaskExecutor::TaskExecutor(uint64_t max_size, uint64_t max_usec) : ThreadLoadCounter(max_size, max_usec) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>该类没有其它成员函数，构造函数中，指定了线程负载计算器的统计样本数量和统计时间范围。默认情况下，样本数量是32，时间范围是最近2秒钟(时间单位是微秒)。</p>
<p>这里我认为对基类进行初始化有几点好处：因为继承的成员变量是私有的，访问不到，需要间接赋值，更加直观。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/20/ZLTool%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BB%84%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/20/ZLTool%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BB%84%E4%BB%B6/" class="post-title-link" itemprop="url">ZLTool线程池组件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-20 15:34:33" itemprop="dateCreated datePublished" datetime="2023-12-20T15:34:33+08:00">2023-12-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-23 16:50:40" itemprop="dateModified" datetime="2023-12-23T16:50:40+08:00">2023-12-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>线程模块主要包含以下文件：</p>
<table>
<thead>
<tr>
<th>semaphore.h</th>
<th>信号量。semaphore类，封装了条件变量，提供了post和wait方法。</th>
</tr>
</thead>
<tbody><tr>
<td>TaskExecutor.cpp，TaskExecutor.h</td>
<td>包括线程负载计数器(ThreadLoadCounter)、任务执行器(TaskExecutor)、任务执行器获取器(TaskExecutorGetterImp)、可取消任务封装类(TaskCancelableImp)</td>
</tr>
<tr>
<td>TaskQueue.h</td>
<td>任务队列。队列中存储的是函数对象，任务的类型是function&lt;void()&gt;，所以可以存储所有的可调用对象，包括函数、lambda表达式、重载了()运算符的类实例化对象。</td>
</tr>
<tr>
<td>threadgroup.h</td>
<td>线程组。管理一组线程。提供了创建线程(create_thread)、删除指定线程(remove_thread)、等待线程组中的线程退出(join_all)、判断指定线程是否在线程组中(is_thread_in)、判断当前线程是否在线程组中(is_this_thread_in)、获取当前线程组中线程数量(size)</td>
</tr>
<tr>
<td>ThreadPool.h</td>
<td>线程池。组件管理者，将任务队列以及线程组关联起来使用。继承了TaskExecutor，支持同步和 异步执行任务。</td>
</tr>
<tr>
<td>WorkThreadPool.cpp，WorkThreadPool.h</td>
<td>工作线程池，也是管理一组线程，但和ThreadPool不同，ThreadPool所有线程共享任务队列，存在竞争关系，而WorkThreadPool中的每个线程都有自己的队列(实际上是EventPoller管道事件驱动，一个 EventPoller对应一个线程)、各线程不存在竞争关系。</td>
</tr>
</tbody></table>
<p>各文件中的类关系如下图：</p>
<p><img src="/ZLTool%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BB%84%E4%BB%B6/image-20231220164902318.png" alt="image-20231220164902318"></p>
<img src="/2023/12/20/ZLTool%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BB%84%E4%BB%B6/image-20231220164902318.png" class title="This is an test image">

<p><img src="/ZLTool%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BB%84%E4%BB%B6/image-20231220165017825.png" alt="image-20231220165017825"></p>
<img src="/2023/12/20/ZLTool%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BB%84%E4%BB%B6/image-20231220165017825.png" class title="This is an test image">

<hr>
<p>线程池的两个基本组件：任务队列与线程组</p>
<h1 id="任务队列TaskQueue"><a href="#任务队列TaskQueue" class="headerlink" title="任务队列TaskQueue"></a>任务队列TaskQueue</h1><p>封装TaskQueue类，提供了添加任务、获取任务、清空任务队列接口，通过semaphore控制添加与获取之间的同步。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class TaskQueue &#123;</span><br><span class="line">public:</span><br><span class="line">    //添加任务</span><br><span class="line">    template&lt;typename C&gt;</span><br><span class="line">    void push_task(C &amp;&amp;task_func);</span><br><span class="line">    template&lt;typename C&gt;</span><br><span class="line">    void push_task_first(C &amp;&amp;task_func);//C &amp;&amp;task_func 是一个右值引用参数</span><br><span class="line">    //当传递一个左值对象时，编译器会进行类型推导，将左值对象转换为右值引用。当传递一个右值对象时，直接使用右值引用接收，避免了额外的拷贝操作</span><br><span class="line">    //清空任务列队</span><br><span class="line">    void push_exit(size_t n);</span><br><span class="line">    //获取任务</span><br><span class="line"> bool get_task(T &amp;tsk);</span><br><span class="line">    size_t size();</span><br><span class="line">private:</span><br><span class="line">    List&lt;T&gt; _queue;</span><br><span class="line">    mutable mutex _mutex;</span><br><span class="line">    semaphore _sem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>T &amp;tsk</code> 和 <code>C &amp;&amp;task_func</code> 都是用来传递参数的，但它们之间存在一些重要的区别。</p>
<ol>
<li>左值引用 vs 右值引用：<ul>
<li><code>T &amp;tsk</code> 是左值引用，它只能绑定到左值对象（具名对象），不能绑定到临时对象或表达式；</li>
<li><code>C &amp;&amp;task_func</code> 是右值引用，它可以绑定到临时对象（右值），也可以通过 <code>std::move</code> 将左值转换为右值引用。</li>
</ul>
</li>
<li>对象生命周期管理：<ul>
<li>通过左值引用传递参数，不会改变被引用对象的生命周期，而是直接操作原始对象；</li>
<li>通过右值引用传递参数，可以移动语义，即允许将临时对象的资源所有权转移给目标对象，从而避免额外的拷贝操作</li>
</ul>
</li>
</ol>
<hr>
<p>push_task在队列的尾部添加任务，push_task_first在队列的头部添加任务。</p>
<p>为什么不直接使用void push_task(T &amp;&amp;task_func)而要用模板呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename C&gt; </span><br><span class="line"> void push_task(C &amp;&amp;task_func);</span><br><span class="line">void push_task(T &amp;&amp;task_func);</span><br><span class="line">void push_task(T &amp;task_func);</span><br><span class="line">void push_task(const T &amp;task_func);</span><br></pre></td></tr></table></figure>

<p> push_task(T &amp;&amp;task_func)只能接受右值引用，push_task(T &amp;task_func)不能接受右值引用，push_task(const T &amp;task_func)接受右值时会产生临时变量。<strong>模板因为引用折叠，既能接受左值，也能接受右值。函数模板<code>push_task</code>接受了一个名为<code>task_func</code>的通用类型<code>C</code>的参数，该参数使用了右值引用折叠。因此，这个函数模板可以接受左值引用或右值引用，并且可以在传递参数时进行移动语义操作。</strong></p>
<hr>
<p>从队列中获取一个任务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bool get_task(T &amp;tsk) &#123;</span><br><span class="line">    _sem.wait();</span><br><span class="line">    lock_guard&lt;decltype(_mutex)&gt; lock(_mutex);</span><br><span class="line">    if (_queue.size() == 0) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //改成右值引用后性能提升了1倍多！</span><br><span class="line">    tsk = std::move(_queue.front());</span><br><span class="line">    _queue.pop_front();</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 阻塞在条件变量上，等待队列中添加任务或者通过push_exit主动退出</p>
<p>清空任务列队(让get_task接口返回false)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_exit</span><span class="params">(<span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    _sem.<span class="built_in">post</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任务的数量由semaphore类中的_ count成员控制，正常情况下，每给队列添加一个任务，触发一次_sem.post(1)，任务数量加1，每次wait返回时，队列中都是有任务的，get_task总能获取到一个任务，返回true。此处，在实际没有给队列中添加任务的情况下，让wait多返回了n次，这n次get_task肯定是获取不到任务的，会返回false。线程池中利用get_task返回false来达到退出线程的目的。<strong>如启动了4个工作线程来获取任务，每个线程都等待在get_task上，主线程中调用push_exit(4)，get_task就会有四次返回false，以此让工作线程退出。</strong></p>
<h2 id="semaphore"><a href="#semaphore" class="headerlink" title="semaphore"></a>semaphore</h2><p>封装条件变量condition_variable_any的使用，提供了post和wait接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void post(size_t n = 1) &#123;</span><br><span class="line">    unique_lock&lt;mutex&gt; lock(_mutex);</span><br><span class="line">    _count += n;</span><br><span class="line">    if(n == 1)&#123;</span><br><span class="line">        _condition.notify_one();</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        _condition.notify_all();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void wait() &#123;</span><br><span class="line">    unique_lock&lt;mutex&gt; lock(_mutex);</span><br><span class="line">    while (_count == 0) &#123;</span><br><span class="line">        _condition.wait(lock);</span><br><span class="line">    &#125;</span><br><span class="line">    --_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> _ count成员记录希望wait接口返回的次数。默认情况下，每调用一次post，_ count加1，通过notify_one，所有等待在_ condition.wait上的线程其中一个被唤醒。如果n大于1，将通过notify_all唤醒所有等待在_condition.wait上的线程。</p>
<p>对于生产者消费者模型，count记录产品数量，post每次生产一个或者多个产品，wait每次消费一个产品，wait被唤醒后，会一直执行，直到产品都被消耗完。</p>
<p>在线程池的实现中，通过在没有添加任务的情况下，调用post(n&gt;1)来控制线程的退出。</p>
<h1 id="线程组thread-group"><a href="#线程组thread-group" class="headerlink" title="线程组thread_group"></a>线程组thread_group</h1><p>管理一组线程，接口：添加线程、删除线程、等待线程组中所有线程退出、判断指定的线程是否在线程组中、判断当前线程是否在线程组中</p>
<h3 id="判断当前线程是否在线程组中"><a href="#判断当前线程是否在线程组中" class="headerlink" title="判断当前线程是否在线程组中"></a>判断当前线程是否在线程组中</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bool is_this_thread_in() &#123;</span><br><span class="line">    auto thread_id = this_thread::get_id();</span><br><span class="line">    if(_thread_id == thread_id)&#123;//意义是？比unordered_map遍历快？为了提高运行效率？</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return _threads.find(thread_id) != _threads.end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断指定的线程是否在线程组中"><a href="#判断指定的线程是否在线程组中" class="headerlink" title="判断指定的线程是否在线程组中"></a>判断指定的线程是否在线程组中</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bool is_thread_in(thread* thrd) &#123;</span><br><span class="line">    if (!thrd) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    auto it = _threads.find(thrd-&gt;get_id());</span><br><span class="line">    return it != _threads.end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加线程"><a href="#添加线程" class="headerlink" title="添加线程"></a>添加线程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename F&gt;</span><br><span class="line">thread* create_thread(F &amp;&amp;threadfunc) &#123;</span><br><span class="line">    auto thread_new = std::make_shared&lt;thread&gt;(threadfunc);</span><br><span class="line">    _thread_id = thread_new-&gt;get_id();</span><br><span class="line">    _threads[_thread_id] = thread_new;</span><br><span class="line">    return thread_new.get();//调用 std::shared_ptr 对象的 get 方法，用于获取指向的原始指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除线程"><a href="#删除线程" class="headerlink" title="删除线程"></a>删除线程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void remove_thread(thread* thrd) &#123;</span><br><span class="line">    auto it = _threads.find(thrd-&gt;get_id());</span><br><span class="line">    if (it != _threads.end()) &#123;</span><br><span class="line">        _threads.erase(it);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="等待线程组中所有线程退出"><a href="#等待线程组中所有线程退出" class="headerlink" title="等待线程组中所有线程退出"></a>等待线程组中所有线程退出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void join_all() &#123;</span><br><span class="line">    if (is_this_thread_in()) &#123;</span><br><span class="line">        throw runtime_error(&quot;thread_group: trying joining itself&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    for (auto &amp;it : _threads) &#123;</span><br><span class="line">        if (it.second-&gt;joinable()) &#123;</span><br><span class="line">            it.second-&gt;join(); //等待线程主动退出</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    _threads.clear();//清空线程组 _threads，以便下次使用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 C++ 中，当一个线程完成运行后，它需要被明确地加入（join），这样才能释放线程所占用的资源。因此，当 <code>it.second-&gt;joinable()</code> 返回 <code>true</code> 时，意味着线程仍在运行或者已经完成运行但尚未被加入，此时需要调用 <code>it.second-&gt;join()</code> 来等待线程完成并进行资源回收。相反，如果 <code>it.second-&gt;joinable()</code> 返回 <code>false</code>，则表示线程已经完成运行并且已经被加入，不再需要进一步处理。</p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>基于**任务队列(TaskQueue)和线程组(thread_group)**，实现线程池，线程池中所有线程等待在任务队列上，循环执行：等待任务到来-&gt;获取到任务-&gt;执行任务。</p>
<p> ThreadPool继承自TaskExecutor，TaskExecutor又同时继承了ThreadLoadCounter和TaskExecutorInterface，所以线程池支持负载统计、同步以及异步执行任务。以下是线程池支持的所有接口说明</p>
<p><img src="/ZLTool%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BB%84%E4%BB%B6/image-20231222171453254.png" alt="image-20231222171453254"></p>
<img src="/2023/12/20/ZLTool%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BB%84%E4%BB%B6/image-20231222171453254.png" class title="This is an test image">

<h3 id="start-创建并启动线程"><a href="#start-创建并启动线程" class="headerlink" title="start-创建并启动线程"></a>start-创建并启动线程</h3><p>线程组中创建指定数量的线程，当线程组中线程数不足时，补齐缺少的。已经达到指定数量时，该接口什么也不做。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void start() &#123;</span><br><span class="line">        if (_thread_num &lt;= 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        size_t total = _thread_num - _thread_group.size();</span><br><span class="line">        for (size_t i = 0; i &lt; total; ++i) &#123;</span><br><span class="line">            _thread_group.create_thread([this, i]() &#123;run(i);&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="wait-等待线程组中所有线程退出"><a href="#wait-等待线程组中所有线程退出" class="headerlink" title="wait-等待线程组中所有线程退出"></a>wait-等待线程组中所有线程退出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void wait() &#123;</span><br><span class="line">        _thread_group.join_all();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="shutdown-队列中所有任务执行完成后让线程退出"><a href="#shutdown-队列中所有任务执行完成后让线程退出" class="headerlink" title="shutdown-队列中所有任务执行完成后让线程退出"></a>shutdown-队列中所有任务执行完成后让线程退出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void shutdown() &#123;</span><br><span class="line">        _queue.push_exit(_thread_num);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p> 队列的push_task和push_task_first会插入任务并触发一次唤醒wait的操作，等待在队列上的线程此时会从队列中获取到任务并执行。</p>
<p>但是push_exit没有给队列插入任务，也会触发其参数指定的n次唤醒wait的操作，等待在队列上的线程被唤醒后，因为实际并没有插入任务，所以这n次是获取不到任务的，队列为空。</p>
<p>基于上述条件，实现了run函数的自动退出(获取任务失败时，退出线程)，push_exit指定多唤醒的次数与线程组中线程数量一致，每唤醒一次，就有一个线程被退出，最终刚好让所有线程都退出。</p>
<p>调用shutdown之后，需要调用wait()函数等待线程全部退出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void run() &#123;</span><br><span class="line">        ThreadPool::setPriority(_priority);</span><br><span class="line">        Task::Ptr task;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            startSleep();</span><br><span class="line">            if (!_queue.get_task(task)) &#123;//引用传递</span><br><span class="line">                //空任务，退出线程</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            sleepWakeUp();</span><br><span class="line">            try &#123;</span><br><span class="line">                (*task)();//执行任务的具体代码。然后将任务指针 task 置为空指针，表示该任务已经执行完毕</span><br><span class="line">                task = nullptr;</span><br><span class="line">            &#125; catch (std::exception &amp;ex) &#123;</span><br><span class="line">                ErrorL &lt;&lt; &quot;ThreadPool执行任务捕获到异常:&quot; &lt;&lt; ex.what();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="async-异步执行任务"><a href="#async-异步执行任务" class="headerlink" title="async-异步执行任务"></a>async-异步执行任务</h3><p>如果允许同步执行，并且当前调用线程在线程组中，则同步执行任务。否则将任务放入队列中异步执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Task::Ptr async(TaskIn task,bool may_sync = true) override &#123;</span><br><span class="line">        if (may_sync &amp;&amp; _thread_group.is_this_thread_in()) &#123;</span><br><span class="line">            task();</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        auto ret = std::make_shared&lt;Task&gt;(std::move(task));</span><br><span class="line">        _queue.push_task(ret);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="async-first异步优先执行任务"><a href="#async-first异步优先执行任务" class="headerlink" title="async-first异步优先执行任务"></a>async-first异步优先执行任务</h3><p>与async的区别是，async将任务放在队尾，async-first将任务放在队首，确保优先执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Task::Ptr async_first(TaskIn task,bool may_sync = true) override&#123;</span><br><span class="line">        if (may_sync &amp;&amp; _thread_group.is_this_thread_in()) &#123;</span><br><span class="line">            task();</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        auto ret = std::make_shared&lt;Task&gt;(std::move(task));</span><br><span class="line">        _queue.push_task_first(ret);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="任务类型"><a href="#任务类型" class="headerlink" title="任务类型"></a>任务类型</h1><p>这部分看一下任务队列中插入的任务类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TaskQueue&lt;Task::Ptr&gt; _queue;</span><br></pre></td></tr></table></figure>

<p>队列中的任务类型是Task::Ptr，此外，我们还需要看另一个类型，TaskIn，他作为用户添加任务时的任务类型。在TaskExecutor.h中，两者声明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">using TaskIn = function&lt;void()&gt;;</span><br><span class="line"></span><br><span class="line">using Task = TaskCancelableImp&lt;void()&gt;;</span><br><span class="line">using Ptr = std::shared_ptr&lt;TaskCancelableImp&gt;;</span><br></pre></td></tr></table></figure>

<h2 id="TaskIn"><a href="#TaskIn" class="headerlink" title="TaskIn"></a>TaskIn</h2><p>一个基于std::function的可调用对象封装类型，其返回值是void，且没有参数。用户可以传入任何符合要求的可调用对象，如lambda表达式、函数指针、重载了operator()的类函数对象。 </p>
<h2 id="Task-Ptr"><a href="#Task-Ptr" class="headerlink" title="Task::Ptr"></a>Task::Ptr</h2><p>TaskCancelableImp&lt;void()&gt;类型的智能指针。 <strong>TaskCancelableImp是一个可取消的任务封装器</strong>，实际上是对TaskIn的再次封装。TaskCancelableImp的内部存<strong>储了TaskIn类型的对象</strong>。</p>
<p>看一下TaskCancelableImp的模板实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class R, class... ArgTypes&gt;</span><br><span class="line">class TaskCancelableImp;</span><br><span class="line"></span><br><span class="line">template&lt;class R, class... ArgTypes&gt;</span><br><span class="line">class TaskCancelableImp&lt;R(ArgTypes...)&gt; : public TaskCancelable &#123;</span><br><span class="line">public:</span><br><span class="line">    using Ptr = std::shared_ptr&lt;TaskCancelableImp&gt;;</span><br><span class="line">    using func_type = function&lt;R(ArgTypes...)&gt;;</span><br><span class="line"></span><br><span class="line">~TaskCancelableImp() = default;</span><br><span class="line"></span><br><span class="line">template&lt;typename FUNC&gt;</span><br><span class="line">TaskCancelableImp(FUNC &amp;&amp;task) &#123;</span><br><span class="line">    _strongTask = std::make_shared&lt;func_type&gt;(std::forward&lt;FUNC&gt;(task));</span><br><span class="line">    _weakTask = _strongTask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void cancel() override &#123;</span><br><span class="line">    _strongTask = nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">operator bool() &#123;</span><br><span class="line">    return _strongTask &amp;&amp; *_strongTask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void operator=(nullptr_t) &#123;</span><br><span class="line">    _strongTask = nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">R operator()(ArgTypes ...args) const &#123;</span><br><span class="line">    auto strongTask = _weakTask.lock();</span><br><span class="line">    if (strongTask &amp;&amp; *strongTask) &#123;</span><br><span class="line">        return (*strongTask)(forward&lt;ArgTypes&gt;(args)...);</span><br><span class="line">    &#125;</span><br><span class="line">    return defaultValue&lt;R&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    std::weak_ptr&lt;func_type&gt; _weakTask;</span><br><span class="line">    std::shared_ptr&lt;func_type&gt; _strongTask;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>class TaskCancelableImp&lt;R(ArgTypes…)&gt;是TaskCancelableImp的偏例化(部分特例化)，它的全特化版本就是Task（using Task &#x3D; TaskCancelableImp&lt;void()&gt;）。</p>
<p>构造函数TaskCancelableImp(FUNC &amp;&amp;task) 中可以看出，它接受的是一个func_type类型的参数，<strong>即function&lt;R(ArgTypes…)&gt;，这与我们让用户输入的TaskIn的类型一致</strong>。该类<strong>提供了cancel接口，可以在任务执行前取消任务</strong>。</p>
<p>当我们调用任务时，<code>operator()</code> 函数会首先检查 <code>_weakTask</code> 是否仍然有效，如果有效，则通过 <code>_weakTask</code> 获取到 <code>_strongTask</code> 的指针。如果 <code>_strongTask</code> 不为 <code>nullptr</code>，则会执行任务并返回结果；如果 <code>_strongTask</code> 已经被设置为 <code>nullptr</code>，则会返回默认值。</p>
<p>因此，如果我们在任务执行前调用了 <code>cancel</code> 接口并将 <code>_strongTask</code> 设置为 <code>nullptr</code>，则在调用任务时会直接返回默认值，从而达到了取消任务的效果。</p>
<p>为什么任务队列不直接使用TaskIn类型而<strong>要用Task类型</strong>呢？主要是为了支持任务的可中途取消。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TaskQueue&lt;std::shared_ptr&lt;TaskIn&gt;&gt; _queue;</span><br><span class="line">TaskQueue&lt;std::shared_ptr&lt;Task&gt;&gt; _queue;</span><br><span class="line">//TaskQueue&lt;Task::Ptr&gt; _queue;</span><br></pre></td></tr></table></figure>

<p><code>_queue.get_task(task)</code>的task可以调用<code>task-&gt;cancel()</code>;</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>线程池的测试程序是test_threadPoolBenchmark.cpp文件，具体可以看源码。</p>
<p>该部分使用了lambda表达式作为任务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool.async([&amp;]()&#123;</span><br><span class="line">		   if(++count &gt;= 1000*10000)&#123;</span><br><span class="line">			   InfoL &lt;&lt; &quot;执行1000万任务总共耗时:&quot; &lt;&lt; ticker.elapsedTime() &lt;&lt; &quot;ms&quot;;</span><br><span class="line">		   &#125;</span><br><span class="line">		&#125;);</span><br></pre></td></tr></table></figure>

<p>当然也可以使用函数指针或者函数对象，以重载operator()的函数对象作为任务的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class MyTask &#123;</span><br><span class="line">public:</span><br><span class="line">    MyTask(atomic_llong* pCount) :m_pCount(pCount)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void operator()() &#123;</span><br><span class="line">	if (++(*m_pCount) &gt;= 1000 * 10000) &#123;</span><br><span class="line">		InfoL &lt;&lt; &quot;执行1000万任务总共耗时:&quot; &lt;&lt; ticker.elapsedTime() &lt;&lt; &quot;ms&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    atomic_llong* m_pCount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyTask myTask(&amp;count);</span><br><span class="line">pool.async(myTask);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/18/ZLTool-%E8%B5%84%E6%BA%90%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/18/ZLTool-%E8%B5%84%E6%BA%90%E6%B1%A0/" class="post-title-link" itemprop="url">ZLTool-资源池</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-12-18 14:07:44 / 修改时间：16:17:57" itemprop="dateCreated datePublished" datetime="2023-12-18T14:07:44+08:00">2023-12-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="源码结构分析"><a href="#源码结构分析" class="headerlink" title="源码结构分析"></a>源码结构分析</h1><p>该部分功能在ResourcePool.h中实现，由shared_ptr_imp、ResourcePool_l、ResourcePool三个类组成,资源池中的对象被获取使用后，直到使用完成回收后才能被下一个使用者获取到。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//显式释放对象,让对象重新进入循环列队，这时该对象应该会被后台线程持有并赋值</span><br><span class="line">    reservedObj.reset();</span><br></pre></td></tr></table></figure>

<h2 id="对象封装智能指针：shared-ptr-imp"><a href="#对象封装智能指针：shared-ptr-imp" class="headerlink" title="对象封装智能指针：shared_ptr_imp"></a>对象封装智能指针：shared_ptr_imp</h2><p>智能指针实现类，管理资源的自动回收。每次要获取一个C资源对象到外部使用时，都先把该资源通过shared_ptr_imp进行封装，shared_ptr_imp对象析构时，会回收资源</p>
<p>测试的代码是 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//大小为50的循环池</span><br><span class="line">    ResourcePool&lt;string_imp&gt; pool;</span><br><span class="line">    pool.setSize(50);</span><br><span class="line"></span><br><span class="line">    //获取一个对象,该对象将被主线程持有，并且不会被后台线程获取并赋值</span><br><span class="line">    auto reservedObj = pool.obtain();</span><br><span class="line">    </span><br><span class="line">    在ResourcePool中有</span><br><span class="line"> 	using ValuePtr = shared_ptr_imp&lt;C&gt;;   </span><br><span class="line">    ValuePtr obtain(const std::function&lt;void(C *)&gt; &amp;on_recycle = nullptr) &#123; return pool-&gt;obtain(on_recycle); &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename C&gt;</span><br><span class="line">class shared_ptr_imp : public std::shared_ptr&lt;C&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">    shared_ptr_imp() &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 构造智能指针</span><br><span class="line">     * @param ptr 裸指针</span><br><span class="line">     * @param weakPool 管理本指针的循环池</span><br><span class="line">     * @param quit 对接是否放弃循环使用</span><br><span class="line">     */</span><br><span class="line">    shared_ptr_imp(C *ptr,</span><br><span class="line">                  const std::weak_ptr&lt;ResourcePool_l&lt;C&gt; &gt; &amp;weakPool,</span><br><span class="line">                   std::shared_ptr&lt;atomic_bool&gt; quit,</span><br><span class="line">                   const function&lt;void(C *)&gt; &amp;on_recycle);</span><br><span class="line"> </span><br><span class="line">    /**    </span><br><span class="line">    * 放弃或恢复回到循环池继续使用，该函数设置的_quit影响的是shared_ptr_imp构造函数中自定义的lambda删除器</span><br><span class="line">     * @param flag</span><br><span class="line">     */</span><br><span class="line">    void quit(bool flag = true)&#123;</span><br><span class="line">        if(_quit)&#123;//此处是判断指针是否有效，而不是判断_quit的值是否为true</span><br><span class="line">            *_quit = flag;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    std::shared_ptr&lt;atomic_bool&gt; _quit;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>shared_ptr_imp的有参构造函数中，使用lambda自定义了自身析构时的删除器，该删除器决定了是删除C对象还是将C对象重新添加到对象池中。如下，可以看到，如果对象池还在使用，并且用户在资源没有被使用时不想删除资源，即回收资源(指定quit为false)，那么就会重新将该资源回收到对象池中，否则直接删除资源。此处，使用std::move将quit转为右值引用，通过_quit的移动构造函数转移了对象。lambda中捕获的quit即变成 _quit，后续通过void quit(bool flag &#x3D; true)函数可以修改 _quit的值来决定资源是否被删除。</p>
<p>所以，shared_ptr_imp对象的构造和析构次数和C资源的构造析构次数是不一样的，两者没有关系，由用户指定C资源是回收还是删除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/* 自定义了删除器,删除器处理逻辑如下：</span><br><span class="line">1、如果对象池还在，且明确要回收该对象(quit为false)，则调用对象池的回收函数</span><br><span class="line">2、否则，直接删除该对象，不再放入对象池中 */</span><br><span class="line">template&lt;typename C&gt;</span><br><span class="line">shared_ptr_imp&lt;C&gt;::shared_ptr_imp(C *ptr,</span><br><span class="line">                                  const std::weak_ptr&lt;ResourcePool_l&lt;C&gt; &gt; &amp;weakPool,</span><br><span class="line">                                  std::shared_ptr&lt;atomic_bool&gt; quit,</span><br><span class="line">                                  const function&lt;void(C *)&gt; &amp;on_recycle) :</span><br><span class="line">        //lambda捕获quit后(值捕获，发生拷贝)，quit的引用计数变为2，函数退出后，引用计数变为1(形参释放)</span><br><span class="line">        //quit被转移到了_quit中，lambda中后续捕获的值即就是_quit的值，_quit的变更在void quit(bool flag = true)函数中</span><br><span class="line">        shared_ptr&lt;C&gt;(ptr, [weakPool, quit, on_recycle](C *ptr) &#123;</span><br><span class="line">            if (on_recycle) &#123;</span><br><span class="line">                on_recycle(ptr);</span><br><span class="line">            &#125;</span><br><span class="line">            auto strongPool = weakPool.lock();//将weakPool弱指针转换为strongPool强指针</span><br><span class="line">            if (strongPool &amp;&amp; !(*quit)) &#123;</span><br><span class="line">                //循环池还在并且不放弃放入循环池</span><br><span class="line">                strongPool-&gt;recycle(ptr);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                delete ptr; //quit为true，则删除该对象</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;), _quit(std::move(quit)) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ResourcePool_l中的</span><br><span class="line">ValuePtr obtain(const std::function&lt;void(C *)&gt; &amp;on_recycle = nullptr) &#123;</span><br><span class="line">        return ValuePtr(getPtr(), _weak_self, std::make_shared&lt;std::atomic_bool&gt;(false), on_recycle);</span><br><span class="line"> &#125;</span><br><span class="line">测试代码</span><br><span class="line">//大小为50的循环池</span><br><span class="line">    ResourcePool&lt;string_imp&gt; pool;</span><br><span class="line">    pool.setSize(50);</span><br><span class="line"></span><br><span class="line">    //获取一个对象,该对象将被主线程持有，并且不会被后台线程获取并赋值</span><br><span class="line">    auto reservedObj = pool.obtain();</span><br><span class="line">    是在我们obtain后初始化的shared_ptr_imp</span><br></pre></td></tr></table></figure>

<h2 id="资源池：ResourcePool-l"><a href="#资源池：ResourcePool-l" class="headerlink" title="资源池：ResourcePool_l"></a>资源池：ResourcePool_l</h2><p>管理资源，指定资源分配器、分配资源、回收资源、设置资源池大小。</p>
<h3 id="资源分配"><a href="#资源分配" class="headerlink" title="资源分配"></a>资源分配</h3><p>1、如果获取到对象锁，且资源池不为空，则从池子中头部取出一个资源，如果资源池为空，则新分配一个资源<br>2、如果没有获取到对象锁，则直接新分配一个资源<br>3、将分配的资源封装成智能指针返回<br>备注：新分配的资源，由于要被使用，所以此处不能加入到资源池，在资源不再被使用，即智能指针释放时，才把资源添加到池子中；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ValuePtr obtain(const function&lt;void(C *)&gt; &amp;on_recycle = nullptr) &#123;</span><br><span class="line">        C *ptr;</span><br><span class="line">        auto is_busy = _busy.test_and_set();</span><br><span class="line">        if (!is_busy) &#123;</span><br><span class="line">            //获取到锁</span><br><span class="line">            if (_objs.size() == 0) &#123;</span><br><span class="line">                ptr = _allotter()</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ptr = _objs.front();</span><br><span class="line">                _objs.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">            _busy.clear();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //未获取到锁</span><br><span class="line">            ptr = _allotter();</span><br><span class="line">        &#125;</span><br><span class="line">        //第三个参数，默认指定该资源是需要回收的，可以通过quit函数修改后续是否需要回收</span><br><span class="line">        return ValuePtr(ptr, _weak_self, std::make_shared&lt;atomic_bool&gt;(false), on_recycle);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="资源回收"><a href="#资源回收" class="headerlink" title="资源回收"></a>资源回收</h3><p>1、如果获取到对象锁，且当前池中资源数量已达到上线，则不回收该资源，直接释放，否则回收。<br>2、如果没有获取到对象锁，则不回收该资源，直接释放。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void recycle(C *obj) &#123;</span><br><span class="line">        auto is_busy = _busy.test_and_set();</span><br><span class="line">        if (!is_busy) &#123;</span><br><span class="line">            //获取到锁</span><br><span class="line">            if (_objs.size() &gt;= _poolsize) &#123;</span><br><span class="line">                delete obj;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                _objs.emplace_back(obj);</span><br><span class="line">            &#125;</span><br><span class="line">            _busy.clear();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //未获取到锁</span><br><span class="line">            delete obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="设置资源池的最大个数"><a href="#设置资源池的最大个数" class="headerlink" title="设置资源池的最大个数"></a>设置资源池的最大个数</h3><p>默认为8个。虽然资源池中的资源个数最多只能有_poolsize个，但是用户实际在使用的资源个数是没有限制的。</p>
<p>从obtain函数可以看出，如果用户一直调用该函数分配资源，且不释放，那么肯定会超过_poolsize；</p>
<p>从recycle函数可以看出，当资源池容量达到_poolsize后，其余待释放的资源是不会被回收的,释放当前obj。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void setSize(size_t size) &#123;</span><br><span class="line">        _poolsize = size;</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>

<hr>
<p><code>std::shared_ptr&lt;C&gt;</code> 和 <code>std::enable_shared_from_this&lt;ResourcePool_l&lt;C&gt;&gt;</code> 分别提供了不同的功能，它们的继承关系是为了结合它们的优点。</p>
<p>在这个代码中，<code>shared_ptr_imp</code> 继承自 <code>std::shared_ptr&lt;C&gt;</code> 主要是为了重载或扩展 <code>shared_ptr</code> 的行为，使其更加适合当前的需求。同时，<code>shared_ptr_imp</code> 可以利用 <code>std::shared_ptr&lt;C&gt;</code> 提供的各种成员函数和操作符来管理资源，例如：</p>
<ul>
<li><code>reset()</code>：释放当前指向的对象，同时将智能指针重置为一个空指针；</li>
<li><code>operator-&gt;()</code> 和 <code>operator*()</code>：分别返回当前指向对象的指针和引用；</li>
<li><code>use_count()</code>：返回当前指向对象的共享指针数量等等。</li>
</ul>
<p>而 <code>std::enable_shared_from_this&lt;ResourcePool_l&lt;C&gt;&gt;</code> 则提供了一个方便的方式来获取指向当前对象的共享指针，避免手动创建共享指针时可能出现的错误。通过继承 <code>std::enable_shared_from_this</code>，我们可以调用 <code>shared_from_this()</code> 函数来获取指向自身的共享指针。</p>
<h2 id="对象池封装类：ResourcePool"><a href="#对象池封装类：ResourcePool" class="headerlink" title="对象池封装类：ResourcePool"></a>对象池封装类：ResourcePool</h2><p>ResourcePool_l对象是该类唯一的成员变量，该类实际上就是对ResourcePool_l的再次包装。</p>
<p>因为在ResourcePool_l中，需要将自身传递到shared_ptr_imp的构造函数中，这里用到了shared_from_this()来获取一个shared_ptr实例。</p>
<p>shared_from_this()有两个使用限制：</p>
<p>1、不能在自身的构造函数中调用；</p>
<p>2、只允许在先前已被std::shared_ptr 管理的对象上调用 shared_from_this 。</p>
<p>所以作者提供了ResourcePool类，唯一的成员变量：<code>std::shared_ptr&lt;ResourcePool_l&lt;C&gt; &gt; pool;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ResourcePool() &#123;</span><br><span class="line">        pool.reset(new ResourcePool_l&lt;C&gt;());</span><br><span class="line">        pool-&gt;setup();</span><br><span class="line">    &#125;</span><br><span class="line">void setup() &#123; _weak_self = this-&gt;shared_from_this(); &#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/12/ZLTool-%E6%97%A5%E5%BF%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/12/ZLTool-%E6%97%A5%E5%BF%97/" class="post-title-link" itemprop="url">ZLTool-日志</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-12-12 15:03:46 / 修改时间：22:12:36" itemprop="dateCreated datePublished" datetime="2023-12-12T15:03:46+08:00">2023-12-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h1><p>主要是logger.h和logger.cpp两个文件</p>
<h2 id="日志功能的使用"><a href="#日志功能的使用" class="headerlink" title="日志功能的使用"></a>日志功能的使用</h2><h3 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h3><p>定义了以下五个日志级别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef enum &#123;</span><br><span class="line">    LTrace = 0, LDebug, LInfo, LWarn, LError</span><br><span class="line">&#125; LogLevel;</span><br></pre></td></tr></table></figure>

<h3 id="日志的调用方式"><a href="#日志的调用方式" class="headerlink" title="日志的调用方式"></a>日志的调用方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define TraceL LogContextCapturer(getLogger(), LTrace, __FILE__,__FUNCTION__, __LINE__)</span><br><span class="line">#define DebugL LogContextCapturer(getLogger(),LDebug, __FILE__,__FUNCTION__, __LINE__)</span><br><span class="line">#define InfoL LogContextCapturer(getLogger(),LInfo, __FILE__,__FUNCTION__, __LINE__)</span><br><span class="line">#define WarnL LogContextCapturer(getLogger(),LWarn,__FILE__, __FUNCTION__, __LINE__)</span><br><span class="line">#define ErrorL LogContextCapturer(getLogger(),LError,__FILE__, __FUNCTION__, __LINE__)</span><br><span class="line">#define WriteL(level) LogContextCapturer(getLogger(),level,__FILE__, __FUNCTION__, __LINE__)</span><br></pre></td></tr></table></figure>

<p>头文件中分别提供了五个日志级别的宏定义，使用方式在test_logger.cpp中有示例。</p>
<h2 id="源码结构分析"><a href="#源码结构分析" class="headerlink" title="源码结构分析"></a>源码结构分析</h2><p><img src="/ZLTool-%E6%97%A5%E5%BF%97/image-20231212154549582.png" alt="image-20231212154549582"></p>
<img src="/2023/12/12/ZLTool-%E6%97%A5%E5%BF%97/image-20231212154549582.png" class title="This is an test image">

<p>整体看下日志模块的类图，主要分为五部分，LogChannel、LogWriter、LogContext、logger、logContextCapturer</p>
<h3 id="LogContextCapturer"><a href="#LogContextCapturer" class="headerlink" title="LogContextCapturer"></a>LogContextCapturer</h3><p>日志上下文捕获器，调用者使用日志功能时，直接接触到的就是该类，每次打印日志时，都实例化一个该类的对象。类的内部，持有LogContext和Logger两个类的对象。LogContext对象存储用户输出的日志信息，Logger对象最终把LogContext中字符串信息输出。该类重载了&lt;&lt;运算符，有以下两个版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LogContextCapture::LogContextCapture(Logger &amp;logger, LogLevel level, const char *file, const char *function, int line, const char *flag) :</span><br><span class="line">        _ctx(new LogContext(level, file, function, line, s_module_name.c_str(), flag)), _logger(logger) &#123;</span><br><span class="line">&#125;</span><br><span class="line">LogContextCapture &amp;LogContextCapture::operator&lt;&lt;(ostream &amp;(*f)(ostream &amp;)) &#123;</span><br><span class="line">    if (!_ctx) &#123;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    _logger.write(_ctx);</span><br><span class="line">    _ctx.reset();</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数f是一个函数指针，说明这个重载版本需要的是一个函数，那么什么时候会用到这个版本的重载呢？</p>
<p>重载这个版本的目的是为了立即将当前的日志信息进行输出，在这里直接复用了STL中的std::endl。在&lt;&lt;std::endl时会执行这个重载函数。这里我们需要了解下std::endl本质上到底是什么？以下是windows下看到的endl的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class _Elem, class _Traits&gt;</span><br><span class="line">basic_ostream&lt;_Elem, _Traits&gt;&amp; __CLRCALL_OR_CDECL endl(</span><br><span class="line">    basic_ostream&lt;_Elem, _Traits&gt;&amp; _Ostr) &#123; // insert newline and flush stream</span><br><span class="line">    _Ostr.put(_Ostr.widen(&#x27;\n&#x27;));</span><br><span class="line">    _Ostr.flush();</span><br><span class="line">    return _Ostr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，endl就是一个函数，且函数原型实际上就是ostream&amp; endl(ostream&amp;);</p>
<p>用户在使用该类输出日志时，首先实例化一个类对象，在构造函数中，实例化了LogContext对象。当执行logContextCapturer&lt;&lt;str时，会把日志先存储到logContext中，最后在调用logContextCapturer&lt;&lt;endl或者对象析构时，通过Logger的对象将日志内容输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">    LogContextCapture &amp;operator&lt;&lt;(T &amp;&amp;data) &#123;</span><br><span class="line">        if (!_ctx) &#123;</span><br><span class="line">            return *this;</span><br><span class="line">        &#125;</span><br><span class="line">        (*_ctx) &lt;&lt; std::forward&lt;T&gt;(data);</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>模板函数，主要是将用户输入的log信息存储到LogContext对象中。如果传入的data是c++内置数据类型或者是标准库中实现了<strong>ostream</strong>重载的类型，可以直接使用，如果是用户自定义类，则需要自己在自定义类中重载以下运算符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const userClass&amp; userObj );</span><br></pre></td></tr></table></figure>

<h3 id="LogContext"><a href="#LogContext" class="headerlink" title="LogContext"></a>LogContext</h3><p>日志上下文，用于存储日志信息，包括日志级别、日志所在文件名、函数名、行号、用户待输出的日志信息。</p>
<p>该类继承了ostringstream类，用户待输出的日志信息会先存储在ostringstream中。前边说的用户自定义类型在使用日志功能时，需要重载以下函数的原因就是基于此。ostringstream的基类是ostream。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const userClass&amp; userObj );</span><br></pre></td></tr></table></figure>

<h3 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h3><p>该类是一个单例类，体现在util.h类中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define INSTANCE_IMP(class_name, ...) \</span><br><span class="line">class_name &amp;class_name::Instance() &#123; \</span><br><span class="line">    static std::shared_ptr&lt;class_name&gt; s_instance(new class_name(__VA_ARGS__)); \</span><br><span class="line">    static class_name &amp;s_instance_ref = *s_instance; \</span><br><span class="line">    return s_instance_ref; \</span><br><span class="line">&#125;</span><br><span class="line">INSTANCE_IMP 是一个宏定义，用于实现单例模式的静态成员函数。通过使用该宏，可以简化单例模式的实现。</span><br><span class="line">在使用 INSTANCE_IMP 宏时，需要将 class_name 替换为实际的类名，并在宏的参数中传入类构造函数所需的参数</span><br></pre></td></tr></table></figure>

<p>，用于日志模块的配置管理。主要有以下功能：</p>
<p>配置日志输出通道。是终端还是文件、或者系统日志中，对应函数add、del、get；</p>
<p>设置写日志器。实际上就是控制日志是否要异步输出，对应函数setWriter；</p>
<p>设置各类型通道的日志级别。对应函数setLevel；</p>
<p>控制是同步还是异步写日志。如果没有设置写日志器，就是同步写，否则就是异步写。实际的写日志操作最终是在各类型日志通道中完成。</p>
<h3 id="logWriter"><a href="#logWriter" class="headerlink" title="logWriter"></a>logWriter</h3><p>写日志器类，该类是一个抽象类，定义了一个write纯虚函数。实际上，该类目前也只有一个派生类，即<strong>AsyncLogWriter类</strong>，作用是开启一个线程，先将日志存储在队列中，然后异步的将日志信息输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">void Logger::setWriter(const std::shared_ptr&lt;LogWriter&gt; &amp;writer) &#123;</span><br><span class="line">    _writer = writer;</span><br><span class="line">&#125;</span><br><span class="line">class LogWriter : public noncopyable &#123;</span><br><span class="line">public:</span><br><span class="line">    LogWriter() = default;</span><br><span class="line">    virtual ~LogWriter() = default;</span><br><span class="line"></span><br><span class="line">    virtual void write(const LogContextPtr &amp;ctx, Logger &amp;logger) = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class AsyncLogWriter : public LogWriter &#123;</span><br><span class="line">public:</span><br><span class="line">    AsyncLogWriter();</span><br><span class="line">    ~AsyncLogWriter();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    void run();</span><br><span class="line">    void flushAll();</span><br><span class="line">    void write(const LogContextPtr &amp;ctx, Logger &amp;logger) override;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    bool _exit_flag;</span><br><span class="line">    semaphore _sem;</span><br><span class="line">    std::mutex _mutex;</span><br><span class="line">    std::shared_ptr&lt;std::thread&gt; _thread;</span><br><span class="line">    List&lt;std::pair&lt;LogContextPtr, Logger *&gt; &gt; _pending;</span><br><span class="line">&#125;;</span><br><span class="line">AsyncLogWriter::AsyncLogWriter() : _exit_flag(false) &#123;</span><br><span class="line">    _thread = std::make_shared&lt;thread&gt;([this]() &#123; this-&gt;run(); &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AsyncLogWriter::~AsyncLogWriter() &#123;</span><br><span class="line">    _exit_flag = true;</span><br><span class="line">    _sem.post();</span><br><span class="line">    _thread-&gt;join();</span><br><span class="line">    flushAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AsyncLogWriter::write(const LogContextPtr &amp;ctx, Logger &amp;logger) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        lock_guard&lt;mutex&gt; lock(_mutex);</span><br><span class="line">        _pending.emplace_back(std::make_pair(ctx, &amp;logger));</span><br><span class="line">    &#125;</span><br><span class="line">    _sem.post();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AsyncLogWriter::run() &#123;</span><br><span class="line">    setThreadName(&quot;async log&quot;);</span><br><span class="line">    while (!_exit_flag) &#123;</span><br><span class="line">        _sem.wait();</span><br><span class="line">        flushAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AsyncLogWriter::flushAll() &#123;</span><br><span class="line">    decltype(_pending) tmp;</span><br><span class="line">    &#123;</span><br><span class="line">        lock_guard&lt;mutex&gt; lock(_mutex);</span><br><span class="line">        tmp.swap(_pending);</span><br><span class="line">    &#125;</span><br><span class="line">	//for_each在这里起到的作用就是遍历值，然后让值在lambda 表达式中执行writeChannels函数</span><br><span class="line">    tmp.for_each([&amp;](std::pair&lt;LogContextPtr, Logger *&gt; &amp;pr) &#123;</span><br><span class="line">        pr.second-&gt;writeChannels(pr.first);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，可以看出日志写入器 <code>LogWriter</code> 是一个抽象基类，其中声明了纯虚函数 <code>write</code>，用于实现具体的日志写入逻辑。而派生类 <code>AsyncLogWriter</code> 继承自 <code>LogWriter</code>，并重写了 <code>write</code> 函数。</p>
<p>在 <code>AsyncLogWriter</code> 的构造函数中，可以看到通过 <code>std::make_shared&lt;thread&gt;</code> 创建了一个新的线程，并将 <code>run</code> 函数作为线程的入口函数。这表明 <code>AsyncLogWriter</code> 将在独立的线程中执行日志写入操作，实现了异步写入的功能。</p>
<p>而在 <code>AsyncLogWriter</code> 的析构函数中，首先将退出标志 <code>_exit_flag</code> 置为 <code>true</code>，然后通过 <code>_sem.post()</code> 发送一个信号量来通知线程退出，并调用 <code>_thread-&gt;join()</code> 等待线程结束。在等待线程结束之后，还会调用 <code>flushAll</code> 函数来确保所有待处理的日志都被写入。</p>
<p>因此，根据以上代码分析，如果没有设置写日志器（即没有设置 <code>_writer</code>），则默认使用的是同步写入方式，即直接在当前线程中进行日志写入操作。如果设置了写日志器且该写日志器是 <code>AsyncLogWriter</code> 类型的实例，则会启动一个独立的线程，在该线程中异步执行日志写入操作。</p>
<h3 id="LogChannel"><a href="#LogChannel" class="headerlink" title="LogChannel"></a>LogChannel</h3><p>日志通道类，该类是一个抽象类，且是所有特定类型通道的基类。该类包含一个纯虚函数write，以及一个静态函数printTime，两个成员函数name和setLevel，以及一个虚函数format，实际的日志输出最终在format中，如果是终端，还会对不同级别的日志信息分颜色输出。</p>
<p>ConsoleChannel，输出日志到终端，使用std::cout。</p>
<p>SysLogChannel，输出日志到系统日志。windows、IOS、Android不支持。</p>
<p>FileChannelBase，输出日志到文件，使用ofstream。因为写日志到文件还涉及文件的保存天数、单文件大小、文件数量等配置项，所以输出日志到文件最终使用的是FileChannel类。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/21/%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/21/%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F-1/" class="post-title-link" itemprop="url">聊天系统-1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-21 13:11:58" itemprop="dateCreated datePublished" datetime="2023-11-21T13:11:58+08:00">2023-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-26 22:14:06" itemprop="dateModified" datetime="2023-11-26T22:14:06+08:00">2023-11-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="聊天系统"><a href="#聊天系统" class="headerlink" title="聊天系统"></a>聊天系统</h1><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>对于编译来说，先创建build目录，进入之后先<code>cmake ..</code>,再make可以编译，make clean可以会清除先前构建的目标文件和可执行文件，使得代码回到未编译状态。</p>
<p>除了<code>make clean</code>之外，你可以使用<code>make</code>命令实现其他操作，比如：</p>
<ul>
<li><code>make all</code>：构建所有的目标</li>
<li><code>make ChatServer</code>：构建ChatServer目标</li>
<li><code>make ChatClient</code>：构建ChatClient目标</li>
<li><code>make depend</code>：检查并生成依赖关系</li>
<li><code>make rebuild_cache</code>：重新运行CMake来重新生成构建系统</li>
<li><code>make edit_cache</code>：编辑CMake的配置参数</li>
</ul>
<p>你还可以使用<code>make help</code>命令查看所有有效的目标及其说明</p>
<p><code>cmake ..</code>命令的作用是在当前目录的上一级目录中寻找CMakeLists.txt文件，并以该文件作为输入，生成构建系统所需的Makefile或项目文件。这通常用于在构建过程中将构建系统的配置文件生成到一个单独的目录中，以保持源代码目录的清洁。</p>
<p>在实际应用中，如果你的项目使用CMake进行构建管理，通常会在项目根目录中创建一个build目录，并在其中执行<code>cmake ..</code>命令，来生成构建系统所需的文件。这样做有利于隔离源代码和构建产物，方便项目管理和维护。</p>
<h2 id="对muduo库的一些必要操作"><a href="#对muduo库的一些必要操作" class="headerlink" title="对muduo库的一些必要操作"></a>对muduo库的一些必要操作</h2><p>因为在make时出现了一些错误，显示不能加载头文件，说明没有正确引用头文件和静态库的链接，我的操作是怎样的：进入我在&#x2F;home&#x2F;xiaohuilin&#x2F;build目录下，这个目录是jmuduo生成的，进入build后利用<code>sudo make install</code>，在 Makefile 文件中，通常会定义 <code>install</code> 目标，并指定在执行 <code>make install</code> 时要执行的操作，这些操作可能包括复制文件到指定位置、设置文件权限、创建链接等。</p>
<p>因此，当你执行 <code>sudo make install</code> 命令时，实际上是在调用 Makefile 文件中定义的 <code>install</code> 目标，并由该目标指定的命令执行相应的安装操作。Makefile文件是由CMakeList.txt生成的。</p>
<p>在<code>sudo make install</code>，会得到头文件和静态库的目录，就可以知道位置了，接下来只需要修改一下CMakeList.txt的内容，就可以引用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">xiaohuilin@Ubuntu:~/聊天副本2/Service$ cat CMakeLists.txt </span><br><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(chat)</span><br><span class="line"></span><br><span class="line"># 配置编译选项</span><br><span class="line">set(CMAKE_CXX_FLAGS $&#123;CMAKE_CXX_FLAGS&#125; -g)</span><br><span class="line"></span><br><span class="line"># 配置最终的可执行文件输出的路径 </span><br><span class="line">set(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/bin)</span><br><span class="line"></span><br><span class="line"># 配置头文件的搜索路径</span><br><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)</span><br><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include/server)</span><br><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include/server/db)</span><br><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include/server/model)</span><br><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include/server/redis)</span><br><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/thirdparty)</span><br><span class="line"># 添加 muduo 的头文件路径</span><br><span class="line">include_directories(/home/xiaohuilin/build/release-install-cpp11/include)</span><br><span class="line"># 加载子目录</span><br><span class="line">add_subdirectory(src)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">xiaohuilin@Ubuntu:~/聊天副本2/Service/src/server$ cat CMakeLists.txt </span><br><span class="line"># 定义了SRC_LIST变量，包含当前目录下所有的源文件</span><br><span class="line">aux_source_directory(. SRC_LIST)</span><br><span class="line">aux_source_directory(./model MODEL_LIST)</span><br><span class="line">aux_source_directory(./redis REDIS_LIST)</span><br><span class="line"></span><br><span class="line"># 指定生成可执行文件</span><br><span class="line">add_executable(ChatServer $&#123;SRC_LIST&#125; $&#123;MODEL_LIST&#125; $&#123;REDIS_LIST&#125;)</span><br><span class="line"># 指定可执行文件链接时需要的库文件</span><br><span class="line">target_link_libraries(ChatServer /home/xiaohuilin/build/release-install-cpp11/lib/libmuduo_base.a /home/xiaohuilin/build/release-install-cpp11/lib/libmuduo_net.a mysqlclient  hiredis pthread)</span><br></pre></td></tr></table></figure>

<p>hiredis的一些步骤就跟muduo库一样了，</p>
<p>你可以通过以下步骤下载和安装 hiredis 库文件：</p>
<p>打开终端，使用以下命令克隆 hiredis 仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/redis/hiredis.git</span><br></pre></td></tr></table></figure>

<p>进入克隆的 <code>hiredis</code> 目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd hiredis</span><br></pre></td></tr></table></figure>

<p>编译和安装 hiredis 库。运行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>有地方与muduo不一样，是安装在系统路径下的。根据CMakeLists.txt文件中的代码，可以看出执行<code>sudo make install</code>命令会将头文件和库文件安装到系统路径下。</p>
<p>具体来说，在以下代码中指定了安装的目标路径：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cmakeCopy CodeINSTALL(TARGETS hiredis</span><br><span class="line">    EXPORT hiredis-targets</span><br><span class="line">    RUNTIME DESTINATION $&#123;CMAKE_INSTALL_BINDIR&#125;</span><br><span class="line">    LIBRARY DESTINATION $&#123;CMAKE_INSTALL_LIBDIR&#125;</span><br><span class="line">    ARCHIVE DESTINATION $&#123;CMAKE_INSTALL_LIBDIR&#125;)</span><br><span class="line"></span><br><span class="line">INSTALL(FILES hiredis.h read.h sds.h async.h alloc.h sockcompat.h</span><br><span class="line">    DESTINATION $&#123;CMAKE_INSTALL_INCLUDEDIR&#125;/hiredis)</span><br><span class="line"></span><br><span class="line">INSTALL(DIRECTORY adapters</span><br><span class="line">    DESTINATION $&#123;CMAKE_INSTALL_INCLUDEDIR&#125;/hiredis)</span><br><span class="line"></span><br><span class="line">INSTALL(FILES $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/hiredis.pc</span><br><span class="line">    DESTINATION $&#123;CMAKE_INSTALL_LIBDIR&#125;/pkgconfig)</span><br></pre></td></tr></table></figure>

<p>其中，<code>$&#123;CMAKE_INSTALL_BINDIR&#125;</code>表示可执行文件的安装路径，<code>$&#123;CMAKE_INSTALL_LIBDIR&#125;</code>表示库文件的安装路径，<code>$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;</code>表示头文件的安装路径。</p>
<p>因此，执行<code>sudo make install</code>命令后，头文件将被安装到<code>$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;/hiredis</code>目录下，库文件将被安装到<code>$&#123;CMAKE_INSTALL_LIBDIR&#125;</code>目录下</p>
<p>在大多数Linux系统上，<code>$&#123;CMAKE_INSTALL_LIBDIR&#125;</code>可能会被设置为<code>/usr/local/lib</code>或<code>/usr/lib</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/local/include/hiredis /usr/local/include/hiredis/adapters /usr/local/lib</span><br><span class="line">cp -pPR hiredis.h async.h read.h sds.h alloc.h sockcompat.h /usr/local/include/hiredis</span><br><span class="line">cp -pPR adapters/*.h /usr/local/include/hiredis/adapters</span><br><span class="line">cp -pPR libhiredis.so /usr/local/lib/libhiredis.so.1.2.1-dev</span><br><span class="line">cd /usr/local/lib &amp;&amp; ln -sf libhiredis.so.1.2.1-dev libhiredis.so &amp;&amp; ln -sf libhiredis.so.1.2.1-dev libhiredis.so.1</span><br><span class="line">cp -pPR libhiredis.a /usr/local/lib</span><br><span class="line">mkdir -p /usr/local/lib/pkgconfig</span><br><span class="line">cp -pPR hiredis.pc /usr/local/lib/pkgconfig</span><br></pre></td></tr></table></figure>

<h2 id="对MySQL操作"><a href="#对MySQL操作" class="headerlink" title="对MySQL操作"></a>对MySQL操作</h2><p>在 Linux 下使用用户名 “ik” 登录数据库，通常可以通过以下命令行操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u ik -p</span><br></pre></td></tr></table></figure>

<p>在上述命令中：</p>
<ul>
<li><code>-u ik</code> 指定了要使用的用户名为 “ik”。</li>
<li><code>-p</code> 表示需要输入密码进行登录。</li>
</ul>
<p>执行上述命令后，系统会提示你输入密码。输入正确的密码后，即可登录到 MySQL 数据库中</p>
<p>在 MySQL 中，可以使用以下命令来查看数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure>

<p>执行上述命令后，会列出当前 MySQL 服务器上的所有数据库。</p>
<p>如果你想要查看特定数据库中的表，可以先选择数据库，然后使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use your_database_name;</span><br><span class="line">show tables;</span><br></pre></td></tr></table></figure>

<p>将 <code>your_database_name</code> 替换为你希望查看的数据库名称。</p>
<hr>
<p>以下是一个简单示例，展示了如何在Qt项目中实现与OpenCV的集成和车牌识别功能。请注意，这只是一个示例，具体的实现可能因项目需求和环境而有所不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;opencv2/opencv.hpp&gt;</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line">#include &lt;QDateTime&gt;</span><br><span class="line"></span><br><span class="line">// 车牌识别函数</span><br><span class="line">QString recognizeLicensePlate(const cv::Mat&amp; image) &#123;</span><br><span class="line">    // 加载车牌识别模型，例如使用CascadeClassifier或者DNN模型</span><br><span class="line">    cv::CascadeClassifier plate_cascade;</span><br><span class="line">    if (!plate_cascade.load(&quot;path/to/license_plate_model.xml&quot;)) &#123;</span><br><span class="line">        qDebug() &lt;&lt; &quot;Failed to load license plate model!&quot;;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 进行车牌识别</span><br><span class="line">    std::vector&lt;cv::Rect&gt; plates;</span><br><span class="line">    cv::Mat gray;</span><br><span class="line">    cv::cvtColor(image, gray, cv::COLOR_BGR2GRAY);</span><br><span class="line">    cv::equalizeHist(gray, gray);</span><br><span class="line">    plate_cascade.detectMultiScale(gray, plates, 1.1, 3);</span><br><span class="line"></span><br><span class="line">    // 提取车牌号码并返回结果</span><br><span class="line">    if (!plates.empty()) &#123;</span><br><span class="line">        cv::Rect plateRect = plates[0];</span><br><span class="line">        cv::Mat plateImage = image(plateRect);</span><br><span class="line">        std::string licensePlate = /* 提取车牌号码的逻辑 */;</span><br><span class="line">        return QString::fromStdString(licensePlate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 读取车牌图片</span><br><span class="line">    cv::Mat image = cv::imread(&quot;path/to/license_plate_image.jpg&quot;);</span><br><span class="line">    if (image.empty()) &#123;</span><br><span class="line">        qDebug() &lt;&lt; &quot;Failed to load license plate image!&quot;;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 进行车牌识别</span><br><span class="line">    QString licensePlate = recognizeLicensePlate(image);</span><br><span class="line">    if (licensePlate.isEmpty()) &#123;</span><br><span class="line">        qDebug() &lt;&lt; &quot;Failed to recognize license plate!&quot;;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取当前时间和IP地址</span><br><span class="line">    QDateTime currentTime = QDateTime::currentDateTime();</span><br><span class="line">    QString ipAddress = /* 获取IP地址的逻辑 */;</span><br><span class="line"></span><br><span class="line">    // 构造数据库插入语句</span><br><span class="line">    QString insertStatement = QString(&quot;INSERT INTO cars (id, license_plate, time, ip) VALUES (&#x27;%1&#x27;, &#x27;%2&#x27;, &#x27;%3&#x27;, &#x27;%4&#x27;)&quot;)</span><br><span class="line">                                  .arg(&quot;your_id&quot;).arg(licensePlate).arg(currentTime.toString()).arg(ipAddress);</span><br><span class="line"></span><br><span class="line">    // 执行数据库插入操作</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例代码中，<code>recognizeLicensePlate</code>函数使用了OpenCV提供的图像处理和机器学习算法，结合你训练好的车牌识别模型，对输入的图像进行处理和识别。你需要根据实际情况加载和使用合适的模型。</p>
<p>在主函数中，通过调用<code>recognizeLicensePlate</code>函数进行车牌识别，并获取识别结果。然后，使用Qt提供的功能获取当前时间和IP地址。最后，构造数据库插入语句并执行插入操作，将识别结果存储到数据库表”cars”中。</p>
<p>请注意，在实际开发中，你需要根据自己的需求和环境，调整和完善代码。同时，你还需要实现获取IP地址的逻辑（例如使用网络API），以及数据库的连接和插入操作。</p>
<p>希望这个示例能够帮助你开始在Qt项目中实现与OpenCV的集成和车牌识别功能，并将结果存储到数据库中。如果你有进一步的问题，请随时提问。</p>
<hr>
<p>检测分割部分  #include&lt;opencv2&#x2F;opencv.hpp&gt; #include&lt;opencv2&#x2F;core&#x2F;core.hpp&gt;  #include&lt;opencv2&#x2F;highgui&#x2F;highgui.hpp&gt; #include<iostream> #include<sstream> using namespace std; using namespace cv;   int  main_licenseprogress(Mat &amp; image);   &#x2F;&#x2F;int main() { &#x2F;&#x2F; string path &#x3D; “license&#x2F;license”; &#x2F;&#x2F; Mat image; &#x2F;&#x2F; for (int i &#x3D; 2; i &lt;&#x3D; 2; i++) { &#x2F;&#x2F; ostringstream oss; &#x2F;&#x2F; oss &lt;&lt; path &lt;&lt; i &lt;&lt; “.jpg”; &#x2F;&#x2F; cout &lt;&lt; “path &#x3D; “ &lt;&lt; path &lt;&lt; “str &#x3D; “ &lt;&lt; oss.str() &lt;&lt; endl; &#x2F;&#x2F; image &#x3D; imread(oss.str(), 1); &#x2F;&#x2F; main_licenseprogress(image); &#x2F;&#x2F; } &#x2F;&#x2F; system(“pause”); &#x2F;&#x2F; return 0; &#x2F;&#x2F;}     int main_licenseprogress(Mat &amp; image) { imshow(“test”, image); waitKey(1000); &#x2F;&#x2F;灰度化 Mat  gray_image; cvtColor(image, gray_image, CV_RGB2GRAY); imshow(“test”, gray_image); imwrite(“license3_gray.jpg”, gray_image);  waitKey(1000);   &#x2F;&#x2F;平滑处理 中值滤波 Mat blur_image; medianBlur(gray_image, blur_image, 3); imwrite(“blur_image.jpg”, blur_image); &#x2F;&#x2F;imshow(“test”, gray_image); &#x2F;&#x2F;waitKey(1000);   &#x2F;&#x2F;自适应二值化处理  由于candy 算子产生的图像已经是二值化图像，所以这里不做处理 &#x2F;&#x2F;Mat threadhold_image; &#x2F;&#x2F;threshold(blur_image, threadhold_image, 200, 255, CV_THRESH_BINARY); &#x2F;&#x2F;imshow(“test”, threadhold_image); &#x2F;&#x2F;waitKey(1000);   &#x2F;&#x2F;Candy&#x2F;sobel 边缘检测： float mask[3][3] &#x3D; { { 1,2,1 },{ 0,0,0 },{ -1,-2,-1 } }; Mat y_mask &#x3D; Mat(3, 3, CV_32F, mask) &#x2F; 8; Mat x_mask &#x3D; y_mask.t(); &#x2F;&#x2F; 转置 Mat sobelX, sobelY; filter2D(blur_image, sobelX, CV_32F, x_mask); filter2D(blur_image, sobelY, CV_32F, y_mask); sobelX &#x3D; abs(sobelX); sobelY &#x3D; abs(sobelY);   Mat candy_image; Canny(blur_image, candy_image, 500, 250, 3); &#x2F;&#x2F;imshow(“test”, candy_image); &#x2F;&#x2F;waitKey(1000); &#x2F;&#x2F;imshow(“test”, sobelY); &#x2F;&#x2F;waitKey(1000); imwrite(“candy_image.jpg”, candy_image);   &#x2F;&#x2F;形态学处理 &#x2F;&#x2F;图片膨胀处理 Mat dilate_image, erode_image; &#x2F;&#x2F;自定义 核进行 x 方向的膨胀腐蚀 Mat elementX &#x3D; getStructuringElement(MORPH_RECT, Size(25, 1)); Mat elementY &#x3D; getStructuringElement(MORPH_RECT, Size(1, 19)); Point point(-1, -1); dilate(candy_image, dilate_image, elementX, point, 2); imwrite(“dilate_image.jpg”, dilate_image); erode(dilate_image, erode_image, elementX, point, 4); imwrite(“erode_image.jpg”, erode_image); dilate(erode_image, dilate_image, elementX, point, 2); imwrite(“dilate_image1.jpg”, dilate_image); &#x2F;&#x2F;自定义 核进行 Y 方向的膨胀腐蚀 erode(dilate_image, erode_image, elementY, point, 1); imwrite(“erode_image1.jpg”, erode_image); dilate(erode_image, dilate_image, elementY, point, 2); &#x2F;&#x2F;imshow(“test”, dilate_image); &#x2F;&#x2F;waitKey(1000); imwrite(“dilate_image2.jpg”, dilate_image); &#x2F;&#x2F;噪声处理 &#x2F;&#x2F;平滑处理 中值滤波 Mat blurr_image; medianBlur(dilate_image, blurr_image, 15); medianBlur(blurr_image, blurr_image, 15); imshow(“test”, blurr_image); waitKey(1000);   &#x2F;&#x2F;矩形轮廓查找与筛选： Mat contour_image; &#x2F;&#x2F;深拷贝  查找轮廓会改变源图像信息，需要重新 拷贝 图像 contour_image &#x3D; blurr_image.clone(); vector&lt;vector<Point>&gt; contours; findContours(contour_image, contours, CV_RETR_EXTERNAL, CHAIN_APPROX_SIMPLE); &#x2F;&#x2F;画出轮廓 drawContours(contour_image, contours, -1, Scalar(255), 1); &#x2F;&#x2F;imshow(“test”, contour_image); &#x2F;&#x2F;waitKey(1000);   &#x2F;&#x2F;Mat cannyy_image; &#x2F;&#x2F;Canny(contour_image, cannyy_image, 500, 200, 3);   &#x2F;&#x2F;hough 直线  &#x2F;&#x2F;vector<Vec4i> lines; &#x2F;&#x2F;HoughLinesP(cannyy_image, lines, 1, CV_PI &#x2F; 180, 20, 10, 0); &#x2F;&#x2F;for (size_t i &#x3D; 0; i &lt; lines.size(); i++) { &#x2F;&#x2F; Vec4i l &#x3D; lines[i]; &#x2F;&#x2F; line(image, Point(l[0], l[1]), Point(l[2], l[3]), Scalar(0, 0, 255), 1, LINE_AA); &#x2F;&#x2F; cout &lt;&lt; “直线：  “&lt;&lt; i &lt;&lt;endl; &#x2F;&#x2F;} &#x2F;&#x2F;imshow(“test”, image); &#x2F;&#x2F;waitKey(1000);   &#x2F;&#x2F;轮廓表示为一个矩形  车牌提取 Mat  roi_image; vector<Point> rectPoint; for (int i &#x3D; 0; i &lt; contours.size(); i++) { Rect r &#x3D; boundingRect(Mat(contours[i])); &#x2F;&#x2F;RotatedRect r &#x3D; minAreaRect(Mat(contours[i])); cout &lt;&lt; “contours “ &lt;&lt; i &lt;&lt; “  height &#x3D; “ &lt;&lt; r.height &lt;&lt; “  width &#x3D; “ &lt;&lt; r.width &lt;&lt; “rate &#x3D; “ &lt;&lt; ((float)r.width &#x2F; r.height) &lt;&lt; endl; if ((float)r.width &#x2F; r.height &gt;&#x3D; 2.2 &amp;&amp; (float)r.width &#x2F; r.height &lt;&#x3D; 3.6) { cout &lt;&lt; “r.x &#x3D; “ &lt;&lt; r.x &lt;&lt; “  r.y  &#x3D; “ &lt;&lt; r.y &lt;&lt; endl; rectangle(contour_image, r, Scalar(0, 0, 255), 2); imwrite(“contour_image.jpg”, contour_image); Point p1, p2, p3, p4; p1.x &#x3D; r.x; p1.y &#x3D; r.y; p2.x &#x3D; r.x + r.width; p2.x &#x3D; r.y; p3.x &#x3D; r.x + r.width; p3.y &#x3D; r.y + r.height; p4.x &#x3D; r.x; p4.y &#x3D; r.y + r.height;   rectPoint.push_back(p1); rectPoint.push_back(p2); rectPoint.push_back(p3); rectPoint.push_back(p4);   for (int j &#x3D; 0; j &lt; contours[i].size(); j++) { cout &lt;&lt; “point &#x3D; “ &lt;&lt; contours[i][j] &lt;&lt; endl; } &#x2F;&#x2F;rectangle(image, r, Scalar(0, 0, 255), 3); roi_image &#x3D; image(r); } } imshow(“test”, roi_image); waitKey(1000); imwrite(“roi_image.jpg”, roi_image); &#x2F;&#x2F;图片放大 Mat large_image; int col &#x3D; roi_image.cols, row &#x3D; roi_image.rows; resize(roi_image, large_image, Size(300, 300 * row &#x2F; col)); imshow(“test”, large_image); waitKey(2000); &#x2F;&#x2F;车牌分割 &#x2F;&#x2F;灰度化  Mat  roi_gray_image; cvtColor(large_image, roi_gray_image, CV_RGB2GRAY); imshow(“test”, roi_gray_image); waitKey(1000);   &#x2F;&#x2F;中值滤波 增强边缘     &#x2F;&#x2F;Candy 边缘检测 Mat candy_roi_image; Canny(roi_gray_image, candy_roi_image, 450, 120, 3); imshow(“test”, candy_roi_image); imwrite(“candy_roi_image.jpg”, candy_roi_image); waitKey(1000); &#x2F;&#x2F;二值化 Mat roi_threadhold_image; threshold(candy_roi_image, roi_threadhold_image, 50, 255, CV_THRESH_BINARY); imshow(“test”, roi_threadhold_image); waitKey(1000); imwrite(“roi_threadhold_image.jpg”, roi_threadhold_image); &#x2F;&#x2F;平滑处理 中值滤波 &#x2F;&#x2F;Mat roi_blurr_image; &#x2F;&#x2F;medianBlur(roi_threadhold_image, roi_blurr_image, 1); &#x2F;&#x2F;imshow(“test”, roi_blurr_image); &#x2F;&#x2F;waitKey(1000);   &#x2F;&#x2F;查找轮廓 Mat roi_contours_image; vector&lt;vector<Point>&gt; roi_contours; roi_contours_image &#x3D; roi_threadhold_image.clone(); findContours(roi_contours_image, roi_contours, CV_RETR_EXTERNAL, CHAIN_APPROX_SIMPLE); &#x2F;&#x2F;画出轮廓 &#x2F;&#x2F;drawContours(roi_contours_image, roi_contours, -1, Scalar(255), 2); &#x2F;&#x2F;imshow(“test”, roi_contours_image); &#x2F;&#x2F;waitKey(1000);   &#x2F;&#x2F;轮廓表示成矩形 &#x2F;&#x2F;轮廓表示为一个矩形  车牌提取 vector<Point> roi_rectPoint; for (int i &#x3D; 0; i &lt; roi_contours.size(); i++) { Rect r &#x3D; boundingRect(Mat(roi_contours[i])); &#x2F;&#x2F;RotatedRect r &#x3D; minAreaRect(Mat(contours[i])); cout &lt;&lt; “contours “ &lt;&lt; i &lt;&lt; “  height &#x3D; “ &lt;&lt; r.height &lt;&lt; “  width &#x3D; “ &lt;&lt; r.width &lt;&lt; “rate &#x3D; “ &lt;&lt; ((float)r.width &#x2F; r.height) &lt;&lt; endl; cout &lt;&lt; “r.x &#x3D; “ &lt;&lt; r.x &lt;&lt; “  r.y  &#x3D; “ &lt;&lt; r.y &lt;&lt; endl;     &#x2F;&#x2F;rectangle(large_image, r, Scalar(0, 0, 255), 1); Point p1, p2, p3, p4; p1.x &#x3D; r.x; p1.y &#x3D; r.y; p2.x &#x3D; r.x + r.width; p2.x &#x3D; r.y; p3.x &#x3D; r.x + r.width; p3.y &#x3D; r.y + r.height; p4.x &#x3D; r.x; p4.y &#x3D; r.y + r.height;   roi_rectPoint.push_back(p1); roi_rectPoint.push_back(p2); roi_rectPoint.push_back(p3); roi_rectPoint.push_back(p4); for (int j &#x3D; 0; j &lt; roi_contours[i].size(); j++) { cout &lt;&lt; “point &#x3D; “ &lt;&lt; roi_contours[i][j] &lt;&lt; endl; } } imshow(“test”, roi_threadhold_image); waitKey(1000);   &#x2F;&#x2F;矩形轮廓特征提取 int contours_height[30], contours_width[30]; for (int i &#x3D; 0; i &lt; roi_contours.size(); i++) { Rect r &#x3D; boundingRect(Mat(roi_contours[i])); contours_height[i] &#x3D; r.height; contours_width[i] &#x3D; r.width; cout &lt;&lt; “contours_height &#x3D; “ &lt;&lt; r.height &lt;&lt; “ contours_width &#x3D; “ &lt;&lt; r.width &lt;&lt; endl; }   &#x2F;&#x2F;判断字符水平位置 int roi_col &#x3D; roi_threadhold_image.cols, roi_row &#x3D; roi_threadhold_image.rows, position1[50], position2[50], roi_width[50]; uchar pix; &#x2F;&#x2F;cout &lt;&lt; roi_threadhold_image &lt;&lt; endl;  &#x2F;&#x2F;确认为1 的像素 int pixrow[1000]; for (int i &#x3D; 0; i &lt; roi_col - 1; i++) { for (int j &#x3D; 0; j &lt; roi_row - 1; j++) { pix &#x3D; roi_threadhold_image.at<uchar>(j, i); pixrow[i] &#x3D; 0; if (pix &gt; 0) { pixrow[i] &#x3D; 1; break; } } } &#x2F;&#x2F;对数组进行滤波，减少突变概率 for (int i &#x3D; 2; i &lt; roi_col - 1 - 2; i++) { if ((pixrow[i - 1] + pixrow[i - 2] + pixrow[i + 1] + pixrow[i + 2]) &gt;&#x3D; 3) { pixrow[i] &#x3D; 1; } else if((pixrow[i - 1] + pixrow[i - 2] + pixrow[i + 1] + pixrow[i + 2]) &lt;&#x3D; 1) { pixrow[i] &#x3D; 0; } } &#x2F;&#x2F;确认字符位置 int count &#x3D; 0; bool flage &#x3D; false; for (int i &#x3D; 0; i &lt; roi_col - 1; i++) { pix &#x3D; pixrow[i]; if (pix &#x3D;&#x3D; 1 &amp;&amp; !flage) { flage &#x3D; true; position1[count] &#x3D; i; continue; } if (pix &#x3D;&#x3D; 0 &amp;&amp; flage) { flage &#x3D; false; position2[count] &#x3D; i; count++; } if (i &#x3D;&#x3D; (roi_col - 2) &amp;&amp; flage) { flage &#x3D; false; position2[count] &#x3D; i; count++; } } &#x2F;&#x2F;记录所有字符宽度 for (int n &#x3D; 0; n &lt; count; n++) { cout &lt;&lt; “ position1 &#x3D; “ &lt;&lt; position2[n] &lt;&lt;” position2 &#x3D; “&lt;&lt; position2[n] &lt;&lt; “distance &#x3D;” &lt;&lt; (position2[n] - position1[n]) &lt;&lt; endl; roi_width[n] &#x3D; position2[n] - position1[n]; } &#x2F;&#x2F; 减去最大值，最小值 int max &#x3D; roi_width[0], max_index &#x3D; 0; int min &#x3D; roi_width[0], min_index &#x3D; 0; for (int n &#x3D; 1; n &lt; count; n++) { if (max &lt; roi_width[n]) { max &#x3D; roi_width[n]; max_index &#x3D; n; } if (min &gt; roi_width[n]) { min &#x3D; roi_width[n]; min_index &#x3D; n; } } int index &#x3D; 0; int new_roi_width[50]; for (int i &#x3D; 0; i &lt; count; i++) { if (i &#x3D;&#x3D; min_index || i &#x3D;&#x3D; max_index) {   } else { new_roi_width[index] &#x3D; roi_width[i]; index++; } } cout &lt;&lt; “count &#x3D; “ &lt;&lt; count &lt;&lt; endl; for (int i &#x3D; 0; i &lt; count - 2; i++) { cout &lt;&lt; “new roi width &#x3D; “ &lt;&lt; new_roi_width[i] &lt;&lt; endl; } &#x2F;&#x2F;取后面三个值的平均值： int avgre &#x3D; (int)((new_roi_width[count - 3] + new_roi_width[count - 4] + new_roi_width[count - 5]) &#x2F; 3.0); cout &lt;&lt; avgre &lt;&lt; endl; &#x2F;&#x2F;for (int i &#x3D; count-3; i &lt; count - 6; i–) { &#x2F;&#x2F;if (i &lt; 0) { &#x2F;&#x2F; break; &#x2F;&#x2F;} &#x2F;&#x2F;cout &lt;&lt; “count &#x3D; “ &lt;&lt; new_roi_width[i] &lt;&lt; endl; &#x2F;&#x2F;} &#x2F;&#x2F;字母位置信息确认 int licenseX[10], licenseW[10], licenseNum &#x3D; 0; int countX &#x3D; 0; for (int i &#x3D; 0; i &lt; count; i++) { if (roi_width[i] &gt; (avgre - 8) &amp;&amp; roi_width[i] &lt; (avgre + 8)) { licenseX[licenseNum] &#x3D; position1[i]; licenseW[licenseNum] &#x3D; roi_width[i]; licenseNum++; cout &lt;&lt; “licenseX &#x3D; “ &lt;&lt; licenseX[i] &lt;&lt; “  roi_width  &#x3D;” &lt;&lt; roi_width[i] &lt;&lt; endl; continue; } if (roi_width[i] &gt; (avgre * 2 - 10) &amp;&amp; roi_width[i] &lt; (avgre * 2 + 10)) { licenseX[licenseNum] &#x3D; position1[i]; licenseW[licenseNum] &#x3D; roi_width[i]; licenseNum++; cout &lt;&lt; “licenseX &#x3D; “ &lt;&lt; licenseX[i] &lt;&lt;”  roi_width  &#x3D;”&lt;&lt; roi_width[i]&lt;&lt; endl; } }   &#x2F;&#x2F;判断字符垂直位置 int licenseY[10], licenseH[10]; int position3[10], position4[10]; &#x2F;&#x2F;确认为1 的像素 int countYY &#x3D; 0; int pixcol[1000], row_height[10]; for (int temp &#x3D; 0; temp &lt; licenseNum; temp++) { for (int i &#x3D; 0; i &lt; roi_row - 1; i++) { for (int j &#x3D; licenseX[temp]; j &lt; (licenseX[temp]+ licenseW[temp]); j++) { pix &#x3D; roi_threadhold_image.at<uchar>(i, j); pixcol[i] &#x3D; 0; if (pix &gt; 0) { pixcol[i] &#x3D; 1; break; } } } &#x2F;&#x2F;对数组进行滤波，减少突变概率 for (int i &#x3D; 2; i &lt; roi_row - 1 - 2; i++) { if ((pixcol[i - 1] + pixcol[i - 2] + pixcol[i + 1] + pixcol[i + 2]) &gt;&#x3D; 3) { pixcol[i] &#x3D; 1; } else if ((pixcol[i - 1] + pixcol[i - 2] + pixcol[i + 1] + pixcol[i + 2]) &lt;&#x3D; 1) { pixcol[i] &#x3D; 0; } } &#x2F;&#x2F;确认字符位置 int countY &#x3D; 0; bool flage2 &#x3D; false; for (int i &#x3D; 0; i &lt; roi_row - 1; i++) { pix &#x3D; pixcol[i]; if (pix &#x3D;&#x3D; 1 &amp;&amp; !flage2) { flage2 &#x3D; true; position3[countY] &#x3D; i; continue; } if (pix &#x3D;&#x3D; 0 &amp;&amp; flage2) { flage2 &#x3D; false; position4[countY] &#x3D; i; countY++; } }  &#x2F;&#x2F;记录所有字符宽度 for (int n &#x3D; 0; n &lt; countY; n++) { cout &lt;&lt; “ position3 &#x3D; “ &lt;&lt; position3[n] &lt;&lt; “ position4 &#x3D; “ &lt;&lt; position4[n] &lt;&lt; “distance &#x3D;” &lt;&lt; (position4[n] - position3[n]) &lt;&lt; endl; row_height[countYY] &#x3D; position4[n] - position3[n]; licenseY[countYY] &#x3D; position3[n]; licenseH[countYY] &#x3D; row_height[countYY]; } countYY++; }  &#x2F;&#x2F;截取字符 Mat licenseN &#x3D; Mat(Scalar(0)); cout &lt;&lt; “countYY &#x3D; “&lt;&lt; countYY &lt;&lt; endl; for (int i &#x3D; 0; i &lt; countYY; i++) { Rect rect(licenseX[i], licenseY[i], licenseW[i], licenseH[i]); cout &lt;&lt; “position &#x3D; “ &lt;&lt; licenseX[i] &lt;&lt; “  “ &lt;&lt; licenseY[i] &lt;&lt; “  “ &lt;&lt; licenseW[i] &lt;&lt; “  “ &lt;&lt; licenseH[i] &lt;&lt; endl; licenseN &#x3D; large_image(rect); imshow(“test1”+i, licenseN); ostringstream oss; oss &lt;&lt; “licenseN” &lt;&lt; i &lt;&lt; “.jpg”; imwrite(oss.str(), licenseN); waitKey(1000); }    cout &lt;&lt; “license plate process” &lt;&lt; endl; return 0; }      识别部分：  #include&lt;opencv2&#x2F;opencv.hpp&gt; #include&lt;opencv2&#x2F;core&#x2F;core.hpp&gt; #include&lt;opencv2&#x2F;highgui&#x2F;highgui.hpp&gt; #include &lt;opencv2&#x2F;ml&#x2F;ml.hpp&gt; #include<iostream> #include<sstream> using namespace std; using namespace cv; using namespace ml;     float sumMatValue(const Mat &amp; image) { float sumValue &#x3D; 0; int r &#x3D; image.rows; int c &#x3D; image.cols; if (image.isContinuous()) { c &#x3D; r*c; r &#x3D; 1; } for (int i &#x3D; 0; i &lt; r; i++) { const uchar *linePtr &#x3D; image.ptr<uchar>(i); for (int j &#x3D; 0; j &lt; c; j++) { sumValue +&#x3D; linePtr[j]; } } return sumValue; } void calcGradientFeat(Mat &amp; imgSrc, vector<float> &amp; feat) { Mat image; cvtColor(imgSrc, image, CV_BGR2GRAY); resize(image, image, Size(8, 16)); float mask[3][3] &#x3D; { { 1,2,1 },{ 0,0,0 },{ -1,-2,-1 } }; Mat y_mask &#x3D; Mat(3, 3, CV_32F, mask) &#x2F; 8; Mat x_mask &#x3D; y_mask.t(); &#x2F;&#x2F; 转置 Mat sobelX, sobelY;   filter2D(image, sobelX, CV_32F, x_mask); filter2D(image, sobelY, CV_32F, y_mask); sobelX &#x3D; abs(sobelX); sobelY &#x3D; abs(sobelY);   float totleValueX &#x3D; sumMatValue(sobelX); float totleValueY &#x3D; sumMatValue(sobelY); for (int i &#x3D; 0; i &lt; image.rows; i &#x3D; i + 4) { for (int j &#x3D; 0; j &lt; image.cols; j &#x3D; j + 4) { Mat subImageX &#x3D; sobelX(Rect(j, i, 4, 4)); feat.push_back(sumMatValue(subImageX) &#x2F; totleValueX); Mat subImageY &#x3D; sobelY(Rect(j, i, 4, 4)); feat.push_back(sumMatValue(subImageY) &#x2F; totleValueY); } }   Mat img2; resize(image, img2, Size(4, 8)); int r &#x3D; img2.rows; int c &#x3D; img2.cols; if (img2.isContinuous()) { c &#x3D; r*c; r &#x3D; 1; } for (int i &#x3D; 0; i &lt; r; i++) { const uchar *linePtr &#x3D; img2.ptr<uchar>(i); for (int j &#x3D; 0; j &lt; c; j++) { feat.push_back(linePtr[j]); } } &#x2F;&#x2F;       cout&lt;&lt;sobelX&lt;&lt;endl; &#x2F;&#x2F;     cout&lt;&lt;sobelY&lt;&lt;endl; &#x2F;&#x2F; cout&lt;&lt; x_mask&lt;&lt;endl; &#x2F;&#x2F; cout&lt;&lt;img2&lt;&lt;endl; &#x2F;&#x2F; for(int i&#x3D;0; i&lt;feat[num].size(); i++) &#x2F;&#x2F;   { &#x2F;&#x2F;           cout&lt;&lt;feat[i]&lt;&lt;endl; &#x2F;&#x2F;   } &#x2F;&#x2F;       imshow(“cat”, img2); &#x2F;&#x2F;       cout&lt;&lt;”sumValue &#x3D;”&lt;&lt;sumMatValue(image)&lt;&lt;endl; }   Ptr<StatModel> buildMLPClassifier(Mat &amp; input, Mat &amp; output) { Ptr<ANN_MLP> model; &#x2F;&#x2F;train classifier; int layer_sz[] &#x3D; { input.cols, 100 , output.cols }; int nlayers &#x3D; (int)(sizeof(layer_sz) &#x2F; sizeof(layer_sz[0])); Mat layer_sizes(1, nlayers, CV_32S, layer_sz); int method; double method_param; int max_iter; if (1) { method &#x3D; ANN_MLP::BACKPROP; method_param &#x3D; 0.01; max_iter &#x3D; 100; } else { method &#x3D; ANN_MLP::RPROP; method_param &#x3D; 0.1; max_iter &#x3D; 1000; } Ptr<TrainData> tData &#x3D; TrainData::create(input, ROW_SAMPLE, output); model &#x3D; ANN_MLP::create(); cout &lt;&lt; “create success” &lt;&lt; endl; model-&gt;setLayerSizes(layer_sizes); model-&gt;setActivationFunction(ANN_MLP::SIGMOID_SYM, 0, 0); model-&gt;setTermCriteria(TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, max_iter, FLT_EPSILON)); &#x2F;&#x2F;setIterCondition(max_iter, 0); model-&gt;setTrainMethod(method, method_param); cout &lt;&lt; “train data in process ….”&lt;&lt;endl; model-&gt;train(tData); cout &lt;&lt; “train success” &lt;&lt; endl; model-&gt;save(“mlp1.xml”); return model; } Ptr<StatModel> loadMLPClassifiler() {   Ptr<ANN_MLP> model &#x3D; Algorithm::load<ANN_MLP>(“mlp1.xml”); return model; }     int main_num_reconginzed() { Mat image; vector<float>feats; vector<float>test, test1; string path &#x3D; “code&#x2F;python_image_learn&#x2F;identfying_code_recognize&#x2F;charSamples&#x2F;“; int num &#x3D; 0; int classfilternum &#x3D; 34; int modlenum &#x3D; 30; for (int i &#x3D; 0; i &lt; classfilternum; i++) { for (int j &#x3D; 0; j &lt; modlenum; j++) { ostringstream oss; oss &lt;&lt; path &lt;&lt; i &lt;&lt; “&#x2F;“ &lt;&lt; j &lt;&lt; “.png”; &#x2F;&#x2F;cout&lt;&lt;oss.str()&lt;&lt;endl; image &#x3D; imread(oss.str()); calcGradientFeat(image, feats); num++;   if (i &#x3D;&#x3D; 11 &amp;&amp; j &#x3D;&#x3D; 10) { ostringstream oss; oss &lt;&lt; path &lt;&lt; i &lt;&lt; “&#x2F;“ &lt;&lt; (j + 1) &lt;&lt; “.png”; &#x2F;&#x2F;cout&lt;&lt;oss.str()&lt;&lt;endl; image &#x3D; imread(oss.str()); calcGradientFeat(image, test); } } } Mat input, output; input &#x3D; Mat(classfilternum*modlenum, 48, CV_32F); output &#x3D; Mat(classfilternum*modlenum, classfilternum, CV_32F, Scalar(0)); int r &#x3D; input.rows; int c &#x3D; input.cols; if (input.isContinuous()) { c &#x3D; r*c; r &#x3D; 1; } for (int i &#x3D; 0; i &lt; r; i++) { float *linePtr &#x3D; input.ptr<float>(i); for (int j &#x3D; 0; j &lt; c; j++) { linePtr[j] &#x3D; feats[c*i + j]; } } for (int i &#x3D; 0; i &lt; output.rows; i++) { float *lineoutput &#x3D; output.ptr<float>(i); lineoutput[i &#x2F; modlenum] &#x3D; 1; }   &#x2F;&#x2F;if( &#x2F;&#x2F;Ptr<StatModel> model &#x3D; buildMLPClassifier(input, output); Ptr<StatModel> model &#x3D; loadMLPClassifiler(); float response &#x3D; model-&gt;predict(test, test1); cout &lt;&lt; “response &#x3D; “ &lt;&lt; response &lt;&lt; endl; for (int i &#x3D; 0; i &lt; test1.size(); i++) { cout &lt;&lt; “test1 &#x3D; “ &lt;&lt; test1[i] &lt;&lt; endl; } &#x2F;&#x2F;cout&lt;&lt;input&lt;&lt;endl; &#x2F;&#x2F;cout&lt;&lt;”rows &#x3D; “&lt;&lt;input.rows&lt;&lt;”col &#x3D; “&lt;&lt;input.cols&lt;&lt;endl; &#x2F;&#x2F;cout&lt;&lt;output&lt;&lt;endl;    waitKey(0);                    &#x2F;&#x2F;等待按键 system(“pause”); return 0; }你能在上面代码基础上改成能够在Linux下使用在有车牌图片的情况下，能够识别并转换成id、license_plate、time和ip结构然后将识别结果数据插入到数据库表”cars”中吗，并给出具体过程和修改后的完整代码</StatModel></StatModel></float></float></float></float></ANN_MLP></ANN_MLP></StatModel></TrainData></ANN_MLP></StatModel></uchar></float></uchar></sstream></iostream></uchar></uchar></Point></Point></Point></Vec4i></Point></sstream></iostream></p>
<p>2023&#x2F;11&#x2F;26 21:38:02</p>
<p>首先，为了在Linux下使用OpenCV，您需要安装OpenCV库并将代码进行适当的修改。接下来，我将为您提供代码的修改和实现识别结果插入数据库表的具体过程。</p>
<h3 id="修改后的完整代码"><a href="#修改后的完整代码" class="headerlink" title="修改后的完整代码"></a>修改后的完整代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">cppCopy Code#include&lt;opencv2/opencv.hpp&gt;</span><br><span class="line">#include&lt;opencv2/core/core.hpp&gt;</span><br><span class="line">#include&lt;opencv2/highgui/highgui.hpp&gt;</span><br><span class="line">#include &lt;opencv2/ml/ml.hpp&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include &lt;mysql/mysql.h&gt;  // 包含MySQL数据库接口的头文件</span><br><span class="line">using namespace std;</span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace ml;</span><br><span class="line"></span><br><span class="line">// ...（前面的代码不变）</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Mat image;</span><br><span class="line">    vector&lt;float&gt; feats;</span><br><span class="line">    vector&lt;float&gt; test, test1;</span><br><span class="line"></span><br><span class="line">    // 读取车牌图片并进行特征提取</span><br><span class="line">    string imagePath = &quot;path_to_license_plate_image.jpg&quot;;  // 替换为实际的车牌图片路径</span><br><span class="line">    image = imread(imagePath);</span><br><span class="line">    calcGradientFeat(image, feats);</span><br><span class="line"></span><br><span class="line">    // 加载训练好的模型</span><br><span class="line">    Ptr&lt;StatModel&gt; model = loadMLPClassifiler();</span><br><span class="line"></span><br><span class="line">    // 使用模型对车牌图片进行识别</span><br><span class="line">    float response = model-&gt;predict(feats, test1);</span><br><span class="line">    cout &lt;&lt; &quot;response = &quot; &lt;&lt; response &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    // 将识别结果插入到数据库表中</span><br><span class="line">    string id = &quot;123&quot;;  // 替换为实际的id</span><br><span class="line">    string licensePlate = &quot;粤B12345&quot;;  // 替换为实际的车牌号</span><br><span class="line">    string time = &quot;2023-11-26 13:37:51&quot;;  // 替换为实际的时间</span><br><span class="line">    string ip = &quot;192.168.1.100&quot;;  // 替换为实际的IP地址</span><br><span class="line"></span><br><span class="line">    // 连接数据库</span><br><span class="line">    MYSQL *conn;</span><br><span class="line">    conn = mysql_init(NULL);</span><br><span class="line">    if (conn == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr, &quot;mysql_init failed\n&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    conn = mysql_real_connect(conn, &quot;localhost&quot;, &quot;username&quot;, &quot;password&quot;, &quot;database_name&quot;, 0, NULL, 0);</span><br><span class="line">    if (conn == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr, &quot;mysql_real_connect failed\n&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 插入数据到数据库表</span><br><span class="line">    stringstream query;</span><br><span class="line">    query &lt;&lt; &quot;INSERT INTO cars (id, license_plate, time, ip) VALUES (&#x27;&quot; &lt;&lt; id &lt;&lt; &quot;&#x27;, &#x27;&quot; &lt;&lt; licensePlate &lt;&lt; &quot;&#x27;, &#x27;&quot; &lt;&lt; time &lt;&lt; &quot;&#x27;, &#x27;&quot; &lt;&lt; ip &lt;&lt; &quot;&#x27;)&quot;;</span><br><span class="line">    if (mysql_query(conn, query.str().c_str()))</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr, &quot;Query failed (%s)\n&quot;, mysql_error(conn));</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Data inserted successfully&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 关闭数据库连接</span><br><span class="line">    mysql_close(conn);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><ol>
<li>安装OpenCV库并配置编译环境。</li>
<li>将上述修改后的完整代码保存为 <code>recognize_and_insert.cpp</code>。</li>
<li>编译代码：<code>g++ recognize_and_insert.cpp -o recognize_and_insert </code>。</li>
<li>运行可执行文件：<code>./recognize_and_insert</code>。</li>
</ol>
<p>在具体插入数据库的过程中，确保在代码中替换示例中的数据库连接信息和实际的识别结果数据。这样便能够将识别结果数据插入到名为 <code>cars</code> 的数据库表中。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/17/c%E5%92%8Cc++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/17/c%E5%92%8Cc++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4/" class="post-title-link" itemprop="url">数据结构-4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-09-17 15:37:50 / 修改时间：15:48:04" itemprop="dateCreated datePublished" datetime="2023-09-17T15:37:50+08:00">2023-09-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h1><p>给定节点数为 n 的二叉树的前序遍历和中序遍历结果，请重建出该二叉树并返回它的头结点。</p>
<p>例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建出如下图所示。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4/image-20230917153948200.png" alt="image-20230917153948200"></p>
<img src="/2023/09/17/c%E5%92%8Cc++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4/image-20230917153948200.png" class title="This is an test image">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123;</span><br><span class="line">         if (pre.size() == 0 || vin.size() == 0) &#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* treeNode = new TreeNode(pre[0]);</span><br><span class="line">        int mid = distance(begin(vin), find(vin.begin(), vin.end(), pre[0]));</span><br><span class="line">        vector&lt;int&gt; left_pre(pre.begin() + 1, pre.begin() + mid + 1);</span><br><span class="line">        vector&lt;int&gt; right_pre(pre.begin() + mid + 1, pre.end());</span><br><span class="line">        vector&lt;int&gt; left_in(vin.begin(), vin.begin() + mid);</span><br><span class="line">        vector&lt;int&gt; right_in(vin.begin() + mid + 1, vin.end());</span><br><span class="line"></span><br><span class="line">        treeNode-&gt;left = reConstructBinaryTree(left_pre, left_in);</span><br><span class="line">        treeNode-&gt;right = reConstructBinaryTree(right_pre, right_in);</span><br><span class="line">        return treeNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>思路：根据前序找到根节点，然后在中序遍历找到左右子节点，依此递归。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/13/c%E5%92%8Cc++/c-%E8%A1%A5%E5%85%853/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/13/c%E5%92%8Cc++/c-%E8%A1%A5%E5%85%853/" class="post-title-link" itemprop="url">c++-补充3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-13 17:01:39" itemprop="dateCreated datePublished" datetime="2023-09-13T17:01:39+08:00">2023-09-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-25 15:48:36" itemprop="dateModified" datetime="2023-10-25T15:48:36+08:00">2023-10-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="静态类型和动态类型，静态绑定和动态绑定"><a href="#静态类型和动态类型，静态绑定和动态绑定" class="headerlink" title="静态类型和动态类型，静态绑定和动态绑定"></a>静态类型和动态类型，静态绑定和动态绑定</h1><ul>
<li>静态类型：对象在声明时采用的类型，在编译期既已确定；</li>
<li>动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；</li>
<li>静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；</li>
<li>动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；</li>
</ul>
<p>非虚函数一般都是静态绑定，而虚函数都是动态绑定（如此才可实现多态 性）。 举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    /*virtual*/ void func() &#123; std::cout &lt;&lt; &quot;A::func()\n&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class B : public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void func() &#123; std::cout &lt;&lt; &quot;B::func()\n&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class C : public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void func() &#123; std::cout &lt;&lt; &quot;C::func()\n&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    C *pc = new C(); // pc的静态类型是它声明的类型C*，动态类型也是C*；</span><br><span class="line">    B *pb = new B(); // pb的静态类型和动态类型也都是B*；</span><br><span class="line">    A *pa = pc;      // pa的静态类型是它声明的类型A*，动态类型是pa所指向的对象pc的类型C*；</span><br><span class="line">    pa = pb;         // pa的动态类型可以更改，现在它的动态类型是B*，但其静态类型仍是声明时候的A*；</span><br><span class="line">    C *pnull = NULL; // pnull的静态类型是它声明的类型C*,没有动态类型，因为它指向了NULL；</span><br><span class="line"></span><br><span class="line">    pa-&gt;func();    // A::func() pa的静态类型永远都是A*，不管其指向的是哪个子类，都是直接调用A::func()；</span><br><span class="line">    pc-&gt;func();    // C::func() pc的动、静态类型都是C*，因此调用C::func()；</span><br><span class="line">    pnull-&gt;func(); // C::func() 不用奇怪为什么空指针也可以调用函数，因为这在编译期就确定了，和指针空不空没关系；</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果将A类中的virtual注释去掉，则运行结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pa-&gt;func(); //B::func() 因为有了virtual虚函数特性，pa的动态类型指向B*，因此先在B中查找，找到后直接调用；</span><br><span class="line">pc-&gt;func(); //C::func() pc的动、静态类型都是C*，因此也是先在C中查找；</span><br><span class="line">pnull-&gt;func(); //空指针异常，因为是func是virtual函数，因此对func的调用只能等到运行期才能确定，然后才发现pnull是空指针；</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，</p>
<ul>
<li>如果基类A中的func不是virtual函数，那么不论pa、pb、pc指向哪个子类对象，对func的调用都是在定义pa、pb、pc时的静态类型决定，早已在编译期确定了。</li>
<li>同样的空指针也能够直接调用no-virtual函数而不报错（这也说明一定要做空指针检查啊！），因此静态绑定不能实现多态；</li>
<li>如果func是虚函数，那所有的调用都要等到运行时根据其指向对象的类型才能确定，比起静态绑定自然是要有性能损失的，但是却能实现多态特性；</li>
</ul>
<p>另外，在动态绑定也即在virtual函数中，要注意默认参数的使用。当 缺省参数和virtual函数一起使用的时候一定要谨慎，不然出了问题怕是很难排查</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class E</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void func(int i = 0)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;E::func()\t&quot; &lt;&lt; i &lt;&lt; &quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class F : public E</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void func(int i = 1)override</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;F::func()\t&quot; &lt;&lt; i &lt;&lt; &quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test2()</span><br><span class="line">&#123;</span><br><span class="line">    F *pf = new F();</span><br><span class="line">    E *pe = pf;</span><br><span class="line">    pf-&gt;func(); // F::func() 1 正常，就该如此；</span><br><span class="line">    pe-&gt;func(); // F::func() 0 哇哦，这是什么情况，调用了子类的函数，却使用了基类中参数的默认值！</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    test2();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="指针加减计算"><a href="#指针加减计算" class="headerlink" title="指针加减计算"></a>指针加减计算</h1><p>指针加减本质是对其所指地址的移动，移动的步长跟指针的类型是有关系的，因此在涉及到指针加减运 算需要十分小心，加多或者减多都会导致指针指向一块未知的内存地址，如果再进行操作就会很危险。 举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> 	int *a, *b, c;</span><br><span class="line"> 	a = (int*)0x500;</span><br><span class="line"> 	b = (int*)0x520;</span><br><span class="line"> 	c = b - a;</span><br><span class="line"> 	printf(&quot;%d\n&quot;, c); // 8</span><br><span class="line"> 	a += 0x020;</span><br><span class="line"> 	c = b - a;</span><br><span class="line"> 	printf(&quot;%d\n&quot;, c); // -24</span><br><span class="line"> 	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先变量a和b都是以16进制的形式初始化，将它们转成10进制分别是1280（5<em>16^2&#x3D;1280）和 1312（5</em>16^2+2*16&#x3D;1312)， 那么它们的差值为32，也就是说a和b所指向的地址之间间隔32个位，但是 考虑到是int类型占4位，所以c的值为32&#x2F;4&#x3D;8.</p>
<p>a自增16进制0x20之后，其实际地址变为1280 + 2<em>16</em>4 &#x3D; 1408，（因为一个int占4位，所以要乘4），这 样它们的差值就变成了1312 - 1280 &#x3D; -96，所以c的值就变成了-96&#x2F;4 &#x3D; -24 遇到指针的计算，<strong>需要明确的是指针每移动一位，它实际跨越的内存间隔是指针类型的长度，建议都转 成10进制计算，计算结果除以类型长度取得结果</strong></p>
<h1 id="判断两个浮点数是否相等"><a href="#判断两个浮点数是否相等" class="headerlink" title="判断两个浮点数是否相等"></a>判断两个浮点数是否相等</h1><p>对两个浮点数判断大小和是否相等不能直接用&#x3D;&#x3D;来判断，会出错！明明相等的两个数比较反而是不相 等！对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值！浮点数与0的比较 也应该注意。与浮点数的表示方式有关。</p>
<p>在判断两个浮点数是否相等时，由于浮点数的内部表示方式以及浮点数运算的特性，直接使用相等运算符（<code>==</code>）进行比较可能会导致误差。</p>
<p>这是因为浮点数的内部二进制表示可能会存在舍入误差，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">float a = 0.1f + 0.1f + 0.1f;</span><br><span class="line">float b = 0.3f;</span><br><span class="line"></span><br><span class="line">if (a == b) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;相等&quot; &lt;&lt; endl;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    cout &lt;&lt; &quot;不相等&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，我们期望 <code>a</code> 和 <code>b</code> 的值相等，因为它们都是 0.3。然而，由于浮点数的内部二进制表示存在舍入误差，实际运行结果可能会输出 “不相等”。</p>
<p>为了解决这个问题，一种常用的方法是定义一个误差范围（epsilon），然后判断两个浮点数的绝对差是否小于该误差范围。如果绝对差小于等于 epsilon，那么认为两个浮点数是近似相等的。</p>
<p>下面是一个示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">bool areEqual(float a, float b, float epsilon = 1e-6) &#123;</span><br><span class="line">    return std::abs(a - b) &lt;= epsilon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    float a = 0.1f + 0.1f + 0.1f;</span><br><span class="line">    float b = 0.3f;</span><br><span class="line"></span><br><span class="line">    if (areEqual(a, b)) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;相等&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;不相等&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，我们定义了一个 <code>areEqual</code> 函数，用于判断两个浮点数是否近似相等。默认情况下，我们使用误差范围 <code>epsilon</code> 的值为 1e-6，你可以根据具体的需求调整这个值。</p>
<p>通过调用 <code>areEqual</code> 函数来比较 <code>a</code> 和 <code>b</code> 的值，输出结果应该是 “相等”。通过引入误差范围，可以避免由于浮点数的舍入误差而导致的比较结果错误。</p>
<h1 id="继承机制中对象之间如何转换"><a href="#继承机制中对象之间如何转换" class="headerlink" title="继承机制中对象之间如何转换"></a>继承机制中对象之间如何转换</h1><ol>
<li>向上类型转换<br>将派生类指针或引用转换为基类的指针或引用被称为向上类型转换，向上类型转换会自动进行，而且向上类型转换是安全的。</li>
<li>向下类型转换<br>将基类指针或引用转换为派生类指针或引用被称为向下类型转换，向下类型转换不会自动进行，因为一个基类对应几个派生类，所以向下类型转换时不知道对应哪个派生类，所以在向下类型转换时必须加动态类型识别技术。RTTI技术，用dynamic_cast进行向下类型转换</li>
</ol>
<h1 id="函数调用过程栈的变化"><a href="#函数调用过程栈的变化" class="headerlink" title="函数调用过程栈的变化"></a>函数调用过程栈的变化</h1><p>调用者函数把被调函数所需要的参数按照与被调函数的形参顺序相反的顺序压入栈中,即:从右向左依次把被调 函数所需要的参数压入栈;</p>
<p>调用者函数使用call指令调用被调函数,并把call指令的下一条指令的地址当成返回地址压入栈中(这个压栈操作隐含在call指令中);</p>
<h1 id="define、const、typedef、inline"><a href="#define、const、typedef、inline" class="headerlink" title="define、const、typedef、inline"></a>define、const、typedef、inline</h1><p>​		一、const与#define的区别：</p>
<ul>
<li><p>const定义的常量是变量带类型，而#define定义的只是个常数不带类型；</p>
</li>
<li><p>define只在预处理阶段起作用，简单的文本替换，而const在编译、链接过程中起作用；</p>
</li>
<li><p>define只是简单的字符串替换没有类型检查。而const是有数据类型的，是要进行判断的，可以避免一些低级错误；</p>
</li>
<li><p>define预处理后，占用代码段空间，const占用数据段空间；</p>
</li>
<li><p>const不能重定义，而define可以通过#undef取消某个符号的定义，进行重定义；</p>
</li>
<li><p>define独特功能，比如可以用来防止文件重复引用。</p>
<p>二、#define和别名typedef的区别</p>
</li>
<li><p>执行时间不同，typedef在编译阶段有效，typedef有类型检查的功能；#define是宏定义，发生在预处理阶段，不进行类型检查；</p>
</li>
<li><p>功能差异，typedef用来定义类型的别名，定义与平台无关的数据类型，与struct的结合使用等。#define不只是可以为类型取别名，还可以定义常量、变量、编译开关等。</p>
</li>
<li><p>作用域不同，#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。而typedef有自己的作用域。<br>三、 define与inline的区别</p>
</li>
<li><p>#define是关键字，inline是函数；</p>
</li>
<li><p>宏定义在预处理阶段进行文本替换，inline函数在编译阶段进行替换；</p>
</li>
<li><p>inline函数有类型检查，相比宏定义比较安全；</p>
</li>
</ul>
<h1 id="printf函数的实现原理"><a href="#printf函数的实现原理" class="headerlink" title="printf函数的实现原理"></a>printf函数的实现原理</h1><p>在C&#x2F;C++中，对函数参数的扫描是从后向前的。</p>
<p>C&#x2F;C++的函数参数是通过压入堆栈的方式来给函数传参数的（堆栈是一种先进后出的数据结构），最先压入的参数最后出来，在计算机的内存中，数据有2块，一块是堆，一块是栈（函数参数及局部变量在这里），而栈是从内存的高地址向低地址生长的，控制生长的就是堆栈指针了，最先压入的参数是在最上面，就是说在所有参数的最后面，最后压入的参数在最下面，结构上看起来是第一个，所以最后压入的参数总是能够被函数找到，因为它就在堆栈指针的上方。</p>
<p>printf的第一个被找到的参数就是那个字符指针，就是被双引号括起来的那一部分，函数通过判断字符串里控制参数的个数来判断参数个数及数据类型，通过这些就可算出数据需要的堆栈指针的偏移量了。</p>
<h1 id="strcpy和memcpy的区别"><a href="#strcpy和memcpy的区别" class="headerlink" title="strcpy和memcpy的区别"></a>strcpy和memcpy的区别</h1><ol>
<li>复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。</li>
<li>复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。</li>
<li>用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</li>
<li>① strcpy主要实现字符串变量间的拷贝<br>② sprintf主要实现其他数据类型格式到字符串的转化<br>③ memcpy主要是内存块间的拷贝。</li>
</ol>
<p><code>strcpy</code> 函数用于将一个字符串（以 null 结尾的字符数组）复制到另一个字符数组中。它的函数原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char* strcpy(char* destination, const char* source);</span><br></pre></td></tr></table></figure>

<p>其中，<code>destination</code> 是目标字符数组的指针，<code>source</code> 是要拷贝的源字符数组的指针。<code>strcpy</code> 函数会将源字符数组中的内容复制到目标字符数组中，并返回目标字符数组的指针。</p>
<p><code>memcpy</code> 函数用于将一块内存区域的内容复制到另一个内存区域。它的函数原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void* memcpy(void* destination, const void* source, size_t num);</span><br></pre></td></tr></table></figure>

<p>其中，<code>destination</code> 是目标内存区域的指针，<code>source</code> 是源内存区域的指针，<code>num</code> 是要复制的字节数。<code>memcpy</code> 函数会将源内存区域中的内容复制到目标内存区域中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memcpy(&amp;person2, &amp;person1, sizeof(Person));//prerson是类或结构体的情况</span><br></pre></td></tr></table></figure>

<h1 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1><p>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如： 操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行 优化，从而可以提供对特殊地址的稳定访问。声明时语法：int volatile vInt; 当要求使用 volatile 声明的变 量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而 且读取的数据立刻被保存。</p>
<p>volatile用在如下的几个地方：</p>
<ol>
<li>中断服务程序中修改的供其它程序检测的变量需要加volatile；</li>
<li>多任务环境下各任务间共享的标志应该加volatile；</li>
<li>存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；</li>
</ol>
<h1 id="空类默认添加函数"><a href="#空类默认添加函数" class="headerlink" title="空类默认添加函数"></a>空类默认添加函数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1) Empty(); // 缺省构造函数//</span><br><span class="line">2) Empty( const Empty&amp; ); // 拷贝构造函数//</span><br><span class="line">3) ~Empty(); // 析构函数//</span><br><span class="line">4) Empty&amp; operator=( const Empty&amp; ); // 赋值运算符//</span><br></pre></td></tr></table></figure>

<h1 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h1><ul>
<li>(1) 友元关系不能被继承。</li>
<li>(2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。</li>
<li>(3) 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明</li>
</ul>
<h1 id="成员函数中调用delete-this"><a href="#成员函数中调用delete-this" class="headerlink" title="成员函数中调用delete this"></a>成员函数中调用delete this</h1><p>在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放 在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。 当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及 到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现 不可预期的问题。</p>
<p>在成员函数中调用 <code>delete this</code> 将导致未定义行为。这是因为在调用 <code>delete this</code> 后，对象所在的内存将被释放，但对象的成员函数仍然存在。</p>
<p>由于对象所占用的内存已经被释放，再次调用该对象的成员函数将导致访问已经无效的内存，可能会导致程序崩溃或产生其他不可预测的结果。</p>
<p>所以，在调用 <code>delete this</code> 后，不应该再使用对象的成员函数，也不能对对象进行任何操作。</p>
<p>以下示例演示了在成员函数中调用 <code>delete this</code> 的问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class MyClass &#123;</span><br><span class="line">public:</span><br><span class="line">    void doSomething() &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Doing something&quot; &lt;&lt; std::endl;</span><br><span class="line">        delete this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    MyClass* obj = new MyClass();</span><br><span class="line">    obj-&gt;doSomething();  // 调用 delete this</span><br><span class="line"></span><br><span class="line">    obj-&gt;doSomething();  // 潜在的未定义行为：访问无效的内存</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>MyClass</code> 类的 <code>doSomething</code> 成员函数中调用了 <code>delete this</code>。在 <code>main</code> 函数中，我们首先创建了一个 <code>MyClass</code> 的对象 <code>obj</code>，然后调用了 <code>obj-&gt;doSomething()</code>。在该调用内部，对象被删除并且内存被释放。接着，我们又尝试调用 <code>obj-&gt;doSomething()</code> 一次，这是不安全的，因为对象已经不存在，访问无效的内存会导致未定义行为。</p>
<p>this在成员函数的开始执行前构造，在成员的执行结束后清除。这里的清除和delete有区别。</p>
<ul>
<li><p>结束对象的生命周期时，内存会被自动释放（在栈上分配的对象在作用域结束时，动态分配的对象在使用 <code>delete</code> 运算符时）。</p>
</li>
<li><p>调用 <code>delete this</code> 是显式地删除对象，包括对象本身和其成员。这是一种危险的操作，需要谨慎使用。</p>
<ul>
<li><p>栈对象：栈对象是在函数内部或代码块内部声明的对象，其存储在程序的栈上。当栈对象的作用域结束时（例如函数返回或代码块结束），编译器会自动清理栈对象，释放其所占用的内存。</p>
</li>
<li><p>堆对象：堆对象是通过 <code>new</code> 运算符在堆内存中动态分配的对象。使用 <code>new</code> 创建的对象存储在堆上，并且需要通过 <code>delete</code> 运算符显式地释放。调用 <code>delete</code> 会销毁堆对象，释放其所占用的内存。这里我理解成相当于删除副本和原件。</p>
</li>
</ul>
</li>
</ul>
<p>堆上分配的对象的生命周期不受作用域的限制。堆对象可以在任何地方创建，并且会一直存在，直到显式地通过<code>delete</code>删除或程序运行结束。</p>
<h1 id="空类"><a href="#空类" class="headerlink" title="空类"></a>空类</h1><ol>
<li>C++空类的大小不为0，不同编译器设置不一样，vs设置为1；</li>
<li>C++标准指出，不允许一个对象（当然包括类对象）的大小为0，不同的对象不能具有相同的地址；</li>
<li>带有虚函数的C++类大小不为1，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小<br>确定；</li>
<li>C++中要求对于类的每个实例都必须有独一无二的地址,那么编译器自动为空类分配一个字节大小，<br>这样便保证了每个实例均有独一无二的内存地址。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line"> 	cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 1;</span><br><span class="line"> 	A a; </span><br><span class="line"> 	cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 1;</span><br><span class="line"> 	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空类的大小是1， 在C++中空类会占一个字节，这是为了让对象的实例能够相互区别。具体来说，空类 同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个 字节，这样空类实例化之后就会拥有独一无二的内存地址。当该空白类作为基类时，该类的大小就优化 为0了，子类的大小就是子类本身的大小。这就是所谓的空白基类最优化。</p>
<p>空类的实例大小就是类的大小，所以sizeof(a)&#x3D;1字节,如果a是指针，则sizeof(a)就是指针的大小，即4字 节。因为有虚函数的类对象中都有一个虚函数表指针 __vptr，其大小是4字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A &#123; virtual Fun()&#123;&#125; &#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line"> 	cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 4(32位机器)/8(64位机器);</span><br><span class="line"> 	A a; </span><br><span class="line"> 	cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 4(32位机器)/8(64位机器);</span><br><span class="line"> 	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>静态成员存放在静态存储区，不占用类的大小, 普通函数也不占用类大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A &#123; static int a; &#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line"> 	cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 1;</span><br><span class="line"> 	A a; </span><br><span class="line"> 	cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 1;</span><br><span class="line"> 	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>静态成员a不占用类的大小，所以类的大小就是b变量的大小 即4个字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class A &#123; int a; &#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line"> 	cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 4;</span><br><span class="line"> 	A a; </span><br><span class="line"> 	cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 4;</span><br><span class="line"> 	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A &#123; static int a; int b; &#125;;;</span><br><span class="line">int main()&#123;</span><br><span class="line"> 	cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 4;</span><br><span class="line"> 	A a; </span><br><span class="line"> 	cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 4;</span><br><span class="line"> 	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="类对象的大小"><a href="#类对象的大小" class="headerlink" title="类对象的大小"></a>类对象的大小</h1><ol>
<li>类的非静态成员变量大小，静态成员不占据类的空间，成员函数也不占据类的空间大小；</li>
<li>内存对齐另外分配的空间大小，类内的数据也是需要进行内存对齐操作的；</li>
<li>虚函数的话，会在类对象插入vptr指针，加上指针大小；</li>
<li>当该类是某类的派生类，那么派生类继承的基类部分的数据成员也会存在在派生类中的空间中，也会对派生类进行扩展。</li>
</ol>
<h1 id="std-forward-list（单向链表）"><a href="#std-forward-list（单向链表）" class="headerlink" title="std::forward_list（单向链表）"></a>std::forward_list（单向链表）</h1><p><code>std::forward_list</code> 是 C++ 中的单向链表容器，它在 <code>&lt;forward_list&gt;</code> 头文件中定义。相比于其他容器，<code>std::forward_list</code> 具有内存占用低、插入删除高效等特点，适用于快速插入和删除元素的场景。</p>
<p>以下是 <code>std::forward_list</code> 的一些基本特性和用法：</p>
<ol>
<li>链表结构：<code>std::forward_list</code> 采用单向链表的数据结构，每个节点存储一个值，并通过指针连接到下一个节点。</li>
<li>基本操作：<code>std::forward_list</code> 提供了插入、删除、查找等基本操作，如 <code>push_front()</code>、<code>pop_front()</code>、<code>insert_after()</code>、<code>erase_after()</code> 等。</li>
<li>迭代器：可以使用迭代器遍历链表元素，分别为 <code>begin()</code> 和 <code>end()</code>，其中 <code>begin()</code> 返回指向第一个元素的迭代器，<code>end()</code> 返回指向最后一个元素之后的迭代器。</li>
<li>高效性能：由于链表结构的特点，<code>std::forward_list</code> 在插入和删除元素时具有高效性能，时间复杂度接近常数时间。</li>
<li>不支持随机访问：由于单向链表的特点，<code>std::forward_list</code> 不支持通过下标随机访问元素，只能通过迭代器逐个遍历查找。</li>
</ol>
<p>以下是一个使用 <code>std::forward_list</code> 的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;forward_list&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::forward_list&lt;int&gt; myList;</span><br><span class="line"></span><br><span class="line">    // 在链表头部插入元素</span><br><span class="line">    myList.push_front(2);</span><br><span class="line">    myList.push_front(1);</span><br><span class="line"></span><br><span class="line">    // 在链表头部删除元素</span><br><span class="line">    myList.pop_front();</span><br><span class="line"></span><br><span class="line">    // 遍历链表并打印元素</span><br><span class="line">    for (const auto&amp; value : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们创建了一个 <code>std::forward_list</code> 容器 <code>myList</code>，并使用 <code>push_front()</code> 在链表头部插入两个元素。然后，通过 <code>pop_front()</code> 删除链表头部的元素。最后，使用范围-based for 循环遍历链表，并打印每个元素。</p>
<ul>
<li><code>insert_after(pos, value)</code>：在迭代器 <code>pos</code> 所指节点之后插入值为 <code>value</code> 的新节点。插入的元素将成为当前节点的下一个节点。</li>
<li><code>erase_after(pos)</code>：删除迭代器 <code>pos</code> 所指节点的下一个节点。</li>
</ul>
<h1 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h1><p>C++11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些 只对应某种特定的类型说明符(例如 int)不同， auto 让编译器通过初始值来进行类型推演。从而获得定义变量的类型，所以说 auto 定义的变量必须有 初始值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//普通；类型</span><br><span class="line">int a = 1, b = 3;</span><br><span class="line">auto c = a + b;// c为int型</span><br><span class="line">//const类型</span><br><span class="line">const int i = 5;</span><br><span class="line">auto j = i; // 变量i是顶层const, 会被忽略, 所以j的类型是int</span><br><span class="line">auto k = &amp;i; // 变量i是一个常量, 对常量取地址是一种底层const, 所以b的类型是const int*</span><br><span class="line">const auto l = i; //如果希望推断出的类型是顶层const的, 那么就需要在auto前面加上cosnt</span><br><span class="line">//引用和指针类型</span><br><span class="line">int x = 2;</span><br><span class="line">int&amp; y = x;</span><br><span class="line">auto z = y; //z是int型不是int&amp; 型</span><br><span class="line">auto&amp; p1 = y; //p1是int&amp;型</span><br><span class="line">auto p2 = &amp;x; //p2是指针类型int*</span><br></pre></td></tr></table></figure>

<p>从 const 指针开始说起。<code>const int* pInt;</code> 和 <code>int *const pInt = &amp;someInt;</code>，前者是 *pInt 不能改变，而后者是 pInt 不能改变。因此指针本身是不是常量和指针所指向的对象是不是常量就是两个互相独立的问题。用<strong>顶层</strong>表示指针本身是个常量，<strong>底层</strong>表示指针所指向的对象是个常量。</p>
<p>更一般的，顶层 const 可以表示任意的对象是常量，这一点对任何数据类型都适用；<strong>底层 const 则与指针和引用等复合类型有关</strong>，比较特殊的是，指针类型<strong>既可以是顶层</strong> const <strong>也可以是底层</strong> const 或者<strong>二者兼备</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int i=0;</span><br><span class="line">int *const pl =&amp;i;//不能改变p1的值，这是一个顶层const</span><br><span class="line">const int ci =42;</span><br><span class="line">//不能改变ci的值，这是一个顶层const</span><br><span class="line">const int *p2= &amp;ci;</span><br><span class="line">//允许改变p2的值，这是一个底层const</span><br><span class="line">const int &amp;r=ci;</span><br><span class="line">//  所有的引用本身都是顶层 const，因为引用一旦初始化就不能再改为其他对象的引用，这里用于声明引用的 const 都是底层 const</span><br></pre></td></tr></table></figure>

<h1 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h1><p>有的时候我们还会遇到这种情况，我们希望从表达式中推断出要定义变量的类型，但却不想用表达式的 值去初始化变量。还有可能是函数的返回类型为某表达式的值类型。在这些时候auto显得就无力了，所 以C++11又引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数据类型。在此过程中， 编译器只是分析表达式并得到它的类型，却不进行实际的计算表达式的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int func() &#123;return 0&#125;;</span><br><span class="line">//普通类型</span><br><span class="line">decltype(func()) sum = 5; // sum的类型是函数func()的返回值的类型int, 但是这时不会实际调用函数func()</span><br><span class="line">int a = 0;</span><br><span class="line">decltype(a) b = 4; // a的类型是int, 所以b的类型也是int</span><br><span class="line"></span><br><span class="line">//不论是顶层const还是底层const, decltype都会保留 </span><br><span class="line">const int c = 3;</span><br><span class="line">decltype(c) d = c; // d的类型和c是一样的, 都是顶层const</span><br><span class="line">int e = 4;</span><br><span class="line">const int* f = &amp;e; // f是底层const</span><br><span class="line">decltype(f) g = f; // g也是底层const</span><br><span class="line"></span><br><span class="line">//引用与指针类型</span><br><span class="line">//1. 如果表达式是引用类型, 那么decltype的类型也是引用</span><br><span class="line">const int i = 3, &amp;j = i;</span><br><span class="line">decltype(j) k = 5; // k的类型是 const int&amp;</span><br><span class="line"></span><br><span class="line">//2. 如果表达式是引用类型, 但是想要得到这个引用所指向的类型, 需要修改表达式:</span><br><span class="line">int i = 3, &amp;r = i;</span><br><span class="line">decltype(r + 0) t = 5; // 此时是int类型</span><br><span class="line"></span><br><span class="line">//3. 对指针的解引用操作返回的是引用类型</span><br><span class="line">int i = 3, j = 6, *p = &amp;i;</span><br><span class="line">decltype(*p) c = j; // c是int&amp;类型, c和j绑定在一起</span><br><span class="line">//p 是一个指针，它指向变量 i。因为 *p 是解引用操作符，它返回指针 p 所指向的对象。在这种情况下，*p 返回的是 i 的引用</span><br><span class="line"></span><br><span class="line">//4. 如果一个表达式的类型不是引用, 但是我们需要推断出引用, 那么可以加上一对括号, 就变成了引用</span><br><span class="line">类型了</span><br><span class="line">int i = 3;</span><br><span class="line">decltype((i)) j = i; // 此时j的类型是int&amp;类型, j和i绑定在了一起</span><br></pre></td></tr></table></figure>

<h1 id="decltype-auto"><a href="#decltype-auto" class="headerlink" title="decltype(auto)"></a>decltype(auto)</h1><p>decltype(auto)是C++14新增的类型指示符，可以用来声明变量以及指示函数返回类型。在使用时，会将 “&#x3D;”号左边的表达式替换掉auto，再根据decltype的语法规则来确定类型。举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int e = 4;</span><br><span class="line">const int* f = &amp;e; // f是底层const</span><br><span class="line">decltype(auto) j = f;//j的类型是const int* 并且指向的是e</span><br></pre></td></tr></table></figure>

<h1 id="auto-ptr作用"><a href="#auto-ptr作用" class="headerlink" title="auto_ptr作用"></a>auto_ptr作用</h1><ol>
<li>auto_ptr的出现，主要是为了解决“有异常抛出时发生内存泄漏”的问题；抛出异常，将导致指针p所指向的空间得不到释放而导致内存泄漏；</li>
<li>auto_ptr构造时取得某个对象的控制权，在析构时释放该对象。我们实际上是创建一个auto_ptr类型的局部对象，该局部对象析构时，会将自身所拥有的指针空间释放，所以不会有内存泄漏；</li>
<li>auto_ptr的构造函数是explicit，阻止了一般指针隐式转换为 auto_ptr的构造，所以不能直接将一般类型的指针赋值给auto_ptr类型的对象，必须用auto_ptr的构造函数创建对象；</li>
<li>由于auto_ptr对象析构时会删除它所拥有的指针，所以使用时避免多个auto_ptr对象管理同一个指针；</li>
<li>Auto_ptr内部实现，析构函数中删除对象用的是delete而不是delete[]，所以auto_ptr不能管理数组；</li>
<li>auto_ptr支持所拥有的指针类型之间的隐式类型转换。</li>
<li>可以通过*和-&gt;运算符对auto_ptr所有用的指针进行提领操作；</li>
<li>T* get(),获得auto_ptr所拥有的指针；T* release()，释放auto_ptr的所有权，并将所有用的指针返回。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  // 创建一个 auto_ptr 对象并分配内存</span><br><span class="line">  std::auto_ptr&lt;int&gt; ptr(new int(42));</span><br><span class="line"></span><br><span class="line">  // 使用 get() 方法获取 auto_ptr 持有的指针</span><br><span class="line">  int* raw_ptr = ptr.get();</span><br><span class="line">  std::cout &lt;&lt; &quot;The value of the pointer is: &quot; &lt;&lt; *raw_ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  // 使用 release() 释放 auto_ptr 的所有权，并获取所拥有的指针</span><br><span class="line">  int* released_ptr = ptr.release();</span><br><span class="line">  std::cout &lt;&lt; &quot;The value of the released pointer is: &quot; &lt;&lt; *released_ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  // 此时 ptr 已没有任何所有权，不能对其进行访问或释放</span><br><span class="line">  // std::cout &lt;&lt; &quot;The value of the released auto_ptr is: &quot; &lt;&lt; *ptr &lt;&lt; std::endl; // 试图访问会导致运行时错误</span><br><span class="line">  // ptr.reset(); // 试图释放会导致运行时错误</span><br><span class="line"></span><br><span class="line">  delete released_ptr;  // 需要手动释放获取到的指针</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="智能指针的循环引用"><a href="#智能指针的循环引用" class="headerlink" title="智能指针的循环引用"></a>智能指针的循环引用</h1><p>循环引用是指使用多个智能指针share_ptr时，出现了指针之间相互指向，从而形成环的情况，有点类似 于死锁的情况，这种情况下，智能指针往往不能正常调用对象的析构函数，从而造成内存泄漏。举个例 子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class Node</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Node(const T &amp;value)</span><br><span class="line">        : _pPre(NULL), _pNext(NULL), _value(value)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Node()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Node()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;~Node()&quot; &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;this:&quot; &lt;&lt; this &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    shared_ptr&lt;Node&lt;T&gt;&gt; _pPre;</span><br><span class="line">    shared_ptr&lt;Node&lt;T&gt;&gt; _pNext;</span><br><span class="line">    T _value;</span><br><span class="line">&#125;;</span><br><span class="line">void Funtest()</span><br><span class="line">&#123;</span><br><span class="line">    shared_ptr&lt;Node&lt;int&gt;&gt; sp1(new Node&lt;int&gt;(1));</span><br><span class="line">    shared_ptr&lt;Node&lt;int&gt;&gt; sp2(new Node&lt;int&gt;(2));</span><br><span class="line">    cout &lt;&lt; &quot;sp1.use_count:&quot; &lt;&lt; sp1.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;sp2.use_count:&quot; &lt;&lt; sp2.use_count() &lt;&lt; endl;</span><br><span class="line">    sp1-&gt;_pNext = sp2; // sp1的引用+1</span><br><span class="line">    sp2-&gt;_pPre = sp1;  // sp2的引用+1</span><br><span class="line">    cout &lt;&lt; &quot;sp1.use_count:&quot; &lt;&lt; sp1.use_count() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;sp2.use_count:&quot; &lt;&lt; sp2.use_count() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Funtest();</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//输出结果</span><br><span class="line">//Node()</span><br><span class="line">//Node()</span><br><span class="line">//sp1.use_count:1</span><br><span class="line">//sp2.use_count:1</span><br><span class="line">//sp1.use_count:2</span><br><span class="line">//sp2.use_count:2</span><br></pre></td></tr></table></figure>

<p>从上面shared_ptr的实现中我们知道了只有当引用计数减减之后等于0，析构时才会释放对象，而上述情 况造成了一个僵局，那就是析构对象时先析构sp2,可是由于sp2的空间sp1还在使用中，所以sp2.use_count 减减之后为1，不释放，sp1也是相同的道理，由于sp1的空间sp2还在使用中，所以sp1.use_count减减之 后为1，也不释放。sp1等着sp2先释放，sp2等着sp1先释放,二者互不相让，导致最终都没能释放，内存泄漏。 </p>
<p>在实际编程过程中，应该尽量避免出现智能指针之前相互指向的情况，如果不可避免，可以使用使用弱 指针——weak_ptr，它不增加引用计数，只要出了作用域就会自动析构。</p>
<p>弱指针用于专门解决shared_ptr循环引用的问题，weak_ptr不会修改引用计数，即其存在与否并不影响对 象的引用计数器。循环引用就是：两个对象互相使用一个shared_ptr成员变量指向对方。弱引用并不对对 象的内存进行管理，在功能上类似于普通指针，然而一个比较大的区别是，弱引用能检测到所管理的对 象是否已经被释放，从而避免访问非法内存。</p>
<h1 id="对数组的-amp-操作"><a href="#对数组的-amp-操作" class="headerlink" title="对数组的&amp;操作"></a>对数组的&amp;操作</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[5] = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">    //&amp;a + 1 实际上就是指向数组 a 所占内存块的下一个地址，即 &amp;a[5] 的地址</span><br><span class="line">    int *p1 = (int *)(&amp;a + 1);//&amp;a 表示的是整个数组的地址。指针加 1 的操作实际上是按照指针所指向类型的大小进行偏移</span><br><span class="line">    //&amp;a 的类型是 int (*)[5]，表示指向包含 5 个 int 类型元素的数组的指针。因此，当你执行 &amp;a + 1 时，指针会增加 sizeof(int [5]) 的大小</span><br><span class="line">    int *p2 = (int *)(a + 1);</span><br><span class="line">    printf(&quot;%d, %d\n&quot;, p1[-1], p2[1]);//5, 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="子父类构造函数的调用"><a href="#子父类构造函数的调用" class="headerlink" title="子父类构造函数的调用"></a>子父类构造函数的调用</h1><p>创建子类的时候，先检查父类是否有静态的属性，如果有，则先调用静态属性的语句，然后检查子类是否也有静态类型属性，有则调用子类的静态类型，然后在调用父类普通变量，构造函数，然后才是子类的普通属性，构造函数 顺序是：<br><strong>父类静态  -&gt; 子类静态 -&gt; 父类属性  -&gt; 父类构造函数 -&gt; 子类属性 -&gt; 子类构造函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Value1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Value1()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        printf(&quot;Call Value1::Value1(int nValue1)\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    ~Value1()</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Call Value1::~Value1()\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    int m_nVal1;</span><br><span class="line">&#125;;</span><br><span class="line">class Value</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Value(int nVal)</span><br><span class="line">    &#123;</span><br><span class="line">        m_nVal = nVal;</span><br><span class="line">        printf(&quot;Call Value::Value(int nValue)\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    ~Value()</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Call Value::~Value()\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Value &amp;operator=(int nVal)</span><br><span class="line">    &#123;</span><br><span class="line">        m_nVal = nVal;</span><br><span class="line">        printf(&quot;Call Value::operator=\n&quot;);</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    void Dump()</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Value::m_nVal=%d\n&quot;, m_nVal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    int m_nVal;</span><br><span class="line">&#125;;</span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Base()</span><br><span class="line">    &#123;</span><br><span class="line">        Init();</span><br><span class="line">    &#125;</span><br><span class="line">    virtual ~Base()</span><br><span class="line">    &#123;</span><br><span class="line">        Release();</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void Init()</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Call Base::Init()\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void Release()</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Call Base::Release()\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void Dump()</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Call Base::Dump()\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    Value1 m_Val1;</span><br><span class="line">&#125;;</span><br><span class="line">class Derive : public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Derive()</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Call Derive::Derive()\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    ~Derive()</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Call Derive::~Derive()\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void Init()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        m_Val = 2;</span><br><span class="line">        printf(&quot;Call Derive::Init()\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void Release()</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Call Derive::Release()\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void Dump()</span><br><span class="line">    &#123;</span><br><span class="line">        m_Val.Dump();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static Value m_Val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Value Derive::m_Val = 0;</span><br><span class="line"></span><br><span class="line">void DestroyObj(Base *pOb)</span><br><span class="line">&#123;</span><br><span class="line">    pOb-&gt;Dump();</span><br><span class="line">    delete pOb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Derive *pOb = new Derive;</span><br><span class="line">    DestroyObj(pOb);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Call Value::Value(int nValue)</code><br><code>Call Value1::Value1(int nValue1)</code><br><code>Call Base::Init()</code><br><code>Call Derive::Derive()</code><br><code>Value::m_nVal=0</code><br><code>Call Derive::~Derive()</code><br><code>Call Base::Release()</code><br><code>Call Value1::~Value1()</code><br><code>Call Value::~Value()</code></p>
<p>父类的非静态成员变量的初始化发生在父类的构造函数之前，这是因为在构造函数执行之前，对象的内存空间已经被分配和布局好了。在对象的内存空间布局过程中，首先会为对象的成员变量分配对应的内存空间，并按照它们在类中的声明顺序进行布局。</p>
<p>由于父类的构造函数负责对父类的成员进行初始化操作，而成员变量的初始化依赖于内存空间的分配和布局，所以需要在构造函数执行之前完成。这样在父类的构造函数中，可以直接使用已经分配并初始化好的成员变量。</p>
<p>因此，在对象的构造过程中，首先进行父类的非静态成员变量的初始化，然后才会调用父类的构造函数来完成其他的初始化操作。这样确保了对象的成员变量在构造函数中是可用和正确初始化的。</p>
<h1 id="STL-中的算法来操作堆"><a href="#STL-中的算法来操作堆" class="headerlink" title="STL 中的算法来操作堆"></a>STL 中的算法来操作堆</h1><p>heap（堆）并不是STL的容器组件，是priority queue（优先队列）的底层实现机制，因为binary max  heap（大根堆）总是最大值位于堆的根部，优先级最高。 binary heap本质是一种complete binary tree（完全二叉树），整棵binary tree除了最底层的叶节点之外，都 是填满的，但是叶节点从左到右不会出现空隙</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; v = &#123;0, 1, 2, 3, 4, 5, 6&#125;;</span><br><span class="line">    make_heap(v.begin(), v.end()); // 以vector为底层容器</span><br><span class="line">    for (auto i : v)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; &quot; &quot;; // 6 4 5 3 1 0 2</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    v.push_back(7);</span><br><span class="line">    push_heap(v.begin(), v.end());</span><br><span class="line">    for (auto i : v)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; &quot; &quot;; // 7 6 5 4 1 0 2 3</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    pop_heap(v.begin(), v.end());</span><br><span class="line">    cout &lt;&lt; v.back() &lt;&lt; endl; // 7</span><br><span class="line">    v.pop_back();</span><br><span class="line">    for (auto i : v)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; &quot; &quot;; // 6 4 5 3 1 0 2</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    sort_heap(v.begin(), v.end());</span><br><span class="line">    for (auto i : v)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; &quot; &quot;; // 0 1 2 3 4 5 6</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是pop之后元素并没有被移走，如果要将其移走，可以使用 pop_back()。在heap内部执行pop_heap时，只是将其移动到vector的最后位 置，然后再为这个被挤走的元素找到一个合适的安放位置，使整颗树满足完全二叉树的条件</p>
<p>priority_queue，优先队列，是一个拥有权值观念的queue，它跟queue一样是顶部入口，底部出口，在插 入元素时，元素并非按照插入次序排列，它会自动根据权值（通常是元素的实值）排列，权值最高，排 在最前面，如下图所示。 默认情况下，priority_queue使用一个max-heap完成，底层容器使用的是一般为vector为底层容器，堆heap 为处理规则来管理底层容器实现 。priority_queue的这种实现机制导致其不被归为容器，而是一种容器配 接器。</p>
<p>priority_queue的所有元素，进出都有一定的规则，只有queue顶端的元素（权值最高者），才有机会被外 界取用，它没有遍历功能，也不提供迭代器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int ia[9] = &#123;0, 4, 1, 2, 3, 6, 5, 8, 7&#125;;</span><br><span class="line">    priority_queue&lt;int&gt; pq(ia, ia + 9);</span><br><span class="line">    cout &lt;&lt; pq.size() &lt;&lt; endl; // 9</span><br><span class="line">    for (int i = 0; i &lt; pq.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; pq.top() &lt;&lt; &quot; &quot;; // 8 8 8 8 8 8 8 8 8</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    while (!pq.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; pq.top() &lt;&lt; &#x27; &#x27;; // 8 7 6 5 4 3 2 1 0</span><br><span class="line">        pq.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="C-把引用作为返回值"><a href="#C-把引用作为返回值" class="headerlink" title="C++ 把引用作为返回值"></a>C++ 把引用作为返回值</h1><p>通过使用引用来替代指针，会使 C++ 程序更容易阅读和维护。C++ 函数可以返回一个引用，方式与返回一个指针类似。</p>
<p>当函数返回一个引用时，则返回一个指向返回值的隐式指针。这样，函数就可以放在赋值语句的左边。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">double vals[] = &#123;10.1, 12.6, 33.1, 24.1, 50.0&#125;;</span><br><span class="line"> </span><br><span class="line">double&amp; setValues(int i) &#123;  </span><br><span class="line">   double&amp; ref = vals[i];    </span><br><span class="line">   return ref;   // 返回第 i 个元素的引用，ref 是一个引用变量，ref 引用 vals[i]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 要调用上面定义函数的主函数</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;改变前的值&quot; &lt;&lt; endl;</span><br><span class="line">   for ( int i = 0; i &lt; 5; i++ )</span><br><span class="line">   &#123;</span><br><span class="line">       cout &lt;&lt; &quot;vals[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;;</span><br><span class="line">       cout &lt;&lt; vals[i] &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   setValues(1) = 20.23; // 改变第 2 个元素</span><br><span class="line">   setValues(3) = 70.8;  // 改变第 4 个元素</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;改变后的值&quot; &lt;&lt; endl;</span><br><span class="line">   for ( int i = 0; i &lt; 5; i++ )</span><br><span class="line">   &#123;</span><br><span class="line">       cout &lt;&lt; &quot;vals[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;;</span><br><span class="line">       cout &lt;&lt; vals[i] &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当返回一个引用时，要注意被引用的对象不能超出作用域。所以返回一个对局部变量的引用是不合法的，但是，可以返回一个对静态变量的引用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int&amp; func() &#123;</span><br><span class="line">   int q;</span><br><span class="line">   //! return q; // 在编译时发生错误</span><br><span class="line">   static int x;</span><br><span class="line">   return x;     // 安全，x 在函数作用域外依然是有效的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int &amp;changevalue()</span><br><span class="line">&#123;</span><br><span class="line">    static int a_return =-29;</span><br><span class="line">    return a_return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int &amp;a_return=changevalue();</span><br><span class="line">    a_return =20;</span><br><span class="line">    cout&lt;&lt;changevalue()&lt;&lt;endl;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终，屏幕上打印的结果是：20</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/10/c%E5%92%8Cc++/c-%E8%A1%A5%E5%85%85-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/10/c%E5%92%8Cc++/c-%E8%A1%A5%E5%85%85-2/" class="post-title-link" itemprop="url">c++补充-2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-10 11:50:16" itemprop="dateCreated datePublished" datetime="2023-09-10T11:50:16+08:00">2023-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-19 16:21:56" itemprop="dateModified" datetime="2023-09-19T16:21:56+08:00">2023-09-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="extern”C”的用法"><a href="#extern”C”的用法" class="headerlink" title="extern”C”的用法"></a>extern”C”的用法</h1><p>为了能够正确的在C++代码中调用C语言的代码：在程序中加上extern “C”后，相当于告诉编译器这部分<br>代码是C语言写的，因此要按照C语言进行编译，而不是C++；<br>哪些情况下使用extern “C”：<br>（1）C++代码中调用C语言代码；<br>（2）在C++中的头文件中使用；<br>（3）在多个人协同开发时，可能有人擅长C语言，而有人擅长C++；<br>综上，总结出使用方法，在C语言的头文件中，对其外部函数只能指定为extern类型，C语言中不支持 extern “C”声明，在.c文件中包含了extern “C”时会出现编译语法错误。所以使用extern “C”全部都放在 于cpp程序相关文件或其头文件中。</p>
<p>（1）C++调用C函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//xx.h</span><br><span class="line">extern int add(...)</span><br><span class="line">//xx.c</span><br><span class="line">int add()&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">//xx.cpp</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line"> #include &quot;xx.h&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）C调用C++函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//xx.h</span><br><span class="line">extern &quot;C&quot;&#123;</span><br><span class="line"> int add();</span><br><span class="line">&#125;</span><br><span class="line">//xx.cpp</span><br><span class="line">int add()&#123; </span><br><span class="line">&#125;</span><br><span class="line">//xx.c</span><br><span class="line">extern int add();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="野指针和悬空指针"><a href="#野指针和悬空指针" class="headerlink" title="野指针和悬空指针"></a>野指针和悬空指针</h1><p>都是是指向无效内存区域(这里的无效指的是”不安全不可控”)的指针，访问行为将会导致未定义行为。</p>
<ul>
<li>野指针，指的是没有被初始化过的指针</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(void) &#123; </span><br><span class="line"> </span><br><span class="line"> 	int* p; // 未初始化</span><br><span class="line"> 	std::cout&lt;&lt; *p &lt;&lt; std::endl; // 未初始化就被使用</span><br><span class="line"> 	</span><br><span class="line"> 	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，为了防止出错，对于指针初始化时都是赋值为 nullptr，这样在使用时编译器就会直接报错， 产生非法内存访问。</p>
<ul>
<li>悬空指针，指针最初指向的内存已经被释放了的一种指针。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(void) &#123; </span><br><span class="line"> int * p = nullptr;</span><br><span class="line"> int* p2 = new int;</span><br><span class="line"> </span><br><span class="line"> p = p2;</span><br><span class="line"> delete p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时 p和p2就是悬空指针，指向的内存已经被释放。继续使用这两个指针，行为不可预料。需要设置为 p&#x3D;p2&#x3D;nullptr。此时再使用，编译器会直接保错。 </p>
<p>避免野指针比较简单，但悬空指针比较麻烦。c++引入了智能指针，C++智能指针的本质就是避免悬空指针的产生。</p>
<p>产生原因及解决办法： </p>
<ul>
<li>野指针：指针变量未及时初始化 &#x3D;&gt; 定义指针变量及时初始化，要么置空。 </li>
<li>悬空指针：指针free或delete之后没有及时置空 &#x3D;&gt; 释放操作后立即置空。</li>
</ul>
<h1 id="判断大小端存储"><a href="#判断大小端存储" class="headerlink" title="判断大小端存储"></a>判断大小端存储</h1><p>大端存储：字数据的高字节存储在低地址中</p>
<p>小端存储：字数据的低字节存储在低地址中</p>
<p>在Socket编程中，往往需要将操作系统所用的小端存储的IP地址转换为大端存储，这样才能进行网络传输</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> int a = 0x1234;</span><br><span class="line"> //由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分</span><br><span class="line"> char c = (char)(a);</span><br><span class="line"> if (c == 0x12)</span><br><span class="line"> cout &lt;&lt; &quot;big endian&quot; &lt;&lt; endl;</span><br><span class="line"> else if(c == 0x34)</span><br><span class="line"> cout &lt;&lt; &quot;little endian&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//union联合体的重叠式存储，endian联合体占用内存的空间为每个成员字节长度的最大值</span><br><span class="line">union endian</span><br><span class="line">&#123;</span><br><span class="line"> int a;</span><br><span class="line"> char ch;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> endian value;</span><br><span class="line"> value.a = 0x1234;</span><br><span class="line"> //a和ch共用4字节的内存空间</span><br><span class="line"> if (value.ch == 0x12)</span><br><span class="line"> cout &lt;&lt; &quot;big endian&quot;&lt;&lt;endl;</span><br><span class="line"> else if (value.ch == 0x34)</span><br><span class="line"> cout &lt;&lt; &quot;little endian&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="volatile、mutable和explicit关键字"><a href="#volatile、mutable和explicit关键字" class="headerlink" title="volatile、mutable和explicit关键字"></a>volatile、mutable和explicit关键字</h1><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如： 操作系统、硬件或者其它线程等。</p>
<p>遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行 优化，从而可以提供对特殊地址的稳定访问。 当要求使用 volatile 声明的变量的值的时候，<strong>系统总是重新从它所在的内存读取数据</strong>，即使它前面的指 令刚刚从该处读取过数据。</p>
<p> <strong>volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读 寄存器内的备份。多线程中被几个任务共享的变量需要定义为volatile类型。</strong></p>
<p>有些变量是用volatile关键字声明的。当两个线程都要用到某一个变量且该变量的值会被改变时，应该用 volatile声明，该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中。如果变量被装入寄存 器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执 行。volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器 中的值。</p>
<h2 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h2><p>mutable的中文意思是“可变的，易变的”，跟constant（既C++中的const）是反义词。在C++中，mutable 也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const 函数中。我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。 但是，有些时候，我们<strong>需要在const函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被 mutable来修饰，并且放在函数后后面关键字位置。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">int m_A;</span><br><span class="line">mutable int m_B;//特殊变量 在常函数里值也可以被修改</span><br><span class="line">public:</span><br><span class="line"> void add() const//在函数里不可修改this指针指向的值 常量指针</span><br><span class="line"> &#123;</span><br><span class="line"> m_A=10;//错误 不可修改值，this已经被修饰为常量指针</span><br><span class="line"> m_B=20;//正确</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">int m_A;</span><br><span class="line">mutable int m_B;//特殊变量 在常函数里值也可以被修改</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">const person p;//修饰常对象 不可修改类成员的值</span><br><span class="line">p.m_A=10;//错误，被修饰了指针常量</span><br><span class="line">p.m_B=200;//正确，特殊变量，修饰了mutable</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><p>explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以 显示的方式进行类型转换，注意以下几点： </p>
<ul>
<li>explicit 关键字只能用于类内部的构造函数声明上 </li>
<li>explicit 关键字作用于单个参数的构造函数 </li>
<li>被explicit修饰的构造函数的类，不能发生相应的隐式类型转换</li>
</ul>
<h1 id="C-的异常处理"><a href="#C-的异常处理" class="headerlink" title="C++的异常处理"></a>C++的异常处理</h1><h2 id="try、throw和catch关键字"><a href="#try、throw和catch关键字" class="headerlink" title="try、throw和catch关键字"></a>try、throw和catch关键字</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> double m = 1, n = 0;</span><br><span class="line"> try &#123;</span><br><span class="line"> cout &lt;&lt; &quot;before dividing.&quot; &lt;&lt; endl;</span><br><span class="line"> if (n == 0)</span><br><span class="line"> throw - 1; //抛出int型异常</span><br><span class="line"> else if (m == 0)</span><br><span class="line"> throw - 1.0; //拋出 double 型异常</span><br><span class="line"> else</span><br><span class="line"> cout &lt;&lt; m / n &lt;&lt; endl;</span><br><span class="line"> cout &lt;&lt; &quot;after dividing.&quot; &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> catch (double d) &#123;</span><br><span class="line"> cout &lt;&lt; &quot;catch (double)&quot; &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> catch (...) &#123;</span><br><span class="line"> cout &lt;&lt; &quot;catch (...)&quot; &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> cout &lt;&lt; &quot;finished&quot; &lt;&lt; endl;</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br><span class="line">//运行结果</span><br><span class="line">//before dividing.</span><br><span class="line"></span><br><span class="line">//catch (...)</span><br><span class="line">//finished</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码中，对两个数进行除法计算，其中除数为0。可以看到以上三个关键字，程序的执行流程是先执行try包裹的语句块，如果执行过程中没有异常发生，则不会进入任何catch包裹的语句块，如果发生异常，则使用throw进行异常抛出，再由catch进行捕获，throw可以抛出各种数据类型的信息，代码中使用的是数字，也可以自定义异常class。<strong>catch根据throw抛出的数据类型进行精确捕获（不会出现类型转换），如果匹配不到就直接报错，可以使用catch(…)的方式捕获任何异常（不推荐）</strong>。当然，如果catch了异常，当前函数如果不进行处理，或者已经处理了想通知上一层的调用者，可以在catch里面再throw异常。</p>
<h2 id="函数的异常声明列表"><a href="#函数的异常声明列表" class="headerlink" title="函数的异常声明列表"></a>函数的异常声明列表</h2><p>有时候，程序员在定义函数的时候知道函数可能发生的异常，可以在函数声明和定义时，指出所能抛出异常的列表，写法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fun() throw(int,double,A,B,C)&#123;...&#125;;</span><br></pre></td></tr></table></figure>

<p>这种写法表名函数可能会抛出int,double型或者A、B、C三种类型的异常，如果throw中为空，表明不会抛出任何异常，如果没有throw则可能抛出任何异常</p>
<h2 id="C-标准异常类-exception"><a href="#C-标准异常类-exception" class="headerlink" title="C++标准异常类 exception"></a>C++标准异常类 exception</h2><p>C++ 标准库中有一些类代表异常，这些类都是从 exception 类派生而来的</p>
<p>bad_typeid：使用typeid运算符，如果其操作数是一个多态类的指针，而该指针的值为 NULL，则会拋出此异常，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;typeinfo&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line"> virtual ~A();</span><br><span class="line">&#125;;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line"> A* a = NULL;</span><br><span class="line"> try &#123;</span><br><span class="line"> cout &lt;&lt; typeid(*a).name() &lt;&lt; endl; // Error condition</span><br><span class="line"> &#125;</span><br><span class="line"> catch (bad_typeid)&#123;</span><br><span class="line"> cout &lt;&lt; &quot;Object is NULL&quot; &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br><span class="line">//运行结果：bject is NULL</span><br></pre></td></tr></table></figure>

<ul>
<li>bad_cast：在用 dynamic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的，则会拋出此异常 </li>
<li>bad_alloc：在用 new 运算符进行动态内存分配时，如果没有足够的内存，则会引发此异常 </li>
<li>out_of_range:用 vector 或 string的at 成员函数根据下标访问元素时，如果下标越界，则会拋出此异常</li>
</ul>
<h1 id="静态变量什么时候初始化"><a href="#静态变量什么时候初始化" class="headerlink" title="静态变量什么时候初始化"></a>静态变量什么时候初始化</h1><ol>
<li>初始化只有一次，但是可以多次赋值，在主程序之前，编译器已经为其分配好了内存。</li>
<li>静态局部变量和全局变量一样，数据都存放在全局区域，所以在主程序之前，编译器已经为其分配<br>好了内存，但在C和C++中静态局部变量的初始化节点又有点不太一样。在C中，初始化发生在代码执行<br>之前，编译阶段分配好内存之后，就会进行初始化，所以我们看到在C语言中<strong>无法使用变量对静态局部</strong><br><strong>变量进行初始化</strong>，在程序运行结束，变量所处的全局内存会被全部回收。</li>
<li>而在C++中，初始化时在执行相关代码时才会进行初始化，主要是由于C++引入对象后，要进行初始<br>化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的<br>特定操作，并非简单地分配内存。所以C++标准定为全局或静态对象是有首次用到时才会进行构造，并<br>通过atexit()来管理。在程序结束，按照构造顺序反方向进行逐个析构。所以在C++中是可以使用变量对<br>静态局部变量进行初始化的。</li>
</ol>
<h1 id="i-和-i的左右值判断"><a href="#i-和-i的左右值判断" class="headerlink" title="i++和++i的左右值判断"></a>i++和++i的左右值判断</h1><p>左值就是出现在表达式左边的值（等号左边），可以被改变，他是存储数据值的那块内存的地址，也称为变量的地址；</p>
<p>右值是指存储在某内存地址中的数据，也称为变量的数据。</p>
<p>左值可以作为右值，但右值不可以是左值。</p>
<p>因此也只有<strong>左值才能被取地址</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line"></span><br><span class="line">(i++)+=i; //错误</span><br><span class="line"></span><br><span class="line">(++i)+=i; //正确 </span><br><span class="line"></span><br><span class="line">int *ip = &amp;(i++); //错误</span><br><span class="line"></span><br><span class="line">int *ip = &amp;(++i); //正确</span><br></pre></td></tr></table></figure>

<p><strong>为什么i++不能作左值</strong></p>
<p>简单得到理解，就是i++返回的是一个临时变量，函数返回后不能被寻址得到，它只是一个数据值，而非地址，因此不能作为左值</p>
<h1 id="关于二维数组例题"><a href="#关于二维数组例题" class="headerlink" title="关于二维数组例题"></a>关于二维数组例题</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int arr[][3] = &#123; &#123;1, 2, 3&#125;, &#123;4, 5, 6&#125; &#125;;</span><br><span class="line">    int (*ptr)[3] = arr;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%d %d \n&quot;, (*ptr)[0], (*ptr)[1]);</span><br><span class="line">    ptr++;</span><br><span class="line">    printf(&quot;%d %d \n&quot;, (*ptr)[0], (*ptr)[1]);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 </span><br><span class="line">4 5 </span><br></pre></td></tr></table></figure>

<p>请注意，<code>int (*ptr)[3] = arr;</code> 定义了一个指向包含3个整数元素的数组的指针，初始指向二维数组的第一行。通过 <code>(*ptr)[0]</code> 和 <code>(*ptr)[1]</code> 的方式访问了指针所指向的数组的元素。在 <code>ptr++</code> 后，指针指向了二维数组的第二行，再次访问元素时，输出了第二行的前两个元素。</p>
<p><code>int (*ptr)[3] = arr;</code> 定义了一个指向包含3个整数元素的数组的指针，初始化指向二维数组的第一行。</p>
<p>在 C&#x2F;C++ 中，数组名表示数组首元素的地址，而指针的加法运算实际上是将指针指向的地址加上一个偏移量，然后返回一个新的指针。因此，<code>ptr++</code> 将会使指针指向下一行的首元素。</p>
<p>具体地说，在这个例子中，<code>ptr</code> 指向的是 <code>arr</code> 的第一行，类型为 <code>int (*)[3]</code>，指向一个包含3个整数元素的数组，即 <code>arr[0]</code>。执行 <code>ptr++</code> 后，<code>ptr</code> 指向了 <code>arr</code> 的第二行，即指向 <code>arr[1]</code>。</p>
<p>因此，第二次输出中，<code>(*ptr)[0]</code> 和 <code>(*ptr)[1]</code> 分别对应了 <code>arr[1][0]</code> 和 <code>arr[1][1]</code> 两个元素的值。</p>
<h1 id="从汇编层去解释一下引用"><a href="#从汇编层去解释一下引用" class="headerlink" title="从汇编层去解释一下引用"></a>从汇编层去解释一下引用</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">9: int x = 1;</span><br><span class="line">00401048 mov dword ptr [ebp-4],1</span><br><span class="line">10: int &amp;b = x;</span><br><span class="line">0040104F lea eax,[ebp-4]</span><br><span class="line">00401052 mov dword ptr [ebp-8],eax</span><br></pre></td></tr></table></figure>

<p>x的地址为ebp-4，b的地址为ebp-8，因为栈内的变量内存是从高往低进行分配的，所以b的地址比x的 低。 </p>
<p>lea eax,[ebp-4] 这条语句将x的地址ebp-4放入eax寄存器 </p>
<p>mov dword ptr [ebp-8],eax 这条语句将eax的值放入b的地址 </p>
<p>ebp-8中上面两条汇编的作用即：将x的地址存入变量b中，这不和将某个变量的地址存入指针变量是一样 的吗？<strong>所以从汇编层次来看，的确引用是通过指针来实现的</strong>。</p>
<h1 id="malloc、realloc、calloc的区别"><a href="#malloc、realloc、calloc的区别" class="headerlink" title="malloc、realloc、calloc的区别"></a>malloc、realloc、calloc的区别</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1) malloc函数</span><br><span class="line">void* malloc(unsigned int num_size);</span><br><span class="line">int *p = malloc(20*sizeof(int));申请20个int类型的空间；</span><br><span class="line">2) calloc函数</span><br><span class="line">省去了人为空间计算；malloc申请的空间的值是随机初始化的，calloc申请的空间的值是初始化为0的；</span><br><span class="line">void* calloc(size_t n,size_t size);</span><br><span class="line">int *p = calloc(20, sizeof(int));</span><br><span class="line">3) realloc函数</span><br><span class="line">void realloc(void *p, size_t new_size);</span><br><span class="line">给动态分配的空间分配额外的空间，用于扩充容量。</span><br></pre></td></tr></table></figure>

<h1 id="构造函数的执行顺序"><a href="#构造函数的执行顺序" class="headerlink" title="构造函数的执行顺序"></a>构造函数的执行顺序</h1><p>一个派生类构造函数的执行顺序如下：<br>① 虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）。<br>② 基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）。<br>③ 类类型的成员对象的构造函数（按照初始化顺序）<br>④ 派生类自己的构造函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    A() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;A&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B : public A &#123;</span><br><span class="line">public:</span><br><span class="line">    B() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;B&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class C : public A &#123;</span><br><span class="line">    B b;</span><br><span class="line">public:</span><br><span class="line">    C() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;C&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    C *obj=new C();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="什么是内存泄露，如何检测与避免"><a href="#什么是内存泄露，如何检测与避免" class="headerlink" title="什么是内存泄露，如何检测与避免"></a>什么是内存泄露，如何检测与避免</h1><p>内存泄露<br>一般我们常说的内存泄漏是指堆内存的泄漏。堆内存是指程序从堆中分配的，大小任意的(内存块的大小可以在程序运行期决定)内存块，使用完后必须显式释放的内存。应用程序般使用malloc,、realloc、new等函数从堆中分配到块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了</p>
<p>避免内存泄露的几种方式</p>
<ul>
<li>计数法：使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄露</li>
<li>一定要将基类的析构函数声明为虚函数</li>
<li>对象数组的释放一定要用delete []</li>
<li>有new就有delete，有malloc就有free，保证它们一定成对出现</li>
</ul>
<p>检测工具</p>
<ul>
<li>Linux下可以使用Valgrind工具</li>
<li>Windows下可以使用CRT库</li>
</ul>
<h1 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h1><p>零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。</p>
<p>零拷贝技术可以减少数据拷贝和共享总线操作的次数。</p>
<p>在C++中，vector的一个成员函数emplace_back()很好地体现了零拷贝技术，它跟push_back()函数一样可以将一个元素插入容器尾部，区别在于：使用push_back()函数需要调用拷贝构造函数和转移构造函数，而使用emplace_back()插入的元素原地构造，不需要触发拷贝构造和转移构造，效率更高。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct Person</span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    int age;</span><br><span class="line">    // 初始构造函数</span><br><span class="line">    Person(string p_name, int p_age) : name(std::move(p_name)), age(p_age)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;I have been constructed&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    // 拷贝构造函数</span><br><span class="line">    Person(const Person &amp;other) : name(std::move(other.name)), age(other.age)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;I have been copy constructed&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    // 转移构造函数，</span><br><span class="line">    //移动构造函数（Move Constructor）用于将资源从一个对象转移到另一个对象，这通常用于提高性能，避免不必要的拷贝操作</span><br><span class="line">    //当编译器检测到可以使用移动构造函数时，它会优先选择移动构造函数而不是拷贝构造函数，以提高性能</span><br><span class="line">    //&amp;&amp; 是右值引用运算符的语法，表示一个右值引用类型</span><br><span class="line">    Person(Person &amp;&amp;other) : name(std::move(other.name)), age(other.age)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;I have been moved&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;Person&gt; e;</span><br><span class="line">    cout &lt;&lt; &quot;emplace_back:&quot; &lt;&lt; endl;</span><br><span class="line">    e.emplace_back(&quot;Jane&quot;, 23); // 不用构造类对象</span><br><span class="line">    vector&lt;Person&gt; p;</span><br><span class="line">    cout &lt;&lt; &quot;push_back:&quot; &lt;&lt; endl;</span><br><span class="line">    p.push_back(Person(&quot;Mike&quot;, 36));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">emplace_back:</span><br><span class="line">I have been constructed   </span><br><span class="line">push_back:</span><br><span class="line">I have been constructed   </span><br><span class="line">I have been moved</span><br></pre></td></tr></table></figure>

<h1 id="成员初始化列表的概念，为什么用它会快一些"><a href="#成员初始化列表的概念，为什么用它会快一些" class="headerlink" title="成员初始化列表的概念，为什么用它会快一些"></a>成员初始化列表的概念，为什么用它会快一些</h1><p>在类的构造函数中，不在函数体内对成员变量赋值，而是在构造函数的花括号前面使用冒号和初始化列 表赋值</p>
<p>用初始化列表会快一些的原因是，对于类型，它少了一次调用构造函数的过程，而在函数体中赋值则会 多一次调用。而对于内置数据类型则没有差别。举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    A()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;默认构造函数A()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    A(int a)</span><br><span class="line">    &#123;</span><br><span class="line">        value = a;</span><br><span class="line">        cout &lt;&lt; &quot;A(int &quot; &lt;&lt; value &lt;&lt; &quot;)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    A(const A &amp;a)</span><br><span class="line">    &#123;</span><br><span class="line">        value = a.value;</span><br><span class="line">        cout &lt;&lt; &quot;拷贝构造函数A(A&amp; a): &quot; &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    int value;</span><br><span class="line">&#125;;</span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    B() : a(1)</span><br><span class="line">    &#123;</span><br><span class="line">        b = A(2);</span><br><span class="line">    &#125;</span><br><span class="line">    A a;</span><br><span class="line">    A b;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    B b;</span><br><span class="line">&#125;</span><br><span class="line">// 输出结果：</span><br><span class="line">// A(int 1)</span><br><span class="line">// 默认构造函数A()</span><br><span class="line">// A(int 2)</span><br></pre></td></tr></table></figure>

<p>从代码运行结果可以看出，在构造函数体内部初始化的对象b多了一次构造函数的调用过程，而对象a则 没有。由于对象成员变量的初始化动作发生在进入构造函数之前，对于内置类型没什么影响，但如果有 些成员是类，那么在进入构造函数之前，会先调用一次默认构造函数，进入构造函数后所做的事其实是 一次赋值操作(对象已存在)，<strong>所以如果是在构造函数体内进行赋值的话，等于是一次默认构造加一次赋 值，而初始化列表只做一次赋值操作。</strong></p>
<h1 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h1><p>有类型检查，基类向派生类转换比较安全，但是派生类向基类转换则不太安全</p>
<p><code>dynamic_cast</code> 是 C++ 中用于运行时类型识别的一种操作符。它可以将一个指向基类的指针或引用转换为指向派生类的指针或引用，也可以将一个指向派生类的指针或引用转换为指向基类的指针或引用。<code>dynamic_cast</code> 能够在类型转换过程中进行安全检查，以确保类型转换的正确性。</p>
<p>在将基类指针或引用转换为派生类指针或引用时，<code>dynamic_cast</code> 可以在编译时检查类型信息，并确保类型转换的正确性。如果类型转换不正确，<code>dynamic_cast</code> 将返回一个空指针或引用。因此，这种类型转换比较安全。</p>
<p>但是，将派生类指针或引用转换为基类指针或引用时，情况就不一样了。由于派生类包含了基类的所有成员和方法，因此派生类指针或引用可以随意地转换为基类指针或引用。但是，在将派生类指针或引用转换为基类指针或引用时，由于派生类可能包含不止一个基类，而且这些基类之间可能有重叠，所以在运行时无法确定要转换的基类指针或引用的确切类型。因此，如果转换的类型与实际类型不匹配，将会出现未定义的行为。</p>
<h1 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h1><p><code>reinterpret_cast (expression)</code></p>
<p> type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以用于类型之间进行强制转 换。</p>
<h1 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h1><p><code>const_cast&lt;type_id&gt; (expression)</code><br>该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型<br>是一样的。用法如下：</p>
<ul>
<li>常量指针被转化成非常量的指针，并且仍然指向原来的对象</li>
<li>常量引用被转换成非常量的引用，并且仍然指向原来的对象</li>
<li>const_cast一般用于修改底指针。如const char *p形式</li>
</ul>
<h1 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h1><p>static_cast &lt; type-id &gt; (expression)<br>该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几<br>种用法：</p>
<ul>
<li>用于类层次结构中基类（父类）和派生类（子类）之间指针或引用引用的转换<ul>
<li>进行上行转换（把派生类的指针或引用转换成基类表示）是安全的</li>
<li>进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的</li>
</ul>
</li>
<li>用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。</li>
<li>把空指针转换成目标类型的空指针</li>
<li>把任何类型的表达式转换成void类型</li>
</ul>
<p>注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/06/c%E5%92%8Cc++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/06/c%E5%92%8Cc++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3/" class="post-title-link" itemprop="url">数据结构-3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-06 21:18:06" itemprop="dateCreated datePublished" datetime="2023-09-06T21:18:06+08:00">2023-09-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-07 16:31:20" itemprop="dateModified" datetime="2023-10-07T16:31:20+08:00">2023-10-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="服务器A和B交换资源"><a href="#服务器A和B交换资源" class="headerlink" title="服务器A和B交换资源"></a>服务器A和B交换资源</h1><p>输入两行，每个数字之间用空格隔开，代表服务器A和B下节点的资源数，某个资源交换之后A和B的资源数相等，输出交换后的资源</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;numeric&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string line;</span><br><span class="line">    </span><br><span class="line">    // 读取输入行</span><br><span class="line">    getline(cin, line);</span><br><span class="line"></span><br><span class="line">    // 创建字符串流</span><br><span class="line">    stringstream ss(line);//std::string delimiter = &quot;,&quot;;  // 自定义分隔符</span><br><span class="line">    					  //std::getline(ss, token, delimiter[0]);</span><br><span class="line">    int num,sumA,sumB;</span><br><span class="line">    vector&lt;int&gt; resourcesA;</span><br><span class="line"></span><br><span class="line">    // 解析服务器A节点的资源数</span><br><span class="line">    while (ss &gt;&gt; num) &#123;</span><br><span class="line">        resourcesA.push_back(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 读取下一行输入</span><br><span class="line">    getline(cin, line);</span><br><span class="line">    stringstream ss2(line);//使用 std::stringstream 对象进行输入操作时，默认情况下，空格是被认为是分隔符的，即会被用来划分不同的变量值</span><br><span class="line">    vector&lt;int&gt; resourcesB;</span><br><span class="line"></span><br><span class="line">    // 解析服务器B节点的资源数</span><br><span class="line">    while (ss2 &gt;&gt; num) &#123;</span><br><span class="line">        //由于空格是默认的分隔符，因此 ss &gt;&gt; num 操作符会自动跳过空格，直到遇到一个整数，</span><br><span class="line">        //在这种情况下，它会将整数提取出来，并将其存储到 num 变量中。然后，我们将 num 添加到向量 vec 中</span><br><span class="line">        resourcesB.push_back(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在此处添加你的交换逻辑和计算等操作</span><br><span class="line">    for (int i = 0; i &lt; resourcesA.size(); ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; resourcesB.size(); ++j) &#123;</span><br><span class="line">            swap(resourcesA[i],resourcesB[j]);</span><br><span class="line">            sumA=accumulate(resourcesA.begin(), resourcesA.end(),0);</span><br><span class="line">            sumB=accumulate(resourcesB.begin(), resourcesB.end(),0);</span><br><span class="line">            if(sumA == sumB)</span><br><span class="line">                break;</span><br><span class="line">            swap(resourcesA[i],resourcesB[j]);</span><br><span class="line">         &#125;</span><br><span class="line">         if (sumA == sumB) &#123;</span><br><span class="line">            break;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    // 输出结果</span><br><span class="line">    for (int i = 0; i &lt; resourcesA.size(); ++i) &#123;</span><br><span class="line">        cout &lt;&lt; resourcesA[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; resourcesB.size(); ++i) &#123;</span><br><span class="line">        cout &lt;&lt; resourcesB[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3/image-20230906222153192.png" alt="image-20230906222153192"></p>
<img src="/2023/09/06/c%E5%92%8Cc++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3/image-20230906222153192.png" class title="This is an test image">

<p><code>std::getline</code> 函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cppCopy Codetemplate&lt; class CharT, class Traits, class Allocator &gt;</span><br><span class="line">std::basic_istream&lt;CharT,Traits&gt;&amp; getline( std::basic_istream&lt;CharT,Traits&gt;&amp; input,</span><br><span class="line">                                           std::basic_string&lt;CharT,Traits,Allocator&gt;&amp; str,</span><br><span class="line">                                           CharT delim );</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>input</code>：输入流对象，如 <code>std::cin</code>。</li>
<li><code>str</code>：用于存储读取的字符串的变量。</li>
<li><code>delim</code>：可选参数，指定行结束的分隔符，默认为换行符 <code>\n</code>。你可以传递其他字符作为分隔符，例如 <code>&#39;,&#39;</code> 或 <code>&#39; &#39;</code>。</li>
</ul>
<p>注意事项：</p>
<ul>
<li>如果读取到的行为空（即只有换行符），则 <code>std::getline</code> 将不会向 <code>str</code> 中存储任何内容。</li>
<li><code>std::getline</code> 函数会读取到分隔符为止，但不会将其存储在 <code>str</code> 中。</li>
</ul>
<h1 id="回文最少分割"><a href="#回文最少分割" class="headerlink" title="回文最少分割"></a>回文最少分割</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    string str;</span><br><span class="line">    while(cin&gt;&gt;str)&#123;</span><br><span class="line">        int len = str.size();</span><br><span class="line">        int isRound[len][len];//记录第i个字符与第j个字符之间的字符是否是回文串</span><br><span class="line">        memset(isRound,0,sizeof(isRound));</span><br><span class="line">        int dp[len+1];//记录从第0个字符开始到当前字符最少的分割数</span><br><span class="line">        dp[-1] = -1;//动态规划中处理边界情况而设置的一个初始值</span><br><span class="line">        for(int i = 0;i&lt;len;i++)&#123;</span><br><span class="line">            dp[i] = i;//dp[i]表示以第i个字符结尾的子字符串（包括第i个字符）中的最少回文子序列个数</span><br><span class="line">            for(int j = i;j&gt;=0;j--)&#123;</span><br><span class="line">            	//(i-j&lt;2)表示子串的长度小于2时，无需进一步判断，直接视为回文子串</span><br><span class="line">            	//isRound[j+1][i-1]表示去掉首尾字符后的子串是否为回文子串。</span><br><span class="line">                if(str[i]==str[j]&amp;&amp;(i-j&lt;2||isRound[j+1][i-1]))&#123;</span><br><span class="line">                    isRound[j][i] = 1;</span><br><span class="line">                    dp[i] = (dp[i]&lt;dp[j-1]+1?dp[i]:dp[j-1]+1);</span><br><span class="line">                &#125;	</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;dp[len-1]&lt;&lt;endl;//即整个字符串的最少回文子序列个数</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双重循环用于填充<code>isRound</code>数组和更新<code>dp</code>数组。在每次迭代中，我们遍历从第<code>i</code>个字符到第<code>j</code>个字符的所有可能子串。如果当前子串是一个回文子串（满足条件<code>str[i]==str[j]</code>且长度小于等于2或者更小的子串也是回文子串），则将<code>isRound[j][i]</code>标记为1，并更新<code>dp[i]</code>为<code>dp[j-1]+1</code>或<code>dp[i]</code>中的较小值</p>
<p>具体思路如下：</p>
<p>首先，定义 <code>dp[i]</code> 表示以第 i 个字符结尾的子字符串（包括第 i 个字符）中的最少回文子序列个数。因此，最终我们需要求解整个字符串的最小回文子序列个数，即 <code>dp[len-1]</code>。</p>
<p>接下来考虑如何推导出 <code>dp[i]</code> 的值。我们可以从前往后遍历字符串，对于每个 <code>i</code>，再从 <code>i</code> 往前遍历所有的可能的起点 <code>j</code>，检查子串 <code>str[j..i]</code> 是否为回文子串。如果是回文子串，则通过状态转移方程 <code>dp[i] = min(dp[i], dp[j-1]+1)</code> 更新 <code>dp[i]</code>。</p>
<p>其中，如果 <code>str[j..i]</code> 的长度小于等于 1，则直接视为回文子串。否则，需要检查其中间部分是否也是回文子串。可以通过使用一个二维数组 <code>isRound</code> 记录每个子串中的字符是否构成回文子串来实现。</p>
<p>最后，将整个字符串的最小回文子序列个数输出即可。</p>
<p>状态转移方程 <code>dp[i] = min(dp[i], dp[j-1]+1)</code> 是这个动态规划算法的核心。</p>
<p>其中 <code>dp[i]</code> 表示以第 i 个字符结尾的子字符串（包括第 i 个字符）中的最少回文子序列个数。因此，我们需要通过 <code>dp[j-1]</code> 求出以下两个值中的较小值：</p>
<ul>
<li>从第 0 个字符开始到第 j-1 个字符为止的子字符串中的最少回文子序列个数。即 <code>dp[j-1]</code>。这里要求子串中必须包含第 j-1 个字符。</li>
<li>如果子串 <code>str[j..i]</code> 本身就是回文子串，则不需要再分割，此时包含 i 个字符的子字符串的最少回文子序列个数为 1。因此，我们可以将当前子串视为由 j-1 号字符后面新分割出来的一个回文子序列，所需的分割次数为 1。</li>
</ul>
<p>计算出这两个值之后，将它们加上 1（表示将 j-1 后面的子串作为一个新回文子序列），即可得到在子串 <code>str[j..i]</code> 内部新分割出一个回文子序列所需的最少分割次数。我们需要比较这个最少分割次数与当前 <code>dp[i]</code> 的值，取较小者更新 <code>dp[i]</code>。这样就能够更新到整个字符串所需最少的分割次数了</p>
<hr>
<p>这个算法是一个动态规划算法，主要原因是它满足动态规划的两个关键特征：</p>
<ul>
<li>最优子结构性质</li>
</ul>
<p>最优子结构是指一个问题的最优解包含了其子问题的最优解。在本问题中，对于任意以第 i 个字符结尾的子字符串，它的最少回文子序列个数可以由它的前面的子串（即以小于 i 的下标结尾的子串）的最少回文子序列个数推导得出，因此满足最优子结构性质。</p>
<ul>
<li>重叠子问题性质</li>
</ul>
<p>重叠子问题性质是指在解决一个问题时需要多次求解重复的子问题。在本问题中，计算一个以第 i 个字符结尾的子字符串中的最少回文子序列个数需要用到它所有的前缀子串中的每一个最少回文子序列个数，而这些前缀子串是有重叠的部分的，因此满足重叠子问题性质。</p>
<p>基于以上两个特征，我们可以使用动态规划算法来解决本问题，具体实现过程就是：通过递推式计算出每个状态（即 <code>dp</code> 数组中的每个元素），并保存中间结果，避免重复计算同一个子问题。</p>
<h1 id="LRU缓存"><a href="#LRU缓存" class="headerlink" title="LRU缓存"></a>LRU缓存</h1><p>LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。</p>
<ul>
<li><p>双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最久未使用的，而靠近尾部的键值对是最近使用的。</p>
</li>
<li><p>哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。</p>
</li>
</ul>
<p>这样以来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 O(1)O(1)O(1) 的时间内完成 get 或者 put 操作。具体的方法如下：</p>
<ul>
<li><p>对于 get 操作，首先判断 key 是否存在：</p>
<ul>
<li><p>如果 key 不存在，则返回 −1-1−1；</p>
</li>
<li><p>如果 key 存在，则 key 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的尾部，最后返回该节点的值。</p>
</li>
</ul>
</li>
<li><p>对于set 操作，首先判断 key 是否存在：</p>
<ul>
<li><p>如果 key 不存在，使用 key 和 value 创建一个新的节点，在双向链表的尾部添加该节点，并将 key 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的头部节点（即伪头部下一个），并删除哈希表中对应的项；</p>
</li>
<li><p>如果 key 存在，则与 get 操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的尾部。</p>
</li>
</ul>
</li>
</ul>
<p>上述各项操作中，访问哈希表的时间复杂度为 O(1)O(1)O(1)，在双向链表的尾部添加节点、在双向链表的头部删除节点的复杂度也为 O(1)O(1)O(1)。而将一个节点移到双向链表的头部，可以分成「删除该节点」和「在双向链表的头部添加节点」两步操作，都可以在 O(1)O(1)O(1) 时间内完成。</p>
<p>复杂度分析</p>
<ul>
<li><p>时间复杂度：对于 put 和 get 都是 O(1)O(1)O(1)。</p>
</li>
<li><p>空间复杂度：<em>O</em>(capacity)，因为哈希表和双向链表最多存储 capacity+1 个元素</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">struct DoubleList</span><br><span class="line">&#123;</span><br><span class="line">    int key, val;</span><br><span class="line">    DoubleList *pre, *next;</span><br><span class="line">    DoubleList(int _key, int _val) : key(_key), val(_val), pre(nullptr), next(nullptr) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class LRU</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int capacity;</span><br><span class="line">    DoubleList *head, *tail;</span><br><span class="line">    unordered_map&lt;int, DoubleList *&gt; memory;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    LRU(int _capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;capacity = _capacity;</span><br><span class="line">        head = new DoubleList(-1, -1);</span><br><span class="line">        tail = new DoubleList(-1, -1);</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;pre = head;</span><br><span class="line">    &#125;</span><br><span class="line">    ~LRU()</span><br><span class="line">    &#123;</span><br><span class="line">        if (head != nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            delete head;</span><br><span class="line">            head = nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        if (tail != nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            delete tail;</span><br><span class="line">            tail = nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        for (auto &amp;a : memory)</span><br><span class="line">        &#123;</span><br><span class="line">            if (a.second != nullptr)</span><br><span class="line">            &#123;</span><br><span class="line">            	//在使用 unordered_map 存储指针作为值时，需要小心管理内存分配和释放，以避免内存泄漏</span><br><span class="line">                delete a.second;</span><br><span class="line">                a.second = nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void set(int _key, int _val)</span><br><span class="line">    &#123;</span><br><span class="line">        if (memory.find(_key) != memory.end())</span><br><span class="line">        &#123;</span><br><span class="line">            DoubleList *node = memory[_key];</span><br><span class="line">            removeNode(node);</span><br><span class="line">            node-&gt;val = _val;</span><br><span class="line">            pushNode(node);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (memory.size() == this-&gt;capacity)</span><br><span class="line">        &#123;                                 // 这里很重要，也很爱错，千万记得更新memory</span><br><span class="line">            int topKey = head-&gt;next-&gt;key; // 取得key值，方便在后面删除</span><br><span class="line">            removeNode(head-&gt;next);       // 移除头部的下一个</span><br><span class="line">            memory.erase(topKey);         // 在memory中删除当前头部的值</span><br><span class="line">        &#125;</span><br><span class="line">        DoubleList *node = new DoubleList(_key, _val); // 新增node</span><br><span class="line">        pushNode(node);                                // 放在尾部</span><br><span class="line">        memory[_key] = node;                           // 记得在memory中添加进去</span><br><span class="line">    &#125;</span><br><span class="line">    int get(int _key)</span><br><span class="line">    &#123;</span><br><span class="line">        if (memory.find(_key) != memory.end())</span><br><span class="line">        &#123;</span><br><span class="line">            DoubleList *node = memory[_key];</span><br><span class="line">            removeNode(node);</span><br><span class="line">            pushNode(node);</span><br><span class="line">            return node-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    void removeNode(DoubleList *node)</span><br><span class="line">    &#123;</span><br><span class="line">        node-&gt;pre-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;pre = node-&gt;pre;</span><br><span class="line">    &#125;</span><br><span class="line">    void pushNode(DoubleList *node)</span><br><span class="line">    &#123;</span><br><span class="line">        tail-&gt;pre-&gt;next = node;</span><br><span class="line">        node-&gt;pre = tail-&gt;pre;</span><br><span class="line">        node-&gt;next = tail;</span><br><span class="line">        tail-&gt;pre = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>unordered_map</code> 是 C++ 标准库提供的关联容器之一，它存储了键-值对，并支持通过键来快速访问值。在这个示例中，<code>cache</code> 中存储了 <code>int</code> 类型的键和指向 <code>DLinkedNode</code> 对象的指针作为值。</p>
<p>你可以使用 <code>cache</code> 对象执行以下操作：</p>
<p>插入键值对：可以使用 <code>cache[key] = value</code> 的方式插入新的键值对，其中 <code>key</code> 是要插入的键，<code>value</code> 是要插入的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cache[1] = new DLinkedNode();</span><br></pre></td></tr></table></figure>

<p>访问值：可以使用 <code>cache[key]</code> 的方式访问特定键对应的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DLinkedNode* node = cache[1];</span><br></pre></td></tr></table></figure>

<p>检查键是否存在：可以使用 <code>count()</code> 或 <code>find()</code> 方法来检查特定键是否存在于 <code>cache</code> 中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (cache.count(1) &gt; 0) &#123;</span><br><span class="line">    // 键存在</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或者使用 find()</span><br><span class="line">if (cache.find(1) != cache.end()) &#123;</span><br><span class="line">    // 键存在</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>unordered_map</code> 和 <code>map</code> 是 C++ 中的两种关联容器，它们在实现和性能上有一些区别：</p>
<ol>
<li>有序性：<code>unordered_map</code> 是基于哈希表实现的，所以它不维护元素的顺序，也不支持按键排序。而 <code>map</code> 是基于红黑树实现的，它会根据键的比较排序元素，所以它是有序的。</li>
<li>查找效率：对于 <code>unordered_map</code>，通过哈希函数可以快速定位到元素的位置，平均情况下查找的时间复杂度为 O(1)。而对于 <code>map</code>，由于元素是有序的，查找的时间复杂度为 O(log n)，其中 n 是元素数量。</li>
<li>内存占用：由于需要维护红黑树的结构，<code>map</code> 往往比 <code>unordered_map</code> 占用更多的内存空间。</li>
<li>插入和删除操作：对于 <code>unordered_map</code>，插入和删除操作的时间复杂度也是平均 O(1) 的，而对于 <code>map</code>，由于需要维护有序性，插入和删除操作的时间复杂度为 O(log n)。</li>
</ol>
<p>根据具体的需求，选择使用 <code>unordered_map</code> 还是 <code>map</code>。如果对元素的顺序没有要求，并且关注查找的速度，可以选择 <code>unordered_map</code>。如果需要有序的元素集合，并且关注元素的插入和删除效率，可以选择 <code>map</code>。</p>
<h1 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a>重排链表</h1><p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ， 将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→… 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.</span><br><span class="line">示例 2:</span><br><span class="line">给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct node *next;</span><br><span class="line">    node(int _data) : data(_data),next(nullptr)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void reorderList(node* head) &#123;</span><br><span class="line">        if (head == nullptr) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;node *&gt; vec;</span><br><span class="line">        node *node = head;</span><br><span class="line">        while (node != nullptr) &#123;</span><br><span class="line">            vec.emplace_back(node);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        int i = 0, j = vec.size() - 1;</span><br><span class="line">        while (i &lt; j) &#123;</span><br><span class="line">            vec[i]-&gt;next = vec[j];</span><br><span class="line">            i++;</span><br><span class="line">            if (i == j) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            vec[j]-&gt;next = vec[i];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        vec[i]-&gt;next = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    node *head=new node(-1);</span><br><span class="line">    node *newhead = new node(-1);</span><br><span class="line">    newhead=head;//不能next，这样才能在改变head后从头节点访问</span><br><span class="line">    string str;</span><br><span class="line">    getline(cin,str);</span><br><span class="line">    stringstream ss(str);</span><br><span class="line">    int a;</span><br><span class="line">    while(ss&gt;&gt;a)</span><br><span class="line">    &#123;</span><br><span class="line">        node *node1=new node(a);</span><br><span class="line">        head-&gt;next=node1;</span><br><span class="line">        head=head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Solution *sol=new Solution();</span><br><span class="line">    sol-&gt;reorderList(newhead-&gt;next);</span><br><span class="line">    while (newhead) &#123;</span><br><span class="line">        cout &lt;&lt;newhead-&gt;next-&gt;data &lt;&lt; endl;</span><br><span class="line">        newhead=newhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="三个线程交替打印ABC"><a href="#三个线程交替打印ABC" class="headerlink" title="三个线程交替打印ABC"></a>三个线程交替打印ABC</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;condition_variable&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">mutex mymutex;</span><br><span class="line">condition_variable cv;</span><br><span class="line">int flag = 0;</span><br><span class="line">void printa()</span><br><span class="line">&#123;</span><br><span class="line">    unique_lock&lt;mutex&gt; lk(mymutex);</span><br><span class="line">    int count = 0;</span><br><span class="line">    while (count &lt; 10)</span><br><span class="line">    &#123;</span><br><span class="line">        while (flag != 0)</span><br><span class="line">            cv.wait(lk);</span><br><span class="line">        cout &lt;&lt; &quot;thread 1: a&quot; &lt;&lt; endl;</span><br><span class="line">        flag = 1;</span><br><span class="line">        cv.notify_all();</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;my thread 1 finish&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void printb()</span><br><span class="line">&#123;</span><br><span class="line">    unique_lock&lt;mutex&gt; lk(mymutex);</span><br><span class="line">    for (int i = 0; i &lt; 10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        while (flag != 1)</span><br><span class="line">            cv.wait(lk);</span><br><span class="line">        cout &lt;&lt; &quot;thread 2: b&quot; &lt;&lt; endl;</span><br><span class="line">        flag = 2;</span><br><span class="line">        cv.notify_all();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;my thread 2 finish&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void printc()</span><br><span class="line">&#123;</span><br><span class="line">    unique_lock&lt;mutex&gt; lk(mymutex);</span><br><span class="line">    for (int i = 0; i &lt; 10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        while (flag != 2)</span><br><span class="line">            cv.wait(lk);</span><br><span class="line">        cout &lt;&lt; &quot;thread 3: c&quot; &lt;&lt; endl;</span><br><span class="line">        flag = 0;</span><br><span class="line">        cv.notify_all();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;my thread 3 finish&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	//是一个 C++ 11 中创建线程的语句。该语句创建了一个名为 th2 的线程对象，并将函数 printa 作为线程的入口点</span><br><span class="line">    thread th2(printa);</span><br><span class="line">    thread th1(printb);</span><br><span class="line">    thread th3(printc);</span><br><span class="line">    th1.join();</span><br><span class="line">    th2.join();//是一个 C++11 中的语句，用于等待线程 th2 的执行结束,没有回收线程资源的功能。它只是让当前线程阻塞</span><br><span class="line">    th3.join();</span><br><span class="line">    cout &lt;&lt; &quot; main thread &quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//thread 1: a</span><br><span class="line">//thread 2: b</span><br><span class="line">//thread 3: c</span><br><span class="line">//thread 1: a</span><br><span class="line">//thread 2: b</span><br><span class="line">//thread 3: c</span><br><span class="line">//thread 1: a</span><br><span class="line">//thread 2: b</span><br><span class="line">//thread 3: c</span><br><span class="line">//thread 1: a</span><br><span class="line">//thread 2: b</span><br><span class="line">//thread 3: c</span><br><span class="line">//thread 1: a</span><br><span class="line">//thread 2: b</span><br><span class="line">//thread 3: c</span><br><span class="line">//thread 1: a</span><br><span class="line">//thread 2: b</span><br><span class="line">//thread 3: c</span><br><span class="line">//thread 1: a</span><br><span class="line">//thread 2: b</span><br><span class="line">//thread 3: c</span><br><span class="line">//thread 1: a</span><br><span class="line">//thread 2: b</span><br><span class="line">//thread 3: c</span><br><span class="line">//thread 1: a</span><br><span class="line">//thread 2: b</span><br><span class="line">//thread 3: c</span><br><span class="line">//thread 1: a</span><br><span class="line">//my thread 1 finish</span><br><span class="line">//thread 2: b</span><br><span class="line">//my thread 2 finish</span><br><span class="line">//thread 3: c</span><br><span class="line">//my thread 3 finish</span><br><span class="line">//main thread</span><br></pre></td></tr></table></figure>

<p>C++11 中的 <code>std::thread</code> 类提供了更加面向对象的方式来创建和管理线程，代码更加简洁易读。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;thread&gt;</span><br><span class="line"></span><br><span class="line">std::thread th(tfn, i);</span><br></pre></td></tr></table></figure>

<p>使用 <code>std::thread</code>，你可以直接创建一个线程对象，并指定线程的入口函数和参数。</p>
<p>与 <code>pthread_create</code> 不同，<code>std::thread</code> 在线程对象销毁时会自动处理资源回收，无需手动调用 <code>pthread_join</code> 或 <code>pthread_detach</code>。</p>
<p>总结而言，<code>pthread_create</code> 是 POSIX 线程库中的函数，而 <code>std::thread</code> 是 C++11 中标准库提供的线程类，使用 <code>std::thread</code> 可以更方便地创建和管理线程</p>
<hr>
<p><code>unique_lock&lt;mutex&gt; lk(mymutex);</code> 是一个 C++11 中用于实现互斥锁的语法，它的作用是创建一个 <code>unique_lock</code> 对象并锁定指定的互斥量（即 <code>mymutex</code>）。</p>
<p>在 C++11 中，<code>mutex</code> 是一个标准库类型，用于实现多线程中的互斥锁。对于共享资源的访问，我们需要保证同一时刻只有一个线程能够访问该资源，这就需要用到互斥锁。</p>
<p><code>unique_lock</code> 是 C++11 中对互斥锁进行操作的一个封装类，它提供了比传统的 <code>lock()</code> 和 <code>unlock()</code> 更加丰富的操作，例如自动地加锁和解锁、支持调用 <code>try_lock()</code> 等函数来尝试获取锁等。</p>
<p>具体来说，当我们在创建 <code>unique_lock</code> 对象时，即 <code>unique_lock&lt;mutex&gt; lk(mymutex);</code>，该对象会自动地获取 <code>mymutex</code> 的锁，并阻塞当前线程直到获取成功。当 <code>lk</code> 对象超出作用域时，它会自动释放 <code>mymutex</code> 的锁。</p>
<p>以这种方式使用 <code>unique_lock</code> 可以确保线程安全，并且同时避免了手动加锁和解锁所带来的不必要烦恼和风险。</p>
<p>需要注意的是，在使用 <code>unique_lock</code> 时，我们应该尽量减少持有锁的时间，以避免因为长时间占用互斥锁导致程序性能下降。</p>
<hr>
<p><code>cv.wait(lk)</code> 和 <code>cv.notify_all()</code> 是与条件变量（Condition Variable）相关的操作。</p>
<p>在 C++ 中，条件变量用于线程间的同步和通信。它允许线程等待某个条件成立，并在条件满足时被通知继续执行。</p>
<p><code>cv.wait(lk)</code> 是一个等待操作，它会阻塞当前线程，并释放持有的 <code>unique_lock</code> 对象 <code>lk</code> 所关联的互斥锁（即 <code>mymutex</code>）。线程会被挂起，直到其他线程调用 <code>cv.notify_all()</code> 或 <code>cv.notify_one()</code> 来通知条件变量的唤醒。</p>
<p>一般情况下，使用 <code>cv.wait(lk)</code> 时需要搭配条件判断来确保线程在正确的条件下等待和被唤醒。</p>
<p>当条件满足时，可以通过调用 <code>cv.notify_all()</code> 或 <code>cv.notify_one()</code> 来唤醒等待的线程。</p>
<p><code>cv.notify_all()</code> 会唤醒所有等待条件变量的线程，而 <code>cv.notify_one()</code> 则会随机唤醒一个等待的线程。</p>
<p>这样的组合使用可以实现线程间的同步和通信，避免了不必要的忙等待和资源浪费。</p>
<p>需要注意的是，在调用 <code>cv.wait(lk)</code> 之前，必须通过 <code>unique_lock</code> 对象 <code>lk</code> 持有相应的互斥锁，因为 <code>wait()</code> 函数会在等待之前释放该互斥锁，并在被唤醒时重新获取锁</p>
<h1 id="Top-K-问题"><a href="#Top-K-问题" class="headerlink" title="Top K 问题"></a>Top K 问题</h1><p>Top K 问题是指从一组元素中找出前 K 个最大或最小的元素。有几种解决 Top K 问题的常用方法：</p>
<ol>
<li>排序：对整个数组进行排序，然后取前 K 个元素。时间复杂度为 O(NlogN)，其中 N 是数组的长度。这种方法适用于 K 较小的情况。</li>
<li>堆：使用堆数据结构来解决 Top K 问题。维护一个大小为 K 的最小堆或最大堆，遍历数组中的元素，将元素依次加入堆中，使堆的大小保持在 K。如果当前元素比堆顶元素大（或小），则替换堆顶元素，并重新调整堆。最后，堆中的元素即为前 K 个最大（或最小）的元素。该方法的时间复杂度为 O(NlogK)，其中 N 是数组的长度。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct Node &#123;</span><br><span class="line">     int value;</span><br><span class="line">     int idx;</span><br><span class="line">     Node (int v, int i): value(v), idx(i) &#123;&#125;</span><br><span class="line">     //friend 关键字表示 &lt; 函数是 struct Node 的友元函数，可以访问 struct Node 中的私有成员变量</span><br><span class="line">     friend bool operator &lt; (const struct Node &amp;n1, const struct Node &amp;n2) ; //这里可以没有</span><br><span class="line">&#125;;</span><br><span class="line">//在C++中，默认情况下，priority_queue是一个最大堆（即堆顶元素最大）</span><br><span class="line">//将值较大的元素放在堆顶</span><br><span class="line">inline bool operator &lt; (const struct Node &amp;n1, const struct Node &amp;n2) &#123;</span><br><span class="line"> 	return n1.value &lt; n2.value;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    priority_queue&lt;Node&gt; pq;// 此时pq为最大堆</span><br><span class="line"></span><br><span class="line">    pq.push(Node(3, 0));</span><br><span class="line">    pq.push(Node(5, 1));</span><br><span class="line">    pq.push(Node(2, 2));</span><br><span class="line"></span><br><span class="line">    while (!pq.empty()) &#123;</span><br><span class="line">        Node top = pq.top();</span><br><span class="line">        pq.pop();</span><br><span class="line">        cout &lt;&lt; &quot;Value: &quot; &lt;&lt; top.value &lt;&lt; &quot; Index: &quot; &lt;&lt; top.idx &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>inline bool operator &lt; (const struct Node &amp;n1, const struct Node &amp;n2)</code> 是一个重载小于号 <code>&lt;</code> 运算符的函数。但是，它实际上并没有直接重载优先队列 <code>priority_queue</code> 中 <code>&lt;</code> 运算符，而是重载了节点结构体 <code>Node</code> 中的 <code>&lt;</code> 运算符。由于优先队列 <code>priority_queue</code> 默认使用元素类型的 <code>&lt;</code> 运算符来进行排序，因此，在这种情况下，节点结构体 <code>Node</code> 中的 <code>&lt;</code> 运算符会被用来对节点对象进行排序，从而达到了重载优先队列 <code>priority_queue</code> 的效果。</p>
<p>3.快速选择算法：类似于快速排序的思想，通过划分操作将数组分为两部分，每次选择一个基准元素，将小于基准元素的放在左边，大于基准元素的放在右边。如果基准元素的位置恰好等于 K-1，则基准元素及其左边的元素就是前 K 个最大的元素。如果基准元素的位置小于 K-1，则在基准元素的右边继续进行划分操作。如果基准元素的位置大于 K-1，则在基准元素的左边进行划分操作。该方法的平均时间复杂度为 O(N)，最坏情况下时间复杂度为 O(N^2)。</p>
<p>Quick Select脱胎于快速排序，提出这两个算法的都是同一个人。算法的过程是这样的： 首先选取一个枢轴，然后将数组中小于该枢轴的数放到左边，大于该枢轴的数放到右边。 此时，如果左边的数组中的元素个数大于等于K，则第K大的数肯定在左边数组中，继续对左边数组 执行相同操作； 如果左边的数组元素个数等于K-1，则第K大的数就是pivot； 如果左边的数组元素个数小于K，则第K大的数肯定在右边数组中，对右边数组执行相同操作。 这个算法与快排最大的区别是，<strong>每次划分后只处理左半边或者右半边，而快排在划分后对左右半边都继续排序。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 分区函数，将小于枢轴的数放到左边，大于枢轴的数放到右边</span><br><span class="line">//选择第一个元素作为枢轴，并通过不断交换元素的方式将小于枢轴的数移到左边，大于枢轴的数移到右边，最终将枢轴放到正确的位置上</span><br><span class="line">int partition(vector&lt;int&gt;&amp; nums, int low, int high) &#123;</span><br><span class="line">    int pivot = nums[low]; // 选择第一个元素作为枢轴</span><br><span class="line">    while (low &lt; high) &#123;</span><br><span class="line">        while (low &lt; high &amp;&amp; nums[high] &gt;= pivot) &#123;</span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[low] = nums[high]; // 将较小的值移到左边</span><br><span class="line"></span><br><span class="line">        while (low &lt; high &amp;&amp; nums[low] &lt;= pivot) &#123;</span><br><span class="line">            low++;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[high] = nums[low]; // 将较大的值移到右边</span><br><span class="line">    &#125;</span><br><span class="line">    nums[low] = pivot; // 将枢轴放到最终位置</span><br><span class="line">    return low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int quickSelect(vector&lt;int&gt;&amp; nums, int low, int high, int k) &#123;</span><br><span class="line">	if (left == right) </span><br><span class="line">		return arr[right];</span><br><span class="line">    int pivotIndex = partition(nums, low, high); // 划分数组，随机选择一个枢轴元素，返回枢轴的索引</span><br><span class="line">    if (pivotIndex-low+1 == k ) &#123;</span><br><span class="line">        return nums[pivotIndex]; // 找到第 k 大的元素</span><br><span class="line">    &#125; else if (pivotIndex-low+1 &gt; k) &#123;</span><br><span class="line">        return quickSelect(nums, low, pivotIndex - 1, k); // 在左半边继续查找</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return quickSelect(nums, pivotIndex + 1, high, k-(pivotIndex-low+1)); // 在右半边继续查找</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">    int n = nums.size();</span><br><span class="line">    return quickSelect(nums, 0, n - 1, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;3, 2, 1, 5, 6, 4&#125;;</span><br><span class="line">    int k = 2;</span><br><span class="line">    int result = findKthLargest(nums, k);</span><br><span class="line">    cout &lt;&lt; &quot;第 &quot; &lt;&lt; k &lt;&lt; &quot; 大的元素是：&quot; &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这些方法的选择应取决于具体的场景和数据规模。如果 K 较小且不需要改变原始数组的顺序，堆是一个高效的选择。如果 K 相对较大或需要改变原始数组的顺序，可以考虑使用快速选择算法。如果对时空复杂度要求较低，且不改变原始数组的顺序，可以先进行排序再取前 K 个元素。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">肖汇林</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">82</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">肖汇林</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
