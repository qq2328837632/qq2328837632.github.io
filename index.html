<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="选择有时候比努力更重要">
<meta property="og:type" content="website">
<meta property="og:title" content="肖汇林的博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="肖汇林的博客">
<meta property="og:description" content="选择有时候比努力更重要">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="肖汇林">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>肖汇林的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖汇林的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/16/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%885%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/16/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%885%EF%BC%89/" class="post-title-link" itemprop="url">muduo-网络库（5）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-16 19:21:54 / 修改时间：20:26:15" itemprop="dateCreated datePublished" datetime="2023-08-16T19:21:54+08:00">2023-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="muduo库如何支持多线程"><a href="#muduo库如何支持多线程" class="headerlink" title="muduo库如何支持多线程"></a>muduo库如何支持多线程</h1><ul>
<li>EventLoopThread (IO线程类)</li>
<li>EventLoopThreadPool(IO线程池类)<ul>
<li>IO线程池的功能是开启若干个IO线程，并让这些IO线程处于事件循环的状态</li>
</ul>
</li>
</ul>
<p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%885%EF%BC%89/image-20230816193049699.png" alt="image-20230816193049699"></p>
<img src="/2023/08/16/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%885%EF%BC%89/image-20230816193049699.png" class title="This is an test image">

<h2 id="TcpServer-cc关于EventLoopThreadPool部分"><a href="#TcpServer-cc关于EventLoopThreadPool部分" class="headerlink" title="TcpServer.cc关于EventLoopThreadPool部分"></a>TcpServer.cc关于EventLoopThreadPool部分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">std::shared_ptr&lt;EventLoopThreadPool&gt; threadPool_;</span><br><span class="line">void setThreadInitCallback(const ThreadInitCallback&amp; cb)</span><br><span class="line">  &#123; threadInitCallback_ = cb; &#125;</span><br><span class="line">构造函数</span><br><span class="line">threadPool_(new EventLoopThreadPool(loop, name_))</span><br><span class="line"></span><br><span class="line">void TcpServer::setThreadNum(int numThreads)</span><br><span class="line">&#123;</span><br><span class="line">  assert(0 &lt;= numThreads);</span><br><span class="line">  threadPool_-&gt;setThreadNum(numThreads);//不包含主线程</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpServer::start()</span><br><span class="line">&#123;</span><br><span class="line">  if (started_.getAndSet(1) == 0)</span><br><span class="line">  &#123;</span><br><span class="line">    threadPool_-&gt;start(threadInitCallback_);//启动线程池</span><br><span class="line"></span><br><span class="line">    assert(!acceptor_-&gt;listening());</span><br><span class="line">    //get_pointer返回原生指针</span><br><span class="line">    loop_-&gt;runInLoop(</span><br><span class="line">        std::bind(&amp;Acceptor::listen, get_pointer(acceptor_)));//ptr.get();裸指针是为了将对象指针传递给 std::bind，从而在可调用对象中使用</span><br><span class="line">  &#125;//acceptor_.get() 是 std::unique_ptr 类提供的成员函数 get() 的调用，它用于获取被智能指针管理的对象的原始裸指针</span><br><span class="line">  //智能指针不能直接传递对象，是因为智能指针对对象进行了所有权管理</span><br><span class="line">&#125;</span><br><span class="line">void TcpServer::newConnection(int sockfd, const InetAddress&amp; peerAddr)&#123;</span><br><span class="line"> //按照轮叫的方式选择一个EventLoop</span><br><span class="line">  EventLoop* ioLoop = threadPool_-&gt;getNextLoop();</span><br><span class="line">  TcpConnectionPtr conn(new TcpConnection(ioLoop,</span><br><span class="line">                                          connName,</span><br><span class="line">                                          sockfd,</span><br><span class="line">                                          localAddr,</span><br><span class="line">                                          peerAddr));</span><br><span class="line"> ioLoop-&gt;runInLoop(std::bind(&amp;TcpConnection::connectEstablished, conn));//再ioLoop所属线程调用connectEstablished</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>EventLoopThreadPool::start</code> 方法中，线程池会根据指定的线程数量创建并启动多个 <code>EventLoopThread</code> 线程，然后每个线程会创建一个 <code>EventLoop</code> 实例。通过调用 <code>threadInitCallback_</code> 回调函数，你可以在每个线程开始事件循环之前执行一些初始化操作，以确保线程处于正确的状态。</p>
<p>因此，<code>threadPool_-&gt;start(threadInitCallback_)</code> 是用于启动整个线程池，其中每个线程会拥有自己的事件循环，并在事件循环开始之前调用 <code>threadInitCallback_</code> 进行初始化。这样就为每个线程提供了一个适当的上下文，以便它们可以正常地处理连接和事件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/15/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%884%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/15/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%884%EF%BC%89/" class="post-title-link" itemprop="url">muduo-网络库（4）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-15 11:25:01" itemprop="dateCreated datePublished" datetime="2023-08-15T11:25:01+08:00">2023-08-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-16 16:31:41" itemprop="dateModified" datetime="2023-08-16T16:31:41+08:00">2023-08-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="TcpServer-x2F-TcpConnection"><a href="#TcpServer-x2F-TcpConnection" class="headerlink" title="TcpServer&#x2F;TcpConnection"></a>TcpServer&#x2F;TcpConnection</h1><ul>
<li>Acceptor类的主要功能是socket、bind、listen</li>
<li>一般来说，在上层应用程序中，我们不直接使用Acceptor，而是把它作为TcpServer的成员</li>
<li>TcpServer还包含了一个TcpConnection列表</li>
<li>TcpConnection与Acceptor类似，有两个重要的数据成员，Socket与Channel,Channel关注Socket的可读可写事件</li>
</ul>
<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%884%EF%BC%89/image-20230815112907646.png" alt="image-20230815112907646"></p>
<img src="/2023/08/15/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%884%EF%BC%89/image-20230815112907646.png" class title="This is an test image">

<h2 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h2><p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%884%EF%BC%89/image-20230815155937436.png" alt="image-20230815155937436"></p>
<img src="/2023/08/15/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%884%EF%BC%89/image-20230815155937436.png" class title="This is an test image">

<p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%884%EF%BC%89/image-20230815155828886.png" alt="image-20230815155828886"></p>
<img src="/2023/08/15/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%884%EF%BC%89/image-20230815155828886.png" class title="This is an test image">

<p>在TcpServer.cc中，TcpServer类通过监听指定的IP地址和端口号，接受客户端的连接，并管理多个TcpConnection对象。下面是对TcpServer类对连接客户端的一步步操作的总结：</p>
<ol>
<li><p>在构造函数中创建一个Acceptor对象，并设置新连接回调函数<code>newConnectionCallback</code>。Acceptor负责监听并接受新的客户端连接。</p>
</li>
<li><p>在<code>start()</code>函数中启动服务器，包括启动EventLoop线程池、绑定地址、开始监听等操作。</p>
</li>
<li><p>当Acceptor接受到新的客户端连接时，在<code>TcpServer</code>类中的私有成员函数<code>newConnection()</code>被回调。在<code>newConnection()</code>函数中，会创建一个新的TcpConnection对象，并将其添加到连接管理字典<code>connections_</code>中。</p>
</li>
<li><p>在创建TcpConnection对象时，会设置相应的回调函数，包括连接建立回调函数、消息到达回调函数、写操作完成回调函数以及连接关闭回调函数。</p>
</li>
<li><p>创建TcpConnection后，通过调用<code>connectEstablished()</code>函数通知TcpConnection所属的EventLoop连接已经建立完毕，并触发用户设置的连接建立回调函数。（<code>connectEstablished()</code>函数会在TcpConnection对象所属的EventLoop线程中被回调，具体发生的时机是在新的客户端连接建立完成后。</p>
<p>当TcpServer监听到新的连接请求并接受连接时，会在<code>TcpServer::newConnection()</code>函数中创建一个新的TcpConnection对象，并通过<code>ioLoop-&gt;runInLoop()</code>将<code>TcpConnection::connectEstablished()</code>函数添加到所属的EventLoop线程的任务队列中。</p>
<p>随后，在EventLoop线程的下一个事件循环周期中，会从任务队列中取出<code>TcpConnection::connectEstablished()</code>函数并执行。这时，会触发用户设置的连接建立回调函数，并通知用户连接已经建立完毕。</p>
<p>因此，<code>connectEstablished()</code>函数的回调时机是在新的客户端连接建立完成后，即连接建立时机已经稳定，可以进行后续数据收发操作。）</p>
</li>
<li><p>在TcpConnection中，会监听连接的读事件，当有数据到达时，会调用用户设置的消息到达回调函数。</p>
</li>
<li><p>用户可以通过TcpConnection对象发送消息给客户端，TcpConnection内部会处理发送缓冲区，并通过调用底层的Socket API发送数据。</p>
</li>
<li><p>当连接关闭时，会触发连接关闭回调函数，并将TcpConnection从连接管理字典<code>connections_</code>中移除。</p>
</li>
</ol>
<p>这样，TcpServer实现了对连接客户端的一步步操作，包括接受连接、创建TcpConnection对象、监听事件、处理数据收发等过程。</p>
<p>以下是一个简单的例子来说明TcpServer的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;TcpServer.h&quot;</span><br><span class="line"></span><br><span class="line">void onConnection(const TcpConnectionPtr&amp; conn) &#123;</span><br><span class="line">    if (conn-&gt;connected()) &#123;</span><br><span class="line">        printf(&quot;New connection from %s\n&quot;, conn-&gt;peerAddress().toIpPort().c_str());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        printf(&quot;Connection %s is closed\n&quot;, conn-&gt;peerAddress().toIpPort().c_str());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void onMessage(const TcpConnectionPtr&amp; conn, Buffer* buffer) &#123;</span><br><span class="line">    std::string message = buffer-&gt;retrieveAllAsString();</span><br><span class="line">    printf(&quot;Received message from %s: %s\n&quot;, conn-&gt;peerAddress().toIpPort().c_str(), message.c_str());</span><br><span class="line">    conn-&gt;send(message); // Echo back the received message to the client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    EventLoop loop;</span><br><span class="line">    TcpServer server(&amp;loop, InetAddress(1234), &quot;TestServer&quot;);</span><br><span class="line">    server.setConnectionCallback(onConnection);</span><br><span class="line">    server.setMessageCallback(onMessage);</span><br><span class="line"></span><br><span class="line">    server.start();</span><br><span class="line"></span><br><span class="line">    loop.loop();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们首先创建一个EventLoop对象和一个TcpServer对象。然后，我们设置了连接建立回调函数<code>onConnection</code>和消息到达回调函数<code>onMessage</code>。最后，我们启动服务器并运行事件循环。</p>
<p>当有新的客户端连接时，会调用<code>onConnection</code>函数进行处理，输出连接建立信息。当有消息到达时，会调用<code>onMessage</code>函数进行处理，输出接收到的消息，并将该消息回传给客户端。</p>
<h2 id="TcpServer-h"><a href="#TcpServer-h" class="headerlink" title="TcpServer.h"></a>TcpServer.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">class TcpServer : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  typedef std::function&lt;void(EventLoop*)&gt; ThreadInitCallback;</span><br><span class="line">  enum Option</span><br><span class="line">  &#123;</span><br><span class="line">    kNoReusePort,</span><br><span class="line">    kReusePort,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  //TcpServer(EventLoop* loop, const InetAddress&amp; listenAddr);</span><br><span class="line">  TcpServer(EventLoop* loop,</span><br><span class="line">            const InetAddress&amp; listenAddr,</span><br><span class="line">            const string&amp; nameArg,</span><br><span class="line">            Option option = kNoReusePort);</span><br><span class="line">  ~TcpServer();  // force out-line dtor, for std::unique_ptr members.</span><br><span class="line"></span><br><span class="line">  const string&amp; ipPort() const &#123; return ipPort_; &#125;</span><br><span class="line">  const string&amp; name() const &#123; return name_; &#125;</span><br><span class="line">  EventLoop* getLoop() const &#123; return loop_; &#125;</span><br><span class="line"></span><br><span class="line">  void setThreadNum(int numThreads);</span><br><span class="line">  void setThreadInitCallback(const ThreadInitCallback&amp; cb)</span><br><span class="line">  &#123; threadInitCallback_ = cb; &#125;</span><br><span class="line">  /// valid after calling start()</span><br><span class="line">  std::shared_ptr&lt;EventLoopThreadPool&gt; threadPool()</span><br><span class="line">  &#123; return threadPool_; &#125;</span><br><span class="line"></span><br><span class="line">  /// Starts the server if it&#x27;s not listening.</span><br><span class="line">  ///</span><br><span class="line">  /// It&#x27;s harmless to call it multiple times.</span><br><span class="line">  /// Thread safe.</span><br><span class="line">  void start();</span><br><span class="line"></span><br><span class="line">  /// Set connection callback.</span><br><span class="line">  /// Not thread safe.</span><br><span class="line">  //设置连接到来或者连接关闭回调函数</span><br><span class="line">  void setConnectionCallback(const ConnectionCallback&amp; cb)</span><br><span class="line">  &#123; connectionCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line">  /// Set message callback.</span><br><span class="line">  /// Not thread safe.</span><br><span class="line">  //设置消息到来回调函数</span><br><span class="line">  void setMessageCallback(const MessageCallback&amp; cb)</span><br><span class="line">  &#123; messageCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line">  /// Set write complete callback.</span><br><span class="line">  /// Not thread safe.</span><br><span class="line">  void setWriteCompleteCallback(const WriteCompleteCallback&amp; cb)</span><br><span class="line">  &#123; writeCompleteCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  /// Not thread safe, but in loop</span><br><span class="line">  void newConnection(int sockfd, const InetAddress&amp; peerAddr);</span><br><span class="line">  /// Thread safe.</span><br><span class="line">  void removeConnection(const TcpConnectionPtr&amp; conn);</span><br><span class="line">  /// Not thread safe, but in loop</span><br><span class="line">  void removeConnectionInLoop(const TcpConnectionPtr&amp; conn);</span><br><span class="line"></span><br><span class="line">  typedef std::map&lt;string, TcpConnectionPtr&gt; ConnectionMap;//typedef std::shared_ptr&lt;TcpConnection&gt; TcpConnectionPtr;</span><br><span class="line"></span><br><span class="line">  EventLoop* loop_;  // the acceptor loop</span><br><span class="line">  const string ipPort_;//服务端口</span><br><span class="line">  const string name_;//服务名</span><br><span class="line">  std::unique_ptr&lt;Acceptor&gt; acceptor_; // avoid revealing Acceptor</span><br><span class="line">  std::shared_ptr&lt;EventLoopThreadPool&gt; threadPool_;</span><br><span class="line">  ConnectionCallback connectionCallback_;</span><br><span class="line">  MessageCallback messageCallback_;</span><br><span class="line">  WriteCompleteCallback writeCompleteCallback_;</span><br><span class="line">  ThreadInitCallback threadInitCallback_;</span><br><span class="line">  AtomicInt32 started_;</span><br><span class="line">  </span><br><span class="line">  ConnectionMap connections_;//连接列表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="TcpServer-cc"><a href="#TcpServer-cc" class="headerlink" title="TcpServer.cc"></a>TcpServer.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/net/TcpServer.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line">#include &quot;muduo/net/Acceptor.h&quot;</span><br><span class="line">#include &quot;muduo/net/EventLoop.h&quot;</span><br><span class="line">#include &quot;muduo/net/EventLoopThreadPool.h&quot;</span><br><span class="line">#include &quot;muduo/net/SocketsOps.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;  // snprintf</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">TcpServer::TcpServer(EventLoop* loop,</span><br><span class="line">                     const InetAddress&amp; listenAddr,</span><br><span class="line">                     const string&amp; nameArg,</span><br><span class="line">                     Option option)</span><br><span class="line">  : loop_(CHECK_NOTNULL(loop)),//是Logging.h定义的CHECK_NOTNULL</span><br><span class="line">    ipPort_(listenAddr.toIpPort()),</span><br><span class="line">    name_(nameArg),</span><br><span class="line">    acceptor_(new Acceptor(loop, listenAddr, option == kReusePort)),</span><br><span class="line">    threadPool_(new EventLoopThreadPool(loop, name_)),</span><br><span class="line">    connectionCallback_(defaultConnectionCallback),</span><br><span class="line">    messageCallback_(defaultMessageCallback),</span><br><span class="line">    nextConnId_(1)</span><br><span class="line">&#123;</span><br><span class="line">  //Acceptor: :handleRead函数中会回调用TcpSeruer::newConnection</span><br><span class="line">  //_1对应的是socket文件描述符，2对应的是对等方的地址( InetAddress)</span><br><span class="line">  acceptor_-&gt;setNewConnectionCallback(</span><br><span class="line">      std::bind(&amp;TcpServer::newConnection, this, _1, _2));</span><br><span class="line">&#125;</span><br><span class="line">//该函数多次调用是无害的</span><br><span class="line">//该函数可改跨线程调用</span><br><span class="line">void TcpServer::start()</span><br><span class="line">&#123;</span><br><span class="line">  if (started_.getAndSet(1) == 0)</span><br><span class="line">  &#123;</span><br><span class="line">    threadPool_-&gt;start(threadInitCallback_);</span><br><span class="line"></span><br><span class="line">    assert(!acceptor_-&gt;listening());</span><br><span class="line">    //get_pointer返回原生指针</span><br><span class="line">    loop_-&gt;runInLoop(</span><br><span class="line">        std::bind(&amp;Acceptor::listen, get_pointer(acceptor_)));//ptr.get();裸指针是为了将对象指针传递给 std::bind，从而在可调用对象中使用</span><br><span class="line">  &#125;//acceptor_.get() 是 std::unique_ptr 类提供的成员函数 get() 的调用，它用于获取被智能指针管理的对象的原始裸指针</span><br><span class="line">  //智能指针不能直接传递对象，是因为智能指针对对象进行了所有权管理</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpServer::newConnection(int sockfd, const InetAddress&amp; peerAddr)</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  EventLoop* ioLoop = threadPool_-&gt;getNextLoop();</span><br><span class="line">  char buf[64];</span><br><span class="line">  snprintf(buf, sizeof buf, &quot;-%s#%d&quot;, ipPort_.c_str(), nextConnId_);</span><br><span class="line">  ++nextConnId_;</span><br><span class="line">  string connName = name_ + buf;</span><br><span class="line"></span><br><span class="line">  LOG_INFO &lt;&lt; &quot;TcpServer::newConnection [&quot; &lt;&lt; name_</span><br><span class="line">           &lt;&lt; &quot;] - new connection [&quot; &lt;&lt; connName</span><br><span class="line">           &lt;&lt; &quot;] from &quot; &lt;&lt; peerAddr.toIpPort();</span><br><span class="line">  InetAddress localAddr(sockets::getLocalAddr(sockfd));</span><br><span class="line">  // FIXME poll with zero timeout to double confirm the new connection</span><br><span class="line">  // FIXME use make_shared if necessary</span><br><span class="line">  TcpConnectionPtr conn(new TcpConnection(ioLoop,</span><br><span class="line">                                          connName,</span><br><span class="line">                                          sockfd,</span><br><span class="line">                                          localAddr,</span><br><span class="line">                                          peerAddr));</span><br><span class="line">  connections_[connName] = conn;</span><br><span class="line">  conn-&gt;setConnectionCallback(connectionCallback_);</span><br><span class="line">  conn-&gt;setMessageCallback(messageCallback_);</span><br><span class="line">  conn-&gt;setWriteCompleteCallback(writeCompleteCallback_);</span><br><span class="line">  conn-&gt;setCloseCallback(</span><br><span class="line">      std::bind(&amp;TcpServer::removeConnection, this, _1)); // FIXME: unsafe</span><br><span class="line">  ioLoop-&gt;runInLoop(std::bind(&amp;TcpConnection::connectEstablished, conn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当服务器监听到新的客户端连接请求时，Acceptor类会调用<code>handleRead</code>函数，在<code>handleRead</code>函数中会回调<code>TcpServer</code>类的<code>newConnection</code>函数来处理新的连接。</p>
<p>无论是第一个连接还是后续的连接，都会通过调用<code>newConnection</code>函数来创建相应的TcpConnection对象，并进行必要的初始化和设置。</p>
<h2 id="TcpConnection-h"><a href="#TcpConnection-h" class="headerlink" title="TcpConnection.h"></a>TcpConnection.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void setConnectionCallback(const ConnectionCallback&amp; cb)</span><br><span class="line">  &#123; connectionCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line">  void setMessageCallback(const MessageCallback&amp; cb)</span><br><span class="line">  &#123; messageCallback_ = cb; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="TcpConnection-cc"><a href="#TcpConnection-cc" class="headerlink" title="TcpConnection.cc"></a>TcpConnection.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">TcpConnection::TcpConnection(EventLoop* loop,</span><br><span class="line">                             const string&amp; nameArg,</span><br><span class="line">                             int sockfd,</span><br><span class="line">                             const InetAddress&amp; localAddr,</span><br><span class="line">                             const InetAddress&amp; peerAddr)</span><br><span class="line">  : loop_(CHECK_NOTNULL(loop)),</span><br><span class="line">    name_(nameArg),</span><br><span class="line">    state_(kConnecting),</span><br><span class="line">    reading_(true),</span><br><span class="line">    socket_(new Socket(sockfd)),</span><br><span class="line">    channel_(new Channel(loop, sockfd)),</span><br><span class="line">    localAddr_(localAddr),</span><br><span class="line">    peerAddr_(peerAddr),</span><br><span class="line">    highWaterMark_(64*1024*1024)</span><br><span class="line">&#123;</span><br><span class="line">  //通道可读事件到来的时候，回调TcpConnection::handleRead，_1是事件发生时间</span><br><span class="line">  channel_-&gt;setReadCallback(</span><br><span class="line">      std::bind(&amp;TcpConnection::handleRead, this, _1));</span><br><span class="line">  channel_-&gt;setWriteCallback(</span><br><span class="line">      std::bind(&amp;TcpConnection::handleWrite, this));</span><br><span class="line">  channel_-&gt;setCloseCallback(</span><br><span class="line">      std::bind(&amp;TcpConnection::handleClose, this));</span><br><span class="line">  channel_-&gt;setErrorCallback(</span><br><span class="line">      std::bind(&amp;TcpConnection::handleError, this));</span><br><span class="line">  LOG_DEBUG &lt;&lt; &quot;TcpConnection::ctor[&quot; &lt;&lt;  name_ &lt;&lt; &quot;] at &quot; &lt;&lt; this</span><br><span class="line">            &lt;&lt; &quot; fd=&quot; &lt;&lt; sockfd;</span><br><span class="line">  socket_-&gt;setKeepAlive(true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpConnection::connectEstablished()</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  assert(state_ == kConnecting);</span><br><span class="line">  setState(kConnected);</span><br><span class="line">  channel_-&gt;tie(shared_from_this());</span><br><span class="line">  channel_-&gt;enableReading();//Tcpconnection所对应的通道加入到Poller关注</span><br><span class="line"></span><br><span class="line">  connectionCallback_(shared_from_this());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpConnection::handleRead(Timestamp receiveTime)</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  int savedErrno = 0;</span><br><span class="line">  ssize_t n = inputBuffer_.readFd(channel_-&gt;fd(), &amp;savedErrno);</span><br><span class="line">  if (n &gt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    messageCallback_(shared_from_this(), &amp;inputBuffer_, receiveTime);//shared_from_this()将当前对象转换成shared_ptr，而不是裸指针</span><br><span class="line">  &#125;</span><br><span class="line">  else if (n == 0)</span><br><span class="line">  &#123;</span><br><span class="line">    handleClose();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    errno = savedErrno;</span><br><span class="line">    LOG_SYSERR &lt;&lt; &quot;TcpConnection::handleRead&quot;;</span><br><span class="line">    handleError();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TcpConnection::connectEstablished()</code>函数是TcpConnection类的成员函数，用于在连接成功建立后进行相应的处理。</p>
<p>首先，使用<code>loop_-&gt;assertInLoopThread()</code>断言当前函数被调用的线程是所属的EventLoop线程，以确保函数只能在正确的线程中被调用。</p>
<p>然后，通过<code>assert(state_ == kConnecting)</code>断言当前连接状态<code>state_</code>为正在连接状态，以确保该函数只能在连接状态为正在连接时被调用。</p>
<p>接下来，通过调用<code>setState(kConnected)</code>将连接状态更新为已连接状态。</p>
<p>然后，将TcpConnection所对应的通道<code>channel_</code>与TcpConnection对象自身进行绑定，即调用<code>channel_-&gt;tie(shared_from_this())</code>。这个操作是为了在通道回调函数中可以安全地使用TcpConnection对象。</p>
<p>接着，调用<code>channel_-&gt;enableReading()</code>，将TcpConnection所对应的通道加入到Poller中进行读事件的监听。</p>
<p>最后，调用<code>connectionCallback_(shared_from_this())</code>，即用户设置的连接回调函数，通知用户连接已经建立成功，并将TcpConnection对象作为参数传递给回调函数。</p>
<p>总之，<code>connectEstablished</code>函数在连接成功建立后，会进行一系列的操作，包括更新连接状态、关联通道并进行事件监听，并触发连接回调函数以通知用户连接建立成功。</p>
<h2 id="TcpConnection生存期管理"><a href="#TcpConnection生存期管理" class="headerlink" title="TcpConnection生存期管理"></a>TcpConnection生存期管理</h2><p>当连接到来，创建一个TcpConnection对象，立刻用shared_ptr来管理，引用计数为1<br>在Channel中维护一个<code>weak_ptr(tie_)</code>，将这个<code>shared_ptr</code>对象赋值给<code>tie_</code>引用计数仍为1</p>
<p>当连接关闭，在handleEvent，将<code>tie_</code>提升，得到一个<code>shared_ptr</code>对象，引用计数就变成了2</p>
<p><code>shared_ptr</code> 是 C++ 标准库中的一个智能指针（Smart Pointer）类模板，用于管理动态分配的对象的生命周期。它允许多个 <code>shared_ptr</code> 实例共享同一个堆上的对象，当没有引用指向对象时，对象会自动被销毁，从而避免了内存泄漏。</p>
<p><code>shared_ptr</code> 提供了一种自动引用计数机制，它会跟踪有多少个 <code>shared_ptr</code> 实例指向相同的对象。每当创建一个新的 <code>shared_ptr</code> 指向对象，引用计数会增加；当 <code>shared_ptr</code> 被销毁或重置时，引用计数会减少。当引用计数减少到零时，表示没有 <code>shared_ptr</code> 实例再指向该对象，对象将会被自动删除。</p>
<p>以下是 <code>shared_ptr</code> 的一些重要特性和用法：</p>
<ol>
<li><strong>共享所有权：</strong> 多个 <code>shared_ptr</code> 实例可以共享相同的对象所有权，从而避免了手动管理内存释放。</li>
<li><strong>循环引用问题：</strong> 尽管 <code>shared_ptr</code> 可以有效地管理内存，但如果存在循环引用（两个或多个对象相互引用），可能会导致内存泄漏。为了解决这个问题，可以使用 <code>weak_ptr</code> 来解除循环引用。</li>
<li><strong>自定义删除器：</strong> 可以使用自定义的删除器函数或函数对象来控制对象的销毁过程。</li>
<li><strong>线程安全：</strong> <code>shared_ptr</code> 本身不提供线程安全的保证。多个线程同时修改引用计数可能导致竞态条件。在多线程环境中，需要额外的同步机制来确保安全使用。</li>
<li><strong>使用方便：</strong> <code>shared_ptr</code> 的使用方式类似于常规指针，可以通过 <code>-&gt;</code> 和 <code>*</code> 运算符访问对象的成员。</li>
</ol>
<h3 id="连接关闭时序图"><a href="#连接关闭时序图" class="headerlink" title="连接关闭时序图"></a>连接关闭时序图</h3><p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%884%EF%BC%89/image-20230816112443369.png" alt="image-20230816112443369"></p>
<img src="/2023/08/15/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%884%EF%BC%89/image-20230816112443369.png" class title="This is an test image">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> &#123; /// Internal use only.</span><br><span class="line">  void setCloseCallback(const CloseCallback&amp; cb)</span><br><span class="line">  &#123; closeCallback_ = cb; &#125;</span><br><span class="line">private:</span><br><span class="line">  void connectDestroyed();  // should be called only once</span><br><span class="line">  CloseCallback closeCallback_;//用户内部的连接关闭回调函数</span><br><span class="line">  void handleError();</span><br><span class="line">  void handleClose();</span><br><span class="line"> &#125;; </span><br><span class="line">  typedef std::shared_ptr&lt;TcpConnection&gt; TcpConnectionPtr;</span><br><span class="line">  </span><br><span class="line">  构造函数：</span><br><span class="line">  channel_-&gt;setCloseCallback(</span><br><span class="line">      std::bind(&amp;TcpConnection::handleClose, this));</span><br><span class="line">  channel_-&gt;setErrorCallback(</span><br><span class="line">      std::bind(&amp;TcpConnection::handleError, this));</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">void TcpConnection::handleRead(Timestamp receiveTime)</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  int savedErrno = 0;</span><br><span class="line">  ssize_t n = inputBuffer_.readFd(channel_-&gt;fd(), &amp;savedErrno);</span><br><span class="line">  if (n &gt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    messageCallback_(shared_from_this(), &amp;inputBuffer_, receiveTime);//shared_from_this()将当前对象转换成shared_ptr，而不是裸指针</span><br><span class="line">  &#125;</span><br><span class="line">  else if (n == 0)</span><br><span class="line">  &#123;</span><br><span class="line">    handleClose();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    errno = savedErrno;</span><br><span class="line">    LOG_SYSERR &lt;&lt; &quot;TcpConnection::handleRead&quot;;</span><br><span class="line">    handleError();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpConnection::handleClose()</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  LOG_TRACE &lt;&lt; &quot;fd = &quot; &lt;&lt; channel_-&gt;fd() &lt;&lt; &quot; state = &quot; &lt;&lt; stateToString();</span><br><span class="line">  assert(state_ == kConnected || state_ == kDisconnecting);</span><br><span class="line">  // we don&#x27;t close fd, leave it to dtor, so we can find leaks easily.</span><br><span class="line">  setState(kDisconnected);</span><br><span class="line">  channel_-&gt;disableAll();</span><br><span class="line"></span><br><span class="line">  TcpConnectionPtr guardThis(shared_from_this());</span><br><span class="line">  connectionCallback_(guardThis);//这一行可以不调用</span><br><span class="line">  // must be the last line</span><br><span class="line">  closeCallback_(guardThis);//调用TcpServer::removeConnection</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TcpConnection::handleError()</span><br><span class="line">&#123;</span><br><span class="line">  int err = sockets::getSocketError(channel_-&gt;fd());</span><br><span class="line">  LOG_ERROR &lt;&lt; &quot;TcpConnection::handleError [&quot; &lt;&lt; name_</span><br><span class="line">            &lt;&lt; &quot;] - SO_ERROR = &quot; &lt;&lt; err &lt;&lt; &quot; &quot; &lt;&lt; strerror_tl(err);</span><br><span class="line">&#125;</span><br><span class="line">void TcpConnection::connectEstablished()</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  assert(state_ == kConnecting);</span><br><span class="line">  setState(kConnected);</span><br><span class="line">  channel_-&gt;tie(shared_from_this());//void tie(const std::shared_ptr&lt;void&gt;&amp;);</span><br><span class="line">  //但是tie_不会更改计数，还是shared_from_this()加一后的，因为它是弱引用，但是shared_from_this()是临死对象，加1后会减1</span><br><span class="line">  //shared_from_this()继承自std::enable_shared_from_this&lt;TcpConnection&gt;，返回一个shared_ptr类型的TcpConnection对象</span><br><span class="line">  channel_-&gt;enableReading();//Tcpconnection所对应的通道加入到Poller关注</span><br><span class="line"></span><br><span class="line">  connectionCallback_(shared_from_this());</span><br><span class="line">&#125;</span><br><span class="line">void TcpServer::removeConnectionInLoop(const TcpConnectionPtr&amp; conn)</span><br><span class="line">// &#123;</span><br><span class="line">//   loop_-&gt;assertInLoopThread();</span><br><span class="line">//   LOG_INFO &lt;&lt; &quot;TcpServer::removeConnectionInLoop [&quot; &lt;&lt; name_</span><br><span class="line">//            &lt;&lt; &quot;] - connection &quot; &lt;&lt; conn-&gt;name();</span><br><span class="line">//   size_t n = connections_.erase(conn-&gt;name());//引用计数减一,从容器中删除相应的键值对</span><br><span class="line">//   (void)n;</span><br><span class="line">//   assert(n == 1);</span><br><span class="line">//   EventLoop* ioLoop = conn-&gt;getLoop();</span><br><span class="line">//   ioLoop-&gt;queueInLoop(//handEvent事件处理完毕后处理functors</span><br><span class="line">//       std::bind(&amp;TcpConnection::connectDestroyed, conn));//引用计数加一</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">void TcpConnection::connectDestroyed()</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  if (state_ == kConnected)//如果handleClose中已调用回调函数，这里就不会再调用</span><br><span class="line">  &#123;</span><br><span class="line">    setState(kDisconnected);</span><br><span class="line">    channel_-&gt;disableAll();</span><br><span class="line"></span><br><span class="line">    connectionCallback_(shared_from_this());//shared_from_this()将当前对象转换成shared_ptr获取，会使shared_ptr引用计数加1，但是是临时对象，马上会销毁</span><br><span class="line">  &#125;</span><br><span class="line">  channel_-&gt;remove();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Channel::handleEvent(Timestamp receiveTime)</span><br><span class="line">&#123;</span><br><span class="line">  std::shared_ptr&lt;void&gt; guard;</span><br><span class="line">  if (tied_)</span><br><span class="line">  &#123;</span><br><span class="line">    guard = tie_.lock();//如果 lock 成功，即 guard 不为空，那么表示资源仍然有效，可以安全地执行 handleEventWithGuard 函数</span><br><span class="line">    if (guard)</span><br><span class="line">    &#123;</span><br><span class="line">      handleEventWithGuard(receiveTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else//如果 lock 失败，即 guard 为空，那么表示被 std::weak_ptr 管理的资源已经失效，不再存在</span><br><span class="line">  &#123;</span><br><span class="line">    handleEventWithGuard(receiveTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tie_.lock()</code> 是 <code>std::weak_ptr</code> 的一个方法，用于创建一个有效的 <code>std::shared_ptr</code>，以便在某个范围内使用这个资源。如果资源仍然有效，<code>lock()</code> 方法将返回一个非空的 <code>std::shared_ptr</code>；如果资源已经失效，它将返回一个空的 <code>std::shared_ptr</code>。</p>
<p>因此，<code>tie_.lock()</code> 方法不是针对 <code>std::shared_ptr</code> 或 <code>std::weak_ptr</code> 类的全局方法，而是 <code>std::weak_ptr</code> 的成员方法，用于操作 <code>std::weak_ptr</code> 对象以检查被观察的资源是否仍然存在。</p>
<p><code>std::shared_ptr</code> 和 <code>std::weak_ptr</code> 是 C++ 标准库中两种用于管理动态分配的对象的智能指针类型。它们之间有关联，主要用于解决循环引用问题以及确保动态分配对象的正确管理。</p>
<p>下面是它们之间的关系：</p>
<ol>
<li><strong>std::shared_ptr</strong>：是一种强引用智能指针，它允许多个 <code>shared_ptr</code> 共享同一个对象，并且通过引用计数来追踪对象的生命周期。当最后一个 <code>shared_ptr</code> 对象释放其引用时，引用计数会降为零，从而释放对象并释放其分配的内存。<code>std::shared_ptr</code> 本身会增加对象的引用计数。</li>
<li><strong>std::weak_ptr</strong>：是一种弱引用智能指针，它不会增加对象的引用计数。它允许观察由 <code>shared_ptr</code> 管理的对象，但不会影响对象的生命周期。最常见的用途是避免循环引用问题，其中两个对象彼此持有对方的 <code>shared_ptr</code>，导致对象无法被正确释放。通过使用 <code>std::weak_ptr</code>，可以解决循环引用问题，因为它不会增加引用计数，但仍然可以用于检查对象是否仍然存在。</li>
</ol>
<p>总结来说，<code>std::shared_ptr</code> 允许多个智能指针共享所有权，并且通过引用计数来管理对象的生命周期。<code>std::weak_ptr</code> 允许观察 <code>std::shared_ptr</code> 管理的对象，但不会影响其生命周期。这两种智能指针在一起使用，可以有效地解决资源管理和循环引用问题。</p>
<p>如果 <code>p</code> 是一个 <code>std::shared_ptr</code> 对象，那么 <code>p.get()</code> 的含义是获取 <code>std::shared_ptr</code> 对象所管理的原始指针</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/13/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%883%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/13/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%883%EF%BC%89/" class="post-title-link" itemprop="url">muduo-网络库（3）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-13 15:37:10" itemprop="dateCreated datePublished" datetime="2023-08-13T15:37:10+08:00">2023-08-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-14 21:21:06" itemprop="dateModified" datetime="2023-08-14T21:21:06+08:00">2023-08-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="进程-线程-wait-x2F-notify"><a href="#进程-线程-wait-x2F-notify" class="headerlink" title="进程(线程)wait&#x2F;notify"></a>进程(线程)wait&#x2F;notify</h1><ul>
<li><p>pipe</p>
<ul>
<li>单向通信</li>
</ul>
</li>
<li><p>socketpair</p>
<ul>
<li>双向通信</li>
</ul>
</li>
<li><p>eventfd</p>
<ul>
<li>eventfd是一个比 pipe更高效的线程间事件通知机制，一方面它比 pipe少用一个file descripor,节省了资源;另一方面，eventfd的缓冲区管理也简单得多，全部“buffer”只有定长8 bytes，不像pipe那样可能有不定长的真正 buffer。</li>
</ul>
</li>
</ul>
<p>线程间还多一个条件变量，但是上面三个有文件描述符，可以用IO复用，即poll&#x2F;epoll&#x2F;select,条件变量不行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int wakeupFd_;//用于eventfd</span><br><span class="line">  // unlike in TimerQueue, which is an internal class,</span><br><span class="line">  // we don&#x27;t expose Channel to client.</span><br><span class="line"> std::unique_ptr&lt;Channel&gt; wakeupChannel_;//wakeupFd_通道的管理，将会纳入poller_管理,是一个智能指针</span><br><span class="line">  //这里EventLoop和Channel是组合关系，EventLoop销毁则channel也要销毁，也就是wakeupFd_销毁</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wakeupFd_(createEventfd()),</span><br><span class="line">    wakeupChannel_(new Channel(this, wakeupFd_)),</span><br><span class="line"></span><br><span class="line">int createEventfd()</span><br><span class="line">&#123;</span><br><span class="line">  int evtfd = ::eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC);</span><br><span class="line">  if (evtfd &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSERR &lt;&lt; &quot;Failed in eventfd&quot;;</span><br><span class="line">    abort();</span><br><span class="line">  &#125;</span><br><span class="line">  return evtfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="EventLoop-runInLoop"><a href="#EventLoop-runInLoop" class="headerlink" title="EventLoop::runInLoop"></a>EventLoop::runInLoop</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//在IO线程中执行某个回调函数，该函数可以跨线程调用，调用这个函数可以保证不用加锁</span><br><span class="line">void EventLoop::runInLoop(Functor cb)</span><br><span class="line">&#123;</span><br><span class="line">  if (isInLoopThread())</span><br><span class="line">  &#123;</span><br><span class="line">  	//如果是当前线程调用runInLoop，则同步调用cb</span><br><span class="line">    cb();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">  	//如果是其它线程调用，则异步地将cb添加到队列</span><br><span class="line">    queueInLoop(std::move(cb));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="EventLoop-queueInLoop"><a href="#EventLoop-queueInLoop" class="headerlink" title="EventLoop::queueInLoop"></a>EventLoop::queueInLoop</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void EventLoop::queueInLoop(Functor cb)</span><br><span class="line">&#123;</span><br><span class="line">  &#123;</span><br><span class="line">  MutexLockGuard lock(mutex_);</span><br><span class="line">  pendingFunctors_.push_back(std::move(cb));</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">//调用queuelnLoop的线程不是当前IO线程需要唤醒</span><br><span class="line">//或者调用queueInLoop的线程是当前IO线程，并且此时正在调用pending functor，需要唤醒</span><br><span class="line">//只有当前IO线程的事件回调中调用queuelnLoop才不需要唤醒</span><br><span class="line">  if (!isInLoopThread() || callingPendingFunctors_)</span><br><span class="line">  &#123;</span><br><span class="line">    wakeup();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="EventLoop-loop"><a href="#EventLoop-loop" class="headerlink" title="EventLoop::loop"></a>EventLoop::loop</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">while (!quit_)</span><br><span class="line">  &#123;</span><br><span class="line">    activeChannels_.clear();</span><br><span class="line">    pollReturnTime_ = poller_-&gt;poll(kPollTimeMs, &amp;activeChannels_);</span><br><span class="line">    ++iteration_;</span><br><span class="line">    if (Logger::logLevel() &lt;= Logger::TRACE)</span><br><span class="line">    &#123;</span><br><span class="line">      printActiveChannels();</span><br><span class="line">    &#125;</span><br><span class="line">    // TODO sort channel by priority</span><br><span class="line">    eventHandling_ = true;</span><br><span class="line">    for (Channel* channel : activeChannels_)</span><br><span class="line">    &#123;</span><br><span class="line">      currentActiveChannel_ = channel;</span><br><span class="line">      currentActiveChannel_-&gt;handleEvent(pollReturnTime_);</span><br><span class="line">    &#125;</span><br><span class="line">    currentActiveChannel_ = NULL;</span><br><span class="line">    eventHandling_ = false;</span><br><span class="line">    doPendingFunctors();//让IO线程也能执行一些计算任务，即IO不繁忙的时候添加计算任务让他来处理</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%883%EF%BC%89/image-20230813163113214.png" alt="image-20230813163113214"></p>
<img src="/2023/08/13/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%883%EF%BC%89/image-20230813163113214.png" class title="This is an test image">

<h2 id="EventLoop-doPendingFunctors"><a href="#EventLoop-doPendingFunctors" class="headerlink" title="EventLoop::doPendingFunctors"></a><strong>EventLoop</strong>::doPendingFunctors</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void EventLoop::doPendingFunctors()</span><br><span class="line">&#123;</span><br><span class="line">  std::vector&lt;Functor&gt; functors;</span><br><span class="line">  callingPendingFunctors_ = true;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">  MutexLockGuard lock(mutex_);//</span><br><span class="line">  functors.swap(pendingFunctors_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for (const Functor&amp; functor : functors)</span><br><span class="line">  &#123;</span><br><span class="line">    functor();</span><br><span class="line">  &#125;</span><br><span class="line">  callingPendingFunctors_ = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不是简单地在临界区内依次调用Functor，而是把回调列表swap到functors中，这样一方面减小了临界区的长度（意味着不会阻塞其它线程的queuelnLoop()），另一方面，也避免了死锁(因为Functor可能再次调用queuelnLoop())</li>
<li>由于doPendingFunctors()调用的Functor可能再次调用queuelnLoop(cb)，这时，queuelnLoop()就必须wakeup(),否则新增的cb可能就不能及时调用了</li>
<li>muduo没有反复执行doPendingFunctors()直到pendingFunctors为空，这是有意的，否则IO线程可能陷入死循环，无法处理IO事件。</li>
</ul>
<h1 id="EventLoopThread"><a href="#EventLoopThread" class="headerlink" title="EventLoopThread"></a>EventLoopThread</h1><ul>
<li>任何一个线程，只要创建并运行了EventLoop,都称之为IO线程</li>
<li>IO线程不一定是主线程</li>
<li>muduo并发模型one loop per thread + threadpool，(包括了IO线程池和计算线程池)</li>
<li>为了方便今后使用，定义了EventLoopThread类，该类封装了IO线程<ul>
<li>EventLoopThread创建了一个线程</li>
<li>在线程函数中创建了一个EvenLoop对象并调用EventLoop:loop</li>
</ul>
</li>
</ul>
<p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%883%EF%BC%89/image-20230813203826232.png" alt="image-20230813203826232"></p>
<img src="/2023/08/13/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%883%EF%BC%89/image-20230813203826232.png" class title="This is an test image">

<p>在startLoop时会 thread_.<strong>start</strong>()，进入线程回调函数并绑定 <code>loop_ = &amp;loop;</code>再 <code>return loop;</code>，也就是说loop的runInLoop,runAfter都是同一个线程。</p>
<h2 id="EventLoopThread-h"><a href="#EventLoopThread-h" class="headerlink" title="EventLoopThread.h"></a>EventLoopThread.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_NET_EVENTLOOPTHREAD_H</span><br><span class="line">#define MUDUO_NET_EVENTLOOPTHREAD_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Condition.h&quot;</span><br><span class="line">#include &quot;muduo/base/Mutex.h&quot;</span><br><span class="line">#include &quot;muduo/base/Thread.h&quot;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">class EventLoop;</span><br><span class="line"></span><br><span class="line">class EventLoopThread : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  typedef std::function&lt;void(EventLoop*)&gt; ThreadInitCallback;</span><br><span class="line"></span><br><span class="line">  EventLoopThread(const ThreadInitCallback&amp; cb = ThreadInitCallback(),</span><br><span class="line">                  const string&amp; name = string());</span><br><span class="line">  ~EventLoopThread();</span><br><span class="line">  EventLoop* startLoop();//启动线程，该线程就成为了IO线程</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  void threadFunc();//线程函数</span><br><span class="line"></span><br><span class="line">  EventLoop* loop_ GUARDED_BY(mutex_);//loop指针指向了eventloop对象</span><br><span class="line">  bool exiting_;</span><br><span class="line">  Thread thread_;//因为是基于对象编程思想，所以包含了一个thread类</span><br><span class="line">  MutexLock mutex_;</span><br><span class="line">  Condition cond_ GUARDED_BY(mutex_);</span><br><span class="line">  ThreadInitCallback callback_;//回调函数在EventLoop::loop事件循环之前被调用</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_NET_EVENTLOOPTHREAD_H</span><br></pre></td></tr></table></figure>

<h2 id="EventLoopThread-cc"><a href="#EventLoopThread-cc" class="headerlink" title="EventLoopThread.cc"></a>EventLoopThread.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/net/EventLoopThread.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/net/EventLoop.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">EventLoopThread::EventLoopThread(const ThreadInitCallback&amp; cb,</span><br><span class="line">                                 const string&amp; name)</span><br><span class="line">  : loop_(NULL),</span><br><span class="line">    exiting_(false),</span><br><span class="line">    thread_(std::bind(&amp;EventLoopThread::threadFunc, this), name),</span><br><span class="line">    mutex_(),</span><br><span class="line">    cond_(mutex_),</span><br><span class="line">    callback_(cb)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventLoopThread::~EventLoopThread()</span><br><span class="line">&#123;</span><br><span class="line">  exiting_ = true;</span><br><span class="line">  if (loop_ != NULL) // not 100% race-free, eg. threadFunc could be running callback_.</span><br><span class="line">  &#123;</span><br><span class="line">    // still a tiny chance to call destructed object, if threadFunc exits just now.</span><br><span class="line">    // but when EventLoopThread destructs, usually programming is exiting anyway.</span><br><span class="line">    loop_-&gt;quit();//退出IO线程，让IO线程的loop循环退出，从而退出了IO线程</span><br><span class="line">    thread_.join();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventLoop* EventLoopThread::startLoop()</span><br><span class="line">&#123;</span><br><span class="line">  assert(!thread_.started());//断言线程还未启动</span><br><span class="line">  thread_.start();//启动调用EventLoopThread::threadFunc</span><br><span class="line"></span><br><span class="line">  EventLoop* loop = NULL;</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    while (loop_ == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      cond_.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    loop = loop_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void EventLoopThread::threadFunc()</span><br><span class="line">&#123;</span><br><span class="line">  EventLoop loop;</span><br><span class="line"></span><br><span class="line">  if (callback_)//可以有选择的传递回调函数</span><br><span class="line">  &#123;</span><br><span class="line">    callback_(&amp;loop);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    //1oop_指针指向了一个栈上的对象，threadFunc函数退出之后，这个指针就失效了.</span><br><span class="line">    //threadFunc函教退出，就意味着线程退出了，EventLoopThread对象也就没有存在的价值了.</span><br><span class="line">    loop_ = &amp;loop;</span><br><span class="line">    cond_.notify();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  loop.loop();//退出了，也就相当于整个线程退出了</span><br><span class="line">  //assert(exiting_);</span><br><span class="line">  MutexLockGuard lock(mutex_);</span><br><span class="line">  loop_ = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Socket封装"><a href="#Socket封装" class="headerlink" title="Socket封装"></a>Socket封装</h1><h2 id="Endian-h"><a href="#Endian-h" class="headerlink" title="Endian.h"></a>Endian.h</h2><ul>
<li>封装了字节序转换函数（全局函数，位于muduo::net::sockets名称空间中）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_NET_ENDIAN_H</span><br><span class="line">#define MUDUO_NET_ENDIAN_H</span><br><span class="line"></span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;endian.h&gt;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line">namespace sockets</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">// the inline assembler code makes type blur,</span><br><span class="line">// so we disable warnings for a while.</span><br><span class="line">#pragma GCC diagnostic push//这个指令将当前的警告和错误状态入栈，保存起来，以便稍后可以使用 #pragma GCC diagnostic pop 恢复到先前的状态。在这个代码块中，它保存了当前的警告状态，以便可以在代码块结束后还原</span><br><span class="line">#pragma GCC diagnostic ignored &quot;-Wconversion&quot;//这个指令告诉编译器在接下来的代码块中忽略与隐式类型转换相关的警告（-Wconversion 警告）。这样，代码块内的类型转换不会触发编译器的警告信息</span><br><span class="line">#pragma GCC diagnostic ignored &quot;-Wold-style-cast&quot;//这个指令告诉编译器在接下来的代码块中忽略与旧式的C风格类型转换相关的警告。这种类型的转换在现代C++中被认为是不安全的，通过这个指令可以禁用与它相关的警告</span><br><span class="line">//#pragma GCC diagnostic push 和 #pragma GCC diagnostic pop 用于临时禁用编译器的警告，以便在进行字节序转换函数的实现时，不受 -Wconversion 和 -Wold-style-cast 这两种警告的干扰。这些警告与类型转换相关，可能在你的代码中的转换操作时触发</span><br><span class="line">inline uint64_t hostToNetwork64(uint64_t host64)</span><br><span class="line">&#123;</span><br><span class="line">  return htobe64(host64);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline uint32_t hostToNetwork32(uint32_t host32)</span><br><span class="line">&#123;</span><br><span class="line">  return htobe32(host32);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline uint16_t hostToNetwork16(uint16_t host16)</span><br><span class="line">&#123;</span><br><span class="line">  return htobe16(host16);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline uint64_t networkToHost64(uint64_t net64)</span><br><span class="line">&#123;</span><br><span class="line">  return be64toh(net64);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline uint32_t networkToHost32(uint32_t net32)</span><br><span class="line">&#123;</span><br><span class="line">  return be32toh(net32);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline uint16_t networkToHost16(uint16_t net16)</span><br><span class="line">&#123;</span><br><span class="line">  return be16toh(net16);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma GCC diagnostic pop</span><br><span class="line"></span><br><span class="line">&#125;  // namespace sockets</span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_NET_ENDIAN_H</span><br></pre></td></tr></table></figure>

<p>上面的方法只适用于Linux，不能跨平台。</p>
<h2 id="SocketsOps-h-x2F-SocketsOps-cc"><a href="#SocketsOps-h-x2F-SocketsOps-cc" class="headerlink" title="SocketsOps.h&#x2F; SocketsOps.cc"></a>SocketsOps.h&#x2F; SocketsOps.cc</h2><ul>
<li>封装了socket相关系统调用（全局函数，位于muduo::net::sockets名称空间中)。</li>
</ul>
<p>这些函数看起来是用于类型转换，主要是在Socket编程中对网络地址结构 <code>sockaddr</code> 及其 IPv4 (<code>sockaddr_in</code>) 和 IPv6 (<code>sockaddr_in6</code>) 版本之间的转换。让我们分析每个函数的区别和用途：</p>
<ol>
<li><strong><code>const struct sockaddr* sockets::sockaddr_cast(const struct sockaddr_in6* addr)</code></strong>:<ul>
<li>参数类型：<code>sockaddr_in6</code> 指针</li>
<li>返回类型：<code>const sockaddr*</code></li>
<li>作用：将IPv6地址结构 (<code>sockaddr_in6</code>) 转换为通用的地址结构 (<code>sockaddr</code>) 的常量指针。</li>
<li>使用场景：通常在需要操作IPv6地址的网络编程中，可能需要将 <code>sockaddr_in6</code> 类型的地址转换为通用的 <code>sockaddr</code> 类型。</li>
</ul>
</li>
<li><strong><code>struct sockaddr* sockets::sockaddr_cast(struct sockaddr_in6* addr)</code></strong>:<ul>
<li>参数类型：<code>sockaddr_in6</code> 指针</li>
<li>返回类型：<code>sockaddr*</code></li>
<li>作用：将IPv6地址结构 (<code>sockaddr_in6</code>) 转换为通用的地址结构 (<code>sockaddr</code>) 的指针。</li>
<li>使用场景：类似于上一个函数，但这个函数返回的是非常量指针，可能用于修改地址结构。</li>
</ul>
</li>
<li><strong><code>const struct sockaddr* sockets::sockaddr_cast(const struct sockaddr_in* addr)</code></strong>:<ul>
<li>参数类型：<code>sockaddr_in</code> 指针</li>
<li>返回类型：<code>const sockaddr*</code></li>
<li>作用：将IPv4地址结构 (<code>sockaddr_in</code>) 转换为通用的地址结构 (<code>sockaddr</code>) 的常量指针。</li>
<li>使用场景：类似于第一个函数，但这个函数针对IPv4地址结构。</li>
</ul>
</li>
<li><strong><code>const struct sockaddr_in* sockets::sockaddr_in_cast(const struct sockaddr* addr)</code></strong>:<ul>
<li>参数类型：<code>sockaddr</code> 指针</li>
<li>返回类型：<code>const sockaddr_in*</code></li>
<li>作用：将通用的地址结构 (<code>sockaddr</code>) 转换为IPv4地址结构 (<code>sockaddr_in</code>) 的常量指针。</li>
<li>使用场景：通常在需要获取 <code>sockaddr</code> 类型的指针指向 IPv4 地址结构的情况下使用。</li>
</ul>
</li>
<li><strong><code>const struct sockaddr_in6* sockets::sockaddr_in6_cast(const struct sockaddr* addr)</code></strong>:<ul>
<li>参数类型：<code>sockaddr</code> 指针</li>
<li>返回类型：<code>const sockaddr_in6*</code></li>
<li>作用：将通用的地址结构 (<code>sockaddr</code>) 转换为IPv6地址结构 (<code>sockaddr_in6</code>) 的常量指针。</li>
<li>使用场景：类似于第四个函数，但这个函数针对IPv6地址结构。</li>
</ul>
</li>
</ol>
<p>这些函数的主要目的是在不同类型的网络地址结构之间进行安全的类型转换，以便在网络编程中处理不同的地址类型。它们使用了 <code>implicit_cast</code>（隐式转换）来实现这些转换，确保了正确的指针类型。</p>
<h3 id="SocketsOps-h"><a href="#SocketsOps-h" class="headerlink" title="SocketsOps.h"></a>SocketsOps.h</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_NET_SOCKETSOPS_H</span><br><span class="line">#define MUDUO_NET_SOCKETSOPS_H</span><br><span class="line"></span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line">namespace sockets</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">///</span><br><span class="line">/// Creates a non-blocking socket file descriptor,</span><br><span class="line">/// abort if any error.</span><br><span class="line">int createNonblockingOrDie(sa_family_t family);</span><br><span class="line"></span><br><span class="line">int  connect(int sockfd, const struct sockaddr* addr);</span><br><span class="line">void bindOrDie(int sockfd, const struct sockaddr* addr);</span><br><span class="line">void listenOrDie(int sockfd);</span><br><span class="line">int  accept(int sockfd, struct sockaddr_in6* addr);</span><br><span class="line">ssize_t read(int sockfd, void *buf, size_t count);</span><br><span class="line">ssize_t readv(int sockfd, const struct iovec *iov, int iovcnt);</span><br><span class="line">ssize_t write(int sockfd, const void *buf, size_t count);</span><br><span class="line">void close(int sockfd);</span><br><span class="line">void shutdownWrite(int sockfd);</span><br><span class="line"></span><br><span class="line">void toIpPort(char* buf, size_t size,</span><br><span class="line">              const struct sockaddr* addr);</span><br><span class="line">void toIp(char* buf, size_t size,</span><br><span class="line">          const struct sockaddr* addr);</span><br><span class="line"></span><br><span class="line">void fromIpPort(const char* ip, uint16_t port,</span><br><span class="line">                struct sockaddr_in* addr);</span><br><span class="line">void fromIpPort(const char* ip, uint16_t port,</span><br><span class="line">                struct sockaddr_in6* addr);</span><br><span class="line"></span><br><span class="line">int getSocketError(int sockfd);</span><br><span class="line"></span><br><span class="line">const struct sockaddr* sockaddr_cast(const struct sockaddr_in* addr);</span><br><span class="line">const struct sockaddr* sockaddr_cast(const struct sockaddr_in6* addr);</span><br><span class="line">struct sockaddr* sockaddr_cast(struct sockaddr_in6* addr);</span><br><span class="line">const struct sockaddr_in* sockaddr_in_cast(const struct sockaddr* addr);</span><br><span class="line">const struct sockaddr_in6* sockaddr_in6_cast(const struct sockaddr* addr);</span><br><span class="line"></span><br><span class="line">struct sockaddr_in6 getLocalAddr(int sockfd);</span><br><span class="line">struct sockaddr_in6 getPeerAddr(int sockfd);</span><br><span class="line">bool isSelfConnect(int sockfd);</span><br><span class="line"></span><br><span class="line">&#125;  // namespace sockets</span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_NET_SOCKETSOPS_H</span><br></pre></td></tr></table></figure>

<h3 id="SocketsOps-cc"><a href="#SocketsOps-cc" class="headerlink" title="SocketsOps.cc"></a>SocketsOps.cc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line">int sockets::createNonblockingOrDie(sa_family_t family)//创建非阻塞套接字，失败就终止</span><br><span class="line">&#123;</span><br><span class="line">#if VALGRIND//VALGRIND可以检测内存泄漏和文件描述符</span><br><span class="line">  int sockfd = ::socket(family, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">  if (sockfd &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSFATAL &lt;&lt; &quot;sockets::createNonblockingOrDie&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setNonBlockAndCloseOnExec(sockfd);</span><br><span class="line">#else</span><br><span class="line">  int sockfd = ::socket(family, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, IPPROTO_TCP);</span><br><span class="line">  //IPPROTO_TCP 是一个常量，用于指定套接字选项或协议参数中的 TCP（Transmission Control Protocol）协议</span><br><span class="line">  if (sockfd &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSFATAL &lt;&lt; &quot;sockets::createNonblockingOrDie&quot;;//FATAL 终止</span><br><span class="line">  &#125;</span><br><span class="line">#endif</span><br><span class="line">  return sockfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sockets::bindOrDie(int sockfd, const struct sockaddr* addr)</span><br><span class="line">&#123;</span><br><span class="line">  int ret = ::bind(sockfd, addr, static_cast&lt;socklen_t&gt;(sizeof(struct sockaddr_in6)));</span><br><span class="line">  if (ret &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSFATAL &lt;&lt; &quot;sockets::bindOrDie&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sockets::listenOrDie(int sockfd)</span><br><span class="line">&#123;</span><br><span class="line">  int ret = ::listen(sockfd, SOMAXCONN);//SOMAXCONN 的值表示操作系统允许的监听队列的最大长度。这个值可能因操作系统而异，但通常是一个相对较大的数字。当连接请求超过这个队列长度时，客户端的连接请求可能会被拒绝。</span><br><span class="line">  if (ret &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSFATAL &lt;&lt; &quot;sockets::listenOrDie&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sockets::accept(int sockfd, struct sockaddr_in6* addr)</span><br><span class="line">&#123;</span><br><span class="line">  socklen_t addrlen = static_cast&lt;socklen_t&gt;(sizeof *addr);</span><br><span class="line">#if VALGRIND || defined (NO_ACCEPT4)</span><br><span class="line">  int connfd = ::accept(sockfd, sockaddr_cast(addr), &amp;addrlen);</span><br><span class="line">  setNonBlockAndCloseOnExec(connfd);</span><br><span class="line">#else</span><br><span class="line">  int connfd = ::accept4(sockfd, sockaddr_cast(addr),</span><br><span class="line">                         &amp;addrlen, SOCK_NONBLOCK | SOCK_CLOEXEC);</span><br><span class="line">#endif</span><br><span class="line">  if (connfd &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    int savedErrno = errno;</span><br><span class="line">    LOG_SYSERR &lt;&lt; &quot;Socket::accept&quot;;</span><br><span class="line">    switch (savedErrno)</span><br><span class="line">    &#123;</span><br><span class="line">      case EAGAIN:</span><br><span class="line">      case ECONNABORTED:</span><br><span class="line">      case EINTR:</span><br><span class="line">      case EPROTO: // ???</span><br><span class="line">      case EPERM:</span><br><span class="line">      case EMFILE: // per-process lmit of open file desctiptor ???</span><br><span class="line">        // expected errors</span><br><span class="line">        errno = savedErrno;//上面的都不是致命错误</span><br><span class="line">        break;</span><br><span class="line">      case EBADF:</span><br><span class="line">      case EFAULT:</span><br><span class="line">      case EINVAL:</span><br><span class="line">      case ENFILE:</span><br><span class="line">      case ENOBUFS:</span><br><span class="line">      case ENOMEM:</span><br><span class="line">      case ENOTSOCK:</span><br><span class="line">      case EOPNOTSUPP:</span><br><span class="line">        // unexpected errors</span><br><span class="line">        LOG_FATAL &lt;&lt; &quot;unexpected error of ::accept &quot; &lt;&lt; savedErrno;</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        LOG_FATAL &lt;&lt; &quot;unknown error of ::accept &quot; &lt;&lt; savedErrno;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return connfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sockets::connect(int sockfd, const struct sockaddr* addr)</span><br><span class="line">&#123;</span><br><span class="line">  return ::connect(sockfd, addr, static_cast&lt;socklen_t&gt;(sizeof(struct sockaddr_in6)));</span><br><span class="line">&#125;</span><br><span class="line">//read与readv不同之处在于</span><br><span class="line">ssize_t sockets::read(int sockfd, void *buf, size_t count)</span><br><span class="line">&#123;</span><br><span class="line">  return ::read(sockfd, buf, count);</span><br><span class="line">&#125;</span><br><span class="line">//readv与read不同之处在于，接受的数据可以填充到多个缓冲区中</span><br><span class="line">ssize_t sockets::readv(int sockfd, const struct iovec *iov, int iovcnt)</span><br><span class="line">&#123;</span><br><span class="line">  return ::readv(sockfd, iov, iovcnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ssize_t sockets::write(int sockfd, const void *buf, size_t count)//struct iovec 是一个结构体，用于描述一组分散的内存缓冲区</span><br><span class="line">&#123;</span><br><span class="line">  return ::write(sockfd, buf, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sockets::close(int sockfd)</span><br><span class="line">&#123;</span><br><span class="line">  if (::close(sockfd) &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSERR &lt;&lt; &quot;sockets::close&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//只关闭写的这一半</span><br><span class="line">void sockets::shutdownWrite(int sockfd)</span><br><span class="line">&#123;</span><br><span class="line">  if (::shutdown(sockfd, SHUT_WR) &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSERR &lt;&lt; &quot;sockets::shutdownWrite&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//将addr转换成IP与端口的形式保存在buf中</span><br><span class="line">void sockets::toIpPort(char* buf, size_t size,</span><br><span class="line">                       const struct sockaddr* addr)</span><br><span class="line">&#123;</span><br><span class="line">  if (addr-&gt;sa_family == AF_INET6)</span><br><span class="line">  &#123;</span><br><span class="line">    buf[0] = &#x27;[&#x27;;</span><br><span class="line">    toIp(buf+1, size-1, addr);</span><br><span class="line">    size_t end = ::strlen(buf);</span><br><span class="line">    const struct sockaddr_in6* addr6 = sockaddr_in6_cast(addr);</span><br><span class="line">    uint16_t port = sockets::networkToHost16(addr6-&gt;sin6_port);</span><br><span class="line">    assert(size &gt; end);</span><br><span class="line">    snprintf(buf+end, size-end, &quot;]:%u&quot;, port);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  toIp(buf, size, addr);</span><br><span class="line">  size_t end = ::strlen(buf);</span><br><span class="line">  const struct sockaddr_in* addr4 = sockaddr_in_cast(addr);</span><br><span class="line">  uint16_t port = sockets::networkToHost16(addr4-&gt;sin_port);</span><br><span class="line">  assert(size &gt; end);</span><br><span class="line">  snprintf(buf+end, size-end, &quot;:%u&quot;, port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sockets::toIp(char* buf, size_t size,</span><br><span class="line">                   const struct sockaddr* addr)</span><br><span class="line">&#123;</span><br><span class="line">  if (addr-&gt;sa_family == AF_INET)</span><br><span class="line">  &#123;</span><br><span class="line">    assert(size &gt;= INET_ADDRSTRLEN);</span><br><span class="line">    const struct sockaddr_in* addr4 = sockaddr_in_cast(addr);</span><br><span class="line">    ::inet_ntop(AF_INET, &amp;addr4-&gt;sin_addr, buf, static_cast&lt;socklen_t&gt;(size));</span><br><span class="line">  &#125;</span><br><span class="line">  else if (addr-&gt;sa_family == AF_INET6)</span><br><span class="line">  &#123;</span><br><span class="line">    assert(size &gt;= INET6_ADDRSTRLEN);</span><br><span class="line">    const struct sockaddr_in6* addr6 = sockaddr_in6_cast(addr);</span><br><span class="line">    ::inet_ntop(AF_INET6, &amp;addr6-&gt;sin6_addr, buf, static_cast&lt;socklen_t&gt;(size));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sockets::fromIpPort(const char* ip, uint16_t port,</span><br><span class="line">                         struct sockaddr_in* addr)</span><br><span class="line">&#123;</span><br><span class="line">  addr-&gt;sin_family = AF_INET;</span><br><span class="line">  addr-&gt;sin_port = hostToNetwork16(port);</span><br><span class="line">  if (::inet_pton(AF_INET, ip, &amp;addr-&gt;sin_addr) &lt;= 0)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSERR &lt;&lt; &quot;sockets::fromIpPort&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sockets::fromIpPort(const char* ip, uint16_t port,</span><br><span class="line">                         struct sockaddr_in6* addr)//从IP和port构造一个网际协议地址addr</span><br><span class="line">&#123;</span><br><span class="line">  addr-&gt;sin6_family = AF_INET6;</span><br><span class="line">  addr-&gt;sin6_port = hostToNetwork16(port);</span><br><span class="line">  if (::inet_pton(AF_INET6, ip, &amp;addr-&gt;sin6_addr) &lt;= 0)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSERR &lt;&lt; &quot;sockets::fromIpPort&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sockets::getSocketError(int sockfd)</span><br><span class="line">&#123;</span><br><span class="line">  int optval;</span><br><span class="line">  socklen_t optlen = static_cast&lt;socklen_t&gt;(sizeof optval);</span><br><span class="line"></span><br><span class="line">  if (::getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &amp;optval, &amp;optlen) &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    return errno;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    return optval;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct sockaddr_in6 sockets::getLocalAddr(int sockfd)</span><br><span class="line">&#123;</span><br><span class="line">  struct sockaddr_in6 localaddr;</span><br><span class="line">  memZero(&amp;localaddr, sizeof localaddr);</span><br><span class="line">  socklen_t addrlen = static_cast&lt;socklen_t&gt;(sizeof localaddr);</span><br><span class="line">  if (::getsockname(sockfd, sockaddr_cast(&amp;localaddr), &amp;addrlen) &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSERR &lt;&lt; &quot;sockets::getLocalAddr&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  return localaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct sockaddr_in6 sockets::getPeerAddr(int sockfd)</span><br><span class="line">&#123;</span><br><span class="line">  struct sockaddr_in6 peeraddr;</span><br><span class="line">  memZero(&amp;peeraddr, sizeof peeraddr);</span><br><span class="line">  socklen_t addrlen = static_cast&lt;socklen_t&gt;(sizeof peeraddr);</span><br><span class="line">  if (::getpeername(sockfd, sockaddr_cast(&amp;peeraddr), &amp;addrlen) &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSERR &lt;&lt; &quot;sockets::getPeerAddr&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  return peeraddr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Socket-h-x2F-Socket-cc-Socket类"><a href="#Socket-h-x2F-Socket-cc-Socket类" class="headerlink" title="Socket.h&#x2F;Socket.cc ( Socket类)"></a>Socket.h&#x2F;Socket.cc ( Socket类)</h2><ul>
<li>用RAIl方法封装socket file descriptor</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Socket::~Socket()</span><br><span class="line">&#123;</span><br><span class="line">  sockets::close(sockfd_);</span><br><span class="line">&#125;</span><br><span class="line">void Socket::bindAddress(const InetAddress&amp; addr)</span><br><span class="line">&#123;</span><br><span class="line">  sockets::bindOrDie(sockfd_, addr.getSockAddr());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Socket::listen()</span><br><span class="line">&#123;</span><br><span class="line">  sockets::listenOrDie(sockfd_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Socket::accept(InetAddress* peeraddr)</span><br><span class="line">&#123;</span><br><span class="line">  struct sockaddr_in6 addr;</span><br><span class="line">  memZero(&amp;addr, sizeof addr);</span><br><span class="line">  int connfd = sockets::accept(sockfd_, &amp;addr);</span><br><span class="line">  if (connfd &gt;= 0)</span><br><span class="line">  &#123;</span><br><span class="line">    peeraddr-&gt;setSockAddrInet6(addr);</span><br><span class="line">  &#125;</span><br><span class="line">  return connfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Socket::shutdownWrite()</span><br><span class="line">&#123;</span><br><span class="line">  sockets::shutdownWrite(sockfd_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="InetAddress-h-x2F-InetAddress-cc-InetAddress类）"><a href="#InetAddress-h-x2F-InetAddress-cc-InetAddress类）" class="headerlink" title="InetAddress.h&#x2F;InetAddress.cc (InetAddress类）"></a>InetAddress.h&#x2F;InetAddress.cc (InetAddress类）</h2><ul>
<li>网际地址sockaddr_in封装,就不用关注底层</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">InetAddress::InetAddress(uint16_t portArg, bool loopbackOnly, bool ipv6)</span><br><span class="line">&#123;</span><br><span class="line">  static_assert(offsetof(InetAddress, addr6_) == 0, &quot;addr6_ offset 0&quot;);</span><br><span class="line">  static_assert(offsetof(InetAddress, addr_) == 0, &quot;addr_ offset 0&quot;);</span><br><span class="line">  if (ipv6)</span><br><span class="line">  &#123;</span><br><span class="line">    memZero(&amp;addr6_, sizeof addr6_);</span><br><span class="line">    addr6_.sin6_family = AF_INET6;</span><br><span class="line">    in6_addr ip = loopbackOnly ? in6addr_loopback : in6addr_any;</span><br><span class="line">    addr6_.sin6_addr = ip;</span><br><span class="line">    addr6_.sin6_port = sockets::hostToNetwork16(portArg);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    memZero(&amp;addr_, sizeof addr_);</span><br><span class="line">    addr_.sin_family = AF_INET;</span><br><span class="line">    in_addr_t ip = loopbackOnly ? kInaddrLoopback : kInaddrAny;</span><br><span class="line">    addr_.sin_addr.s_addr = sockets::hostToNetwork32(ip);</span><br><span class="line">    addr_.sin_port = sockets::hostToNetwork16(portArg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InetAddress::InetAddress(StringArg ip, uint16_t portArg, bool ipv6)</span><br><span class="line">&#123;</span><br><span class="line">  if (ipv6 || strchr(ip.c_str(), &#x27;:&#x27;))</span><br><span class="line">  &#123;</span><br><span class="line">    memZero(&amp;addr6_, sizeof addr6_);</span><br><span class="line">    sockets::fromIpPort(ip.c_str(), portArg, &amp;addr6_);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    memZero(&amp;addr_, sizeof addr_);</span><br><span class="line">    sockets::fromIpPort(ip.c_str(), portArg, &amp;addr_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string InetAddress::toIpPort() const</span><br><span class="line">&#123;</span><br><span class="line">  char buf[64] = &quot;&quot;;</span><br><span class="line">  sockets::toIpPort(buf, sizeof buf, getSockAddr());</span><br><span class="line">  return buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string InetAddress::toIp() const</span><br><span class="line">&#123;</span><br><span class="line">  char buf[64] = &quot;&quot;;</span><br><span class="line">  sockets::toIp(buf, sizeof buf, getSockAddr());</span><br><span class="line">  return buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint32_t InetAddress::ipv4NetEndian() const</span><br><span class="line">&#123;</span><br><span class="line">  assert(family() == AF_INET);</span><br><span class="line">  return addr_.sin_addr.s_addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint16_t InetAddress::port() const</span><br><span class="line">&#123;</span><br><span class="line">  return sockets::networkToHost16(portNetEndian());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个函数似乎是C++中用于创建网络地址（InetAddress）对象的构造函数。它们的功能是根据提供的参数（IP地址、端口等）创建网络地址对象，并根据需要支持IPv6和IPv4。</p>
<p>下面是这两个函数的功能和区别的解释：</p>
<h3 id="构造函数-1-InetAddress-InetAddress-uint16-t-portArg-bool-loopbackOnly-bool-ipv6"><a href="#构造函数-1-InetAddress-InetAddress-uint16-t-portArg-bool-loopbackOnly-bool-ipv6" class="headerlink" title="构造函数 1: InetAddress::InetAddress(uint16_t portArg, bool loopbackOnly, bool ipv6)"></a>构造函数 1: InetAddress::InetAddress(uint16_t portArg, bool loopbackOnly, bool ipv6)</h3><p>这个构造函数用于创建一个网络地址对象，参数包括：</p>
<ul>
<li><code>portArg</code>：端口号。</li>
<li><code>loopbackOnly</code>：一个布尔值，指示是否只能在回环地址上监听。</li>
<li><code>ipv6</code>：一个布尔值，指示是否使用IPv6。</li>
</ul>
<p>函数的功能如下：</p>
<ol>
<li>如果 <code>ipv6</code> 为 <code>true</code>，则会初始化IPv6地址结构 <code>addr6_</code>，并根据 <code>loopbackOnly</code> 的值设置IP地址为回环地址或任意地址，然后设置端口号。</li>
<li>如果 <code>ipv6</code> 为 <code>false</code>，则会初始化IPv4地址结构 <code>addr_</code>，并根据 <code>loopbackOnly</code> 的值设置IP地址为回环地址或任意地址，然后设置端口号。</li>
</ol>
<h3 id="构造函数-2-InetAddress-InetAddress-StringArg-ip-uint16-t-portArg-bool-ipv6"><a href="#构造函数-2-InetAddress-InetAddress-StringArg-ip-uint16-t-portArg-bool-ipv6" class="headerlink" title="构造函数 2: InetAddress::InetAddress(StringArg ip, uint16_t portArg, bool ipv6)"></a>构造函数 2: InetAddress::InetAddress(StringArg ip, uint16_t portArg, bool ipv6)</h3><p>这个构造函数也用于创建一个网络地址对象，参数包括：</p>
<ul>
<li><code>ip</code>：一个字符串类型的IP地址。</li>
<li><code>portArg</code>：端口号。</li>
<li><code>ipv6</code>：一个布尔值，指示是否使用IPv6。</li>
</ul>
<p>函数的功能如下：</p>
<ol>
<li>如果 <code>ipv6</code> 为 <code>true</code> 或者 <code>ip</code> 中包含 <code>:</code>，则会初始化IPv6地址结构 <code>addr6_</code>，并通过调用 <code>sockets::fromIpPort</code> 函数从提供的IP地址和端口号解析填充 <code>addr6_</code>。</li>
<li>如果 <code>ipv6</code> 为 <code>false</code> 且 <code>ip</code> 中不包含 <code>:</code>，则会初始化IPv4地址结构 <code>addr_</code>，并通过调用 <code>sockets::fromIpPort</code> 函数从提供的IP地址和端口号解析填充 <code>addr_</code>。</li>
</ol>
<p>总之，这两个构造函数都用于创建网络地址对象，根据提供的参数不同，可以支持IPv6和IPv4，并根据需要设置端口号和IP地址。区别在于第一个构造函数的参数直接指定了是否使用回环地址，而第二个构造函数根据提供的IP地址字符串判断是否使用IPv6。</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">bool InetAddress::resolve(StringArg hostname, InetAddress* out)</span><br><span class="line">&#123;</span><br><span class="line">  assert(out != NULL);</span><br><span class="line">  struct hostent hent;</span><br><span class="line">  struct hostent* he = NULL;</span><br><span class="line">  int herrno = 0;</span><br><span class="line">  memZero(&amp;hent, sizeof(hent));</span><br><span class="line"></span><br><span class="line">  int ret = gethostbyname_r(hostname.c_str(), &amp;hent, t_resolveBuffer, sizeof t_resolveBuffer, &amp;he, &amp;herrno);</span><br><span class="line">  if (ret == 0 &amp;&amp; he != NULL)</span><br><span class="line">  &#123;</span><br><span class="line">    assert(he-&gt;h_addrtype == AF_INET &amp;&amp; he-&gt;h_length == sizeof(uint32_t));</span><br><span class="line">    out-&gt;addr_.sin_addr = *reinterpret_cast&lt;struct in_addr*&gt;(he-&gt;h_addr);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    if (ret)</span><br><span class="line">    &#123;</span><br><span class="line">      LOG_SYSERR &lt;&lt; &quot;InetAddress::resolve&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数是用于将主机名（hostname）解析为 IPv4 地址（InetAddress 对象）的功能。IPv4 地址结构在网络编程中用于表示 IP 地址。</p>
<p>以下是这个函数的作用：</p>
<ol>
<li>接收一个主机名（hostname）作为输入参数，以及一个指向 InetAddress 对象的指针 <code>out</code>，用于存储解析后的结果。</li>
<li>使用 <code>gethostbyname_r</code> 函数来解析主机名。该函数是线程安全的，它接受主机名、用于存储结果的结构体 <code>hent</code>、缓冲区 <code>t_resolveBuffer</code> 以及其他参数，然后尝试解析主机名并将结果存储在 <code>hent</code> 中。</li>
<li>如果解析成功（<code>ret</code> 等于 0，并且 <code>he</code> 非空），则验证返回的结果确实是 IPv4 地址类型，并且地址长度是 <code>sizeof(uint32_t)</code>。</li>
<li>将解析到的 IPv4 地址复制到 <code>out</code> 的 <code>addr_</code> 成员中，然后返回 <code>true</code> 表示解析成功。</li>
<li>如果解析失败（<code>ret</code> 不等于 0，或者 <code>he</code> 为空），则根据情况输出错误日志，然后返回 <code>false</code> 表示解析失败。</li>
</ol>
<p>总之，这个函数是用于将主机名解析为 IPv4 地址的工具函数，如果解析成功，会将解析结果存储在 <code>out</code> 参数中，并返回 <code>true</code>，否则返回 <code>false</code>。</p>
<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/net/InetAddress.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line"></span><br><span class="line">//#define BOOST_TEST_MODULE InetAddressTest</span><br><span class="line">#define BOOST_TEST_MAIN</span><br><span class="line">#define BOOST_TEST_DYN_LINK</span><br><span class="line">#include &lt;boost/test/unit_test.hpp&gt;</span><br><span class="line"></span><br><span class="line">using muduo::string;</span><br><span class="line">using muduo::net::InetAddress;</span><br><span class="line"></span><br><span class="line">BOOST_AUTO_TEST_CASE(testInetAddress)</span><br><span class="line">&#123;</span><br><span class="line">  InetAddress addr0(1234);</span><br><span class="line">  BOOST_CHECK_EQUAL(addr0.toIp(), string(&quot;0.0.0.0&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(addr0.toIpPort(), string(&quot;0.0.0.0:1234&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(addr0.port(), 1234);</span><br><span class="line"></span><br><span class="line">  InetAddress addr1(4321, true);</span><br><span class="line">  BOOST_CHECK_EQUAL(addr1.toIp(), string(&quot;127.0.0.1&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(addr1.toIpPort(), string(&quot;127.0.0.1:4321&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(addr1.port(), 4321);</span><br><span class="line"></span><br><span class="line">  InetAddress addr2(&quot;1.2.3.4&quot;, 8888);</span><br><span class="line">  BOOST_CHECK_EQUAL(addr2.toIp(), string(&quot;1.2.3.4&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(addr2.toIpPort(), string(&quot;1.2.3.4:8888&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(addr2.port(), 8888);</span><br><span class="line"></span><br><span class="line">  InetAddress addr3(&quot;255.254.253.252&quot;, 65535);</span><br><span class="line">  BOOST_CHECK_EQUAL(addr3.toIp(), string(&quot;255.254.253.252&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(addr3.toIpPort(), string(&quot;255.254.253.252:65535&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(addr3.port(), 65535);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOST_AUTO_TEST_CASE(testInet6Address)</span><br><span class="line">&#123;</span><br><span class="line">  InetAddress addr0(1234, false, true);</span><br><span class="line">  BOOST_CHECK_EQUAL(addr0.toIp(), string(&quot;::&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(addr0.toIpPort(), string(&quot;[::]:1234&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(addr0.port(), 1234);</span><br><span class="line"></span><br><span class="line">  InetAddress addr1(1234, true, true);</span><br><span class="line">  BOOST_CHECK_EQUAL(addr1.toIp(), string(&quot;::1&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(addr1.toIpPort(), string(&quot;[::1]:1234&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(addr1.port(), 1234);</span><br><span class="line"></span><br><span class="line">  InetAddress addr2(&quot;2001:db8::1&quot;, 8888, true);</span><br><span class="line">  BOOST_CHECK_EQUAL(addr2.toIp(), string(&quot;2001:db8::1&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(addr2.toIpPort(), string(&quot;[2001:db8::1]:8888&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(addr2.port(), 8888);</span><br><span class="line"></span><br><span class="line">  InetAddress addr3(&quot;fe80::1234:abcd:1&quot;, 8888);</span><br><span class="line">  BOOST_CHECK_EQUAL(addr3.toIp(), string(&quot;fe80::1234:abcd:1&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(addr3.toIpPort(), string(&quot;[fe80::1234:abcd:1]:8888&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(addr3.port(), 8888);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOST_AUTO_TEST_CASE(testInetAddressResolve)</span><br><span class="line">&#123;</span><br><span class="line">  InetAddress addr(80);</span><br><span class="line">  if (InetAddress::resolve(&quot;google.com&quot;, &amp;addr))</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_INFO &lt;&lt; &quot;google.com resolved to &quot; &lt;&lt; addr.toIpPort();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_ERROR &lt;&lt; &quot;Unable to resolve google.com&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%883%EF%BC%89/image-20230814161825526.png" alt="image-20230814161825526"></p>
<img src="/2023/08/13/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%883%EF%BC%89/image-20230814161825526.png" class title="This is an test image">

<h1 id="Acceptor"><a href="#Acceptor" class="headerlink" title="Acceptor"></a>Acceptor</h1><p>Acceptor用于accept(2)接受TCP连接<br>Acceptor的数据成员包括Socket、Channel,Acceptor的socket是listening socket ( serversocket)。Channel用于观察此socket的readable事件，并回调Accptor:handleRead()，后者调用accept(2)来接受新连接，并回调用户callback.</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%883%EF%BC%89/image-20230814200106610.png" alt="image-20230814200106610"></p>
<img src="/2023/08/13/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%883%EF%BC%89/image-20230814200106610.png" class title="This is an test image">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_NET_ACCEPTOR_H</span><br><span class="line">#define MUDUO_NET_ACCEPTOR_H</span><br><span class="line"></span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/net/Channel.h&quot;</span><br><span class="line">#include &quot;muduo/net/Socket.h&quot;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">class EventLoop;</span><br><span class="line">class InetAddress;</span><br><span class="line"></span><br><span class="line">///</span><br><span class="line">/// Acceptor of incoming TCP connections.</span><br><span class="line">///</span><br><span class="line">class Acceptor : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  typedef std::function&lt;void (int sockfd, const InetAddress&amp;)&gt; NewConnectionCallback;</span><br><span class="line"></span><br><span class="line">  Acceptor(EventLoop* loop, const InetAddress&amp; listenAddr, bool reuseport);</span><br><span class="line">  ~Acceptor();</span><br><span class="line"></span><br><span class="line">  void setNewConnectionCallback(const NewConnectionCallback&amp; cb)</span><br><span class="line">  &#123; newConnectionCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line">  void listen();</span><br><span class="line"></span><br><span class="line">  bool listening() const &#123; return listening_; &#125;</span><br><span class="line"></span><br><span class="line">  // Deprecated, use the correct spelling one above.</span><br><span class="line">  // Leave the wrong spelling here in case one needs to grep it for error messages.</span><br><span class="line">  // bool listenning() const &#123; return listening(); &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  void handleRead();</span><br><span class="line"></span><br><span class="line">  EventLoop* loop_;</span><br><span class="line">  Socket acceptSocket_;</span><br><span class="line">  Channel acceptChannel_;</span><br><span class="line">  NewConnectionCallback newConnectionCallback_;</span><br><span class="line">  bool listening_;</span><br><span class="line">  int idleFd_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_NET_ACCEPTOR_H</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;muduo/net/Acceptor.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line">#include &quot;muduo/net/EventLoop.h&quot;</span><br><span class="line">#include &quot;muduo/net/InetAddress.h&quot;</span><br><span class="line">#include &quot;muduo/net/SocketsOps.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">//#include &lt;sys/types.h&gt;</span><br><span class="line">//#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">Acceptor::Acceptor(EventLoop* loop, const InetAddress&amp; listenAddr, bool reuseport)</span><br><span class="line">  : loop_(loop),</span><br><span class="line">    acceptSocket_(sockets::createNonblockingOrDie(listenAddr.family())),</span><br><span class="line">    acceptChannel_(loop, acceptSocket_.fd()),</span><br><span class="line">    listening_(false),</span><br><span class="line">    idleFd_(::open(&quot;/dev/null&quot;, O_RDONLY | O_CLOEXEC))</span><br><span class="line">&#123;</span><br><span class="line">  assert(idleFd_ &gt;= 0);</span><br><span class="line">  acceptSocket_.setReuseAddr(true);</span><br><span class="line">  acceptSocket_.setReusePort(reuseport);</span><br><span class="line">  acceptSocket_.bindAddress(listenAddr);</span><br><span class="line">  acceptChannel_.setReadCallback(</span><br><span class="line">      std::bind(&amp;Acceptor::handleRead, this));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Acceptor::~Acceptor()</span><br><span class="line">&#123;</span><br><span class="line">  acceptChannel_.disableAll();</span><br><span class="line">  acceptChannel_.remove();</span><br><span class="line">  ::close(idleFd_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Acceptor::listen()</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  listening_ = true;</span><br><span class="line">  acceptSocket_.listen();</span><br><span class="line">  acceptChannel_.enableReading();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Acceptor::handleRead()</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  InetAddress peerAddr;</span><br><span class="line">  //FIXME loop until no more</span><br><span class="line">  int connfd = acceptSocket_.accept(&amp;peerAddr);</span><br><span class="line">  if (connfd &gt;= 0)</span><br><span class="line">  &#123;</span><br><span class="line">    // string hostport = peerAddr.toIpPort();</span><br><span class="line">    // LOG_TRACE &lt;&lt; &quot;Accepts of &quot; &lt;&lt; hostport;</span><br><span class="line">    if (newConnectionCallback_)</span><br><span class="line">    &#123;</span><br><span class="line">      newConnectionCallback_(connfd, peerAddr);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      sockets::close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSERR &lt;&lt; &quot;in Acceptor::handleRead&quot;;</span><br><span class="line">    // Read the section named &quot;The special problem of</span><br><span class="line">    // accept()ing when you can&#x27;t&quot; in libev&#x27;s doc.</span><br><span class="line">    // By Marc Lehmann, author of libev.</span><br><span class="line">    if (errno == EMFILE)</span><br><span class="line">    &#123;</span><br><span class="line">      ::close(idleFd_);</span><br><span class="line">      idleFd_ = ::accept(acceptSocket_.fd(), NULL, NULL);</span><br><span class="line">      ::close(idleFd_);</span><br><span class="line">      idleFd_ = ::open(&quot;/dev/null&quot;, O_RDONLY | O_CLOEXEC);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>server:<br>    1. socket()	创建socket</p>
<ol start="2">
<li><p>bind()	绑定服务器地址结构</p>
</li>
<li><p>listen()	设置监听上限</p>
</li>
<li><p>accept()	阻塞监听客户端连接</p>
</li>
<li><p>read(fd)	读socket获取客户端数据</p>
</li>
<li><p>小–大写	toupper()</p>
</li>
<li><p>write(fd)，567回调函数</p>
</li>
<li><p>close();</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/10/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%882%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/10/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%882%EF%BC%89/" class="post-title-link" itemprop="url">muduo-网络库（2）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-10 10:48:35" itemprop="dateCreated datePublished" datetime="2023-08-10T10:48:35+08:00">2023-08-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-13 17:36:31" itemprop="dateModified" datetime="2023-08-13T17:36:31+08:00">2023-08-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="定时器函数选择"><a href="#定时器函数选择" class="headerlink" title="定时器函数选择"></a>定时器函数选择</h1><p>定时函数，用于让程序等待一段时间或安排计划任务:</p>
<p>sleep</p>
<p>alarm</p>
<p>usleep</p>
<p>nanosleep<br>clock_nanosleep</p>
<p>getitimer &#x2F; setitimer</p>
<p>timer_create &#x2F; timer_settime &#x2F; timer_gettime &#x2F; timer_delete</p>
<p>timerfd_create &#x2F; timerfd_gettime &#x2F; timerfd_settime</p>
<h2 id="timerfd-入选的原因"><a href="#timerfd-入选的原因" class="headerlink" title="timerfd_入选的原因:"></a>timerfd_入选的原因:</h2><ul>
<li>sleep &#x2F; alarm &#x2F; usleep在实现时有可能用了信号SIGALRM，在多线程程序中处理信号是个相当麻烦的事情，应当尽量避免</li>
<li>nanosleep和 clock_nanosleep是线程安全的，但是在非阻塞网络编程中，绝对不能用让线程挂起的方式来等待一段时间，程序会失去响应。正确的做法是注册一个时间回调函数。</li>
<li>getitimer和l timer_create 也是用信号来deliver 超时，在多线程程序中也会有麻烦。</li>
<li>timer_create 可以指定信号的接收方是进程还是线程，算是一个进步，不过在信号处理函数(signal handler)能做的事情实在很受限。</li>
<li>timerfd_create <strong>把时间变成了一个文件描述符</strong>，该“文件”在定时器超时的那一刻变得可读，这样就能很方便地融入到select&#x2F;poll框架中，用统一的方式来处理IO事件和超时事件，这也正是 Reactor模式的长处。</li>
</ul>
<h3 id="函数签名："><a href="#函数签名：" class="headerlink" title="函数签名："></a>函数签名：</h3><p><code>int signalfd(int fd,const sigset_t *mask, int flags);</code></p>
<h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><p><code>fd</code>：一个整数，表示文件描述符。通常设置为 <code>-1</code>，这将导致内核创建一个新的文件描述符。</p>
</li>
<li><p><code>mask</code>：一个指向 <code>sigset_t</code> 类型的指针，表示要监视的信号集。通过将感兴趣的信号添加到这个集合中，您可以选择性地监控特定信号。</p>
</li>
<li><p>&#96;&#96;&#96;<br>flags</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ：整数标志，可以使用以下标志进行按位或运算：</span><br><span class="line"></span><br><span class="line">  - `SFD_CLOEXEC`：在执行 `exec` 系统调用时关闭文件描述符。</span><br><span class="line">  - `SFD_NONBLOCK`：以非阻塞模式打开文件描述符。</span><br><span class="line"></span><br><span class="line">### 返回值：</span><br><span class="line"></span><br><span class="line">- 如果函数调用成功，它将返回一个非负整数，表示新创建的文件描述符。如果失败，它将返回 `-1` 并设置 `errno` 来指示错误类型。</span><br><span class="line"></span><br><span class="line">### 示例用法：</span><br><span class="line"></span><br><span class="line">下面是一个详细的示例，演示了如何使用 `signalfd` 函数来监视 `SIGINT` 信号的到来：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>c复制代码#include &lt;stdio.h&gt;</p>
</li>
</ul>
<p>#include &lt;stdlib.h&gt;<br>#include &lt;signal.h&gt;<br>#include &lt;sys&#x2F;signalfd.h&gt;<br>#include &lt;unistd.h&gt;</p>
<p>int main() {<br>    sigset_t mask;<br>    sigemptyset(&amp;mask);<br>    sigaddset(&amp;mask, SIGINT);  &#x2F;&#x2F; 监控 SIGINT 信号</p>
<pre><code>int sfd = signalfd(-1, &amp;mask, 0);  // 创建 signalfd
if (sfd == -1) &#123;
    perror(&quot;signalfd&quot;);
    exit(EXIT_FAILURE);
&#125;

// 使用 select 或 epoll 监视 sfd

printf(&quot;Waiting for SIGINT...\n&quot;);

// 在此处执行 I/O 多路复用等待

// 当 SIGINT 信号到达时，处理逻辑会在此处触发

close(sfd);
return 0;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在此示例中，我们创建了一个新的 signalfd 文件描述符以监视 `SIGINT` 信号的到来。然后，您可以使用适当的多路复用机制（如 `select`、`poll`、`epoll` 等）来监视该文件描述符，并在信号到达时触发相应的处理逻辑。</span><br><span class="line"></span><br><span class="line">这个方法可以起到timerfd_create同样作用</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">下面是 `timerfd_create`、`timerfd_gettime` 和 `timerfd_settime` 函数的原型和简要说明。这些函数是用于创建和操作定时器事件的 Linux 系统调用。</span><br><span class="line"></span><br><span class="line">1. **timerfd_create**：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#include &lt;sys&#x2F;timerfd.h&gt;</p>
<p>int timerfd_create(int clockid, int flags);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **参数**：</span><br><span class="line">  - `clockid`：用于指定定时器的时钟类型，可以是 `CLOCK_REALTIME` 或 `CLOCK_MONOTONIC`。一般使用 `CLOCK_MONOTONIC` 以避免受系统时间的影响。</span><br><span class="line">  - `flags`：额外的选项标志，通常设置为 0。</span><br><span class="line">- **返回值**：</span><br><span class="line">  - 成功：返回一个新的文件描述符，用于访问创建的定时器。</span><br><span class="line">  - 失败：返回 -1，并设置 `errno` 表示错误原因。</span><br><span class="line"></span><br><span class="line">1. **timerfd_gettime**：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#include &lt;sys&#x2F;timerfd.h&gt;</p>
<p>int timerfd_gettime(int fd, struct itimerspec *curr_value);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **参数**：</span><br><span class="line">  - `fd`：定时器的文件描述符。</span><br><span class="line">  - `curr_value`：指向 `struct itimerspec` 的指针，用于存储当前定时器的配置信息。</span><br><span class="line">- **返回值**：</span><br><span class="line">  - 成功：返回 0，`curr_value` 结构体被填充为当前定时器的配置信息。</span><br><span class="line">  - 失败：返回 -1，并设置 `errno` 表示错误原因。</span><br><span class="line"></span><br><span class="line">1. **timerfd_settime**：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#include &lt;sys&#x2F;timerfd.h&gt;</p>
<p>int timerfd_settime(int fd, int flags, const struct itimerspec *new_value, struct itimerspec *old_value);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **参数**：</span><br><span class="line">  - `fd`：定时器的文件描述符。</span><br><span class="line">  - `flags`：设置定时器的选项标志，一般设置为 0。</span><br><span class="line">  - `new_value`：指向 `struct itimerspec` 的指针，用于设置新的定时器配置。</span><br><span class="line">  - `old_value`：指向 `struct itimerspec` 的指针，用于存储之前的定时器配置（如果不需要，可以传递 NULL）。</span><br><span class="line">- **返回值**：</span><br><span class="line">  - 成功：返回 0，`old_value` 结构体被填充为之前的定时器配置。</span><br><span class="line">  - 失败：返回 -1，并设置 `errno` 表示错误原因。</span><br><span class="line"></span><br><span class="line">这些函数主要用于创建定时器、获取定时器配置和修改定时器配置，通常用于实现高精度的定时操作，例如事件循环中的定时器管理。请注意，这里的结构体 `struct itimerspec` 包含了定时器的详细配置信息。</span><br><span class="line"></span><br><span class="line">## 示例</span><br><span class="line"></span><br><span class="line">![image-20230810112723867](muduo-网络库（2）/image-20230810112723867.png)</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20230810112723867.png This is an test image %&#125;</span><br><span class="line"></span><br><span class="line">因为howlong.it_interval=0，所以间隔时间为0，这是一次性的。enableReading将通道注册到poll或epoll当中。</span><br><span class="line"></span><br><span class="line">loop.loop(),处于事件循环状态，一旦可读事件产生，也就是定时器超时，1秒，EventLoop调用poll（`poller_-&gt;**poll**(kPollTimeMs, &amp;activeChannels_);`）返回activeChannels，再调用handleEvent（`currentActiveChannel_-&gt;**handleEvent**(pollReturnTime_);`）。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;该函数可以跨线程调用<br>void EventLoop::quit()<br>{<br>  quit_ &#x3D; true;&#x2F;&#x2F;多个线程都有quit_变量，因为它是bool类型，因为在Linux下bool是原子类型<br>  &#x2F;&#x2F; There is a chance that loop() just executes while(!quit_) and exits,<br>  &#x2F;&#x2F; then EventLoop destructs, then we are accessing an invalid object.<br>  &#x2F;&#x2F; Can be fixed using mutex_ in both places.<br>  if (!isInLoopThread())<br>  {<br>    wakeup();&#x2F;&#x2F;如果不是再当前线程，还需要唤醒，因为线程本身在loop循环阻塞poll<br>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 定时器</span><br><span class="line"></span><br><span class="line">muduo的定时器由三个类实现，Timerld、Timer、TimerQueue,用户只能看到第一个类，其它两个都是内部实现细节</span><br><span class="line"></span><br><span class="line">TimerQueue的接口很简单，只有两个函数addTimer和cancel</span><br><span class="line"></span><br><span class="line">EventLoop</span><br><span class="line"></span><br><span class="line">- ​	runAt								在某个时刻运行定时器</span><br><span class="line">- ​	runAfter							过一段时间运行定时器</span><br><span class="line">- ​	runEvery							每隔一段时间运行定时器</span><br><span class="line">- ​	cancel								取消定时器</span><br><span class="line"></span><br><span class="line">TimerQueue数据结构的选择，能快速根据当前时间找到已到期的定时器，也要高效的添加和删除Timer，因而可以用二叉搜索树，用</span><br><span class="line"></span><br><span class="line">map或者set</span><br><span class="line"></span><br><span class="line">- ​	`typedef std:pair&lt;Timestamp, Timer*&gt; Entry;`</span><br><span class="line"></span><br><span class="line">- ​	`typedef std:set&lt;Entry&gt; TimerList;``std::set` 是 C++ 标准库中的一个关联容器，它会对存储的元素自动排序，以保持有序状态</span><br><span class="line"></span><br><span class="line">## 时序图</span><br><span class="line"></span><br><span class="line">![image-20230811105332742](muduo-网络库（2）/image-20230811105332742.png)</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20230811105332742.png This is an test image %&#125;</span><br><span class="line"></span><br><span class="line">## EventLoop.cc部分调用</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>std::unique_ptr<TimerQueue> timerQueue_;<br>TimerId EventLoop::runAt(Timestamp time, TimerCallback cb)&#x2F;&#x2F;某个时刻调用，一次性定时器<br>{<br>  return timerQueue_-&gt;addTimer(std::move(cb), time, 0.0);<br>}</TimerQueue></p>
<p>TimerId EventLoop::runAfter(double delay, TimerCallback cb)&#x2F;&#x2F;延迟一会调用，一次性定时器<br>{<br>  Timestamp time(addTime(Timestamp::now(), delay));<br>  return runAt(time, std::move(cb));<br>}</p>
<p>TimerId EventLoop::runEvery(double interval, TimerCallback cb)&#x2F;&#x2F;间隔性定时器，interval大于0，repeat就是true，就是重复的定时器，也就可以Timer::restart<br>{<br>  Timestamp time(addTime(Timestamp::now(), interval));<br>  return timerQueue_-&gt;addTimer(std::move(cb), time, interval);<br>}</p>
<p>void EventLoop::cancel(TimerId timerId)<br>{<br>  return timerQueue_-&gt;cancel(timerId);<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## TimerId.h</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#ifndef MUDUO_NET_TIMERID_H<br>#define MUDUO_NET_TIMERID_H</p>
<p>#include “muduo&#x2F;base&#x2F;copyable.h”</p>
<p>namespace muduo<br>{<br>namespace net<br>{</p>
<p>class Timer;</p>
<p>&#x2F;&#x2F;&#x2F;<br>&#x2F;&#x2F;&#x2F; An opaque identifier, for canceling Timer.<br>&#x2F;&#x2F;&#x2F;<br>class TimerId : public muduo::copyable<br>{<br> public:<br>  TimerId()<br>    : timer_(NULL),<br>      sequence_(0)<br>  {<br>  }</p>
<p>  TimerId(Timer* timer, int64_t seq)<br>    : timer_(timer),<br>      sequence_(seq)<br>  {<br>  }</p>
<p>  &#x2F;&#x2F; default copy-ctor, dtor and assignment are okay</p>
<p>  friend class TimerQueue;</p>
<p> private:<br>  Timer* timer_;&#x2F;&#x2F;定时器地址<br>  int64_t sequence_;&#x2F;&#x2F;定时器序号<br>};</p>
<p>}  &#x2F;&#x2F; namespace net<br>}  &#x2F;&#x2F; namespace muduo</p>
<p>#endif  &#x2F;&#x2F; MUDUO_NET_TIMERID_H</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Timer.h</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#ifndef MUDUO_NET_TIMER_H<br>#define MUDUO_NET_TIMER_H</p>
<p>#include “muduo&#x2F;base&#x2F;Atomic.h”<br>#include “muduo&#x2F;base&#x2F;Timestamp.h”<br>#include “muduo&#x2F;net&#x2F;Callbacks.h”</p>
<p>namespace muduo<br>{<br>namespace net<br>{</p>
<p>&#x2F;&#x2F;&#x2F;<br>&#x2F;&#x2F;&#x2F; Internal class for timer event.<br>&#x2F;&#x2F;&#x2F;<br>class Timer : noncopyable<br>{<br> public:<br>  Timer(TimerCallback cb, Timestamp when, double interval)<br>    : callback_(std::move(cb)),<br>      expiration_(when),<br>      interval_(interval),<br>      repeat_(interval &gt; 0.0),<br>      sequence_(s_numCreated_.incrementAndGet())&#x2F;&#x2F;sequence唯一的<br>  { }</p>
<p>  void run() const<br>  {<br>    callback_();<br>  }</p>
<p>  Timestamp expiration() const  { return expiration_; }<br>  bool repeat() const { return repeat_; }<br>  int64_t sequence() const { return sequence_; }</p>
<p>  void restart(Timestamp now);</p>
<p>  static int64_t numCreated() { return s_numCreated_.get(); }</p>
<p> private:<br>  const TimerCallback callback_;&#x2F;&#x2F;定时器回调函数<br>  Timestamp expiration_;&#x2F;&#x2F;下一次的超时时刻<br>  const double interval_;&#x2F;&#x2F;超时时间间隔，如果是一次性定时器，该值为0<br>  const bool repeat_;&#x2F;&#x2F;是否重复<br>  const int64_t sequence_;&#x2F;&#x2F;定时器序号</p>
<p>  static AtomicInt64 s_numCreated_;&#x2F;&#x2F;定时器计数，当前已经创建的定时器数量<br>};</p>
<p>}  &#x2F;&#x2F; namespace net<br>}  &#x2F;&#x2F; namespace muduo</p>
<p>#endif  &#x2F;&#x2F; MUDUO_NET_TIMER_H</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Timer.cc</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#include “muduo&#x2F;net&#x2F;Timer.h”</p>
<p>using namespace muduo;<br>using namespace muduo::net;</p>
<p>AtomicInt64 Timer::s_numCreated_;</p>
<p>void Timer::restart(Timestamp now)&#x2F;&#x2F;重启<br>{<br>  &#x2F;&#x2F;如果是重复的计时器，则重新计算下一个超时时刻<br>  if (repeat_)<br>  {<br>    expiration_ &#x3D; addTime(now, interval_);<br>    &#x2F;&#x2F;全局函数，因为Timestamp相当于一个整数，所以是值传递，不是类传递都是引用传递<br>  }<br>  else<br>  {<br>    expiration_ &#x3D; Timestamp::invalid();&#x2F;&#x2F;非法的时间<br>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## TimerQueue.h</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>#ifndef MUDUO_NET_TIMERQUEUE_H<br>#define MUDUO_NET_TIMERQUEUE_H</p>
<p>#include <set><br>#include <vector></vector></set></p>
<p>#include “muduo&#x2F;base&#x2F;Mutex.h”<br>#include “muduo&#x2F;base&#x2F;Timestamp.h”<br>#include “muduo&#x2F;net&#x2F;Callbacks.h”<br>#include “muduo&#x2F;net&#x2F;Channel.h”</p>
<p>namespace muduo<br>{<br>namespace net<br>{</p>
<p>class EventLoop;<br>class Timer;<br>class TimerId;</p>
<p>&#x2F;&#x2F;&#x2F;<br>&#x2F;&#x2F;&#x2F; A best efforts timer queue.<br>&#x2F;&#x2F;&#x2F; No guarantee that the callback will be on time.<br>&#x2F;&#x2F;&#x2F;<br>class TimerQueue : noncopyable<br>{<br> public:<br>  explicit TimerQueue(EventLoop* loop);&#x2F;&#x2F;一个TimerQueue属于EventLoop对象<br>  ~TimerQueue();</p>
<p>  &#x2F;&#x2F;&#x2F;<br>  &#x2F;&#x2F;&#x2F; Schedules the callback to be run at given time,<br>  &#x2F;&#x2F;&#x2F; repeats if @c interval &gt; 0.0.<br>  &#x2F;&#x2F;&#x2F;<br>  &#x2F;&#x2F;&#x2F; Must be thread safe. Usually be called from other threads.<br>  &#x2F;&#x2F;一定是线程安全的，可以跨线程调用。通常情况下被其它线程调用<br>  TimerId addTimer(TimerCallback cb,<br>                   Timestamp when,<br>                   double interval);<br>  &#x2F;&#x2F;也可以跨线程调用<br>  void cancel(TimerId timerId);</p>
<p> private:</p>
<p>  &#x2F;&#x2F; FIXME: use unique_ptr<Timer> instead of raw pointers.<br>  &#x2F;&#x2F; This requires heterogeneous comparison lookup (N3465) from C++14<br>  &#x2F;&#x2F; so that we can find an T* in a set&lt;unique_ptr<T>&gt;.<br>  &#x2F;&#x2F;unique_ptr是c++11标准的一个独享所有权的智能指针<br>  &#x2F;&#x2F;无法得到指向同一对象的两个unique_ptr指针<br>  &#x2F;&#x2F;但可以进行移动构造与移动赋值操作，即所有权可以移动到另一个对象（而非拷贝构造)<br>  typedef std::pair&lt;Timestamp, Timer*&gt; Entry;<br>  typedef std::set<Entry> TimerList;<br>  typedef std::pair&lt;Timer*, int64_t&gt; ActiveTimer;<br>  typedef std::set<ActiveTimer> ActiveTimerSet;<br>  &#x2F;&#x2F;事实上 TimerList和 ActiveTimerSet表示的是同一样东西定时器列表，只是一个是地址排序，一个是按时间排序<br>  &#x2F;&#x2F;以下成员函数只可能在其所属的IO线程中调用，因而不必加锁<br>  &#x2F;&#x2F;服务器性能杀手之一是锁竞争，所以尽量减少锁的使用<br>  void addTimerInLoop(Timer* timer);<br>  void cancelInLoop(TimerId timerId);<br>  &#x2F;&#x2F; called when timerfd alarms<br>  void handleRead();&#x2F;&#x2F;定时器事件到来，调用回调函数handleRead()<br>  &#x2F;&#x2F; move out all expired timers</ActiveTimer></Entry></T></Timer></p>
<p>  &#x2F;&#x2F;返回超时的定时器列表<br>  std::vector<Entry> getExpired(Timestamp now);<br>  &#x2F;&#x2F;对于重复的定时器我们需要重置<br>  void reset(const std::vector<Entry>&amp; expired, Timestamp now);<br>  &#x2F;&#x2F;插入定时器<br>  bool insert(Timer* timer);</Entry></Entry></p>
<p>  EventLoop* loop_;&#x2F;&#x2F;所属EventLoop<br>  const int timerfd_;&#x2F;&#x2F;定时器文件描述符<br>  Channel timerfdChannel_;&#x2F;&#x2F;定时器通道<br>  &#x2F;&#x2F; Timer list sorted by expiration<br>  TimerList timers_;&#x2F;&#x2F;是按到期时间排序的</p>
<p>  &#x2F;&#x2F; for cancel()<br>  &#x2F;&#x2F;事实上 TimerList和 ActiveTimerSet表示的是同一样东西定时器列表，只是一个是地址排序，一个是按时间排序<br>  ActiveTimerSet activeTimers_;<br>  bool callingExpiredTimers_; &#x2F;* atomic *&#x2F;<br>  &#x2F;&#x2F;是否处于调用那些超时定时器处理当中<br>  ActiveTimerSet cancelingTimers_;&#x2F;&#x2F;保存的是被取消的定时器<br>};</p>
<p>}  &#x2F;&#x2F; namespace net<br>}  &#x2F;&#x2F; namespace muduo<br>#endif  &#x2F;&#x2F; MUDUO_NET_TIMERQUEUE_H</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## TimerQueue.cc</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#ifndef __STDC_LIMIT_MACROS<br>#define __STDC_LIMIT_MACROS<br>#endif</p>
<p>#include “muduo&#x2F;net&#x2F;TimerQueue.h”</p>
<p>#include “muduo&#x2F;base&#x2F;Logging.h”<br>#include “muduo&#x2F;net&#x2F;EventLoop.h”<br>#include “muduo&#x2F;net&#x2F;Timer.h”<br>#include “muduo&#x2F;net&#x2F;TimerId.h”</p>
<p>#include &lt;sys&#x2F;timerfd.h&gt;<br>#include &lt;unistd.h&gt;</p>
<p>namespace muduo<br>{<br>namespace net<br>{<br>namespace detail<br>{</p>
<p>int createTimerfd()<br>{<br>  int timerfd &#x3D; ::timerfd_create(CLOCK_MONOTONIC,<br>                                 TFD_NONBLOCK | TFD_CLOEXEC);<br>  if (timerfd &lt; 0)<br>  {<br>    LOG_SYSFATAL &lt;&lt; “Failed in timerfd_create”;<br>  }<br>  return timerfd;<br>}</p>
<p>struct timespec howMuchTimeFromNow(Timestamp when)<br>{<br>  int64_t microseconds &#x3D; when.microSecondsSinceEpoch()<br>                         - Timestamp::now().microSecondsSinceEpoch();<br>  if (microseconds &lt; 100)<br>  {<br>    microseconds &#x3D; 100;<br>  }<br>  struct timespec ts;<br>  ts.tv_sec &#x3D; static_cast<time_t>(<br>      microseconds &#x2F; Timestamp::kMicroSecondsPerSecond);<br>  ts.tv_nsec &#x3D; static_cast<long>(<br>      (microseconds % Timestamp::kMicroSecondsPerSecond) * 1000);<br>  return ts;<br>}</long></time_t></p>
<p>void readTimerfd(int timerfd, Timestamp now)<br>{<br>  uint64_t howmany;<br>  ssize_t n &#x3D; ::read(timerfd, &amp;howmany, sizeof howmany);<br>  LOG_TRACE &lt;&lt; “TimerQueue::handleRead() “ &lt;&lt; howmany &lt;&lt; “ at “ &lt;&lt; now.toString();<br>  if (n !&#x3D; sizeof howmany)<br>  {<br>    LOG_ERROR &lt;&lt; “TimerQueue::handleRead() reads “ &lt;&lt; n &lt;&lt; “ bytes instead of 8”;<br>  }<br>}<br>&#x2F;&#x2F;重置定时器的超时时间<br>void resetTimerfd(int timerfd, Timestamp expiration)<br>{<br>  &#x2F;&#x2F; wake up loop by timerfd_settime()<br>  struct itimerspec newValue;<br>  struct itimerspec oldValue;<br>  memZero(&amp;newValue, sizeof newValue);<br>  memZero(&amp;oldValue, sizeof oldValue);<br>  newValue.it_value &#x3D; howMuchTimeFromNow(expiration);<br>  int ret &#x3D; ::timerfd_settime(timerfd, 0, &amp;newValue, &amp;oldValue);<br>  if (ret)<br>  {<br>    LOG_SYSERR &lt;&lt; “timerfd_settime()”;<br>  }<br>}</p>
<p>}  &#x2F;&#x2F; namespace detail<br>}  &#x2F;&#x2F; namespace net<br>}  &#x2F;&#x2F; namespace muduo</p>
<p>using namespace muduo;<br>using namespace muduo::net;<br>using namespace muduo::net::detail;</p>
<p>TimerQueue::TimerQueue(EventLoop* loop)<br>  : loop_(loop),<br>    timerfd_(createTimerfd()),<br>    timerfdChannel_(loop, timerfd_),<br>    timers_(),<br>    callingExpiredTimers_(false)<br>{<br>  timerfdChannel_.setReadCallback(<br>      std::bind(&amp;TimerQueue::handleRead, this));<br>  &#x2F;&#x2F; we are always reading the timerfd, we disarm it with timerfd_settime.<br>  timerfdChannel_.enableReading();&#x2F;&#x2F;把timerfdChannel_这个通道加入poll关注<br>}</p>
<p>TimerQueue::~TimerQueue()<br>{<br>  timerfdChannel_.disableAll();<br>  timerfdChannel_.remove();<br>  ::close(timerfd_);<br>  &#x2F;&#x2F; do not remove channel, since we’re in EventLoop::dtor();<br>  for (const Entry&amp; timer : timers_)<br>  {<br>    delete timer.second;&#x2F;&#x2F;只需要删除其中一个的原因是因为Timer 对象同时被 timers_ 集合和 activeTimers_ 集合所拥有<br>  }<br>}</p>
<p>TimerId TimerQueue::addTimer(TimerCallback cb,<br>                             Timestamp when,&#x2F;&#x2F;超时时间<br>                             double interval)<br>{<br>  Timer* timer &#x3D; new Timer(std::move(cb), when, interval);&#x2F;&#x2F;每隔interval就会产生定时事件，回调cb<br>  loop_-&gt;runInLoop(<br>      std::bind(&amp;TimerQueue::addTimerInLoop, this, timer));&#x2F;&#x2F;用来保证跨线程调用，并且保证线程安全<br>  return TimerId(timer, timer-&gt;sequence());<br>}</p>
<p>void TimerQueue::cancel(TimerId timerId)<br>{<br>  loop_-&gt;runInLoop(<br>      std::bind(&amp;TimerQueue::cancelInLoop, this, timerId));<br>}</p>
<p>void TimerQueue::addTimerInLoop(Timer* timer)<br>{<br>  loop_-&gt;assertInLoopThread();<br>  &#x2F;&#x2F;插入一个定时器，有可能会使得最早到期的定时器发生改变<br>  bool earliestChanged &#x3D; insert(timer);&#x2F;&#x2F;不用加锁，因为loop_-&gt;runInLoop异步有加锁这一步</p>
<p>  if (earliestChanged)&#x2F;&#x2F;最早的定时器会到期<br>  {<br>    &#x2F;&#x2F;重置定时器的超时时刻（timerfd_settime）<br>    resetTimerfd(timerfd_, timer-&gt;expiration());<br>  }<br>}</p>
<p>void TimerQueue::cancelInLoop(TimerId timerId)<br>{<br>  loop_-&gt;assertInLoopThread();<br>  assert(timers_.size() &#x3D;&#x3D; activeTimers_.size());<br>  ActiveTimer timer(timerId.timer_, timerId.sequence_);<br>  &#x2F;&#x2F;查找该定时器<br>  ActiveTimerSet::iterator it &#x3D; activeTimers_.find(timer);<br>  if (it !&#x3D; activeTimers_.end())<br>  {<br>    size_t n &#x3D; timers_.erase(Entry(it-&gt;first-&gt;expiration(), it-&gt;first));<br>    assert(n &#x3D;&#x3D; 1); (void)n;<br>    delete it-&gt;first; &#x2F;&#x2F; FIXME: no delete please，如果用了unique_ptr就不用手动删除了，typedef std::pair&lt;Timestamp, std::unique_ptr<Timer>&gt; Entry;<br>    activeTimers_.erase(it);<br>  }<br>  else if (callingExpiredTimers_)<br>  {<br>    &#x2F;&#x2F;已经到期，并且正在调用回调函数的定时器<br>    cancelingTimers_.insert(timer);<br>  }<br>  assert(timers_.size() &#x3D;&#x3D; activeTimers_.size());<br>}</Timer></p>
<p>void TimerQueue::handleRead()<br>{<br>  loop_-&gt;assertInLoopThread();<br>  Timestamp now(Timestamp::now());<br>  readTimerfd(timerfd_, now);&#x2F;&#x2F;清除该事件，避免一直触发<br>  &#x2F;&#x2F;获取该时刻之前所以的定时器列表（即超时定时器列表）<br>  std::vector<Entry> expired &#x3D; getExpired(now);</Entry></p>
<p>  callingExpiredTimers_ &#x3D; true;<br>  cancelingTimers_.clear();<br>  &#x2F;&#x2F; safe to callback outside critical section<br>  for (const Entry&amp; it : expired)<br>  {<br>    &#x2F;&#x2F;这里回调定时器处理函数<br>    it.second-&gt;run();<br>  }<br>  callingExpiredTimers_ &#x3D; false;<br>  &#x2F;&#x2F;不是一次性定时器，需要重启<br>  reset(expired, now);<br>}<br>&#x2F;&#x2F;不会对expired拷贝构造，rvo<br>std::vector<a href="TimerQueue::Entry">TimerQueue::Entry</a> TimerQueue::getExpired(Timestamp now)<br>{<br>  assert(timers_.size() &#x3D;&#x3D; activeTimers_.size());<br>  std::vector<Entry> expired;<br>  Entry sentry(now, reinterpret_cast&lt;Timer*&gt;(UINTPTR_MAX));&#x2F;&#x2F;将机器指针的最大值（UINTPTR_MAX）转换为 Timer* 类型的指针<br>  &#x2F;&#x2F;返回第一个未到期timer迭代器<br>  &#x2F;&#x2F;lower_bound表示返回第一个大于等于sentry的元素的iterator<br>  &#x2F;&#x2F;即*end&gt;&#x3D;sentry,从而end-&gt;first&gt;now</Entry></p>
<p>  TimerList::iterator end &#x3D; timers_.lower_bound(sentry);<br>  assert(end &#x3D;&#x3D; timers_.end() || now &lt; end-&gt;first);<br>  &#x2F;&#x2F;将到期的定时器插入到expired<br>  std::copy(timers_.begin(), end, back_inserter(expired));<br>  timers_.erase(timers_.begin(), end);&#x2F;&#x2F;删除timers_到期的定时器<br>  &#x2F;&#x2F;移除ActiveTimer到期的定时器<br>  for (const Entry&amp; it : expired)<br>  {<br>    ActiveTimer timer(it.second, it.second-&gt;sequence());<br>    size_t n &#x3D; activeTimers_.erase(timer);<br>    assert(n &#x3D;&#x3D; 1); (void)n;<br>  }</p>
<p>  assert(timers_.size() &#x3D;&#x3D; activeTimers_.size());<br>  return expired;<br>}</p>
<p>void TimerQueue::reset(const std::vector<Entry>&amp; expired, Timestamp now)<br>{<br>  Timestamp nextExpire;</Entry></p>
<p>  for (const Entry&amp; it : expired)<br>  {<br>    ActiveTimer timer(it.second, it.second-&gt;sequence());<br>    &#x2F;&#x2F;如果是重复的定时器并且是未取消的定时器，则重启该定时器<br>    if (it.second-&gt;repeat()<br>        &amp;&amp; cancelingTimers_.find(timer) &#x3D;&#x3D; cancelingTimers_.end())<br>    {<br>      &#x2F;&#x2F;一次性定时器或者被取消的定时器是不能重置的，因此删除该定时器<br>      it.second-&gt;restart(now);<br>      insert(it.second);<br>    }<br>    else<br>    {<br>      &#x2F;&#x2F; FIXME move to a free list<br>      delete it.second; &#x2F;&#x2F; FIXME: no delete please<br>    }<br>  }</p>
<p>  if (!timers_.empty())<br>  {<br>    nextExpire &#x3D; timers_.begin()-&gt;second-&gt;expiration();<br>  }</p>
<p>  if (nextExpire.valid())<br>  {<br>    resetTimerfd(timerfd_, nextExpire);<br>  }<br>}</p>
<p>bool TimerQueue::insert(Timer* timer)<br>{<br>  loop_-&gt;assertInLoopThread();<br>  assert(timers_.size() &#x3D;&#x3D; activeTimers_.size());<br>  &#x2F;&#x2F;最早到期时间是否改变<br>  bool earliestChanged &#x3D; false;<br>  Timestamp when &#x3D; timer-&gt;expiration();&#x2F;&#x2F;timer的到期时间取出来<br>  TimerList::iterator it &#x3D; timers_.begin();&#x2F;&#x2F;时间最早的定时器<br>  &#x2F;&#x2F;如果timers_为空或者when小于timers_最早到期时间<br>  if (it &#x3D;&#x3D; timers_.end() || when &lt; it-&gt;first)<br>  {<br>    earliestChanged &#x3D; true;<br>  }<br>  {<br>    &#x2F;&#x2F;插入到timers_<br>    std::pair&lt;TimerList::iterator, bool&gt; result<br>      &#x3D; timers_.insert(Entry(when, timer));&#x2F;&#x2F;Entry是一个pair,when是到期时间，timer是地址<br>    assert(result.second); (void)result;<br>  }<br>  {<br>    &#x2F;&#x2F;插入到activeTimers_<br>    std::pair&lt;ActiveTimerSet::iterator, bool&gt; result<br>      &#x3D; activeTimers_.insert(ActiveTimer(timer, timer-&gt;sequence()));<br>    assert(result.second); (void)result;<br>  }</p>
<p>  assert(timers_.size() &#x3D;&#x3D; activeTimers_.size());<br>  return earliestChanged;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### RVO优化</span><br><span class="line"></span><br><span class="line">在C++中，RVO（Return Value Optimization）是一种优化技术，旨在减少函数返回对象时的不必要拷贝构造或移动构造操作，从而提高程序的性能和效率。</span><br><span class="line"></span><br><span class="line">通常情况下，当一个函数返回一个临时对象时，编译器会生成一个临时对象的副本，然后将这个副本返回给调用者。这可能会导致额外的开销，特别是对于大型对象。RVO优化的目标是避免这种额外的拷贝操作。</span><br><span class="line"></span><br><span class="line">RVO优化的原理是在编译器级别进行优化，使得函数返回的临时对象直接构造在调用者提供的内存空间中，从而避免了中间的拷贝步骤。这样可以显著提高程序的性能，减少内存和时间开销。</span><br><span class="line"></span><br><span class="line">以下是一个简单的示例，说明RVO优化是如何工作的：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#include <iostream></iostream></p>
<p>&#x2F;&#x2F; 返回一个临时对象的函数<br>std::string createString() {<br>    std::string str &#x3D; “Hello, RVO!”;<br>    return str; &#x2F;&#x2F; 在RVO优化下，str将直接构造在调用者提供的内存中<br>}</p>
<p>int main() {<br>    std::string result &#x3D; createString();<br>    std::cout &lt;&lt; result &lt;&lt; std::endl;<br>    return 0;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在上述示例中，当RVO优化启用时，函数`createString`返回的临时对象将直接构造在`main`函数中的`result`对象所占用的内存中，而不会发生额外的拷贝操作。</span><br><span class="line"></span><br><span class="line">需要注意的是，RVO并非在所有编译器和所有情况下都会发生。在某些情况下，由于编译器的实现或代码的复杂性，RVO可能无法进行。然而，现代的编译器通常都会支持RVO优化，以提高程序的性能和效率。</span><br><span class="line"></span><br><span class="line">## 测试文件Timerqueue_unittest.cc</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>using namespace muduo;<br>using namespace muduo::net;</p>
<p>int cnt &#x3D; 0;<br>EventLoop* g_loop;</p>
<p>void printTid()<br>{<br>  printf(“pid &#x3D; %d, tid &#x3D; %d\n”, getpid(), CurrentThread::tid());<br>  printf(“now %s\n”, Timestamp::now().toString().c_str());<br>}</p>
<p>void print(const char* msg)<br>{<br>  printf(“msg %s %s\n”, Timestamp::now().toString().c_str(), msg);<br>  if (++cnt &#x3D;&#x3D; 20)<br>  {<br>    g_loop-&gt;quit();<br>  }<br>}</p>
<p>void cancel(TimerId timer)<br>{<br>  g_loop-&gt;cancel(timer);<br>  printf(“cancelled at %s\n”, Timestamp::now().toString().c_str());<br>}</p>
<p>int main()<br>{<br>  printTid();<br>  sleep(1);<br>  {<br>    EventLoop loop;<br>    g_loop &#x3D; &amp;loop;</p>
<pre><code>print(&quot;main&quot;);
loop.runAfter(1, std::bind(print, &quot;once1&quot;));
loop.runAfter(1.5, std::bind(print, &quot;once1.5&quot;));
loop.runAfter(2.5, std::bind(print, &quot;once2.5&quot;));
loop.runAfter(3.5, std::bind(print, &quot;once3.5&quot;));
TimerId t45 = loop.runAfter(4.5, std::bind(print, &quot;once4.5&quot;));
loop.runAfter(4.2, std::bind(cancel, t45));//在4.2秒提前取消
loop.runAfter(4.8, std::bind(cancel, t45));//没有意义
loop.runEvery(2, std::bind(print, &quot;every2&quot;));//每隔2秒运行一下
TimerId t3 = loop.runEvery(3, std::bind(print, &quot;every3&quot;));
loop.runAfter(9.001, std::bind(cancel, t3));

loop.loop();
print(&quot;main loop exits&quot;);
</code></pre>
<p>  }</p>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![image-20230811182546845](muduo-网络库（2）/image-20230811182546845.png)</span><br><span class="line"></span><br><span class="line">&#123;% asset_img image-20230811182546845.png This is an test image %&#125;</span><br><span class="line"></span><br><span class="line">只有TimerId对外可见，其余两个都是内部封装的。</span><br><span class="line"></span><br><span class="line">这段代码实现了一个定时器队列 `TimerQueue`，用于在事件循环中管理定时器的触发和处理。以下是它是如何添加定时器的过程：</span><br><span class="line"></span><br><span class="line">1. 在 `TimerQueue` 的构造函数中，创建了一个 `timerfd`，用于实现定时器的底层计时。</span><br><span class="line">2. 当需要添加一个定时器时，调用 `addTimer` 函数，传递定时器的回调函数 `cb`、超时时间 `when` 和重复间隔 `interval`。</span><br><span class="line">3. 在 `addTimer` 函数中，创建一个新的 `Timer` 对象，将回调函数 `cb`、超时时间 `when` 和重复间隔 `interval` 存储在该定时器对象中。</span><br><span class="line">4. 调用 `loop_-&gt;runInLoop`，将添加定时器的操作安排在事件循环线程中执行，以确保跨线程调用的安全性。</span><br><span class="line">5. 在 `addTimerInLoop` 函数中，首先调用 `insert` 函数将定时器插入到定时器列表 `timers_` 和活跃定时器集合 `activeTimers_` 中。</span><br><span class="line">6. 如果插入定时器后，它成为了最早到期的定时器（即 `earliestChanged` 为 `true`），那么需要调用 `resetTimerfd` 函数来重置 `timerfd` 的超时时间为该定时器的到期时间。</span><br><span class="line">7. 在 `handleRead` 函数中，会处理 `timerfd` 的读事件，即定时器到期事件。它首先获取已到期的定时器列表，然后依次调用它们的回调函数。</span><br><span class="line">8. 如果定时器是重复定时器且没有被取消，它会被重新插入定时器列表，以便下一次触发。否则，被取消的定时器将会被删除。</span><br><span class="line"></span><br><span class="line">总之，通过调用 `addTimer`，代码会创建一个 `Timer` 对象，并将其插入到定时器列表和活跃定时器集合中。在每个事件循环迭代中，会检查定时器列表中是否有已到期的定时器，并触发它们的回调函数。如果定时器是重复定时器且未被取消，它将被重新插入列表中，以便下次触发。</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">当插入一个定时器时，可能会导致最早到期的定时器发生改变。这是因为新插入的定时器有可能比当前最早到期的定时器更早到期，从而改变了整个定时器队列的顺序。</span><br><span class="line"></span><br><span class="line">具体地，以下是插入定时器可能引起的操作：</span><br><span class="line"></span><br><span class="line">1. 首先，插入定时器操作将定时器对象插入到定时器列表 `timers_` 和活跃定时器集合 `activeTimers_` 中。</span><br><span class="line">2. 然后，会检查插入的定时器是否比当前最早到期的定时器更早到期。如果是，那么最早到期的定时器发生了改变，需要进行相应操作。</span><br><span class="line">3. 如果最早到期的定时器发生了改变，会调用 `resetTimerfd` 函数，将 `timerfd` 的超时时间设置为新的最早到期定时器的到期时间。这样做是为了确保 `timerfd` 在最早到期定时器到期时触发读事件。</span><br><span class="line"></span><br><span class="line">总之，插入定时器可能会改变最早到期的定时器，如果发生了这种改变，代码会通过 `resetTimerfd` 函数更新 `timerfd` 的超时时间，以确保及时触发最早到期定时器的事件</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>TimerId TimerQueue::addTimer(TimerCallback cb,<br>                             Timestamp when,&#x2F;&#x2F;超时时间<br>                             double interval)<br>{<br>  Timer* timer &#x3D; new Timer(std::move(cb), when, interval);&#x2F;&#x2F;每隔interval就会产生定时事件，回调cb<br>  loop_-&gt;runInLoop(<br>      std::bind(&amp;TimerQueue::addTimerInLoop, this, timer));&#x2F;&#x2F;用来保证跨线程调用<br>  return TimerId(timer, timer-&gt;sequence());<br>}</p>
<p>void TimerQueue::addTimerInLoop(Timer* timer)<br>{<br>  loop_-&gt;assertInLoopThread();<br>  &#x2F;&#x2F;插入一个定时器，有可能会使得最早到期的定时器发生改变<br>  bool earliestChanged &#x3D; insert(timer);</p>
<p>  if (earliestChanged)&#x2F;&#x2F;最早到期的定时器会<br>  {<br>    &#x2F;&#x2F;重置定时器的超时时刻（timerfd_settime）<br>    resetTimerfd(timerfd_, timer-&gt;expiration());<br>  }<br>}<br>&#x2F;&#x2F;判断是否需要改变最早到期的定时器<br>bool TimerQueue::insert(Timer* timer)<br>{<br>  loop_-&gt;assertInLoopThread();<br>  assert(timers_.size() &#x3D;&#x3D; activeTimers_.size());<br>  &#x2F;&#x2F;最早到期时间是否改变<br>  bool earliestChanged &#x3D; false;<br>  Timestamp when &#x3D; timer-&gt;expiration();&#x2F;&#x2F;timer的到期时间取出来<br>  TimerList::iterator it &#x3D; timers_.begin();&#x2F;&#x2F;时间最早的定时器<br>  &#x2F;&#x2F;如果timers_为空或者when小于timers_最早到期时间<br>  if (it &#x3D;&#x3D; timers_.end() || when &lt; it-&gt;first)<br>  {<br>    earliestChanged &#x3D; true;<br>  }<br>  {<br>    &#x2F;&#x2F;插入到timers_<br>    std::pair&lt;TimerList::iterator, bool&gt; result<br>      &#x3D; timers_.insert(Entry(when, timer));&#x2F;&#x2F;Entry是一个pair,when是到期时间，timer是地址<br>    assert(result.second); (void)result;<br>  }<br>  {<br>    &#x2F;&#x2F;插入到activeTimers_<br>    std::pair&lt;ActiveTimerSet::iterator, bool&gt; result<br>      &#x3D; activeTimers_.insert(ActiveTimer(timer, timer-&gt;sequence()));<br>    assert(result.second); (void)result;<br>  }</p>
<p>  assert(timers_.size() &#x3D;&#x3D; activeTimers_.size());<br>  return earliestChanged;<br>}</p>
<pre><code>
函数 `resetTimerfd`，用于通过调用 `timerfd_settime` 函数来重置定时器的超时时间。以下是每个步骤的解释：

1. `struct itimerspec newValue;` 和 `struct itimerspec oldValue;`：定义了两个 `itimerspec` 结构体，用于存储新旧定时器的超时时间信息。
2. `memZero(&amp;newValue, sizeof newValue);` 和 `memZero(&amp;oldValue, sizeof oldValue);`：将 `newValue` 和 `oldValue` 结构体初始化为全零，以确保没有未初始化的内存数据。
3. `newValue.it_value = howMuchTimeFromNow(expiration);`：计算从当前时间到目标到期时间 `expiration` 的时间间隔，并将其设置为 `newValue` 结构体的 `it_value` 字段。这将在定时器到期时触发定时器事件。
4. `int ret = ::timerfd_settime(timerfd, 0, &amp;newValue, &amp;oldValue);`：调用 `timerfd_settime` 函数，将 `newValue` 结构体应用到指定的定时器文件描述符 `timerfd` 上，从而重置定时器的超时时间。第一个参数为定时器文件描述符，第二个参数为标志（此处为0，表示相对时间），第三个参数为新的定时器超时时间，第四个参数为旧的定时器超时时间。
5. `if (ret)`：检查 `timerfd_settime` 函数的返回值，如果返回值非零，表示函数调用失败。
6. `LOG_SYSERR &lt;&lt; &quot;timerfd_settime()&quot;;`：如果函数调用失败，通过日志记录错误信息。

总之，这段代码通过计算时间间隔并调用 `timerfd_settime` 函数，实现了对定时器超时时间的重置，以便在定时器到期时触发相应的事件。
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1/" class="post-title-link" itemprop="url">数据结构-1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-09 21:57:14 / 修改时间：22:20:51" itemprop="dateCreated datePublished" datetime="2023-08-09T21:57:14+08:00">2023-08-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="二分查找算法"><a href="#二分查找算法" class="headerlink" title="二分查找算法"></a>二分查找算法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">void search(int nums[],int size,int x)</span><br><span class="line">&#123;</span><br><span class="line"> 	int left=0;</span><br><span class="line"> 	int right=size-1;</span><br><span class="line"> 	int flag=0;</span><br><span class="line"> 	int sum=1;</span><br><span class="line"> 	while(left&lt;=right)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		int mid;</span><br><span class="line"> 		//mid=(left+right)/2;</span><br><span class="line"> 		mid=left+(right-left)*(x-nums[left])/(nums[right]-nums[left]);</span><br><span class="line"> 		printf(&quot;%dth\t:left=%d\tmid=%d\tright=%d\n&quot;,sum++,nums[left],nums[mid],nums[right]);</span><br><span class="line"> 		if(x==nums[mid])</span><br><span class="line"> 		&#123;</span><br><span class="line"> 			printf(&quot;第%d次查找到值为%d的数\n&quot;,sum-1,x);</span><br><span class="line"> 			flag=1;</span><br><span class="line"> 			break;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		else if(x&lt;nums[mid])</span><br><span class="line"> 		&#123;</span><br><span class="line"> 			right=mid-1;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		else if(x&gt;nums[mid])</span><br><span class="line"> 		&#123;</span><br><span class="line"> 			left=mid+1;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	if(flag==0)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		printf(&quot;没有找到相关值。\n&quot;);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;	</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> 	int x;</span><br><span class="line"> 	int nums[]=&#123;0,7,12,13,19,31,40,55,66,77,88&#125;;</span><br><span class="line"> 	int size=sizeof(nums)/sizeof(nums[0]);</span><br><span class="line"> 	printf(&quot;Input your number:\n&quot;);</span><br><span class="line"> 	scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line"> 	search(nums,size,x);</span><br><span class="line"> 	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mid=left+(right-left)*(x-nums[left])/(nums[right]-nums[left]);</code>是用来计算二分查找中间元素的下标 <code>mid</code> 的一种特殊方式，以避免整数溢出的问题。让我来解释这个计算的含义：</p>
<p>在标准的二分查找中，通常计算中间元素下标的方式是 <code>(left + right) / 2</code>。然而，当 <code>left</code> 和 <code>right</code> 的值非常大时，相加操作可能导致整数溢出，从而得到错误的中间元素下标。</p>
<p>为了避免这个问题，代码中使用了一个等价的计算方法，即 <code>mid = left + (right - left) * (x - nums[left]) / (nums[right] - nums[left])</code>。这个计算涉及到几个步骤：</p>
<ol>
<li><code>x - nums[left]</code>：计算目标值 <code>x</code> 与左边界元素值的差，即在当前查找范围内，目标值相对于左边界的偏移量。</li>
<li><code>nums[right] - nums[left]</code>：计算右边界元素值与左边界元素值的差，即在当前查找范围内，元素值的范围。</li>
<li><code>(right - left) * (x - nums[left]) / (nums[right] - nums[left])</code>：将偏移量与元素值的范围相乘，然后除以范围的差值。这个操作会产生一个相对于范围的偏移量，将这个偏移量加到左边界的下标上，就得到了一个在当前查找范围内的中间位置的下标。</li>
</ol>
<p>总之，这种计算方法的目的是避免整数溢出，并在大整数范围内也能够正确计算出中间元素的下标，从而确保二分查找的正确性。虽然这个计算方法比标准的 <code>(left + right) / 2</code> 更复杂，但它在处理大整数时更加安全。</p>
<h1 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br><span class="line">#define ElemType int</span><br><span class="line">#define KeyType int</span><br><span class="line"></span><br><span class="line">/* 二叉排序树的节点结构定义 */</span><br><span class="line">typedef struct BiTNode &#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct BiTNode *lchild, *rchild;</span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line">// 二叉排序树查找算法</span><br><span class="line">int SearchBST(BiTree T, KeyType key, BiTree f, BiTree *p) &#123;</span><br><span class="line">	//如果 T 指针为空，说明查找失败，令 p 指针指向查找过程中最后一个叶子结点，并返回查找失败的信息</span><br><span class="line">    if (!T) &#123;</span><br><span class="line">        *p = f;</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125; </span><br><span class="line">    //如果相等，令 p 指针指向该关键字，并返回查找成功信息</span><br><span class="line">    else if (key == T-&gt;data) &#123;</span><br><span class="line">        *p = T;</span><br><span class="line">        return TRUE;</span><br><span class="line">    &#125; </span><br><span class="line">    //如果 key 值比 T 根结点的值小，则查找其左子树；反之，查找其右子树</span><br><span class="line">	else if (key &lt; T-&gt;data) &#123;</span><br><span class="line">		//使用递归的方式</span><br><span class="line">        return SearchBST(T-&gt;lchild, key, T, p);</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">        return SearchBST(T-&gt;rchild, key, T, p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 插入节点</span><br><span class="line">int InsertBST(BiTree *T, ElemType e) &#123;</span><br><span class="line">    BiTree p = NULL;</span><br><span class="line">    //如果查找不成功，需做插入操作</span><br><span class="line">    if (!SearchBST(*T, e, NULL, &amp;p)) &#123;</span><br><span class="line">		//初始化插入结点</span><br><span class="line">        BiTree s = (BiTree)malloc(sizeof(BiTNode));</span><br><span class="line">        s-&gt;data = e;</span><br><span class="line">        s-&gt;lchild = s-&gt;rchild = NULL;</span><br><span class="line">        //如果 p 为NULL，说明该二叉排序树为空树，此时插入的结点为整棵树的根结点</span><br><span class="line">        if (!p) &#123;</span><br><span class="line">            *T = s;</span><br><span class="line">        &#125; </span><br><span class="line">        //如果 p 不为 NULL，则 p 指向的为查找失败的最后一个叶子结点，只需要通过比较 p 和 e 的值确定 s 到底</span><br><span class="line">是 p 的左孩子还是右孩子</span><br><span class="line">        else if (e &lt; p-&gt;data) &#123;</span><br><span class="line">            p-&gt;lchild = s;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            p-&gt;rchild = s;</span><br><span class="line">        &#125;</span><br><span class="line">        return TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果查找成功，不需要做插入操作，插入失败</span><br><span class="line">    return FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除节点</span><br><span class="line">int Delete(BiTree *p) &#123;</span><br><span class="line">    BiTree q, s;</span><br><span class="line">    //情况 1，结点 p 本身为叶子结点，直接删除即可</span><br><span class="line">    if ((*p)-&gt;lchild == NULL &amp;&amp; (*p)-&gt;rchild == NULL) &#123;</span><br><span class="line">        *p = NULL;</span><br><span class="line">    &#125; else if ((*p)-&gt;lchild == NULL) &#123;//左子树为空，只需用结点 p 的右子树根结点代替结点 p 即可；</span><br><span class="line">        q = *p;</span><br><span class="line">        *p = (*p)-&gt;rchild;</span><br><span class="line">        free(q);</span><br><span class="line">    &#125; else if ((*p)-&gt;rchild == NULL) &#123;//右子树为空，只需用结点 p 的左子树根结点代替结点 p 即可；</span><br><span class="line">        q = *p;</span><br><span class="line">        *p = (*p)-&gt;lchild;//这里不是指针 *p 指向左子树，而是将左子树存储的结点的地址赋值给指针变量 p</span><br><span class="line">        free(q);</span><br><span class="line">    &#125; else &#123;//左右子树均不为空，采用第 2 种方式</span><br><span class="line">        q = *p;</span><br><span class="line">        s = (*p)-&gt;lchild;</span><br><span class="line">        //遍历，找到结点 p 的直接前驱</span><br><span class="line">        while (s-&gt;rchild) &#123;</span><br><span class="line">            q = s;</span><br><span class="line">            s = s-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        //直接改变结点 p 的值</span><br><span class="line">        (*p)-&gt;data = s-&gt;data;</span><br><span class="line">        //判断结点 p 的左子树 s 是否有右子树，分为两种情况讨论</span><br><span class="line">        if (q != *p) &#123;</span><br><span class="line">            q-&gt;rchild = s-&gt;lchild;//若有，则在删除直接前驱结点的同时，令前驱的左孩子结点改为 q 指向结点的</span><br><span class="line">孩子结点</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            q-&gt;lchild = s-&gt;lchild;//否则，直接将左子树上移即可</span><br><span class="line">        &#125;</span><br><span class="line">        free(s);</span><br><span class="line">    &#125;</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int DeleteBST(BiTree *T, int key) &#123;</span><br><span class="line">    if (!(*T)) &#123;//不存在关键字等于key的数据元素</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (key == (*T)-&gt;data) &#123;</span><br><span class="line">            Delete(T);</span><br><span class="line">            return TRUE;</span><br><span class="line">        &#125; else if (key &lt; (*T)-&gt;data) &#123;</span><br><span class="line">        	//使用递归的方式</span><br><span class="line">            return DeleteBST(&amp;(*T)-&gt;lchild, key);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return DeleteBST(&amp;(*T)-&gt;rchild, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void midOrder(BiTree t) &#123;</span><br><span class="line">    if (t == NULL) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    midOrder(t-&gt;lchild);</span><br><span class="line">    printf(&quot;%d &quot;, t-&gt;data);</span><br><span class="line">    midOrder(t-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int i;</span><br><span class="line">    int a[8] = &#123; 3, 4, 2, 5, 9, 12, 8, 21 &#125;;</span><br><span class="line">    BiTree T = NULL;</span><br><span class="line">    for (i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">        InsertBST(&amp;T, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;中序遍历二叉排序树：\n&quot;);</span><br><span class="line">    midOrder(T);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    printf(&quot;请输入要删除的值：\n&quot;);</span><br><span class="line">    int x;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">    printf(&quot;删除 %d 后，中序遍历二叉排序树：\n&quot;, x);</span><br><span class="line">    DeleteBST(&amp;T, x);</span><br><span class="line">    midOrder(T);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>直接前驱是指在二叉排序树（BST）中，一个节点的“直接前驱”是在中序遍历中位于该节点之前的节点，即值小于该节点值的最大节点。换句话说，直接前驱是紧邻在该节点之前的节点中的最大节点。</p>
<p>具体来说，假设有一个二叉排序树，并且你希望找到某个节点的直接前驱：</p>
<ol>
<li>如果该节点有左子树，直接前驱是其左子树的最右边节点。因为中序遍历中，左子树的最右节点会位于该节点的左下方。</li>
<li>如果该节点没有左子树，你需要从根节点开始，从上往下搜索，直到找到第一个小于该节点值的节点。这个节点就是直接前驱。</li>
</ol>
<p>直接前驱在二叉排序树中具有重要作用，特别是在删除节点的操作中。当你要删除一个节点时，如果该节点有左子树，你可以找到其直接前驱来替代该节点，从而保持树的结构和有序性。这样的替代操作可以保持二叉排序树的性质不变。</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct BiTNode &#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct BiTNode *lchild, *rchild;</span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>不带星号的情况</strong>：</li>
</ol>
<p>当你声明一个不带星号的变量，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BiTNode node;</span><br></pre></td></tr></table></figure>

<p>这意味着你在声明一个实际的 <code>BiTNode</code> 类型的变量，这个变量将会<strong>存储实际的结构体数据</strong>。你可以直接访问这个变量的成员，比如 <code>node.data</code> 或者 <code>node.lchild</code>。</p>
<ol>
<li><strong>带星号的情况</strong>：</li>
</ol>
<p>当你声明一个带星号的变量，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BiTree ptr;</span><br></pre></td></tr></table></figure>

<p>这意味着你在声明一个指针变量，这个指针变量将用来<strong>存储一个内存地址</strong>，这个地址指向了一个实际的 <code>BiTNode</code> 类型的对象。你可以通过这个指针来访问所指向的实际对象的成员，比如 <code>ptr-&gt;data</code> 或者 <code>ptr-&gt;lchild</code>。</p>
<p>实际上，带星号的变量就是指针，它存储了一个内存地址，而这个地址指向了某个实际的对象（比如结构体）。因此，通过这个指针，你可以在程序中操作和修改实际对象的数据。</p>
<p>总结起来，带星号的变量是指向实际对象的指针，而不带星号的变量则直接存储实际对象的数据。在代码中使用它们的时候，需要根据具体情况来决定是要访问实际对象的数据，还是要操作指向实际对象的指针。</p>
<hr>
<p>中序遍历的过程，按照从小到大的顺序遍历二叉树的所有节点，即先遍历左子树，再遍历根节点，最后遍历右子树。这种遍历方式可以帮助我们得到一个有序的节点序列</p>
<p>前序遍历和后序遍历是二叉树的另外两种遍历方式，与中序遍历不同。下面我会分别解释前序遍历和后序遍历的过程。</p>
<h3 id="前序遍历（Preorder-Traversal）"><a href="#前序遍历（Preorder-Traversal）" class="headerlink" title="前序遍历（Preorder Traversal）"></a>前序遍历（Preorder Traversal）</h3><p>前序遍历是指首先访问根节点，然后按照先左后右的顺序递归地遍历左子树和右子树。</p>
<p>前序遍历的过程：</p>
<ol>
<li>访问当前节点的值。</li>
<li>递归地对左子树进行前序遍历。</li>
<li>递归地对右子树进行前序遍历。</li>
</ol>
<h3 id="后序遍历（Postorder-Traversal）"><a href="#后序遍历（Postorder-Traversal）" class="headerlink" title="后序遍历（Postorder Traversal）"></a>后序遍历（Postorder Traversal）</h3><p>后序遍历是指先递归地遍历左子树和右子树，然后再访问根节点。</p>
<p>后序遍历的过程：</p>
<ol>
<li>递归地对左子树进行后序遍历。</li>
<li>递归地对右子树进行后序遍历。</li>
<li>访问当前节点的值。</li>
</ol>
<p>这两种遍历方式与中序遍历相比，输出节点的顺序有所不同，也会得到不同的遍历结果。</p>
<p>总结起来：</p>
<ul>
<li>前序遍历：根 - 左子树 - 右子树</li>
<li>中序遍历：左子树 - 根 - 右子树</li>
<li>后序遍历：左子树 - 右子树 - 根</li>
</ul>
<p>根据遍历方式的不同，你可以得到不同的节点序列，从而更好地理解二叉树的结构和内容。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/08/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/08/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/" class="post-title-link" itemprop="url">muduo-网络库（1）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-08 11:10:38" itemprop="dateCreated datePublished" datetime="2023-08-08T11:10:38+08:00">2023-08-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-13 15:57:20" itemprop="dateModified" datetime="2023-08-13T15:57:20+08:00">2023-08-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="TCP网络编程本质"><a href="#TCP网络编程本质" class="headerlink" title="TCP网络编程本质"></a>TCP网络编程本质</h1><p>TCP网络编程最本质是处理三个半事件</p>
<ul>
<li>连接建立:服务器accept（被动）接受连接，客户端connect（主动）发起连接</li>
<li>连接断开:主动断开（close、shutdown），被动断开(read返回0)</li>
<li>消息到达:文件描述符可读</li>
<li>消息发送完毕:这算半个。对于低流量的服务，可不必关心这个事件;这里的发送完毕是指数据写入操作系统缓冲区，将由TCP协议栈负责数据的发送与重传不代表对方已经接收到数据。</li>
</ul>
<p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230808151011083.png" alt="image-20230808151011083"></p>
<img src="/2023/08/08/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230808151011083.png" class title="This is an test image">

<p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230808152449591.png" alt="image-20230808152449591"></p>
<p>也是基于对象编程思想</p>
<h1 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h1><ul>
<li>one loop per thread意思是说每个线程最多只能有一个EventLoop对象。</li>
<li>EventLoop对象构造的时候，会检查当前线程是否己经创建了具他EventLoop,如果已创建，终止程序（LOG FATAL)</li>
<li>EventLoop构造函数会记住本对象所属线程（threadld_)</li>
<li>创建了EventLoop对象的线程称为lO线程，其功能是运行事件循环（EventLoop::loop)</li>
</ul>
<h2 id="EventLoop-h部分"><a href="#EventLoop-h部分" class="headerlink" title="EventLoop.h部分"></a>EventLoop.h部分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">class Channel;</span><br><span class="line">class Poller;</span><br><span class="line">class TimerQueue;</span><br><span class="line"></span><br><span class="line">///</span><br><span class="line">/// Reactor, at most one per thread.</span><br><span class="line">///</span><br><span class="line">/// This is an interface class, so don&#x27;t expose too much details.</span><br><span class="line">class EventLoop : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  typedef std::function&lt;void()&gt; Functor;</span><br><span class="line"></span><br><span class="line">  EventLoop();</span><br><span class="line">  ~EventLoop();  // force out-line dtor, for std::unique_ptr members.</span><br><span class="line">  void updateChannel(Channel* channel);//在Poller中添加或更新通道</span><br><span class="line">  void removeChannel(Channel* channel);//从Poller中移除通道</span><br><span class="line">  // pid_t threadId() const &#123; return threadId_; &#125;</span><br><span class="line">  void assertInLoopThread()</span><br><span class="line">  &#123;</span><br><span class="line">    if (!isInLoopThread())</span><br><span class="line">    &#123;</span><br><span class="line">      abortNotInLoopThread();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  bool isInLoopThread() const &#123; return threadId_ == CurrentThread::tid(); &#125;</span><br><span class="line">  // bool callingPendingFunctors() const &#123; return callingPendingFunctors_; &#125;</span><br><span class="line">  bool eventHandling() const &#123; return eventHandling_; &#125;</span><br><span class="line"> private:</span><br><span class="line">  void abortNotInLoopThread();</span><br><span class="line">  void handleRead();  // waked up</span><br><span class="line">  void doPendingFunctors();</span><br><span class="line"></span><br><span class="line">  void printActiveChannels() const; // DEBUG</span><br><span class="line">  typedef std::vector&lt;Channel*&gt; ChannelList;</span><br><span class="line"></span><br><span class="line">  bool looping_; /* atomic */</span><br><span class="line">  std::atomic&lt;bool&gt; quit_;</span><br><span class="line">  bool eventHandling_; /* atomic */</span><br><span class="line">  bool callingPendingFunctors_; /* atomic */</span><br><span class="line">  int64_t iteration_;</span><br><span class="line">  const pid_t threadId_;//当前对象所属线程id</span><br><span class="line">  Timestamp pollReturnTime_;//调用poll返回的时间戳</span><br><span class="line">  std::unique_ptr&lt;Poller&gt; poller_;</span><br><span class="line">  std::unique_ptr&lt;TimerQueue&gt; timerQueue_;</span><br><span class="line">  ChannelList activeChannels_;//Poller返回的活动通道</span><br><span class="line">  Channel* currentActiveChannel_;//当前正在处理的活动通道</span><br><span class="line"></span><br><span class="line">  mutable MutexLock mutex_;</span><br><span class="line">  std::vector&lt;Functor&gt; pendingFunctors_ GUARDED_BY(mutex_);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h2 id="EventLoop-cc部分"><a href="#EventLoop-cc部分" class="headerlink" title="EventLoop.cc部分"></a>EventLoop.cc部分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">namespace</span><br><span class="line">&#123;</span><br><span class="line">//当前线程EventLoop对象指针</span><br><span class="line">//线程局部存储</span><br><span class="line">__thread EventLoop* t_loopInThisThread = 0;//__thread表示每个线程都有这样一个对象</span><br><span class="line"></span><br><span class="line">const int kPollTimeMs = 10000;</span><br><span class="line"></span><br><span class="line">int createEventfd()</span><br><span class="line">&#123;</span><br><span class="line">  int evtfd = ::eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC);</span><br><span class="line">  if (evtfd &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSERR &lt;&lt; &quot;Failed in eventfd&quot;;</span><br><span class="line">    abort();</span><br><span class="line">  &#125;</span><br><span class="line">  return evtfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma GCC diagnostic ignored &quot;-Wold-style-cast&quot;</span><br><span class="line">class IgnoreSigPipe</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  IgnoreSigPipe()</span><br><span class="line">  &#123;</span><br><span class="line">    ::signal(SIGPIPE, SIG_IGN);</span><br><span class="line">    // LOG_TRACE &lt;&lt; &quot;Ignore SIGPIPE&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">#pragma GCC diagnostic error &quot;-Wold-style-cast&quot;</span><br><span class="line"></span><br><span class="line">IgnoreSigPipe initObj;</span><br><span class="line">&#125;  // namespace 代码被放置在了匿名的 namespace 中。这意味着其中的内容只对当前文件中的代码可见，不会对其他文件中的代码造成影响。这在一定程度上隐藏了实现细节，限制了作用域，并且通过将 IgnoreSigPipe 类声明为 private，限制了类在文件之外的可见性。这样可以帮助控制代码的组织和维护，并减少了潜在的命名冲突。</span><br><span class="line">EventLoop* EventLoop::getEventLoopOfCurrentThread()</span><br><span class="line">&#123;</span><br><span class="line">  return t_loopInThisThread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventLoop::EventLoop()</span><br><span class="line">  : looping_(false),</span><br><span class="line">    quit_(false),</span><br><span class="line">    eventHandling_(false),</span><br><span class="line">    callingPendingFunctors_(false),</span><br><span class="line">    iteration_(0),</span><br><span class="line">    threadId_(CurrentThread::tid()),</span><br><span class="line">    poller_(Poller::newDefaultPoller(this)),</span><br><span class="line">    timerQueue_(new TimerQueue(this)),</span><br><span class="line">    wakeupFd_(createEventfd()),</span><br><span class="line">    wakeupChannel_(new Channel(this, wakeupFd_)),</span><br><span class="line">    currentActiveChannel_(NULL)</span><br><span class="line">&#123;</span><br><span class="line">  LOG_DEBUG &lt;&lt; &quot;EventLoop created &quot; &lt;&lt; this &lt;&lt; &quot; in thread &quot; &lt;&lt; threadId_;</span><br><span class="line">  //如果当前线程已经创建了EventLoop对象，终止（LOG_FATAL）</span><br><span class="line">  if (t_loopInThisThread)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_FATAL &lt;&lt; &quot;Another EventLoop &quot; &lt;&lt; t_loopInThisThread</span><br><span class="line">              &lt;&lt; &quot; exists in this thread &quot; &lt;&lt; threadId_;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    t_loopInThisThread = this;</span><br><span class="line">  &#125;</span><br><span class="line">  wakeupChannel_-&gt;setReadCallback(</span><br><span class="line">      std::bind(&amp;EventLoop::handleRead, this));</span><br><span class="line">  // we are always reading the wakeupfd</span><br><span class="line">  wakeupChannel_-&gt;enableReading();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventLoop::~EventLoop()</span><br><span class="line">&#123;</span><br><span class="line">  LOG_DEBUG &lt;&lt; &quot;EventLoop &quot; &lt;&lt; this &lt;&lt; &quot; of thread &quot; &lt;&lt; threadId_</span><br><span class="line">            &lt;&lt; &quot; destructs in thread &quot; &lt;&lt; CurrentThread::tid();</span><br><span class="line">  wakeupChannel_-&gt;disableAll();</span><br><span class="line">  wakeupChannel_-&gt;remove();</span><br><span class="line">  ::close(wakeupFd_);</span><br><span class="line">  t_loopInThisThread = NULL;</span><br><span class="line">&#125;</span><br><span class="line">//事件循环，该函数不能跨线程调用</span><br><span class="line">//只能在创建该对象的线程中调用</span><br><span class="line">void EventLoop::loop()</span><br><span class="line">&#123;</span><br><span class="line">  assert(!looping_);</span><br><span class="line">  assertInLoopThread();//断言当前处于创建该对象的线程中</span><br><span class="line">  looping_ = true;</span><br><span class="line">  quit_ = false;  // FIXME: what if someone calls quit() before loop() ?</span><br><span class="line">  LOG_TRACE &lt;&lt; &quot;EventLoop &quot; &lt;&lt; this &lt;&lt; &quot; start looping&quot;;</span><br><span class="line"></span><br><span class="line">  while (!quit_)</span><br><span class="line">  &#123;</span><br><span class="line">    activeChannels_.clear();</span><br><span class="line">    pollReturnTime_ = poller_-&gt;poll(kPollTimeMs, &amp;activeChannels_);</span><br><span class="line">    ++iteration_;</span><br><span class="line">    if (Logger::logLevel() &lt;= Logger::TRACE)</span><br><span class="line">    &#123;</span><br><span class="line">      printActiveChannels();</span><br><span class="line">    &#125;</span><br><span class="line">    // TODO sort channel by priority</span><br><span class="line">    eventHandling_ = true;</span><br><span class="line">    for (Channel* channel : activeChannels_)</span><br><span class="line">    &#123;</span><br><span class="line">      currentActiveChannel_ = channel;</span><br><span class="line">      currentActiveChannel_-&gt;handleEvent(pollReturnTime_);</span><br><span class="line">    &#125;</span><br><span class="line">    currentActiveChannel_ = NULL;</span><br><span class="line">    eventHandling_ = false;</span><br><span class="line">    doPendingFunctors();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LOG_TRACE &lt;&lt; &quot;EventLoop &quot; &lt;&lt; this &lt;&lt; &quot; stop looping&quot;;</span><br><span class="line">  looping_ = false;</span><br><span class="line">&#125;</span><br><span class="line">void EventLoop::updateChannel(Channel* channel)</span><br><span class="line">&#123;</span><br><span class="line">  assert(channel-&gt;ownerLoop() == this);</span><br><span class="line">  assertInLoopThread();</span><br><span class="line">  poller_-&gt;updateChannel(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void EventLoop::removeChannel(Channel* channel)</span><br><span class="line">&#123;</span><br><span class="line">  assert(channel-&gt;ownerLoop() == this);</span><br><span class="line">  assertInLoopThread();</span><br><span class="line">  if (eventHandling_)</span><br><span class="line">  &#123;</span><br><span class="line">    assert(currentActiveChannel_ == channel ||</span><br><span class="line">        std::find(activeChannels_.begin(), activeChannels_.end(), channel) == activeChannels_.end());</span><br><span class="line">  &#125;</span><br><span class="line">  poller_-&gt;removeChannel(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool EventLoop::hasChannel(Channel* channel)</span><br><span class="line">&#123;</span><br><span class="line">  assert(channel-&gt;ownerLoop() == this);</span><br><span class="line">  assertInLoopThread();</span><br><span class="line">  return poller_-&gt;hasChannel(channel);</span><br><span class="line">&#125;</span><br><span class="line">//终止程序</span><br><span class="line">void EventLoop::abortNotInLoopThread()</span><br><span class="line">&#123;</span><br><span class="line">  LOG_FATAL &lt;&lt; &quot;EventLoop::abortNotInLoopThread - EventLoop &quot; &lt;&lt; this</span><br><span class="line">            &lt;&lt; &quot; was created in threadId_ = &quot; &lt;&lt; threadId_</span><br><span class="line">            &lt;&lt; &quot;, current thread id = &quot; &lt;&lt;  CurrentThread::tid();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="muduo网络库相关类图的关系"><a href="#muduo网络库相关类图的关系" class="headerlink" title="muduo网络库相关类图的关系"></a>muduo网络库相关类图的关系</h1><p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230809104948379.png" alt="image-20230809104948379"></p>
<img src="/2023/08/08/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230809104948379.png" class title="This is an test image">

<p>白色的是外部类，对外是可见的，黑色的是内部类，对外是不可见的</p>
<p>Poller是muduo库唯一一个用面向对象封装的，3个都是纯虚函数。</p>
<p>EventLoop和Poller是组合关系，<strong>一个EventLoop包含一个Poller</strong>，并且Poller生存周期由EventLoop控制，EventLoop的loop函数是调用Poller的poll函数实现的。</p>
<p>Channel是对IO事件的注册与响应的封装，handleEvent对所发生的IO事件进行处理，当调用Channel的update来注册和更新IO的可读可写事件时候，又会调用到EventLoop的updateChannel函数，从而又调用了Poller的updateChannel，相当于把Channel注册到Poller当中，或者说将文件描述符的可读可写事件注册到Poller，<strong>一个EventLoop包含多个Channel</strong>，也就是说可以用来捕捉多个通道的可读可写事件，一对多，<strong>聚合关系</strong>，也就是说不负责Channel生存期控制，并且Channel不拥有文件描述符，也就是说当它销毁的时候不close关闭文件描述符。Channel跟TcpConnection，Acceptor，Connector是组合关系，并且Channel生存周期由他们控制。</p>
<p>FileDescriptor不是一个类，跟Channel是关联关系，<strong>一对一</strong>，<strong>一个EventLoop有多个fd</strong>,FileDescriptor是由Socket拥有的，生存周期由套接字控制。</p>
<p>Acceptor是对被动连接的抽象，关注的是监听套接字的可读事件，这个事件由Channel的handleEvent注册，从而调用了handleRead，是基于对象的编程思想，回调了handleRead。</p>
<p>Connector是对主动连接的抽象，与Acceptor差不多。不管是被动连接还是主动成功后，都会得到一个已连接套接字，对已连接套接字的抽象就是TcpConnection，TcpServer和Acceptor是组合关系，Acceptor生存期由TcpServer控制，但是一个TcpServer有多个TcpConnection，是聚合关系，但是不控制生存期。</p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><ul>
<li>Channel是selectable lO channel，负责注册与响应IO事件，它不拥有file descriptor。</li>
<li>Channel是Acceptor、Connector、EventLoopTimerQueue、TcpConnection的成员，生命期由后者控制。</li>
</ul>
<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230809113131684.png" alt="image-20230809113131684"></p>
<img src="/2023/08/08/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230809113131684.png" class title="This is an test image">

<p><img src="/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230809163337743.png" alt="image-20230809163337743"></p>
<img src="/2023/08/08/muduo-%E7%BD%91%E7%BB%9C%E5%BA%93%EF%BC%881%EF%BC%89/image-20230809163337743.png" class title="This is an test image">

<h2 id="Channel-h"><a href="#Channel-h" class="headerlink" title="Channel.h"></a>Channel.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">class EventLoop;</span><br><span class="line"></span><br><span class="line">///</span><br><span class="line">/// A selectable I/O channel.</span><br><span class="line">///</span><br><span class="line">/// This class doesn&#x27;t own the file descriptor.</span><br><span class="line">/// The file descriptor could be a socket,</span><br><span class="line">/// an eventfd, a timerfd, or a signalfd</span><br><span class="line">class Channel : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  typedef std::function&lt;void()&gt; EventCallback;</span><br><span class="line">  typedef std::function&lt;void(Timestamp)&gt; ReadEventCallback;</span><br><span class="line"></span><br><span class="line">  Channel(EventLoop* loop, int fd);</span><br><span class="line">  ~Channel();</span><br><span class="line"></span><br><span class="line">  void handleEvent(Timestamp receiveTime);</span><br><span class="line">  void setReadCallback(ReadEventCallback cb)</span><br><span class="line">  &#123; readCallback_ = std::move(cb); &#125;</span><br><span class="line">  void setWriteCallback(EventCallback cb)</span><br><span class="line">  &#123; writeCallback_ = std::move(cb); &#125;</span><br><span class="line">  void setCloseCallback(EventCallback cb)</span><br><span class="line">  &#123; closeCallback_ = std::move(cb); &#125;</span><br><span class="line">  void setErrorCallback(EventCallback cb)</span><br><span class="line">  &#123; errorCallback_ = std::move(cb); &#125;</span><br><span class="line"></span><br><span class="line">  /// Tie this channel to the owner object managed by shared_ptr,</span><br><span class="line">  /// prevent the owner object being destroyed in handleEvent.</span><br><span class="line">  void tie(const std::shared_ptr&lt;void&gt;&amp;);</span><br><span class="line"></span><br><span class="line">  int fd() const &#123; return fd_; &#125;</span><br><span class="line">  int events() const &#123; return events_; &#125;</span><br><span class="line">  void set_revents(int revt) &#123; revents_ = revt; &#125; // used by pollers</span><br><span class="line">  // int revents() const &#123; return revents_; &#125;</span><br><span class="line">  bool isNoneEvent() const &#123; return events_ == kNoneEvent; &#125;</span><br><span class="line"></span><br><span class="line">  void enableReading() &#123; events_ |= kReadEvent; update(); &#125;</span><br><span class="line">  void disableReading() &#123; events_ &amp;= ~kReadEvent; update(); &#125;</span><br><span class="line">  void enableWriting() &#123; events_ |= kWriteEvent; update(); &#125;</span><br><span class="line">  void disableWriting() &#123; events_ &amp;= ~kWriteEvent; update(); &#125;</span><br><span class="line">  void disableAll() &#123; events_ = kNoneEvent; update(); &#125;</span><br><span class="line">  bool isWriting() const &#123; return events_ &amp; kWriteEvent; &#125;</span><br><span class="line">  bool isReading() const &#123; return events_ &amp; kReadEvent; &#125;</span><br><span class="line"></span><br><span class="line">  // for Poller</span><br><span class="line">  int index() &#123; return index_; &#125;</span><br><span class="line">  void set_index(int idx) &#123; index_ = idx; &#125;</span><br><span class="line"></span><br><span class="line">  // for debug</span><br><span class="line">  string reventsToString() const;</span><br><span class="line">  string eventsToString() const;</span><br><span class="line"></span><br><span class="line">  void doNotLogHup() &#123; logHup_ = false; &#125;</span><br><span class="line"></span><br><span class="line">  EventLoop* ownerLoop() &#123; return loop_; &#125;</span><br><span class="line">  void remove();</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  static string eventsToString(int fd, int ev);</span><br><span class="line"></span><br><span class="line">  void update();</span><br><span class="line">  void handleEventWithGuard(Timestamp receiveTime);</span><br><span class="line"></span><br><span class="line">  static const int kNoneEvent;</span><br><span class="line">  static const int kReadEvent;</span><br><span class="line">  static const int kWriteEvent;</span><br><span class="line"></span><br><span class="line">  EventLoop* loop_;//所属EventLoop</span><br><span class="line">  const int  fd_;//文件描述符，但不负责关闭</span><br><span class="line">  int        events_;//关注的事件</span><br><span class="line">  int        revents_; // it&#x27;s the received event types of epoll or poll，poll/epoll返回的事件</span><br><span class="line">  int        index_; // used by Poller.表示在poll的事件数组中的序号</span><br><span class="line">  bool       logHup_;</span><br><span class="line"></span><br><span class="line">  std::weak_ptr&lt;void&gt; tie_;</span><br><span class="line">  bool tied_;</span><br><span class="line">  bool eventHandling_;//是否处于处理事件中</span><br><span class="line">  bool addedToLoop_;</span><br><span class="line">  ReadEventCallback readCallback_;</span><br><span class="line">  EventCallback writeCallback_;</span><br><span class="line">  EventCallback closeCallback_;</span><br><span class="line">  EventCallback errorCallback_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br></pre></td></tr></table></figure>

<h2 id="Channel-cc"><a href="#Channel-cc" class="headerlink" title="Channel.cc"></a>Channel.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">const int Channel::kNoneEvent = 0;</span><br><span class="line">const int Channel::kReadEvent = POLLIN | POLLPRI;</span><br><span class="line">const int Channel::kWriteEvent = POLLOUT;</span><br><span class="line"></span><br><span class="line">Channel::Channel(EventLoop* loop, int fd__)</span><br><span class="line">  : loop_(loop),</span><br><span class="line">    fd_(fd__),</span><br><span class="line">    events_(0),</span><br><span class="line">    revents_(0),</span><br><span class="line">    index_(-1),</span><br><span class="line">    logHup_(true),</span><br><span class="line">    tied_(false),</span><br><span class="line">    eventHandling_(false),</span><br><span class="line">    addedToLoop_(false)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Channel::~Channel()</span><br><span class="line">&#123;</span><br><span class="line">  assert(!eventHandling_);</span><br><span class="line">  assert(!addedToLoop_);</span><br><span class="line">  if (loop_-&gt;isInLoopThread())</span><br><span class="line">  &#123;</span><br><span class="line">    assert(!loop_-&gt;hasChannel(this));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Channel::tie(const std::shared_ptr&lt;void&gt;&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">  tie_ = obj;</span><br><span class="line">  tied_ = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Channel::update()</span><br><span class="line">&#123;</span><br><span class="line">  addedToLoop_ = true;</span><br><span class="line">  loop_-&gt;updateChannel(this);</span><br><span class="line">&#125;</span><br><span class="line">//调用这个函数之前确保调用disableAll</span><br><span class="line">void Channel::remove()</span><br><span class="line">&#123;</span><br><span class="line">  assert(isNoneEvent());</span><br><span class="line">  addedToLoop_ = false;</span><br><span class="line">  loop_-&gt;removeChannel(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Channel::handleEvent(Timestamp receiveTime)</span><br><span class="line">&#123;</span><br><span class="line">  std::shared_ptr&lt;void&gt; guard;</span><br><span class="line">  if (tied_)</span><br><span class="line">  &#123;</span><br><span class="line">    guard = tie_.lock();//tie_.lock() 是用于从 std::weak_ptr 类型对象获取其关联的 std::shared_ptr 对象的方法</span><br><span class="line">    //在 Channel::handleEvent() 函数中，tie_.lock() 被用来获取与 tie_ 关联的 std::shared_ptr&lt;void&gt;，如果该 std::shared_ptr 有效，则执行相关的事件处理。这种方式可以确保在事件处理期间，与 Channel 关联的对象仍然有效，避免了因为对象被释放而导致的问题。</span><br><span class="line">    if (guard)</span><br><span class="line">    &#123;</span><br><span class="line">      handleEventWithGuard(receiveTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    handleEventWithGuard(receiveTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">void Channel::handleEventWithGuard(Timestamp receiveTime)</span><br><span class="line">&#123;</span><br><span class="line">  eventHandling_ = true;</span><br><span class="line">  LOG_TRACE &lt;&lt; reventsToString();</span><br><span class="line">  if ((revents_ &amp; POLLHUP) &amp;&amp; !(revents_ &amp; POLLIN))//如果发生了挂起事件，并且没有发生可读事件</span><br><span class="line">  &#123;</span><br><span class="line">    if (logHup_)</span><br><span class="line">    &#123;</span><br><span class="line">      LOG_WARN &lt;&lt; &quot;fd = &quot; &lt;&lt; fd_ &lt;&lt; &quot; Channel::handle_event() POLLHUP&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    if (closeCallback_) closeCallback_();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (revents_ &amp; POLLNVAL)//fd not open</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_WARN &lt;&lt; &quot;fd = &quot; &lt;&lt; fd_ &lt;&lt; &quot; Channel::handle_event() POLLNVAL&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (revents_ &amp; (POLLERR | POLLNVAL))</span><br><span class="line">  &#123;</span><br><span class="line">    if (errorCallback_) errorCallback_();</span><br><span class="line">  &#125;</span><br><span class="line">  if (revents_ &amp; (POLLIN | POLLPRI | POLLRDHUP))</span><br><span class="line">  &#123;</span><br><span class="line">    if (readCallback_) readCallback_(receiveTime);</span><br><span class="line">  &#125;</span><br><span class="line">  if (revents_ &amp; POLLOUT)</span><br><span class="line">  &#123;</span><br><span class="line">    if (writeCallback_) writeCallback_();</span><br><span class="line">  &#125;</span><br><span class="line">  eventHandling_ = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string Channel::reventsToString() const</span><br><span class="line">&#123;</span><br><span class="line">  return eventsToString(fd_, revents_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string Channel::eventsToString() const</span><br><span class="line">&#123;</span><br><span class="line">  return eventsToString(fd_, events_);</span><br><span class="line">&#125;</span><br><span class="line">//用来调试的，发生了什么事件</span><br><span class="line">string Channel::eventsToString(int fd, int ev)</span><br><span class="line">&#123;</span><br><span class="line">  std::ostringstream oss;</span><br><span class="line">  oss &lt;&lt; fd &lt;&lt; &quot;: &quot;;</span><br><span class="line">  if (ev &amp; POLLIN)</span><br><span class="line">    oss &lt;&lt; &quot;IN &quot;;</span><br><span class="line">  if (ev &amp; POLLPRI)</span><br><span class="line">    oss &lt;&lt; &quot;PRI &quot;;</span><br><span class="line">  if (ev &amp; POLLOUT)</span><br><span class="line">    oss &lt;&lt; &quot;OUT &quot;;</span><br><span class="line">  if (ev &amp; POLLHUP)</span><br><span class="line">    oss &lt;&lt; &quot;HUP &quot;;</span><br><span class="line">  if (ev &amp; POLLRDHUP)</span><br><span class="line">    oss &lt;&lt; &quot;RDHUP &quot;;</span><br><span class="line">  if (ev &amp; POLLERR)</span><br><span class="line">    oss &lt;&lt; &quot;ERR &quot;;</span><br><span class="line">  if (ev &amp; POLLNVAL)</span><br><span class="line">    oss &lt;&lt; &quot;NVAL &quot;;</span><br><span class="line"></span><br><span class="line">  return oss.str();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Channel::tie(const std::shared_ptr&lt;void&gt;&amp; obj)</code> 函数的功能是在 <code>Channel</code> 类中设置一个关联对象，以便在事件处理期间使用。这个函数在事件循环中处理事件时很有用，可以保证关联的对象在事件处理期间有效，避免在处理过程中被释放导致的错误。</p>
<p>在具体代码中，函数的作用如下：</p>
<ol>
<li>接受一个 <code>std::shared_ptr&lt;void&gt;</code> 类型的参数 <code>obj</code>，这是一个指向任意类型的 <code>std::shared_ptr</code> 智能指针。<code>std::shared_ptr</code> 是一个可以共享拥有资源所有权的智能指针，它可以确保资源在不再需要时自动释放。</li>
<li>将传入的 <code>obj</code> 赋值给成员变量 <code>tie_</code>，这是一个 <code>std::weak_ptr&lt;void&gt;</code> 类型的成员变量。<code>std::weak_ptr</code> 是一种弱引用指针，它不会增加资源的引用计数，也不会阻止资源的释放。</li>
<li>将成员变量 <code>tied_</code> 设置为 <code>true</code>，表示已经关联了一个对象。</li>
</ol>
<p>函数的目的是在事件处理期间保证相关联的对象不会被提前释放。在事件处理函数 <code>Channel::handleEvent()</code> 中，首先会检查 <code>tied_</code> 是否为 <code>true</code>，如果是，就会尝试使用 <code>std::shared_ptr&lt;void&gt;</code> 类型的 <code>guard</code> 对象来保持关联对象的有效性。这样可以防止在处理事件时，关联对象已经被释放导致的问题。</p>
<p>总之，<code>Channel::tie()</code> 函数允许用户将一个智能指针与 <code>Channel</code> 对象关联起来，以确保在事件处理期间关联对象不会被过早地释放，从而增强了代码的健壮性。这在多线程环境中尤其有用，可以避免悬空指针和资源竞争等问题。</p>
<h2 id="Poller-h"><a href="#Poller-h" class="headerlink" title="Poller.h"></a>Poller.h</h2><p>是面向对象实现的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">class Channel;</span><br><span class="line"></span><br><span class="line">///</span><br><span class="line">/// Base class for IO Multiplexing</span><br><span class="line">///</span><br><span class="line">/// This class doesn&#x27;t own the Channel objects.</span><br><span class="line">class Poller : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  typedef std::vector&lt;Channel*&gt; ChannelList;</span><br><span class="line"></span><br><span class="line">  Poller(EventLoop* loop);</span><br><span class="line">  virtual ~Poller();</span><br><span class="line"></span><br><span class="line">  /// Polls the I/O events.</span><br><span class="line">  /// Must be called in the loop thread.</span><br><span class="line">  virtual Timestamp poll(int timeoutMs, ChannelList* activeChannels) = 0;</span><br><span class="line"></span><br><span class="line">  /// Changes the interested I/O events.</span><br><span class="line">  /// Must be called in the loop thread.</span><br><span class="line">  virtual void updateChannel(Channel* channel) = 0;</span><br><span class="line"></span><br><span class="line">  /// Remove the channel, when it destructs.</span><br><span class="line">  /// Must be called in the loop thread.</span><br><span class="line">  virtual void removeChannel(Channel* channel) = 0;</span><br><span class="line"></span><br><span class="line">  virtual bool hasChannel(Channel* channel) const;</span><br><span class="line"></span><br><span class="line">  static Poller* newDefaultPoller(EventLoop* loop);</span><br><span class="line"></span><br><span class="line">  void assertInLoopThread() const</span><br><span class="line">  &#123;</span><br><span class="line">    ownerLoop_-&gt;assertInLoopThread();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> protected:</span><br><span class="line">  typedef std::map&lt;int, Channel*&gt; ChannelMap;</span><br><span class="line">  ChannelMap channels_;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  EventLoop* ownerLoop_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br></pre></td></tr></table></figure>

<p>在代码片段中，<code>class Channel;</code> 的写法在 <code>namespace muduo::net</code> 命名空间中的作用是进行前向声明（forward declaration）。</p>
<p>前向声明是一种在编译器还未看到实际类定义的情况下，告诉编译器某个类的存在的方式。这在处理循环引用（circular dependencies）或减少编译依赖性时非常有用。在这个特定的情况下，前向声明的目的是在 <code>Poller</code> 类中声明一个指向 <code>Channel</code> 类的指针或引用，而不需要知道 <code>Channel</code> 类的完整定义。</p>
<p>具体来说，<code>class Channel;</code> 的作用是：</p>
<ol>
<li><strong>解决编译依赖性问题：</strong> 如果在 <code>Poller</code> 类中包含了 <code>Channel</code> 类的完整定义，那么在编译 <code>Poller</code> 类时，编译器会需要知道 <code>Channel</code> 类的所有细节。而如果 <code>Channel</code> 类也依赖于 <code>Poller</code> 类，就会导致循环依赖，从而编译错误。通过使用前向声明，<code>Poller</code> 类可以在不知道 <code>Channel</code> 类的完整定义的情况下编译，从而解决了这种依赖性问题。</li>
<li><strong>降低编译时间：</strong> 前向声明可以减少编译时间，因为编译器不需要读取和处理完整的 <code>Channel</code> 类定义，而只需要知道有一个名为 <code>Channel</code> 的类存在即可。</li>
<li><strong>避免不必要的头文件包含：</strong> 如果不需要在 <code>Poller</code> 类中使用 <code>Channel</code> 类的成员变量或方法，而只需要一个指针或引用，那么可以通过前向声明避免包含 <code>Channel</code> 类的完整头文件，从而减少编译依赖和编译时间。</li>
</ol>
<p>综上所述，<code>class Channel;</code> 的写法在这个上下文中用于进行前向声明，以解决编译依赖性问题和提高编译效率。这是 C++ 中常见的用法，可以帮助代码模块化和降低耦合度。</p>
<h2 id="Poller-cc"><a href="#Poller-cc" class="headerlink" title="Poller.cc"></a>Poller.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">Poller::Poller(EventLoop* loop)</span><br><span class="line">  : ownerLoop_(loop)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Poller::~Poller() = default;</span><br><span class="line"></span><br><span class="line">bool Poller::hasChannel(Channel* channel) const</span><br><span class="line">&#123;</span><br><span class="line">  assertInLoopThread();</span><br><span class="line">  ChannelMap::const_iterator it = channels_.find(channel-&gt;fd());</span><br><span class="line">  return it != channels_.end() &amp;&amp; it-&gt;second == channel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="PollPoller-h"><a href="#PollPoller-h" class="headerlink" title="PollPoller.h"></a>PollPoller.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">struct pollfd;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace net</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">///</span><br><span class="line">/// IO Multiplexing with poll(2).</span><br><span class="line">///</span><br><span class="line">class PollPoller : public Poller</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line"></span><br><span class="line">  PollPoller(EventLoop* loop);</span><br><span class="line">  ~PollPoller() override;</span><br><span class="line"></span><br><span class="line">  Timestamp poll(int timeoutMs, ChannelList* activeChannels) override;</span><br><span class="line">  void updateChannel(Channel* channel) override;</span><br><span class="line">  void removeChannel(Channel* channel) override;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  void fillActiveChannels(int numEvents,</span><br><span class="line">                          ChannelList* activeChannels) const;</span><br><span class="line"></span><br><span class="line">  typedef std::vector&lt;struct pollfd&gt; PollFdList;</span><br><span class="line">  PollFdList pollfds_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace net</span><br><span class="line">&#125;  // namespace muduo</span><br></pre></td></tr></table></figure>

<h2 id="PollPoller-cc"><a href="#PollPoller-cc" class="headerlink" title="PollPoller.cc"></a>PollPoller.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::net;</span><br><span class="line"></span><br><span class="line">PollPoller::PollPoller(EventLoop* loop)</span><br><span class="line">  : Poller(loop)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PollPoller::~PollPoller() = default;</span><br><span class="line"></span><br><span class="line">Timestamp PollPoller::poll(int timeoutMs, ChannelList* activeChannels)</span><br><span class="line">&#123;</span><br><span class="line">  // XXX pollfds_ shouldn&#x27;t change</span><br><span class="line">  int numEvents = ::poll(&amp;*pollfds_.begin(), pollfds_.size(), timeoutMs);</span><br><span class="line">  int savedErrno = errno;</span><br><span class="line">  Timestamp now(Timestamp::now());</span><br><span class="line">  if (numEvents &gt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_TRACE &lt;&lt; numEvents &lt;&lt; &quot; events happened&quot;;</span><br><span class="line">    fillActiveChannels(numEvents, activeChannels);//loop调用，pollReturnTime_ = poller_-&gt;poll(kPollTimeMs, &amp;activeChannels_);是一个地址传递</span><br><span class="line">  &#125;</span><br><span class="line">  else if (numEvents == 0)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_TRACE &lt;&lt; &quot; nothing happened&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    if (savedErrno != EINTR)</span><br><span class="line">    &#123;</span><br><span class="line">      errno = savedErrno;</span><br><span class="line">      LOG_SYSERR &lt;&lt; &quot;PollPoller::poll()&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PollPoller::fillActiveChannels(int numEvents,</span><br><span class="line">                                    ChannelList* activeChannels) const</span><br><span class="line">&#123;</span><br><span class="line">  for (PollFdList::const_iterator pfd = pollfds_.begin();</span><br><span class="line">      pfd != pollfds_.end() &amp;&amp; numEvents &gt; 0; ++pfd)</span><br><span class="line">  &#123;</span><br><span class="line">    if (pfd-&gt;revents &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      --numEvents;</span><br><span class="line">      //声明了一个常量迭代器ch</span><br><span class="line">      ChannelMap::const_iterator ch = channels_.find(pfd-&gt;fd);</span><br><span class="line">      assert(ch != channels_.end());</span><br><span class="line">      Channel* channel = ch-&gt;second;//second成员是std::map中键值对的值部分</span><br><span class="line">      assert(channel-&gt;fd() == pfd-&gt;fd);</span><br><span class="line">      channel-&gt;set_revents(pfd-&gt;revents);</span><br><span class="line">      // pfd-&gt;revents = 0;</span><br><span class="line">      activeChannels-&gt;push_back(channel);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//注册和更新事件</span><br><span class="line">void PollPoller::updateChannel(Channel* channel)</span><br><span class="line">&#123;</span><br><span class="line">  Poller::assertInLoopThread();</span><br><span class="line">  LOG_TRACE &lt;&lt; &quot;fd = &quot; &lt;&lt; channel-&gt;fd() &lt;&lt; &quot; events = &quot; &lt;&lt; channel-&gt;events();</span><br><span class="line">  if (channel-&gt;index() &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    //index小于0说明是一个新通道</span><br><span class="line">    // a new one, add to pollfds_</span><br><span class="line">    //断言在 channels_ 容器中不能找到具有与 channel 对象相同文件描述符的 Channel 对象</span><br><span class="line">    assert(channels_.find(channel-&gt;fd()) == channels_.end());</span><br><span class="line">    struct pollfd pfd;</span><br><span class="line">    pfd.fd = channel-&gt;fd();</span><br><span class="line">    pfd.events = static_cast&lt;short&gt;(channel-&gt;events());</span><br><span class="line">    pfd.revents = 0;</span><br><span class="line">    pollfds_.push_back(pfd);</span><br><span class="line">    int idx = static_cast&lt;int&gt;(pollfds_.size())-1;</span><br><span class="line">    channel-&gt;set_index(idx);</span><br><span class="line">    channels_[pfd.fd] = channel;//key是文件描述符，值是channel</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    // update existing one</span><br><span class="line">    assert(channels_.find(channel-&gt;fd()) != channels_.end());</span><br><span class="line">    assert(channels_[channel-&gt;fd()] == channel);</span><br><span class="line">    int idx = channel-&gt;index();</span><br><span class="line">    assert(0 &lt;= idx &amp;&amp; idx &lt; static_cast&lt;int&gt;(pollfds_.size()));</span><br><span class="line">    struct pollfd&amp; pfd = pollfds_[idx];//引用，不需要拷贝</span><br><span class="line">    assert(pfd.fd == channel-&gt;fd() || pfd.fd == -channel-&gt;fd()-1);</span><br><span class="line">    pfd.fd = channel-&gt;fd();</span><br><span class="line">    pfd.events = static_cast&lt;short&gt;(channel-&gt;events());</span><br><span class="line">    pfd.revents = 0;</span><br><span class="line">    //将一个通道暂时更改为不关注事件，但不从Poller中移除该通道</span><br><span class="line">    if (channel-&gt;isNoneEvent())</span><br><span class="line">    &#123;</span><br><span class="line">      // ignore this pollfd</span><br><span class="line">      //暂时忽略该文件描述符的事件</span><br><span class="line">      //这里pfd.fd可以直接设置为-1</span><br><span class="line">      pfd.fd = -channel-&gt;fd()-1;//这样子设置是为了removeChannel优化</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//移除调用removeChannel之前一定要设置成不关注事件，即要先调用isNoneEvent()</span><br><span class="line">void PollPoller::removeChannel(Channel* channel)</span><br><span class="line">&#123;</span><br><span class="line">  Poller::assertInLoopThread();</span><br><span class="line">  LOG_TRACE &lt;&lt; &quot;fd = &quot; &lt;&lt; channel-&gt;fd();</span><br><span class="line">  assert(channels_.find(channel-&gt;fd()) != channels_.end());</span><br><span class="line">  assert(channels_[channel-&gt;fd()] == channel);</span><br><span class="line">  assert(channel-&gt;isNoneEvent());</span><br><span class="line">  int idx = channel-&gt;index();</span><br><span class="line">  assert(0 &lt;= idx &amp;&amp; idx &lt; static_cast&lt;int&gt;(pollfds_.size()));</span><br><span class="line">  const struct pollfd&amp; pfd = pollfds_[idx]; (void)pfd;</span><br><span class="line">  assert(pfd.fd == -channel-&gt;fd()-1 &amp;&amp; pfd.events == channel-&gt;events());</span><br><span class="line">  size_t n = channels_.erase(channel-&gt;fd());</span><br><span class="line">  assert(n == 1); (void)n;</span><br><span class="line">  if (implicit_cast&lt;size_t&gt;(idx) == pollfds_.size()-1)</span><br><span class="line">  &#123;</span><br><span class="line">    //如果是最后一个</span><br><span class="line">    pollfds_.pop_back();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    //这里移除的算法复杂度是O(1)，将待删除元素与最后一个元素交换再pop_back</span><br><span class="line">    int channelAtEnd = pollfds_.back().fd;</span><br><span class="line">    iter_swap(pollfds_.begin()+idx, pollfds_.end()-1);</span><br><span class="line">    if (channelAtEnd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      channelAtEnd = -channelAtEnd-1;</span><br><span class="line">    &#125;</span><br><span class="line">    channels_[channelAtEnd]-&gt;set_index(idx);</span><br><span class="line">    pollfds_.pop_back();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/04/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%884%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/04/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%884%EF%BC%89/" class="post-title-link" itemprop="url">muduo-基础库（4）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-04 15:25:09" itemprop="dateCreated datePublished" datetime="2023-08-04T15:25:09+08:00">2023-08-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-07 16:37:16" itemprop="dateModified" datetime="2023-08-07T16:37:16+08:00">2023-08-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="日志类封装"><a href="#日志类封装" class="headerlink" title="日志类封装"></a>日志类封装</h1><h2 id="日志作用"><a href="#日志作用" class="headerlink" title="日志作用"></a>日志作用</h2><p>开发过程中:</p>
<ul>
<li>调试错误</li>
<li>更好的理解程序</li>
</ul>
<p>运行过程中:</p>
<ul>
<li><p>诊断系统故障并处理</p>
</li>
<li><p>记录系统运行状态</p>
</li>
</ul>
<h2 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h2><p>TRACE</p>
<ul>
<li>指出比DEBUG粒度更细的一些信息事件（开发过程中使用)</li>
</ul>
<p>DEBUG</p>
<ul>
<li>指出细粒度信息事件对调试应用程序是非常有帮助的。(开发过程中使用)</li>
</ul>
<p>INFO</p>
<ul>
<li>表明消息在粗粒度级别上突出强调应用程序的运行过程。</li>
</ul>
<p>WARN</p>
<ul>
<li>系统能正常运行，但可能会出现潜在错误的情形。</li>
</ul>
<p>ERROR</p>
<ul>
<li>指出虽然发生错误事件，但仍然不影响系统的继续运行。</li>
</ul>
<p>FATAL</p>
<ul>
<li>指出每个严重的错误事件将会导致应用程序的退出。</li>
</ul>
<h2 id="Logger使用时序图"><a href="#Logger使用时序图" class="headerlink" title="Logger使用时序图"></a>Logger使用时序图</h2><p>Logger &#x3D;&gt; lmpl &#x3D;&gt; LogStream &#x3D;&gt; operator&lt;&lt;FixedBuffer &#x3D;&gt; g_output &#x3D;&gt; g_flush</p>
<p>Logger：最外层的日志类</p>
<p>Impl:内部实际的实现，比如如何格式化日志</p>
<p> LogStream ：Impl类借助于它来输出日志，输出到FixedBuffer 缓冲区</p>
<p>g_output：标准输出或文件</p>
<p>g_flush：清空，写到文件里面,是将输出缓冲区中的数据立即刷新（写入）到相应的输出流（此处是标准输出流 <code>stdout</code>）</p>
<p><img src="/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%884%EF%BC%89/image-20230804163115384.png" alt="image-20230804163115384"></p>
<img src="/2023/08/04/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%884%EF%BC%89/image-20230804163115384.png" class title="This is an test image">

<p>使用的时候：比如<code>LOG_TRACE &lt;&lt; &quot;trace CST&quot;</code>;首先调用匿名对象构造，调用stream(),实际上是调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LogStream&amp; stream() &#123; return impl_.stream_; &#125;</span><br></pre></td></tr></table></figure>

<p>也就格式化了一些数据到缓冲区了，比如时间，<code>LOG_TRACE &lt;&lt; &quot;trace CST&quot;</code>;这句话执行完毕，无名对象就要被销毁，调用析构函数。</p>
<p>相关函数</p>
<h3 id="Logging-h"><a href="#Logging-h" class="headerlink" title="Logging.h"></a>Logging.h</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">class TimeZone;</span><br><span class="line"></span><br><span class="line">class Logger</span><br><span class="line">&#123;</span><br><span class="line">public</span><br><span class="line">	enum LogLevel//从上往下0开始，一共有NUM_LOG_LEVELS=6个级别</span><br><span class="line">	  &#123;</span><br><span class="line">	    TRACE,</span><br><span class="line">	    DEBUG,</span><br><span class="line">	    INFO,</span><br><span class="line">	    WARN,</span><br><span class="line">	    ERROR,</span><br><span class="line">	    FATAL,</span><br><span class="line">	    NUM_LOG_LEVELS,</span><br><span class="line">	  &#125;;</span><br><span class="line">	  </span><br><span class="line">	  </span><br><span class="line">	LogStream&amp; stream() &#123; return impl_.stream_; &#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	typedef void (*OutputFunc)(const char* msg, int len);</span><br><span class="line">	  typedef void (*FlushFunc)();</span><br><span class="line">	  static void setOutput(OutputFunc);</span><br><span class="line">	  static void setFlush(FlushFunc);</span><br><span class="line">	  static void setTimeZone(const TimeZone&amp; tz);</span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">	class Impl//实际是Logger类内部的嵌套类，还负责日志的格式化</span><br><span class="line">	&#123;</span><br><span class="line">	 public:</span><br><span class="line">	  typedef Logger::LogLevel LogLevel;</span><br><span class="line">	  Impl(LogLevel level, int old_errno, const SourceFile&amp; file, int line);</span><br><span class="line">	  void formatTime();</span><br><span class="line">	  void finish();</span><br><span class="line">	</span><br><span class="line">	  Timestamp time_;</span><br><span class="line">	  LogStream stream_;</span><br><span class="line">	  LogLevel level_;</span><br><span class="line">	  int line_;</span><br><span class="line">	  SourceFile basename_;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	  Impl impl_;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line">extern Logger::LogLevel g_logLevel;//设置级别</span><br><span class="line"></span><br><span class="line">inline Logger::LogLevel Logger::logLevel()//static inline muduo::Logger::LogLevel muduo::Logger::logLevel()</span><br><span class="line">&#123;</span><br><span class="line">  return g_logLevel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//因为logLevel()大于后面的，所以最高级别只输出INFO</span><br><span class="line">#define LOG_TRACE if (muduo::Logger::logLevel() &lt;= muduo::Logger::TRACE) \</span><br><span class="line">  muduo::Logger(__FILE__, __LINE__, muduo::Logger::TRACE, __func__).stream()//调用的是匿名对象，会调用析构</span><br><span class="line">#define LOG_DEBUG if (muduo::Logger::logLevel() &lt;= muduo::Logger::DEBUG) \</span><br><span class="line">  muduo::Logger(__FILE__, __LINE__, muduo::Logger::DEBUG, __func__).stream()</span><br><span class="line">#define LOG_INFO if (muduo::Logger::logLevel() &lt;= muduo::Logger::INFO) \</span><br><span class="line">  muduo::Logger(__FILE__, __LINE__).stream()</span><br><span class="line">#define LOG_WARN muduo::Logger(__FILE__, __LINE__, muduo::Logger::WARN).stream()</span><br><span class="line">#define LOG_ERROR muduo::Logger(__FILE__, __LINE__, muduo::Logger::ERROR).stream()</span><br><span class="line">#define LOG_FATAL muduo::Logger(__FILE__, __LINE__, muduo::Logger::FATAL).stream()</span><br><span class="line">#define LOG_SYSERR muduo::Logger(__FILE__, __LINE__, false).stream()//false表示不会退出程序</span><br><span class="line">#define LOG_SYSFATAL muduo::Logger(__FILE__, __LINE__, true).stream()//true表示FATAL级别会退出程序</span><br></pre></td></tr></table></figure>

<h3 id="Logging-cc"><a href="#Logging-cc" class="headerlink" title="Logging.cc"></a>Logging.cc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">Logger::LogLevel initLogLevel()//这里可以更改级别，比如直接return Logger::TRACE;</span><br><span class="line">&#123;</span><br><span class="line">  if (::getenv(&quot;MUDUO_LOG_TRACE&quot;))</span><br><span class="line">    return Logger::TRACE;</span><br><span class="line">  else if (::getenv(&quot;MUDUO_LOG_DEBUG&quot;))</span><br><span class="line">    return Logger::DEBUG;</span><br><span class="line">  else</span><br><span class="line">    return Logger::INFO;</span><br><span class="line">&#125;</span><br><span class="line">Logger::LogLevel g_logLevel = initLogLevel();//设置级别</span><br><span class="line">const char* LogLevelName[Logger::NUM_LOG_LEVELS] =</span><br><span class="line">&#123;</span><br><span class="line">  &quot;TRACE &quot;,</span><br><span class="line">  &quot;DEBUG &quot;,</span><br><span class="line">  &quot;INFO  &quot;,</span><br><span class="line">  &quot;WARN  &quot;,</span><br><span class="line">  &quot;ERROR &quot;,</span><br><span class="line">  &quot;FATAL &quot;,</span><br><span class="line">&#125;;</span><br><span class="line">// helper class for known string length at compile time</span><br><span class="line">class T</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  T(const char* str, unsigned len)</span><br><span class="line">    :str_(str),</span><br><span class="line">     len_(len)</span><br><span class="line">  &#123;</span><br><span class="line">    assert(strlen(str) == len_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const char* str_;</span><br><span class="line">  const unsigned len_;</span><br><span class="line">&#125;;</span><br><span class="line">void defaultOutput(const char* msg, int len)</span><br><span class="line">&#123;</span><br><span class="line">  size_t n = fwrite(msg, 1, len, stdout);</span><br><span class="line">  //FIXME check n</span><br><span class="line">  (void)n;</span><br><span class="line">  //在这段代码中，fwrite 函数用于将数据写入到标准输出流 stdout 中。fwrite 的返回值是写入成功的数据项个数，通常用 size_t 类型表示。在实际应用中，为了避免编译器的未使用变量警告，常常使用 (void)n; 这样的语句来“使用”变量 n，以便在代码中明确表达它是有意的、预期的未使用状态。</span><br><span class="line"></span><br><span class="line">  //在一些编译器中，未使用变量可能会导致警告，因为它可能表明代码逻辑有问题。通过使用 (void)n; 这样的语句，开发者可以明确表示这个变量是有意的未使用状态，从而避免编译器警告，同时保持代码的清晰和易读.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void defaultFlush()</span><br><span class="line">&#123;</span><br><span class="line">  fflush(stdout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Logger::OutputFunc g_output = defaultOutput;</span><br><span class="line">//typedef void (*OutputFunc)(const char* msg, int len);--&gt;&gt;void g_output(const char* msg, int len)</span><br><span class="line">Logger::FlushFunc g_flush = defaultFlush;</span><br><span class="line">TimeZone g_logTimeZone;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo这是一个 C++ 中的命名空间（namespace）定义示例，名为 muduo，可以通过 muduo:: 前缀来访问命名空间内的成员</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line"></span><br><span class="line">Logger::Impl::Impl(LogLevel level, int savedErrno, const SourceFile&amp; file, int line)</span><br><span class="line">  : time_(Timestamp::now()),</span><br><span class="line">    stream_(),</span><br><span class="line">    level_(level),</span><br><span class="line">    line_(line),</span><br><span class="line">    basename_(file)</span><br><span class="line">&#123;</span><br><span class="line">  formatTime();</span><br><span class="line">  CurrentThread::tid();//缓存一下当前线程的id</span><br><span class="line">  stream_ &lt;&lt; T(CurrentThread::tidString(), CurrentThread::tidStringLength());</span><br><span class="line">  stream_ &lt;&lt; T(LogLevelName[level], 6);</span><br><span class="line">  if (savedErrno != 0)</span><br><span class="line">  &#123;</span><br><span class="line">    stream_ &lt;&lt; strerror_tl(savedErrno) &lt;&lt; &quot; (errno=&quot; &lt;&lt; savedErrno &lt;&lt; &quot;) &quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Logger::Impl::formatTime()</span><br><span class="line">&#123;</span><br><span class="line">  int64_t microSecondsSinceEpoch = time_.microSecondsSinceEpoch();</span><br><span class="line">  time_t seconds = static_cast&lt;time_t&gt;(microSecondsSinceEpoch / Timestamp::kMicroSecondsPerSecond);</span><br><span class="line">  int microseconds = static_cast&lt;int&gt;(microSecondsSinceEpoch % Timestamp::kMicroSecondsPerSecond);</span><br><span class="line">  if (seconds != t_lastSecond)</span><br><span class="line">  &#123;</span><br><span class="line">    t_lastSecond = seconds;</span><br><span class="line">    struct DateTime dt;</span><br><span class="line">    if (g_logTimeZone.valid())</span><br><span class="line">    &#123;</span><br><span class="line">      dt = g_logTimeZone.toLocalTime(seconds);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      dt = TimeZone::toUtcTime(seconds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int len = snprintf(t_time, sizeof(t_time), &quot;%4d%02d%02d %02d:%02d:%02d&quot;,</span><br><span class="line">        dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second);</span><br><span class="line">    assert(len == 17); (void)len;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (g_logTimeZone.valid())</span><br><span class="line">  &#123;</span><br><span class="line">    Fmt us(&quot;.%06d &quot;, microseconds);</span><br><span class="line">    assert(us.length() == 8);</span><br><span class="line">    stream_ &lt;&lt; T(t_time, 17) &lt;&lt; T(us.data(), 8);//将时间和格式化的微秒输出到缓冲区</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    Fmt us(&quot;.%06dZ &quot;, microseconds);</span><br><span class="line">    assert(us.length() == 9);</span><br><span class="line">    stream_ &lt;&lt; T(t_time, 17) &lt;&lt; T(us.data(), 9);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Logger::Logger(SourceFile file, int line, LogLevel level)</span><br><span class="line">  : impl_(level, 0, file, line)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Logger::Logger(SourceFile file, int line, bool toAbort)</span><br><span class="line">  : impl_(toAbort?FATAL:ERROR, errno, file, line)//根据muduo::Logger(__FILE__, __LINE__, true)来判断级别是FATAL还是ERROR</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Logger::~Logger()</span><br><span class="line">&#123;</span><br><span class="line">  impl_.finish();</span><br><span class="line">  const LogStream::Buffer&amp; buf(stream().buffer());//引用的缓冲区，所以不需要拷贝</span><br><span class="line">  g_output(buf.data(), buf.length());//输出，调用defaultOutput</span><br><span class="line">  if (impl_.level_ == FATAL)</span><br><span class="line">  &#123;</span><br><span class="line">    g_flush();//defaultFlush</span><br><span class="line">    abort();//终止程序</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Logger::setLogLevel(Logger::LogLevel level)</span><br><span class="line">&#123;</span><br><span class="line">  g_logLevel = level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Logger::setOutput(OutputFunc out)</span><br><span class="line">&#123;</span><br><span class="line">  g_output = out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要输出到文件当中就可以在测试文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用文件描述符而不用stdout</span><br><span class="line">muduo::Logger::setOutput(outputFunc);</span><br><span class="line">muduo::Logger::setFlush(flushFunc);</span><br></pre></td></tr></table></figure>

<p>重新指定函数</p>
<hr>
<h3 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h3><p> C 标准库中的 <code>fwrite</code> 函数，它的作用是将数据写入到标准输出流 <code>stdout</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fwrite(msg, 1, len, stdout);</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>msg</code> 是一个指向要写入的数据的指针，通常是一个字符数组或者字节流的指针。</li>
<li><code>1</code> 是写入数据块的大小，表示每个数据项的大小为 1 字节。</li>
<li><code>len</code> 表示要写入的数据项的个数，通常用 <code>size_t</code> 类型表示。</li>
</ul>
<p>该函数将 <code>len</code> 个数据项（每个数据项大小为 1 字节）从 <code>msg</code> 指针所指向的内存地址写入到标准输出流 <code>stdout</code> 中。在写入成功时，它会返回成功写入的数据项个数，通常等于 <code>len</code>。失败时，返回值可能会小于 <code>len</code>，或者出现错误。所以，实际应用中一般会检查返回值来确保写入操作成功。</p>
<h3 id="fflush"><a href="#fflush" class="headerlink" title="fflush"></a>fflush</h3><p>C 标准库中的 <code>fflush</code> 函数，它的作用是将输出缓冲区中的数据立即刷新（写入）到相应的输出流（此处是标准输出流 <code>stdout</code>）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fflush(stdout);</span><br></pre></td></tr></table></figure>

<p>在 C&#x2F;C++ 程序中，标准输出流 <code>stdout</code> 是一个带有输出缓冲区的流。当使用输出函数（如 <code>printf</code> 或 <code>fwrite</code>）输出数据时，这些数据会先被放入输出缓冲区，而不是立即输出到终端或文件。输出缓冲区会在满时、程序结束时、或者调用 <code>fflush</code> 函数时进行刷新，将数据真正写入到目标输出设备。</p>
<p>调用 <code>fflush(stdout)</code> 可以强制将输出缓冲区中的数据立即刷新到终端，这在某些情况下是必要的，例如：</p>
<ol>
<li>当需要在输出内容后立即显示在屏幕上，而不等到输出缓冲区满或程序结束时。</li>
<li>在输出文件和控制台混合使用时，确保输出的顺序正确。</li>
<li>当程序需要在输出之后执行一些可能导致崩溃的操作，为了确保输出的数据已经被正确保存。</li>
</ol>
<p>需要注意的是，频繁地调用 <code>fflush</code> 可能会导致性能下降，因为刷新输出缓冲区通常比较耗时。在一般情况下，系统会自动地在合适的时机进行缓冲区刷新，而无需手动调用 <code>fflush</code>。但在某些特殊情况下，手动调用 <code>fflush</code> 是有必要的。</p>
<hr>
<h3 id="LogStream-h"><a href="#LogStream-h" class="headerlink" title="LogStream.h"></a>LogStream.h</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#ifndef MUDUO_BASE_LOGSTREAM_H</span><br><span class="line">#define MUDUO_BASE_LOGSTREAM_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/noncopyable.h&quot;</span><br><span class="line">#include &quot;muduo/base/StringPiece.h&quot;</span><br><span class="line">#include &quot;muduo/base/Types.h&quot;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;string.h&gt; // memcpy</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">namespace detail</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">const int kSmallBuffer = 4000;</span><br><span class="line">const int kLargeBuffer = 4000*1000;</span><br><span class="line"></span><br><span class="line">template&lt;int SIZE&gt;</span><br><span class="line">class FixedBuffer : noncopyable//缓冲区类</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  FixedBuffer()</span><br><span class="line">    : cur_(data_)</span><br><span class="line">  &#123;</span><br><span class="line">    setCookie(cookieStart);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~FixedBuffer()</span><br><span class="line">  &#123;</span><br><span class="line">    setCookie(cookieEnd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void append(const char* /*restrict*/ buf, size_t len)//添加数据</span><br><span class="line">  &#123;</span><br><span class="line">    // FIXME: append partially这里没有实现当空间不足以添加的情况</span><br><span class="line">    if (implicit_cast&lt;size_t&gt;(avail()) &gt; len)// implicit_cast 函数进行 size_t 隐式类型转换</span><br><span class="line">    &#123;</span><br><span class="line">      memcpy(cur_, buf, len);</span><br><span class="line">      //使用 memcpy 函数将源缓冲区 (buf) 中的数据复制到目标缓冲区中。cur_ 是一个指向当前位置的指针，表示数据将被添加到当前位置的后面</span><br><span class="line">      cur_ += len;//将当前指针 cur_ 向后移动 len 个位置，以确保下次添加数据时不会覆盖已经添加的部分</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const char* data() const &#123; return data_; &#125;</span><br><span class="line">  int length() const &#123; return static_cast&lt;int&gt;(cur_ - data_); &#125;//已经用了的空间长度</span><br><span class="line"></span><br><span class="line">  // write to data_ directly</span><br><span class="line">  char* current() &#123; return cur_; &#125;//返回当前添加数据位置的指针</span><br><span class="line">  int avail() const &#123; return static_cast&lt;int&gt;(end() - cur_); &#125;//当前可用空间</span><br><span class="line">  void add(size_t len) &#123; cur_ += len; &#125;</span><br><span class="line"></span><br><span class="line">  void reset() &#123; cur_ = data_; &#125;//重置，只需要移动指针，覆盖就行了</span><br><span class="line">  void bzero() &#123; memZero(data_, sizeof data_); &#125;//清零</span><br><span class="line"></span><br><span class="line">  // for used by GDB</span><br><span class="line">  const char* debugString();</span><br><span class="line">  void setCookie(void (*cookie)()) &#123; cookie_ = cookie; &#125;</span><br><span class="line">  // for used by unit test</span><br><span class="line">  string toString() const &#123; return string(data_, length()); &#125;</span><br><span class="line">  StringPiece toStringPiece() const &#123; return StringPiece(data_, length()); &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  const char* end() const &#123; return data_ + sizeof data_; &#125;//结尾位置，因为data是首地址</span><br><span class="line">  // Must be outline function for cookies.</span><br><span class="line">  static void cookieStart();</span><br><span class="line">  static void cookieEnd();</span><br><span class="line"></span><br><span class="line">  void (*cookie_)();//是一个函数指针</span><br><span class="line">  char data_[SIZE];</span><br><span class="line">  char* cur_;//指向用了空间的下一个位置</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace detail</span><br><span class="line"></span><br><span class="line">class LogStream : noncopyable</span><br><span class="line">&#123;</span><br><span class="line">  typedef LogStream self;</span><br><span class="line"> public:</span><br><span class="line">  typedef detail::FixedBuffer&lt;detail::kSmallBuffer&gt; Buffer;</span><br><span class="line"></span><br><span class="line">  self&amp; operator&lt;&lt;(bool v)</span><br><span class="line">  &#123;</span><br><span class="line">    buffer_.append(v ? &quot;1&quot; : &quot;0&quot;, 1);</span><br><span class="line">    return *this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self&amp; operator&lt;&lt;(short);</span><br><span class="line">  self&amp; operator&lt;&lt;(unsigned short);</span><br><span class="line">  self&amp; operator&lt;&lt;(int);</span><br><span class="line">  self&amp; operator&lt;&lt;(unsigned int);</span><br><span class="line">  self&amp; operator&lt;&lt;(long);</span><br><span class="line">  self&amp; operator&lt;&lt;(unsigned long);</span><br><span class="line">  self&amp; operator&lt;&lt;(long long);</span><br><span class="line">  self&amp; operator&lt;&lt;(unsigned long long);</span><br><span class="line"></span><br><span class="line">  self&amp; operator&lt;&lt;(const void*);</span><br><span class="line"></span><br><span class="line">  self&amp; operator&lt;&lt;(float v)</span><br><span class="line">  &#123;</span><br><span class="line">    *this &lt;&lt; static_cast&lt;double&gt;(v);</span><br><span class="line">    return *this;</span><br><span class="line">  &#125;</span><br><span class="line">  self&amp; operator&lt;&lt;(double);</span><br><span class="line">  // self&amp; operator&lt;&lt;(long double);</span><br><span class="line"></span><br><span class="line">  self&amp; operator&lt;&lt;(char v)</span><br><span class="line">  &#123;</span><br><span class="line">    buffer_.append(&amp;v, 1);</span><br><span class="line">    return *this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // self&amp; operator&lt;&lt;(signed char);</span><br><span class="line">  // self&amp; operator&lt;&lt;(unsigned char);</span><br><span class="line"></span><br><span class="line">  self&amp; operator&lt;&lt;(const char* str)</span><br><span class="line">  &#123;</span><br><span class="line">    if (str)</span><br><span class="line">    &#123;</span><br><span class="line">      buffer_.append(str, strlen(str));</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      buffer_.append(&quot;(null)&quot;, 6);</span><br><span class="line">    &#125;</span><br><span class="line">    return *this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self&amp; operator&lt;&lt;(const unsigned char* str)</span><br><span class="line">  &#123;</span><br><span class="line">    return operator&lt;&lt;(reinterpret_cast&lt;const char*&gt;(str));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self&amp; operator&lt;&lt;(const string&amp; v)</span><br><span class="line">  &#123;</span><br><span class="line">    buffer_.append(v.c_str(), v.size());</span><br><span class="line">    return *this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self&amp; operator&lt;&lt;(const StringPiece&amp; v)</span><br><span class="line">  &#123;</span><br><span class="line">    buffer_.append(v.data(), v.size());</span><br><span class="line">    return *this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self&amp; operator&lt;&lt;(const Buffer&amp; v)</span><br><span class="line">  &#123;</span><br><span class="line">    *this &lt;&lt; v.toStringPiece();</span><br><span class="line">    return *this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void append(const char* data, int len) &#123; buffer_.append(data, len); &#125;</span><br><span class="line">  const Buffer&amp; buffer() const &#123; return buffer_; &#125;</span><br><span class="line">  void resetBuffer() &#123; buffer_.reset(); &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  void staticCheck();</span><br><span class="line"></span><br><span class="line">  template&lt;typename T&gt;</span><br><span class="line">  void formatInteger(T);</span><br><span class="line"></span><br><span class="line">  Buffer buffer_;</span><br><span class="line"></span><br><span class="line">  static const int kMaxNumericSize = 48;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Fmt // : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  template&lt;typename T&gt;</span><br><span class="line">  Fmt(const char* fmt, T val);</span><br><span class="line"></span><br><span class="line">  const char* data() const &#123; return buf_; &#125;</span><br><span class="line">  int length() const &#123; return length_; &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  char buf_[32];</span><br><span class="line">  int length_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inline LogStream&amp; operator&lt;&lt;(LogStream&amp; s, const Fmt&amp; fmt)</span><br><span class="line">&#123;</span><br><span class="line">  s.append(fmt.data(), fmt.length());</span><br><span class="line">  return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Format quantity n in SI units (k, M, G, T, P, E).</span><br><span class="line">// The returned string is atmost 5 characters long.</span><br><span class="line">// Requires n &gt;= 0</span><br><span class="line">string formatSI(int64_t n);</span><br><span class="line"></span><br><span class="line">// Format quantity n in IEC (binary) units (Ki, Mi, Gi, Ti, Pi, Ei).</span><br><span class="line">// The returned string is atmost 6 characters long.</span><br><span class="line">// Requires n &gt;= 0</span><br><span class="line">string formatIEC(int64_t n);</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_BASE_LOGSTREAM_H</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="LogStream-cc"><a href="#LogStream-cc" class="headerlink" title="LogStream.cc"></a>LogStream.cc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/LogStream.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;limits&gt;</span><br><span class="line">#include &lt;type_traits&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#ifndef __STDC_FORMAT_MACROS</span><br><span class="line">#define __STDC_FORMAT_MACROS</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace muduo::detail;</span><br><span class="line"></span><br><span class="line">// TODO: better itoa.</span><br><span class="line">#if defined(__clang__)</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wtautological-compare&quot;</span><br><span class="line">#else</span><br><span class="line">#pragma GCC diagnostic ignored &quot;-Wtype-limits&quot; //代码中忽略检测到旧式的类型转换时发出警告</span><br><span class="line">#endif</span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace detail</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">const char digits[] = &quot;9876543210123456789&quot;;</span><br><span class="line">const char* zero = digits + 9;</span><br><span class="line">static_assert(sizeof(digits) == 20, &quot;wrong number of digits&quot;);</span><br><span class="line"></span><br><span class="line">const char digitsHex[] = &quot;0123456789ABCDEF&quot;;</span><br><span class="line">static_assert(sizeof digitsHex == 17, &quot;wrong number of digitsHex&quot;);</span><br><span class="line"></span><br><span class="line">// Efficient Integer to String Conversions, by Matthew Wilson.</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">size_t convert(char buf[], T value)</span><br><span class="line">&#123;</span><br><span class="line">  T i = value;</span><br><span class="line">  char* p = buf;</span><br><span class="line"></span><br><span class="line">  do</span><br><span class="line">  &#123;</span><br><span class="line">    int lsd = static_cast&lt;int&gt;(i % 10);//最后一个数字</span><br><span class="line">    i /= 10;//// 将 i 缩小为原来的十分之一，即去掉最后一位数字</span><br><span class="line">    *p++ = zero[lsd]; // 将最后一位数字对应的字符存储到 buf 中，然后移动指针 p 到下一个位置</span><br><span class="line">  &#125; while (i != 0);</span><br><span class="line"></span><br><span class="line">  if (value &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    *p++ = &#x27;-&#x27;;// 如果传入的 value 是负数，则在字符串最前面加上负号，并移动指针 p 到下一个位置</span><br><span class="line">  &#125;</span><br><span class="line">  *p = &#x27;\0&#x27;;</span><br><span class="line">  std::reverse(buf, p);// 反转整个字符串，以得到正确的顺序</span><br><span class="line"></span><br><span class="line">  return p - buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">size_t convertHex(char buf[], uintptr_t value)//16进制</span><br><span class="line">&#123;</span><br><span class="line">  uintptr_t i = value;</span><br><span class="line">  char* p = buf;</span><br><span class="line"></span><br><span class="line">  do</span><br><span class="line">  &#123;</span><br><span class="line">    int lsd = static_cast&lt;int&gt;(i % 16);</span><br><span class="line">    i /= 16;</span><br><span class="line">    *p++ = digitsHex[lsd];</span><br><span class="line">  &#125; while (i != 0);</span><br><span class="line"></span><br><span class="line">  *p = &#x27;\0&#x27;;</span><br><span class="line">  std::reverse(buf, p);</span><br><span class="line"></span><br><span class="line">  return p - buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template class FixedBuffer&lt;kSmallBuffer&gt;;</span><br><span class="line">template class FixedBuffer&lt;kLargeBuffer&gt;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace detail</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> Format a number with 5 characters, including SI units.</span><br><span class="line"> [0,     999]</span><br><span class="line"> [1.00k, 999k]</span><br><span class="line"> [1.00M, 999M]</span><br><span class="line"> [1.00G, 999G]</span><br><span class="line"> [1.00T, 999T]</span><br><span class="line"> [1.00P, 999P]</span><br><span class="line"> [1.00E, inf)</span><br><span class="line">*/</span><br><span class="line">std::string formatSI(int64_t s)</span><br><span class="line">&#123;</span><br><span class="line">  double n = static_cast&lt;double&gt;(s);</span><br><span class="line">  char buf[64];</span><br><span class="line">  if (s &lt; 1000)</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%&quot; PRId64, s);</span><br><span class="line">  else if (s &lt; 9995)</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%.2fk&quot;, n/1e3);</span><br><span class="line">  else if (s &lt; 99950)</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%.1fk&quot;, n/1e3);</span><br><span class="line">  else if (s &lt; 999500)</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%.0fk&quot;, n/1e3);</span><br><span class="line">  else if (s &lt; 9995000)</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%.2fM&quot;, n/1e6);</span><br><span class="line">  else if (s &lt; 99950000)</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%.1fM&quot;, n/1e6);</span><br><span class="line">  else if (s &lt; 999500000)</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%.0fM&quot;, n/1e6);</span><br><span class="line">  else if (s &lt; 9995000000)</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%.2fG&quot;, n/1e9);</span><br><span class="line">  else if (s &lt; 99950000000)</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%.1fG&quot;, n/1e9);</span><br><span class="line">  else if (s &lt; 999500000000)</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%.0fG&quot;, n/1e9);</span><br><span class="line">  else if (s &lt; 9995000000000)</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%.2fT&quot;, n/1e12);</span><br><span class="line">  else if (s &lt; 99950000000000)</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%.1fT&quot;, n/1e12);</span><br><span class="line">  else if (s &lt; 999500000000000)</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%.0fT&quot;, n/1e12);</span><br><span class="line">  else if (s &lt; 9995000000000000)</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%.2fP&quot;, n/1e15);</span><br><span class="line">  else if (s &lt; 99950000000000000)</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%.1fP&quot;, n/1e15);</span><br><span class="line">  else if (s &lt; 999500000000000000)</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%.0fP&quot;, n/1e15);</span><br><span class="line">  else</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%.2fE&quot;, n/1e18);</span><br><span class="line">  return buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> [0, 1023]</span><br><span class="line"> [1.00Ki, 9.99Ki]</span><br><span class="line"> [10.0Ki, 99.9Ki]</span><br><span class="line"> [ 100Ki, 1023Ki]</span><br><span class="line"> [1.00Mi, 9.99Mi]</span><br><span class="line">*/</span><br><span class="line">std::string formatIEC(int64_t s)//将给定的整数 s 格式化成带有国际单位符号的字符串表示</span><br><span class="line">&#123;</span><br><span class="line">  double n = static_cast&lt;double&gt;(s);</span><br><span class="line">  char buf[64];</span><br><span class="line">  const double Ki = 1024.0;</span><br><span class="line">  const double Mi = Ki * 1024.0;</span><br><span class="line">  const double Gi = Mi * 1024.0;</span><br><span class="line">  const double Ti = Gi * 1024.0;</span><br><span class="line">  const double Pi = Ti * 1024.0;</span><br><span class="line">  const double Ei = Pi * 1024.0;</span><br><span class="line"></span><br><span class="line">  if (n &lt; Ki)</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%&quot; PRId64, s);</span><br><span class="line">  else if (n &lt; Ki*9.995)</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%.2fKi&quot;, n / Ki);</span><br><span class="line">  else if (n &lt; Ki*99.95)</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%.1fKi&quot;, n / Ki);</span><br><span class="line">  else if (n &lt; Ki*1023.5)</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%.0fKi&quot;, n / Ki);</span><br><span class="line"></span><br><span class="line">  else if (n &lt; Mi*9.995)</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%.2fMi&quot;, n / Mi);</span><br><span class="line">  else if (n &lt; Mi*99.95)</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%.1fMi&quot;, n / Mi);</span><br><span class="line">  else if (n &lt; Mi*1023.5)</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%.0fMi&quot;, n / Mi);</span><br><span class="line"></span><br><span class="line">  else if (n &lt; Gi*9.995)</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%.2fGi&quot;, n / Gi);</span><br><span class="line">  else if (n &lt; Gi*99.95)</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%.1fGi&quot;, n / Gi);</span><br><span class="line">  else if (n &lt; Gi*1023.5)</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%.0fGi&quot;, n / Gi);</span><br><span class="line"></span><br><span class="line">  else if (n &lt; Ti*9.995)</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%.2fTi&quot;, n / Ti);</span><br><span class="line">  else if (n &lt; Ti*99.95)</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%.1fTi&quot;, n / Ti);</span><br><span class="line">  else if (n &lt; Ti*1023.5)</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%.0fTi&quot;, n / Ti);</span><br><span class="line"></span><br><span class="line">  else if (n &lt; Pi*9.995)</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%.2fPi&quot;, n / Pi);</span><br><span class="line">  else if (n &lt; Pi*99.95)</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%.1fPi&quot;, n / Pi);</span><br><span class="line">  else if (n &lt; Pi*1023.5)</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%.0fPi&quot;, n / Pi);</span><br><span class="line"></span><br><span class="line">  else if (n &lt; Ei*9.995)</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%.2fEi&quot;, n / Ei );</span><br><span class="line">  else</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;%.1fEi&quot;, n / Ei );</span><br><span class="line">  return buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void LogStream::formatInteger(T v)</span><br><span class="line">&#123;</span><br><span class="line">  if (buffer_.avail() &gt;= kMaxNumericSize)</span><br><span class="line">  &#123;</span><br><span class="line">    size_t len = convert(buffer_.current(), v);//将int转化成string存入buffer当前位置缓冲区</span><br><span class="line">    buffer_.add(len);//调整current位置</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LogStream&amp; LogStream::operator&lt;&lt;(short v)</span><br><span class="line">&#123;</span><br><span class="line">  *this &lt;&lt; static_cast&lt;int&gt;(v);</span><br><span class="line">  //将一个 short 值转换为 int 值，然后调用 LogStream 对象的另一个 &lt;&lt; 操作符，将转换后的 int 值写入流中</span><br><span class="line">  return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">Fmt::Fmt(const char* fmt, T val)</span><br><span class="line">&#123;//断言T是算术类型</span><br><span class="line">  static_assert(std::is_arithmetic&lt;T&gt;::value == true, &quot;Must be arithmetic type&quot;);</span><br><span class="line"></span><br><span class="line">  length_ = snprintf(buf_, sizeof buf_, fmt, val);</span><br><span class="line">  assert(static_cast&lt;size_t&gt;(length_) &lt; sizeof buf_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Explicit instantiations</span><br><span class="line">//一些特化，除了这些其它类型都不能用，显示实例化了</span><br><span class="line">template Fmt::Fmt(const char* fmt, char);</span><br><span class="line"></span><br><span class="line">template Fmt::Fmt(const char* fmt, short);</span><br><span class="line">template Fmt::Fmt(const char* fmt, unsigned short);</span><br><span class="line">template Fmt::Fmt(const char* fmt, int);</span><br><span class="line">template Fmt::Fmt(const char* fmt, unsigned int);</span><br><span class="line">template Fmt::Fmt(const char* fmt, long);</span><br><span class="line">template Fmt::Fmt(const char* fmt, unsigned long);</span><br><span class="line">template Fmt::Fmt(const char* fmt, long long);</span><br><span class="line">template Fmt::Fmt(const char* fmt, unsigned long long);</span><br><span class="line"></span><br><span class="line">template Fmt::Fmt(const char* fmt, float);</span><br><span class="line">template Fmt::Fmt(const char* fmt, double);</span><br></pre></td></tr></table></figure>

<p>这两个函数 <code>formatSI</code> 和 <code>formatIEC</code> 的作用是将给定的整数 <code>s</code> 格式化成带有国际单位符号的字符串表示。</p>
<ol>
<li><code>formatSI</code> 函数:<ul>
<li>这个函数将一个整数 <code>s</code> 格式化成带有国际单位符号的字符串表示。国际单位符号包括 k（千）、M（百万）、G（十亿）、T（万亿）、P（千万亿）、E（百万亿亿）。</li>
<li>函数首先将整数 <code>s</code> 转换成 <code>double</code> 类型 <code>n</code>，然后根据整数的大小选择合适的单位并格式化成字符串。</li>
<li>例如，如果 <code>s</code> 小于 1000，则直接将整数转换成字符串；如果 <code>s</code> 在 1000 到 9995 之间，则将其除以 1000 并保留两位小数，后缀为 “k”；如果在其他范围内，则依次使用 “M”、”G”、”T”、”P”、”E” 作为后缀，并对数字进行适当的格式化。</li>
</ul>
</li>
<li><code>formatIEC</code> 函数:<ul>
<li>这个函数将一个整数 <code>s</code> 格式化成带有 IEC（国际电工委员会）单位符号的字符串表示。IEC 单位符号是用于计算机存储容量的单位，基于 2 的幂次方，包括 Ki（千字节）、Mi（兆字节）、Gi（吉字节）、Ti（太字节）、Pi（拍字节）、Ei（艾字节）。</li>
<li>函数首先将整数 <code>s</code> 转换成 <code>double</code> 类型 <code>n</code>，然后根据整数的大小选择合适的单位并格式化成字符串。</li>
<li>例如，如果 <code>s</code> 小于 1024，则直接将整数转换成字符串；如果 <code>s</code> 在 1024 到 9995 之间，则将其除以 1024 并保留两位小数，后缀为 “Ki”；如果在其他范围内，则依次使用 “Mi”、”Gi”、”Ti” 作为后缀，并对数字进行适当的格式化。</li>
</ul>
</li>
</ol>
<p>这两个函数使得对整数的单位转换和格式化变得简单和方便，适用于不同范围的整数值，并以易读的形式展示其大小。</p>
<h3 id="LogStream-test-cc"><a href="#LogStream-test-cc" class="headerlink" title="LogStream_test.cc"></a>LogStream_test.cc</h3><p><code>if(BOOSTTEST_LIBRARY)</code>：这个条件语句检查是否定义了宏 <code>BOOSTTEST_LIBRARY</code>。这通常是在 CMake 配置文件中定义的一个宏，用于指示是否包含了 Boost 库的测试框架。如果定义了这个宏，说明系统中包含了 Boost 测试库，可以执行下面的操作；否则，这段代码块会被忽略</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/LogStream.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;limits&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">//#define BOOST_TEST_MODULE LogStreamTest</span><br><span class="line">#define BOOST_TEST_MAIN</span><br><span class="line">#define BOOST_TEST_DYN_LINK</span><br><span class="line">#include &lt;boost/test/unit_test.hpp&gt;</span><br><span class="line"></span><br><span class="line">using muduo::string;</span><br><span class="line"></span><br><span class="line">BOOST_AUTO_TEST_CASE(testLogStreamBooleans)//都是一些测试用例，需要安装sudo apt-get install libboost-test-dev</span><br><span class="line">&#123;//bool的测试</span><br><span class="line">  muduo::LogStream os;</span><br><span class="line">  const muduo::LogStream::Buffer&amp; buf = os.buffer();</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;&quot;));</span><br><span class="line">  os &lt;&lt; true;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;1&quot;));</span><br><span class="line">  os &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;1\n&quot;));</span><br><span class="line">  os &lt;&lt; false;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;1\n0&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOST_AUTO_TEST_CASE(testLogStreamIntegers)//整形的测试</span><br><span class="line">&#123;</span><br><span class="line">  muduo::LogStream os;</span><br><span class="line">  const muduo::LogStream::Buffer&amp; buf = os.buffer();</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;&quot;));</span><br><span class="line">  os &lt;&lt; 1;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;1&quot;));</span><br><span class="line">  os &lt;&lt; 0;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;10&quot;));</span><br><span class="line">  os &lt;&lt; -1;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;10-1&quot;));</span><br><span class="line">  os.resetBuffer();//重复利用</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; 0 &lt;&lt; &quot; &quot; &lt;&lt; 123 &lt;&lt; &#x27;x&#x27; &lt;&lt; 0x64;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0 123x100&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOST_AUTO_TEST_CASE(testLogStreamIntegerLimits)</span><br><span class="line">&#123;</span><br><span class="line">  muduo::LogStream os;</span><br><span class="line">  const muduo::LogStream::Buffer&amp; buf = os.buffer();</span><br><span class="line">  os &lt;&lt; -2147483647;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;-2147483647&quot;));</span><br><span class="line">  os &lt;&lt; static_cast&lt;int&gt;(-2147483647 - 1);</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;-2147483647-2147483648&quot;));</span><br><span class="line">  os &lt;&lt; &#x27; &#x27;;</span><br><span class="line">  os &lt;&lt; 2147483647;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;-2147483647-2147483648 2147483647&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; std::numeric_limits&lt;int16_t&gt;::min();</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;-32768&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; std::numeric_limits&lt;int16_t&gt;::max();</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;32767&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; std::numeric_limits&lt;uint16_t&gt;::min();</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; std::numeric_limits&lt;uint16_t&gt;::max();</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;65535&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; std::numeric_limits&lt;int32_t&gt;::min();</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;-2147483648&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; std::numeric_limits&lt;int32_t&gt;::max();</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;2147483647&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; std::numeric_limits&lt;uint32_t&gt;::min();</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; std::numeric_limits&lt;uint32_t&gt;::max();</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;4294967295&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; std::numeric_limits&lt;int64_t&gt;::min();</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;-9223372036854775808&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; std::numeric_limits&lt;int64_t&gt;::max();</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;9223372036854775807&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; std::numeric_limits&lt;uint64_t&gt;::min();</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; std::numeric_limits&lt;uint64_t&gt;::max();</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;18446744073709551615&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  int16_t a = 0;</span><br><span class="line">  int32_t b = 0;</span><br><span class="line">  int64_t c = 0;</span><br><span class="line">  os &lt;&lt; a;</span><br><span class="line">  os &lt;&lt; b;</span><br><span class="line">  os &lt;&lt; c;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;000&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOST_AUTO_TEST_CASE(testLogStreamFloats)</span><br><span class="line">&#123;</span><br><span class="line">  muduo::LogStream os;</span><br><span class="line">  const muduo::LogStream::Buffer&amp; buf = os.buffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; 0.0;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; 1.0;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;1&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; 0.1;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0.1&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; 0.05;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0.05&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; 0.15;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0.15&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  double a = 0.1;</span><br><span class="line">  os &lt;&lt; a;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0.1&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  double b = 0.05;</span><br><span class="line">  os &lt;&lt; b;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0.05&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  double c = 0.15;</span><br><span class="line">  os &lt;&lt; c;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0.15&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; a+b;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0.15&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  BOOST_CHECK(a+b != c);</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; 1.23456789;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;1.23456789&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; 1.234567;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;1.234567&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; -123.456;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;-123.456&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOST_AUTO_TEST_CASE(testLogStreamVoid)</span><br><span class="line">&#123;</span><br><span class="line">  muduo::LogStream os;</span><br><span class="line">  const muduo::LogStream::Buffer&amp; buf = os.buffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; static_cast&lt;void*&gt;(0);</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0x0&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; reinterpret_cast&lt;void*&gt;(8888);</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;0x22B8&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOST_AUTO_TEST_CASE(testLogStreamStrings)</span><br><span class="line">&#123;</span><br><span class="line">  muduo::LogStream os;</span><br><span class="line">  const muduo::LogStream::Buffer&amp; buf = os.buffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; &quot;Hello &quot;;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;Hello &quot;));</span><br><span class="line"></span><br><span class="line">  string chenshuo = &quot;Shuo Chen&quot;;</span><br><span class="line">  os &lt;&lt; chenshuo;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;Hello Shuo Chen&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOST_AUTO_TEST_CASE(testLogStreamFmts)</span><br><span class="line">&#123;</span><br><span class="line">  muduo::LogStream os;</span><br><span class="line">  const muduo::LogStream::Buffer&amp; buf = os.buffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; muduo::Fmt(&quot;%4d&quot;, 1);</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;   1&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; muduo::Fmt(&quot;%4.2f&quot;, 1.2);</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;1.20&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; muduo::Fmt(&quot;%4.2f&quot;, 1.2) &lt;&lt; muduo::Fmt(&quot;%4d&quot;, 43);</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.toString(), string(&quot;1.20  43&quot;));</span><br><span class="line">  os.resetBuffer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOST_AUTO_TEST_CASE(testLogStreamLong)</span><br><span class="line">&#123;</span><br><span class="line">  muduo::LogStream os;</span><br><span class="line">  const muduo::LogStream::Buffer&amp; buf = os.buffer();</span><br><span class="line">  for (int i = 0; i &lt; 399; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    os &lt;&lt; &quot;123456789 &quot;;</span><br><span class="line">    BOOST_CHECK_EQUAL(buf.length(), 10*(i+1));</span><br><span class="line">    BOOST_CHECK_EQUAL(buf.avail(), 4000 - 10*(i+1));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; &quot;abcdefghi &quot;;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.length(), 3990);</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.avail(), 10);</span><br><span class="line"></span><br><span class="line">  os &lt;&lt; &quot;abcdefghi&quot;;</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.length(), 3999);</span><br><span class="line">  BOOST_CHECK_EQUAL(buf.avail(), 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOST_AUTO_TEST_CASE(testFormatSI)</span><br><span class="line">&#123;</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(0), string(&quot;0&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(999), string(&quot;999&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(1000), string(&quot;1.00k&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(9990), string(&quot;9.99k&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(9994), string(&quot;9.99k&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(9995), string(&quot;10.0k&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(10000), string(&quot;10.0k&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(10049), string(&quot;10.0k&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(10050), string(&quot;10.1k&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(99900), string(&quot;99.9k&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(99949), string(&quot;99.9k&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(99950), string(&quot;100k&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(100499), string(&quot;100k&quot;));</span><br><span class="line">  // FIXME:</span><br><span class="line">  // BOOST_CHECK_EQUAL(muduo::formatSI(100500), string(&quot;101k&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(100501), string(&quot;101k&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(999499), string(&quot;999k&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(999500), string(&quot;1.00M&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(1004999), string(&quot;1.00M&quot;));</span><br><span class="line">  // BOOST_CHECK_EQUAL(muduo::formatSI(1005000), string(&quot;1.01M&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(1005001), string(&quot;1.01M&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatSI(INT64_MAX), string(&quot;9.22E&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOST_AUTO_TEST_CASE(testFormatIEC)//测试 muduo::formatIEC 函数的行为是否正确</span><br><span class="line">&#123;</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(0), string(&quot;0&quot;));//测试用例 0：函数应该返回 &quot;0&quot;</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(1023), string(&quot;1023&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(1024), string(&quot;1.00Ki&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(10234), string(&quot;9.99Ki&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(10235), string(&quot;10.0Ki&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(10240), string(&quot;10.0Ki&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(10291), string(&quot;10.0Ki&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(10292), string(&quot;10.1Ki&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(102348), string(&quot;99.9Ki&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(102349), string(&quot;100Ki&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(102912), string(&quot;100Ki&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(102913), string(&quot;101Ki&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(1022976), string(&quot;999Ki&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(1047552), string(&quot;1023Ki&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(1047961), string(&quot;1023Ki&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(1048063), string(&quot;1023Ki&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(1048064), string(&quot;1.00Mi&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(1048576), string(&quot;1.00Mi&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(10480517), string(&quot;9.99Mi&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(10480518), string(&quot;10.0Mi&quot;));</span><br><span class="line">  BOOST_CHECK_EQUAL(muduo::formatIEC(INT64_MAX), string(&quot;8.00Ei&quot;));</span><br><span class="line">&#125;//每个 BOOST_CHECK_EQUAL 语句都验证了函数的实际输出是否与预期输出相匹配。如果所有检查都通过，就表示 muduo::formatIEC 函数在提供的测试用例中表现正确</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>LogStream_bench.cc</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/LogStream.h&quot;</span><br><span class="line">#include &quot;muduo/base/Timestamp.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define __STDC_FORMAT_MACROS</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line"></span><br><span class="line">const size_t N = 1000000;</span><br><span class="line"></span><br><span class="line">#pragma GCC diagnostic ignored &quot;-Wold-style-cast&quot;</span><br><span class="line">//可以在代码中暂时禁用对 -Wold-style-cast 警告的处理，这意味着编译器会忽略与旧式类型转换相关的警告，不会在这些地方生成警告信息</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void benchPrintf(const char* fmt)//函数打印出性能测试的结果，即格式化字符串操作所花费的时间</span><br><span class="line">&#123;</span><br><span class="line">  char buf[32];</span><br><span class="line">  Timestamp start(Timestamp::now());</span><br><span class="line">  for (size_t i = 0; i &lt; N; ++i)</span><br><span class="line">    snprintf(buf, sizeof buf, fmt, (T)(i));//(T)(i)是c语言的旧式类型转换,snprintf 函数会重新写入到 buf 缓冲区的开头</span><br><span class="line">  Timestamp end(Timestamp::now());</span><br><span class="line"></span><br><span class="line">  printf(&quot;benchPrintf %f\n&quot;, timeDifference(end, start));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void benchStringStream()</span><br><span class="line">&#123;</span><br><span class="line">  Timestamp start(Timestamp::now());</span><br><span class="line">  std::ostringstream os;</span><br><span class="line"></span><br><span class="line">  for (size_t i = 0; i &lt; N; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    os &lt;&lt; (T)(i);</span><br><span class="line">    os.seekp(0, std::ios_base::beg);</span><br><span class="line">    //将流的写指针重置到起始位置，以便下一次循环中可以重新将数据插入到流中</span><br><span class="line">  &#125;</span><br><span class="line">  Timestamp end(Timestamp::now());</span><br><span class="line"></span><br><span class="line">  printf(&quot;benchStringStream %f\n&quot;, timeDifference(end, start));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void benchLogStream()</span><br><span class="line">&#123;</span><br><span class="line">  Timestamp start(Timestamp::now());</span><br><span class="line">  LogStream os;</span><br><span class="line">  for (size_t i = 0; i &lt; N; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    os &lt;&lt; (T)(i);</span><br><span class="line">    os.resetBuffer();//重置，只需要移动指针，覆盖就行了</span><br><span class="line">  &#125;</span><br><span class="line">  Timestamp end(Timestamp::now());</span><br><span class="line"></span><br><span class="line">  printf(&quot;benchLogStream %f\n&quot;, timeDifference(end, start));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  benchPrintf&lt;int&gt;(&quot;%d&quot;);</span><br><span class="line"></span><br><span class="line">  puts(&quot;int&quot;);//在控制台输出字符串 &quot;int&quot;，并在末尾自动添加换行符</span><br><span class="line">  benchPrintf&lt;int&gt;(&quot;%d&quot;);</span><br><span class="line">  benchStringStream&lt;int&gt;();</span><br><span class="line">  benchLogStream&lt;int&gt;();</span><br><span class="line"></span><br><span class="line">  puts(&quot;double&quot;);</span><br><span class="line">  benchPrintf&lt;double&gt;(&quot;%.12g&quot;);</span><br><span class="line">  benchStringStream&lt;double&gt;();</span><br><span class="line">  benchLogStream&lt;double&gt;();</span><br><span class="line"></span><br><span class="line">  puts(&quot;int64_t&quot;);</span><br><span class="line">  benchPrintf&lt;int64_t&gt;(&quot;%&quot; PRId64);</span><br><span class="line">  benchStringStream&lt;int64_t&gt;();</span><br><span class="line">  benchLogStream&lt;int64_t&gt;();</span><br><span class="line"></span><br><span class="line">  puts(&quot;void*&quot;);</span><br><span class="line">  benchPrintf&lt;void*&gt;(&quot;%p&quot;);</span><br><span class="line">  benchStringStream&lt;void*&gt;();</span><br><span class="line">  benchLogStream&lt;void*&gt;();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%884%EF%BC%89/image-20230805153659241.png" alt="image-20230805153659241"></p>
<img src="/2023/08/04/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%884%EF%BC%89/image-20230805153659241.png" class title="This is an test image">

<p>这段代码是一个性能测试程序，旨在比较不同方法（<code>printf</code>、<code>std::ostringstream</code> 和 <code>LogStream</code>）来进行格式化字符串操作时所花费的时间。以下是对代码的分析：</p>
<ol>
<li>引入头文件和命名空间：代码开始引入了 <code>muduo/base/LogStream.h</code> 和 <code>muduo/base/Timestamp.h</code> 头文件，以及 <code>std::ostringstream</code> 和其他标准库头文件。然后，通过 <code>using namespace muduo;</code> 使用了 <code>muduo</code> 命名空间。</li>
<li>定义常量和模板函数：代码定义了一个常量 <code>N</code>，表示迭代次数。接下来，定义了三个模板函数 <code>benchPrintf</code>、<code>benchStringStream</code> 和 <code>benchLogStream</code>，用于分别测试不同的格式化字符串操作方法。</li>
<li><code>benchPrintf</code> 函数：该函数使用 <code>snprintf</code> 函数以指定的格式将数据格式化到缓冲区。使用当前时间戳记录操作开始时间，然后进行循环迭代，每次迭代都进行一次格式化操作。迭代结束后再次获取时间戳，计算出格式化操作所花费的时间，并打印结果。</li>
<li><code>benchStringStream</code> 函数：该函数使用 <code>std::ostringstream</code> 对象进行格式化操作。与前一个函数类似，使用时间戳记录操作开始时间，然后进行循环迭代，每次迭代使用流将数据格式化。迭代结束后计算时间差，并打印结果。</li>
<li><code>benchLogStream</code> 函数：该函数使用 <code>LogStream</code> 对象进行格式化操作。同样，使用时间戳记录操作开始时间，然后进行循环迭代，每次迭代使用 <code>LogStream</code> 将数据格式化。迭代结束后计算时间差，并打印结果。</li>
<li><code>main</code> 函数：在主函数中，首先测试了 <code>benchPrintf</code> 函数的性能，对 <code>int</code> 类型使用 <code>%d</code> 格式。然后分别测试了 <code>int</code>、<code>double</code>、<code>int64_t</code> 和 <code>void*</code> 类型，调用相应的测试函数。</li>
</ol>
<p>总体来说，该程序旨在比较三种不同方法在进行格式化字符串操作时的性能。通过在循环中多次执行格式化操作，可以测量出每种方法的性能表现，并将结果打印出来以进行比较。这样可以帮助开发人员选择在特定情况下最适合的格式化字符串操作方法。</p>
<h1 id="StringPiece-h"><a href="#StringPiece-h" class="headerlink" title="StringPiece.h"></a>StringPiece.h</h1><p>用以实现高效的字符串传递</p>
<p>如果void foo(const StringPiece&amp; x);</p>
<p>这里既可以用const char*、也可以用std::string类型作为参数传递进去</p>
<p>并且不涉及内存拷贝</p>
<p>在STL中为了提供通用的操作而又不损失效率，我们用到了一种特殊的技巧，叫traits编程技巧。其体的来说，traits就是通过定义一些结构体或类，并利用模板特化和偏特化的能力，给类型赋予一些特性，这些特性根据类型的不同而异。<br>在程序设计中可以使用这些traits来判断一个类型的一些特性，引发C++的函数重载机制，实现同一种操作因类型不同而异的效果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#ifdef HAVE_TYPE_TRAITS</span><br><span class="line">//这里对_type_traits进行特化，给StringPiece一些特性</span><br><span class="line">// This makes vector&lt;StringPiece&gt; really fast for some STL implementations</span><br><span class="line">template&lt;&gt; struct __type_traits&lt;muduo::StringPiece&gt; &#123;</span><br><span class="line">  typedef __true_type    has_trivial_default_constructor;</span><br><span class="line">  typedef __true_type    has_trivial_copy_constructor;</span><br><span class="line">  typedef __true_type    has_trivial_assignment_operator;</span><br><span class="line">  typedef __true_type    has_trivial_destructor;</span><br><span class="line">  typedef __true_type    is_POD_type;</span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>这段代码是对 C++ 标准库中的 <code>type_traits</code> 进行特化，为 <code>muduo::StringPiece</code> 类型添加一些特性。</p>
<ol>
<li><code>#ifdef HAVE_TYPE_TRAITS</code>：这是一个预处理指令，用于判断是否定义了宏 <code>HAVE_TYPE_TRAITS</code>。如果定义了该宏，则执行下面的代码块，否则忽略这段代码。</li>
<li><code>template&lt;&gt; struct __type_traits&lt;muduo::StringPiece&gt;</code>：这是一个模板特化，为 <code>muduo::StringPiece</code> 类型添加特性。<code>__type_traits</code> 是一个模板结构体，用于提供类型特性信息。</li>
<li><code>typedef __true_type    has_trivial_default_constructor;</code>：给 <code>muduo::StringPiece</code> 添加了一个类型特性 <code>has_trivial_default_constructor</code>，该特性表示该类型拥有一个平凡的默认构造函数（trivial default constructor）。</li>
<li><code>typedef __true_type    has_trivial_copy_constructor;</code>：添加了类型特性 <code>has_trivial_copy_constructor</code>，表示 <code>muduo::StringPiece</code> 拥有一个平凡的拷贝构造函数（trivial copy constructor）。</li>
<li><code>typedef __true_type    has_trivial_assignment_operator;</code>：添加了类型特性 <code>has_trivial_assignment_operator</code>，表示 <code>muduo::StringPiece</code> 拥有一个平凡的赋值运算符（trivial assignment operator）。</li>
<li><code>typedef __true_type    has_trivial_destructor;</code>：添加了类型特性 <code>has_trivial_destructor</code>，表示 <code>muduo::StringPiece</code> 拥有一个平凡的析构函数（trivial destructor）。</li>
<li><code>typedef __true_type    is_POD_type;</code>：添加了类型特性 <code>is_POD_type</code>，表示 <code>muduo::StringPiece</code> 是一个平凡的数据类型（Plain Old Data type）。</li>
</ol>
<p>特化 <code>type_traits</code> 是为了告诉编译器有关于 <code>muduo::StringPiece</code> 类型的特性信息，这些信息可以用于优化代码，提高程序的性能。例如，在使用标准库容器 <code>vector&lt;StringPiece&gt;</code> 时，这些特性信息可以让一些 STL 实现对 <code>muduo::StringPiece</code> 进行更高效的操作，使得程序在处理该类型时更快速和高效。</p>
<hr>
<p>你可以在代码中使用 <code>muduo::StringPiece</code> 类，以及定义在这个头文件中的相关操作函数。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;muduo/base/StringPiece.h&quot;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    const char* data = &quot;Hello, World!&quot;;</span><br><span class="line">    muduo::StringPiece piece(data, 5); // 创建一个 StringPiece，引用前5个字符</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;StringPiece size: &quot; &lt;&lt; piece.size() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;StringPiece data: &quot; &lt;&lt; piece.data() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li><code>muduo::StringPiece</code> 只是一个视图，它不拥有字符串的内存。因此，在使用 <code>muduo::StringPiece</code> 时，需要确保被引用的字符串的生命周期长于 <code>StringPiece</code> 的使用。</li>
<li><code>muduo::StringPiece</code> 不负责管理字符串的内存，因此不应该对其进行修改（例如增删字符），它只是用来读取字符串数据的。</li>
</ul>
<h1 id="日志滚动"><a href="#日志滚动" class="headerlink" title="日志滚动"></a>日志滚动</h1><p>日志滚动条件</p>
<ul>
<li>文件大小（例如每写满1G换下一个文件)</li>
<li>时间(每天零点新建一个日志文件，不论前一个文件是否写满）</li>
</ul>
<p>一个典型的日志文件名</p>
<ul>
<li>logfile_test.20130411-115604.popo.7743.log</li>
</ul>
<h2 id="LogFile-h"><a href="#LogFile-h" class="headerlink" title="LogFile.h"></a>LogFile.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_BASE_LOGFILE_H</span><br><span class="line">#define MUDUO_BASE_LOGFILE_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Mutex.h&quot;</span><br><span class="line">#include &quot;muduo/base/Types.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">namespace FileUtil</span><br><span class="line">&#123;</span><br><span class="line">class AppendFile;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LogFile : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  LogFile(const string&amp; basename,</span><br><span class="line">          off_t rollSize,</span><br><span class="line">          bool threadSafe = true,</span><br><span class="line">          int flushInterval = 3,</span><br><span class="line">          int checkEveryN = 1024);</span><br><span class="line">  ~LogFile();</span><br><span class="line"></span><br><span class="line">  void append(const char* logline, int len);//添加到日志文件</span><br><span class="line">  void flush();//清空缓冲区</span><br><span class="line">  bool rollFile();//滚动日志</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  void append_unlocked(const char* logline, int len);//不加锁的方式添加</span><br><span class="line"></span><br><span class="line">  static string getLogFileName(const string&amp; basename, time_t* now);</span><br><span class="line"></span><br><span class="line">  const string basename_;//日志文件 basename</span><br><span class="line">  const off_t rollSize_;//日志文件达到rollSize换一个新文件</span><br><span class="line">  const int flushInterval_;//日志写入间隔时间</span><br><span class="line">  const int checkEveryN_;</span><br><span class="line"></span><br><span class="line">  int count_;</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;MutexLock&gt; mutex_;//unique_ptr智能指针对象，不需要调用delete</span><br><span class="line">  time_t startOfPeriod_;//开始记录日志时间（调整至零点的时间）</span><br><span class="line">  time_t lastRoll_;//上一次滚动日志文件时间</span><br><span class="line">  time_t lastFlush_;//上一次日志写入文件时间</span><br><span class="line">  std::unique_ptr&lt;FileUtil::AppendFile&gt; file_;//这行代码声明了一个名为file_的std::unique_ptr，它将用于管理一个指向FileUtil::AppendFile类型对象的指针</span><br><span class="line"></span><br><span class="line">  const static int kRollPerSeconds_ = 60*60*24;//一天</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line">#endif  // MUDUO_BASE_LOGFILE_H</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="LogFile-cc"><a href="#LogFile-cc" class="headerlink" title="LogFile.cc"></a>LogFile.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/LogFile.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/FileUtil.h&quot;</span><br><span class="line">#include &quot;muduo/base/ProcessInfo.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">//可以实现多线程对同一个文件进行写入</span><br><span class="line">LogFile::LogFile(const string&amp; basename,</span><br><span class="line">                 off_t rollSize,</span><br><span class="line">                 bool threadSafe,</span><br><span class="line">                 int flushInterval,</span><br><span class="line">                 int checkEveryN)</span><br><span class="line">  : basename_(basename),</span><br><span class="line">    rollSize_(rollSize),</span><br><span class="line">    flushInterval_(flushInterval),</span><br><span class="line">    checkEveryN_(checkEveryN),</span><br><span class="line">    count_(0),</span><br><span class="line">    mutex_(threadSafe ? new MutexLock : NULL),//根据是否线程安全来初始化mutex</span><br><span class="line">    startOfPeriod_(0),</span><br><span class="line">    lastRoll_(0),</span><br><span class="line">    lastFlush_(0)</span><br><span class="line">&#123;</span><br><span class="line">  assert(basename.find(&#x27;/&#x27;) == string::npos);//断言basename不包含/</span><br><span class="line">  rollFile();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LogFile::~LogFile() = default;</span><br><span class="line"></span><br><span class="line">void LogFile::append(const char* logline, int len)</span><br><span class="line">&#123;</span><br><span class="line">  if (mutex_)</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(*mutex_);</span><br><span class="line">    append_unlocked(logline, len);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    append_unlocked(logline, len);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LogFile::flush()</span><br><span class="line">&#123;</span><br><span class="line">  if (mutex_)</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(*mutex_);</span><br><span class="line">    file_-&gt;flush();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    file_-&gt;flush();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LogFile::append_unlocked(const char* logline, int len)</span><br><span class="line">&#123;</span><br><span class="line">  file_-&gt;append(logline, len);</span><br><span class="line"></span><br><span class="line">  if (file_-&gt;writtenBytes() &gt; rollSize_)</span><br><span class="line">  &#123;</span><br><span class="line">    rollFile();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    ++count_;</span><br><span class="line">    if (count_ &gt;= checkEveryN_)</span><br><span class="line">    &#123;</span><br><span class="line">      count_ = 0;</span><br><span class="line">      time_t now = ::time(NULL);</span><br><span class="line">      time_t thisPeriod_ = now / kRollPerSeconds_ * kRollPerSeconds_;</span><br><span class="line">      if (thisPeriod_ != startOfPeriod_)</span><br><span class="line">      &#123;</span><br><span class="line">        rollFile();</span><br><span class="line">      &#125;</span><br><span class="line">      else if (now - lastFlush_ &gt; flushInterval_)</span><br><span class="line">      &#123;</span><br><span class="line">        lastFlush_ = now;</span><br><span class="line">        file_-&gt;flush();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool LogFile::rollFile()</span><br><span class="line">&#123;</span><br><span class="line">  time_t now = 0;</span><br><span class="line">  string filename = getLogFileName(basename_, &amp;now);//把当前时间返回回来</span><br><span class="line">  //对齐至kRollPerSeconds_的整数倍，也就是时间调整到当天零点</span><br><span class="line">  time_t start = now / kRollPerSeconds_ * kRollPerSeconds_;</span><br><span class="line"></span><br><span class="line">  if (now &gt; lastRoll_)</span><br><span class="line">  &#123;</span><br><span class="line">    lastRoll_ = now;</span><br><span class="line">    lastFlush_ = now;</span><br><span class="line">    startOfPeriod_ = start;</span><br><span class="line">    file_.reset(new FileUtil::AppendFile(filename));</span><br><span class="line">    //通过分配内存来初始化std::unique_ptr，并传递filename参数给FileUtil::AppendFile的构造函数</span><br><span class="line">    //当调用reset函数时，它会释放智能指针当前所持有的对象，并将指针指向一个新的对象或者置为nullptr。如果未提供参数，即不传递新对象指针给reset，则智能指针会释放当前持有的对象，并将其指向空指针（nullptr），相当于释放了内存</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string LogFile::getLogFileName(const string&amp; basename, time_t* now)</span><br><span class="line">&#123;</span><br><span class="line">  string filename;</span><br><span class="line">  filename.reserve(basename.size() + 64);</span><br><span class="line">  filename = basename;</span><br><span class="line"></span><br><span class="line">  char timebuf[32];</span><br><span class="line">  struct tm tm;</span><br><span class="line">  *now = time(NULL);//保存一下当前时间，距离1970.1.1零点的秒数</span><br><span class="line">  gmtime_r(now, &amp;tm); // FIXME: localtime_r ?GMT的时间，_r说明它是线程安全的，因为它还有一个相同的保存在tm中，不会被别的线程访问，如果改成localtime_r就不需要在当前时间加8</span><br><span class="line">  strftime(timebuf, sizeof timebuf, &quot;.%Y%m%d-%H%M%S.&quot;, &amp;tm);</span><br><span class="line">  filename += timebuf;</span><br><span class="line"></span><br><span class="line">  filename += ProcessInfo::hostname();</span><br><span class="line"></span><br><span class="line">  char pidbuf[32];</span><br><span class="line">  snprintf(pidbuf, sizeof pidbuf, &quot;.%d&quot;, ProcessInfo::pid());</span><br><span class="line">  filename += pidbuf;</span><br><span class="line"></span><br><span class="line">  filename += &quot;.log&quot;;</span><br><span class="line"></span><br><span class="line">  return filename;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Logging-test-cc"><a href="#Logging-test-cc" class="headerlink" title="Logging_test.cc"></a>Logging_test.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line">#include &quot;muduo/base/LogFile.h&quot;</span><br><span class="line">#include &quot;muduo/base/ThreadPool.h&quot;</span><br><span class="line">#include &quot;muduo/base/TimeZone.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int g_total;</span><br><span class="line">FILE* g_file;</span><br><span class="line">std::unique_ptr&lt;muduo::LogFile&gt; g_logFile;</span><br><span class="line"></span><br><span class="line">void dummyOutput(const char* msg, int len)</span><br><span class="line">&#123;</span><br><span class="line">  g_total += len;</span><br><span class="line">  if (g_file)</span><br><span class="line">  &#123;</span><br><span class="line">    fwrite(msg, 1, len, g_file);</span><br><span class="line">  &#125;</span><br><span class="line">  else if (g_logFile)</span><br><span class="line">  &#123;</span><br><span class="line">    g_logFile-&gt;append(msg, len);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bench(const char* type)</span><br><span class="line">&#123;</span><br><span class="line">  muduo::Logger::setOutput(dummyOutput);</span><br><span class="line">  muduo::Timestamp start(muduo::Timestamp::now());</span><br><span class="line">  g_total = 0;</span><br><span class="line"></span><br><span class="line">  int n = 1000*1000;</span><br><span class="line">  const bool kLongLog = false;</span><br><span class="line">  muduo::string empty = &quot; &quot;;</span><br><span class="line">  muduo::string longStr(3000, &#x27;X&#x27;);</span><br><span class="line">  longStr += &quot; &quot;;</span><br><span class="line">  for (int i = 0; i &lt; n; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_INFO &lt;&lt; &quot;Hello 0123456789&quot; &lt;&lt; &quot; abcdefghijklmnopqrstuvwxyz&quot;</span><br><span class="line">    //nop没有输出到标准输出和文件，因为上面的dummyOutput的g_file,g_logFile都是0</span><br><span class="line">             &lt;&lt; (kLongLog ? longStr : empty)</span><br><span class="line">             &lt;&lt; i;</span><br><span class="line">  &#125;</span><br><span class="line">  muduo::Timestamp end(muduo::Timestamp::now());</span><br><span class="line">  double seconds = timeDifference(end, start);</span><br><span class="line">  printf(&quot;%12s: %f seconds, %d bytes, %10.2f msg/s, %.2f MiB/s\n&quot;,</span><br><span class="line">         type, seconds, g_total, n / seconds, g_total / seconds / (1024 * 1024));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void logInThread()</span><br><span class="line">&#123;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;logInThread&quot;;//线程池在记日志</span><br><span class="line">  usleep(1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  getppid(); // for ltrace and strace</span><br><span class="line"></span><br><span class="line">  muduo::ThreadPool pool(&quot;pool&quot;);//线程池名称</span><br><span class="line">  pool.start(5);//启动5个线程</span><br><span class="line">  pool.run(logInThread);//下面5个都是在线程池当中运行的</span><br><span class="line">  pool.run(logInThread);</span><br><span class="line">  pool.run(logInThread);</span><br><span class="line">  pool.run(logInThread);</span><br><span class="line">  pool.run(logInThread);</span><br><span class="line"></span><br><span class="line">  LOG_TRACE &lt;&lt; &quot;trace&quot;;//主线程的输出</span><br><span class="line">  LOG_DEBUG &lt;&lt; &quot;debug&quot;;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;Hello&quot;;</span><br><span class="line">  LOG_WARN &lt;&lt; &quot;World&quot;;</span><br><span class="line">  LOG_ERROR &lt;&lt; &quot;Error&quot;;</span><br><span class="line">  LOG_INFO &lt;&lt; sizeof(muduo::Logger);</span><br><span class="line">  LOG_INFO &lt;&lt; sizeof(muduo::LogStream);</span><br><span class="line">  LOG_INFO &lt;&lt; sizeof(muduo::Fmt);</span><br><span class="line">  LOG_INFO &lt;&lt; sizeof(muduo::LogStream::Buffer);</span><br><span class="line">  //只要没有setOutput就是输出到标准输出</span><br><span class="line">  sleep(1);</span><br><span class="line">  bench(&quot;nop&quot;);//性能测试程序</span><br><span class="line"></span><br><span class="line">  char buffer[64*1024];</span><br><span class="line"></span><br><span class="line">  g_file = fopen(&quot;/dev/null&quot;, &quot;w&quot;);</span><br><span class="line">  setbuffer(g_file, buffer, sizeof buffer);</span><br><span class="line">  bench(&quot;/dev/null&quot;);//测试写入到/dev/null性能</span><br><span class="line">  fclose(g_file);</span><br><span class="line"></span><br><span class="line">  g_file = fopen(&quot;/tmp/log&quot;, &quot;w&quot;);</span><br><span class="line">  setbuffer(g_file, buffer, sizeof buffer);</span><br><span class="line">  bench(&quot;/tmp/log&quot;);</span><br><span class="line">  fclose(g_file);</span><br><span class="line"></span><br><span class="line">  g_file = NULL;</span><br><span class="line">  g_logFile.reset(new muduo::LogFile(&quot;test_log_st&quot;, 500*1000*1000, false));//false不是线程安全的</span><br><span class="line">  bench(&quot;test_log_st&quot;);</span><br><span class="line"></span><br><span class="line">  g_logFile.reset(new muduo::LogFile(&quot;test_log_mt&quot;, 500*1000*1000, true));</span><br><span class="line">  bench(&quot;test_log_mt&quot;);</span><br><span class="line">  g_logFile.reset();</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">  g_file = stdout;</span><br><span class="line">  sleep(1);</span><br><span class="line">  muduo::TimeZone beijing(8*3600, &quot;CST&quot;);</span><br><span class="line">  muduo::Logger::setTimeZone(beijing);</span><br><span class="line">  LOG_TRACE &lt;&lt; &quot;trace CST&quot;;//操作的是stream，重载了&lt;&lt;,按流的方式来操作日志</span><br><span class="line">  LOG_DEBUG &lt;&lt; &quot;debug CST&quot;;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;Hello CST&quot;;</span><br><span class="line">  LOG_WARN &lt;&lt; &quot;World CST&quot;;</span><br><span class="line">  LOG_ERROR &lt;&lt; &quot;Error CST&quot;;</span><br><span class="line"></span><br><span class="line">  sleep(1);</span><br><span class="line">  muduo::TimeZone newyork = muduo::TimeZone::loadZoneFile(&quot;/usr/share/zoneinfo/America/New_York&quot;);</span><br><span class="line">  muduo::Logger::setTimeZone(newyork);</span><br><span class="line">  LOG_TRACE &lt;&lt; &quot;trace NYT&quot;;</span><br><span class="line">  LOG_DEBUG &lt;&lt; &quot;debug NYT&quot;;</span><br><span class="line">  LOG_INFO &lt;&lt; &quot;Hello NYT&quot;;</span><br><span class="line">  LOG_WARN &lt;&lt; &quot;World NYT&quot;;</span><br><span class="line">  LOG_ERROR &lt;&lt; &quot;Error NYT&quot;;</span><br><span class="line">  g_file = NULL;</span><br><span class="line">  &#125;</span><br><span class="line">  bench(&quot;timezone nop&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%884%EF%BC%89/image-20230807161311439.png" alt="image-20230807161311439"></p>
<img src="/2023/08/04/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%884%EF%BC%89/image-20230807161311439.png" class title="This is an test image">

<h2 id="FileUtil类封装"><a href="#FileUtil类封装" class="headerlink" title="FileUtil类封装"></a>FileUtil类封装</h2><p>还有一个名为 <code>FileUtil</code> 的命名空间，它包含了两个类：<code>ReadSmallFile</code> 和 <code>AppendFile</code>，用于文件读取和文件追加写入操作。</p>
<ol>
<li><code>ReadSmallFile</code> 类：<ul>
<li>功能：用于读取小文件（小于 64KB）的内容。</li>
<li>成员变量：<ul>
<li><code>int fd_</code>：文件描述符，用于打开要读取的文件。</li>
<li><code>int err_</code>：存储错误码，表示读取过程中是否发生错误。</li>
<li><code>char buf_[kBufferSize]</code>：缓冲区，用于暂存读取的文件内容。</li>
</ul>
</li>
<li>成员函数：<ul>
<li>构造函数 <code>ReadSmallFile(StringArg filename)</code>：打开指定的文件，初始化文件描述符和错误码。</li>
<li>析构函数 <code>~ReadSmallFile()</code>：关闭文件。</li>
<li><code>int readToString(int maxSize, String* content, int64_t* fileSize, int64_t* modifyTime, int64_t* createTime)</code>：读取文件内容到指定的字符串对象中，并返回错误码。</li>
<li><code>int readToBuffer(int* size)</code>：将文件内容读取到缓冲区中，并返回错误码。</li>
</ul>
</li>
</ul>
</li>
<li><code>AppendFile</code> 类：<ul>
<li>功能：用于将内容追加写入文件。</li>
<li>成员变量：<ul>
<li><code>FILE* fp_</code>：文件指针，用于打开要写入的文件。</li>
<li><code>char buffer_[64*1024]</code>：缓冲区，用于暂存写入的内容。</li>
<li><code>off_t writtenBytes_</code>：记录已写入文件的字节数。</li>
</ul>
</li>
<li>成员函数：<ul>
<li>构造函数 <code>explicit AppendFile(StringArg filename)</code>：打开指定的文件，初始化文件指针和字节数。</li>
<li>析构函数 <code>~AppendFile()</code>：关闭文件。</li>
<li><code>void append(const char* logline, size_t len)</code>：将指定长度的内容追加写入文件。</li>
<li><code>void flush()</code>：将缓冲区内容写入文件，并清空缓冲区。</li>
<li><code>off_t writtenBytes() const</code>：返回已写入文件的字节数。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><code>FileUtil::readFile</code>函数模板：用于读取整个文件内容。它调用<code>FileUtil::ReadSmallFile</code>类中的<code>readToString</code>函数实现。</p>
<p>该文件操作类可用于进行文件读取和追加写入操作，并且对小文件进行了特别的处理以提高性能。需要注意的是，这些类在多线程环境下并不是线程安全的，因此在使用时需要注意并发访问的情况。但是但是logfile是线程安全的，所以在logfile用，也是安全的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/03/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%883%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/03/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%883%EF%BC%89/" class="post-title-link" itemprop="url">muduo-基础库（3）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-03 11:11:21" itemprop="dateCreated datePublished" datetime="2023-08-03T11:11:21+08:00">2023-08-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-07 10:34:02" itemprop="dateModified" datetime="2023-08-07T10:34:02+08:00">2023-08-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="线程安全Singleton类实现"><a href="#线程安全Singleton类实现" class="headerlink" title="线程安全Singleton类实现"></a>线程安全Singleton类实现</h1><ul>
<li><p>pthread_once </p>
</li>
<li><p>atexit</p>
</li>
<li><p>typedef char T_must_be_complete_type[sizeof(T)&#x3D;&#x3D;0? -1∶1];</p>
</li>
</ul>
<p>实现单例模式</p>
<h2 id="Singleton-h"><a href="#Singleton-h" class="headerlink" title="Singleton.h"></a>Singleton.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_BASE_SINGLETON_H</span><br><span class="line">#define MUDUO_BASE_SINGLETON_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/noncopyable.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt; // atexit</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">namespace detail</span><br><span class="line">&#123;</span><br><span class="line">// This doesn&#x27;t detect inherited member functions!</span><br><span class="line">// http://stackoverflow.com/questions/1966362/sfinae-to-check-for-inherited-member-functions</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct has_no_destroy</span><br><span class="line">&#123;</span><br><span class="line">  template &lt;typename C&gt; static char test(decltype(&amp;C::no_destroy));</span><br><span class="line">  template &lt;typename C&gt; static int32_t test(...);</span><br><span class="line">  const static bool value = sizeof(test&lt;T&gt;(0)) == 1;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  // namespace detail</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class Singleton : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  Singleton() = delete;</span><br><span class="line">  ~Singleton() = delete;</span><br><span class="line"></span><br><span class="line">  static T&amp; instance()</span><br><span class="line">  &#123;</span><br><span class="line">    pthread_once(&amp;ponce_, &amp;Singleton::init);//只创建一次value_ = new T();，同时保证线程安全</span><br><span class="line">    assert(value_ != NULL);</span><br><span class="line">    return *value_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  static void init()</span><br><span class="line">  &#123;</span><br><span class="line">    value_ = new T();</span><br><span class="line">    if (!detail::has_no_destroy&lt;T&gt;::value)</span><br><span class="line">    &#123;</span><br><span class="line">      ::atexit(destroy);//用于在程序退出时注册一个函数，该函数将在程序退出之前被调用</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static void destroy()</span><br><span class="line">  &#123;</span><br><span class="line">    typedef char T_must_be_complete_type[sizeof(T) == 0 ? -1 : 1];</span><br><span class="line">    //检查类型T是否完整。如果T是一个不完整的类型（比如只有前向声明而没有定义），那么这个typedef将会导致编译错误</span><br><span class="line">    //具体做法是，通过sizeof(T)来检查T的大小，如果T是一个不完整类型，则其大小为0，条件表达式结果为-1，否则为1。这样，如果T是不完整类型，就会尝试定义一个大小为-1的数组，从而导致编译错误</span><br><span class="line">    T_must_be_complete_type dummy; (void) dummy;</span><br><span class="line">    //这里使用了一个无操作的转换，目的是消除未使用变量的编译器警告。dummy是之前定义的T_must_be_complete_type数组，由于它不会被实际使用，为了避免编译器警告，使用(void)进行转换</span><br><span class="line">    delete value_;</span><br><span class="line">    value_ = NULL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  static pthread_once_t ponce_;</span><br><span class="line">  static T*             value_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">pthread_once_t Singleton&lt;T&gt;::ponce_ = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">T* Singleton&lt;T&gt;::value_ = NULL;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_BASE_SINGLETON_H</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Singleton-test-cc"><a href="#Singleton-test-cc" class="headerlink" title="Singleton_test.cc"></a>Singleton_test.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/Singleton.h&quot;</span><br><span class="line">#include &quot;muduo/base/CurrentThread.h&quot;</span><br><span class="line">#include &quot;muduo/base/Thread.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">class Test : muduo::noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  Test()</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;tid=%d, constructing %p\n&quot;, muduo::CurrentThread::tid(), this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~Test()</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;tid=%d, destructing %p %s\n&quot;, muduo::CurrentThread::tid(), this, name_.c_str());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const muduo::string&amp; name() const &#123; return name_; &#125;</span><br><span class="line">  void setName(const muduo::string&amp; n) &#123; name_ = n; &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  muduo::string name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class TestNoDestroy : muduo::noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  // Tag member for Singleton&lt;T&gt;</span><br><span class="line">  void no_destroy();//用于标记不调用析构函数</span><br><span class="line"></span><br><span class="line">  TestNoDestroy()</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;tid=%d, constructing TestNoDestroy %p\n&quot;, muduo::CurrentThread::tid(), this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~TestNoDestroy()</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;tid=%d, destructing TestNoDestroy %p\n&quot;, muduo::CurrentThread::tid(), this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void threadFunc()</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;tid=%d, %p name=%s\n&quot;,</span><br><span class="line">         muduo::CurrentThread::tid(),</span><br><span class="line">         &amp;muduo::Singleton&lt;Test&gt;::instance(),</span><br><span class="line">         muduo::Singleton&lt;Test&gt;::instance().name().c_str());</span><br><span class="line">  muduo::Singleton&lt;Test&gt;::instance().setName(&quot;only one, changed&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  muduo::Singleton&lt;Test&gt;::instance().setName(&quot;only one&quot;);</span><br><span class="line">  muduo::Thread t1(threadFunc);</span><br><span class="line">  t1.start();</span><br><span class="line">  t1.join();</span><br><span class="line">  printf(&quot;tid=%d, %p name=%s\n&quot;,</span><br><span class="line">         muduo::CurrentThread::tid(),</span><br><span class="line">         &amp;muduo::Singleton&lt;Test&gt;::instance(),</span><br><span class="line">         muduo::Singleton&lt;Test&gt;::instance().name().c_str());</span><br><span class="line">  muduo::Singleton&lt;TestNoDestroy&gt;::instance();//在首次调用 instance() 函数时，init() 函数会被调用，并且在 init() 函数内部使用了 new T() 进行对象的动态内存分配，从而调用了 TestNoDestroy 的构造函数来创建对象</span><br><span class="line">  printf(&quot;with valgrind, you should see %zd-byte memory leak.\n&quot;, sizeof(TestNoDestroy));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%883%EF%BC%89/image-20230803161712078.png" alt="image-20230803161712078"></p>
<img src="/2023/08/03/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%883%EF%BC%89/image-20230803161712078.png" class title="This is an test image">

<p>子线程和主线程共有一个<code>muduo::Singleton&lt;Test&gt;::instance().name().c_str()</code></p>
<h1 id="线程本地存储ThreadLocal-lt-T-gt-封装"><a href="#线程本地存储ThreadLocal-lt-T-gt-封装" class="headerlink" title="线程本地存储ThreadLocal&lt;T&gt;封装"></a>线程本地存储<code>ThreadLocal&lt;T&gt;</code>封装</h1><h2 id="ThreadLocal-h"><a href="#ThreadLocal-h" class="headerlink" title="ThreadLocal.h"></a>ThreadLocal.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#ifndef MUDUO_BASE_THREADLOCAL_H</span><br><span class="line">#define MUDUO_BASE_THREADLOCAL_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Mutex.h&quot;</span><br><span class="line">#include &quot;muduo/base/noncopyable.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class ThreadLocal : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  ThreadLocal()</span><br><span class="line">  &#123;</span><br><span class="line">    MCHECK(pthread_key_create(&amp;pkey_, &amp;ThreadLocal::destructor));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~ThreadLocal()</span><br><span class="line">  &#123;</span><br><span class="line">    MCHECK(pthread_key_delete(pkey_));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T&amp; value()//设置并返回perThreadValue</span><br><span class="line">  &#123;</span><br><span class="line">    T* perThreadValue = static_cast&lt;T*&gt;(pthread_getspecific(pkey_));</span><br><span class="line">    if (!perThreadValue)</span><br><span class="line">    &#123;</span><br><span class="line">      T* newObj = new T();</span><br><span class="line">      MCHECK(pthread_setspecific(pkey_, newObj));</span><br><span class="line">      perThreadValue = newObj;</span><br><span class="line">    &#125;</span><br><span class="line">    return *perThreadValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line"></span><br><span class="line">  static void destructor(void *x)</span><br><span class="line">  &#123;</span><br><span class="line">    T* obj = static_cast&lt;T*&gt;(x);</span><br><span class="line">    typedef char T_must_be_complete_type[sizeof(T) == 0 ? -1 : 1];</span><br><span class="line">    T_must_be_complete_type dummy; (void) dummy;</span><br><span class="line">    delete obj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  pthread_key_t pkey_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_BASE_THREADLOCAL_H</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="ThreadLocal-test-cc"><a href="#ThreadLocal-test-cc" class="headerlink" title="ThreadLocal_test.cc"></a>ThreadLocal_test.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/ThreadLocal.h&quot;</span><br><span class="line">#include &quot;muduo/base/CurrentThread.h&quot;</span><br><span class="line">#include &quot;muduo/base/Thread.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">class Test : muduo::noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  Test()</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;tid=%d, constructing %p\n&quot;, muduo::CurrentThread::tid(), this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~Test()</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;tid=%d, destructing %p %s\n&quot;, muduo::CurrentThread::tid(), this, name_.c_str());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const muduo::string&amp; name() const &#123; return name_; &#125;</span><br><span class="line">  void setName(const muduo::string&amp; n) &#123; name_ = n; &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  muduo::string name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">muduo::ThreadLocal&lt;Test&gt; testObj1;//每个线程都有，但是因为testObj1.value().setName(&quot;main one&quot;)，会使公有的变私有</span><br><span class="line">muduo::ThreadLocal&lt;Test&gt; testObj2;</span><br><span class="line"></span><br><span class="line">void print()</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;tid=%d, obj1 %p name=%s\n&quot;,</span><br><span class="line">         muduo::CurrentThread::tid(),</span><br><span class="line">         &amp;testObj1.value(),</span><br><span class="line">         testObj1.value().name().c_str());</span><br><span class="line">  printf(&quot;tid=%d, obj2 %p name=%s\n&quot;,</span><br><span class="line">         muduo::CurrentThread::tid(),</span><br><span class="line">         &amp;testObj2.value(),</span><br><span class="line">         testObj2.value().name().c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void threadFunc()//线程特定数据销毁，是利用static void destructor(void *x)</span><br><span class="line">&#123;</span><br><span class="line">  print();</span><br><span class="line">  testObj1.value().setName(&quot;changed 1&quot;);</span><br><span class="line">  testObj2.value().setName(&quot;changed 42&quot;);</span><br><span class="line">  print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  testObj1.value().setName(&quot;main one&quot;);//testObj1.value()返回的是muduo::ThreadLocal&lt;Test&gt; testObj1;创建时传入的Test对象</span><br><span class="line">  print();</span><br><span class="line">  muduo::Thread t1(threadFunc);</span><br><span class="line">  t1.start();</span><br><span class="line">  t1.join();</span><br><span class="line">  testObj2.value().setName(&quot;main two&quot;);</span><br><span class="line">  print();</span><br><span class="line"></span><br><span class="line">  pthread_exit(0);//退出当前线程，主线程</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%883%EF%BC%89/image-20230804111803394.png" alt="image-20230804111803394"></p>
<img src="/2023/08/03/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%883%EF%BC%89/image-20230804111803394.png" class title="This is an test image">

<h2 id="SingletonThreadLocal-test-cc"><a href="#SingletonThreadLocal-test-cc" class="headerlink" title="SingletonThreadLocal_test.cc"></a>SingletonThreadLocal_test.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/Singleton.h&quot;</span><br><span class="line">#include &quot;muduo/base/CurrentThread.h&quot;</span><br><span class="line">#include &quot;muduo/base/ThreadLocal.h&quot;</span><br><span class="line">#include &quot;muduo/base/Thread.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">class Test : muduo::noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  Test()</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;tid=%d, constructing %p\n&quot;, muduo::CurrentThread::tid(), this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~Test()</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;tid=%d, destructing %p %s\n&quot;, muduo::CurrentThread::tid(), this, name_.c_str());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const muduo::string&amp; name() const &#123; return name_; &#125;</span><br><span class="line">  void setName(const muduo::string&amp; n) &#123; name_ = n; &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  muduo::string name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define STL muduo::Singleton&lt;muduo::ThreadLocal&lt;Test&gt; &gt;::instance().value()</span><br><span class="line">//只是说muduo::ThreadLocal&lt;Test&gt;是单例的而不是Test，也就是每个value是不同的</span><br><span class="line">//即不同线程设置的value不同，读出的STL.name().c_str()是不一样的</span><br><span class="line">void print()</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;tid=%d, %p name=%s\n&quot;,</span><br><span class="line">         muduo::CurrentThread::tid(),</span><br><span class="line">         &amp;STL,</span><br><span class="line">         STL.name().c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void threadFunc(const char* changeTo)</span><br><span class="line">&#123;</span><br><span class="line">  print();</span><br><span class="line">  STL.setName(changeTo);</span><br><span class="line">  sleep(1);</span><br><span class="line">  print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  STL.setName(&quot;main one&quot;);</span><br><span class="line">  muduo::Thread t1(std::bind(threadFunc, &quot;thread1&quot;));</span><br><span class="line">  muduo::Thread t2(std::bind(threadFunc, &quot;thread2&quot;));</span><br><span class="line">  t1.start();</span><br><span class="line">  t2.start();</span><br><span class="line">  t1.join();</span><br><span class="line">  print();</span><br><span class="line">  t2.join();</span><br><span class="line">  pthread_exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%883%EF%BC%89/image-20230804111917446.png" alt="image-20230804111917446"></p>
<img src="/2023/08/03/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%883%EF%BC%89/image-20230804111917446.png" class title="This is an test image">

<p>这个例子只是说明<code>muduo::Singleton&lt;muduo::ThreadLocal&lt;Test&gt; &gt;::instance()</code>是单例对象，每个线程访问的都是同一个instance，通过单例模式可以把它当作全局变量，但是每个线程的value都不一样</p>
<h1 id="ThreadLocalSingleton-lt-T-gt-线程本地单例类封装"><a href="#ThreadLocalSingleton-lt-T-gt-线程本地单例类封装" class="headerlink" title="ThreadLocalSingleton&lt;T&gt;线程本地单例类封装"></a><code>ThreadLocalSingleton&lt;T&gt;</code>线程本地单例类封装</h1><p>线程本地存储机制：POD：__thread，TSD:定义的其它类</p>
<h2 id="ThreadLocalSingleton-h"><a href="#ThreadLocalSingleton-h" class="headerlink" title="ThreadLocalSingleton.h"></a>ThreadLocalSingleton.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#ifndef MUDUO_BASE_THREADLOCALSINGLETON_H</span><br><span class="line">#define MUDUO_BASE_THREADLOCALSINGLETON_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/noncopyable.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class ThreadLocalSingleton : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  ThreadLocalSingleton() = delete;</span><br><span class="line">  ~ThreadLocalSingleton() = delete;</span><br><span class="line"></span><br><span class="line">  static T&amp; instance()</span><br><span class="line">  &#123;</span><br><span class="line">    if (!t_value_)//因为都有，私有的所以不需要按照线程安全的方式来实现</span><br><span class="line">    &#123;</span><br><span class="line">      t_value_ = new T();</span><br><span class="line">      deleter_.set(t_value_);</span><br><span class="line">    &#125;</span><br><span class="line">    return *t_value_;//返回的是指针</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static T* pointer()</span><br><span class="line">  &#123;</span><br><span class="line">    return t_value_;//返回的是引用</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  static void destructor(void* obj)</span><br><span class="line">  &#123;</span><br><span class="line">    assert(obj == t_value_);</span><br><span class="line">    typedef char T_must_be_complete_type[sizeof(T) == 0 ? -1 : 1];</span><br><span class="line">    T_must_be_complete_type dummy; (void) dummy;</span><br><span class="line">    delete t_value_;</span><br><span class="line">    t_value_ = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Deleter//POSIX线程库的特定数据TSD实现的</span><br><span class="line">  &#123;</span><br><span class="line">   public:</span><br><span class="line">    Deleter()</span><br><span class="line">    &#123;</span><br><span class="line">      pthread_key_create(&amp;pkey_, &amp;ThreadLocalSingleton::destructor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Deleter()</span><br><span class="line">    &#123;</span><br><span class="line">      pthread_key_delete(pkey_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void set(T* newObj)</span><br><span class="line">    &#123;</span><br><span class="line">      assert(pthread_getspecific(pkey_) == NULL);</span><br><span class="line">      pthread_setspecific(pkey_, newObj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_key_t pkey_;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  static __thread T* t_value_;//表示每个线程都有,T*是POD类型</span><br><span class="line">  static Deleter deleter_;//是为了可以自动释放，和把指针设置进来</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">__thread T* ThreadLocalSingleton&lt;T&gt;::t_value_ = 0;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">typename ThreadLocalSingleton&lt;T&gt;::Deleter ThreadLocalSingleton&lt;T&gt;::deleter_;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line">#endif  // MUDUO_BASE_THREADLOCALSINGLETON_H</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="ThreadLocalSingleton-test-cc"><a href="#ThreadLocalSingleton-test-cc" class="headerlink" title="ThreadLocalSingleton_test.cc"></a>ThreadLocalSingleton_test.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/ThreadLocalSingleton.h&quot;</span><br><span class="line">#include &quot;muduo/base/CurrentThread.h&quot;</span><br><span class="line">#include &quot;muduo/base/Thread.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">class Test : muduo::noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  Test()</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;tid=%d, constructing %p\n&quot;, muduo::CurrentThread::tid(), this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~Test()</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;tid=%d, destructing %p %s\n&quot;, muduo::CurrentThread::tid(), this, name_.c_str());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const muduo::string&amp; name() const &#123; return name_; &#125;</span><br><span class="line">  void setName(const muduo::string&amp; n) &#123; name_ = n; &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  muduo::string name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void threadFunc(const char* changeTo)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;tid=%d, %p name=%s\n&quot;,</span><br><span class="line">         muduo::CurrentThread::tid(),</span><br><span class="line">         &amp;muduo::ThreadLocalSingleton&lt;Test&gt;::instance(),</span><br><span class="line">         muduo::ThreadLocalSingleton&lt;Test&gt;::instance().name().c_str());//间接调用了test构造函数</span><br><span class="line">  muduo::ThreadLocalSingleton&lt;Test&gt;::instance().setName(changeTo);</span><br><span class="line">  printf(&quot;tid=%d, %p name=%s\n&quot;,</span><br><span class="line">         muduo::CurrentThread::tid(),</span><br><span class="line">         &amp;muduo::ThreadLocalSingleton&lt;Test&gt;::instance(),</span><br><span class="line">         muduo::ThreadLocalSingleton&lt;Test&gt;::instance().name().c_str());</span><br><span class="line"></span><br><span class="line">  // no need to manually delete it</span><br><span class="line">  // muduo::ThreadLocalSingleton&lt;Test&gt;::destroy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  muduo::ThreadLocalSingleton&lt;Test&gt;::instance().setName(&quot;main one&quot;);</span><br><span class="line">  //因为有__thread，线程本地存储的原因，所以每个线程都有构造函数这一步骤</span><br><span class="line">  muduo::Thread t1(std::bind(threadFunc, &quot;thread1&quot;));</span><br><span class="line">  muduo::Thread t2(std::bind(threadFunc, &quot;thread2&quot;));</span><br><span class="line">  t1.start();</span><br><span class="line">  t2.start();</span><br><span class="line">  t1.join();</span><br><span class="line">  printf(&quot;tid=%d, %p name=%s\n&quot;,</span><br><span class="line">         muduo::CurrentThread::tid(),</span><br><span class="line">         &amp;muduo::ThreadLocalSingleton&lt;Test&gt;::instance(),</span><br><span class="line">         muduo::ThreadLocalSingleton&lt;Test&gt;::instance().name().c_str());</span><br><span class="line">  t2.join();</span><br><span class="line"></span><br><span class="line">  pthread_exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%883%EF%BC%89/image-20230804121019493.png" alt="image-20230804121019493"></p>
<img src="/2023/08/03/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%883%EF%BC%89/image-20230804121019493.png" class title="This is an test image">

<p><code>__thread</code> 关键字在 C++ 中用于声明线程局部变量。当你使用 <code>__thread</code> 来声明一个用户自定义类的变量时，意味着每个线程将有自己独立的该变量实例，并且在一个线程中对该变量所做的更改不会影响其他线程中该变量的值。</p>
<p>在提供的代码中，<code>__thread</code> 用于在 <code>ThreadLocalSingleton</code> 类中声明 <code>t_value_</code> 变量。这使得 <code>t_value_</code> 成为一个类型为 <code>T*</code> 的线程局部变量（指向用户定义的类 <code>T</code> 的指针）。当你调用 <code>muduo::ThreadLocalSingleton&lt;Test&gt;::instance()</code> 时，它返回与调用线程关联的 <code>Test</code> 类的线程局部实例的引用。</p>
<p>请注意，当使用 <code>__thread</code> 来声明线程局部变量时，必须在类声明之外的地方单独提供变量的定义（通常在源文件中）。这就是你看到以下定义的原因：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cpp复制代码template&lt;typename T&gt;</span><br><span class="line">__thread T* ThreadLocalSingleton&lt;T&gt;::t_value_ = 0;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">typename ThreadLocalSingleton&lt;T&gt;::Deleter ThreadLocalSingleton&lt;T&gt;::deleter_;</span><br></pre></td></tr></table></figure>

<p>这些定义确保每个线程拥有自己独立的 <code>t_value_</code> 和 <code>deleter_</code> 实例。<code>ThreadLocalSingleton</code> 类使用这些线程局部变量来在每个线程上管理用户定义类 <code>T</code> 的实例。这使得 <code>ThreadLocalSingleton</code> 类能够为每个线程提供一个独立的单例模式。</p>
<p>在 C++03 标准中，<code>__thread</code> 确实只能用于修饰 POD（Plain Old Data）类型，也就是简单的标量类型或者是包含简单标量类型的结构体，而不包含任何自定义构造函数、析构函数、虚函数、或者是含有虚函数的基类。</p>
<p>然而，在 C++11 标准中，<code>__thread</code> 被 <code>thread_local</code> 关键字所取代，并且 <code>thread_local</code> 关键字没有限制只能修饰 POD 类型，它可以用于修饰任何类型，包括用户自定义的类对象。</p>
<p>需要注意的是，在 C++11 之后，应尽量使用 <code>thread_local</code> 关键字来声明线程局部变量，以取代过时的 <code>__thread</code> 关键字，因为 <code>thread_local</code> 更加标准化和跨平台，同时还支持更多类型的线程局部存储。</p>
<p> <code>__thread</code> 关键字在很多编译器中与 <code>thread_local</code> 关键字具有相同的特性。虽然 <code>__thread</code> 关键字是过时的写法，但在很多编译器中仍然可以使用，并且通常与 <code>thread_local</code> 关键字功能相同。</p>
<p>这两个关键字的共同特性是都用于声明线程局部变量 (TLS)，使得每个线程都拥有自己独立的变量副本。每个线程都会维护一个独立的变量，而不会互相干扰。</p>
<p>然而，值得注意的是，虽然在很多情况下 <code>__thread</code> 和 <code>thread_local</code> 可以互换使用，但在某些编译器和特定的情况下可能会有细微的差异。为了确保最佳的可移植性和标准兼容性，推荐使用 <code>thread_local</code> 关键字，因为它是C++11标准中正式定义的线程局部存储方案，具有更好的支持和更广泛的应用。</p>
<hr>
<p>POSIX线程库中的线程特定数据（Thread-Specific Data，TSD）是一种机制，它允许程序员在多线程环境中为每个线程存储独立的数据。这样，每个线程都可以拥有自己的独立数据副本，而不会互相干扰。</p>
<p>在POSIX线程库中，TSD可以通过以下两个函数来实现：</p>
<ol>
<li><code>pthread_key_create</code>: 用于创建一个TSD键，该键在所有线程中具有唯一标识符。当一个线程创建一个TSD键后，其他线程可以通过该键来访问其独立的数据。</li>
<li><code>pthread_setspecific</code>: 用于将一个特定值与TSD键关联，这样当前线程就拥有了该键对应的独立数据。</li>
</ol>
<p>每个线程可以通过调用 <code>pthread_getspecific</code> 函数来获取与TSD键关联的数据，这样就可以实现线程局部存储 (TLS)。当线程退出时，与其相关联的TSD数据会被自动清理和释放，避免了内存泄漏。</p>
<p>POSIX线程库的TSD机制为多线程编程提供了一种简单且有效的方式来管理线程本地存储，从而在不同线程之间实现数据隔离。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/01/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%882%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/01/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%882%EF%BC%89/" class="post-title-link" itemprop="url">muduo-基础库（2）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-01 15:52:49" itemprop="dateCreated datePublished" datetime="2023-08-01T15:52:49+08:00">2023-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-14 11:08:32" itemprop="dateModified" datetime="2023-08-14T11:08:32+08:00">2023-08-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="线程封装Thread"><a href="#线程封装Thread" class="headerlink" title="线程封装Thread"></a>线程封装Thread</h1><p><code>__thread</code>，gcc内置的线程局部存储设施,定义之后表示每个线程都有的</p>
<ul>
<li><code>__thread</code>只能修饰POD类型</li>
<li>POD类型（plain old data），与C兼容的原始数据,例如，结构和整型等C语言中的类型是POD类型，但带有用户定义的构造函数或虚函数的类则不是.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void afterFork()//fork可能是在主线程中调用，也可能是在子线程中调用</span><br><span class="line">				//fork得到一个新进程，新进程只有一个执行序列，只有一个线程（调用fork的线程被继承下来)</span><br><span class="line">&#123;</span><br><span class="line">  muduo::CurrentThread::t_cachedTid = 0;</span><br><span class="line">  muduo::CurrentThread::t_threadName = &quot;main&quot;;</span><br><span class="line">  CurrentThread::tid();</span><br><span class="line">  // no need to call pthread_atfork(NULL, NULL, &amp;afterFork);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ThreadNameInitializer</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  ThreadNameInitializer()</span><br><span class="line">  &#123;</span><br><span class="line">    muduo::CurrentThread::t_threadName = &quot;main&quot;;</span><br><span class="line">    CurrentThread::tid();</span><br><span class="line">    pthread_atfork(NULL, NULL, &amp;afterFork);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ThreadNameInitializer init;//相当于全局变量，一开始就构造了</span><br></pre></td></tr></table></figure>

<p><code>pthread_atfork</code> 是一个 POSIX 线程库中的函数，用于注册在 <code>fork</code> 调用之前和之后执行的回调函数，以便在创建子进程时进行资源管理和同步操作。</p>
<p>该函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void));</span><br></pre></td></tr></table></figure>

<ul>
<li><code>prepare</code>: 当调用 <code>fork</code> 准备复制父进程之前，会调用此函数指定的回调函数。在此回调函数中，可以释放或重新初始化某些资源，以确保子进程继承了预期状态。该回调函数在父进程中执行。</li>
<li><code>parent</code>: 在成功创建子进程后，会在父进程中调用此函数指定的回调函数。在此回调函数中，可以恢复资源状态或重新初始化需要在父进程中使用的资源。</li>
<li><code>child</code>: 在成功创建子进程后，会在子进程中调用此函数指定的回调函数。在此回调函数中，可以重新初始化需要在子进程中使用的资源。</li>
</ul>
<p><code>pthread_atfork</code> 的使用场景通常涉及到多线程程序中调用 <code>fork</code> 创建新进程时，因为 <code>fork</code> 会复制当前进程的所有线程和资源，可能导致一些资源和同步问题。通过注册 <code>pthread_atfork</code> 提供的回调函数，我们可以在 <code>fork</code> 前后进行一些资源管理和同步操作，以确保子进程的创建过程是可控的。</p>
<p>需要注意的是，使用 <code>fork</code> 和 <code>pthread_atfork</code> 需要非常小心，因为它涉及到多线程和多进程的复杂情况。在使用之前，确保你充分理解了相关的潜在问题和风险，并进行必要的测试和验证。另外，如果可能，尽量避免在多线程程序中使用 <code>fork</code>，以减少潜在的问题和调试难度。</p>
<p>父进程在创建了一个线程，在doit并对mutex加锁,<br>父进程创建一个子进程，在子进程中调用doit，由于子进程会复制父进程的内存，这时候mutex处于锁的状态，父进程在复制子进程的时候，只会复制当前线程的执行状态,其它线程不会复制。因此子进程会处于死锁的状态。相当于在不知道加锁的情况下又加锁</p>
<p>CurrentThread</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// internal,__thread修饰的变量是线程局部存储的。也就是私有的线程内的全局变量。</span><br><span class="line"> extern __thread int t_cachedTid;//线程真实pid（tid）的缓存，是为了提高获取tid的效率，减少系统调用的次数::syscall(SYS_gettid)</span><br><span class="line"> extern __thread char t_tidString[32];//tid字符串的表现形式</span><br><span class="line"> extern __thread int t_tidStringLength;</span><br><span class="line"> extern __thread const char* t_threadName;//每个线程的名称</span><br></pre></td></tr></table></figure>

<h2 id="Thread-h"><a href="#Thread-h" class="headerlink" title="Thread.h"></a>Thread.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_BASE_THREAD_H</span><br><span class="line">#define MUDUO_BASE_THREAD_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Atomic.h&quot;</span><br><span class="line">#include &quot;muduo/base/CountDownLatch.h&quot;</span><br><span class="line">#include &quot;muduo/base/Types.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">class Thread : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  typedef std::function&lt;void ()&gt; ThreadFunc;</span><br><span class="line"></span><br><span class="line">  explicit Thread(ThreadFunc, const string&amp; name = string());</span><br><span class="line">  // FIXME: make it movable in C++11</span><br><span class="line">  ~Thread();</span><br><span class="line"></span><br><span class="line">  void start();</span><br><span class="line">  int join(); // return pthread_join()</span><br><span class="line"></span><br><span class="line">  bool started() const &#123; return started_; &#125;</span><br><span class="line">  // pthread_t pthreadId() const &#123; return pthreadId_; &#125;</span><br><span class="line">  pid_t tid() const &#123; return tid_; &#125;</span><br><span class="line">  const string&amp; name() const &#123; return name_; &#125;</span><br><span class="line"></span><br><span class="line">  static int numCreated() &#123; return numCreated_.get(); &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  void setDefaultName();</span><br><span class="line"></span><br><span class="line">  bool       started_;</span><br><span class="line">  bool       joined_;</span><br><span class="line">  pthread_t  pthreadId_;</span><br><span class="line">  pid_t      tid_;</span><br><span class="line">  ThreadFunc func_;</span><br><span class="line">  string     name_;</span><br><span class="line">  CountDownLatch latch_;</span><br><span class="line"></span><br><span class="line">  static AtomicInt32 numCreated_;//private 成员只能在类的成员函数（包括静态成员函数）内部访问，不能在类外部直接访问。</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line">#endif  // MUDUO_BASE_THREAD_H</span><br></pre></td></tr></table></figure>

<h2 id="Thread-cc"><a href="#Thread-cc" class="headerlink" title="Thread.cc"></a>Thread.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/Thread.h&quot;</span><br><span class="line">#include &quot;muduo/base/CurrentThread.h&quot;</span><br><span class="line">#include &quot;muduo/base/Exception.h&quot;</span><br><span class="line">//#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;type_traits&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/prctl.h&gt;</span><br><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;linux/unistd.h&gt;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace detail</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">pid_t gettid()</span><br><span class="line">&#123;</span><br><span class="line">  return static_cast&lt;pid_t&gt;(::syscall(SYS_gettid));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void afterFork()</span><br><span class="line">&#123;</span><br><span class="line">  muduo::CurrentThread::t_cachedTid = 0;</span><br><span class="line">  muduo::CurrentThread::t_threadName = &quot;main&quot;;</span><br><span class="line">  CurrentThread::tid();</span><br><span class="line">  // no need to call pthread_atfork(NULL, NULL, &amp;afterFork);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ThreadNameInitializer</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  ThreadNameInitializer()</span><br><span class="line">  &#123;</span><br><span class="line">    muduo::CurrentThread::t_threadName = &quot;main&quot;;</span><br><span class="line">    CurrentThread::tid();</span><br><span class="line">    pthread_atfork(NULL, NULL, &amp;afterFork);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ThreadNameInitializer init;</span><br><span class="line"></span><br><span class="line">struct ThreadData</span><br><span class="line">&#123;</span><br><span class="line">  typedef muduo::Thread::ThreadFunc ThreadFunc;</span><br><span class="line">  ThreadFunc func_;</span><br><span class="line">  string name_;</span><br><span class="line">  pid_t* tid_;</span><br><span class="line">  CountDownLatch* latch_;</span><br><span class="line"></span><br><span class="line">  ThreadData(ThreadFunc func,</span><br><span class="line">             const string&amp; name,</span><br><span class="line">             pid_t* tid,</span><br><span class="line">             CountDownLatch* latch)</span><br><span class="line">    : func_(std::move(func)),</span><br><span class="line">      name_(name),</span><br><span class="line">      tid_(tid),</span><br><span class="line">      latch_(latch)</span><br><span class="line">  &#123; &#125;</span><br><span class="line"></span><br><span class="line">  void runInThread()</span><br><span class="line">  &#123;</span><br><span class="line">    *tid_ = muduo::CurrentThread::tid();</span><br><span class="line">    tid_ = NULL;</span><br><span class="line">    latch_-&gt;countDown();</span><br><span class="line">    latch_ = NULL;</span><br><span class="line"></span><br><span class="line">    muduo::CurrentThread::t_threadName = name_.empty() ? &quot;muduoThread&quot; : name_.c_str();</span><br><span class="line">    ::prctl(PR_SET_NAME, muduo::CurrentThread::t_threadName);</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      func_();</span><br><span class="line">      muduo::CurrentThread::t_threadName = &quot;finished&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (const Exception&amp; ex)</span><br><span class="line">    &#123;</span><br><span class="line">      muduo::CurrentThread::t_threadName = &quot;crashed&quot;;</span><br><span class="line">      fprintf(stderr, &quot;exception caught in Thread %s\n&quot;, name_.c_str());</span><br><span class="line">      fprintf(stderr, &quot;reason: %s\n&quot;, ex.what());</span><br><span class="line">      fprintf(stderr, &quot;stack trace: %s\n&quot;, ex.stackTrace());</span><br><span class="line">      abort();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (const std::exception&amp; ex)</span><br><span class="line">    &#123;</span><br><span class="line">      muduo::CurrentThread::t_threadName = &quot;crashed&quot;;</span><br><span class="line">      fprintf(stderr, &quot;exception caught in Thread %s\n&quot;, name_.c_str());</span><br><span class="line">      fprintf(stderr, &quot;reason: %s\n&quot;, ex.what());</span><br><span class="line">      abort();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (...)</span><br><span class="line">    &#123;</span><br><span class="line">      muduo::CurrentThread::t_threadName = &quot;crashed&quot;;</span><br><span class="line">      fprintf(stderr, &quot;unknown exception caught in Thread %s\n&quot;, name_.c_str());</span><br><span class="line">      throw; // rethrow</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void* startThread(void* obj)</span><br><span class="line">&#123;</span><br><span class="line">  ThreadData* data = static_cast&lt;ThreadData*&gt;(obj);</span><br><span class="line">  data-&gt;runInThread();</span><br><span class="line">  delete data;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace detail</span><br><span class="line"></span><br><span class="line">void CurrentThread::cacheTid()</span><br><span class="line">&#123;</span><br><span class="line">  if (t_cachedTid == 0)</span><br><span class="line">  &#123;</span><br><span class="line">    t_cachedTid = detail::gettid();</span><br><span class="line">    t_tidStringLength = snprintf(t_tidString, sizeof t_tidString, &quot;%5d &quot;, t_cachedTid);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool CurrentThread::isMainThread()</span><br><span class="line">&#123;</span><br><span class="line">  return tid() == ::getpid();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CurrentThread::sleepUsec(int64_t usec)</span><br><span class="line">&#123;</span><br><span class="line">  struct timespec ts = &#123; 0, 0 &#125;;</span><br><span class="line">  ts.tv_sec = static_cast&lt;time_t&gt;(usec / Timestamp::kMicroSecondsPerSecond);</span><br><span class="line">  ts.tv_nsec = static_cast&lt;long&gt;(usec % Timestamp::kMicroSecondsPerSecond * 1000);</span><br><span class="line">  ::nanosleep(&amp;ts, NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AtomicInt32 Thread::numCreated_;</span><br><span class="line"></span><br><span class="line">Thread::Thread(ThreadFunc func, const string&amp; n)</span><br><span class="line">  : started_(false),</span><br><span class="line">    joined_(false),</span><br><span class="line">    pthreadId_(0),</span><br><span class="line">    tid_(0),</span><br><span class="line">    func_(std::move(func)),</span><br><span class="line">    name_(n),</span><br><span class="line">    latch_(1)</span><br><span class="line">&#123;</span><br><span class="line">  setDefaultName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread::~Thread()</span><br><span class="line">&#123;</span><br><span class="line">  if (started_ &amp;&amp; !joined_)</span><br><span class="line">  &#123;</span><br><span class="line">    pthread_detach(pthreadId_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Thread::setDefaultName()</span><br><span class="line">&#123;</span><br><span class="line">  int num = numCreated_.incrementAndGet();//使用原子类型确保了多线程环境下对 numCreated_ 的增加操作是安全的，不会出现竞态条件。因此，无论多少个线程同时创建 Thread 对象，都能保证 numCreated_ 的计数正确并且线程安全。</span><br><span class="line">  if (name_.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    char buf[32];</span><br><span class="line">    snprintf(buf, sizeof buf, &quot;Thread%d&quot;, num);</span><br><span class="line">    name_ = buf;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Thread::start()</span><br><span class="line">&#123;</span><br><span class="line">  assert(!started_);</span><br><span class="line">  started_ = true;</span><br><span class="line">  // FIXME: move(func_)</span><br><span class="line">  detail::ThreadData* data = new detail::ThreadData(func_, name_, &amp;tid_, &amp;latch_);</span><br><span class="line">  if (pthread_create(&amp;pthreadId_, NULL, &amp;detail::startThread, data))</span><br><span class="line">  &#123;</span><br><span class="line">    started_ = false;</span><br><span class="line">    delete data; // or no delete?</span><br><span class="line">    LOG_SYSFATAL &lt;&lt; &quot;Failed in pthread_create&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    latch_.wait();</span><br><span class="line">    assert(tid_ &gt; 0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Thread::join()</span><br><span class="line">&#123;</span><br><span class="line">  assert(started_);</span><br><span class="line">  assert(!joined_);</span><br><span class="line">  joined_ = true;</span><br><span class="line">  return pthread_join(pthreadId_, NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br></pre></td></tr></table></figure>

<h2 id="CurrentThread-h"><a href="#CurrentThread-h" class="headerlink" title="CurrentThread.h"></a>CurrentThread.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_BASE_CURRENTTHREAD_H</span><br><span class="line">#define MUDUO_BASE_CURRENTTHREAD_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Types.h&quot;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace CurrentThread</span><br><span class="line">&#123;</span><br><span class="line">  // internal,__thread修饰的变量是线程局部存储的。也就是私有的线程内的全局变量。</span><br><span class="line">  extern __thread int t_cachedTid;//线程真实pid（tid）的缓存，是为了提高获取tid的效率，减少系统调用的次数::syscall(SYS_gettid)</span><br><span class="line">  extern __thread char t_tidString[32];//tid字符串的表现形式</span><br><span class="line">  extern __thread int t_tidStringLength;</span><br><span class="line">  extern __thread const char* t_threadName;//每个线程的名称</span><br><span class="line">  void cacheTid();</span><br><span class="line"></span><br><span class="line">  inline int tid()</span><br><span class="line">  &#123;</span><br><span class="line">    if (__builtin_expect(t_cachedTid == 0, 0))//__builtin_expect 是 GCC（GNU Compiler Collection）提供的编译器内置函数。它用于告诉编译器一个分支条件的预期，以便编译器优化代码执行路径</span><br><span class="line">    &#123;</span><br><span class="line">      cacheTid();</span><br><span class="line">    &#125;</span><br><span class="line">    return t_cachedTid;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  inline const char* tidString() // for logging</span><br><span class="line">  &#123;</span><br><span class="line">    return t_tidString;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  inline int tidStringLength() // for logging</span><br><span class="line">  &#123;</span><br><span class="line">    return t_tidStringLength;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  inline const char* name()</span><br><span class="line">  &#123;</span><br><span class="line">    return t_threadName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bool isMainThread();</span><br><span class="line"></span><br><span class="line">  void sleepUsec(int64_t usec);  // for testing</span><br><span class="line"></span><br><span class="line">  string stackTrace(bool demangle);</span><br><span class="line">&#125;  // namespace CurrentThread</span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_BASE_CURRENTTHREAD_H</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="CurrentThread-cc"><a href="#CurrentThread-cc" class="headerlink" title="CurrentThread.cc"></a>CurrentThread.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/CurrentThread.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;cxxabi.h&gt;</span><br><span class="line">#include &lt;execinfo.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line">namespace CurrentThread</span><br><span class="line">&#123;</span><br><span class="line">__thread int t_cachedTid = 0;</span><br><span class="line">__thread char t_tidString[32];</span><br><span class="line">__thread int t_tidStringLength = 6;</span><br><span class="line">__thread const char* t_threadName = &quot;unknown&quot;;</span><br><span class="line">static_assert(std::is_same&lt;int, pid_t&gt;::value, &quot;pid_t should be int&quot;);</span><br><span class="line"></span><br><span class="line">string stackTrace(bool demangle)</span><br><span class="line">&#123;</span><br><span class="line">  string stack;</span><br><span class="line">  const int max_frames = 200;</span><br><span class="line">  void* frame[max_frames];</span><br><span class="line">  int nptrs = ::backtrace(frame, max_frames);</span><br><span class="line">  char** strings = ::backtrace_symbols(frame, nptrs);</span><br><span class="line">  if (strings)</span><br><span class="line">  &#123;</span><br><span class="line">    size_t len = 256;</span><br><span class="line">    char* demangled = demangle ? static_cast&lt;char*&gt;(::malloc(len)) : nullptr;</span><br><span class="line">    for (int i = 1; i &lt; nptrs; ++i)  // skipping the 0-th, which is this function</span><br><span class="line">    &#123;</span><br><span class="line">      if (demangle)</span><br><span class="line">      &#123;</span><br><span class="line">        // https://panthema.net/2008/0901-stacktrace-demangled/</span><br><span class="line">        // bin/exception_test(_ZN3Bar4testEv+0x79) [0x401909]</span><br><span class="line">        char* left_par = nullptr;</span><br><span class="line">        char* plus = nullptr;</span><br><span class="line">        for (char* p = strings[i]; *p; ++p)</span><br><span class="line">        &#123;</span><br><span class="line">          if (*p == &#x27;(&#x27;)</span><br><span class="line">            left_par = p;</span><br><span class="line">          else if (*p == &#x27;+&#x27;)</span><br><span class="line">            plus = p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (left_par &amp;&amp; plus)</span><br><span class="line">        &#123;</span><br><span class="line">          *plus = &#x27;\0&#x27;;</span><br><span class="line">          int status = 0;</span><br><span class="line">          char* ret = abi::__cxa_demangle(left_par+1, demangled, &amp;len, &amp;status);</span><br><span class="line">          *plus = &#x27;+&#x27;;</span><br><span class="line">          if (status == 0)</span><br><span class="line">          &#123;</span><br><span class="line">            demangled = ret;  // ret could be realloc()</span><br><span class="line">            stack.append(strings[i], left_par+1);</span><br><span class="line">            stack.append(demangled);</span><br><span class="line">            stack.append(plus);</span><br><span class="line">            stack.push_back(&#x27;\n&#x27;);</span><br><span class="line">            continue;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // Fallback to mangled names</span><br><span class="line">      stack.append(strings[i]);</span><br><span class="line">      stack.push_back(&#x27;\n&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    free(demangled);</span><br><span class="line">    free(strings);</span><br><span class="line">  &#125;</span><br><span class="line">  return stack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace CurrentThread</span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Thread-test-cc"><a href="#Thread-test-cc" class="headerlink" title="Thread_test.cc"></a>Thread_test.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/Thread.h&quot;</span><br><span class="line">#include &quot;muduo/base/CurrentThread.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void mysleep(int seconds)</span><br><span class="line">&#123;</span><br><span class="line">  timespec t = &#123; seconds, 0 &#125;;//timespec 是 POSIX 中定义的用于表示时间的结构体，包含了秒数和纳秒数两个成员</span><br><span class="line">  nanosleep(&amp;t, NULL); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void threadFunc()</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;tid=%d\n&quot;, muduo::CurrentThread::tid());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void threadFunc2(int x)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;tid=%d, x=%d\n&quot;, muduo::CurrentThread::tid(), x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void threadFunc3()</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;tid=%d\n&quot;, muduo::CurrentThread::tid());</span><br><span class="line">  mysleep(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Foo</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  explicit Foo(double x)</span><br><span class="line">    : x_(x)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void memberFunc()</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;tid=%d, Foo::x_=%f\n&quot;, muduo::CurrentThread::tid(), x_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void memberFunc2(const std::string&amp; text)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;tid=%d, Foo::x_=%f, text=%s\n&quot;, muduo::CurrentThread::tid(), x_, text.c_str());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  double x_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;pid=%d, tid=%d\n&quot;, ::getpid(), muduo::CurrentThread::tid());</span><br><span class="line"></span><br><span class="line">  muduo::Thread t1(threadFunc);</span><br><span class="line">  t1.start();</span><br><span class="line">  printf(&quot;t1.tid=%d\n&quot;, t1.tid());</span><br><span class="line">  t1.join();</span><br><span class="line"></span><br><span class="line">  muduo::Thread t2(std::bind(threadFunc2, 42),</span><br><span class="line">                   &quot;thread for free function with argument&quot;);</span><br><span class="line">  t2.start();</span><br><span class="line">  printf(&quot;t2.tid=%d\n&quot;, t2.tid());</span><br><span class="line">  t2.join();</span><br><span class="line"></span><br><span class="line">  Foo foo(87.53);</span><br><span class="line">  muduo::Thread t3(std::bind(&amp;Foo::memberFunc, &amp;foo),</span><br><span class="line">                   &quot;thread for member function without argument&quot;);</span><br><span class="line">  t3.start();</span><br><span class="line">  t3.join();</span><br><span class="line"></span><br><span class="line">  muduo::Thread t4(std::bind(&amp;Foo::memberFunc2, std::ref(foo), std::string(&quot;Shuo Chen&quot;)));</span><br><span class="line">  t4.start();</span><br><span class="line">  t4.join();</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    muduo::Thread t5(threadFunc3);</span><br><span class="line">    t5.start();</span><br><span class="line">    // t5 may destruct eariler than thread creation.</span><br><span class="line">  &#125;</span><br><span class="line">  mysleep(2);</span><br><span class="line">  &#123;</span><br><span class="line">    muduo::Thread t6(threadFunc3);</span><br><span class="line">    t6.start();</span><br><span class="line">    mysleep(2);</span><br><span class="line">    // t6 destruct later than thread creation.</span><br><span class="line">  &#125;</span><br><span class="line">  sleep(2);</span><br><span class="line">  printf(&quot;number of created threads %d\n&quot;, muduo::Thread::numCreated());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从测试文件开始，主要是<strong>基于对象编程思想</strong>，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">muduo::Thread t2(std::bind(threadFunc2, 42),</span><br><span class="line">                   &quot;thread for free function with argument&quot;);</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>

<p>将threadFunc2利用函数适配器传入func_(std::move(func))</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Thread::Thread(ThreadFunc func, const string&amp; n)</span><br><span class="line">  : started_(false),</span><br><span class="line">    joined_(false),</span><br><span class="line">    pthreadId_(0),</span><br><span class="line">    tid_(0),</span><br><span class="line">    func_(std::move(func)),</span><br><span class="line">    name_(n),</span><br><span class="line">    latch_(1)</span><br><span class="line">&#123;</span><br><span class="line">  setDefaultName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void Thread::start()</span><br><span class="line">&#123;</span><br><span class="line">  assert(!started_);</span><br><span class="line">  started_ = true;</span><br><span class="line">  // FIXME: move(func_)</span><br><span class="line">  detail::ThreadData* data = new detail::ThreadData(func_, name_, &amp;tid_, &amp;latch_);</span><br><span class="line">  if (pthread_create(&amp;pthreadId_, NULL, &amp;detail::startThread, data))</span><br><span class="line">  &#123;</span><br><span class="line">    started_ = false;</span><br><span class="line">    delete data; // or no delete?</span><br><span class="line">    LOG_SYSFATAL &lt;&lt; &quot;Failed in pthread_create&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    latch_.wait();</span><br><span class="line">    assert(tid_ &gt; 0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再start函数初始化data，调用detail::ThreadData构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ThreadData(ThreadFunc func,</span><br><span class="line">             const string&amp; name,</span><br><span class="line">             pid_t* tid,</span><br><span class="line">             CountDownLatch* latch)</span><br><span class="line">    : func_(std::move(func)),</span><br><span class="line">      name_(name),</span><br><span class="line">      tid_(tid),</span><br><span class="line">      latch_(latch)</span><br><span class="line">  &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>将上面的适配函数threadFunc2传入<code>func_(std::move(func))</code>，然后<code>pthread_create(&amp;pthreadId_, NULL, &amp;detail::startThread, data)</code>，创建一个线程进入detail::startThread，并将data传入，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void* startThread(void* obj)</span><br><span class="line">&#123;</span><br><span class="line">  ThreadData* data = static_cast&lt;ThreadData*&gt;(obj);</span><br><span class="line">  data-&gt;runInThread();</span><br><span class="line">  delete data;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再调用runInThread，接着就是<code>func_();</code></p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>异常处理是编程中的重要概念，可以帮助我们更好地处理错误和异常情况，避免程序崩溃或数据不一致。在 C++ 中，异常处理通过 <code>try-catch</code> 块来实现。</p>
<p><code>try-catch</code> 块的处理规则如下：</p>
<ol>
<li><code>try</code> 块：在 <code>try</code> 后面的代码块中编写可能会抛出异常的代码。当程序执行到 <code>try</code> 块时，会尝试执行其中的代码。</li>
<li><code>catch</code> 块：如果在 <code>try</code> 块中的代码执行过程中抛出了异常，程序会跳过 <code>try</code> 块中剩余的代码，并进入与异常类型匹配的 <code>catch</code> 块（如果有的话）。<ul>
<li><code>catch</code> 后面跟着异常类型的参数，如 <code>catch (const std::exception&amp; ex)</code>，这表示该 <code>catch</code> 块用于捕获该类型的异常。可以根据需要捕获多种异常类型，每种类型用一个 <code>catch</code> 块来处理。</li>
</ul>
</li>
<li>匹配异常类型：当程序抛出异常时，它会在 <code>try</code> 块外部搜索与异常类型匹配的 <code>catch</code> 块。它会按照代码中 <code>catch</code> 块的顺序进行匹配，找到第一个匹配的 <code>catch</code> 块来处理异常。匹配规则是：异常类型必须与 <code>catch</code> 块中指定的类型相同，或者是该类型的派生类。</li>
<li>处理异常：一旦找到匹配的 <code>catch</code> 块，程序会执行该 <code>catch</code> 块中的代码，处理异常。在 <code>catch</code> 块中，通常会输出异常信息、记录日志、进行清理操作或者再次抛出异常。</li>
<li>多个 <code>catch</code> 块：可以在一个 <code>try</code> 块中使用多个 <code>catch</code> 块来处理不同类型的异常。它们按照出现的顺序依次匹配，找到匹配的 <code>catch</code> 块后，其它的 <code>catch</code> 块不会被执行。</li>
<li>嵌套 <code>try-catch</code>：可以在一个 <code>catch</code> 块中嵌套另一个 <code>try-catch</code> 块来处理更复杂的异常情况。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">try</span><br><span class="line">    &#123;</span><br><span class="line">      func_();</span><br><span class="line">      muduo::CurrentThread::t_threadName = &quot;finished&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (const Exception&amp; ex)</span><br><span class="line">    &#123;</span><br><span class="line">      muduo::CurrentThread::t_threadName = &quot;crashed&quot;;</span><br><span class="line">      fprintf(stderr, &quot;exception caught in Thread %s\n&quot;, name_.c_str());</span><br><span class="line">      fprintf(stderr, &quot;reason: %s\n&quot;, ex.what());</span><br><span class="line">      fprintf(stderr, &quot;stack trace: %s\n&quot;, ex.stackTrace());</span><br><span class="line">      abort();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (const std::exception&amp; ex)</span><br><span class="line">    &#123;</span><br><span class="line">      muduo::CurrentThread::t_threadName = &quot;crashed&quot;;</span><br><span class="line">      fprintf(stderr, &quot;exception caught in Thread %s\n&quot;, name_.c_str());</span><br><span class="line">      fprintf(stderr, &quot;reason: %s\n&quot;, ex.what());</span><br><span class="line">      abort();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (...)</span><br><span class="line">    &#123;</span><br><span class="line">      muduo::CurrentThread::t_threadName = &quot;crashed&quot;;</span><br><span class="line">      fprintf(stderr, &quot;unknown exception caught in Thread %s\n&quot;, name_.c_str());</span><br><span class="line">      throw; // rethrow</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是一个线程函数的异常处理代码块。它捕获可能抛出的异常并做出相应的处理。让我们逐个解释代码的含义：</p>
<ol>
<li><code>try</code>: 这是异常处理的起始点，表示接下来的代码可能会抛出异常。</li>
<li><code>func_()</code>: 这是一个函数调用，其中 <code>func_()</code> 可能会抛出异常。</li>
<li><code>catch (const Exception&amp; ex)</code>: 这是针对自定义的 <code>Exception</code> 类型的异常的捕获块。如果 <code>func_()</code> 抛出了 <code>Exception</code> 类型的异常，它会被这个 <code>catch</code> 块捕获。</li>
<li><code>catch (const std::exception&amp; ex)</code>: 这是针对标准库 <code>std::exception</code> 类型的异常的捕获块。如果 <code>func_()</code> 抛出了标准库的异常，它会被这个 <code>catch</code> 块捕获。</li>
<li><code>catch (...)</code>: 这是一个通配符的异常捕获块，可以捕获任何未被前面的 <code>catch</code> 块捕获的异常。通常用于处理未知类型的异常，或者为了在捕获后再次抛出异常。</li>
</ol>
<p>在处理不同类型的异常时，它们执行了类似的操作：</p>
<ul>
<li>设置当前线程的名称为 “crashed”，表示线程发生了异常。</li>
<li>输出异常信息到标准错误流 (stderr) ，包括线程名称、异常原因和堆栈跟踪。</li>
<li>如果是自定义的 <code>Exception</code> 或标准库的 <code>std::exception</code> 异常，则调用 <code>abort()</code> 终止程序执行。</li>
<li>对于其他未知类型的异常，它会重新抛出异常，使得异常继续传播到更高级别的异常处理代码。</li>
</ul>
<p>总结：就是测试文件传入一个适配函数，给Thread类，然后再start函数初始化data，调用detail::ThreadData构造函数，设置data的func_函数，再创建线程，传入子线程回调函数，进入startThread，调用data-&gt;runInThread();后面就是正常使用适配函数，打印例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void threadFunc2(int x)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;tid=%d, x=%d\n&quot;, muduo::CurrentThread::tid(), x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是<strong>基于对象编程</strong>思想编写的多线程封装</p>
<h1 id="互斥量Mutex"><a href="#互斥量Mutex" class="headerlink" title="互斥量Mutex"></a>互斥量Mutex</h1><h2 id="Mutex-h"><a href="#Mutex-h" class="headerlink" title="Mutex.h"></a>Mutex.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">class CAPABILITY(&quot;mutex&quot;) MutexLock : noncopyable//CAPABILITY(x): 表示被注释的对象x具有特定的能力，允许在特定线程上下文中使用</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  MutexLock()</span><br><span class="line">    : holder_(0)</span><br><span class="line">  &#123;</span><br><span class="line">    MCHECK(pthread_mutex_init(&amp;mutex_, NULL));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~MutexLock()</span><br><span class="line">  &#123;</span><br><span class="line">    assert(holder_ == 0);</span><br><span class="line">    MCHECK(pthread_mutex_destroy(&amp;mutex_));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // must be called when locked, i.e. for assertion</span><br><span class="line">  bool isLockedByThisThread() const</span><br><span class="line">  &#123;</span><br><span class="line">    return holder_ == CurrentThread::tid();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void assertLocked() const ASSERT_CAPABILITY(this)</span><br><span class="line">  &#123;</span><br><span class="line">    assert(isLockedByThisThread());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // internal usage</span><br><span class="line"></span><br><span class="line">  void lock() ACQUIRE()</span><br><span class="line">  &#123;</span><br><span class="line">    MCHECK(pthread_mutex_lock(&amp;mutex_));</span><br><span class="line">    assignHolder();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void unlock() RELEASE()</span><br><span class="line">  &#123;</span><br><span class="line">    unassignHolder();</span><br><span class="line">    MCHECK(pthread_mutex_unlock(&amp;mutex_));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pthread_mutex_t* getPthreadMutex() /* non-const */</span><br><span class="line">  &#123;</span><br><span class="line">    return &amp;mutex_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  friend class Condition;</span><br><span class="line"></span><br><span class="line">  class UnassignGuard : noncopyable</span><br><span class="line">  &#123;</span><br><span class="line">   public:</span><br><span class="line">    explicit UnassignGuard(MutexLock&amp; owner)</span><br><span class="line">      : owner_(owner)</span><br><span class="line">    &#123;</span><br><span class="line">      owner_.unassignHolder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~UnassignGuard()</span><br><span class="line">    &#123;</span><br><span class="line">      owner_.assignHolder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   private:</span><br><span class="line">    MutexLock&amp; owner_;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  void unassignHolder()</span><br><span class="line">  &#123;</span><br><span class="line">    holder_ = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void assignHolder()</span><br><span class="line">  &#123;</span><br><span class="line">    holder_ = CurrentThread::tid();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pthread_mutex_t mutex_;</span><br><span class="line">  pid_t holder_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Use as a stack variable, eg.</span><br><span class="line">// int Foo::size() const</span><br><span class="line">// &#123;</span><br><span class="line">//   MutexLockGuard lock(mutex_);</span><br><span class="line">//   return data_.size();</span><br><span class="line">// &#125;</span><br><span class="line">//SCOPED_CAPABILITY 注解有助于文档化并强制执行 MutexLockGuard 类的预期用法，清楚地表明它表示一个作用域内可加锁的能力，并且应该根据此用法在多线程代码中使用，以管理互斥锁</span><br><span class="line">class SCOPED_CAPABILITY MutexLockGuard : noncopyable//使用RAII技法封装，即资源获取和利用</span><br><span class="line">&#123;                                              //往往更加常用，移位1如果只加锁了，在生命周期结束后会自动调用析构函数解锁</span><br><span class="line"> public:</span><br><span class="line">  explicit MutexLockGuard(MutexLock&amp; mutex) ACQUIRE(mutex)// ACQUIRE指定被注释的函数获取指定的能力（锁）</span><br><span class="line">    : mutex_(mutex)</span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.lock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~MutexLockGuard() RELEASE()</span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.unlock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line"></span><br><span class="line">  MutexLock&amp; mutex_;//与MutexLockGuard只是关联关系</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">// Prevent misuse like:</span><br><span class="line">// MutexLockGuard(mutex_);</span><br><span class="line">// A tempory object doesn&#x27;t hold the lock for long!</span><br><span class="line">#define MutexLockGuard(x) error &quot;Missing guard object name&quot;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，有两个类：<code>MutexLock</code> 和 <code>MutexLockGuard</code>，以及一个宏定义。这些类用于实现互斥锁的功能，并通过 RAII 技术来确保在使用锁的过程中正确地获取和释放锁。</p>
<ol>
<li><code>MutexLock</code> 类：该类用于封装一个互斥锁，提供了锁的获取、释放和一些辅助方法。这个类具有被注释的特定能力 “mutex”，允许在特定线程上下文中使用。</li>
<li><code>MutexLockGuard</code> 类：这是一个 RAII 封装类，用于自动管理互斥锁的获取和释放。在构造函数中，它获取给定 <code>MutexLock</code> 对象的锁，并在析构函数中释放锁。通过这种方式，可以确保在生命周期结束时自动释放锁，避免了手动管理锁的问题。</li>
<li>宏定义：<code>MutexLockGuard(x) error &quot;Missing guard object name&quot;</code> 这个宏定义的作用是防止误用。当用户尝试创建一个没有给定名称的 <code>MutexLockGuard</code> 对象时，编译器会报错并显示 “Missing guard object name” 的错误消息，提醒用户在创建 <code>MutexLockGuard</code> 对象时必须为其指定一个名称。</li>
</ol>
<p>这样，通过 <code>MutexLock</code> 和 <code>MutexLockGuard</code> 类的组合使用，可以在代码中方便地实现互斥锁功能，并避免常见的锁使用错误。</p>
<h2 id="Mutex-test-cc"><a href="#Mutex-test-cc" class="headerlink" title="Mutex_test.cc"></a>Mutex_test.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/CountDownLatch.h&quot;</span><br><span class="line">#include &quot;muduo/base/Mutex.h&quot;</span><br><span class="line">#include &quot;muduo/base/Thread.h&quot;</span><br><span class="line">#include &quot;muduo/base/Timestamp.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">MutexLock g_mutex;</span><br><span class="line">vector&lt;int&gt; g_vec;</span><br><span class="line">const int kCount = 10*1000*1000;</span><br><span class="line"></span><br><span class="line">void threadFunc()</span><br><span class="line">&#123;</span><br><span class="line">  for (int i = 0; i &lt; kCount; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">  //此操作确保在循环体中对 g_vec 进行添加操作时，只有一个线程能够持有互斥锁，从而避免多个线程同时修改 g_vec 导致的数据竞争</span><br><span class="line">    MutexLockGuard lock(g_mutex);</span><br><span class="line">    g_vec.push_back(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int foo() __attribute__ ((noinline));//__attribute__((noinline)) 是 GCC 编译器提供的一个函数属性（function attribute），用于告诉编译器不要对特定函数进行内联优化。</span><br><span class="line"></span><br><span class="line">int g_count = 0;</span><br><span class="line">int foo()</span><br><span class="line">&#123;</span><br><span class="line">  MutexLockGuard lock(g_mutex);</span><br><span class="line">  if (!g_mutex.isLockedByThisThread())</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;FAIL\n&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ++g_count;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;sizeof pthread_mutex_t: %zd\n&quot;, sizeof(pthread_mutex_t));</span><br><span class="line">  printf(&quot;sizeof Mutex: %zd\n&quot;, sizeof(MutexLock));</span><br><span class="line">  printf(&quot;sizeof pthread_cond_t: %zd\n&quot;, sizeof(pthread_cond_t));</span><br><span class="line">  printf(&quot;sizeof Condition: %zd\n&quot;, sizeof(Condition));</span><br><span class="line">  MCHECK(foo());//MCHECK(foo()) 用于确保 foo() 函数执行正常，即成功获取锁并进行递增操作</span><br><span class="line">  if (g_count != 1)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;MCHECK calls twice.\n&quot;);</span><br><span class="line">    abort();//用于终止当前运行的程序</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const int kMaxThreads = 8;</span><br><span class="line">  g_vec.reserve(kMaxThreads * kCount);</span><br><span class="line"></span><br><span class="line">  Timestamp start(Timestamp::now());</span><br><span class="line">  for (int i = 0; i &lt; kCount; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    g_vec.push_back(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printf(&quot;single thread without lock %f\n&quot;, timeDifference(Timestamp::now(), start));</span><br><span class="line"></span><br><span class="line">  start = Timestamp::now();</span><br><span class="line">  threadFunc();</span><br><span class="line">  printf(&quot;single thread with lock %f\n&quot;, timeDifference(Timestamp::now(), start));</span><br><span class="line"></span><br><span class="line">  for (int nthreads = 1; nthreads &lt; kMaxThreads; ++nthreads)</span><br><span class="line">  &#123;</span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;Thread&gt;&gt; threads;//std::unique_ptr 是一个智能指针，用于管理动态分配的对象，并在其生命周期结束时自动释放内存</span><br><span class="line">    g_vec.clear();</span><br><span class="line">    start = Timestamp::now();</span><br><span class="line">    for (int i = 0; i &lt; nthreads; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      threads.emplace_back(new Thread(&amp;threadFunc));</span><br><span class="line">      //使用 emplace_back() 函数在 threads 容器的末尾插入一个新的 std::unique_ptr 对象，它包含了一个指向 Thread 对象的指针。new Thread(&amp;threadFunc) 动态分配一个新的 Thread 对象，并将其作为参数传递给 std::unique_ptr 的构造函数，从而把 Thread 对象交给智能指针管理</span><br><span class="line">      threads.back()-&gt;start();</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; nthreads; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      threads[i]-&gt;join();</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d thread(s) with lock %f\n&quot;, nthreads, timeDifference(Timestamp::now(), start));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%882%EF%BC%89/image-20230802150753684.png" alt="image-20230802150753684"></p>
<img src="/2023/08/01/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%882%EF%BC%89/image-20230802150753684.png" class title="This is an test image">

<p>这个测试的是在没锁和有锁的情况下向容器添加整数的时间差,后面就是创建不同个数线程然后跟前面一样传入一个函数，在每一个最后新加的Thread对象调用startt函数初始化data，调用detail::ThreadData构造函数，设置data的func_函数，再创建线程，传入子线程回调函数，进入startThread，调用data-&gt;runInThread();后面就是正常使用适配函数，跟前面一样。实际上就是创建不同个数线程在lock下的时间差</p>
<h2 id="条件变量Condition"><a href="#条件变量Condition" class="headerlink" title="条件变量Condition"></a>条件变量Condition</h2><h3 id="condition-h"><a href="#condition-h" class="headerlink" title="condition.h"></a>condition.h</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Condition : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  explicit Condition(MutexLock&amp; mutex)</span><br><span class="line">    : mutex_(mutex)</span><br><span class="line">  &#123;</span><br><span class="line">    MCHECK(pthread_cond_init(&amp;pcond_, NULL));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~Condition()</span><br><span class="line">  &#123;</span><br><span class="line">    MCHECK(pthread_cond_destroy(&amp;pcond_));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void wait()</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLock::UnassignGuard ug(mutex_);</span><br><span class="line">    MCHECK(pthread_cond_wait(&amp;pcond_, mutex_.getPthreadMutex()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // returns true if time out, false otherwise.</span><br><span class="line">  bool waitForSeconds(double seconds);</span><br><span class="line"></span><br><span class="line">  void notify()</span><br><span class="line">  &#123;</span><br><span class="line">    MCHECK(pthread_cond_signal(&amp;pcond_));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void notifyAll()</span><br><span class="line">  &#123;</span><br><span class="line">    MCHECK(pthread_cond_broadcast(&amp;pcond_));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  MutexLock&amp; mutex_;</span><br><span class="line">  pthread_cond_t pcond_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Condition-cc"><a href="#Condition-cc" class="headerlink" title="Condition.cc"></a>Condition.cc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// returns true if time out, false otherwise.</span><br><span class="line">//这个函数允许线程在指定的时间间隔内等待条件变量被唤醒。如果等待时间到期仍未被唤醒，则函数返回等待超时</span><br><span class="line">bool muduo::Condition::waitForSeconds(double seconds)</span><br><span class="line">&#123;</span><br><span class="line">  struct timespec abstime;</span><br><span class="line">  // FIXME: use CLOCK_MONOTONIC or CLOCK_MONOTONIC_RAW to prevent time rewind.</span><br><span class="line">  clock_gettime(CLOCK_REALTIME, &amp;abstime);</span><br><span class="line"></span><br><span class="line">  const int64_t kNanoSecondsPerSecond = 1000000000;</span><br><span class="line">  int64_t nanoseconds = static_cast&lt;int64_t&gt;(seconds * kNanoSecondsPerSecond);</span><br><span class="line"></span><br><span class="line">  abstime.tv_sec += static_cast&lt;time_t&gt;((abstime.tv_nsec + nanoseconds) / kNanoSecondsPerSecond);</span><br><span class="line">  abstime.tv_nsec = static_cast&lt;long&gt;((abstime.tv_nsec + nanoseconds) % kNanoSecondsPerSecond);</span><br><span class="line"></span><br><span class="line">  MutexLock::UnassignGuard ug(mutex_);</span><br><span class="line">  return ETIMEDOUT == pthread_cond_timedwait(&amp;pcond_, mutex_.getPthreadMutex(), &amp;abstime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>friend class Condition;</code> 声明了 <code>Condition</code> 类为 <code>MutexLock</code> 的友元类，使得 <code>Condition</code> 类的成员函数可以访问 <code>MutexLock</code> 类的私有成员。在 <code>MutexLock</code> 类的嵌套类 <code>UnassignGuard</code> 中，通过友元关系可以访问 <code>MutexLock</code> 类的私有成员函数，并在构造和析构过程中使用这些私有函数来实现解锁和重新上锁的操作</p>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>既可以用于所有子线程等待主线程发起“起跑’,用条件变量来通知<br>也可以用于主线程等待子线程初始化完毕才开始工作</p>
<p>配合condition使用，有多少个count_</p>
<h3 id="CountDownLatch-h"><a href="#CountDownLatch-h" class="headerlink" title="CountDownLatch.h"></a>CountDownLatch.h</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/Condition.h&quot;</span><br><span class="line">#include &quot;muduo/base/Mutex.h&quot;</span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">class CountDownLatch : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line"></span><br><span class="line">  explicit CountDownLatch(int count);</span><br><span class="line"></span><br><span class="line">  void wait();</span><br><span class="line"></span><br><span class="line">  void countDown();</span><br><span class="line"></span><br><span class="line">  int getCount() const;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  mutable MutexLock mutex_;//mutable表示可以改变的，在int getCount() const函数可以改变，即加锁</span><br><span class="line">  Condition condition_ GUARDED_BY(mutex_);</span><br><span class="line">  //通过添加 GUARDED_BY(mutex_) 注释，代码的作者表明只有当持有 mutex_ 锁时，才能安全地访问 condition_ 和 count_。这样可以帮助其他程序员理解在多线程环境中对这些成员变量进行操作时的线程安全性</span><br><span class="line">  int count_ GUARDED_BY(mutex_);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br></pre></td></tr></table></figure>

<h3 id="CountDownLatch-cc"><a href="#CountDownLatch-cc" class="headerlink" title="CountDownLatch.cc"></a>CountDownLatch.cc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">using namespace muduo;</span><br><span class="line"></span><br><span class="line">CountDownLatch::CountDownLatch(int count)</span><br><span class="line">  : mutex_(),</span><br><span class="line">    condition_(mutex_),</span><br><span class="line">    count_(count)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CountDownLatch::wait()</span><br><span class="line">&#123;</span><br><span class="line">  MutexLockGuard lock(mutex_);</span><br><span class="line">  while (count_ &gt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    condition_.wait();//阻塞等待条件变量，pthread_cond_wait(&amp;pcond_, mutex_.getPthreadMutex())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CountDownLatch::countDown()//解锁</span><br><span class="line">&#123;</span><br><span class="line">  MutexLockGuard lock(mutex_);</span><br><span class="line">  --count_;</span><br><span class="line">  if (count_ == 0)</span><br><span class="line">  &#123;</span><br><span class="line">    condition_.notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int CountDownLatch::getCount() const//获取当前count</span><br><span class="line">&#123;</span><br><span class="line">  MutexLockGuard lock(mutex_);</span><br><span class="line">  return count_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用于所有子线程等待主线程发起“起跑’,用条件变量来通知，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// 定义 CountDownLatch 对象</span><br><span class="line">CountDownLatch startSignal(1);</span><br><span class="line"></span><br><span class="line">// 子线程的任务函数</span><br><span class="line">void workerThread(int id)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Worker Thread &quot; &lt;&lt; id &lt;&lt; &quot; is waiting for the start signal.&quot; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    // 子线程等待主线程发起“起跑”信号</span><br><span class="line">    startSignal.wait();</span><br><span class="line"></span><br><span class="line">    // 执行子线程的工作任务</span><br><span class="line">    std::cout &lt;&lt; &quot;Worker Thread &quot; &lt;&lt; id &lt;&lt; &quot; starts working.&quot; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;Worker Thread &quot; &lt;&lt; id &lt;&lt; &quot; has finished its work.&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int numThreads = 5;</span><br><span class="line">    muduo::Thread threads[numThreads];</span><br><span class="line"></span><br><span class="line">    // 创建并启动子线程</span><br><span class="line">    for (int i = 0; i &lt; numThreads; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        threads[i] = muduo::Thread(workerThread, i + 1);</span><br><span class="line">        threads[i]-&gt;start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 主线程休眠一段时间，模拟一些准备工作</span><br><span class="line">    std::this_thread::sleep_for(std::chrono::seconds(2));</span><br><span class="line"></span><br><span class="line">    // 发起“起跑”信号</span><br><span class="line">    std::cout &lt;&lt; &quot;Starting all worker threads...&quot; &lt;&lt; std::endl;</span><br><span class="line">    startSignal.countDown(); // 解除阻塞，所有子线程同时开始工作</span><br><span class="line"></span><br><span class="line">    // 等待所有子线程执行完毕</span><br><span class="line">    for (int i = 0; i &lt; numThreads; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        threads[i].join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;All worker threads have finished their work. Main thread exits.&quot; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="BlockinngQueue-lt-T-gt-（无界缓冲区"><a href="#BlockinngQueue-lt-T-gt-（无界缓冲区" class="headerlink" title="BlockinngQueue&lt;T&gt;（无界缓冲区)"></a>BlockinngQueue<code>&lt;T&gt;</code>（无界缓冲区)</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_BASE_BLOCKINGQUEUE_H</span><br><span class="line">#define MUDUO_BASE_BLOCKINGQUEUE_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Condition.h&quot;</span><br><span class="line">#include &quot;muduo/base/Mutex.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class BlockingQueue : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  using queue_type = std::deque&lt;T&gt;;//表明队列使用 std::deque 作为底层容器，其中 T 是类型参数</span><br><span class="line"></span><br><span class="line">  BlockingQueue()</span><br><span class="line">    : mutex_(),</span><br><span class="line">      notEmpty_(mutex_),</span><br><span class="line">      queue_()</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void put(const T&amp; x)//用于将不可移动对象（常量左值）放入队列,这意味着在将对象添加到队列时，不会对传递给函数的对象进行移动或修改</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    queue_.push_back(x);</span><br><span class="line">    notEmpty_.notify(); // wait morphing saves us</span><br><span class="line">    // http://www.domaigne.com/blog/computing/condvars-signal-with-mutex-locked-or-not/</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void put(T&amp;&amp; x)//生产,用于将可移动对象（右值）放入队列</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    queue_.push_back(std::move(x));</span><br><span class="line">    notEmpty_.notify();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T take()//消费</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    // always use a while-loop, due to spurious wakeup</span><br><span class="line">    while (queue_.empty())</span><br><span class="line">    &#123;</span><br><span class="line">      notEmpty_.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    assert(!queue_.empty());</span><br><span class="line">    T front(std::move(queue_.front()));//构造了一个类型为 T 的对象 front</span><br><span class="line">    queue_.pop_front();</span><br><span class="line">    return front;</span><br><span class="line">  &#125;</span><br><span class="line">//drain() 函数将队列中的所有元素移除，并以一个新的 std::deque 对象的形式返回。注意，此操作会清空原队列，原队列中的数据将不再存在。在多线程环境下，使用互斥锁确保操作的原子性，避免与其他线程同时访问队列而导致的竞态条件</span><br><span class="line">  queue_type drain()</span><br><span class="line">  &#123;</span><br><span class="line">    std::deque&lt;T&gt; queue;</span><br><span class="line">    &#123;</span><br><span class="line">      MutexLockGuard lock(mutex_);</span><br><span class="line">      queue = std::move(queue_);</span><br><span class="line">      assert(queue_.empty());//确保在操作完成后，原队列确实为空</span><br><span class="line">    &#125;</span><br><span class="line">    return queue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  size_t size() const</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    return queue_.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  mutable MutexLock mutex_;</span><br><span class="line">  Condition         notEmpty_ GUARDED_BY(mutex_);</span><br><span class="line">  queue_type        queue_ GUARDED_BY(mutex_);</span><br><span class="line">&#125;;  // __attribute__ ((aligned (64)));</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br></pre></td></tr></table></figure>

<h2 id="BlockingQueue-test-cc"><a href="#BlockingQueue-test-cc" class="headerlink" title="BlockingQueue_test.cc"></a>BlockingQueue_test.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/BlockingQueue.h&quot;</span><br><span class="line">#include &quot;muduo/base/CountDownLatch.h&quot;</span><br><span class="line">#include &quot;muduo/base/Thread.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  Test(int numThreads)</span><br><span class="line">    : latch_(numThreads)//构造函数实现将消费者函数传递，跟前面的基于对象编程思想一样</span><br><span class="line">  &#123;</span><br><span class="line">    for (int i = 0; i &lt; numThreads; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      char name[32];</span><br><span class="line">      snprintf(name, sizeof name, &quot;work thread %d&quot;, i);</span><br><span class="line">      ////emplace_back 通常比 push_back 更高效。由于 emplace_back 直接在容器中构造元素，避免了额外的拷贝或移动操作，因此它在某些情况下可以更快</span><br><span class="line">      threads_.emplace_back(new muduo::Thread(</span><br><span class="line">            std::bind(&amp;Test::threadFunc, this), muduo::string(name)));</span><br><span class="line">    &#125;</span><br><span class="line">    for (auto&amp; thr : threads_)//遍历每个线程</span><br><span class="line">    &#123;</span><br><span class="line">      thr-&gt;start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void run(int times)//生产者函数</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;waiting for count down latch\n&quot;);</span><br><span class="line">    latch_.wait();//condition_.wait();阻塞等待唤醒</span><br><span class="line">    printf(&quot;all threads started\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; times; ++i)//生产100个</span><br><span class="line">    &#123;</span><br><span class="line">      char buf[32];</span><br><span class="line">      snprintf(buf, sizeof buf, &quot;hello %d&quot;, i);</span><br><span class="line">      queue_.put(buf);</span><br><span class="line">      printf(&quot;tid=%d, put data = %s, size = %zd\n&quot;, muduo::CurrentThread::tid(), buf, queue_.size());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void joinAll()</span><br><span class="line">  &#123;</span><br><span class="line">    for (size_t i = 0; i &lt; threads_.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      queue_.put(&quot;stop&quot;);//running = (d != &quot;stop&quot;);使其退出</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (auto&amp; thr : threads_)</span><br><span class="line">    &#123;</span><br><span class="line">      thr-&gt;join();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line"></span><br><span class="line">  void threadFunc()//消费者函数</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;tid=%d, %s started\n&quot;,</span><br><span class="line">           muduo::CurrentThread::tid(),</span><br><span class="line">           muduo::CurrentThread::name());</span><br><span class="line"></span><br><span class="line">    latch_.countDown();//--count_;</span><br><span class="line">    bool running = true;</span><br><span class="line">    while (running)</span><br><span class="line">    &#123;</span><br><span class="line">      std::string d(queue_.take());//消费，并将front返回添加到d</span><br><span class="line">      printf(&quot;tid=%d, get data = %s, size = %zd\n&quot;, muduo::CurrentThread::tid(), d.c_str(), queue_.size());</span><br><span class="line">      running = (d != &quot;stop&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;tid=%d, %s stopped\n&quot;,</span><br><span class="line">           muduo::CurrentThread::tid(),</span><br><span class="line">           muduo::CurrentThread::name());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  muduo::BlockingQueue&lt;std::string&gt; queue_;</span><br><span class="line">  muduo::CountDownLatch latch_;</span><br><span class="line">  std::vector&lt;std::unique_ptr&lt;muduo::Thread&gt;&gt; threads_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void testMove()</span><br><span class="line">&#123;</span><br><span class="line">  muduo::BlockingQueue&lt;std::unique_ptr&lt;int&gt;&gt; queue;</span><br><span class="line">  queue.put(std::unique_ptr&lt;int&gt;(new int(42)));</span><br><span class="line">  std::unique_ptr&lt;int&gt; x = queue.take();</span><br><span class="line">  printf(&quot;took %d\n&quot;, *x);</span><br><span class="line">  *x = 123;</span><br><span class="line">  queue.put(std::move(x));</span><br><span class="line">  std::unique_ptr&lt;int&gt; y = queue.take();</span><br><span class="line">  printf(&quot;took %d\n&quot;, *y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;pid=%d, tid=%d\n&quot;, ::getpid(), muduo::CurrentThread::tid());</span><br><span class="line">  Test t(5);//muduo::CountDownLatch latch_;实现5个子线程</span><br><span class="line">  t.run(100);</span><br><span class="line">  t.joinAll();</span><br><span class="line"></span><br><span class="line">  testMove();</span><br><span class="line"></span><br><span class="line">  printf(&quot;number of created threads %d\n&quot;, muduo::Thread::numCreated());</span><br><span class="line">  //muduo::Thread::numCreated(),就是访问static int numCreated() &#123; return numCreated_.get(); &#125;</span><br><span class="line">  //numCreated_ 是一个 AtomicInt32 类型的静态成员变量，这意味着它是一个类变量，属于整个 Thread 类而不是实例化对象。因此，每次创建新的 Thread 实例时，都会共享并更新 numCreated_，从而记录创建的线程数量</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>实现无边界的消费者生产者问题</strong></p>
<h1 id="BoundedBlockingQueue-lt-T-gt-有界缓冲区"><a href="#BoundedBlockingQueue-lt-T-gt-有界缓冲区" class="headerlink" title="BoundedBlockingQueue&lt;T&gt;(有界缓冲区)"></a>BoundedBlockingQueue<code>&lt;T&gt;</code>(有界缓冲区)</h1><h2 id="BoundedBlockingQueue-h"><a href="#BoundedBlockingQueue-h" class="headerlink" title="BoundedBlockingQueue.h"></a>BoundedBlockingQueue.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_BASE_BOUNDEDBLOCKINGQUEUE_H</span><br><span class="line">#define MUDUO_BASE_BOUNDEDBLOCKINGQUEUE_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Condition.h&quot;</span><br><span class="line">#include &quot;muduo/base/Mutex.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;boost/circular_buffer.hpp&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class BoundedBlockingQueue : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  explicit BoundedBlockingQueue(int maxSize)</span><br><span class="line">    : mutex_(),</span><br><span class="line">      notEmpty_(mutex_),</span><br><span class="line">      notFull_(mutex_),</span><br><span class="line">      queue_(maxSize)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void put(const T&amp; x)</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    while (queue_.full())</span><br><span class="line">    &#123;</span><br><span class="line">      notFull_.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    assert(!queue_.full());</span><br><span class="line">    queue_.push_back(x);</span><br><span class="line">    notEmpty_.notify();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void put(T&amp;&amp; x)</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    while (queue_.full())</span><br><span class="line">    &#123;</span><br><span class="line">      notFull_.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    assert(!queue_.full());</span><br><span class="line">    queue_.push_back(std::move(x));</span><br><span class="line">    notEmpty_.notify();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T take()</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    while (queue_.empty())</span><br><span class="line">    &#123;</span><br><span class="line">      notEmpty_.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    assert(!queue_.empty());</span><br><span class="line">    T front(std::move(queue_.front()));</span><br><span class="line">    queue_.pop_front();</span><br><span class="line">    notFull_.notify();</span><br><span class="line">    return front;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bool empty() const</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    return queue_.empty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bool full() const</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    return queue_.full();//用于判断循环缓冲区是否已满</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  size_t size() const</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    return queue_.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  size_t capacity() const</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    return queue_.capacity();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  mutable MutexLock          mutex_;</span><br><span class="line">  Condition                  notEmpty_ GUARDED_BY(mutex_);</span><br><span class="line">  Condition                  notFull_ GUARDED_BY(mutex_);</span><br><span class="line">  boost::circular_buffer&lt;T&gt;  queue_ GUARDED_BY(mutex_);//环形缓冲区</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_BASE_BOUNDEDBLOCKINGQUEUE_H</span><br></pre></td></tr></table></figure>

<p>跟上面相比就是需要判断是否满，并且这里实现的是环形缓冲区</p>
<h2 id="BoundedBlockingQueue-test-cc"><a href="#BoundedBlockingQueue-test-cc" class="headerlink" title="BoundedBlockingQueue_test.cc"></a>BoundedBlockingQueue_test.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/BoundedBlockingQueue.h&quot;</span><br><span class="line">#include &quot;muduo/base/CountDownLatch.h&quot;</span><br><span class="line">#include &quot;muduo/base/Thread.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  Test(int numThreads)</span><br><span class="line">    : queue_(20),</span><br><span class="line">      latch_(numThreads)</span><br><span class="line">  &#123;</span><br><span class="line">    threads_.reserve(numThreads);</span><br><span class="line">    for (int i = 0; i &lt; numThreads; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      char name[32];</span><br><span class="line">      snprintf(name, sizeof name, &quot;work thread %d&quot;, i);</span><br><span class="line">      threads_.emplace_back(new muduo::Thread(</span><br><span class="line">            std::bind(&amp;Test::threadFunc, this), muduo::string(name)));</span><br><span class="line">    &#125;</span><br><span class="line">    for (auto&amp; thr : threads_)</span><br><span class="line">    &#123;</span><br><span class="line">      thr-&gt;start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void run(int times)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;waiting for count down latch\n&quot;);</span><br><span class="line">    latch_.wait();</span><br><span class="line">    printf(&quot;all threads started\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; times; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      char buf[32];</span><br><span class="line">      snprintf(buf, sizeof buf, &quot;hello %d&quot;, i);</span><br><span class="line">      queue_.put(buf);</span><br><span class="line">      printf(&quot;tid=%d, put data = %s, size = %zd\n&quot;, muduo::CurrentThread::tid(), buf, queue_.size());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void joinAll()</span><br><span class="line">  &#123;</span><br><span class="line">    for (size_t i = 0; i &lt; threads_.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      queue_.put(&quot;stop&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (auto&amp; thr : threads_)</span><br><span class="line">    &#123;</span><br><span class="line">      thr-&gt;join();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line"></span><br><span class="line">  void threadFunc()</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;tid=%d, %s started\n&quot;,</span><br><span class="line">           muduo::CurrentThread::tid(),</span><br><span class="line">           muduo::CurrentThread::name());</span><br><span class="line"></span><br><span class="line">    latch_.countDown();</span><br><span class="line">    bool running = true;</span><br><span class="line">    while (running)</span><br><span class="line">    &#123;</span><br><span class="line">      std::string d(queue_.take());</span><br><span class="line">      printf(&quot;tid=%d, get data = %s, size = %zd\n&quot;, muduo::CurrentThread::tid(), d.c_str(), queue_.size());</span><br><span class="line">      running = (d != &quot;stop&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;tid=%d, %s stopped\n&quot;,</span><br><span class="line">           muduo::CurrentThread::tid(),</span><br><span class="line">           muduo::CurrentThread::name());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  muduo::BoundedBlockingQueue&lt;std::string&gt; queue_;</span><br><span class="line">  muduo::CountDownLatch latch_;</span><br><span class="line">  std::vector&lt;std::unique_ptr&lt;muduo::Thread&gt;&gt; threads_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void testMove()</span><br><span class="line">&#123;</span><br><span class="line">#if BOOST_VERSION &gt;= 105500L// Boost 库中的预定义宏，表示当前使用的 Boost 版本号。如果满足条件，则执行下面的代码块</span><br><span class="line">  muduo::BoundedBlockingQueue&lt;std::unique_ptr&lt;int&gt;&gt; queue(10);</span><br><span class="line">  queue.put(std::unique_ptr&lt;int&gt;(new int(42)));</span><br><span class="line">  std::unique_ptr&lt;int&gt; x = queue.take();</span><br><span class="line">  printf(&quot;took %d\n&quot;, *x);</span><br><span class="line">  *x = 123;</span><br><span class="line">  queue.put(std::move(x));</span><br><span class="line">  std::unique_ptr&lt;int&gt; y;</span><br><span class="line">  y = queue.take();</span><br><span class="line">  printf(&quot;took %d\n&quot;, *y);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;pid=%d, tid=%d\n&quot;, ::getpid(), muduo::CurrentThread::tid());</span><br><span class="line">  testMove();</span><br><span class="line">  Test t(5);</span><br><span class="line">  t.run(100);</span><br><span class="line">  t.joinAll();</span><br><span class="line"></span><br><span class="line">  printf(&quot;number of created threads %d\n&quot;, muduo::Thread::numCreated());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试代码和上面差不多，只是在源文件的put和take加入了多的判断界限。</p>
<h1 id="ThreadPool线程池封装"><a href="#ThreadPool线程池封装" class="headerlink" title="ThreadPool线程池封装"></a>ThreadPool线程池封装</h1><p>这个线程池的执行任务的过程如下：</p>
<ol>
<li><p>调用<code>ThreadPool::run()</code>函数添加一个任务到线程池中。如果线程池为空，直接执行任务。</p>
</li>
<li><p>如果线程池不为空，获取互斥锁，检查队列是否已满（达到最大容量）且线程池正在运行。</p>
<ul>
<li>如果队列已满且线程池正在运行，则等待条件变量<code>notFull_</code>，即等待队列不再满的时候再继续执行。</li>
<li>如果线程池不再运行，则直接返回，不再添加任务。</li>
</ul>
</li>
<li><p>释放互斥锁后，将任务添加到队列中，并通知条件变量<code>notEmpty_</code>，以便通知正在等待任务的线程。</p>
</li>
<li><p>在另外的线程中调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool::take()</span><br></pre></td></tr></table></figure>

<p>函数来获取任务并执行。获取任务前，先获取互斥锁。</p>
<ul>
<li>如果队列为空且线程池正在运行，则等待条件变量<code>notEmpty_</code>，即等待队列不再空的时候再继续执行。</li>
</ul>
</li>
<li><p>获取到任务后，从队列中取出并移除该任务，并检查是否需要唤醒等待在<code>notFull_</code>条件变量上的线程。</p>
</li>
<li><p>释放互斥锁后，执行任务函数。</p>
</li>
<li><p>当线程池停止时，通过调用<code>ThreadPool::stop()</code>函数设置<code>running_</code>为<code>false</code>，并通知等待在<code>notEmpty_</code>和<code>notFull_</code>条件变量上的线程。</p>
</li>
<li><p>线程池中的所有线程在执行完当前任务后退出。</p>
</li>
</ol>
<p>总结起来，线程池会不断从任务队列中获取任务并执行，同时提供了添加任务和停止线程池的功能。使用互斥锁和条件变量来实现对任务队列的线程安全操作，并通过多个工作线程实现并行执行任务的效果。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/01/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/01/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/" class="post-title-link" itemprop="url">muduo-基础库（1）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-01 12:04:15" itemprop="dateCreated datePublished" datetime="2023-08-01T12:04:15+08:00">2023-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-07 10:30:28" itemprop="dateModified" datetime="2023-08-07T10:30:28+08:00">2023-08-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p><img src="/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230730155255822.png" alt="image-20230730155255822"></p>
<img src="/2023/08/01/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230730155255822.png" class title="This is an test image">

<h2 id="基础库"><a href="#基础库" class="headerlink" title="基础库"></a>基础库</h2><p><img src="/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230730155339712.png" alt="image-20230730155339712"></p>
<img src="/2023/08/01/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230730155339712.png" class title="This is an test image">

<p><img src="/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230730155404611.png" alt="image-20230730155404611"></p>
<img src="/2023/08/01/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230730155404611.png" class title="This is an test image">

<h2 id="时间戳Timestamp类封装"><a href="#时间戳Timestamp类封装" class="headerlink" title="时间戳Timestamp类封装"></a>时间戳Timestamp类封装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;base/types.h&gt;</span><br></pre></td></tr></table></figure>

<p>less_than_comparable<br>    要求实现&lt;，可自动实现&gt;,&lt;&#x3D;,&gt;&#x3D;</p>
<p>BOOST_STATIC_ASSERT</p>
<p>使用PRId64</p>
<p>Timestamp实现及测试</p>
<p><strong>BOOST_STATIC_ASSERT</strong>编译时断言，现在是STATIC_ASSERT<br><strong>assert</strong>是运行时断言</p>
<p><code>static_assert</code> 是标准 C++ 的一部分，更为现代和推荐的用法，特别是在使用 C++11 及以上标准的项目中。而 <code>BOOST_STATIC_ASSERT</code> 则是为了兼容 C++03 标准而提供的 Boost 库中的宏，在旧的编译环境中可能会使用到。在使用时，根据项目的需求和所支持的 C++ 标准版本来选择使用哪种静态断言宏。</p>
<h3 id="使用PRld64"><a href="#使用PRld64" class="headerlink" title="使用PRld64"></a>使用PRld64</h3><p>int64_t用来表示64位整数，在32位系统中是long long int，在64位系统中是long int,所以打印int64_t的格式化方法是:<br><code>printf(&quot;%ld&quot;, value);// 64bit os</code></p>
<p><code>printf(&quot;%lld&quot;, value); // 32bit Os</code></p>
<p>跨平台的做法:<br><code>#define_STDC_FORMAT_MACROS</code>这是一个预处理指令，用于定义一个宏 <code>_STDC_FORMAT_MACROS</code>。在 <code>inttypes.h</code> 头文件中，如果检测到定义了这个宏，它将启用一系列与格式化整数类型相关的宏定义，包括 <code>PRId64</code>、<code>PRIu64</code> 等</p>
<p><code>#include &lt;inttypes.h&gt;</code>这是包含 C&#x2F;C++ 标准库中 <code>inttypes.h</code> 头文件的指令。<code>inttypes.h</code> 头文件提供了一系列用于处理整数类型的宏和格式说明符</p>
<p><code>#undef_STDC_FORMAT_MACROS</code>这是另一个预处理指令，用于取消之前定义的 <code>_STDC_FORMAT_MACROS</code> 宏。在包含完 <code>inttypes.h</code> 头文件之后，我们取消这个宏的定义，以防止它在后续代码中产生影响。</p>
<p><code>printf(&quot;%&quot;PRId64 &quot;\n&quot;, value);</code></p>
<p><img src="/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230730165438382.png" alt="image-20230730165438382"></p>
<img src="/2023/08/01/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230730165438382.png" class title="This is an test image">

<h3 id="Timestamp-h"><a href="#Timestamp-h" class="headerlink" title="Timestamp.h"></a>Timestamp.h</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#ifndef MUDUO_BASE_TIMESTAMP_H</span><br><span class="line">#define MUDUO_BASE_TIMESTAMP_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/copyable.h&quot;</span><br><span class="line">#include &quot;muduo/base/Types.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;boost/operators.hpp&gt;</span><br><span class="line"></span><br><span class="line">namespace muduo//namespace muduo 是一个命名空间（namespace），用于将一组相关的类、函数、变量等实体封装在一个逻辑上相互隔离的作用域中。这个命名空间在上述代码中包含了一个名为 Timestamp 的类以及与该类相关的一些函数和常量。</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">///</span><br><span class="line">/// Time stamp in UTC, in microseconds resolution.</span><br><span class="line">///</span><br><span class="line">/// This class is immutable.</span><br><span class="line">/// It&#x27;s recommended to pass it by value, since it&#x27;s passed in register on x64.</span><br><span class="line">///</span><br><span class="line">class Timestamp : public muduo::copyable,//是值语义，值语义是指对象的复制行为是复制其值而非引用。在 C++ 中，默认情况下，类的对象的复制行为是浅拷贝，即复制对象的成员变量的值，而不复制指向的资源</span><br><span class="line">                  public boost::equality_comparable&lt;Timestamp&gt;,</span><br><span class="line">                  public boost::less_than_comparable&lt;Timestamp&gt;</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  ///</span><br><span class="line">  /// Constucts an invalid Timestamp.</span><br><span class="line">  ///</span><br><span class="line">  Timestamp()</span><br><span class="line">    : microSecondsSinceEpoch_(0)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ///</span><br><span class="line">  /// Constucts a Timestamp at specific time</span><br><span class="line">  ///</span><br><span class="line">  /// @param microSecondsSinceEpoch</span><br><span class="line">  explicit Timestamp(int64_t microSecondsSinceEpochArg)</span><br><span class="line">    : microSecondsSinceEpoch_(microSecondsSinceEpochArg)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void swap(Timestamp&amp; that)</span><br><span class="line">  &#123;</span><br><span class="line">    std::swap(microSecondsSinceEpoch_, that.microSecondsSinceEpoch_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // default copy/assignment/dtor are Okay</span><br><span class="line"></span><br><span class="line">  string toString() const;</span><br><span class="line">  string toFormattedString(bool showMicroseconds = true) const;</span><br><span class="line"></span><br><span class="line">  bool valid() const &#123; return microSecondsSinceEpoch_ &gt; 0; &#125;</span><br><span class="line"></span><br><span class="line">  // for internal usage.</span><br><span class="line">  int64_t microSecondsSinceEpoch() const &#123; return microSecondsSinceEpoch_; &#125;</span><br><span class="line">  time_t secondsSinceEpoch() const</span><br><span class="line">  &#123; return static_cast&lt;time_t&gt;(microSecondsSinceEpoch_ / kMicroSecondsPerSecond); &#125;</span><br><span class="line"></span><br><span class="line">  ///</span><br><span class="line">  /// Get time of now.</span><br><span class="line">  ///</span><br><span class="line">  static Timestamp now();</span><br><span class="line">  static Timestamp invalid()</span><br><span class="line">  &#123;</span><br><span class="line">    return Timestamp();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static Timestamp fromUnixTime(time_t t)</span><br><span class="line">  &#123;</span><br><span class="line">    return fromUnixTime(t, 0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static Timestamp fromUnixTime(time_t t, int microseconds)</span><br><span class="line">  &#123;</span><br><span class="line">    return Timestamp(static_cast&lt;int64_t&gt;(t) * kMicroSecondsPerSecond + microseconds);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static const int kMicroSecondsPerSecond = 1000 * 1000;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  int64_t microSecondsSinceEpoch_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inline bool operator&lt;(Timestamp lhs, Timestamp rhs)//声明和定义都在.h文件</span><br><span class="line">&#123;</span><br><span class="line">  return lhs.microSecondsSinceEpoch() &lt; rhs.microSecondsSinceEpoch();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline bool operator==(Timestamp lhs, Timestamp rhs)//实现&lt;，可自动实现&gt;,&lt;=,&gt;=</span><br><span class="line">&#123;</span><br><span class="line">  return lhs.microSecondsSinceEpoch() == rhs.microSecondsSinceEpoch();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///</span><br><span class="line">/// Gets time difference of two timestamps, result in seconds.</span><br><span class="line">///</span><br><span class="line">/// @param high, low</span><br><span class="line">/// @return (high-low) in seconds</span><br><span class="line">/// @c double has 52-bit precision, enough for one-microsecond</span><br><span class="line">/// resolution for next 100 years.</span><br><span class="line">inline double timeDifference(Timestamp high, Timestamp low)</span><br><span class="line">&#123;</span><br><span class="line">  int64_t diff = high.microSecondsSinceEpoch() - low.microSecondsSinceEpoch();</span><br><span class="line">  return static_cast&lt;double&gt;(diff) / Timestamp::kMicroSecondsPerSecond;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///</span><br><span class="line">/// Add @c seconds to given timestamp.</span><br><span class="line">///</span><br><span class="line">/// @return timestamp+seconds as Timestamp</span><br><span class="line">///</span><br><span class="line">inline Timestamp addTime(Timestamp timestamp, double seconds)</span><br><span class="line">&#123;</span><br><span class="line">  int64_t delta = static_cast&lt;int64_t&gt;(seconds * Timestamp::kMicroSecondsPerSecond);</span><br><span class="line">  return Timestamp(timestamp.microSecondsSinceEpoch() + delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_BASE_TIMESTAMP_H</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Timestamp-cc"><a href="#Timestamp-cc" class="headerlink" title="Timestamp.cc"></a>Timestamp.cc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Timestamp.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#ifndef __STDC_FORMAT_MACROS</span><br><span class="line">#define __STDC_FORMAT_MACROS</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#include &lt;inttypes.h&gt;//如果 __STDC_FORMAT_MACROS 宏未定义，就会将其定义为非零值，然后再包含 &lt;inttypes.h&gt; 头文件，从而确保特殊的格式化宏在代码中可用</span><br><span class="line"></span><br><span class="line">using namespace muduo;//是一个命名空间的使用声明语句。它的作用是将命名空间 muduo 中的所有符号（变量、函数、类等）引入到当前的代码作用域中，使得在代码中可以直接使用这些符号而无需显式指定命名空间前缀。</span><br><span class="line"></span><br><span class="line">static_assert(sizeof(Timestamp) == sizeof(int64_t),</span><br><span class="line">              &quot;Timestamp should be same size as int64_t&quot;);</span><br><span class="line">string Timestamp::toString() const</span><br><span class="line">&#123;</span><br><span class="line">  char buf[32] = &#123;0&#125;;</span><br><span class="line">  int64_t seconds = microSecondsSinceEpoch_ / kMicroSecondsPerSecond;</span><br><span class="line">  int64_t microseconds = microSecondsSinceEpoch_ % kMicroSecondsPerSecond;</span><br><span class="line">  snprintf(buf, sizeof(buf), &quot;%&quot; PRId64 &quot;.%06&quot; PRId64 &quot;&quot;, seconds, microseconds);</span><br><span class="line">  return buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string Timestamp::toFormattedString(bool showMicroseconds) const</span><br><span class="line">&#123;</span><br><span class="line">  char buf[64] = &#123;0&#125;;</span><br><span class="line">  time_t seconds = static_cast&lt;time_t&gt;(microSecondsSinceEpoch_ / kMicroSecondsPerSecond);</span><br><span class="line">  struct tm tm_time;</span><br><span class="line">  gmtime_r(&amp;seconds, &amp;tm_time);//gmtime_r 是 C 语言和 C++ 中的一个函数，用于将 Unix 时间戳（自 1970 年 1 月 1 日以来的秒数）转换为 UTC（协调世界时）时间的结构体表示。该函数的功能与 gmtime 类似，但具有线程安全的特性。</span><br><span class="line"></span><br><span class="line">  if (showMicroseconds)</span><br><span class="line">  &#123;</span><br><span class="line">    int microseconds = static_cast&lt;int&gt;(microSecondsSinceEpoch_ % kMicroSecondsPerSecond);</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%4d%02d%02d %02d:%02d:%02d.%06d&quot;,</span><br><span class="line">             tm_time.tm_year + 1900, tm_time.tm_mon + 1, tm_time.tm_mday,</span><br><span class="line">             tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec,</span><br><span class="line">             microseconds);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    snprintf(buf, sizeof(buf), &quot;%4d%02d%02d %02d:%02d:%02d&quot;,</span><br><span class="line">             tm_time.tm_year + 1900, tm_time.tm_mon + 1, tm_time.tm_mday,</span><br><span class="line">             tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec);</span><br><span class="line">  &#125;</span><br><span class="line">  return buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Timestamp Timestamp::now()</span><br><span class="line">&#123;</span><br><span class="line">  struct timeval tv;</span><br><span class="line">  gettimeofday(&amp;tv, NULL);</span><br><span class="line">  int64_t seconds = tv.tv_sec;</span><br><span class="line">  return Timestamp(seconds * kMicroSecondsPerSecond + tv.tv_usec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">seconds * kMicroSecondsPerSecond + tv.tv_usec</span><br><span class="line">这是计算时间戳的微秒数部分。首先，将 seconds 中的秒数部分转换成微秒，即乘以 kMicroSecondsPerSecond，这个值等于 1,000,000，表示一秒有多少微秒。然后，将这个值与 tv.tv_usec 的微秒数部分相加，得到完整的时间戳的微秒数。</span><br><span class="line">return Timestamp(seconds * kMicroSecondsPerSecond + tv.tv_usec);</span><br><span class="line">最后，通过上述计算得到的完整时间戳的微秒数，创建一个 Timestamp 类的对象，并将其作为函数的返回值。</span><br><span class="line">这行代码的作用是获取当前时间，计算得到完整的时间戳（以微秒为单位），然后返回这个时间戳作为 Timestamp 类的对象。</span><br><span class="line">这个时间戳将用于创建一个 Timestamp 类的对象，并作为函数 Timestamp::now() 的返回值。所以该表达式实际上是用于计算返回值</span><br></pre></td></tr></table></figure>

<h3 id="Timestamp-unittest-cc"><a href="#Timestamp-unittest-cc" class="headerlink" title="Timestamp_unittest.cc"></a>Timestamp_unittest.cc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/Timestamp.h&quot;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using muduo::Timestamp;//它的作用是将命名空间 muduo 中的 Timestamp 类引入到当前的代码作用域中，使得在代码中可以直接使用 Timestamp 类而无需显式指定命名空间前缀</span><br><span class="line"></span><br><span class="line">void passByConstReference(const Timestamp&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;%s\n&quot;, x.toString().c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void passByValue(Timestamp x)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;%s\n&quot;, x.toString().c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void benchmark()</span><br><span class="line">&#123;</span><br><span class="line">  const int kNumber = 1000*1000;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;Timestamp&gt; stamps;</span><br><span class="line">  stamps.reserve(kNumber);</span><br><span class="line">  for (int i = 0; i &lt; kNumber; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    stamps.push_back(Timestamp::now());</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;%s\n&quot;, stamps.front().toString().c_str());</span><br><span class="line">  printf(&quot;%s\n&quot;, stamps.back().toString().c_str());</span><br><span class="line">  printf(&quot;%f\n&quot;, timeDifference(stamps.back(), stamps.front()));</span><br><span class="line"></span><br><span class="line">  int increments[100] = &#123; 0 &#125;;</span><br><span class="line">  int64_t start = stamps.front().microSecondsSinceEpoch();</span><br><span class="line">  for (int i = 1; i &lt; kNumber; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    int64_t next = stamps[i].microSecondsSinceEpoch();</span><br><span class="line">    int64_t inc = next - start;</span><br><span class="line">    start = next;</span><br><span class="line">    if (inc &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;reverse!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (inc &lt; 100)</span><br><span class="line">    &#123;</span><br><span class="line">      ++increments[inc];</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;big gap %d\n&quot;, static_cast&lt;int&gt;(inc));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for (int i = 0; i &lt; 100; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;%2d: %d\n&quot;, i, increments[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  Timestamp now(Timestamp::now());//这是一个对象的定义和初始化语句，它使用上述调用 now() 的结果来初始化一个名为 now 的 Timestamp 类对象。这里使用的是直接初始化的方式，通过调用 now() 函数得到的时间戳对象来初始化 now 对象</span><br><span class="line">  //相当于Timestamp now=Timestamp::now();调用拷贝构造函数初始化对象</span><br><span class="line">  printf(&quot;%s\n&quot;, now.toString().c_str());</span><br><span class="line">  passByValue(now);</span><br><span class="line">  passByConstReference(now);</span><br><span class="line">  benchmark();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tests下的CMake"><a href="#tests下的CMake" class="headerlink" title="tests下的CMake"></a>tests下的CMake</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_executable(timestamp_unittest Timestamp_unittest.cc)</span><br><span class="line">target_link_libraries(timestamp_unittest muduo_base)//target_link_libraries 命令用于将库（静态库或动态库）链接到目标（可执行文件或其他库）</span><br><span class="line">add_test(NAME timestamp_unittest COMMAND timestamp_unittest)</span><br></pre></td></tr></table></figure>

<h2 id="Atomic-h-执行原子性操作"><a href="#Atomic-h-执行原子性操作" class="headerlink" title="Atomic.h 执行原子性操作"></a>Atomic.h 执行原子性操作</h2><p>因为多线程用锁的话，是性能杀手，而原子性操作可以有同样效果，但是没有性能问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#ifndef MUDUO_BASE_ATOMIC_H</span><br><span class="line">#define MUDUO_BASE_ATOMIC_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/noncopyable.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">namespace detail</span><br><span class="line">&#123;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class AtomicIntegerT : noncopyable// noncopyable表示这个类不可拷贝的</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  AtomicIntegerT()</span><br><span class="line">    : value_(0)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // uncomment if you need copying and assignment</span><br><span class="line">  //</span><br><span class="line">  // AtomicIntegerT(const AtomicIntegerT&amp; that)</span><br><span class="line">  //   : value_(that.get())</span><br><span class="line">  // &#123;&#125;</span><br><span class="line">  //</span><br><span class="line">  // AtomicIntegerT&amp; operator=(const AtomicIntegerT&amp; that)//把等号运算符做成私有的</span><br><span class="line">  // &#123;</span><br><span class="line">  //   getAndSet(that.get());</span><br><span class="line">  //   return *this;</span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line">  T get()//原子地比较指定变量的值和期望值，如果相等则将该变量的值设置为新的值，并返回操作之前的值</span><br><span class="line">  &#123;</span><br><span class="line">    // in gcc &gt;= 4.7: __atomic_load_n(&amp;value_, __ATOMIC_SEQ_CST)</span><br><span class="line">    return __sync_val_compare_and_swap(&amp;value_, 0, 0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T getAndAdd(T x)//原子地将指定变量的值加上一个增量，并返回变量加增量后的结果</span><br><span class="line">  &#123;</span><br><span class="line">    // in gcc &gt;= 4.7: __atomic_fetch_add(&amp;value_, x, __ATOMIC_SEQ_CST)</span><br><span class="line">    return __sync_fetch_and_add(&amp;value_, x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T addAndGet(T x)</span><br><span class="line">  &#123;</span><br><span class="line">    return getAndAdd(x) + x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T incrementAndGet()</span><br><span class="line">  &#123;</span><br><span class="line">    return addAndGet(1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T decrementAndGet()</span><br><span class="line">  &#123;</span><br><span class="line">    return addAndGet(-1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void add(T x)</span><br><span class="line">  &#123;</span><br><span class="line">    getAndAdd(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void increment()</span><br><span class="line">  &#123;</span><br><span class="line">    incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void decrement()</span><br><span class="line">  &#123;</span><br><span class="line">    decrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T getAndSet(T newValue)</span><br><span class="line">  &#123;</span><br><span class="line">    // in gcc &gt;= 4.7: __atomic_exchange_n(&amp;value_, newValue, __ATOMIC_SEQ_CST)</span><br><span class="line">    return __sync_lock_test_and_set(&amp;value_, newValue);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  volatile T value_;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  // namespace detail</span><br><span class="line"></span><br><span class="line">typedef detail::AtomicIntegerT&lt;int32_t&gt; AtomicInt32;</span><br><span class="line">typedef detail::AtomicIntegerT&lt;int64_t&gt; AtomicInt64;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_BASE_ATOMIC_H</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在c++11下有更新</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;atomic&gt;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class AtomicIntegerT : noncopyable</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    AtomicIntegerT()</span><br><span class="line">        : value_(0)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T get()</span><br><span class="line">    &#123;</span><br><span class="line">        return value_.load(std::memory_order_seq_cst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T getAndAdd(T x)</span><br><span class="line">    &#123;</span><br><span class="line">        return value_.fetch_add(x, std::memory_order_seq_cst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T addAndGet(T x)</span><br><span class="line">    &#123;</span><br><span class="line">        return getAndAdd(x) + x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T incrementAndGet()</span><br><span class="line">    &#123;</span><br><span class="line">        return addAndGet(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T decrementAndGet()</span><br><span class="line">    &#123;</span><br><span class="line">        return addAndGet(-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void add(T x)</span><br><span class="line">    &#123;</span><br><span class="line">        getAndAdd(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void increment()</span><br><span class="line">    &#123;</span><br><span class="line">        incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void decrement()</span><br><span class="line">    &#123;</span><br><span class="line">        decrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T getAndSet(T newValue)</span><br><span class="line">    &#123;</span><br><span class="line">        return value_.exchange(newValue, std::memory_order_seq_cst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::atomic&lt;T&gt; value_;//具有volatile特性</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="测试文件Atomic-test-cc"><a href="#测试文件Atomic-test-cc" class="headerlink" title="测试文件Atomic_test.cc"></a>测试文件Atomic_test.cc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/Atomic.h&quot;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  &#123;</span><br><span class="line">  muduo::AtomicInt64 a0;</span><br><span class="line">  assert(a0.get() == 0);</span><br><span class="line">  assert(a0.getAndAdd(1) == 0);</span><br><span class="line">  assert(a0.get() == 1);</span><br><span class="line">  assert(a0.addAndGet(2) == 3);</span><br><span class="line">  assert(a0.get() == 3);</span><br><span class="line">  assert(a0.incrementAndGet() == 4);</span><br><span class="line">  assert(a0.get() == 4);</span><br><span class="line">  a0.increment();</span><br><span class="line">  assert(a0.get() == 5);</span><br><span class="line">  assert(a0.addAndGet(-3) == 2);</span><br><span class="line">  assert(a0.getAndSet(100) == 2);</span><br><span class="line">  assert(a0.get() == 100);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">  muduo::AtomicInt32 a1;</span><br><span class="line">  assert(a1.get() == 0);</span><br><span class="line">  assert(a1.getAndAdd(1) == 0);</span><br><span class="line">  assert(a1.get() == 1);</span><br><span class="line">  assert(a1.addAndGet(2) == 3);</span><br><span class="line">  assert(a1.get() == 3);</span><br><span class="line">  assert(a1.incrementAndGet() == 4);</span><br><span class="line">  assert(a1.get() == 4);</span><br><span class="line">  a1.increment();</span><br><span class="line">  assert(a1.get() == 5);</span><br><span class="line">  assert(a1.addAndGet(-3) == 2);</span><br><span class="line">  assert(a1.getAndSet(100) == 2);</span><br><span class="line">  assert(a1.get() == 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在tests下的CMake里不需要target_link_libraries，因为它没有编译静态库</span><br></pre></td></tr></table></figure>

<h3 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h3><p><img src="/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230731161906596.png" alt="image-20230731161906596"></p>
<h3 id="Types-h"><a href="#Types-h" class="headerlink" title="Types.h"></a>Types.h</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename To, typename From&gt;</span><br><span class="line">inline To implicit_cast(From const &amp;f)//隐式转换</span><br><span class="line">&#123;</span><br><span class="line">  return f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>好处是可以在没有前面代码的基础下能看懂是隐式转换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename To, typename From&gt;     // use like this: down_cast&lt;T*&gt;(foo);</span><br><span class="line">inline To down_cast(From* f)                     // so we only accept pointers</span><br><span class="line">&#123;//向下转型的函数</span><br><span class="line">  // Ensures that To is a sub-type of From *.  This test is here only</span><br><span class="line">  // for compile-time type checking, and has no overhead in an</span><br><span class="line">  // optimized build at run-time, as it will be optimized away</span><br><span class="line">  // completely.</span><br><span class="line">  if (false)</span><br><span class="line">  &#123;</span><br><span class="line">    implicit_cast&lt;From*, To&gt;(0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">#if !defined(NDEBUG) &amp;&amp; !defined(GOOGLE_PROTOBUF_NO_RTTI)</span><br><span class="line">  assert(f == NULL || dynamic_cast&lt;To&gt;(f) != NULL);  // RTTI: debug mode only!</span><br><span class="line">#endif</span><br><span class="line">  return static_cast&lt;To&gt;(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异常Exception封装"><a href="#异常Exception封装" class="headerlink" title="异常Exception封装"></a>异常Exception封装</h2><p>Exception类实现</p>
<ul>
<li><p>backtrace，栈回溯，保存各个栈帧的地址</p>
</li>
<li><p>backtrace_symbols，根据地址，转成相应的函数符号</p>
</li>
<li><p>abi: :__cxa_demangle,我这里使用了将<code>demangle</code>参数设置为ture可以进行符号解析以得到更具可读性的堆栈信息</p>
</li>
</ul>
<h3 id="Exception-h"><a href="#Exception-h" class="headerlink" title="Exception.h"></a>Exception.h</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#ifndef MUDUO_BASE_EXCEPTION_H</span><br><span class="line">#define MUDUO_BASE_EXCEPTION_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Types.h&quot;</span><br><span class="line">#include &lt;exception&gt;  </span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">class Exception : public std::exception</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  Exception(string what);</span><br><span class="line">  ~Exception() noexcept override = default;</span><br><span class="line"></span><br><span class="line">  // default copy-ctor and operator= are okay.</span><br><span class="line"></span><br><span class="line">  const char* what() const noexcept override</span><br><span class="line">  &#123;</span><br><span class="line">    return message_.c_str();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const char* stackTrace() const noexcept</span><br><span class="line">  //const 关键字在函数名后面表示该函数是一个常量成员函数。而 noexcept 关键字则表示该函数不会抛出异常</span><br><span class="line">  &#123;</span><br><span class="line">    return stack_.c_str();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  string message_;</span><br><span class="line">  string stack_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_BASE_EXCEPTION_H</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Exception-cc"><a href="#Exception-cc" class="headerlink" title="Exception.cc"></a>Exception.cc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/Exception.h&quot;</span><br><span class="line">#include &quot;muduo/base/CurrentThread.h&quot;</span><br><span class="line"></span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Exception::Exception(string msg)</span><br><span class="line">  : message_(std::move(msg)),//std::move用于实现右值引用（rvalue reference）。它将一个左值（lvalue）强制转换为右值引用，从而可以实现移动语义，减少不必要的拷贝，提高代码的性能</span><br><span class="line">    stack_(CurrentThread::stackTrace(/*demangle=*/false))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>stack_(CurrentThread::stackTrace(/*demangle=*/false))</code>这行代码是在构造<code>Exception</code>对象时调用<code>stackTrace</code>函数，并将返回的字符串作为参数传递给<code>stack_</code>成员变量。</p>
<p>具体调用过程如下：</p>
<ol>
<li>在<code>Exception</code>类的构造函数中，使用<code>std::move(msg)</code>将传入的<code>msg</code>字符串初始化<code>message_</code>成员变量。</li>
<li>接着，调用<code>CurrentThread::stackTrace(/*demangle=*/false)</code>函数，获取当前线程的堆栈信息，<code>demangle</code>参数设置为<code>false</code>表示不需要进行符号解析（mangling）。</li>
<li><code>stackTrace</code>函数首先声明了一个字符串<code>stack</code>，用于存储堆栈信息。</li>
<li>接下来，通过<code>::backtrace()</code>函数获取当前线程的调用堆栈帧，并将返回的帧指针数组存储在<code>frame</code>中。</li>
<li>使用<code>::backtrace_symbols()</code>函数将帧指针数组转换为可读的字符串数组<code>strings</code>，每个字符串表示一个堆栈帧的信息。</li>
<li>然后，函数进入一个循环，遍历堆栈帧，处理每个帧的信息。</li>
<li>如果<code>demangle</code>为<code>true</code>，则尝试对符号进行解析，以得到可读的函数名和地址信息。这里使用<code>abi::__cxa_demangle()</code>进行符号解析。</li>
<li>解析得到的字符串会与原始的堆栈帧信息拼接，然后添加到<code>stack</code>字符串中，并添加一个换行符。</li>
<li>如果<code>demangle</code>为<code>false</code>或解析失败，将使用原始的堆栈帧信息添加到<code>stack</code>字符串中，并添加一个换行符。</li>
<li>最后，返回拼接好的<code>stack</code>字符串作为函数的返回值。</li>
<li>这个返回的字符串将被用来初始化<code>Exception</code>对象的<code>stack_</code>成员变量。</li>
</ol>
<p>总结：<code>stack_(CurrentThread::stackTrace(/*demangle=*/false))</code>调用了<code>stackTrace</code>函数并将返回的字符串作为堆栈信息赋值给<code>stack_</code>成员变量。</p>
<h3 id="CurrentThread-cc"><a href="#CurrentThread-cc" class="headerlink" title="CurrentThread.cc"></a>CurrentThread.cc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">string stackTrace(bool demangle)</span><br><span class="line">&#123;</span><br><span class="line">  string stack;</span><br><span class="line">  const int max_frames = 200;</span><br><span class="line">  void* frame[max_frames];</span><br><span class="line">  int nptrs = ::backtrace(frame, max_frames);</span><br><span class="line">  char** strings = ::backtrace_symbols(frame, nptrs);</span><br><span class="line">  if (strings)</span><br><span class="line">  &#123;</span><br><span class="line">    size_t len = 256;</span><br><span class="line">    char* demangled = demangle ? static_cast&lt;char*&gt;(::malloc(len)) : nullptr;</span><br><span class="line">    for (int i = 1; i &lt; nptrs; ++i)  // skipping the 0-th, which is this function</span><br><span class="line">    &#123;</span><br><span class="line">      if (demangle)</span><br><span class="line">      &#123;</span><br><span class="line">        // https://panthema.net/2008/0901-stacktrace-demangled/</span><br><span class="line">        // bin/exception_test(_ZN3Bar4testEv+0x79) [0x401909]</span><br><span class="line">        char* left_par = nullptr;</span><br><span class="line">        char* plus = nullptr;</span><br><span class="line">        for (char* p = strings[i]; *p; ++p)</span><br><span class="line">        &#123;</span><br><span class="line">          if (*p == &#x27;(&#x27;)</span><br><span class="line">            left_par = p;</span><br><span class="line">          else if (*p == &#x27;+&#x27;)</span><br><span class="line">            plus = p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (left_par &amp;&amp; plus)</span><br><span class="line">        &#123;</span><br><span class="line">          *plus = &#x27;\0&#x27;;</span><br><span class="line">          int status = 0;</span><br><span class="line">          char* ret = abi::__cxa_demangle(left_par+1, demangled, &amp;len, &amp;status);</span><br><span class="line">          *plus = &#x27;+&#x27;;</span><br><span class="line">          if (status == 0)</span><br><span class="line">          &#123;</span><br><span class="line">            demangled = ret;  // ret could be realloc()</span><br><span class="line">            stack.append(strings[i], left_par+1);</span><br><span class="line">            stack.append(demangled);</span><br><span class="line">            stack.append(plus);</span><br><span class="line">            stack.push_back(&#x27;\n&#x27;);</span><br><span class="line">            continue;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // Fallback to mangled names</span><br><span class="line">      stack.append(strings[i]);</span><br><span class="line">      stack.push_back(&#x27;\n&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    free(demangled);</span><br><span class="line">    free(strings);</span><br><span class="line">  &#125;</span><br><span class="line">  return stack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在C++中，双冒号<code>::</code>被用于两个主要目的：</p>
<ol>
<li>表示全局命名空间：在全局作用域中，<code>::</code>表示全局命名空间，例如<code>::function_name()</code>表示调用全局命名空间中的函数<code>function_name</code>。</li>
<li>限定类的作用域：在类的作用域中，<code>::</code>可以用于限定类的作用域，例如<code>Class::member_function()</code>表示调用类<code>Class</code>的成员函数<code>member_function</code>。</li>
</ol>
<p>对于<code>::backtrace()</code>这个函数，它不属于任何特定的类，所以双冒号<code>::</code>表示全局命名空间，这样可以在全局范围内调用<code>backtrace</code>函数。</p>
<h3 id="Exception-test-cc"><a href="#Exception-test-cc" class="headerlink" title="Exception_test.cc"></a>Exception_test.cc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/CurrentThread.h&quot;</span><br><span class="line">#include &quot;muduo/base/Exception.h&quot;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">class Bar</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">  void test(std::vector&lt;std::string&gt; names = &#123;&#125;)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Stack:\n%s\n&quot;, muduo::CurrentThread::stackTrace(true).c_str());</span><br><span class="line">    [] &#123;</span><br><span class="line">      printf(&quot;Stack inside lambda:\n%s\n&quot;, muduo::CurrentThread::stackTrace(true).c_str());</span><br><span class="line">    &#125;();</span><br><span class="line">    std::function&lt;void()&gt; func([] &#123;</span><br><span class="line">      printf(&quot;Stack inside std::function:\n%s\n&quot;, muduo::CurrentThread::stackTrace(true).c_str());</span><br><span class="line">    &#125;);</span><br><span class="line">    func();</span><br><span class="line"></span><br><span class="line">    func = std::bind(&amp;Bar::callback, this);</span><br><span class="line">    func();</span><br><span class="line"></span><br><span class="line">    throw muduo::Exception(&quot;oops&quot;);</span><br><span class="line">    //会创建一个 muduo::Exception 类型的异常对象，并将其抛出。然后程序会搜索调用栈，查找适合处理该异常的异常处理代码。如果找不到合适的处理代码，程序将终止并显示异常信息，跳转到下面catch</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">   void callback()</span><br><span class="line">   &#123;</span><br><span class="line">     printf(&quot;Stack inside std::bind:\n%s\n&quot;, muduo::CurrentThread::stackTrace(true).c_str());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void foo()</span><br><span class="line">&#123;</span><br><span class="line">  Bar b;</span><br><span class="line">  b.test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  try</span><br><span class="line">  &#123;</span><br><span class="line">    foo();</span><br><span class="line">  &#125;</span><br><span class="line">  catch (const muduo::Exception&amp; ex)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;reason: %s\n&quot;, ex.what());</span><br><span class="line">    printf(&quot;stack trace:\n%s\n&quot;, ex.stackTrace());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230801150628949.png" alt="image-20230801150628949"></p>
<img src="/2023/08/01/muduo-%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%881%EF%BC%89/image-20230801150628949.png" class title="This is an test image">

<p>对throw muduo::Exception(“oops”);的理解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // 可能抛出异常的代码块</span><br><span class="line">    // ...</span><br><span class="line">    throw SomeException(&quot;Error message&quot;); // 抛出异常</span><br><span class="line">    // ...</span><br><span class="line">&#125; catch (const SomeException&amp; ex) &#123;</span><br><span class="line">    // 处理异常的代码块</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">肖汇林</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">肖汇林</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
