<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="选择有时候比努力更重要">
<meta property="og:type" content="website">
<meta property="og:title" content="肖汇林的博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="肖汇林的博客">
<meta property="og:description" content="选择有时候比努力更重要">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="肖汇林">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>肖汇林的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肖汇林的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4/" class="post-title-link" itemprop="url">数据结构-4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-09-17 15:37:50 / 修改时间：15:48:04" itemprop="dateCreated datePublished" datetime="2023-09-17T15:37:50+08:00">2023-09-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h1><p>给定节点数为 n 的二叉树的前序遍历和中序遍历结果，请重建出该二叉树并返回它的头结点。</p>
<p>例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建出如下图所示。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4/image-20230917153948200.png" alt="image-20230917153948200"></p>
<img src="/2023/09/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4/image-20230917153948200.png" class title="This is an test image">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123;</span><br><span class="line">         if (pre.size() == 0 || vin.size() == 0) &#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* treeNode = new TreeNode(pre[0]);</span><br><span class="line">        int mid = distance(begin(vin), find(vin.begin(), vin.end(), pre[0]));</span><br><span class="line">        vector&lt;int&gt; left_pre(pre.begin() + 1, pre.begin() + mid + 1);</span><br><span class="line">        vector&lt;int&gt; right_pre(pre.begin() + mid + 1, pre.end());</span><br><span class="line">        vector&lt;int&gt; left_in(vin.begin(), vin.begin() + mid);</span><br><span class="line">        vector&lt;int&gt; right_in(vin.begin() + mid + 1, vin.end());</span><br><span class="line"></span><br><span class="line">        treeNode-&gt;left = reConstructBinaryTree(left_pre, left_in);</span><br><span class="line">        treeNode-&gt;right = reConstructBinaryTree(right_pre, right_in);</span><br><span class="line">        return treeNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>思路：根据前序找到根节点，然后在中序遍历找到左右子节点，依此递归。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/13/c-%E8%A1%A5%E5%85%853/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/13/c-%E8%A1%A5%E5%85%853/" class="post-title-link" itemprop="url">c++-补充3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-13 17:01:39" itemprop="dateCreated datePublished" datetime="2023-09-13T17:01:39+08:00">2023-09-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-17 14:35:09" itemprop="dateModified" datetime="2023-09-17T14:35:09+08:00">2023-09-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="静态类型和动态类型，静态绑定和动态绑定"><a href="#静态类型和动态类型，静态绑定和动态绑定" class="headerlink" title="静态类型和动态类型，静态绑定和动态绑定"></a>静态类型和动态类型，静态绑定和动态绑定</h1><ul>
<li>静态类型：对象在声明时采用的类型，在编译期既已确定；</li>
<li>动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；</li>
<li>静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；</li>
<li>动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；</li>
</ul>
<p>非虚函数一般都是静态绑定，而虚函数都是动态绑定（如此才可实现多态 性）。 举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    /*virtual*/ void func() &#123; std::cout &lt;&lt; &quot;A::func()\n&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class B : public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void func() &#123; std::cout &lt;&lt; &quot;B::func()\n&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class C : public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void func() &#123; std::cout &lt;&lt; &quot;C::func()\n&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    C *pc = new C(); // pc的静态类型是它声明的类型C*，动态类型也是C*；</span><br><span class="line">    B *pb = new B(); // pb的静态类型和动态类型也都是B*；</span><br><span class="line">    A *pa = pc;      // pa的静态类型是它声明的类型A*，动态类型是pa所指向的对象pc的类型C*；</span><br><span class="line">    pa = pb;         // pa的动态类型可以更改，现在它的动态类型是B*，但其静态类型仍是声明时候的A*；</span><br><span class="line">    C *pnull = NULL; // pnull的静态类型是它声明的类型C*,没有动态类型，因为它指向了NULL；</span><br><span class="line"></span><br><span class="line">    pa-&gt;func();    // A::func() pa的静态类型永远都是A*，不管其指向的是哪个子类，都是直接调用A::func()；</span><br><span class="line">    pc-&gt;func();    // C::func() pc的动、静态类型都是C*，因此调用C::func()；</span><br><span class="line">    pnull-&gt;func(); // C::func() 不用奇怪为什么空指针也可以调用函数，因为这在编译期就确定了，和指针空不空没关系；</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果将A类中的virtual注释去掉，则运行结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pa-&gt;func(); //B::func() 因为有了virtual虚函数特性，pa的动态类型指向B*，因此先在B中查找，找到后直接调用；</span><br><span class="line">pc-&gt;func(); //C::func() pc的动、静态类型都是C*，因此也是先在C中查找；</span><br><span class="line">pnull-&gt;func(); //空指针异常，因为是func是virtual函数，因此对func的调用只能等到运行期才能确定，然后才发现pnull是空指针；</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，</p>
<ul>
<li>如果基类A中的func不是virtual函数，那么不论pa、pb、pc指向哪个子类对象，对func的调用都是在定义pa、pb、pc时的静态类型决定，早已在编译期确定了。</li>
<li>同样的空指针也能够直接调用no-virtual函数而不报错（这也说明一定要做空指针检查啊！），因此静态绑定不能实现多态；</li>
<li>如果func是虚函数，那所有的调用都要等到运行时根据其指向对象的类型才能确定，比起静态绑定自然是要有性能损失的，但是却能实现多态特性；</li>
</ul>
<p>另外，在动态绑定也即在virtual函数中，要注意默认参数的使用。当 缺省参数和virtual函数一起使用的时候一定要谨慎，不然出了问题怕是很难排查</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class E</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void func(int i = 0)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;E::func()\t&quot; &lt;&lt; i &lt;&lt; &quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class F : public E</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void func(int i = 1)override</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;F::func()\t&quot; &lt;&lt; i &lt;&lt; &quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test2()</span><br><span class="line">&#123;</span><br><span class="line">    F *pf = new F();</span><br><span class="line">    E *pe = pf;</span><br><span class="line">    pf-&gt;func(); // F::func() 1 正常，就该如此；</span><br><span class="line">    pe-&gt;func(); // F::func() 0 哇哦，这是什么情况，调用了子类的函数，却使用了基类中参数的默认值！</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    test2();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="指针加减计算"><a href="#指针加减计算" class="headerlink" title="指针加减计算"></a>指针加减计算</h1><p>指针加减本质是对其所指地址的移动，移动的步长跟指针的类型是有关系的，因此在涉及到指针加减运 算需要十分小心，加多或者减多都会导致指针指向一块未知的内存地址，如果再进行操作就会很危险。 举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> 	int *a, *b, c;</span><br><span class="line"> 	a = (int*)0x500;</span><br><span class="line"> 	b = (int*)0x520;</span><br><span class="line"> 	c = b - a;</span><br><span class="line"> 	printf(&quot;%d\n&quot;, c); // 8</span><br><span class="line"> 	a += 0x020;</span><br><span class="line"> 	c = b - a;</span><br><span class="line"> 	printf(&quot;%d\n&quot;, c); // -24</span><br><span class="line"> 	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先变量a和b都是以16进制的形式初始化，将它们转成10进制分别是1280（5<em>16^2&#x3D;1280）和 1312（5</em>16^2+2*16&#x3D;1312)， 那么它们的差值为32，也就是说a和b所指向的地址之间间隔32个位，但是 考虑到是int类型占4位，所以c的值为32&#x2F;4&#x3D;8.</p>
<p>a自增16进制0x20之后，其实际地址变为1280 + 2<em>16</em>4 &#x3D; 1408，（因为一个int占4位，所以要乘4），这 样它们的差值就变成了1312 - 1280 &#x3D; -96，所以c的值就变成了-96&#x2F;4 &#x3D; -24 遇到指针的计算，<strong>需要明确的是指针每移动一位，它实际跨越的内存间隔是指针类型的长度，建议都转 成10进制计算，计算结果除以类型长度取得结果</strong></p>
<h1 id="判断两个浮点数是否相等"><a href="#判断两个浮点数是否相等" class="headerlink" title="判断两个浮点数是否相等"></a>判断两个浮点数是否相等</h1><p>对两个浮点数判断大小和是否相等不能直接用&#x3D;&#x3D;来判断，会出错！明明相等的两个数比较反而是不相 等！对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值！浮点数与0的比较 也应该注意。与浮点数的表示方式有关。</p>
<p>在判断两个浮点数是否相等时，由于浮点数的内部表示方式以及浮点数运算的特性，直接使用相等运算符（<code>==</code>）进行比较可能会导致误差。</p>
<p>这是因为浮点数的内部二进制表示可能会存在舍入误差，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">float a = 0.1f + 0.1f + 0.1f;</span><br><span class="line">float b = 0.3f;</span><br><span class="line"></span><br><span class="line">if (a == b) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;相等&quot; &lt;&lt; endl;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    cout &lt;&lt; &quot;不相等&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，我们期望 <code>a</code> 和 <code>b</code> 的值相等，因为它们都是 0.3。然而，由于浮点数的内部二进制表示存在舍入误差，实际运行结果可能会输出 “不相等”。</p>
<p>为了解决这个问题，一种常用的方法是定义一个误差范围（epsilon），然后判断两个浮点数的绝对差是否小于该误差范围。如果绝对差小于等于 epsilon，那么认为两个浮点数是近似相等的。</p>
<p>下面是一个示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">bool areEqual(float a, float b, float epsilon = 1e-6) &#123;</span><br><span class="line">    return std::abs(a - b) &lt;= epsilon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    float a = 0.1f + 0.1f + 0.1f;</span><br><span class="line">    float b = 0.3f;</span><br><span class="line"></span><br><span class="line">    if (areEqual(a, b)) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;相等&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;不相等&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，我们定义了一个 <code>areEqual</code> 函数，用于判断两个浮点数是否近似相等。默认情况下，我们使用误差范围 <code>epsilon</code> 的值为 1e-6，你可以根据具体的需求调整这个值。</p>
<p>通过调用 <code>areEqual</code> 函数来比较 <code>a</code> 和 <code>b</code> 的值，输出结果应该是 “相等”。通过引入误差范围，可以避免由于浮点数的舍入误差而导致的比较结果错误。</p>
<h1 id="继承机制中对象之间如何转换"><a href="#继承机制中对象之间如何转换" class="headerlink" title="继承机制中对象之间如何转换"></a>继承机制中对象之间如何转换</h1><ol>
<li>向上类型转换<br>将派生类指针或引用转换为基类的指针或引用被称为向上类型转换，向上类型转换会自动进行，而且向上类型转换是安全的。</li>
<li>向下类型转换<br>将基类指针或引用转换为派生类指针或引用被称为向下类型转换，向下类型转换不会自动进行，因为一个基类对应几个派生类，所以向下类型转换时不知道对应哪个派生类，所以在向下类型转换时必须加动态类型识别技术。RTTI技术，用dynamic_cast进行向下类型转换</li>
</ol>
<h1 id="函数调用过程栈的变化"><a href="#函数调用过程栈的变化" class="headerlink" title="函数调用过程栈的变化"></a>函数调用过程栈的变化</h1><p>调用者函数把被调函数所需要的参数按照与被调函数的形参顺序相反的顺序压入栈中,即:从右向左依次把被调 函数所需要的参数压入栈;</p>
<p>调用者函数使用call指令调用被调函数,并把call指令的下一条指令的地址当成返回地址压入栈中(这个压栈操作隐含在call指令中);</p>
<h1 id="define、const、typedef、inline"><a href="#define、const、typedef、inline" class="headerlink" title="define、const、typedef、inline"></a>define、const、typedef、inline</h1><p>​		一、const与#define的区别：</p>
<ul>
<li><p>const定义的常量是变量带类型，而#define定义的只是个常数不带类型；</p>
</li>
<li><p>define只在预处理阶段起作用，简单的文本替换，而const在编译、链接过程中起作用；</p>
</li>
<li><p>define只是简单的字符串替换没有类型检查。而const是有数据类型的，是要进行判断的，可以避免一些低级错误；</p>
</li>
<li><p>define预处理后，占用代码段空间，const占用数据段空间；</p>
</li>
<li><p>const不能重定义，而define可以通过#undef取消某个符号的定义，进行重定义；</p>
</li>
<li><p>define独特功能，比如可以用来防止文件重复引用。</p>
<p>二、#define和别名typedef的区别</p>
</li>
<li><p>执行时间不同，typedef在编译阶段有效，typedef有类型检查的功能；#define是宏定义，发生在预处理阶段，不进行类型检查；</p>
</li>
<li><p>功能差异，typedef用来定义类型的别名，定义与平台无关的数据类型，与struct的结合使用等。#define不只是可以为类型取别名，还可以定义常量、变量、编译开关等。</p>
</li>
<li><p>作用域不同，#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。而typedef有自己的作用域。<br>三、 define与inline的区别</p>
</li>
<li><p>#define是关键字，inline是函数；</p>
</li>
<li><p>宏定义在预处理阶段进行文本替换，inline函数在编译阶段进行替换；</p>
</li>
<li><p>inline函数有类型检查，相比宏定义比较安全；</p>
</li>
</ul>
<h1 id="printf函数的实现原理"><a href="#printf函数的实现原理" class="headerlink" title="printf函数的实现原理"></a>printf函数的实现原理</h1><p>在C&#x2F;C++中，对函数参数的扫描是从后向前的。</p>
<p>C&#x2F;C++的函数参数是通过压入堆栈的方式来给函数传参数的（堆栈是一种先进后出的数据结构），最先压入的参数最后出来，在计算机的内存中，数据有2块，一块是堆，一块是栈（函数参数及局部变量在这里），而栈是从内存的高地址向低地址生长的，控制生长的就是堆栈指针了，最先压入的参数是在最上面，就是说在所有参数的最后面，最后压入的参数在最下面，结构上看起来是第一个，所以最后压入的参数总是能够被函数找到，因为它就在堆栈指针的上方。</p>
<p>printf的第一个被找到的参数就是那个字符指针，就是被双引号括起来的那一部分，函数通过判断字符串里控制参数的个数来判断参数个数及数据类型，通过这些就可算出数据需要的堆栈指针的偏移量了。</p>
<h1 id="strcpy和memcpy的区别"><a href="#strcpy和memcpy的区别" class="headerlink" title="strcpy和memcpy的区别"></a>strcpy和memcpy的区别</h1><ol>
<li>复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。</li>
<li>复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。</li>
<li>用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</li>
<li>① strcpy主要实现字符串变量间的拷贝<br>② sprintf主要实现其他数据类型格式到字符串的转化<br>③ memcpy主要是内存块间的拷贝。</li>
</ol>
<p><code>strcpy</code> 函数用于将一个字符串（以 null 结尾的字符数组）复制到另一个字符数组中。它的函数原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char* strcpy(char* destination, const char* source);</span><br></pre></td></tr></table></figure>

<p>其中，<code>destination</code> 是目标字符数组的指针，<code>source</code> 是要拷贝的源字符数组的指针。<code>strcpy</code> 函数会将源字符数组中的内容复制到目标字符数组中，并返回目标字符数组的指针。</p>
<p><code>memcpy</code> 函数用于将一块内存区域的内容复制到另一个内存区域。它的函数原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void* memcpy(void* destination, const void* source, size_t num);</span><br></pre></td></tr></table></figure>

<p>其中，<code>destination</code> 是目标内存区域的指针，<code>source</code> 是源内存区域的指针，<code>num</code> 是要复制的字节数。<code>memcpy</code> 函数会将源内存区域中的内容复制到目标内存区域中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memcpy(&amp;person2, &amp;person1, sizeof(Person));//prerson是类或结构体的情况</span><br></pre></td></tr></table></figure>

<h1 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1><p>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如： 操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行 优化，从而可以提供对特殊地址的稳定访问。声明时语法：int volatile vInt; 当要求使用 volatile 声明的变 量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而 且读取的数据立刻被保存。</p>
<p>volatile用在如下的几个地方：</p>
<ol>
<li>中断服务程序中修改的供其它程序检测的变量需要加volatile；</li>
<li>多任务环境下各任务间共享的标志应该加volatile；</li>
<li>存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；</li>
</ol>
<h1 id="空类默认添加函数"><a href="#空类默认添加函数" class="headerlink" title="空类默认添加函数"></a>空类默认添加函数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1) Empty(); // 缺省构造函数//</span><br><span class="line">2) Empty( const Empty&amp; ); // 拷贝构造函数//</span><br><span class="line">3) ~Empty(); // 析构函数//</span><br><span class="line">4) Empty&amp; operator=( const Empty&amp; ); // 赋值运算符//</span><br></pre></td></tr></table></figure>

<h1 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h1><ul>
<li>(1) 友元关系不能被继承。</li>
<li>(2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。</li>
<li>(3) 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明</li>
</ul>
<h1 id="成员函数中调用delete-this"><a href="#成员函数中调用delete-this" class="headerlink" title="成员函数中调用delete this"></a>成员函数中调用delete this</h1><p>在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放 在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。 当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及 到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现 不可预期的问题。</p>
<p>在成员函数中调用 <code>delete this</code> 将导致未定义行为。这是因为在调用 <code>delete this</code> 后，对象所在的内存将被释放，但对象的成员函数仍然存在。</p>
<p>由于对象所占用的内存已经被释放，再次调用该对象的成员函数将导致访问已经无效的内存，可能会导致程序崩溃或产生其他不可预测的结果。</p>
<p>所以，在调用 <code>delete this</code> 后，不应该再使用对象的成员函数，也不能对对象进行任何操作。</p>
<p>以下示例演示了在成员函数中调用 <code>delete this</code> 的问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class MyClass &#123;</span><br><span class="line">public:</span><br><span class="line">    void doSomething() &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Doing something&quot; &lt;&lt; std::endl;</span><br><span class="line">        delete this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    MyClass* obj = new MyClass();</span><br><span class="line">    obj-&gt;doSomething();  // 调用 delete this</span><br><span class="line"></span><br><span class="line">    obj-&gt;doSomething();  // 潜在的未定义行为：访问无效的内存</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>MyClass</code> 类的 <code>doSomething</code> 成员函数中调用了 <code>delete this</code>。在 <code>main</code> 函数中，我们首先创建了一个 <code>MyClass</code> 的对象 <code>obj</code>，然后调用了 <code>obj-&gt;doSomething()</code>。在该调用内部，对象被删除并且内存被释放。接着，我们又尝试调用 <code>obj-&gt;doSomething()</code> 一次，这是不安全的，因为对象已经不存在，访问无效的内存会导致未定义行为。</p>
<p>this在成员函数的开始执行前构造，在成员的执行结束后清除。这里的清除和delete有区别。</p>
<ul>
<li><p>结束对象的生命周期时，内存会被自动释放（在栈上分配的对象在作用域结束时，动态分配的对象在使用 <code>delete</code> 运算符时）。</p>
</li>
<li><p>调用 <code>delete this</code> 是显式地删除对象，包括对象本身和其成员。这是一种危险的操作，需要谨慎使用。</p>
<ul>
<li><p>栈对象：栈对象是在函数内部或代码块内部声明的对象，其存储在程序的栈上。当栈对象的作用域结束时（例如函数返回或代码块结束），编译器会自动清理栈对象，释放其所占用的内存。</p>
</li>
<li><p>堆对象：堆对象是通过 <code>new</code> 运算符在堆内存中动态分配的对象。使用 <code>new</code> 创建的对象存储在堆上，并且需要通过 <code>delete</code> 运算符显式地释放。调用 <code>delete</code> 会销毁堆对象，释放其所占用的内存。这里我理解成相当于删除副本和原件。</p>
</li>
</ul>
</li>
</ul>
<p>堆上分配的对象的生命周期不受作用域的限制。堆对象可以在任何地方创建，并且会一直存在，直到显式地通过<code>delete</code>删除或程序运行结束。</p>
<h1 id="空类"><a href="#空类" class="headerlink" title="空类"></a>空类</h1><ol>
<li>C++空类的大小不为0，不同编译器设置不一样，vs设置为1；</li>
<li>C++标准指出，不允许一个对象（当然包括类对象）的大小为0，不同的对象不能具有相同的地址；</li>
<li>带有虚函数的C++类大小不为1，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小<br>确定；</li>
<li>C++中要求对于类的每个实例都必须有独一无二的地址,那么编译器自动为空类分配一个字节大小，<br>这样便保证了每个实例均有独一无二的内存地址。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line"> 	cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 1;</span><br><span class="line"> 	A a; </span><br><span class="line"> 	cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 1;</span><br><span class="line"> 	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空类的大小是1， 在C++中空类会占一个字节，这是为了让对象的实例能够相互区别。具体来说，空类 同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个 字节，这样空类实例化之后就会拥有独一无二的内存地址。当该空白类作为基类时，该类的大小就优化 为0了，子类的大小就是子类本身的大小。这就是所谓的空白基类最优化。</p>
<p>空类的实例大小就是类的大小，所以sizeof(a)&#x3D;1字节,如果a是指针，则sizeof(a)就是指针的大小，即4字 节。因为有虚函数的类对象中都有一个虚函数表指针 __vptr，其大小是4字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A &#123; virtual Fun()&#123;&#125; &#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line"> 	cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 4(32位机器)/8(64位机器);</span><br><span class="line"> 	A a; </span><br><span class="line"> 	cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 4(32位机器)/8(64位机器);</span><br><span class="line"> 	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>静态成员存放在静态存储区，不占用类的大小, 普通函数也不占用类大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A &#123; static int a; &#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line"> 	cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 1;</span><br><span class="line"> 	A a; </span><br><span class="line"> 	cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 1;</span><br><span class="line"> 	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>静态成员a不占用类的大小，所以类的大小就是b变量的大小 即4个字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class A &#123; int a; &#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line"> 	cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 4;</span><br><span class="line"> 	A a; </span><br><span class="line"> 	cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 4;</span><br><span class="line"> 	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A &#123; static int a; int b; &#125;;;</span><br><span class="line">int main()&#123;</span><br><span class="line"> 	cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 4;</span><br><span class="line"> 	A a; </span><br><span class="line"> 	cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 4;</span><br><span class="line"> 	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="类对象的大小"><a href="#类对象的大小" class="headerlink" title="类对象的大小"></a>类对象的大小</h1><ol>
<li>类的非静态成员变量大小，静态成员不占据类的空间，成员函数也不占据类的空间大小；</li>
<li>内存对齐另外分配的空间大小，类内的数据也是需要进行内存对齐操作的；</li>
<li>虚函数的话，会在类对象插入vptr指针，加上指针大小；</li>
<li>当该类是某类的派生类，那么派生类继承的基类部分的数据成员也会存在在派生类中的空间中，也会对派生类进行扩展。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/10/c-%E8%A1%A5%E5%85%85-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/10/c-%E8%A1%A5%E5%85%85-2/" class="post-title-link" itemprop="url">c++补充-2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-10 11:50:16" itemprop="dateCreated datePublished" datetime="2023-09-10T11:50:16+08:00">2023-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-17 12:33:30" itemprop="dateModified" datetime="2023-09-17T12:33:30+08:00">2023-09-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="extern”C”的用法"><a href="#extern”C”的用法" class="headerlink" title="extern”C”的用法"></a>extern”C”的用法</h1><p>为了能够正确的在C++代码中调用C语言的代码：在程序中加上extern “C”后，相当于告诉编译器这部分<br>代码是C语言写的，因此要按照C语言进行编译，而不是C++；<br>哪些情况下使用extern “C”：<br>（1）C++代码中调用C语言代码；<br>（2）在C++中的头文件中使用；<br>（3）在多个人协同开发时，可能有人擅长C语言，而有人擅长C++；<br>综上，总结出使用方法，在C语言的头文件中，对其外部函数只能指定为extern类型，C语言中不支持 extern “C”声明，在.c文件中包含了extern “C”时会出现编译语法错误。所以使用extern “C”全部都放在 于cpp程序相关文件或其头文件中。</p>
<p>（1）C++调用C函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//xx.h</span><br><span class="line">extern int add(...)</span><br><span class="line">//xx.c</span><br><span class="line">int add()&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">//xx.cpp</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line"> #include &quot;xx.h&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）C调用C++函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//xx.h</span><br><span class="line">extern &quot;C&quot;&#123;</span><br><span class="line"> int add();</span><br><span class="line">&#125;</span><br><span class="line">//xx.cpp</span><br><span class="line">int add()&#123; </span><br><span class="line">&#125;</span><br><span class="line">//xx.c</span><br><span class="line">extern int add();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="野指针和悬空指针"><a href="#野指针和悬空指针" class="headerlink" title="野指针和悬空指针"></a>野指针和悬空指针</h1><p>都是是指向无效内存区域(这里的无效指的是”不安全不可控”)的指针，访问行为将会导致未定义行为。</p>
<ul>
<li>野指针，指的是没有被初始化过的指针</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(void) &#123; </span><br><span class="line"> </span><br><span class="line"> 	int* p; // 未初始化</span><br><span class="line"> 	std::cout&lt;&lt; *p &lt;&lt; std::endl; // 未初始化就被使用</span><br><span class="line"> 	</span><br><span class="line"> 	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，为了防止出错，对于指针初始化时都是赋值为 nullptr，这样在使用时编译器就会直接报错， 产生非法内存访问。</p>
<ul>
<li>悬空指针，指针最初指向的内存已经被释放了的一种指针。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(void) &#123; </span><br><span class="line"> int * p = nullptr;</span><br><span class="line"> int* p2 = new int;</span><br><span class="line"> </span><br><span class="line"> p = p2;</span><br><span class="line"> delete p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时 p和p2就是悬空指针，指向的内存已经被释放。继续使用这两个指针，行为不可预料。需要设置为 p&#x3D;p2&#x3D;nullptr。此时再使用，编译器会直接保错。 </p>
<p>避免野指针比较简单，但悬空指针比较麻烦。c++引入了智能指针，C++智能指针的本质就是避免悬空指针的产生。</p>
<p>产生原因及解决办法： </p>
<ul>
<li>野指针：指针变量未及时初始化 &#x3D;&gt; 定义指针变量及时初始化，要么置空。 </li>
<li>悬空指针：指针free或delete之后没有及时置空 &#x3D;&gt; 释放操作后立即置空。</li>
</ul>
<h1 id="判断大小端存储"><a href="#判断大小端存储" class="headerlink" title="判断大小端存储"></a>判断大小端存储</h1><p>大端存储：字数据的高字节存储在低地址中</p>
<p>小端存储：字数据的低字节存储在低地址中</p>
<p>在Socket编程中，往往需要将操作系统所用的小端存储的IP地址转换为大端存储，这样才能进行网络传输</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> int a = 0x1234;</span><br><span class="line"> //由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分</span><br><span class="line"> char c = (char)(a);</span><br><span class="line"> if (c == 0x12)</span><br><span class="line"> cout &lt;&lt; &quot;big endian&quot; &lt;&lt; endl;</span><br><span class="line"> else if(c == 0x34)</span><br><span class="line"> cout &lt;&lt; &quot;little endian&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//union联合体的重叠式存储，endian联合体占用内存的空间为每个成员字节长度的最大值</span><br><span class="line">union endian</span><br><span class="line">&#123;</span><br><span class="line"> int a;</span><br><span class="line"> char ch;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> endian value;</span><br><span class="line"> value.a = 0x1234;</span><br><span class="line"> //a和ch共用4字节的内存空间</span><br><span class="line"> if (value.ch == 0x12)</span><br><span class="line"> cout &lt;&lt; &quot;big endian&quot;&lt;&lt;endl;</span><br><span class="line"> else if (value.ch == 0x34)</span><br><span class="line"> cout &lt;&lt; &quot;little endian&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="volatile、mutable和explicit关键字"><a href="#volatile、mutable和explicit关键字" class="headerlink" title="volatile、mutable和explicit关键字"></a>volatile、mutable和explicit关键字</h1><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如： 操作系统、硬件或者其它线程等。</p>
<p>遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行 优化，从而可以提供对特殊地址的稳定访问。 当要求使用 volatile 声明的变量的值的时候，<strong>系统总是重新从它所在的内存读取数据</strong>，即使它前面的指 令刚刚从该处读取过数据。</p>
<p> <strong>volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读 寄存器内的备份。多线程中被几个任务共享的变量需要定义为volatile类型。</strong></p>
<p>有些变量是用volatile关键字声明的。当两个线程都要用到某一个变量且该变量的值会被改变时，应该用 volatile声明，该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中。如果变量被装入寄存 器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执 行。volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器 中的值。</p>
<h2 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h2><p>mutable的中文意思是“可变的，易变的”，跟constant（既C++中的const）是反义词。在C++中，mutable 也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const 函数中。我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。 但是，有些时候，我们<strong>需要在const函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被 mutable来修饰，并且放在函数后后面关键字位置。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">int m_A;</span><br><span class="line">mutable int m_B;//特殊变量 在常函数里值也可以被修改</span><br><span class="line">public:</span><br><span class="line"> void add() const//在函数里不可修改this指针指向的值 常量指针</span><br><span class="line"> &#123;</span><br><span class="line"> m_A=10;//错误 不可修改值，this已经被修饰为常量指针</span><br><span class="line"> m_B=20;//正确</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">int m_A;</span><br><span class="line">mutable int m_B;//特殊变量 在常函数里值也可以被修改</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">const person p;//修饰常对象 不可修改类成员的值</span><br><span class="line">p.m_A=10;//错误，被修饰了指针常量</span><br><span class="line">p.m_B=200;//正确，特殊变量，修饰了mutable</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><p>explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以 显示的方式进行类型转换，注意以下几点： </p>
<ul>
<li>explicit 关键字只能用于类内部的构造函数声明上 </li>
<li>explicit 关键字作用于单个参数的构造函数 </li>
<li>被explicit修饰的构造函数的类，不能发生相应的隐式类型转换</li>
</ul>
<h1 id="C-的异常处理"><a href="#C-的异常处理" class="headerlink" title="C++的异常处理"></a>C++的异常处理</h1><h2 id="try、throw和catch关键字"><a href="#try、throw和catch关键字" class="headerlink" title="try、throw和catch关键字"></a>try、throw和catch关键字</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> double m = 1, n = 0;</span><br><span class="line"> try &#123;</span><br><span class="line"> cout &lt;&lt; &quot;before dividing.&quot; &lt;&lt; endl;</span><br><span class="line"> if (n == 0)</span><br><span class="line"> throw - 1; //抛出int型异常</span><br><span class="line"> else if (m == 0)</span><br><span class="line"> throw - 1.0; //拋出 double 型异常</span><br><span class="line"> else</span><br><span class="line"> cout &lt;&lt; m / n &lt;&lt; endl;</span><br><span class="line"> cout &lt;&lt; &quot;after dividing.&quot; &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> catch (double d) &#123;</span><br><span class="line"> cout &lt;&lt; &quot;catch (double)&quot; &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> catch (...) &#123;</span><br><span class="line"> cout &lt;&lt; &quot;catch (...)&quot; &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> cout &lt;&lt; &quot;finished&quot; &lt;&lt; endl;</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br><span class="line">//运行结果</span><br><span class="line">//before dividing.</span><br><span class="line"></span><br><span class="line">//catch (...)</span><br><span class="line">//finished</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码中，对两个数进行除法计算，其中除数为0。可以看到以上三个关键字，程序的执行流程是先执行try包裹的语句块，如果执行过程中没有异常发生，则不会进入任何catch包裹的语句块，如果发生异常，则使用throw进行异常抛出，再由catch进行捕获，throw可以抛出各种数据类型的信息，代码中使用的是数字，也可以自定义异常class。<strong>catch根据throw抛出的数据类型进行精确捕获（不会出现类型转换），如果匹配不到就直接报错，可以使用catch(…)的方式捕获任何异常（不推荐）</strong>。当然，如果catch了异常，当前函数如果不进行处理，或者已经处理了想通知上一层的调用者，可以在catch里面再throw异常。</p>
<h2 id="函数的异常声明列表"><a href="#函数的异常声明列表" class="headerlink" title="函数的异常声明列表"></a>函数的异常声明列表</h2><p>有时候，程序员在定义函数的时候知道函数可能发生的异常，可以在函数声明和定义时，指出所能抛出异常的列表，写法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fun() throw(int,double,A,B,C)&#123;...&#125;;</span><br></pre></td></tr></table></figure>

<p>这种写法表名函数可能会抛出int,double型或者A、B、C三种类型的异常，如果throw中为空，表明不会抛出任何异常，如果没有throw则可能抛出任何异常</p>
<h2 id="C-标准异常类-exception"><a href="#C-标准异常类-exception" class="headerlink" title="C++标准异常类 exception"></a>C++标准异常类 exception</h2><p>C++ 标准库中有一些类代表异常，这些类都是从 exception 类派生而来的</p>
<p>bad_typeid：使用typeid运算符，如果其操作数是一个多态类的指针，而该指针的值为 NULL，则会拋出此异常，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;typeinfo&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line"> virtual ~A();</span><br><span class="line">&#125;;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line"> A* a = NULL;</span><br><span class="line"> try &#123;</span><br><span class="line"> cout &lt;&lt; typeid(*a).name() &lt;&lt; endl; // Error condition</span><br><span class="line"> &#125;</span><br><span class="line"> catch (bad_typeid)&#123;</span><br><span class="line"> cout &lt;&lt; &quot;Object is NULL&quot; &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br><span class="line">//运行结果：bject is NULL</span><br></pre></td></tr></table></figure>

<ul>
<li>bad_cast：在用 dynamic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的，则会拋出此异常 </li>
<li>bad_alloc：在用 new 运算符进行动态内存分配时，如果没有足够的内存，则会引发此异常 </li>
<li>out_of_range:用 vector 或 string的at 成员函数根据下标访问元素时，如果下标越界，则会拋出此异常</li>
</ul>
<h1 id="静态变量什么时候初始化"><a href="#静态变量什么时候初始化" class="headerlink" title="静态变量什么时候初始化"></a>静态变量什么时候初始化</h1><ol>
<li>初始化只有一次，但是可以多次赋值，在主程序之前，编译器已经为其分配好了内存。</li>
<li>静态局部变量和全局变量一样，数据都存放在全局区域，所以在主程序之前，编译器已经为其分配<br>好了内存，但在C和C++中静态局部变量的初始化节点又有点不太一样。在C中，初始化发生在代码执行<br>之前，编译阶段分配好内存之后，就会进行初始化，所以我们看到在C语言中<strong>无法使用变量对静态局部</strong><br><strong>变量进行初始化</strong>，在程序运行结束，变量所处的全局内存会被全部回收。</li>
<li>而在C++中，初始化时在执行相关代码时才会进行初始化，主要是由于C++引入对象后，要进行初始<br>化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的<br>特定操作，并非简单地分配内存。所以C++标准定为全局或静态对象是有首次用到时才会进行构造，并<br>通过atexit()来管理。在程序结束，按照构造顺序反方向进行逐个析构。所以在C++中是可以使用变量对<br>静态局部变量进行初始化的。</li>
</ol>
<h1 id="i-和-i的左右值判断"><a href="#i-和-i的左右值判断" class="headerlink" title="i++和++i的左右值判断"></a>i++和++i的左右值判断</h1><p>左值就是出现在表达式左边的值（等号左边），可以被改变，他是存储数据值的那块内存的地址，也称为变量的地址；</p>
<p>右值是指存储在某内存地址中的数据，也称为变量的数据。</p>
<p>左值可以作为右值，但右值不可以是左值。</p>
<p>因此也只有<strong>左值才能被取地址</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line"></span><br><span class="line">(i++)+=i; //错误</span><br><span class="line"></span><br><span class="line">(++i)+=i; //正确 </span><br><span class="line"></span><br><span class="line">int *ip = &amp;(i++); //错误</span><br><span class="line"></span><br><span class="line">int *ip = &amp;(++i); //正确</span><br></pre></td></tr></table></figure>

<p><strong>为什么i++不能作左值</strong></p>
<p>简单得到理解，就是i++返回的是一个临时变量，函数返回后不能被寻址得到，它只是一个数据值，而非地址，因此不能作为左值</p>
<h1 id="关于二维数组例题"><a href="#关于二维数组例题" class="headerlink" title="关于二维数组例题"></a>关于二维数组例题</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int arr[][3] = &#123; &#123;1, 2, 3&#125;, &#123;4, 5, 6&#125; &#125;;</span><br><span class="line">    int (*ptr)[3] = arr;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%d %d \n&quot;, (*ptr)[0], (*ptr)[1]);</span><br><span class="line">    ptr++;</span><br><span class="line">    printf(&quot;%d %d \n&quot;, (*ptr)[0], (*ptr)[1]);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 </span><br><span class="line">4 5 </span><br></pre></td></tr></table></figure>

<p>请注意，<code>int (*ptr)[3] = arr;</code> 定义了一个指向包含3个整数元素的数组的指针，初始指向二维数组的第一行。通过 <code>(*ptr)[0]</code> 和 <code>(*ptr)[1]</code> 的方式访问了指针所指向的数组的元素。在 <code>ptr++</code> 后，指针指向了二维数组的第二行，再次访问元素时，输出了第二行的前两个元素。</p>
<p><code>int (*ptr)[3] = arr;</code> 定义了一个指向包含3个整数元素的数组的指针，初始化指向二维数组的第一行。</p>
<p>在 C&#x2F;C++ 中，数组名表示数组首元素的地址，而指针的加法运算实际上是将指针指向的地址加上一个偏移量，然后返回一个新的指针。因此，<code>ptr++</code> 将会使指针指向下一行的首元素。</p>
<p>具体地说，在这个例子中，<code>ptr</code> 指向的是 <code>arr</code> 的第一行，类型为 <code>int (*)[3]</code>，指向一个包含3个整数元素的数组，即 <code>arr[0]</code>。执行 <code>ptr++</code> 后，<code>ptr</code> 指向了 <code>arr</code> 的第二行，即指向 <code>arr[1]</code>。</p>
<p>因此，第二次输出中，<code>(*ptr)[0]</code> 和 <code>(*ptr)[1]</code> 分别对应了 <code>arr[1][0]</code> 和 <code>arr[1][1]</code> 两个元素的值。</p>
<h1 id="从汇编层去解释一下引用"><a href="#从汇编层去解释一下引用" class="headerlink" title="从汇编层去解释一下引用"></a>从汇编层去解释一下引用</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">9: int x = 1;</span><br><span class="line">00401048 mov dword ptr [ebp-4],1</span><br><span class="line">10: int &amp;b = x;</span><br><span class="line">0040104F lea eax,[ebp-4]</span><br><span class="line">00401052 mov dword ptr [ebp-8],eax</span><br></pre></td></tr></table></figure>

<p>x的地址为ebp-4，b的地址为ebp-8，因为栈内的变量内存是从高往低进行分配的，所以b的地址比x的 低。 </p>
<p>lea eax,[ebp-4] 这条语句将x的地址ebp-4放入eax寄存器 </p>
<p>mov dword ptr [ebp-8],eax 这条语句将eax的值放入b的地址 </p>
<p>ebp-8中上面两条汇编的作用即：将x的地址存入变量b中，这不和将某个变量的地址存入指针变量是一样 的吗？<strong>所以从汇编层次来看，的确引用是通过指针来实现的</strong>。</p>
<h1 id="malloc、realloc、calloc的区别"><a href="#malloc、realloc、calloc的区别" class="headerlink" title="malloc、realloc、calloc的区别"></a>malloc、realloc、calloc的区别</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1) malloc函数</span><br><span class="line">void* malloc(unsigned int num_size);</span><br><span class="line">int *p = malloc(20*sizeof(int));申请20个int类型的空间；</span><br><span class="line">2) calloc函数</span><br><span class="line">省去了人为空间计算；malloc申请的空间的值是随机初始化的，calloc申请的空间的值是初始化为0的；</span><br><span class="line">void* calloc(size_t n,size_t size);</span><br><span class="line">int *p = calloc(20, sizeof(int));</span><br><span class="line">3) realloc函数</span><br><span class="line">void realloc(void *p, size_t new_size);</span><br><span class="line">给动态分配的空间分配额外的空间，用于扩充容量。</span><br></pre></td></tr></table></figure>

<h1 id="构造函数的执行顺序"><a href="#构造函数的执行顺序" class="headerlink" title="构造函数的执行顺序"></a>构造函数的执行顺序</h1><p>一个派生类构造函数的执行顺序如下：<br>① 虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）。<br>② 基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）。<br>③ 类类型的成员对象的构造函数（按照初始化顺序）<br>④ 派生类自己的构造函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    A() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;A&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B : public A &#123;</span><br><span class="line">public:</span><br><span class="line">    B() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;B&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class C : public A &#123;</span><br><span class="line">    B b;</span><br><span class="line">public:</span><br><span class="line">    C() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;C&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    C *obj=new C();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="什么是内存泄露，如何检测与避免"><a href="#什么是内存泄露，如何检测与避免" class="headerlink" title="什么是内存泄露，如何检测与避免"></a>什么是内存泄露，如何检测与避免</h1><p>内存泄露<br>一般我们常说的内存泄漏是指堆内存的泄漏。堆内存是指程序从堆中分配的，大小任意的(内存块的大<br>小可以在程序运行期决定)内存块，使用完后必须显式释放的内存。应用程序般使用malloc,、realloc、<br>new等函数从堆中分配到块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否<br>则，这块内存就不能被再次使用，我们就说这块内存泄漏了</p>
<p>避免内存泄露的几种方式</p>
<ul>
<li>计数法：使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄露</li>
<li>一定要将基类的析构函数声明为虚函数</li>
<li>对象数组的释放一定要用delete []</li>
<li>有new就有delete，有malloc就有free，保证它们一定成对出现</li>
</ul>
<p>检测工具</p>
<ul>
<li>Linux下可以使用Valgrind工具</li>
<li>Windows下可以使用CRT库</li>
</ul>
<h1 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h1><p>零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。</p>
<p>零拷贝技术可以减少数据拷贝和共享总线操作的次数。</p>
<p>在C++中，vector的一个成员函数emplace_back()很好地体现了零拷贝技术，它跟push_back()函数一样可以将一个元素插入容器尾部，区别在于：使用push_back()函数需要调用拷贝构造函数和转移构造函数，而使用emplace_back()插入的元素原地构造，不需要触发拷贝构造和转移构造，效率更高。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct Person</span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    int age;</span><br><span class="line">    // 初始构造函数</span><br><span class="line">    Person(string p_name, int p_age) : name(std::move(p_name)), age(p_age)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;I have been constructed&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    // 拷贝构造函数</span><br><span class="line">    Person(const Person &amp;other) : name(std::move(other.name)), age(other.age)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;I have been copy constructed&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    // 转移构造函数，</span><br><span class="line">    //移动构造函数（Move Constructor）用于将资源从一个对象转移到另一个对象，这通常用于提高性能，避免不必要的拷贝操作</span><br><span class="line">    //当编译器检测到可以使用移动构造函数时，它会优先选择移动构造函数而不是拷贝构造函数，以提高性能</span><br><span class="line">    //&amp;&amp; 是右值引用运算符的语法，表示一个右值引用类型</span><br><span class="line">    Person(Person &amp;&amp;other) : name(std::move(other.name)), age(other.age)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;I have been moved&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;Person&gt; e;</span><br><span class="line">    cout &lt;&lt; &quot;emplace_back:&quot; &lt;&lt; endl;</span><br><span class="line">    e.emplace_back(&quot;Jane&quot;, 23); // 不用构造类对象</span><br><span class="line">    vector&lt;Person&gt; p;</span><br><span class="line">    cout &lt;&lt; &quot;push_back:&quot; &lt;&lt; endl;</span><br><span class="line">    p.push_back(Person(&quot;Mike&quot;, 36));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">emplace_back:</span><br><span class="line">I have been constructed   </span><br><span class="line">push_back:</span><br><span class="line">I have been constructed   </span><br><span class="line">I have been moved</span><br></pre></td></tr></table></figure>

<h1 id="成员初始化列表的概念，为什么用它会快一些"><a href="#成员初始化列表的概念，为什么用它会快一些" class="headerlink" title="成员初始化列表的概念，为什么用它会快一些"></a>成员初始化列表的概念，为什么用它会快一些</h1><p>在类的构造函数中，不在函数体内对成员变量赋值，而是在构造函数的花括号前面使用冒号和初始化列 表赋值</p>
<p>用初始化列表会快一些的原因是，对于类型，它少了一次调用构造函数的过程，而在函数体中赋值则会 多一次调用。而对于内置数据类型则没有差别。举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    A()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;默认构造函数A()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    A(int a)</span><br><span class="line">    &#123;</span><br><span class="line">        value = a;</span><br><span class="line">        cout &lt;&lt; &quot;A(int &quot; &lt;&lt; value &lt;&lt; &quot;)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    A(const A &amp;a)</span><br><span class="line">    &#123;</span><br><span class="line">        value = a.value;</span><br><span class="line">        cout &lt;&lt; &quot;拷贝构造函数A(A&amp; a): &quot; &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    int value;</span><br><span class="line">&#125;;</span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    B() : a(1)</span><br><span class="line">    &#123;</span><br><span class="line">        b = A(2);</span><br><span class="line">    &#125;</span><br><span class="line">    A a;</span><br><span class="line">    A b;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    B b;</span><br><span class="line">&#125;</span><br><span class="line">// 输出结果：</span><br><span class="line">// A(int 1)</span><br><span class="line">// 默认构造函数A()</span><br><span class="line">// A(int 2)</span><br></pre></td></tr></table></figure>

<p>从代码运行结果可以看出，在构造函数体内部初始化的对象b多了一次构造函数的调用过程，而对象a则 没有。由于对象成员变量的初始化动作发生在进入构造函数之前，对于内置类型没什么影响，但如果有 些成员是类，那么在进入构造函数之前，会先调用一次默认构造函数，进入构造函数后所做的事其实是 一次赋值操作(对象已存在)，<strong>所以如果是在构造函数体内进行赋值的话，等于是一次默认构造加一次赋 值，而初始化列表只做一次赋值操作。</strong></p>
<h1 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h1><p>有类型检查，基类向派生类转换比较安全，但是派生类向基类转换则不太安全</p>
<p><code>dynamic_cast</code> 是 C++ 中用于运行时类型识别的一种操作符。它可以将一个指向基类的指针或引用转换为指向派生类的指针或引用，也可以将一个指向派生类的指针或引用转换为指向基类的指针或引用。<code>dynamic_cast</code> 能够在类型转换过程中进行安全检查，以确保类型转换的正确性。</p>
<p>在将基类指针或引用转换为派生类指针或引用时，<code>dynamic_cast</code> 可以在编译时检查类型信息，并确保类型转换的正确性。如果类型转换不正确，<code>dynamic_cast</code> 将返回一个空指针或引用。因此，这种类型转换比较安全。</p>
<p>但是，将派生类指针或引用转换为基类指针或引用时，情况就不一样了。由于派生类包含了基类的所有成员和方法，因此派生类指针或引用可以随意地转换为基类指针或引用。但是，在将派生类指针或引用转换为基类指针或引用时，由于派生类可能包含不止一个基类，而且这些基类之间可能有重叠，所以在运行时无法确定要转换的基类指针或引用的确切类型。因此，如果转换的类型与实际类型不匹配，将会出现未定义的行为。</p>
<h1 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h1><p><code>reinterpret_cast (expression)</code></p>
<p> type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以用于类型之间进行强制转 换。</p>
<h1 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h1><p><code>const_cast&lt;type_id&gt; (expression)</code><br>该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型<br>是一样的。用法如下：</p>
<ul>
<li>常量指针被转化成非常量的指针，并且仍然指向原来的对象</li>
<li>常量引用被转换成非常量的引用，并且仍然指向原来的对象</li>
<li>const_cast一般用于修改底指针。如const char *p形式</li>
</ul>
<h1 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h1><p>static_cast &lt; type-id &gt; (expression)<br>该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几<br>种用法：</p>
<ul>
<li>用于类层次结构中基类（父类）和派生类（子类）之间指针或引用引用的转换<ul>
<li>进行上行转换（把派生类的指针或引用转换成基类表示）是安全的</li>
<li>进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的</li>
</ul>
</li>
<li>用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。</li>
<li>把空指针转换成目标类型的空指针</li>
<li>把任何类型的表达式转换成void类型</li>
</ul>
<p>注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3/" class="post-title-link" itemprop="url">数据结构-3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-06 21:18:06" itemprop="dateCreated datePublished" datetime="2023-09-06T21:18:06+08:00">2023-09-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-14 21:41:05" itemprop="dateModified" datetime="2023-09-14T21:41:05+08:00">2023-09-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="服务器A和B交换资源"><a href="#服务器A和B交换资源" class="headerlink" title="服务器A和B交换资源"></a>服务器A和B交换资源</h1><p>输入两行，每个数字之间用空格隔开，代表服务器A和B下节点的资源数，某个资源交换之后A和B的资源数相等，输出交换后的资源</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;numeric&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    string line;</span><br><span class="line">    </span><br><span class="line">    // 读取输入行</span><br><span class="line">    getline(cin, line);</span><br><span class="line"></span><br><span class="line">    // 创建字符串流</span><br><span class="line">    stringstream ss(line);//std::string delimiter = &quot;,&quot;;  // 自定义分隔符</span><br><span class="line">    					  //std::getline(ss, token, delimiter[0]);</span><br><span class="line">    int num,sumA,sumB;</span><br><span class="line">    vector&lt;int&gt; resourcesA;</span><br><span class="line"></span><br><span class="line">    // 解析服务器A节点的资源数</span><br><span class="line">    while (ss &gt;&gt; num) &#123;</span><br><span class="line">        resourcesA.push_back(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 读取下一行输入</span><br><span class="line">    getline(cin, line);</span><br><span class="line">    stringstream ss2(line);//使用 std::stringstream 对象进行输入操作时，默认情况下，空格是被认为是分隔符的，即会被用来划分不同的变量值</span><br><span class="line">    vector&lt;int&gt; resourcesB;</span><br><span class="line"></span><br><span class="line">    // 解析服务器B节点的资源数</span><br><span class="line">    while (ss2 &gt;&gt; num) &#123;</span><br><span class="line">        //由于空格是默认的分隔符，因此 ss &gt;&gt; num 操作符会自动跳过空格，直到遇到一个整数，</span><br><span class="line">        //在这种情况下，它会将整数提取出来，并将其存储到 num 变量中。然后，我们将 num 添加到向量 vec 中</span><br><span class="line">        resourcesB.push_back(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在此处添加你的交换逻辑和计算等操作</span><br><span class="line">    for (int i = 0; i &lt; resourcesA.size(); ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; resourcesB.size(); ++j) &#123;</span><br><span class="line">            swap(resourcesA[i],resourcesB[j]);</span><br><span class="line">            sumA=accumulate(resourcesA.begin(), resourcesA.end(),0);</span><br><span class="line">            sumB=accumulate(resourcesB.begin(), resourcesB.end(),0);</span><br><span class="line">            if(sumA == sumB)</span><br><span class="line">                break;</span><br><span class="line">            swap(resourcesA[i],resourcesB[j]);</span><br><span class="line">         &#125;</span><br><span class="line">         if (sumA == sumB) &#123;</span><br><span class="line">            break;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    // 输出结果</span><br><span class="line">    for (int i = 0; i &lt; resourcesA.size(); ++i) &#123;</span><br><span class="line">        cout &lt;&lt; resourcesA[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; resourcesB.size(); ++i) &#123;</span><br><span class="line">        cout &lt;&lt; resourcesB[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3/image-20230906222153192.png" alt="image-20230906222153192"></p>
<img src="/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3/image-20230906222153192.png" class title="This is an test image">

<p><code>std::getline</code> 函数的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cppCopy Codetemplate&lt; class CharT, class Traits, class Allocator &gt;</span><br><span class="line">std::basic_istream&lt;CharT,Traits&gt;&amp; getline( std::basic_istream&lt;CharT,Traits&gt;&amp; input,</span><br><span class="line">                                           std::basic_string&lt;CharT,Traits,Allocator&gt;&amp; str,</span><br><span class="line">                                           CharT delim );</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>input</code>：输入流对象，如 <code>std::cin</code>。</li>
<li><code>str</code>：用于存储读取的字符串的变量。</li>
<li><code>delim</code>：可选参数，指定行结束的分隔符，默认为换行符 <code>\n</code>。你可以传递其他字符作为分隔符，例如 <code>&#39;,&#39;</code> 或 <code>&#39; &#39;</code>。</li>
</ul>
<p>注意事项：</p>
<ul>
<li>如果读取到的行为空（即只有换行符），则 <code>std::getline</code> 将不会向 <code>str</code> 中存储任何内容。</li>
<li><code>std::getline</code> 函数会读取到分隔符为止，但不会将其存储在 <code>str</code> 中。</li>
</ul>
<h1 id="回文最少分割"><a href="#回文最少分割" class="headerlink" title="回文最少分割"></a>回文最少分割</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    string str;</span><br><span class="line">    while(cin&gt;&gt;str)&#123;</span><br><span class="line">        int len = str.size();</span><br><span class="line">        int isRound[len][len];//记录第i个字符与第j个字符之间的字符是否是回文串</span><br><span class="line">        memset(isRound,0,sizeof(isRound));</span><br><span class="line">        int dp[len+1];//记录从第0个字符开始到当前字符最少的分割数</span><br><span class="line">        dp[-1] = -1;//动态规划中处理边界情况而设置的一个初始值</span><br><span class="line">        for(int i = 0;i&lt;len;i++)&#123;</span><br><span class="line">            dp[i] = i;//dp[i]表示以第i个字符结尾的子字符串（包括第i个字符）中的最少回文子序列个数</span><br><span class="line">            for(int j = i;j&gt;=0;j--)&#123;</span><br><span class="line">            	//(i-j&lt;2)表示子串的长度小于2时，无需进一步判断，直接视为回文子串</span><br><span class="line">            	//isRound[j+1][i-1]表示去掉首尾字符后的子串是否为回文子串。</span><br><span class="line">                if(str[i]==str[j]&amp;&amp;(i-j&lt;2||isRound[j+1][i-1]))&#123;</span><br><span class="line">                    isRound[j][i] = 1;</span><br><span class="line">                    dp[i] = (dp[i]&lt;dp[j-1]+1?dp[i]:dp[j-1]+1);</span><br><span class="line">                &#125;	</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;dp[len-1]&lt;&lt;endl;//即整个字符串的最少回文子序列个数</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双重循环用于填充<code>isRound</code>数组和更新<code>dp</code>数组。在每次迭代中，我们遍历从第<code>i</code>个字符到第<code>j</code>个字符的所有可能子串。如果当前子串是一个回文子串（满足条件<code>str[i]==str[j]</code>且长度小于等于2或者更小的子串也是回文子串），则将<code>isRound[j][i]</code>标记为1，并更新<code>dp[i]</code>为<code>dp[j-1]+1</code>或<code>dp[i]</code>中的较小值</p>
<p>具体思路如下：</p>
<p>首先，定义 <code>dp[i]</code> 表示以第 i 个字符结尾的子字符串（包括第 i 个字符）中的最少回文子序列个数。因此，最终我们需要求解整个字符串的最小回文子序列个数，即 <code>dp[len-1]</code>。</p>
<p>接下来考虑如何推导出 <code>dp[i]</code> 的值。我们可以从前往后遍历字符串，对于每个 <code>i</code>，再从 <code>i</code> 往前遍历所有的可能的起点 <code>j</code>，检查子串 <code>str[j..i]</code> 是否为回文子串。如果是回文子串，则通过状态转移方程 <code>dp[i] = min(dp[i], dp[j-1]+1)</code> 更新 <code>dp[i]</code>。</p>
<p>其中，如果 <code>str[j..i]</code> 的长度小于等于 1，则直接视为回文子串。否则，需要检查其中间部分是否也是回文子串。可以通过使用一个二维数组 <code>isRound</code> 记录每个子串中的字符是否构成回文子串来实现。</p>
<p>最后，将整个字符串的最小回文子序列个数输出即可。</p>
<p>状态转移方程 <code>dp[i] = min(dp[i], dp[j-1]+1)</code> 是这个动态规划算法的核心。</p>
<p>其中 <code>dp[i]</code> 表示以第 i 个字符结尾的子字符串（包括第 i 个字符）中的最少回文子序列个数。因此，我们需要通过 <code>dp[j-1]</code> 求出以下两个值中的较小值：</p>
<ul>
<li>从第 0 个字符开始到第 j-1 个字符为止的子字符串中的最少回文子序列个数。即 <code>dp[j-1]</code>。这里要求子串中必须包含第 j-1 个字符。</li>
<li>如果子串 <code>str[j..i]</code> 本身就是回文子串，则不需要再分割，此时包含 i 个字符的子字符串的最少回文子序列个数为 1。因此，我们可以将当前子串视为由 j-1 号字符后面新分割出来的一个回文子序列，所需的分割次数为 1。</li>
</ul>
<p>计算出这两个值之后，将它们加上 1（表示将 j-1 后面的子串作为一个新回文子序列），即可得到在子串 <code>str[j..i]</code> 内部新分割出一个回文子序列所需的最少分割次数。我们需要比较这个最少分割次数与当前 <code>dp[i]</code> 的值，取较小者更新 <code>dp[i]</code>。这样就能够更新到整个字符串所需最少的分割次数了</p>
<hr>
<p>这个算法是一个动态规划算法，主要原因是它满足动态规划的两个关键特征：</p>
<ul>
<li>最优子结构性质</li>
</ul>
<p>最优子结构是指一个问题的最优解包含了其子问题的最优解。在本问题中，对于任意以第 i 个字符结尾的子字符串，它的最少回文子序列个数可以由它的前面的子串（即以小于 i 的下标结尾的子串）的最少回文子序列个数推导得出，因此满足最优子结构性质。</p>
<ul>
<li>重叠子问题性质</li>
</ul>
<p>重叠子问题性质是指在解决一个问题时需要多次求解重复的子问题。在本问题中，计算一个以第 i 个字符结尾的子字符串中的最少回文子序列个数需要用到它所有的前缀子串中的每一个最少回文子序列个数，而这些前缀子串是有重叠的部分的，因此满足重叠子问题性质。</p>
<p>基于以上两个特征，我们可以使用动态规划算法来解决本问题，具体实现过程就是：通过递推式计算出每个状态（即 <code>dp</code> 数组中的每个元素），并保存中间结果，避免重复计算同一个子问题。</p>
<h1 id="LRU缓存"><a href="#LRU缓存" class="headerlink" title="LRU缓存"></a>LRU缓存</h1><p>LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。</p>
<ul>
<li><p>双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最久未使用的，而靠近尾部的键值对是最近使用的。</p>
</li>
<li><p>哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。</p>
</li>
</ul>
<p>这样以来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 O(1)O(1)O(1) 的时间内完成 get 或者 put 操作。具体的方法如下：</p>
<ul>
<li><p>对于 get 操作，首先判断 key 是否存在：</p>
<ul>
<li><p>如果 key 不存在，则返回 −1-1−1；</p>
</li>
<li><p>如果 key 存在，则 key 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的尾部，最后返回该节点的值。</p>
</li>
</ul>
</li>
<li><p>对于set 操作，首先判断 key 是否存在：</p>
<ul>
<li><p>如果 key 不存在，使用 key 和 value 创建一个新的节点，在双向链表的尾部添加该节点，并将 key 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的头部节点（即伪头部下一个），并删除哈希表中对应的项；</p>
</li>
<li><p>如果 key 存在，则与 get 操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的尾部。</p>
</li>
</ul>
</li>
</ul>
<p>上述各项操作中，访问哈希表的时间复杂度为 O(1)O(1)O(1)，在双向链表的尾部添加节点、在双向链表的头部删除节点的复杂度也为 O(1)O(1)O(1)。而将一个节点移到双向链表的头部，可以分成「删除该节点」和「在双向链表的头部添加节点」两步操作，都可以在 O(1)O(1)O(1) 时间内完成。</p>
<p>复杂度分析</p>
<ul>
<li><p>时间复杂度：对于 put 和 get 都是 O(1)O(1)O(1)。</p>
</li>
<li><p>空间复杂度：<em>O</em>(capacity)，因为哈希表和双向链表最多存储 capacity+1 个元素</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">struct DoubleList</span><br><span class="line">&#123;</span><br><span class="line">    int key, val;</span><br><span class="line">    DoubleList *pre, *next;</span><br><span class="line">    DoubleList(int _key, int _val) : key(_key), val(_val), pre(nullptr), next(nullptr) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class LRU</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int capacity;</span><br><span class="line">    DoubleList *head, *tail;</span><br><span class="line">    unordered_map&lt;int, DoubleList *&gt; memory;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    LRU(int _capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;capacity = _capacity;</span><br><span class="line">        head = new DoubleList(-1, -1);</span><br><span class="line">        tail = new DoubleList(-1, -1);</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;pre = head;</span><br><span class="line">    &#125;</span><br><span class="line">    ~LRU()</span><br><span class="line">    &#123;</span><br><span class="line">        if (head != nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            delete head;</span><br><span class="line">            head = nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        if (tail != nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            delete tail;</span><br><span class="line">            tail = nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        for (auto &amp;a : memory)</span><br><span class="line">        &#123;</span><br><span class="line">            if (a.second != nullptr)</span><br><span class="line">            &#123;</span><br><span class="line">            	//在使用 unordered_map 存储指针作为值时，需要小心管理内存分配和释放，以避免内存泄漏</span><br><span class="line">                delete a.second;</span><br><span class="line">                a.second = nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void set(int _key, int _val)</span><br><span class="line">    &#123;</span><br><span class="line">        if (memory.find(_key) != memory.end())</span><br><span class="line">        &#123;</span><br><span class="line">            DoubleList *node = memory[_key];</span><br><span class="line">            removeNode(node);</span><br><span class="line">            node-&gt;val = _val;</span><br><span class="line">            pushNode(node);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (memory.size() == this-&gt;capacity)</span><br><span class="line">        &#123;                                 // 这里很重要，也很爱错，千万记得更新memory</span><br><span class="line">            int topKey = head-&gt;next-&gt;key; // 取得key值，方便在后面删除</span><br><span class="line">            removeNode(head-&gt;next);       // 移除头部的下一个</span><br><span class="line">            memory.erase(topKey);         // 在memory中删除当前头部的值</span><br><span class="line">        &#125;</span><br><span class="line">        DoubleList *node = new DoubleList(_key, _val); // 新增node</span><br><span class="line">        pushNode(node);                                // 放在尾部</span><br><span class="line">        memory[_key] = node;                           // 记得在memory中添加进去</span><br><span class="line">    &#125;</span><br><span class="line">    int get(int _key)</span><br><span class="line">    &#123;</span><br><span class="line">        if (memory.find(_key) != memory.end())</span><br><span class="line">        &#123;</span><br><span class="line">            DoubleList *node = memory[_key];</span><br><span class="line">            removeNode(node);</span><br><span class="line">            pushNode(node);</span><br><span class="line">            return node-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    void removeNode(DoubleList *node)</span><br><span class="line">    &#123;</span><br><span class="line">        node-&gt;pre-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;pre = node-&gt;pre;</span><br><span class="line">    &#125;</span><br><span class="line">    void pushNode(DoubleList *node)</span><br><span class="line">    &#123;</span><br><span class="line">        tail-&gt;pre-&gt;next = node;</span><br><span class="line">        node-&gt;pre = tail-&gt;pre;</span><br><span class="line">        node-&gt;next = tail;</span><br><span class="line">        tail-&gt;pre = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>unordered_map</code> 是 C++ 标准库提供的关联容器之一，它存储了键-值对，并支持通过键来快速访问值。在这个示例中，<code>cache</code> 中存储了 <code>int</code> 类型的键和指向 <code>DLinkedNode</code> 对象的指针作为值。</p>
<p>你可以使用 <code>cache</code> 对象执行以下操作：</p>
<p>插入键值对：可以使用 <code>cache[key] = value</code> 的方式插入新的键值对，其中 <code>key</code> 是要插入的键，<code>value</code> 是要插入的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cache[1] = new DLinkedNode();</span><br></pre></td></tr></table></figure>

<p>访问值：可以使用 <code>cache[key]</code> 的方式访问特定键对应的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DLinkedNode* node = cache[1];</span><br></pre></td></tr></table></figure>

<p>检查键是否存在：可以使用 <code>count()</code> 或 <code>find()</code> 方法来检查特定键是否存在于 <code>cache</code> 中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (cache.count(1) &gt; 0) &#123;</span><br><span class="line">    // 键存在</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或者使用 find()</span><br><span class="line">if (cache.find(1) != cache.end()) &#123;</span><br><span class="line">    // 键存在</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>unordered_map</code> 和 <code>map</code> 是 C++ 中的两种关联容器，它们在实现和性能上有一些区别：</p>
<ol>
<li>有序性：<code>unordered_map</code> 是基于哈希表实现的，所以它不维护元素的顺序，也不支持按键排序。而 <code>map</code> 是基于红黑树实现的，它会根据键的比较排序元素，所以它是有序的。</li>
<li>查找效率：对于 <code>unordered_map</code>，通过哈希函数可以快速定位到元素的位置，平均情况下查找的时间复杂度为 O(1)。而对于 <code>map</code>，由于元素是有序的，查找的时间复杂度为 O(log n)，其中 n 是元素数量。</li>
<li>内存占用：由于需要维护红黑树的结构，<code>map</code> 往往比 <code>unordered_map</code> 占用更多的内存空间。</li>
<li>插入和删除操作：对于 <code>unordered_map</code>，插入和删除操作的时间复杂度也是平均 O(1) 的，而对于 <code>map</code>，由于需要维护有序性，插入和删除操作的时间复杂度为 O(log n)。</li>
</ol>
<p>根据具体的需求，选择使用 <code>unordered_map</code> 还是 <code>map</code>。如果对元素的顺序没有要求，并且关注查找的速度，可以选择 <code>unordered_map</code>。如果需要有序的元素集合，并且关注元素的插入和删除效率，可以选择 <code>map</code>。</p>
<h1 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a>重排链表</h1><p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ， 将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→… 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.</span><br><span class="line">示例 2:</span><br><span class="line">给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct node *next;</span><br><span class="line">    node(int _data) : data(_data),next(nullptr)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void reorderList(node* head) &#123;</span><br><span class="line">        if (head == nullptr) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;node *&gt; vec;</span><br><span class="line">        node *node = head;</span><br><span class="line">        while (node != nullptr) &#123;</span><br><span class="line">            vec.emplace_back(node);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        int i = 0, j = vec.size() - 1;</span><br><span class="line">        while (i &lt; j) &#123;</span><br><span class="line">            vec[i]-&gt;next = vec[j];</span><br><span class="line">            i++;</span><br><span class="line">            if (i == j) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            vec[j]-&gt;next = vec[i];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        vec[i]-&gt;next = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    node *head=new node(-1);</span><br><span class="line">    node *newhead = new node(-1);</span><br><span class="line">    newhead=head;//不能next，这样才能在改变head后从头节点访问</span><br><span class="line">    string str;</span><br><span class="line">    getline(cin,str);</span><br><span class="line">    stringstream ss(str);</span><br><span class="line">    int a;</span><br><span class="line">    while(ss&gt;&gt;a)</span><br><span class="line">    &#123;</span><br><span class="line">        node *node1=new node(a);</span><br><span class="line">        head-&gt;next=node1;</span><br><span class="line">        head=head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Solution *sol=new Solution();</span><br><span class="line">    sol-&gt;reorderList(newhead-&gt;next);</span><br><span class="line">    while (newhead) &#123;</span><br><span class="line">        cout &lt;&lt;newhead-&gt;next-&gt;data &lt;&lt; endl;</span><br><span class="line">        newhead=newhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="三个线程交替打印ABC"><a href="#三个线程交替打印ABC" class="headerlink" title="三个线程交替打印ABC"></a>三个线程交替打印ABC</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;condition_variable&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">mutex mymutex;</span><br><span class="line">condition_variable cv;</span><br><span class="line">int flag = 0;</span><br><span class="line">void printa()</span><br><span class="line">&#123;</span><br><span class="line">    unique_lock&lt;mutex&gt; lk(mymutex);</span><br><span class="line">    int count = 0;</span><br><span class="line">    while (count &lt; 10)</span><br><span class="line">    &#123;</span><br><span class="line">        while (flag != 0)</span><br><span class="line">            cv.wait(lk);</span><br><span class="line">        cout &lt;&lt; &quot;thread 1: a&quot; &lt;&lt; endl;</span><br><span class="line">        flag = 1;</span><br><span class="line">        cv.notify_all();</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;my thread 1 finish&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void printb()</span><br><span class="line">&#123;</span><br><span class="line">    unique_lock&lt;mutex&gt; lk(mymutex);</span><br><span class="line">    for (int i = 0; i &lt; 10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        while (flag != 1)</span><br><span class="line">            cv.wait(lk);</span><br><span class="line">        cout &lt;&lt; &quot;thread 2: b&quot; &lt;&lt; endl;</span><br><span class="line">        flag = 2;</span><br><span class="line">        cv.notify_all();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;my thread 2 finish&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void printc()</span><br><span class="line">&#123;</span><br><span class="line">    unique_lock&lt;mutex&gt; lk(mymutex);</span><br><span class="line">    for (int i = 0; i &lt; 10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        while (flag != 2)</span><br><span class="line">            cv.wait(lk);</span><br><span class="line">        cout &lt;&lt; &quot;thread 3: c&quot; &lt;&lt; endl;</span><br><span class="line">        flag = 0;</span><br><span class="line">        cv.notify_all();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;my thread 3 finish&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	//是一个 C++ 11 中创建线程的语句。该语句创建了一个名为 th2 的线程对象，并将函数 printa 作为线程的入口点</span><br><span class="line">    thread th2(printa);</span><br><span class="line">    thread th1(printb);</span><br><span class="line">    thread th3(printc);</span><br><span class="line">    th1.join();</span><br><span class="line">    th2.join();//是一个 C++11 中的语句，用于等待线程 th2 的执行结束,没有回收线程资源的功能。它只是让当前线程阻塞</span><br><span class="line">    th3.join();</span><br><span class="line">    cout &lt;&lt; &quot; main thread &quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//thread 1: a</span><br><span class="line">//thread 2: b</span><br><span class="line">//thread 3: c</span><br><span class="line">//thread 1: a</span><br><span class="line">//thread 2: b</span><br><span class="line">//thread 3: c</span><br><span class="line">//thread 1: a</span><br><span class="line">//thread 2: b</span><br><span class="line">//thread 3: c</span><br><span class="line">//thread 1: a</span><br><span class="line">//thread 2: b</span><br><span class="line">//thread 3: c</span><br><span class="line">//thread 1: a</span><br><span class="line">//thread 2: b</span><br><span class="line">//thread 3: c</span><br><span class="line">//thread 1: a</span><br><span class="line">//thread 2: b</span><br><span class="line">//thread 3: c</span><br><span class="line">//thread 1: a</span><br><span class="line">//thread 2: b</span><br><span class="line">//thread 3: c</span><br><span class="line">//thread 1: a</span><br><span class="line">//thread 2: b</span><br><span class="line">//thread 3: c</span><br><span class="line">//thread 1: a</span><br><span class="line">//thread 2: b</span><br><span class="line">//thread 3: c</span><br><span class="line">//thread 1: a</span><br><span class="line">//my thread 1 finish</span><br><span class="line">//thread 2: b</span><br><span class="line">//my thread 2 finish</span><br><span class="line">//thread 3: c</span><br><span class="line">//my thread 3 finish</span><br><span class="line">//main thread</span><br></pre></td></tr></table></figure>

<p>C++11 中的 <code>std::thread</code> 类提供了更加面向对象的方式来创建和管理线程，代码更加简洁易读。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;thread&gt;</span><br><span class="line"></span><br><span class="line">std::thread th(tfn, i);</span><br></pre></td></tr></table></figure>

<p>使用 <code>std::thread</code>，你可以直接创建一个线程对象，并指定线程的入口函数和参数。</p>
<p>与 <code>pthread_create</code> 不同，<code>std::thread</code> 在线程对象销毁时会自动处理资源回收，无需手动调用 <code>pthread_join</code> 或 <code>pthread_detach</code>。</p>
<p>总结而言，<code>pthread_create</code> 是 POSIX 线程库中的函数，而 <code>std::thread</code> 是 C++11 中标准库提供的线程类，使用 <code>std::thread</code> 可以更方便地创建和管理线程</p>
<hr>
<p><code>unique_lock&lt;mutex&gt; lk(mymutex);</code> 是一个 C++11 中用于实现互斥锁的语法，它的作用是创建一个 <code>unique_lock</code> 对象并锁定指定的互斥量（即 <code>mymutex</code>）。</p>
<p>在 C++11 中，<code>mutex</code> 是一个标准库类型，用于实现多线程中的互斥锁。对于共享资源的访问，我们需要保证同一时刻只有一个线程能够访问该资源，这就需要用到互斥锁。</p>
<p><code>unique_lock</code> 是 C++11 中对互斥锁进行操作的一个封装类，它提供了比传统的 <code>lock()</code> 和 <code>unlock()</code> 更加丰富的操作，例如自动地加锁和解锁、支持调用 <code>try_lock()</code> 等函数来尝试获取锁等。</p>
<p>具体来说，当我们在创建 <code>unique_lock</code> 对象时，即 <code>unique_lock&lt;mutex&gt; lk(mymutex);</code>，该对象会自动地获取 <code>mymutex</code> 的锁，并阻塞当前线程直到获取成功。当 <code>lk</code> 对象超出作用域时，它会自动释放 <code>mymutex</code> 的锁。</p>
<p>以这种方式使用 <code>unique_lock</code> 可以确保线程安全，并且同时避免了手动加锁和解锁所带来的不必要烦恼和风险。</p>
<p>需要注意的是，在使用 <code>unique_lock</code> 时，我们应该尽量减少持有锁的时间，以避免因为长时间占用互斥锁导致程序性能下降。</p>
<hr>
<p><code>cv.wait(lk)</code> 和 <code>cv.notify_all()</code> 是与条件变量（Condition Variable）相关的操作。</p>
<p>在 C++ 中，条件变量用于线程间的同步和通信。它允许线程等待某个条件成立，并在条件满足时被通知继续执行。</p>
<p><code>cv.wait(lk)</code> 是一个等待操作，它会阻塞当前线程，并释放持有的 <code>unique_lock</code> 对象 <code>lk</code> 所关联的互斥锁（即 <code>mymutex</code>）。线程会被挂起，直到其他线程调用 <code>cv.notify_all()</code> 或 <code>cv.notify_one()</code> 来通知条件变量的唤醒。</p>
<p>一般情况下，使用 <code>cv.wait(lk)</code> 时需要搭配条件判断来确保线程在正确的条件下等待和被唤醒。</p>
<p>当条件满足时，可以通过调用 <code>cv.notify_all()</code> 或 <code>cv.notify_one()</code> 来唤醒等待的线程。</p>
<p><code>cv.notify_all()</code> 会唤醒所有等待条件变量的线程，而 <code>cv.notify_one()</code> 则会随机唤醒一个等待的线程。</p>
<p>这样的组合使用可以实现线程间的同步和通信，避免了不必要的忙等待和资源浪费。</p>
<p>需要注意的是，在调用 <code>cv.wait(lk)</code> 之前，必须通过 <code>unique_lock</code> 对象 <code>lk</code> 持有相应的互斥锁，因为 <code>wait()</code> 函数会在等待之前释放该互斥锁，并在被唤醒时重新获取锁</p>
<h1 id="Top-K-问题"><a href="#Top-K-问题" class="headerlink" title="Top K 问题"></a>Top K 问题</h1><p>Top K 问题是指从一组元素中找出前 K 个最大或最小的元素。有几种解决 Top K 问题的常用方法：</p>
<ol>
<li>排序：对整个数组进行排序，然后取前 K 个元素。时间复杂度为 O(NlogN)，其中 N 是数组的长度。这种方法适用于 K 较小的情况。</li>
<li>堆：使用堆数据结构来解决 Top K 问题。维护一个大小为 K 的最小堆或最大堆，遍历数组中的元素，将元素依次加入堆中，使堆的大小保持在 K。如果当前元素比堆顶元素大（或小），则替换堆顶元素，并重新调整堆。最后，堆中的元素即为前 K 个最大（或最小）的元素。该方法的时间复杂度为 O(NlogK)，其中 N 是数组的长度。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct Node &#123;</span><br><span class="line">     int value;</span><br><span class="line">     int idx;</span><br><span class="line">     Node (int v, int i): value(v), idx(i) &#123;&#125;</span><br><span class="line">     //friend 关键字表示 &lt; 函数是 struct Node 的友元函数，可以访问 struct Node 中的私有成员变量</span><br><span class="line">     friend bool operator &lt; (const struct Node &amp;n1, const struct Node &amp;n2) ; //这里可以没有</span><br><span class="line">&#125;;</span><br><span class="line">//在C++中，默认情况下，priority_queue是一个最大堆（即堆顶元素最大）</span><br><span class="line">//将值较大的元素放在堆顶</span><br><span class="line">inline bool operator &lt; (const struct Node &amp;n1, const struct Node &amp;n2) &#123;</span><br><span class="line"> 	return n1.value &lt; n2.value;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    priority_queue&lt;Node&gt; pq;// 此时pq为最大堆</span><br><span class="line"></span><br><span class="line">    pq.push(Node(3, 0));</span><br><span class="line">    pq.push(Node(5, 1));</span><br><span class="line">    pq.push(Node(2, 2));</span><br><span class="line"></span><br><span class="line">    while (!pq.empty()) &#123;</span><br><span class="line">        Node top = pq.top();</span><br><span class="line">        pq.pop();</span><br><span class="line">        cout &lt;&lt; &quot;Value: &quot; &lt;&lt; top.value &lt;&lt; &quot; Index: &quot; &lt;&lt; top.idx &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>inline bool operator &lt; (const struct Node &amp;n1, const struct Node &amp;n2)</code> 是一个重载小于号 <code>&lt;</code> 运算符的函数。但是，它实际上并没有直接重载优先队列 <code>priority_queue</code> 中 <code>&lt;</code> 运算符，而是重载了节点结构体 <code>Node</code> 中的 <code>&lt;</code> 运算符。由于优先队列 <code>priority_queue</code> 默认使用元素类型的 <code>&lt;</code> 运算符来进行排序，因此，在这种情况下，节点结构体 <code>Node</code> 中的 <code>&lt;</code> 运算符会被用来对节点对象进行排序，从而达到了重载优先队列 <code>priority_queue</code> 的效果。</p>
<p>3.快速选择算法：类似于快速排序的思想，通过划分操作将数组分为两部分，每次选择一个基准元素，将小于基准元素的放在左边，大于基准元素的放在右边。如果基准元素的位置恰好等于 K-1，则基准元素及其左边的元素就是前 K 个最大的元素。如果基准元素的位置小于 K-1，则在基准元素的右边继续进行划分操作。如果基准元素的位置大于 K-1，则在基准元素的左边进行划分操作。该方法的平均时间复杂度为 O(N)，最坏情况下时间复杂度为 O(N^2)。</p>
<p>Quick Select脱胎于快速排序，提出这两个算法的都是同一个人。算法的过程是这样的： 首先选取一个枢轴，然后将数组中小于该枢轴的数放到左边，大于该枢轴的数放到右边。 此时，如果左边的数组中的元素个数大于等于K，则第K大的数肯定在左边数组中，继续对左边数组 执行相同操作； 如果左边的数组元素个数等于K-1，则第K大的数就是pivot； 如果左边的数组元素个数小于K，则第K大的数肯定在右边数组中，对右边数组执行相同操作。 这个算法与快排最大的区别是，<strong>每次划分后只处理左半边或者右半边，而快排在划分后对左右半边都继续排序。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 分区函数，将小于枢轴的数放到左边，大于枢轴的数放到右边</span><br><span class="line">//选择第一个元素作为枢轴，并通过不断交换元素的方式将小于枢轴的数移到左边，大于枢轴的数移到右边，最终将枢轴放到正确的位置上</span><br><span class="line">int partition(vector&lt;int&gt;&amp; nums, int low, int high) &#123;</span><br><span class="line">    int pivot = nums[low]; // 选择第一个元素作为枢轴</span><br><span class="line">    while (low &lt; high) &#123;</span><br><span class="line">        while (low &lt; high &amp;&amp; nums[high] &gt;= pivot) &#123;</span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[low] = nums[high]; // 将较小的值移到左边</span><br><span class="line"></span><br><span class="line">        while (low &lt; high &amp;&amp; nums[low] &lt;= pivot) &#123;</span><br><span class="line">            low++;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[high] = nums[low]; // 将较大的值移到右边</span><br><span class="line">    &#125;</span><br><span class="line">    nums[low] = pivot; // 将枢轴放到最终位置</span><br><span class="line">    return low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int quickSelect(vector&lt;int&gt;&amp; nums, int low, int high, int k) &#123;</span><br><span class="line">	if (left == right) </span><br><span class="line">		return arr[right];</span><br><span class="line">    int pivotIndex = partition(nums, low, high); // 划分数组，随机选择一个枢轴元素，返回枢轴的索引</span><br><span class="line">    if (pivotIndex-low+1 == k ) &#123;</span><br><span class="line">        return nums[pivotIndex]; // 找到第 k 大的元素</span><br><span class="line">    &#125; else if (pivotIndex-low+1 &gt; k) &#123;</span><br><span class="line">        return quickSelect(nums, low, pivotIndex - 1, k); // 在左半边继续查找</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return quickSelect(nums, pivotIndex + 1, high, k-(pivotIndex-low+1)); // 在右半边继续查找</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">    int n = nums.size();</span><br><span class="line">    return quickSelect(nums, 0, n - 1, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;3, 2, 1, 5, 6, 4&#125;;</span><br><span class="line">    int k = 2;</span><br><span class="line">    int result = findKthLargest(nums, k);</span><br><span class="line">    cout &lt;&lt; &quot;第 &quot; &lt;&lt; k &lt;&lt; &quot; 大的元素是：&quot; &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这些方法的选择应取决于具体的场景和数据规模。如果 K 较小且不需要改变原始数组的顺序，堆是一个高效的选择。如果 K 相对较大或需要改变原始数组的顺序，可以考虑使用快速选择算法。如果对时空复杂度要求较低，且不改变原始数组的顺序，可以先进行排序再取前 K 个元素。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/05/Mysql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/05/Mysql/" class="post-title-link" itemprop="url">Mysql</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-05 14:59:57" itemprop="dateCreated datePublished" datetime="2023-09-05T14:59:57+08:00">2023-09-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-07 16:32:04" itemprop="dateModified" datetime="2023-09-07T16:32:04+08:00">2023-09-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MySQL是如何执行一条SQL"><a href="#MySQL是如何执行一条SQL" class="headerlink" title="MySQL是如何执行一条SQL"></a>MySQL是如何执行一条SQL</h1><p>Server层按顺序执行sql的步骤为：</p>
<ol>
<li>客户端请求-&gt;</li>
<li>连接器（验证用户身份，给予权限） -&gt;</li>
<li>查询缓存（存在缓存则直接返回，不存在则执行后续操作）-&gt;</li>
<li>分析器（对SQL进行词法分析和语法分析操作） -&gt; </li>
<li>优化器（主要对执行的sql优化选择最优的执行方案方法） -&gt; </li>
<li>执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）-&gt;</li>
<li>去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）</li>
</ol>
<p>简单概括：<br>连接器：管理连接、权限验证；<br>查询缓存：命中缓存则直接返回结果；<br>分析器：对SQL进行词法分析、语法分析；（判断查询的SQL字段是否存在也是在这步）<br>优化器：执行计划生成、选择索引；<br>执行器：操作引擎、返回结果；<br>存储引擎：存储数据、提供读写接口。</p>
<p><img src="/Mysql/image-20230905150235233.png" alt="image-20230905150235233"></p>
<img src="/2023/09/05/Mysql/image-20230905150235233.png" class title="This is an test image">

<h2 id="数据库中的主键、超键、候选键、外键"><a href="#数据库中的主键、超键、候选键、外键" class="headerlink" title="数据库中的主键、超键、候选键、外键"></a>数据库中的主键、超键、候选键、外键</h2><ul>
<li>超键：在关系中能唯一标识元组的属性集称为关系模式的超键 </li>
<li>候选键：不含有多余属性的超键称为候选键。也就是在候选键中，若再删除属性，就不是键了！ </li>
<li>主键：用户选作元组标识的一个候选键程序主键 </li>
<li>外键：如果关系模式R中属性K是其它模式的主键，那么k在模式R中称为外键。</li>
</ul>
<p>主键为候选键的子集，候选键为超键的子集，而外键的确定是相对于主键的。</p>
<h2 id="MySQL的内部构造"><a href="#MySQL的内部构造" class="headerlink" title="MySQL的内部构造"></a>MySQL的内部构造</h2><p>可以分为服务层和存储引擎层两部分，其中： 服务层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及 所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如 存储过程、触发器、视图等。 </p>
<p>存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个 存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认的存储引擎。</p>
<h2 id="Drop、Delete与Truncate的共同点和区别"><a href="#Drop、Delete与Truncate的共同点和区别" class="headerlink" title="Drop、Delete与Truncate的共同点和区别"></a>Drop、Delete与Truncate的共同点和区别</h2><p>Drop、Delete、Truncate都表示删除，但是三者有一些差别：<br>Delete用来删除表的全部或者一部分数据行，执行delete之后，用户需要提交(commmit)或者回滚<br>(rollback)来执行删除或者撤销删除，会触发这个表上所有的delete触发器。<br>Truncate删除表中的所有数据，这个操作不能回滚，也不会触发这个表上的触发器，TRUNCATE比<br>delete更快，占用的空间更小。<br>Drop命令从数据库中删除表，所有的数据行，索引和权限也会被删除，所有的DML触发器也不会被触<br>发，这个命令也不能回滚。<br>因此，在不再需要一张表的时候，用Drop；在想删除部分数据行时候，用Delete；在保留表而删除所有<br>数据的时候用Truncate。</p>
<h2 id="MySQL优化"><a href="#MySQL优化" class="headerlink" title="MySQL优化"></a>MySQL优化</h2><p>为搜索字段创建索引<br>避免使用 Select *，列出需要查询的字段<br>垂直分割分表<br>选择正确的存储引擎</p>
<h1 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h1><ul>
<li><strong>未提交读</strong>，事务中发生了修改，即使没有提交，其他事务也是可见的，比如对于一个数A原来50修改为100，但是我还没有提交修改，另一个事务看到这个修改，而这个时候原事务发生了回滚，这时候A还是50，但是另一个事务看到的A是100.<strong>可能会导致脏读、幻读或不可重复读</strong></li>
<li><strong>提交读</strong>，对于一个事务从开始直到提交之前，所做的任何修改是其他事务不可见的，举例就是对于一个数A原来是50，然后提交修改成100，这个时候另一个事务在A提交修改之前，读取的A是50，刚读取完，A就被修改成100，这个时候另一个事务再进行读取发现A就突然变成100了；<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li>
<li><strong>重复读</strong>，就是对一个记录读取多次的记录是相同的，比如对于一个数A读取的话一直是A，前后两次读取的A是一致的；<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong></li>
<li><strong>可串行化读</strong>，通过强制事务串行执行来实现最高的数据隔离性，在并发情况下，和串行化的读取的结果是一致的，没有什么不同，比如不会发生脏读和幻读；<strong>该级别可以防止脏读、不可重复读以及幻读</strong></li>
</ul>
<p>需要注意的是，隔离级别越高，数据的一致性越好，但可能会对并发性能产生负面影响。因此，在应用开发中，需要根据实际情况选择适合的隔离级别</p>
<p>幻影读（Phantom Read）：幻影读指在一个事务中，当多次查询同一范围的数据时，得到的结果集不一致。通常是由于其他事务在这期间对数据做了插入、更新或删除操作，导致当前事务看到了新增或删除的数据行。幻影读是在可重复读隔离级别下的一种问题。</p>
<p>脏读（Dirty Read）：脏读指一个事务读取到了另一个未提交的事务的数据。换句话说，一个事务可以读取到尚未被其他事务确认的数据，这样的读取可能是不正确或不一致的。脏读是在读未提交隔离级别下的一种问题。</p>
<p>不可重复读（Non-Repeatable Read）是数据库中的一种并发问题，它指在一个事务内，多次读取同一数据得到的结果不一致。</p>
<p><strong>不可重复读的重点是修改，幻读的重点在于新增或者删除。</strong></p>
<p><strong>数据库并发</strong>会带来脏读、幻读、丢弃更改、不可重复读这四个常见问题，其中：</p>
<ul>
<li>脏读：在第一个修改事务和读取事务进行的时候，读取事务读到的数据为100，这是修改之后的数据，但是之后该事务满足一致性等特性而做了回滚操作，那么读取事务得到的结果就是脏数据了。</li>
<li>幻读：一般是T1在某个范围内进行修改操作（增加或者删除），而T2读取该范围导致读到的数据是修改之间的了，强调范围。</li>
<li>丢弃修改：两个写事务T1 T2同时对A&#x3D;0进行递增操作，结果T2覆盖T1，导致最终结果是1 而不是2，事务被覆盖</li>
<li>不可重复读：T2 读取一个数据，然后T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</li>
</ul>
<h1 id="MyISAM和InnoDB实现B树索引方式的区别是什么"><a href="#MyISAM和InnoDB实现B树索引方式的区别是什么" class="headerlink" title="MyISAM和InnoDB实现B树索引方式的区别是什么"></a>MyISAM和InnoDB实现B树索引方式的区别是什么</h1><p>InnoDB(<strong>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎</strong>)和MyISAM是MySQL中两种常见的存储引擎</p>
<ol>
<li>事务: InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。 </li>
<li>并发: MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</li>
<li>外键: InnoDB 支持外键。 </li>
<li>备份: InnoDB 支持在线热备份。</li>
<li>崩溃恢复: MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。 </li>
<li>其它特性: MyISAM 支持压缩表和空间数据索引。</li>
</ol>
<ul>
<li>MyISAM，B+Tree叶节点的<strong>data域存放的是数据记录的地址</strong>，在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录，这被称为“<strong>非聚簇索引</strong>”</li>
<li>InnoDB，其<strong>数据文件本身就是索引文件</strong>，相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，<strong>树的节点data域保存了完整的数据记录</strong>，这个索引的key是数据表的主键，因此<strong>InnoDB表数据文件本身就是主索引</strong>，这被称为“<strong>聚簇索引</strong>”或者聚集索引，而其余的索引都作为辅助索引，<strong>辅助索引的data域存储相应记录主键的值而不是地址</strong>，这也是和MyISAM不同的地方。<br>在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。因此，在设计表的时候，不建议使用过长的字段为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</li>
</ul>
<p>聚簇索引就是按照拼音查询，非聚簇索引就是按照偏旁等来进行查询。</p>
<p>我们把这种正文内容本身就是一种按照一定规则排列的目录称为”聚集索引”</p>
<p>我们把这种目录纯粹是目录，正文纯粹是正文的排序方式称为”非聚集索引”。</p>
<p>非聚集索引和聚集索引的区别在于， 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以 查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据。 聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。 </p>
<p>聚集索引（Innodb）的叶节点就是数据节点，而非聚集索引(MyisAM)的叶节点仍然是索引节点，只不 过其包含一个指向对应数据块的指针。</p>
<h2 id="InnoDB、MyISAM的区别"><a href="#InnoDB、MyISAM的区别" class="headerlink" title="InnoDB、MyISAM的区别"></a>InnoDB、MyISAM的区别</h2><p>1）事务：MyISAM不支持，InnoDB支持<br>2）锁级别： MyISAM 表级锁，InnoDB 行级锁及外键约束<br>3）MyISAM存储表的总行数；InnoDB不存储总行数；<br>4）MyISAM采用非聚集索引，B+树叶子存储指向数据文件的指针。InnoDB主键索引采用聚集索引，B+树叶子存储数据<br>适用场景：<br>MyISAM适合： 插入不频繁，查询非常频繁，如果执行大量的SELECT，MyISAM是更好的选择， 没有<br>事务。<br>InnoDB适合： 可靠性要求比较高，或者要求事务； 表更新和查询都相当的频繁， 大量的INSERT或<br>UPDATE</p>
<h2 id="数据库索引采用B-树而不是B树"><a href="#数据库索引采用B-树而不是B树" class="headerlink" title="数据库索引采用B+树而不是B树"></a>数据库索引采用B+树而不是B树</h2><p>主要原因：B+树只要遍历叶子节点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频 繁的，而B树只能中序遍历所有节点，效率太低。</p>
<h2 id="文件索引和数据库索引为什么使用B-树"><a href="#文件索引和数据库索引为什么使用B-树" class="headerlink" title="文件索引和数据库索引为什么使用B+树"></a>文件索引和数据库索引为什么使用B+树</h2><p>文件与数据库都是需要较大的存储，也就是说，它们都不可能全部存储在内存中，故需要存储到磁盘上。而所谓索引，则为了数据的快速定位与查找，那么索引的结构组织要尽量减少查找过程中磁盘I&#x2F;O 的存取次数，因此B+树相比B树更为合适。数据库系统巧妙利用了局部性原理与磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I&#x2F;O就可以完全载入，而红黑树这种结构，高度明显要深的多，并且由于逻辑上很近的节点(父子)物理上可能很远，无法利用局部性。 </p>
<p>最重要的是，B+树还有一个最大的好处：方便扫库。 B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query(范围查询) 非常方便，而B树不支持，这是数据库选用B+树的最主要原因。 B+树查找效率更加稳定，B树有可能在中间节点找到数据，稳定性不够。 B+tree的磁盘读写代价更低：B+tree的内部结点并没有指向关键字具体信息的指针(红色部分)，因此其内部结点相对B 树更小。</p>
<p>如果把所有同一内部结点的关键字存放在同一块盘中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多，相对来说IO读写次数也就降低了； B+tree的查询效率更加稳定：由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引，所以，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相 同，导致每一个数据的查询效率相当；</p>
<h1 id="视图和游标"><a href="#视图和游标" class="headerlink" title="视图和游标"></a>视图和游标</h1><ol>
<li>视图：视图是数据库中的一个虚拟表，它是基于一个或多个实际表的查询结果集。视图可以对表进行过滤、重命名、聚合等操作，以便提供更简洁、易读的数据展示形式。使用视图可以隐藏底层表结构的复杂性，同时还可以提供额外的安全性，因为只有授权的用户能够访问视图。</li>
<li>游标：游标是一种用于在数据库中遍历和操作结果集的数据库对象。它通常与存储过程或触发器等数据库编程功能一起使用。游标可以将一个结果集保存在内存中，并提供对该结果集的逐行访问。通过游标，可以在结果集中移动、检索和修改数据。游标可用于实现对查询结果的精确控制，甚至可以在结果集上进行随机访问。</li>
</ol>
<p>视图主要用于提供简化和安全的数据访问方式，而游标主要用于对结果集进行编程式的遍历和操作。</p>
<h1 id="MySQL中事务回滚机制"><a href="#MySQL中事务回滚机制" class="headerlink" title="MySQL中事务回滚机制"></a>MySQL中事务回滚机制</h1><p>MySQL的事务是指由一组数据库操作语句构成的逻辑处理单元，它们在数据库中原子性地执行，要么同时成功，要么同时失败，具有一致性和持久性的特征</p>
<p><strong>MySQL的事务实现了四个基本属性，简称ACID</strong>：</p>
<ol>
<li>Atomicity（原子性）：事务可以看做是一组不可分割的操作，要么全部执行成功，要么全部执行失败。当任何一个操作失败时，MySQL会自动回滚所有已经执行的操作，保证数据的一致性。如果所有操作都执行成功，MySQL会将它们提交到数据库中，保证数据的持久性。</li>
<li>Consistency（一致性）：在事务执行期间，不会破坏数据库的完整性和约束条件。这意味着只有满足表中所有的约束条件，事务才可以提交成功。如果任何一个约束条件失败，整个事务会被回滚，以保证所有数据的一致性。</li>
<li>Isolation（隔离性）：多个事务同时运行时，他们的修改互不干扰。MySQL通过使用锁机制来实现隔离性，保证了在并发访问时对数据的正确性和完整性。</li>
<li>Durability（持久性）：一旦事务提交，其所做出的修改将永远保存到数据库中，即使出现系统故障也不会丢失。这是通过在提交事务之前将所有相关数据和日志写入磁盘中来实现的。</li>
</ol>
<p>而在 MySQL 中，恢复机制是通过回滚日志（undo log）实现的，所有事务进行的修改都会先记录到这个 回滚日志中，然后在对数据库中的对应行进行写入。 当事务已经被提交之后，就无法再次回滚了。 </p>
<p>回滚日志作用： </p>
<ul>
<li>能够在发生错误或者用户执行 ROLLBACK 时提供回滚相关的信息 </li>
<li>在整个系统发生崩溃、数据库进程直接被杀死后，当用户再次启动数据库进程时，还能够立刻通过查询回滚日志将之前未完成的事务进行回滚，这也就需要<strong>回滚日志必须先于数据持久化到磁盘</strong>上，是我们需要<strong>先写日志后写数据库</strong>的主要原因。</li>
</ul>
<h1 id="数据库悲观锁和乐观锁"><a href="#数据库悲观锁和乐观锁" class="headerlink" title="数据库悲观锁和乐观锁"></a>数据库悲观锁和乐观锁</h1><p><strong>悲观锁，先获取锁，再进行业务操作</strong>，一般就是利用类似 SELECT … FOR UPDATE 这样的语句(它会获取选定的行的排他锁，以确保在事务中其它会话无法修改或删除这些行。这个功能通常在需要读取数据并且希望保持数据一致性的情况下使用)，对数据加锁，避免其他事务意外修改数据。 当数据库执行SELECT … FOR UPDATE时会获取被select中的数据行的行锁，select for update获取的行锁 会在当前事务结束时自动释放，因此必须在事务中使用。 </p>
<p><strong>乐观锁，先进行业务操作，只在最后实际更新数据时进行检查数据是否被更新过</strong>。Java 并发包中的 AtomicFieldUpdater 类似，也是利用 CAS 机制，并不会对数据加锁，而是通过对比数据的时间戳或者版本号，来实现乐观锁需要的版本判断。</p>
<h1 id="MySQL索引主要使用的两种数据结构"><a href="#MySQL索引主要使用的两种数据结构" class="headerlink" title="MySQL索引主要使用的两种数据结构"></a>MySQL索引主要使用的两种数据结构</h1><ul>
<li><p><strong>哈希索引</strong>，对于哈希索引来说，底层的数据结构肯定是哈希表，因此在<strong>绝大多数需求为单条记录查询</strong> 的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引 </p>
</li>
<li><p><strong>BTree索引</strong>，Mysql的BTree索引使用的是B树中的B+Tree，BTREE索引就是一种将索引值按一定的算 法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获 取leaf。 但对于主要的两种存储引擎（MyISAM和InnoDB）的实现方式是不同的</p>
</li>
</ul>
<h1 id="数据库分库和分表"><a href="#数据库分库和分表" class="headerlink" title="数据库分库和分表"></a>数据库分库和分表</h1><p>分库与分表的目的在于，减小数据库的单库单表负担，提高查询性能，缩短查询时间。</p>
<ol>
<li><p>数据库分库（Sharding）： 数据库分库是将一个大型数据库按照一定规则划分为多个较小的数据库实例。每个数据库实例通常被部署在不同的服务器或节点上，并独立处理自己的数据。这样可以将数据库负载分散到多个节点上，有效提高数据库的并发处理能力和可扩展性。</p>
<p>数据库分库的常见划分策略包括：</p>
<ul>
<li>垂直分库：按照业务功能或数据模块将数据库划分为不同的库，例如将用户信息、订单信息、日志信息等分别存储在不同的库中。</li>
<li>水平分库：按照数据记录的某个属性（如用户ID、时间范围等）将数据库划分为多个库，例如按照用户ID的哈希值划分。</li>
</ul>
</li>
<li><p>数据库分表（Sharding）： 数据库分表是将一个大型表按照一定规则拆分为多个较小的表。每个小表通常分散存储在不同的数据库实例中，以平衡数据负载和提高查询性能。每个小表具有相同的表结构，但包含不同的数据。</p>
<p>数据库分表的常见拆分策略包括：</p>
<ul>
<li>垂直分表：按照业务功能或数据模块将表中的列划分到不同的表中，例如将用户信息中的基本信息和详细信息存储在两个表中。</li>
<li>水平分表：按照数据记录的某个属性（如时间范围、地理位置等）将表中的数据划分到多个表中，例如按照订单创建时间将订单表拆分为多个表。</li>
</ul>
<p>在进行数据库分表时，可以使用一些标识来确定数据应该存储在哪个表中，以便后续查询时可以正确定位到目标表。</p>
</li>
</ol>
<h1 id="MySQL四种索引类型"><a href="#MySQL四种索引类型" class="headerlink" title="MySQL四种索引类型"></a>MySQL四种索引类型</h1><ol>
<li>B-Tree索引（默认索引）： B-Tree（B树）索引是MySQL中最常用的索引类型，适用于各种查询条件和数据类型。B-Tree索引以平衡树的结构存储数据，可以快速地定位到满足查询条件的数据行。它对于范围查询、排序和分组等操作效果较好。</li>
<li>哈希索引： 哈希索引使用哈希算法将索引键值映射为特定的桶（bucket）地址，从而实现快速的查找。哈希索引适合于等值查询，但不支持范围查询，也无法利用索引进行排序操作。此外，哈希索引对于重复键值的处理较为复杂。</li>
<li>全文索引（Full-Text Index）： 全文索引主要用于对文本内容进行搜索，例如文章、日志、博客等。它可以高效地实现全文本关键字的模糊匹配，并支持各种自然语言的搜索功能。全文索引适用于包含大量文本的列，如VARCHAR和TEXT类型的字段。</li>
<li>空间索引（Spatial Index）：包括RTREE， 空间索引用于优化地理空间数据的查询，例如基于位置的搜索和距离计算。空间索引支持各种地理数据类型，如点、线、面等，并提供了丰富的查询函数和操作符来处理地理空间数据。空间索引在处理地理信息系统（GIS）和位置服务等应用中广泛使用。</li>
</ol>
<h2 id="建立数据库索引"><a href="#建立数据库索引" class="headerlink" title="建立数据库索引"></a>建立数据库索引</h2><p>在最频繁使用的、用以缩小查询范围的字段,需要排序的字段上建立索引。 </p>
<p>不宜： </p>
<p>1）对于查询中很少涉及的列或者重复值比较多的列 </p>
<p>2）对于一些特殊的数据类型，不宜建立索引，比如文本字段（text）等。</p>
<p><strong>创建索引时需要注意什么</strong></p>
<p><strong>非空字段</strong>：应该指定列为NOT NULL，除非你想存储NULL。在 MySQL 中，含有空值的列很难进行查 询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者 一个空串代替空值； </p>
<p><strong>取值离散大的字段</strong>：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数 查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高； </p>
<p><strong>索引字段越小越好</strong>：数据库的数据存储以页为单位，一页存储的数据越多一次IO操作获取的数据越大效率 越高。 </p>
<p>唯一、不为空、经常被查询的字段 的字段适合建索引</p>
<h2 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h2><p>索引是对数据库表中一列或多列的值进行排序的一种数据结构，也就是说索引是一种数据结 构。数据库在执行一条Sql语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配 条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中通 过二分法等高效率算法一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增 加查询性能。类似新华字典的目录，如果没有目录的话，我们想要查找一个汉字的话，就必 须检索整本字典，而正因为有了目录，我们只要知道我们所要查找的偏旁或者拼音首字母， 就可以快速地定位到我们想要查找汉字的所在页码。</p>
<h2 id="索引使用的注意事项"><a href="#索引使用的注意事项" class="headerlink" title="索引使用的注意事项"></a>索引使用的注意事项</h2><p>不要在列上使用函数，这将导致索引失效而进行全表扫描</p>
<p>尽量避免使用 !&#x3D; 或 not in或 &lt;&gt; 等否定操作符</p>
<ul>
<li>应该尽量避免在 where 子句中使用 !&#x3D; 或 not in 或 &lt;&gt; 操作符，因为这几个操作符都会导致索引失效而进 行全表扫描。尽量避免使用 or 来连接条件 应该尽量避免在 where 子句中使用 or 来连接条件，因为这会导致索引失效而进行全表扫描。</li>
</ul>
<p>多个单列索引并不是最佳选择 MySQL 只能使用一个索引，会从多个索引中选择一个限制最为严格的索引，因此，为多个列创建单列 索引，并不能提高 MySQL 的查询性能。</p>
<ul>
<li>假设，有两个单列索引，分别为 news_year_idx(news_year) 和 news_month_idx(news_month)。现在，有一个场景需要针对资讯的年份和月份进行查询，那么，SQL 语句可以写成：<code>select * from news where news_year = 2017 and news_month = 1</code> 事 实 上 ， MySQL 只 能 使 用 一 个 单 列 索 引 。 为 了 提 高 性 能 ， 可 以 使 用 复 合 索 引 <code>news_year_month_idx(news_year, news_month)</code> 保证 news_year 和 news_month 两个列都被索引覆盖。</li>
</ul>
<p>复合索引的最左前缀原则</p>
<ul>
<li>复合索引遵守“最左前缀”原则，即在<strong>查询条件中使用了复合索引的第一个字段，索引才会被使用</strong>。因 此，在复合索引中索引列的顺序至关重要。如果不是按照索引的最左列开始查找，则无法使用索引。 假设，有一个场景只需要针对资讯的月份进行查询，那么，SQL 语句可以写成：<code>select * from news where news_month = 1</code>	此时，无法使用 <code>news_year_month_idx(news_year, news_month)</code> 索引，因为遵守“最左前缀”原则，在查询 条件中没有使用复合索引的第一个字段，索引是不会被使用的。</li>
</ul>
<p>覆盖索引的好处</p>
<ul>
<li>如果一个索引包含所有需要的查询的字段的值，直接根据索引的查询结果返回数据，而无需读表，能够 极大的提高性能。因此，可以定义一个让索引包含的额外的列，即使这个列对于索引而言是无用的。</li>
</ul>
<p>范围查询对多列查询的影响</p>
<ul>
<li>查询中的某个列有范围查询，则其右边所有列都无法使用索引优化查找。</li>
</ul>
<p>索引不会包含有NULL值的列</p>
<ul>
<li>只要列中包含有 NULL 值都将不会被包含在索引中，复合索引中只要有一列含有 NULL值，那么这一列 对于此复合索引就是无效的。因此，在数据库设计时，除非有一个很特别的原因使用 NULL 值，不然尽量不要让字段的默认值为 NULL。</li>
</ul>
<p>隐式转换的影响</p>
<ul>
<li>当查询条件左右两侧类型不匹配的时候会发生隐式转换，隐式转换带来的影响就是可能导致索引失效而 进行全表扫描。</li>
</ul>
<p>like 语句的索引失效问题</p>
<ul>
<li>like 的方式进行查询，在 like “value%” 可以使用索引，但是对于 like “%value%” 这样的方式，执行全表查询，这在数据量小的表，不存在性能问题，但是对于海量数据，全表扫描是非常可怕的事情。所以，根据业务需求，考虑使用 ElasticSearch 或 Solr 是个不错的方案。<code>SELECT * FROM table WHERE column LIKE &#39;abc%&#39;</code></li>
</ul>
<h2 id="有哪些索引"><a href="#有哪些索引" class="headerlink" title="有哪些索引"></a>有哪些索引</h2><ol>
<li>普通索引：仅加速查询</li>
<li>唯一索引：加速查询 + 列值唯一（可以有null）</li>
<li>主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个</li>
<li>组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</li>
<li>全文索引：对文本的内容进行分词，进行搜索</li>
<li>索引合并：使用多个单列索引组合搜索</li>
<li>覆盖索引：select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖</li>
<li>聚簇索引：表数据是和主键一起存储的，主键索引的叶结点存储行数据(包含了主键值)，二级索引的叶结点存储行的主键值。使用的是B+树作为索引的存储结构，非叶子节点都是索引关键字，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录(数据内容）</li>
</ol>
<h1 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h1><p>第一范式<br>在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。 所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。简而言之，<strong>第一范式就是无重复的列</strong>。</p>
<p>第二范式<br>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为<strong>主关键字或主键、主码</strong>。 第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是<strong>非主属性非部分依赖于主关键字</strong>。</p>
<p>第三范式<br>满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。<br>简而言之，第三范式就是<strong>属性不依赖于其它非主属性</strong>。</p>
<p>第一范式（1NF）：字段不可分；<br> 第二范式（2NF）：有主键，非主键字段依赖主键；<br> 第三范式（3NF）：非主键字段不能相互依赖。<br>解释：<br> 1NF：原子性。 字段不可再分,否则就不是关系数据库;；<br> 2NF：唯一性 。一个表只说明一个事物；<br> 3NF：每列都与主键有直接关系，不存在传递依赖。</p>
<h1 id="MySQL中CHAR和VARCHAR"><a href="#MySQL中CHAR和VARCHAR" class="headerlink" title="MySQL中CHAR和VARCHAR"></a>MySQL中CHAR和VARCHAR</h1><ul>
<li>char的长度是不可变的，用空格填充到指定长度大小，而varchar的长度是可变的。</li>
<li>char的存取速度还是要比varchar要快得多</li>
<li>char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。</li>
</ul>
<h1 id="数据库表锁和行锁"><a href="#数据库表锁和行锁" class="headerlink" title="数据库表锁和行锁"></a>数据库表锁和行锁</h1><h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><p>不会出现死锁，发生锁冲突几率高，并发低。<br>MyISAM在执行查询语句（select）前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给涉及的表加写锁。</p>
<p>MySQL的表级锁有两种模式：<strong>表共享读锁和表独占写锁</strong>。</p>
<p>读锁会阻塞写，写锁会阻塞读和写</p>
<ul>
<li>对MyISAM表的读操作，不会阻塞其它进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作。</li>
<li>对MyISAM表的写操作，会阻塞其它进程对同一表的读和写操作，只有当写锁释放后，才会执行其它进程的读写操作。</li>
</ul>
<p>MyISAM不适合做写为主表的引擎，因为写锁后，其它线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。</p>
<h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>会出现死锁，发生锁冲突几率低，并发高。 在MySQL的InnoDB引擎支持行锁，与Oracle不同，MySQL的行锁是通过索引加载的，也就是说，行锁 是加在索引响应的行上的，要是对应的SQL语句没有走索引，则会全表扫描，行锁则无法实现，取而代 之的是表锁，此时其它事务无法对当前表进行更新或插入操作。</p>
<p>行锁的实现需要注意：</p>
<ul>
<li>行锁必须有索引才能实现，否则会自动锁全表，那么就不是行锁了。 </li>
<li>两个事务不能锁同一个索引。 </li>
<li>insert，delete，update在事务中都会自动默认加上排它锁。</li>
</ul>
<p>行锁的适用场景： A用户消费，service层先查询该用户的账户余额，若余额足够，则进行后续的扣款操作；这种情况查询 的时候应该对该记录进行加锁。 否则，B用户在A用户查询后消费前先一步将A用户账号上的钱转走，而此时A用户已经进行了用户余额 是否足够的判断，则可能会出现余额已经不足但却扣款成功的情况。 为了避免此情况，需要在A用户操作该记录的时候进行for update加锁</p>
<h1 id="内连接、自连接、外连接（左、右、全）、交叉连接"><a href="#内连接、自连接、外连接（左、右、全）、交叉连接" class="headerlink" title="内连接、自连接、外连接（左、右、全）、交叉连接"></a>内连接、自连接、外连接（左、右、全）、交叉连接</h1><p>内连接：只有两个元素表相匹配的才能在结果集中显示。<br>外连接： 左外连接: 左边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。右外连接:右边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。<br>全外连接：连接的表中不匹配的数据全部会显示出来。<br>交叉连接： 笛卡尔效应，显示的结果是链接表数的乘积。结果集包括了 <code>table1</code> 中的每一行和 <code>table2</code> 中的每一行的所有可能组合。注意，交叉连接可能会生成非常大的结果集，通常需要与其他查询条件一起使用来缩小结果集大小，避免无意义的数据计算和传输。</p>
<h1 id="数据库高并发解决方案"><a href="#数据库高并发解决方案" class="headerlink" title="数据库高并发解决方案"></a>数据库高并发解决方案</h1><ul>
<li>在web服务框架中加入缓存。在服务器与数据库层之间加入缓存层，将高频访问的数据存入缓存中，减少数据库的读取负担。</li>
<li>增加数据库索引，进而提高查询速度。（不过索引太多会导致速度变慢，并且数据库的写入会导致索引的更新，也会导致速度变慢）</li>
<li>主从读写分离，让主服务器负责写，从服务器负责读。</li>
<li>将数据库进行拆分，使得数据库的表尽可能小，提高查询的速度。</li>
<li>使用分布式架构，分散计算压力。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%EF%BC%883%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%EF%BC%883%EF%BC%89/" class="post-title-link" itemprop="url">数据结构-（3）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-09-03 21:39:11 / 修改时间：22:05:26" itemprop="dateCreated datePublished" datetime="2023-09-03T21:39:11+08:00">2023-09-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="企业链表"><a href="#企业链表" class="headerlink" title="企业链表"></a>企业链表</h1><p>传统链表包含数据域和指针域，就是我们从课本上学到的那一种。</p>
<p> 而企业链表把 “挂钩” 放在了结构体的首地址，挂钩指向挂钩，从而把表了连接起来。 </p>
<p>linux呢，则是把 ”挂钩“ 放在了底部，那么串的时候就需要自己计算偏移量。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%EF%BC%883%EF%BC%89/image-20230903214441893.png" alt="image-20230903214441893"></p>
<img src="/2023/09/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%EF%BC%883%EF%BC%89/image-20230903214441893.png" class title="This is an test image">

<p>首先 ，按照传统的方式去写节点的结构体是这样子的，包含数据域和指针域。在企业链表中，我们定义的时候，仅仅保留指针域，相当于这只是 一个 ”挂钩“</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef struct LINKNODE&#123;</span><br><span class="line">	struct LINKNODE* next;</span><br><span class="line">&#125; LinkNode;</span><br></pre></td></tr></table></figure>

<p>怎么样去使用它呢？ 我们先定义一个自己平时使用的数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct MyData &#123;</span><br><span class="line">	LinkNode node;</span><br><span class="line">	char name[64];</span><br><span class="line">	int age;</span><br><span class="line">&#125;Mydata;</span><br></pre></td></tr></table></figure>

<p>如此一来，我们的每个结构体都包含这个 ”挂钩“ ，而这个 ”挂钩“ 呢，可以指向 ”挂钩“ 类型的数据。</p>
<p>然后呢，我们的 ”挂钩“ 在我们自定义 结构体的首地址。 因此，我们只需要把我们的自定义 结构体<code>Mydata*</code>类型的数据转换成 <code>LinKNode*</code>的数据类型，就可以将各个节点串起来了，具体操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mydata datal;</span><br><span class="line">LinKNode* node = (LinkNode*) &amp;(datal);</span><br></pre></td></tr></table></figure>

<p>这样的类型转换数据并不会丢失，仅仅只是LinKNode类型的指针访问不到我们的Mydata结构体中的其它数据而已，而当我们需要对Mydata中的数据进行操作时，很简单，把类型转换成Mydata指 针类型即可。</p>
<hr>
<p>最小生成树（Minimum Spanning Tree，简称MST）是在无向连通图中的一棵生成树，它包含了图中的所有顶点，并且具有最小的总权值。生成树是图的一个子图，它是一颗树，连接了图中所有的顶点，但没有形成环。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/02/%E5%AF%B9%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9A%84%E8%A1%A5%E5%85%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/02/%E5%AF%B9%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9A%84%E8%A1%A5%E5%85%85/" class="post-title-link" itemprop="url">对面试题的补充</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-09-02 15:43:44 / 修改时间：15:50:02" itemprop="dateCreated datePublished" datetime="2023-09-02T15:43:44+08:00">2023-09-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="网络地址和广播地址"><a href="#网络地址和广播地址" class="headerlink" title="网络地址和广播地址"></a>网络地址和广播地址</h2><p>192.168.1.53&#x2F;27 的相应子网掩码是11111111.11111111.11111111.11100000，所有可用的主机数为主机号所剩下的5位掩码中算出</p>
<p>8位主机号减少网络号借去的3位，所剩下5位。即n&#x3D;8-m&#x3D;5。即最多可以容纳的主机数位 32，可用的主机数为 30</p>
<p>减去2是因为用于表示网络和广播地址，最多可以容纳的主机与可用主机数不是一回事。</p>
<p>先把IP地址转换成二进制，然后与二进制的子网掩码进行与运算，得到的就是网络地址。</p>
<p>广播地址是在网络地址的基础上，将网络号右边的表示IP地址的主机部分的二进制全部填上1，再将得到的二进制转化为十进制就可以得到广播地址。</p>
<p><img src="/%E5%AF%B9%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9A%84%E8%A1%A5%E5%85%85/image-20230902154859245.png" alt="image-20230902154859245"></p>
<img src="/2023/09/02/%E5%AF%B9%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9A%84%E8%A1%A5%E5%85%85/image-20230902154859245.png" class title="This is an test image">

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/" class="post-title-link" itemprop="url">数据结构-2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-02 10:52:11" itemprop="dateCreated datePublished" datetime="2023-09-02T10:52:11+08:00">2023-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-17 11:01:01" itemprop="dateModified" datetime="2023-09-17T11:01:01+08:00">2023-09-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="左旋字符串"><a href="#左旋字符串" class="headerlink" title="左旋字符串"></a>左旋字符串</h1><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字 符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结 果”cdefgab”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">char* reverseLeftWords(char* s, int n)&#123;</span><br><span class="line"> 	int i=0;</span><br><span class="line"> 	int len=strlen(s);</span><br><span class="line"> 	char *t=malloc(sizeof(char)*(len+1));</span><br><span class="line"> 	while(i&lt;len)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		t[i++]=s[(n+(i))%len];</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	t[len]=&#x27;\0&#x27;;</span><br><span class="line"> 	return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="reverse反转解法"><a href="#reverse反转解法" class="headerlink" title="reverse反转解法"></a>reverse反转解法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"> 	string reverseLeftWords(string s, int n) &#123;</span><br><span class="line"> 		reverse(s.begin(),s.begin()+n);</span><br><span class="line"> 		reverse(s.begin()+n,s.end());</span><br><span class="line"> 		reverse(s.begin(),s.end());</span><br><span class="line"> 		return s;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h1><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<p>示例 1： 限制：0 &lt;&#x3D; 节点个数 &lt;&#x3D; 1000 </p>
<h2 id="前序递归解法"><a href="#前序递归解法" class="headerlink" title="前序递归解法"></a>前序递归解法</h2><p>使用递归（前序遍历），让每一个节点的左右孩子互换位置 需要注意的是，这种方法必须要检查传入的二叉树是否合法，即该树不为空，否则无法执行。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode* mirrorTree(struct TreeNode* root)&#123;</span><br><span class="line"> 	if(root)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		struct TreeNode* temp=root-&gt;left;</span><br><span class="line"> 		root-&gt;left=root-&gt;right;</span><br><span class="line"> 		root-&gt;right=temp;</span><br><span class="line"> 		mirrorTree(root-&gt;left);</span><br><span class="line"> 		mirrorTree(root-&gt;right);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode* mirrorTree(struct TreeNode* root)&#123;</span><br><span class="line"> 	if(root)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		struct TreeNode *temp=root-&gt;left;</span><br><span class="line"> 		root-&gt;left=mirrorTree(root-&gt;right);</span><br><span class="line"> 		root-&gt;right=mirrorTree(temp);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码简洁，而且可读性强</p>
<h2 id="C-版"><a href="#C-版" class="headerlink" title="C++版"></a>C++版</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"> 	TreeNode* mirrorTree(TreeNode* root) &#123;</span><br><span class="line"> 		if(root)</span><br><span class="line"> 		&#123;</span><br><span class="line"> 			TreeNode *temp=root-&gt;left;</span><br><span class="line"> 			root-&gt;left=mirrorTree(root-&gt;right);</span><br><span class="line"> 			root-&gt;right=mirrorTree(temp);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		return root;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="哈希查找"><a href="#哈希查找" class="headerlink" title="哈希查找"></a>哈希查找</h1><p>哈希查找算法又称散列查找算法，是一种借助哈希表（散列表）查找目标元素的方法，查找效率最高时对应的时间复杂度为 O(1)。</p>
<p>使用数组构建哈希表，最大的好处在于：可以直接将数组下标当作已存储元素的索引，不再需要为每个元素手动配置索引，极大得简化了构建哈希表的难度。</p>
<p>我们知道，在数组中查找一个元素，除非提前知晓它存储位置处的下标，否则只能遍历整个数组。哈希表的解决方案是：各个元素并不从数组的起始位置依次存储，它们的存储位置由专门设计的函数计算得出，我们通常将这样的函数称为哈希函数。</p>
<p>哈希函数类似于数学中的一次函数，我们给它传递一个元素，它反馈给我们一个结果值，这个值就是该元素对应的索引，也就是存储到哈希表中的位置。</p>
<p>举个例子，将 {20, 30, 50, 70, 80} 存储到哈希表中，我们设计的哈希函数为 y&#x3D;x&#x2F;10，最终各个元素的存储位置如下图所示：</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/image-20230902155837486.png" alt="image-20230902155837486"></p>
<img src="/2023/09/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/image-20230902155837486.png" class title="This is an test image">

<p>假设我们想查找元素 50，只需将它带入 y&#x3D;x&#x2F;10 这个哈希函数中，计算出它对应的索引值为 5，直接可以在数组中找到它。借助哈希函数，我们提高了数组中数据的查找效率，这就是哈希表存储结构。</p>
<p>构建哈希表时，哈希函数的设计至关重要。假设将 {5, 20, 30, 50, 55} 存储到哈希表中，哈希函数是 y&#x3D;x%10，各个元素在数组中的存储位置如下图所示：</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/image-20230902155932936.png" alt="image-20230902155932936"></p>
<img src="/2023/09/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/image-20230902155932936.png" class title="This is an test image">

<p>可以看到，5 和 55 以及 20、30 和 50 对应的索引值是相同的，它们的存储位置发生了冲突，我们习惯称为哈希冲突或者哈希碰撞。设计一个好的哈希函数，可以降低哈希冲突的出现次数。哈希表提供了很多解决哈希冲突的方案，比如线性探测法、再哈希法、链地址法等。</p>
<p>本节我们使用线性探测法解决哈希冲突，解决方法是：当元素的索引值（存储位置）发生冲突时，从当前位置向后查找，直至找到一个空闲位置，作为冲突元素的存储位置。仍以图 3 中的哈希表为例，使用线性探测法解决哈希冲突的过程是：</p>
<ul>
<li>元素 5 最先存储到数组中下标为 5 的位置；</li>
<li>元素 20 最先存储到数组中下标为 0 的位置；</li>
<li>元素 30 的存储位置为 0，和 20 冲突，根据线性探测法，从下标为 0 的位置向后查找，下标为 1 的存储位置空闲，用来存储 30；</li>
<li>元素 50 的存储位置为 0，和 20 冲突，根据线性探测法，从下标为 0 的位置向后查找，下标为 2 的存储位置空闲，用来存储 50；</li>
<li>元素 55 的存储位置为 5，和 5 冲突，根据线性探测法，从下标为 5 的位置向后查找，下标为 6 的存储位置空闲，用来存储 55。</li>
</ul>
<p>借助线性探测法，最终 {5, 20, 30, 50, 55} 存储到哈希表中的状态为：</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/image-20230902160001791.png" alt="image-20230902160001791"></p>
<img src="/2023/09/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/image-20230902160001791.png" class title="This is an test image">

<h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><p>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p>
<p>在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。</p>
<p>通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1。</p>
<p>若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。树的根结点权值为其左、右子树根结点权值之和，相对于15，9，5是构造的，不参与权值计数</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/image-20230902162158683.png" alt="image-20230902162158683"></p>
<img src="/2023/09/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/image-20230902162158683.png" class title="This is an test image">

<p>树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL。</p>
<p>如上图：数的带权路径长度为：</p>
<p>WPL &#x3D; (2+3) * 3 + 4 * 2 + 6 * 1 &#x3D; 29</p>
<h1 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h1><p>若设二叉树的深度为h，除第 h 层外，其它各层 (1~h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。</p>
<p>完全二叉树是由<strong>满二叉树</strong>而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。满二叉树是一种特殊类型的二叉树，其中每个节点都具有两个子节点，除了叶子节点。换句话说，如果一个二叉树的所有非叶子节点都有两个子节点，那么它就是一个满二叉树。</p>
<p>一棵二叉树至多只有最下面的一层上的结点的度数可以小于2，并且最下层上的结点都集中在该层最左边的若干位置上，而在最后一层上，右边的若干结点缺失的二叉树，则此二叉树成为完全二叉树。</p>
<p>有n个节点的完全二叉树的深度为？</p>
<p>h(n) &#x3D; (log2n)+1计算以 2 为底的对数值，即 log2n</p>
<p>深度为 k 的满二叉树的节点个数：</p>
<p>总节点个数 &#x3D; 2^k - 1</p>
<p>一个完全二叉树的节点为n，则该二叉树的叶子节点为多少？</p>
<ul>
<li><strong>当n为奇数时 n0&#x3D; (n+1)&#x2F;2</strong></li>
<li><strong>当n为偶数</strong> <strong>n0&#x3D; n&#x2F;2</strong></li>
</ul>
<p>对任何一棵二叉树，叶子结点(度为0)的个数比度为2的结点数多一个,则no&#x3D;n2＋1</p>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>假设给定一个组无序数列{100,5,3,11,6,8,7}，带着问题，我们对其进行堆排序操作进行分步操作说明。</p>
<h2 id="创建最大堆"><a href="#创建最大堆" class="headerlink" title="创建最大堆"></a>创建最大堆</h2><p>首先我们将数组我们将数组从上至下按顺序排列，转换成二叉树：一个无序堆。每一个三角关系都是一个堆，上面是父节点，下面两个分叉是子节点，两个子节点俗称左孩子、右孩子；</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/image-20230902171921919.png" alt="image-20230902171921919"></p>
<img src="/2023/09/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/image-20230902171921919.png" class title="This is an test image">

<p>转换成无序堆之后，我们要努力让这个无序堆变成最大堆(或是最小堆)，即每个堆里都实现父节点的值都大于任何一个子节点的值</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/image-20230902171947417.png" alt="image-20230902171947417"></p>
<img src="/2023/09/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/image-20230902171947417.png" class title="This is an test image">

<p>从最后一个堆开始，即左下角那个没有右孩子的那个堆开始；首先对比左右孩子，由于这个堆没有右孩子，所以只能用左孩子，左孩子的值比父节点的值小所以不需要交换。如果发生交换，要检测子节点是否为其他堆的父节点，如果是，递归进行同样的操作。</p>
<p>第二次对比红色三角形内的堆，取较大的子节点，右孩子8胜出，和父节点比较，右孩子8大于父节点3，升级做父节点，与3交换位置，3的位置没有子节点，这个堆建成最大堆。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/image-20230902172011780.png" alt="image-20230902172011780"></p>
<img src="/2023/09/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/image-20230902172011780.png" class title="This is an test image">

<p>对黄色三角形内堆进行排序，过程和上面一样，最终是右孩子33升为父节点，被交换的右孩子下面也没有子节点，所以直接结束对比。</p>
<p>最顶部绿色的堆，堆顶100比左右孩子都大，所以不用交换，至此最大堆创建完成</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/image-20230902172042297.png" alt="image-20230902172042297"></p>
<img src="/2023/09/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/image-20230902172042297.png" class title="This is an test image">

<p>堆排序 （heapsort）— O(n log n)非稳定排序,空间复杂度O(1)</p>
<p>按照数组顺序，当前节点i，它的parent&#x3D;(i-1)&#x2F;2，左子节点2i+1，右子节点2i+2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">void heapify(vector&lt;int&gt; &amp;nums, int n, int i) // 对有一定顺序的堆，</span><br><span class="line">// 当前第i个结点取根左右的最大值（这个操作称heapfiy）</span><br><span class="line">&#123;</span><br><span class="line">	if(i&gt;=n)</span><br><span class="line">		return;</span><br><span class="line">	// 计算左右子节点的下标 left=2*i+1 right=2*i+2 parent=(i-1)/2</span><br><span class="line">    int l = i * 2 + 1, r = i * 2 + 2;</span><br><span class="line">    int max = i;</span><br><span class="line">    if (l &lt; n &amp;&amp; nums[l] &gt; nums[max])</span><br><span class="line">        max = l;</span><br><span class="line">    if (r &lt; n &amp;&amp; nums[r] &gt; nums[max])</span><br><span class="line">        max = r;</span><br><span class="line">    if (max != i)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(nums[max], nums[i]);</span><br><span class="line">        heapify(nums, n, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void heapify_build(vector&lt;int&gt; &amp;nums, int n) // 对无顺序的数组建立大根堆，从树的倒数第二层第一个结点开始，</span><br><span class="line">// 对每个结点进行heapify操作，然后向上走</span><br><span class="line">&#123;</span><br><span class="line">	// 初次构建堆，i要从最后一个非叶子节点开始，所以是(n-1-1)/2，0这个位置要加等号</span><br><span class="line">    int temp = (n - 2) / 2;</span><br><span class="line">    for (int i = temp; i &gt;= 0; i--)</span><br><span class="line">        heapify(nums, n, i);</span><br><span class="line">    for (int i = 0; i &lt; nums.size(); i++)</span><br><span class="line">        cout &lt;&lt; nums[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void heapify_sort(vector&lt;int&gt; &amp;nums, int n) // 建立大根堆之后，每次交换最后一个结点和根节点（最大值），堆排序</span><br><span class="line">// 对交换后的根节点继续进行heapify（此时堆的最后一位是最大值，因此不用管他，n变为n-1）</span><br><span class="line">&#123;</span><br><span class="line">    heapify_build(nums, n);</span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(nums.front(), nums[n - i - 1]);//把最大的交换到最后，然后下一步再找最大的左右子节点里面最大的</span><br><span class="line">        heapify(nums, n - i - 1, 0);//最后打印nums就是从小到大的顺序</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最<br>大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void bubbleSort(vector&lt;int&gt;&amp; a, int n) &#123;//使用引用（&amp;）可以避免进行值的拷贝</span><br><span class="line"> 	for (auto i = 0; i &lt; n; ++i) &#123;//auto根据右侧的赋值表达式自动推导出变量类型</span><br><span class="line"> 		for (int j = 0; j &lt; n - i - 1; ++j) &#123;</span><br><span class="line"> 			if (a[j] &gt; a[j + 1])</span><br><span class="line"> 			swap(a[j], a[j + 1]);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度 o(n^2) ，空间 o 1， 原地算法，稳定</strong></p>
<p>假如从开始的第一对到结尾的最后一对，相邻的元素之间都没有发生交换的操作，这意味着右边的元素 总是大于等于左边的元素，此时的数组已经是有序的了，我们无需再对剩余的元素重复比较下去了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void bubbleSort2(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int len = nums.size();</span><br><span class="line">    bool flag = false;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; len; ++i) &#123;</span><br><span class="line">        flag = false;</span><br><span class="line">        </span><br><span class="line">        for (int j = 0; j &lt; len - 1 - i; ++j) &#123;</span><br><span class="line">            if (nums[j] &gt; nums[j + 1]) &#123; </span><br><span class="line">                flag = true;</span><br><span class="line">                swap(nums[j], nums[j + 1]); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (!flag)////说明没有交换，则表明[0,len-i-1]已经是有序的了</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述两个冒泡排序（包括优化版本），均存在一定问题： 1、两种冒泡排序（包括优化版本）都是循环了n次，虽然不影响结果的正确性，但对于n个元素的冒泡 排序躺数， n - 1躺更符合规范理解一些； 2、对于冒泡排序优化版本中，if（!flag）break；这个语句，我觉得有一些疏漏。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void bubbleSort(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line"> 	int n = nums.size();</span><br><span class="line"> 	bool flag = false;</span><br><span class="line"> 	for (int i = 0; i &lt; n - 1; ++i) &#123;//i = 0 起，循环了n - 1趟，更符合规范理解</span><br><span class="line"> 	//for (int i = 0; i &lt; n; ++i) &#123;//i = 0 起，循环了n 趟，不影响结果</span><br><span class="line"> 		flag = false;</span><br><span class="line"> 		for (int j = 0; j &lt; n - 1 - i; ++j) &#123;</span><br><span class="line"> 			if (nums[j] &gt; nums[j + 1]) &#123;</span><br><span class="line"> 			//某一趟排序中，只要发生一次元素交换，flag就从false变为了true</span><br><span class="line"> 			//也即表示这一趟排序还不能确定所剩待排序列是否已经有序，应继续下一趟循环</span><br><span class="line"> 				swap(nums[j], nums[j + 1]);</span><br><span class="line"> 				flag = true;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	//但若某一趟中一次元素交换都没有，即依然为flag = false</span><br><span class="line"> 	//那么表明所剩待排序列已经有序</span><br><span class="line"> 	//不必再进行趟数比较，外层循环应该结束，即此时if (!flag) break; 跳出循环</span><br><span class="line"> 	/* if (flag) &#123; break; &#125; */</span><br><span class="line"> 	if (!flag) &#123; break; &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p><strong>时间复杂度：O(n^2)，空间O（1），非稳定排序，原地排序</strong></p>
<p>选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个 元素不用选择了，因为只剩下它一个最大的元 素了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void selectionSort(vector&lt;int&gt;&amp; a, int n) &#123;</span><br><span class="line"> 	int minIndex;</span><br><span class="line"> 	for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line"> 		minIndex = i;</span><br><span class="line"> 		for (int j = i + 1; j &lt; n; ++j) &#123;</span><br><span class="line"> 			if (a[j] &lt; a[minIndex]) minIndex = j;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		swap(a[i], a[minIndex]); </span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。 当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开 始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直 到找到它该插入的位置。 如果碰见一个和插入元素相 等的，那么插入元素把想插入的元素放在相等元素的后面。</p>
<p>所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是 <strong>稳定的</strong>。</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5<br><strong>时间复杂度 on^2 空间 o1，稳定排序，原地排序</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void insertionSort(vector&lt;int&gt;&amp; a, int n) &#123;//&#123; 9,1,5,6,2,3 &#125;</span><br><span class="line"> 	for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line"> 		if (a[i] &lt; a[i - 1]) &#123; //若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入</span><br><span class="line"> 			int j = i - 1;</span><br><span class="line"> 			int x = a[i]; //复制为哨兵，即存储待排序元素</span><br><span class="line"> 			//a[i] = a[i - 1]; //先后移一个元素，可以不要这一句，跟循环里面的功能重复了</span><br><span class="line"> 			while (j &gt;= 0 &amp;&amp; x &lt; a[j]) &#123; //查找在有序表的插入位置,还必须要保证j是&gt;=0的因为a[j]要合法</span><br><span class="line"> 				a[j + 1] = a[j];</span><br><span class="line"> 				j--; //元素后移</span><br><span class="line"> 			&#125;</span><br><span class="line"> 			a[j + 1] = x; //插入到正确位置</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		</span><br><span class="line"> 		print(a, n, i); //打印每趟排序的结果</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码实现了插入排序算法，可以对给定数组进行排序。如果你传入的数组已经包含了所有需要排序的元素，那么你可以直接调用这段代码进行排序，不需要再进行插入操作。</p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序 （quicksort）— O(n log n)，非稳定排序</p>
<p>算法思想<br>1、选取第一个数为基准<br>2、将比基准小的数交换到前面，比基准大的数交换到后面<br>3、对左右区间重复第二步，直到各区间只有一个数</p>
<p>我们从数组中选择一个元素，我们把这个元素称之为中轴元素吧，然后把数组中所有小于中轴元素的元素放在其左边，所有大于或等于中轴元素的元素放在其右边，显然，此时中轴元素所处的位置的是有序 的。也就是说，我们无需再移动中轴元素的位置。 </p>
<p>从中轴元素那里开始把大的数组切割成两个小的数组(两个数组都不包含中轴元素)，接着我们通过递归 的方式，让中轴元素左边的数组和右边的数组也重复同样的操作，直到数组的大小为1，此时每个元素 都处于有序的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// quick函数实现</span><br><span class="line">void quick_sort(int *arr, int start, int end)</span><br><span class="line">&#123;</span><br><span class="line">    int i = start;</span><br><span class="line">    int j = end;</span><br><span class="line">    int temp = arr[start]; // 默认将数组第一个元素作为基准值</span><br><span class="line">    if (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        while (i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            // 从end向start筛选比temp更小的数</span><br><span class="line">            while (i &lt; j &amp;&amp; arr[j] &gt;= temp)</span><br><span class="line">            &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &lt; j)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[i] = arr[j]; // 把这个数放到基准值的左边</span><br><span class="line">            &#125;</span><br><span class="line">            // 从start向end筛选比temp更大的数</span><br><span class="line">            while (i &lt; j &amp;&amp; arr[i] &lt; temp)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &lt; j)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[j] = arr[i]; // 把这个数放到基准值的右边</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = temp; // 将基准值放到正确位置</span><br><span class="line"></span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">        quick_sort(arr, start, i - 1);</span><br><span class="line">        quick_sort(arr, i + 1, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>希尔排序的思想是采用插入排序的方法，先让数组中任意间隔为 h 的元素有序，刚开始 h 的大小可以是 h &#x3D; n &#x2F; 2,接着让 h &#x3D; n &#x2F; 4，让 h 一直缩小，当 h &#x3D; 1 时，也就是此时数组中任意间隔为1的元素有序，此时 的数组就是有序的了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void shellSortCore(vector&lt;int&gt; &amp;nums, int gap, int i)</span><br><span class="line">&#123;</span><br><span class="line">    int inserted = nums[i];</span><br><span class="line">    int j;</span><br><span class="line">    // 插入的时候按组进行插入</span><br><span class="line">    for (j = i - gap; j &gt;= 0 &amp;&amp; inserted &lt; nums[j]; j -= gap)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[j + gap] = nums[j];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[j + gap] = inserted;</span><br><span class="line">&#125;</span><br><span class="line">void shellSort(vector&lt;int&gt; &amp;nums)</span><br><span class="line">&#123;</span><br><span class="line">    int len = nums.size();</span><br><span class="line">    // 进行分组，最开始的时候，gap为数组长度一半</span><br><span class="line">    for (int gap = len / 2; gap &gt; 0; gap /= 2)</span><br><span class="line">    &#123;</span><br><span class="line">        // 对各个分组进行插入分组</span><br><span class="line">        for (int i = gap; i &lt; len; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            // 将nums[i]插入到所在分组正确的位置上</span><br><span class="line">            shellSortCore(nums, gap, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (auto a : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序 （merge sort）— O(n log n)稳定排序，空间复杂度O(n)</p>
<p>将一个大的无序数组有序，我们可以把大的数组分成两个，然后对这两个数组分别进行排序，之后在把 这两个数组合并成一个有序的数组。由于两个小的数组都是有序的，所以在合并的时候是很快的。 </p>
<p>通过递归的方式将大的数组一直分割，直到数组的大小为 1，此时只有一个元素，那么该数组就是有序 的了，之后再把两个数组大小为1的合并成一个大小为2的，再把两个大小为2的合并成4的 … 直到全部 小的数组合并起来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">void mergeSortCore(vector&lt;int&gt; &amp;nums, vector&lt;int&gt; &amp;copy, int begin, int end)</span><br><span class="line">&#123;</span><br><span class="line">    if (begin &gt;= end)</span><br><span class="line">        return;</span><br><span class="line">    int mid = begin + (end - begin) / 2;</span><br><span class="line">    int low1 = begin, high1 = mid, low2 = mid + 1, high2 = end;</span><br><span class="line">    mergeSortCore(copy, nums, low1, high1); // 这里减少了copy向nums的赋值部分，千万注意不要把copy 和 nums赋值反了</span><br><span class="line">    mergeSortCore(copy, nums, low2, high2);</span><br><span class="line">    int copyIndex = low1;</span><br><span class="line">    while (low1 &lt;= high1 &amp;&amp; low2 &lt;= high2)//将两个子数组中的元素按顺序进行了比较和合并，并放入了 copy 数组</span><br><span class="line">    &#123;//第一个子数组中还有剩余的元素，而第二个子数组已经全部比较完毕。</span><br><span class="line">	//第二个子数组中还有剩余的元素，而第一个子数组已经全部比较完毕。</span><br><span class="line">	//接下来的两个 while 循环用于处理这种情况，将剩余的元素放入 copy 数组</span><br><span class="line">        copy[copyIndex++] = nums[low1] &lt; nums[low2] ? nums[low1++] : nums[low2++];</span><br><span class="line">    &#125;</span><br><span class="line">    while (low1 &lt;= high1)</span><br><span class="line">    &#123;</span><br><span class="line">        copy[copyIndex++] = nums[low1++];</span><br><span class="line">    &#125;</span><br><span class="line">    while (low2 &lt;= high2)</span><br><span class="line">    &#123;</span><br><span class="line">        copy[copyIndex++] = nums[low2++];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; begin &lt;&lt; &quot; &quot; &lt;&lt; end &lt;&lt; endl;</span><br><span class="line">    for (auto a : copy)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void mergeSort(vector&lt;int&gt; nums)</span><br><span class="line">&#123;</span><br><span class="line">    for (auto a : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; copyNums(nums); // 这里要借助一个一模一样的数组的</span><br><span class="line">    mergeSortCore(nums, copyNums, 0, nums.size() - 1);</span><br><span class="line">    nums.assign(copyNums.begin(), copyNums.end()); // 到最后copy数组是排序好的，记得要赋值一下</span><br><span class="line"></span><br><span class="line">    for (auto a : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>计数排序统计小于等于该元素值的元素的个数i，于是该元素就放在目标数组的索引i位（i≥0）。</p>
<ul>
<li>计数排序基于一个假设，待排序数列的所有数均为整数，且出现在（0，k）的区间之内。</li>
<li>如果 k（待排数组的最大值） 过大则会引起较大的空间复杂度，一般是用来排序 0 到 100 之间的数字的最好的算法，但是它不适合按字母顺序排序人名。</li>
<li>计数排序不是比较排序，排序的速度快于任何比较排序算法。</li>
</ul>
<p>算法思想：</p>
<ol>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项；</li>
<li>对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）；</li>
<li>向填充目标数组：将每个元素 i 放在新数组的第 C[i] 项，每放一个元素就将 C[i] 减去 1；</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 计数排序</span><br><span class="line">void CountSort(vector&lt;int&gt; &amp;vecRaw, vector&lt;int&gt; &amp;vecObj)</span><br><span class="line">&#123;</span><br><span class="line">    // 确保待排序容器非空</span><br><span class="line">    if (vecRaw.size() == 0)</span><br><span class="line">        return;</span><br><span class="line">    // 使用 vecRaw 的最大值 + 1 作为计数容器 countVec 的大小</span><br><span class="line">    int vecCountLength = (*max_element(begin(vecRaw), end(vecRaw))) + 1;</span><br><span class="line">    vector&lt;int&gt; vecCount(vecCountLength, 0);</span><br><span class="line">    // 统计每个键值出现的次数</span><br><span class="line">    for (int i = 0; i &lt; vecRaw.size(); i++)</span><br><span class="line">        vecCount[vecRaw[i]]++;</span><br><span class="line"></span><br><span class="line">    // 后面的键值出现的位置为前面所有键值出现的次数之和</span><br><span class="line">    for (int i = 1; i &lt; vecCountLength; i++)</span><br><span class="line">        vecCount[i] += vecCount[i - 1];</span><br><span class="line">    // 将键值放到目标位置</span><br><span class="line">    for (int i = vecRaw.size(); i &gt; 0; i--) // 此处逆序是为了保持相同键值的稳定性</span><br><span class="line">        vecObj[--vecCount[vecRaw[i - 1]]] = vecRaw[i - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有逆序累加操作（即 <code>vecCount[i] += vecCount[i - 1]</code>），则按照键值从小到大的顺序进行累加，最终得到的是每个键值在排序后的结果数组中的起始位置索引。这将会导致在相同键值的情况下，它们的相对顺序被打乱，即不再保持稳定性。</p>
<h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><p>桶排序的核心:使数组的下标具有意义</p>
<p>将值为i的元素放入i号桶，最后依次把桶里的元素倒出来。<br>算法思想：</p>
<ol>
<li>设置一个定量的数组当作空桶子。</li>
<li>寻访序列，并且把项目一个一个放到对应的桶子去。</li>
<li>对每个不是空的桶子进行排序。</li>
<li>从不是空的桶子里把项目再放回原来的序列中。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">int a[11]; // 下标代表考试的等级int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n, tmp;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; tmp;</span><br><span class="line">        a[tmp]++;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= 10; i++) // i代表等级i</span><br><span class="line">        if (a[i])</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>一种多关键字的排序算法，可用桶排序实现。<br>算法思想：</p>
<ol>
<li>取得数组中的最大数，并取得位数；</li>
<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">int maxbit(int data[], int n) // 辅助函数，求数据的最大位数</span><br><span class="line">&#123;</span><br><span class="line">    int maxData = data[0]; ///&lt; 最大数</span><br><span class="line">    /// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。</span><br><span class="line">    for (int i = 1; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if (maxData &lt; data[i])</span><br><span class="line">            maxData = data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int d = 1;</span><br><span class="line">    int p = 10;</span><br><span class="line">    while (maxData &gt;= p)</span><br><span class="line">    &#123;</span><br><span class="line">        // p *= 10; // Maybe overflow</span><br><span class="line">        maxData /= 10;</span><br><span class="line">        ++d;</span><br><span class="line">    &#125;</span><br><span class="line">    return d;</span><br><span class="line">    /* int d = 1; //保存最大的位数</span><br><span class="line">     int p = 10;</span><br><span class="line">     for(int i = 0; i &lt; n; ++i)</span><br><span class="line">     &#123;</span><br><span class="line">    	 while(data[i] &gt;= p)</span><br><span class="line">     	&#123;</span><br><span class="line">    		 p *= 10;</span><br><span class="line">     		 ++d;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return d;*/</span><br><span class="line">&#125;</span><br><span class="line">void radixsort(int data[], int n) // 基数排序</span><br><span class="line">&#123;</span><br><span class="line">    int d = maxbit(data, n);</span><br><span class="line">    int *tmp = new int[n];</span><br><span class="line">    int *count = new int[10]; // 计数器</span><br><span class="line">    int i, j, k;</span><br><span class="line">    int radix = 1;</span><br><span class="line">    for (i = 1; i &lt;= d; i++) // 进行d次排序</span><br><span class="line">    &#123;</span><br><span class="line">        for (j = 0; j &lt; 10; j++)</span><br><span class="line">            count[j] = 0; // 每次分配前清空计数器</span><br><span class="line">        for (j = 0; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            k = (data[j] / radix) % 10; // 统计每个桶中的记录数</span><br><span class="line">            count[k]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for (j = 1; j &lt; 10; j++)</span><br><span class="line">            count[j] = count[j - 1] + count[j]; // 将tmp中的位置依次分配给每个桶</span><br><span class="line">        for (j = n - 1; j &gt;= 0; j--)            // 将所有桶中记录依次收集到tmp中</span><br><span class="line">        &#123;</span><br><span class="line">            k = (data[j] / radix) % 10;//k是元素最大位所代表的count位置</span><br><span class="line">            tmp[count[k] - 1] = data[j];//count[k] - 1代表第多少个位置的元素，有序的</span><br><span class="line">            count[k]--;//最大位一样个数的元素减一</span><br><span class="line">        &#125;</span><br><span class="line">        for (j = 0; j &lt; n; j++) // 将临时数组的内容复制到data中</span><br><span class="line">            data[j] = tmp[j];</span><br><span class="line">        radix = radix * 10;//可以看出i++代表的是位数，即最大数是两位那么d是2</span><br><span class="line">    &#125;</span><br><span class="line">    delete[] tmp;</span><br><span class="line">    delete[] count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/29/Redis%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/29/Redis%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">Redis基本操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-29 20:40:43" itemprop="dateCreated datePublished" datetime="2023-08-29T20:40:43+08:00">2023-08-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-02 15:37:30" itemprop="dateModified" datetime="2023-09-02T15:37:30+08:00">2023-09-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>启动redis:redis-cli</strong></p>
<h1 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h1><p>redis默认有16个数据库，编号为0~15，且默认访问0号数据库</p>
<table>
<thead>
<tr>
<th>select 数据库编号</th>
<th>选择指定数据库</th>
</tr>
</thead>
<tbody><tr>
<td>dbsize</td>
<td>获取当前数据库键值对数量</td>
</tr>
<tr>
<td>flushdb</td>
<td>清空当前数据库</td>
</tr>
<tr>
<td>flushall</td>
<td>清空所有数据库</td>
</tr>
<tr>
<td>save</td>
<td>将数据保存至磁盘</td>
</tr>
<tr>
<td>bgsave</td>
<td>将数据异步保存至磁盘(后台:Background)</td>
</tr>
<tr>
<td>lastsave</td>
<td>获取最后一次成功保存的unix时间</td>
</tr>
</tbody></table>
<h2 id="通用数据操作"><a href="#通用数据操作" class="headerlink" title="通用数据操作"></a>通用数据操作</h2><p>操作范围为当前数据库</p>
<table>
<thead>
<tr>
<th>keys 格式</th>
<th>查看符合指定格式的key，*为通配符</th>
</tr>
</thead>
<tbody><tr>
<td>exists key1 [key2 …]</td>
<td>查看是否存在一至多个指定的key</td>
</tr>
<tr>
<td>type key</td>
<td>按key查看value的数据类型</td>
</tr>
<tr>
<td>del key1 [key2 …]</td>
<td>按key删除一至多个键值对</td>
</tr>
<tr>
<td>rename key1 key1</td>
<td>重命名key1，如果key2已经存在，其值会被覆盖</td>
</tr>
<tr>
<td>renamenx key1 key2</td>
<td>key2不存在时重命名key1</td>
</tr>
<tr>
<td>move key 数据库编号</td>
<td>按key将一个键值对移动到指定数据库</td>
</tr>
<tr>
<td>copy key1 key2</td>
<td>将key1的值拷贝给key2</td>
</tr>
</tbody></table>
<p>Redis 持久化拥有以下三种方式：</p>
<ul>
<li><strong>快照方式</strong>（RDB, Redis DataBase）将某一个时刻的内存数据，以二进制的方式写入磁盘；</li>
<li><strong>文件追加方式</strong>（AOF, Append Only File），记录所有的操作命令，并以文本的形式追加到文件中；</li>
<li><strong>混合持久化方式</strong>，Redis 4.0 之后新增的方式，混合持久化是结合了 RDB 和 AOF 的优点，在写入的时候，先把当前的数据以 RDB 的形式写入文件的开头，再将后续的操作命令以 AOF 的格式存入文件，这样既能保证 Redis 重启时的速度，又能简单数据丢失的风险</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/28/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="肖汇林">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肖汇林的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/28/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-7/" class="post-title-link" itemprop="url">muduo库使用示例_7</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-28 11:22:54" itemprop="dateCreated datePublished" datetime="2023-08-28T11:22:54+08:00">2023-08-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-29 16:13:57" itemprop="dateModified" datetime="2023-08-29T16:13:57+08:00">2023-08-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="高效率多线程异步日志"><a href="#高效率多线程异步日志" class="headerlink" title="高效率多线程异步日志"></a>高效率多线程异步日志</h1><p>线程安全，即多个线程可以并发写日志，两个线程的日志消息不会出现交织。</p>
<ul>
<li>​	用一个全局的mutex保护lO		前者造成全部线程抢占一个锁，就变成串行了</li>
<li>​	每个线程单独写一个日志文件	后者有可能让业务线程阻塞在写磁盘操作上。</li>
<li>​	muduo库的方法是用<strong>一个</strong>背景线程负责收集日志消息，并写入日志文件，其他业务线程只管往这个“日志线程”发送日志消息，这称为“异步日志”。不一定是实时的，但是不影响并发的写日志。非阻塞日志<ul>
<li>使得前端的业务线程与后端的日志线程能够并发，并且，写日志不太频繁，提高了效率。</li>
</ul>
</li>
</ul>
<p><img src="/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-7/image-20230828114049679.png" alt="image-20230828114049679"></p>
<img src="/2023/08/28/muduo%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-7/image-20230828114049679.png" class title="This is an test image">

<h2 id="AsyncLogging-h"><a href="#AsyncLogging-h" class="headerlink" title="AsyncLogging.h"></a>AsyncLogging.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MUDUO_BASE_ASYNCLOGGING_H</span><br><span class="line">#define MUDUO_BASE_ASYNCLOGGING_H</span><br><span class="line"></span><br><span class="line">#include &quot;muduo/base/BlockingQueue.h&quot;</span><br><span class="line">#include &quot;muduo/base/BoundedBlockingQueue.h&quot;</span><br><span class="line">#include &quot;muduo/base/CountDownLatch.h&quot;</span><br><span class="line">#include &quot;muduo/base/Mutex.h&quot;</span><br><span class="line">#include &quot;muduo/base/Thread.h&quot;</span><br><span class="line">#include &quot;muduo/base/LogStream.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;atomic&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">//异步日志</span><br><span class="line">namespace muduo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">class AsyncLogging : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line"></span><br><span class="line">  AsyncLogging(const string&amp; basename,</span><br><span class="line">               off_t rollSize,</span><br><span class="line">               int flushInterval = 3);</span><br><span class="line"></span><br><span class="line">  ~AsyncLogging()</span><br><span class="line">  &#123;</span><br><span class="line">    if (running_)</span><br><span class="line">    &#123;</span><br><span class="line">      stop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //供前端生产者线程调用（日志数据写到缓冲区)</span><br><span class="line">  void append(const char* logline, int len);</span><br><span class="line"></span><br><span class="line">  void start()</span><br><span class="line">  &#123;</span><br><span class="line">    running_ = true;</span><br><span class="line">    thread_.start();//日志线程启动，调用threadFunc</span><br><span class="line">    latch_.wait();//等待线程启动</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void stop() NO_THREAD_SAFETY_ANALYSIS</span><br><span class="line">  &#123;</span><br><span class="line">    running_ = false;</span><br><span class="line">    cond_.notify();</span><br><span class="line">    thread_.join();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  //供后端消费者线程调用（将数据写到日志文件)</span><br><span class="line">  void threadFunc();</span><br><span class="line">  //实例化 FixedBuffer 类模板，并指定模板参数的具体值</span><br><span class="line">  typedef muduo::detail::FixedBuffer&lt;muduo::detail::kLargeBuffer&gt; Buffer;</span><br><span class="line">  typedef std::vector&lt;std::unique_ptr&lt;Buffer&gt;&gt; BufferVector;</span><br><span class="line">  typedef BufferVector::value_type BufferPtr;//可理解为Buffer的智能指针，能管理BufFer的生存期</span><br><span class="line">                                             //BufferVector::value_type 表示 BufferVector 中的元素类型，也就是 std::unique_ptr&lt;Buffer&gt;类型,真备移动语义</span><br><span class="line">                                            //(两个unique_ptr不能指向一个对象，不能进行复制操作只能进行移动操作</span><br><span class="line"> </span><br><span class="line">  const int flushInterval_;//超时时间，在flushInterval_秒内，缓冲区没写满，仍将缓冲区中的数据写到文件中</span><br><span class="line">  std::atomic&lt;bool&gt; running_;</span><br><span class="line">  const string basename_;</span><br><span class="line">  const off_t rollSize_;//日志文件的滚动大小</span><br><span class="line">  muduo::Thread thread_;</span><br><span class="line">  muduo::CountDownLatch latch_;//用于等待线程启动</span><br><span class="line">  muduo::MutexLock mutex_;</span><br><span class="line">  muduo::Condition cond_ GUARDED_BY(mutex_);//条件变量与互斥量配合使用</span><br><span class="line">  BufferPtr currentBuffer_ GUARDED_BY(mutex_);//当前缓冲区，智能指针</span><br><span class="line">  BufferPtr nextBuffer_ GUARDED_BY(mutex_);//预备缓冲区</span><br><span class="line">  BufferVector buffers_ GUARDED_BY(mutex_);//待写入文件的已填满的缓冲区</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace muduo</span><br><span class="line"></span><br><span class="line">#endif  // MUDUO_BASE_ASYNCLOGGING_H</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="AsyncLogging-cc"><a href="#AsyncLogging-cc" class="headerlink" title="AsyncLogging.cc"></a>AsyncLogging.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/AsyncLogging.h&quot;</span><br><span class="line">#include &quot;muduo/base/LogFile.h&quot;</span><br><span class="line">#include &quot;muduo/base/Timestamp.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace muduo;</span><br><span class="line"></span><br><span class="line">AsyncLogging::AsyncLogging(const string&amp; basename,</span><br><span class="line">                           off_t rollSize,</span><br><span class="line">                           int flushInterval)</span><br><span class="line">  : flushInterval_(flushInterval),</span><br><span class="line">    running_(false),</span><br><span class="line">    basename_(basename),</span><br><span class="line">    rollSize_(rollSize),</span><br><span class="line">    thread_(std::bind(&amp;AsyncLogging::threadFunc, this), &quot;Logging&quot;),</span><br><span class="line">    latch_(1),</span><br><span class="line">    mutex_(),</span><br><span class="line">    cond_(mutex_),</span><br><span class="line">    currentBuffer_(new Buffer),</span><br><span class="line">    nextBuffer_(new Buffer),</span><br><span class="line">    buffers_()</span><br><span class="line">&#123;</span><br><span class="line">  currentBuffer_-&gt;bzero();//清空缓冲区内容</span><br><span class="line">  nextBuffer_-&gt;bzero();</span><br><span class="line">  buffers_.reserve(16);//预留</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AsyncLogging::append(const char* logline, int len)</span><br><span class="line">&#123;</span><br><span class="line">  muduo::MutexLockGuard lock(mutex_);</span><br><span class="line">  if (currentBuffer_-&gt;avail() &gt; len)//当前可用空间</span><br><span class="line">  &#123;</span><br><span class="line">    //当前缓冲区未满，将数据追加到末尾</span><br><span class="line">    currentBuffer_-&gt;append(logline, len);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    //当前缓冲区已满，将当前缓冲区添加到待写入文件的已填满的缓冲区列表</span><br><span class="line">    buffers_.push_back(std::move(currentBuffer_));//currentBuffer_就没指向区域</span><br><span class="line">    //将当前缓冲区设置为预备缓冲区</span><br><span class="line">    if (nextBuffer_)</span><br><span class="line">    &#123;</span><br><span class="line">      currentBuffer_ = std::move(nextBuffer_);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      //这种情况，极少发生，前端写入速度太快，一下子把两块缓冲区都写完</span><br><span class="line">      //那么，只好分配一玦新的缓冲</span><br><span class="line">      currentBuffer_.reset(new Buffer); // Rarely happens</span><br><span class="line">    &#125;</span><br><span class="line">    currentBuffer_-&gt;append(logline, len);</span><br><span class="line">    cond_.notify();//通知后端开始写入日志</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AsyncLogging::threadFunc()</span><br><span class="line">&#123;</span><br><span class="line">  assert(running_ == true);</span><br><span class="line">  latch_.countDown();</span><br><span class="line">  LogFile output(basename_, rollSize_, false);</span><br><span class="line">  BufferPtr newBuffer1(new Buffer);</span><br><span class="line">  BufferPtr newBuffer2(new Buffer);</span><br><span class="line">  newBuffer1-&gt;bzero();</span><br><span class="line">  newBuffer2-&gt;bzero();</span><br><span class="line">  BufferVector buffersToWrite;</span><br><span class="line">  buffersToWrite.reserve(16);</span><br><span class="line">  while (running_)</span><br><span class="line">  &#123;</span><br><span class="line">    assert(newBuffer1 &amp;&amp; newBuffer1-&gt;length() == 0);</span><br><span class="line">    assert(newBuffer2 &amp;&amp; newBuffer2-&gt;length() == 0);</span><br><span class="line">    assert(buffersToWrite.empty());</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      muduo::MutexLockGuard lock(mutex_);</span><br><span class="line">      if (buffers_.empty())  // unusual usage!(注意，这里是一个非常规用法,一般是while)</span><br><span class="line">      &#123;</span><br><span class="line">        //不能解决虚假唤醒spurious wakeup</span><br><span class="line">        //Linux网络编程、spurious wakeup可能是遇到了信号(signal)</span><br><span class="line">        //在多处理器中，pthread_cond_signal可能唤醒多个等待条件变量的线程。</span><br><span class="line">        cond_.waitForSeconds(flushInterval_);//等待前端写满了一个或者多个buffer ,或者一个超时时间到来</span><br><span class="line">      &#125;</span><br><span class="line">      buffers_.push_back(std::move(currentBuffer_));//将当前缓冲区移入buffers</span><br><span class="line">      currentBuffer_ = std::move(newBuffer1);//将空闲的newBuffer1置为当前缓冲区</span><br><span class="line">      buffersToWrite.swap(buffers_);//buffers_与buffersTowrite交换，这样后面的代码可以在临界区之外安全地访问buffersToWrite</span><br><span class="line">      if (!nextBuffer_)</span><br><span class="line">      &#123;</span><br><span class="line">        nextBuffer_ = std::move(newBuffer2);//确保前端始终有一个预备buffer可供调配，</span><br><span class="line">        //减少前端临界区分配内存的概率,缩短前端临界区长度。</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //buffersToWrite.swap这样可以保证前端和后端可以并发 </span><br><span class="line">    assert(!buffersToWrite.empty());</span><br><span class="line">    //消息堆积</span><br><span class="line">    //前端陷入死循环，拼命发送日志消息，超过后端的处理能力,这就是典型的生产速度</span><br><span class="line">    //超过消费速度问题,会造成数据在内存中堆积，严重时引发性能问题或程序崩溃(分配内存失败)</span><br><span class="line">    if (buffersToWrite.size() &gt; 25)</span><br><span class="line">    &#123;</span><br><span class="line">      char buf[256];</span><br><span class="line">      snprintf(buf, sizeof buf, &quot;Dropped log messages at %s, %zd larger buffers\n&quot;,</span><br><span class="line">               Timestamp::now().toFormattedString().c_str(),</span><br><span class="line">               buffersToWrite.size()-2);</span><br><span class="line">      fputs(buf, stderr);</span><br><span class="line">      output.append(buf, static_cast&lt;int&gt;(strlen(buf)));</span><br><span class="line">      buffersToWrite.erase(buffersToWrite.begin()+2, buffersToWrite.end());//丢掉多余日志,以腾出内存,仅保留两块缓冲区</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (const auto&amp; buffer : buffersToWrite)</span><br><span class="line">    &#123;</span><br><span class="line">      // FIXME: use unbuffered stdio FILE ? or use ::writev ?</span><br><span class="line">      output.append(buffer-&gt;data(), buffer-&gt;length());//写入日志，是一个logfile</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (buffersToWrite.size() &gt; 2)</span><br><span class="line">    &#123;</span><br><span class="line">      // drop non-bzero-ed buffers, avoid trashing</span><br><span class="line">      buffersToWrite.resize(2);//buffersToWrite 向量会丢弃多余的元素，从而保持最多只有两个元素</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!newBuffer1)</span><br><span class="line">    &#123;</span><br><span class="line">      assert(!buffersToWrite.empty());</span><br><span class="line">      newBuffer1 = std::move(buffersToWrite.back());//将 buffersToWrite 向量中最后一个元素的所有权转移到 newBuffer1</span><br><span class="line">      buffersToWrite.pop_back();//删除 buffersToWrite 向量中的最后一个元素，即移除已经被移动的缓冲区指针</span><br><span class="line">      newBuffer1-&gt;reset();//重置，只需要移动指针，覆盖就行了</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!newBuffer2)</span><br><span class="line">    &#123;</span><br><span class="line">      assert(!buffersToWrite.empty());</span><br><span class="line">      newBuffer2 = std::move(buffersToWrite.back());</span><br><span class="line">      buffersToWrite.pop_back();</span><br><span class="line">      newBuffer2-&gt;reset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buffersToWrite.clear();</span><br><span class="line">    output.flush();</span><br><span class="line">  &#125;</span><br><span class="line">  output.flush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>void <strong>AsyncLogging</strong>::<strong>threadFunc</strong>()中</p>
<p>在给出的代码中，<code>currentBuffer_</code> 和 <code>nextBuffer_</code> 是智能指针对象，它们的类型是 <code>std::unique_ptr&lt;Buffer&gt;</code>。这些智能指针用于管理 <code>Buffer</code> 对象的生命周期。现在我们来解释 <code>currentBuffer_-&gt;append(logline, len)</code> 和 <code>currentBuffer_.reset(new Buffer)</code> 中箭头运算符 <code>-&gt;</code> 和点运算符 <code>.</code> 的用法。</p>
<ol>
<li>箭头运算符 <code>-&gt;</code> 当智能指针类型是指向类或结构体的指针时，我们使用箭头运算符 <code>-&gt;</code> 来访问其指向对象的成员。正如前面提到的，<code>currentBuffer_</code> 和 <code>nextBuffer_</code> 是智能指针对象，类型为 <code>std::unique_ptr&lt;Buffer&gt;</code>，它们指向 <code>Buffer</code> 类的对象。 因此，在 <code>currentBuffer_-&gt;append(logline, len)</code> 中，<code>currentBuffer_</code> 是一个指向 <code>Buffer</code> 对象的智能指针，通过箭头运算符 <code>-&gt;</code> 可以调用 <code>Buffer</code> 类的 <code>append</code> 成员函数。</li>
<li>点运算符 <code>.</code> 当智能指针类型是实际对象（而不是指向对象的指针）时，我们使用点运算符 <code>.</code> 来访问成员。例如，<code>currentBuffer_.reset(new Buffer)</code> 中的 <code>currentBuffer_</code> 是一个 <code>std::unique_ptr&lt;Buffer&gt;</code> 的对象，我们通过使用点运算符来操作这个智能指针对象，调用 智能指针的<code>reset</code> 成员函数，并将其指向一个新的 <code>Buffer</code> 对象。</li>
</ol>
<p>总结一下，箭头运算符 <code>-&gt;</code> 用于访问智能指针所指向对象的成员函数和成员变量，而点运算符 <code>.</code> 则用于操作智能指针对象本身的成员函数。这样可以方便地在代码中使用智能指针来管理对象的生命周期，并访问其成员。</p>
<h2 id="AsyncLogging-test-cc"><a href="#AsyncLogging-test-cc" class="headerlink" title="AsyncLogging_test.cc"></a>AsyncLogging_test.cc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;muduo/base/AsyncLogging.h&quot;</span><br><span class="line">#include &quot;muduo/base/Logging.h&quot;</span><br><span class="line">#include &quot;muduo/base/Timestamp.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/resource.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">off_t kRollSize = 500*1000*1000;</span><br><span class="line"></span><br><span class="line">muduo::AsyncLogging* g_asyncLog = NULL;</span><br><span class="line"></span><br><span class="line">void asyncOutput(const char* msg, int len)</span><br><span class="line">&#123;</span><br><span class="line">  g_asyncLog-&gt;append(msg, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bench(bool longLog)</span><br><span class="line">&#123;                                       //void Logger::setOutput(OutputFunc out)</span><br><span class="line">  muduo::Logger::setOutput(asyncOutput);//typedef void (*OutputFunc)(const char* msg, int len);</span><br><span class="line">  //通过这个函数写入日志</span><br><span class="line">  int cnt = 0;</span><br><span class="line">  const int kBatch = 1000;</span><br><span class="line">  muduo::string empty = &quot; &quot;;</span><br><span class="line">  muduo::string longStr(3000, &#x27;X&#x27;);</span><br><span class="line">  longStr += &quot; &quot;;</span><br><span class="line"></span><br><span class="line">  for (int t = 0; t &lt; 30; ++t)</span><br><span class="line">  &#123;</span><br><span class="line">    muduo::Timestamp start = muduo::Timestamp::now();</span><br><span class="line">    for (int i = 0; i &lt; kBatch; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      //因为setOutput(asyncOutput)，所以添加到日志文件当中</span><br><span class="line">      LOG_INFO &lt;&lt; &quot;Hello 0123456789&quot; &lt;&lt; &quot; abcdefghijklmnopqrstuvwxyz &quot;</span><br><span class="line">               &lt;&lt; (longLog ? longStr : empty)</span><br><span class="line">               &lt;&lt; cnt;</span><br><span class="line">      ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    muduo::Timestamp end = muduo::Timestamp::now();</span><br><span class="line">    printf(&quot;%f\n&quot;, timeDifference(end, start)*1000000/kBatch);</span><br><span class="line">    //下面两行注释掉，会加剧消息堆积，日志文件变小</span><br><span class="line">    struct timespec ts = &#123; 0, 500*1000*1000 &#125;;</span><br><span class="line">    nanosleep(&amp;ts, NULL);</span><br><span class="line">    //通过 nanosleep 函数进行延时，暂停程序执行一段时间，具体时间由 ts 中的值决定。这里的延时时间为 500 毫秒（即 50010001000 纳秒）</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;//设置分配最大虚拟内存大小为 2GB</span><br><span class="line">  &#123;//这个设置的目的是为了限制程序所能使用的虚拟内存大小，避免程序占用过多的虚拟内存导致系统资源耗尽或程序异常运行</span><br><span class="line">    // set max virtual memory to 2GB.</span><br><span class="line">    size_t kOneGB = 1000*1024*1024;</span><br><span class="line">    rlimit rl = &#123; 2*kOneGB, 2*kOneGB &#125;;</span><br><span class="line">    setrlimit(RLIMIT_AS, &amp;rl);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printf(&quot;pid = %d\n&quot;, getpid());</span><br><span class="line"></span><br><span class="line">  char name[256] = &#123; &#x27;\0&#x27; &#125;;</span><br><span class="line">  strncpy(name, argv[0], sizeof name - 1);</span><br><span class="line">  muduo::AsyncLogging log(::basename(name), kRollSize);//滚动大小为500M</span><br><span class="line">  log.start();</span><br><span class="line">  g_asyncLog = &amp;log;</span><br><span class="line"></span><br><span class="line">  bool longLog = argc &gt; 1;//根据命令行参数设置是否使用长日志</span><br><span class="line">  bench(longLog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="MySQL-配置"><a href="#MySQL-配置" class="headerlink" title="MySQL 配置"></a>MySQL 配置</h1><ol>
<li><p>在 MySQL 控制台中，您可以执行各种 MySQL 相关的操作和命令。例如，您可以创建数据库、创建用户、授权等。下面是一些常用的命令示例：</p>
<ul>
<li><p>创建数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE database_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建用户并授权：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#x27;username&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;password&#x27;;</span><br><span class="line">//将 &#x27;username&#x27; 替换为您要创建的用户名，并将 &#x27;password&#x27; 替换为用户的密码。</span><br><span class="line">GRANT ALL PRIVILEGES ON database_name.* TO &#x27;username&#x27;@&#x27;localhost&#x27;;</span><br><span class="line">//将 &#x27;database_name&#x27; 替换为您要授权的数据库名称。</span><br><span class="line">//或者，如果您只想为用户授予特定的权限（例如 SELECT、INSERT 等），可以使用以下格式：</span><br><span class="line">//GRANT SELECT, INSERT ON database_name.* TO &#x27;username&#x27;@&#x27;localhost&#x27;;</span><br><span class="line">//如果需要远程访问，可以将 &#x27;localhost&#x27; 替换为允许访问的 IP 地址或主机名，或者使用 &#x27;%&#x27; 表示允许从任何主机进行访问。例如：</span><br><span class="line">//GRANT ALL PRIVILEGES ON database_name.* TO &#x27;username&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;password&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示数据库列表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES;</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示数据表列表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//刷新权限以使更改生效</span><br><span class="line">SHOW TABLES FROM database_name;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>当您完成 MySQL 的配置和操作后，可以使用以下命令退出 MySQL 控制台：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>Linux mysql表名称大小写敏感</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">肖汇林</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">76</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">肖汇林</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
